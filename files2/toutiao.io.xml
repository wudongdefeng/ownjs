<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83cf33b9907c1f808259901464cdbc5e</guid>
<title>如何防止水印被恶意删除或者隐藏？</title>
<link>https://toutiao.io/k/9dgqp5a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entryContent&quot;&gt;&amp;#13;
        &lt;p&gt;继上篇 &lt;strong&gt;&lt;a href=&quot;http://i-fanr.com/2022/07/29/vue3-watermark/&quot;&gt;Vue3 实现网页背景水印功能&lt;/a&gt;&lt;/strong&gt; 我们了解了常见的网页水印功能是如何实现的，懂原理的都知道水印是通过在网页中添加代码绘制 DOM 元素覆盖在原有的网页上而来的，一旦你打开浏览器中的元素审查，可以通过删除元素或者在元素的样式上操作属性值，就可以用来临时屏蔽水印。&lt;/p&gt;
&lt;p&gt;为了防止作弊，我们可以利用接口 &lt;code&gt;MutationObserver&lt;/code&gt; 对 &lt;strong&gt;DOM&lt;/strong&gt; 元素进行监听。如果你对监听的元素进行样式属性的设置，或者对监听元素的子元素进行删除，都能通过 &lt;code&gt;MutationObserver&lt;/code&gt; 的回调函数进行捕获，然后再针对你的修改操作进行复原。这样可以有效防止临时操作网页元素来隐藏水印。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;MutationObserver 接口提供了监视对 DOM 树所做更改的能力。它被设计为旧的 Mutation Events 功能的替代品，该功能是 DOM3 Events 规范的一部分。&lt;/p&gt;&lt;/blockquote&gt;
&lt;pre&gt;// 选择需要观察变动的节点&amp;#13;
const targetNode = document.getElementById(&#x27;some-id&#x27;);&amp;#13;
&amp;#13;
// 观察器的配置（需要观察什么变动）&amp;#13;
const config = { attributes: true, childList: true, subtree: true };&amp;#13;
&amp;#13;
// 当观察到变动时执行的回调函数&amp;#13;
const callback = function(mutationsList, observer) {&amp;#13;
    // Use traditional &#x27;for loops&#x27; for IE 11&amp;#13;
    for(let mutation of mutationsList) {&amp;#13;
        if (mutation.type === &#x27;childList&#x27;) {&amp;#13;
            console.log(&#x27;A child node has been added or removed.&#x27;);&amp;#13;
        }&amp;#13;
        else if (mutation.type === &#x27;attributes&#x27;) {&amp;#13;
            console.log(&#x27;The &#x27; + mutation.attributeName + &#x27; attribute was modified.&#x27;);&amp;#13;
        }&amp;#13;
    }&amp;#13;
};&amp;#13;
&amp;#13;
// 创建一个观察器实例并传入回调函数&amp;#13;
const observer = new MutationObserver(callback);&amp;#13;
&amp;#13;
// 以上述配置开始观察目标节点&amp;#13;
observer.observe(targetNode, config);&amp;#13;
&amp;#13;
// 之后，可停止观察&amp;#13;
observer.disconnect();&lt;/pre&gt;
&lt;p&gt;了解如何使用之后，我们对上篇封装的增加水印功能的 &lt;code&gt;hooks&lt;/code&gt; 进行优化，添加一个防删除的方法 &lt;code&gt;antiDeletion&lt;/code&gt;，里面对水印元素和它的父级也就是 &lt;code&gt;body&lt;/code&gt;进行了监听。&lt;/p&gt;
&lt;p&gt;对父级元素进行监听，是为了捕获对它的删除操作，&lt;code&gt;mutation&lt;/code&gt; 的类型为 &lt;code&gt;childList&lt;/code&gt;，当删除水印元素的时候，我们通过回调参数 &lt;code&gt;removedNodes&lt;/code&gt; 拿到删除元素的内容后再往它的父节点动态插入水印元素，相当于未删除成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i-fanr.oss-cn-hangzhou.aliyuncs.com/1660875008793-fcf84daf-75a7-4199-8027-360183b66171.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后还需要防止用户对水印元素进行样式属性的设置，比如 &lt;code&gt;display: none;&lt;/code&gt;隐藏元素内容。这个时候我们添加对水印 DIV 层的监听，通过对 &lt;code&gt;mutation&lt;/code&gt; 类型为&lt;code&gt;attributes&lt;/code&gt; 的判断，然后强制给可能导致水印显示变化的样式进行复原操作。&lt;/p&gt;
&lt;pre&gt;const observers = [];&amp;#13;
function antiDeletion() {&amp;#13;
    const targetNode = unref(watermarkEl);&amp;#13;
    const parentNode = unref(appendEl);&amp;#13;
    const config = {&amp;#13;
      childList: true,&amp;#13;
      attributes: true,&amp;#13;
      attributeOldValue: true,&amp;#13;
      characterData: true,&amp;#13;
      characterDataOldValue: true&amp;#13;
    };&amp;#13;
    observers[0] = new MutationObserver((mutationList, _observer) =&amp;gt; {&amp;#13;
      for (const mutation of mutationList) {&amp;#13;
        const type = mutation.type;&amp;#13;
        switch (type) {&amp;#13;
          case &quot;childList&quot;:&amp;#13;
            console.log(&quot;childList&quot;, mutation);&amp;#13;
            if (mutation.removedNodes.length &amp;gt; 0) {&amp;#13;
              parentNode.appendChild(mutation.removedNodes[0]);&amp;#13;
            }&amp;#13;
            break;&amp;#13;
          default:&amp;#13;
            break;&amp;#13;
        }&amp;#13;
      }&amp;#13;
    });&amp;#13;
    observers[0].observe(parentNode, { childList: true });&amp;#13;
    observers[1] = new MutationObserver((mutationList, _observer) =&amp;gt; {&amp;#13;
      for (const mutation of mutationList) {&amp;#13;
        const type = mutation.type;&amp;#13;
        switch (type) {&amp;#13;
          case &quot;attributes&quot;:&amp;#13;
            console.log(&quot;attributes&quot;, mutation);&amp;#13;
            if (mutation.attributeName === &quot;style&quot;) {&amp;#13;
              targetNode.style.display = &quot;block&quot;;&amp;#13;
              targetNode.style.zIndex = &quot;100000&quot;;&amp;#13;
              targetNode.style.top = &quot;0px&quot;;&amp;#13;
              targetNode.style.left = &quot;0px&quot;;&amp;#13;
              targetNode.style.position = &quot;absolute&quot;;&amp;#13;
            }&amp;#13;
            if (mutation.attributeName === &quot;class&quot;) {&amp;#13;
              targetNode.style.setProperty(&amp;#13;
                &quot;visibility&quot;,&amp;#13;
                &quot;visible&quot;,&amp;#13;
                &quot;important&quot;&amp;#13;
              );&amp;#13;
            }&amp;#13;
            break;&amp;#13;
          default:&amp;#13;
            break;&amp;#13;
        }&amp;#13;
      }&amp;#13;
    });&amp;#13;
    observers[1].observe(targetNode, config);&amp;#13;
  }&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver&lt;/a&gt;&lt;/p&gt;
    &lt;/div&gt;&amp;#13;
&amp;#13;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>80c3b8e0004a3c0e48fa4bd4f406729d</guid>
<title>Java线上CPU内存冲高问题排查步骤</title>
<link>https://toutiao.io/k/t9sj17s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;作者：茂茂的小破号&lt;br/&gt;链接：https://www.jianshu.com/p/801ecfb44113&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;作为一名从事Java开发快一年的程序员，在线上经常碰到某个模块的Pod发出CPU与内存告警的问题，而这些问题会导致系统响应缓慢甚至是服务不可用。一般情况下可以通过重启或者调高Pod的资源量或者增加Pod数量暂时解决问题，但这是治标不治本的，只有找到问题发生的原因才能从根本上解决问题。那么在该如何快速定位到导致告警的原因呢？下面将汇总一下大致的处理思路。&lt;/p&gt;&lt;p&gt;一般来说导致Java程序CPU与内存冲高的原因有两种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中某个位置读取数据量较大，导致系统内存耗尽，从而导致Full GC次数过多，系统缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码中有比较耗CPU的操作，导致CPU过高，系统运行缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于锁使用不当，导致多个线程进入死锁状态，从而导致系统整体比较缓慢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;前两种情况出现的频率较高，可能会导致系统不可用，后三种会导致某个功能运行缓慢，但是不至于导致系统不可用。&lt;/p&gt;&lt;p&gt;对于第一种情况，本人曾经遇到过某个查全量数据的接口在某段时间被频繁调用导致内存耗尽、疯狂GC的情况：记一次GC导致的CPU与内存冲高的问题解决。&lt;/p&gt;&lt;p&gt;下面将总结一些具体的排查步骤。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2 分析工具&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;2.1 top命令查看CPU占用情况&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;PID为进程编号，COMMAND为其中执行命令，java即为要找的应用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0:/&lt;span&gt;### top&lt;/span&gt;&lt;br/&gt;top - 14:01:23 up 1 day, 17:54,  1 user,  &lt;span&gt;load&lt;/span&gt; average: &lt;span&gt;0.00&lt;/span&gt;, &lt;span&gt;0.01&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;&lt;br/&gt;Tasks: &lt;span&gt;101&lt;/span&gt; total,   &lt;span&gt;1&lt;/span&gt; running, &lt;span&gt;100&lt;/span&gt; sleeping,   &lt;span&gt;0&lt;/span&gt; stopped,   &lt;span&gt;0&lt;/span&gt; zombie&lt;br/&gt;%Cpu(s):  &lt;span&gt;0.8&lt;/span&gt; us,  &lt;span&gt;1.2&lt;/span&gt; sy,  &lt;span&gt;0.0&lt;/span&gt; ni, &lt;span&gt;98.0&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,  &lt;span&gt;0.0&lt;/span&gt; wa,  &lt;span&gt;0.0&lt;/span&gt; hi,  &lt;span&gt;0.0&lt;/span&gt; si,  &lt;span&gt;0.0&lt;/span&gt; st&lt;br/&gt;KiB Mem :  &lt;span&gt;3782864&lt;/span&gt; total,  &lt;span&gt;1477524&lt;/span&gt; free,   &lt;span&gt;329656&lt;/span&gt; used,  &lt;span&gt;1975684&lt;/span&gt; buff/&lt;span&gt;cache&lt;/span&gt;&lt;br/&gt;KiB Swap:        &lt;span&gt;0&lt;/span&gt; total,        &lt;span&gt;0&lt;/span&gt; free,        &lt;span&gt;0&lt;/span&gt; used.  &lt;span&gt;3181392&lt;/span&gt; avail Mem&lt;br/&gt;&lt;br/&gt;  PID &lt;span&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S  %CPU %MEM     &lt;span&gt;TIME&lt;/span&gt;+ COMMAND&lt;br/&gt;  &lt;span&gt;9&lt;/span&gt;   root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;1031064&lt;/span&gt;  &lt;span&gt;52580&lt;/span&gt;  &lt;span&gt;19248&lt;/span&gt; S  &lt;span&gt;90.3&lt;/span&gt; &lt;span&gt;10.4&lt;/span&gt;  &lt;span&gt;26&lt;/span&gt;:&lt;span&gt;30.37&lt;/span&gt; javacatalina.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0:/&lt;span&gt;### top -Hp 9&lt;/span&gt;&lt;br/&gt;top - 08:31:16 up 30 min,  0 users,  &lt;span&gt;load&lt;/span&gt; average: &lt;span&gt;0.75&lt;/span&gt;, &lt;span&gt;0.59&lt;/span&gt;, &lt;span&gt;0.35&lt;/span&gt;&lt;br/&gt;Threads:  &lt;span&gt;11&lt;/span&gt; total,   &lt;span&gt;1&lt;/span&gt; running,  &lt;span&gt;10&lt;/span&gt; sleeping,   &lt;span&gt;0&lt;/span&gt; stopped,   &lt;span&gt;0&lt;/span&gt; zombie&lt;br/&gt;%Cpu(s):  &lt;span&gt;3.5&lt;/span&gt; us,  &lt;span&gt;0.6&lt;/span&gt; sy,  &lt;span&gt;0.0&lt;/span&gt; ni, &lt;span&gt;95.9&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,  &lt;span&gt;0.0&lt;/span&gt; wa,  &lt;span&gt;0.0&lt;/span&gt; hi,  &lt;span&gt;0.0&lt;/span&gt; si,  &lt;span&gt;0.0&lt;/span&gt; st&lt;br/&gt;KiB Mem:   &lt;span&gt;2046460&lt;/span&gt; total,  &lt;span&gt;1924856&lt;/span&gt; used,   &lt;span&gt;121604&lt;/span&gt; free,    &lt;span&gt;14396&lt;/span&gt; buffers&lt;br/&gt;KiB Swap:  &lt;span&gt;1048572&lt;/span&gt; total,        &lt;span&gt;0&lt;/span&gt; used,  &lt;span&gt;1048572&lt;/span&gt; free.  &lt;span&gt;1192532&lt;/span&gt; cached Mem&lt;br/&gt;&lt;br/&gt;  PID &lt;span&gt;USER&lt;/span&gt;      PR  NI    VIRT    RES    SHR S %CPU %MEM     &lt;span&gt;TIME&lt;/span&gt;+ COMMAND&lt;br/&gt;   &lt;span&gt;10&lt;/span&gt; root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2557160&lt;/span&gt; &lt;span&gt;289824&lt;/span&gt;  &lt;span&gt;15872&lt;/span&gt; R &lt;span&gt;79.3&lt;/span&gt; &lt;span&gt;14.2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;41.49&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;11&lt;/span&gt; root      &lt;span&gt;20&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt; &lt;span&gt;2557160&lt;/span&gt; &lt;span&gt;289824&lt;/span&gt;  &lt;span&gt;15872&lt;/span&gt; S &lt;span&gt;1.2&lt;/span&gt;  &lt;span&gt;14.2&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;06.78&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到占用CPU消耗最高的PID为10，该ID即为线程ID，使用如下命令将其转化为16进制格式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### printf &quot;%x\n&quot; 10 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;得到输出a线程即为0xa。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.2 使用jstack查看Java线程信息&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### jstack 9 | grep 0xa&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&quot;VM Thread&quot;&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007f871806e000&lt;/span&gt; nid=&lt;span&gt;0xa&lt;/span&gt; runnable”&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程，如果是&quot;main&quot;则是其他线程，后面的runnable是线程状态。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.3 使用jstat查看GC信息&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;root@8d36124607a0&lt;span&gt;:/&lt;/span&gt;&lt;span&gt;### jstat -gcutil 9 1000 10&lt;/span&gt;&lt;br/&gt;  S&lt;span&gt;0&lt;/span&gt;     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;  &lt;span&gt;75.07&lt;/span&gt;  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3259&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;919&lt;/span&gt;  &lt;span&gt;6517&lt;/span&gt;    &lt;span&gt;7.715&lt;/span&gt;    &lt;span&gt;8.635&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3306&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;930&lt;/span&gt;  &lt;span&gt;6611&lt;/span&gt;    &lt;span&gt;7.822&lt;/span&gt;    &lt;span&gt;8.752&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3351&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;943&lt;/span&gt;  &lt;span&gt;6701&lt;/span&gt;    &lt;span&gt;7.924&lt;/span&gt;    &lt;span&gt;8.867&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;00&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;.08  &lt;span&gt;59.09&lt;/span&gt;  &lt;span&gt;59.60&lt;/span&gt;   &lt;span&gt;3397&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;.&lt;span&gt;955&lt;/span&gt;  &lt;span&gt;6793&lt;/span&gt;    &lt;span&gt;8.029&lt;/span&gt;    &lt;span&gt;8.984&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大，确认为Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.4 使用Jmap分析内存&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -dump:format=b,file=文件名称 进程ID&lt;/code&gt; ：生成内存dump文件，进行离线分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;dump文件界面分析工具：IBM HeapAnalyzer，点击进入找到ha457.jar的下载链接进行下载&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;java -Xmx4G -jar ha457.jar&lt;/code&gt;：运行jar文件，如果dump文件过大可以使用&lt;code&gt;-Xmx&lt;/code&gt;设置最大堆内存大小，防止内存溢出。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过ha457.jar的GUI界面可以很清晰的看到各种类型的数据内存占用情况、对象之间的引用关系以及可能存在内存泄漏的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9741666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGe4Jocn295UNx4tEcgMIM0MJFIsWxKQY7YLLyKGKTCxuCPBHBC3ibwkg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;3 原因分析&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;3.1 Full GC次数过多&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相对来说，这种情况是最容易出现的，尤其是新功能上线时。对于Full GC较多的情况，其主要有如下两个特征：&lt;/p&gt;&lt;p&gt;初步排查：使用&lt;code&gt;top&lt;/code&gt;与&lt;code&gt;top -Hp&lt;/code&gt;命令找到CPU占用最高的Java线程，将其转为16进制后，使用&lt;code&gt;jstack&lt;/code&gt;命令抓取该线程信息，发现线程名称是&quot;VM Thread&quot;垃圾回收线程。&lt;br/&gt;进一步确认：使用&lt;code&gt;jstat -gcutil&lt;/code&gt;命令查看gc次数与增长情况。&lt;br/&gt;进一步分析：使用&lt;code&gt;jmap -dump&lt;/code&gt;命令dump内存，然后使用使用&lt;code&gt;ha457.jar&lt;/code&gt;离线分析。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.2 某个业务逻辑执行时间过长&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如果是Full GC次数过多，那么通过 &lt;code&gt;jstack&lt;/code&gt;得到的线程信息会是类似于VM Thread之类的线程，而如果是代码中有比较耗时的计算，那么我们得到的就是一个线程的具体堆栈信息。&lt;/p&gt;&lt;p&gt;如下是一个代码中有比较耗时的计算，导致CPU过高的线程信息：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGHYicpA8OPqIBR6VWN0CVpHcEXZvv6vDcCXxvYnb2HcZMcp4ECiaE3iamg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里可以看到，在请求UserController的时候，由于该Controller进行了一个比较耗时的调用，导致该线程的CPU一直处于100%。&lt;/p&gt;&lt;p&gt;我们可以根据堆栈信息，直接定位到UserController的34行，查看代码中具体是什么原因导致计算量如此之高。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.3 死锁&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;如果有死锁，会直接提示。关键字：deadlock。使用&lt;code&gt;jstack&lt;/code&gt;打印线程信息会打印出业务死锁的位置。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6407407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGNop8ahlnjcTkszUNn30l84v6iaAzRQibIicGLfJRrSdCEdpKVxJd7putQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;3.4 线程一直处于WAITTING状态&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;对于这种情况，这是比较罕见的一种情况，但是也是有可能出现的，而且由于其具有一定的 “不可复现性”，因在排查的时候是非常难以发现的。&lt;/p&gt;&lt;p&gt;某个线程由于某种原因而进入WAITING状态，此时该功能整体不可用，但是无法复现。&lt;code&gt;jstack&lt;/code&gt;多查询几次，每次间隔30秒，对比一直停留在parking 导致的WAITING状态的线程。&lt;/p&gt;&lt;p&gt;可以通过给线程命名快速定位到是哪个业务代码。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;3.5 随机出现大量线程访问接口缓慢&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;对于这种情况，比较典型的例子就是，我们某个接口访问经常需要2~3s才能返回。&lt;/p&gt;&lt;p&gt;这是比较麻烦的一种情况，因为一般来说，其消耗的CPU不多，而且占用的内存也不高，也就是说，我们通过上述两种方式进行排查是无法解决这种问题的。&lt;/p&gt;&lt;p&gt;而且由于这样的接口耗时比较大的问题是不定时出现的，这就导致了我们在通过 jstack命令即使得到了线程访问的堆栈信息，我们也没法判断具体哪个线程是正在执行比较耗时操作的线程。&lt;/p&gt;&lt;p&gt;对于不定时出现的接口耗时比较严重的问题，我们的定位思路基本如下：&lt;/p&gt;&lt;p&gt;首先找到该接口，通过压测工具不断加大访问力度，如果说该接口中有某个位置是比较耗时的，由于我们的访问的频率非常高，那么大多数的线程最终都将阻塞于该阻塞点&lt;/p&gt;&lt;p&gt;这样通过多个线程具有相同的堆栈日志，我们基本上就可以定位到该接口中比较耗时的代码的位置。&lt;/p&gt;&lt;p&gt;如下是一个代码中有比较耗时的阻塞操作通过压测工具得到的线程堆栈日志：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRxUgVJjiaqFmNaG4nVMf6TLGBzbmzopLgWyBSKkdqPvKvZxjT8sbewCmaR2ibLRS8rt6OnLKfVNTU1w/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上面的日志可以看你出，这里有多个线程都阻塞在了UserController的第18行，说明这是一个阻塞点，也就是导致该接口比较缓慢的原因。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4 总结&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;4.1 排查命令总结&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;top&lt;/code&gt;：查看系统进程CPU与内存占用情况，找到占用最多的进程ID&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;top -Hp 进程号&lt;/code&gt;：查看该进程号的所有线程CPU与内存占用情况，找到占用最多的线程ID（显示的PID即为10进制线程编号，printf &quot;%x\n&quot; 进程号转为16进制线程号）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstack 进程号 &amp;amp;gt;&amp;amp;gt; stack.txt&lt;/code&gt;：将进程号所属进程的堆栈信息输出到stack.txt中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstack 进程号 | grep 16进制线程号&lt;/code&gt;：查看进程号先所属线程的堆栈信息，可查看线程名，区分出普通线程与GC线程（&quot;VM Thread&quot;）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一直统计）&lt;/code&gt;：如果是因为GC问题，进一步观察GC情况&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -heap 进程ID&lt;/code&gt;：查看详细进程内存使用信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;jmap -dump:format=b,file=文件名称 进程ID&lt;/code&gt;：将进程内存信息dump到磁盘上供进一步分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;java -Xmx4G -jar ha457.jar&lt;/code&gt;：使用ha457.jar来分析内存泄漏情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;4.2 异常情况解决总结&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC问题：top+top -Hp + jstack排查是&quot;VM Thread&quot;消耗过多资源，可以进一步使用jmap工具进行内存溢出排查。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务执行过慢问题：top+top -Hp + jstack排查发现是普通业务线程，可看到具体是哪个接口。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;死锁：&lt;code&gt;jstack + Java进程&lt;/code&gt;打印堆栈信息中包含死锁信息deadlock&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程处于waiting状态：多打印几次jstack信息，对比一直停留在waiting状态的线程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;5 参考：&lt;/span&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;线上CPU飙升100%问题排查，一篇足矣 - 只会一点java - 博客园 (cnblogs.com)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;面试官：如果你们的系统 CPU 突然飙升且 GC 频繁，如何排查？(qq.com)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统运行缓慢，CPU 100%，以及Full GC次数过多问题的排查思路 - charming丶的个人空间 - OSCHINA - 中文开源技术交流社区&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a2ebef2c4b4e79024db7f2e74a260ce</guid>
<title>40 张最全计算机网络基础思维导图</title>
<link>https://toutiao.io/k/rogs5j4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;PHP开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;phpDevs&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;「PHP开发者」专注分享 PHP 开发相关的技术文章和工具资源。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>41c4dd229189d217432ab50b8e44ce0c</guid>
<title>安全架构设计的方法论</title>
<link>https://toutiao.io/k/ig2i9fh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>