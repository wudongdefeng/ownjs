<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>306ace908cb8e7ede7c5a3e0e05a9e32</guid>
<title>性能领域：你知道的越多，不知道的也就越多</title>
<link>https://toutiao.io/k/tyb3ebp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;计算机性能是一门令人激动的，富于变化同时又充满挑战的领域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统性能&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是对整个计算机系统的性能的研究，包括主要&lt;/span&gt;&lt;span&gt;&lt;strong&gt;硬件&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;组件和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;软件&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;组件。所有数据路径上和从存储设备到应用软件上所发生的事情都包括在内，因为这些都有可能影响性能。对于分布式系统来说，这意味着多台服务器和多个应用。如果你还没有关于你的环境的一张示意图，用来显示数据的路径，赶紧找一张或者自己画一张。它可以帮助你理解所有组件的关系，并确保你不会只见树木不见森林。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系统性能的典型目标是通过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;减少延时&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;降低计算成本&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;来改善终端用户的体验。降低成本可以通过消除低效之处、提高系统吞吐量和进行常规性能调优来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面是系统性能的一些重要概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;延时&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于某些环境，延时是被唯一关注的性能焦点。而对于其他环境，它会是除了吞吐量以外，数一数二的分析要点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为延时的一个例子，图 2.3 显示了如 HTTP GET 请求的网络传输，其响应时间被分成连接延时和数据传输时间两部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18375241779497098&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19Dtl6d1BWJC4iaBOEugZXYV3z6RDAZLIfn2hAQX4EgHRpDm8FbmgRKYbUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;517&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延时是操作执行之前所花的等待时间。在这个例子里，操作是网络服务的数据传输请求。在这个操作发生之前，系统必须等待建立网络连接，这就是这个操作的延时。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;响应时间包括了延时和操作时间。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为延时可以在不同点测量，所以通常会指明延时测量的对象。例如，网站的载入时间由三个从不同点测得的不同时间组成 ：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;DNS 延时、TCP 连接延时和 TCP 数据传输时间。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;DNS 延时指的是整个 DNS 操作的时间，TCP 连接延时仅仅指的是初始化时间（TCP 握手）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于延时是一个时间上的指标，因此可能有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;多种计算方法。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;性能问题可以用延时来进行量化和评级，因为是用相同的单位来表达的（时间）。通过考量所能减少或移除的延时，预计的加速也可以被计算出来。这两者不能用 IOPS 指标很准确地描述出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间的量级和缩写列在了表 2.1 中，可作为参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.27347781217750256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtnPWXSh27UWy79iaRUu7hJ5ic3yxVzXsHFrMFj48OhaGkTDLGu0ibib2jfg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果可能，其他的指标也会转化为延时或者时间，这样就可以进行比较了。如果必须在 100 个网络 I/O 和 50 个磁盘 I/O 之间做出选择，怎样才能知道哪个性能更好？这是一个复杂的选择，因为其中包含了很多因素 ：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;网络跳数、网络丢包率和重传率、I/O 的大小、随机或顺序的 I/O、磁盘类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，等等。但是如果你比较的是 100ms 的网络 I/O 延时和 50ms 的磁盘 I/O 延时，那差别就很明显了！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;时间量级&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以对时间进行量化的比较，同时最好&lt;/span&gt;&lt;span&gt;&lt;strong&gt;对时间和各种来源的延时的合理预期有本能的认识。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;系统各组件的操作的时间量级差别巨大，表 2.2 中提供的延时示例，从访问 3.5GHz 的 CPU 寄存器的延时开始，阐释了各种操作时间量级的差别。表中所示的是发生单次操作的时间均值，等比放大为一个假想的系统，将 1 个 CPU 周期的 0.3ns（十亿分之一秒的三分之一 1）放大为现实生活中的 1 秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1641304347826087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtqFPGjMM3K3rNSd5rekucZwsPh0PwePSRWc9bSmia6cm6krhyny4sgkw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5472527472527473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtiaRcYyF1rcjPfOVDCvTib3hlj3outriazK0PMwichFRLKxrXH2lR0BPkqw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如你所见，1 个 CPU 周期的时间是很短暂的。0.5 米差不多是你的眼睛到这个页面的距离，光线走过这段距离需要的时间大约是 1.7ns。在这段时间里，现代的 CPU 已经执行了 5 个 CPU 周期，处理了若干个指令。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;权衡&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你应该知道某些性能权衡关系。图 2.4 展示的是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;好 / 快 / 便宜&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;“择其二”的权衡关系，右图所示的是对应于 IT 项目的术语。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28028503562945367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtLp5rVXkSUTH8U0hfbJRWQ9ViamLCib3eibEe6rNYicVmAj2heDDLt9pG6Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;许多 IT 项目选择了及时和成本低，留下了性能问题在以后解决。当早期的决定阻碍了性能提高的可能性时，这样的选择会变得有问题，例如，选择了非最优的存储架构，或者使用的编程语言或操作系统缺乏完善的性能分析工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个常见的性能调优的权衡是在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;CPU 与内存之间&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，因为内存能用于缓存数据结果，降低 CPU 的使用率。在有着充足 CPU 资源的现代系统里，交换可以反向进行 ：CPU 可以压缩数据来降低内存的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;调优的影响&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能调优实施在越靠近工作执行的地方效果最显著。对于工作负载驱动的应用程序，这意味着调优性能的地方就在应用程序本身。表 2.3 展示了一个软件栈的例子，说明了性能调优的各种可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.275974025974026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtOM594Gz4dlBOiagxBI1nyibQkXWkZzmsm9dlyuiaDGTYfT1CMJvlayjuw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对应用程序层级进行调优，可能通过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;消除或减少数据库查询&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;获得很大的性能提升（例如，20 倍）。在存储设备层级进行调优，可以&lt;/span&gt;&lt;span&gt;&lt;strong&gt;精简或提高存储 I/O&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，但是性能提升的重要部分在更高层级的操作系统栈代码，所以对存储设备层级的调优对应用程序性能的提升有限，是百分比量级的（例如，20%）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在应用程序层级寻求性能的巨大提升，还有一个理由。如今许多环境都致力于特性和功能的快速部署，按每周或每天将软件的变更推入生产环境。因此，应用程序的开发和测试倾向于&lt;/span&gt;&lt;span&gt;&lt;strong&gt;关注正确性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在部署前留给性能测量和优化的时间很少甚至没有。之后当性能成为问题时，才会去做这些与性能相关的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然发生在应用程序层级的调优效果最显著，但这个层级不一定是观测效果最显著的层级。数据库查询缓慢最好从其所花费的 CPU 时间、文件系统和所执行的磁盘 I/O 方面来考查。使用操作系统工具，这些都是可以观测到的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;合适的层级&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的公司和环境对性能有着不同的需求。你可能加入过这样的公司，其分析标准要比你之前所见过的严格得多，甚至可能听都没听过。或者是这样的公司，你觉得很基本的分析被认为很高端甚至从未使用过（这是好消息 ：事情简单轻松！）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这并不意味着某些公司做的是对的，某些做的是错的。这取决于性能技术投入的投资回报率（ROI）。拥有大型数据中心或大型云环境的组织可能会雇用一个性能工程师团队来分析所有的事情，包括内核内部和 CPU 性能计数器，并频繁使用各种跟踪工具。他们还可能对性能进行正式建模，并对未来的增长进行准确预测。对于每年在计算上有数百万花费的环境来说，雇用这样一个性能团队是值得的，因为他们进行的优化就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;投资回报&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。小型创业公司的计算开支不大，可能只进行表面的检查，利用第三方监测方案来检查性能和提供警报。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;何时停止分析&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做性能分析时的一个挑战是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;如何知道何时停止&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。有这么多的工具，有这么多的东西要检查！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我教性能课程时（最近我又开始教了），我给我的学生一个有三个原因的性能问题，我发现有些学生在找到一个原因后就停止了，有些则是两个，有些则是三个。有些学生则继续努力，试图为性能问题找到更多的原因。谁的做法是正确的？说你应该在找到所有三个原因后就停止，可能很容易，但对于现实生活中的问题，你并不知道原因的数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;这里有三种情况，你可以考虑停止分析&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，并提供了一些个人的例子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你已经解释了大部分性能问题的时候。一个 Java 应用程序消耗的 CPU 资源是原来的 3 倍。我发现的第一个问题是异常堆栈消耗了 CPU。然后我量化了这些堆栈的时间，发现它们只占整个 CPU 占用的 12%。如果这个数字接近 66%，我就可以停止分析了。但在这种情况下，在 12% 的情况下，我需要继续寻找。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当潜在的投资回报率低于分析的成本的时候。我所处理的一些性能问题可以带来每年数千万美元的收益。对于这些问题，我可以证明花几个月的时间（工程成本）进行分析是合理的。其他的性能问题，比如说微服务，可能是以数百美元计算的，甚至不值得花 1 个小时的工程时间来分析它们。例外情况可能包括 ：当我没有更好的事情可做时（这在实践中从未发生过），或者如果我怀疑这可能是日后更大问题的隐患，值得在问题扩大之前进行调试时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当其他地方有更大的投资回报率的时候。即使前两种情况没有得到满足，其他地方有更大的投资回报时经常需要优先考虑。如果你是全职的性能工程师，根据潜在的投资回报率对不同的问题进行有选择的分析可能是一项日常工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;性能推荐的时间点&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;环境的性能特性会随着时间改变，更多的用户、新的硬件、升级的软件或固件都是变化的因素。一种环境，受限于速度 10Gb/s 的网络基础设施，当升级到 100Gb/s 时，很可能会发现磁盘或 CPU 的性能变得紧张。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能推荐，尤其是可调优的参数值，仅仅在一段特定时间内有效。一周内从性能专家那里得到的好建议，可能到了下一周，经过一次软件或硬件升级，或者用户增多后就无效了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在网上搜索找到的调优参数值对于某些情况可能能快速见效。但如果对于你的系统或者工作负载并不合适，它们也可能会对性能有所损害，或者合适过一次，就不再合适了，或者只是作为软件的某个 bug 修复升级之前暂时的应急措施。这和从别人的医药箱里拿药吃很像，那些药可能不适合你，或者可能已经过期，或者只适合短期服用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果仅仅是出于要了解有哪些参数可调以及哪些参数在过去是需要调整的，那么浏览这些性能建议是有用的。针对你的系统和工作负载，这项工作就变成了考虑这些参数是不是要调，以及调整成什么值。如果其他人不需要调整那个值，或者调整了但并未将经验分享出来，那么你有可能漏掉了重要的参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;负载与架构&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用程序性能差可能是因为软件配置和硬件的问题，也就是它的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构和实现&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;问题。另外，应用程序性能差还可能是由于有太多负载，而导致了排队和长延时。负载和架构见图 2.5。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3995943204868154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtiawBsdVy6iaibk3iaaFDiad8PBLVQD0IAmhtsiclexjky09iaGwoOS2hJDu8Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果对架构的分析显示只是工作任务在排队，处理任务没有任何问题，那么问题就可能出在施加的负载太多上。在云计算环境里，这是需要引入更多的服务器实例来处理任务的征兆。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;举个例子，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;架构的问题可能是一个单线程的应用程序在单个 CPU 上忙碌，从而导致请求排队，但是其他的 CPU 却是可用且空闲的。在这个例子里，性能就被应用程序的单一线程架构限制住了。架构的另一个问题可能是一个程序的多个线程争夺一个锁，这样只有一个线程可以向前推进，而其他线程在等待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负载的问题可能会是一个多线程程序在所有的 CPU 上都忙碌，但是请求依然排队的情况。在这个例子里，性能可能被限制于 CPU 的性能，或者说是负载超出了 CPU 所能处理的范围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;指标&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能指标是由系统、应用程序，或者其他工具选定的统计数据，用于测量感兴趣的活动。性能指标用于性能分析和监测，可以由命令行提供数据，也可以由可视化工具提供图表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;常见的系统性能指标如下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;吞吐量 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每秒的数据量或操作量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;IOPS ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;每秒的 I/O 操作数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用率 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;资源的繁忙程度，以百分比表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;延时 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;操作时间，以平均数或百分数表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;吞吐量的使用取决于上下文环境。数据库吞吐量通常用来度量每秒查询或请求的数目（操作量）。网络吞吐量度量的是每秒传输的比特数或字节数（数据量）。IOPS 度量的是吞吐量，但只针对 I/O 操作（读取和写入）。再次重申，上下文很关键，上下文不同，定义可能会有不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缓存被频繁使用来提高性能。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;缓存是将较慢的存储层的结果存放在较快的存储层中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把磁盘的块缓存在主存（RAM）中就是一例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般使用的都是多级缓存。CPU 通常利用多级硬件缓存作为主缓存（L1、L2 和L3），开始是一个非常快但是很小的缓存（L1），后续的 L2 和 L3 逐渐增加了缓存容量和访问延时。这是一个在密度和延时之间经济上的权衡。缓存的级数和大小的选择以CPU 芯片内可用空间为准，确保达到最优的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个了解缓存性能的重要指标是每个缓存的命中率—所需数据在缓存中被找到的次数（hits，命中）与总访问次数（hits+misses）的比例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;命中率 = 命中次数 /（命中次数 + 失效次数）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;命中率越高越好&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，更高的命中率意味着更多的数据能成功地从较快的介质中访问获&lt;/span&gt;&lt;span&gt;得。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2937625754527163&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtLmfSicQpCDiclZ1Lfkobujiauf0rOLMJZ3eCib0CuovVQh5uegfmzibkWsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;497&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;98% 和 99% 之间的性能差异要比 10% 和 11% 之间的性能差异大很多。由于缓存命中和失效之间的速度差异（两个存储层级），导致了这是一条非线性曲线。两个存储层级速度差异越大，曲线越陡峭。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;已知的未知&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;已知的已知、已知的未知、未知的未知在性能领域是很重要的概念。下面是详细的解释，并提供了系统性能分析的例子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;已知的已知 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;有些东西你知道。你知道你应该检查性能指标，你也知道它的当前值。举个例子，你知道你应该检查 CPU 使用率，而且你也知道当前均值是10%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;已知的未知 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;有些东西你知道你不知道。你知道你可以检查一个指标或者判断一个子系统是否存在，但是你还没去做。举个例子，你知道你能用剖析检查是什么致使 CPU 忙碌，但你还没去做这件事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;未知的未知 ：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;有些东西你不知道你不知道。举个例子，你可能不知道设备中断可以消耗大量 CPU 资源，因此你对此并不做检查。在性能领域，“你知道的越多，你不知道的也就越多”。这和学习系统是一样的原理：你了解的越多，你就能意识到未知的未知越多，然后这些未知的未知会变成你可以去查看的已知的未知。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6265895953757226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m4lyVtPpPEicQN18icZ3tA11cApLC5wVRmZvyfKkQMKS4O7Kh4tWROldyU1kqmNa4QUZYB5mOzEodQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;865&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国际知名的性能专家、火焰图（Flame Graph）发明人——Brendan Gregg，&lt;/span&gt;&lt;span&gt;最近将他在Netflflix、英特尔积累的丰富的云计算环境下的性能优化的经验分享了出来，继震惊业界的上一版之后，再次推出新书&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《性能之巅：系统、企业与云可观测性》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m4lyVtPpPEicQN18icZ3tA115iboe3gLyDjUMiaWSUrTJibHdvejTohxStd3A1e6NyhXXKr3qSrf057yA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;739&quot; data-width=&quot;268px&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;34405&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;272:381&quot;&gt;&lt;strong&gt;内容简介&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本书既介绍操作系统和应用程序的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概念、策略、工具和调优&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又基于Linux的操作系统进行&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;示例分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不仅梳理了性能优化的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方法论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;常见性能检测工具的使用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阅读本书，你将看到:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;无论你是系统管理员、运维工程师，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;还是开发工程师、性能架构师，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;无论你是数据库管理员、网站管理员，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;还是刚接触性能优化的学生、小白；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Gregg深厚的技术功底和文字驾驭能力，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;丰富的工程实践经历、教学经验都会给你启发。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lFfa89JiaJLAan9Jegh19DtHyb4A6EfWLsEIfUzo55jm6pLgic6rcZf4mMkS3var2dzUOYO0cicVWPg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内容比较多，书比较厚，原价238，&lt;/span&gt;&lt;span&gt;现在京东正在100-50&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;折后137.8&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;希望所有的 IT 从业者都能从本书受益，让天下的系统都能达到性能之巅！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;图书活动&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;评论点赞最高的前三名，可以免费获得《性能之巅(第2版)》！&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;有兴趣读者可以各大电商渠道购买&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;高可用架构&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;改变互联网的构建方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6dce56c81a413bcfc8358b6b1a801bf0</guid>
<title>万能Debug神器之GDB的使用手册</title>
<link>https://toutiao.io/k/6m4i555</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202207/420532-20220714194009531-1164755773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为啥Logo是条鱼， Jamie Guinan说：&lt;/p&gt;
&lt;p id=&quot;1657798815900&quot;&gt;对于一条鱼来说，众所周知，弓鱼会通过向它们吐水来击落低垂植物上的虫子。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202207/420532-20220714194212668-428215398.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p id=&quot;1657798933913&quot;/&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;pagetop&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;Gdb 快速指南&lt;/h2&gt;
&lt;p&gt;动态调试器实用程序&lt;code&gt;gdb&lt;/code&gt;具有大量功能。本快速指南列出了一小部分有用的&lt;code&gt;gdb&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;Preparation&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用 -g 选项编译。
&lt;p&gt;例子。编译程序 printch.cpp：&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;hawk% g++ -g printch.cpp -o printch&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;启动 gdb 并设置要列出的源代码行数。
&lt;p&gt;例子。在 bin 程序上运行 gdb 并将一次要列出的源代码行数设置为 28。&lt;/p&gt;
&lt;pre class=&quot;language-sql highlighter-hljs&quot;&gt;&lt;code&gt;% gdb -xdb -tui ./bin
GNU gdb 4.17.1

# 如果要调试进程换成
# gdb -xdb -tui -p $(pgrep bin)

(gdb)set listsize 28&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;如图&lt;br/&gt;&lt;img src=&quot;https://img2022.cnblogs.com/blog/420532/202207/420532-20220714202145724-16461875.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&quot;Setting_Breakpoints&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;设置断点&lt;/h3&gt;
&lt;p&gt;断点是代码中&lt;span class=&quot;code&quot;&gt;gdb&lt;/span&gt;将停止并允许执行其他&lt;span class=&quot;code&quot;&gt;gdb&lt;/span&gt;命令的点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在函数的开头设置断点。
&lt;p&gt;例子。在开头设置断点&lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)b main&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;调试时在当前文件的某行设置断点。
&lt;p&gt;例子。在文件 printch.cpp 中的第 35 行设置断点。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)b 35&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;在类成员函数的开头设置断点。
&lt;p&gt;例子。在&lt;em&gt;类&lt;/em&gt;&lt;span class=&quot;code&quot;&gt;列表的&lt;/span&gt;&lt;em&gt;成员函数&lt;/em&gt; &lt;span class=&quot;code&quot;&gt;擦除&lt;/span&gt;开始处设置断点。&lt;/p&gt;
&lt;pre class=&quot;language-css highlighter-hljs&quot;&gt;&lt;code&gt;(gdb) b list::erase&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;列出断点。
&lt;p&gt;例子。列出迄今为止在调试会话中设置的所有断点。&lt;/p&gt;
&lt;pre class=&quot;language-plaintext highlighter-hljs&quot;&gt;&lt;code&gt;(gdb) info b
Num Type           Disp Enb Address    What
1   breakpoint     keep y   0x0040104f in main at printch.cpp:27
2   breakpoint     keep y   0x004010a7 in main at printch.cpp:35&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;删除断点。
&lt;p&gt;例子。删除第 35 行的断点。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)delete 2&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&quot;Running_the_Program_being_Debugged&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;启动正在调试的程序。
&lt;p&gt;示例 1. 程序是 printch，它可以采用可选的命令行参数。&lt;strong&gt;在没有&lt;/strong&gt;命令行参数的情况下启动它。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)r&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例 2. 使用命令行参数A&lt;/strong&gt;启动 printch 运行 。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)r A&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;执行单个语句。如果语句是函数调用，只需单步&lt;em&gt;进入&lt;/em&gt;函数。
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)s&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;执行单个语句。如果语句是函数调用，则执行整个函数并返回调用后的语句；即&lt;em&gt;跨过&lt;/em&gt;函数。
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)n&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;如果有断点，则从当前点执行到下一个断点，否则执行直到程序终止。
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)c&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;执行当前函数的其余部分；也就是&lt;em&gt;跳出&lt;/em&gt;函数。
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)finish&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&quot;Examining_Variables&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;检查变量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;打印变量或表达式的值。
&lt;p&gt;示例 1. 打印变量的值&lt;code&gt;count&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)p count&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例 2. 打印表达式 fname[i+1] 的值&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb) p fname[i+1]&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&quot;List_Source_Code_and_the_Next_Statement&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;列出源代码和下一条语句&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;列出源代码行。
&lt;p&gt;例子。列出下一个&lt;em&gt;listsize&lt;/em&gt;代码行数。&lt;em&gt;请注意，&lt;strong&gt;listsize&lt;/strong&gt;的值可以通过 &lt;strong&gt;set&lt;/strong&gt;命令&lt;/em&gt;更改。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)l&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;列出以特定行为中心的源代码行。
&lt;p&gt;例子。列出以第 41 行为中心的行。&lt;/p&gt;
&lt;pre class=&quot;highlighter-hljs&quot;&gt;&lt;code&gt;(gdb)l 41&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;显示将要执行的下一条语句。
&lt;pre class=&quot;language-plaintext highlighter-hljs&quot;&gt;&lt;code&gt;(gdb) where
#0  mystrcpy (copyto=0x259fc6c &quot;*&quot;, copyfrom=0x259fddc &quot;ABC&quot;) at printch.cpp:27
#1  0x4010c8 in main (argc=3, argv=0x25b0cb8) at printch.cpp:40&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数第 27 行的语句&lt;code&gt;mystrcpy&lt;/code&gt;是 &lt;strong&gt;下&lt;/strong&gt;一条语句，函数 mystrcpy 被调用&lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a name=&quot;Help_and_Quitting_Gdb&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;帮助和退出 Gdb&lt;/h3&gt;
&lt;p&gt;有一个帮助命令，&lt;code&gt;h&lt;/code&gt;退出&lt;strong&gt;gdb&lt;/strong&gt;的命令是&lt;code&gt;q&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a name=&quot;Summary_of_Commands&quot; rel=&quot;noopener&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;最常用的命令&lt;/h3&gt;
&lt;table border=&quot;&quot; cellpadding=&quot;3&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th&gt;Gdb 命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;set listsize &lt;em&gt;n&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;将 list 命令列出的行数设置为&lt;em&gt;n &lt;/em&gt;&lt;span class=&quot;code2&quot;&gt;[set listsize]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b &lt;em&gt;function&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;在函数&lt;/em&gt; 开头设置断点&lt;span class=&quot;code2&quot;&gt;[break]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b &lt;em&gt;line number&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;在当前文件的&lt;em&gt;行号&lt;/em&gt;处设置断点。&lt;span class=&quot;code2&quot;&gt;[休息]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;info b&lt;/td&gt;
&lt;td&gt;列出所有断点&lt;span class=&quot;code2&quot;&gt;[信息]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;delete n&lt;/td&gt;
&lt;td&gt;删除断点编号&lt;em&gt;n &lt;/em&gt;&lt;span class=&quot;code2&quot;&gt;[delete]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;r args&lt;/td&gt;
&lt;td&gt;启动正在调试的程序，可能使用命令行参数&lt;em&gt;args&lt;/em&gt;。&lt;span class=&quot;code2&quot;&gt;[跑]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;em&gt;s count&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;单步下一个&lt;em&gt;计数&lt;/em&gt;语句（默认为 1）。步入 &lt;strong&gt;&lt;em&gt;函数&lt;/em&gt;&lt;/strong&gt;。&lt;span class=&quot;code2&quot;&gt;[步]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;n count &lt;/td&gt;
&lt;td&gt;单步下一个&lt;em&gt;计数&lt;/em&gt;语句（默认为 1）。跳过 功能&lt;strong&gt;&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;span class=&quot;code2&quot;&gt;[下一个]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;finish&lt;/td&gt;
&lt;td&gt;执行当前函数的其余部分。跳出当前功能&lt;strong&gt;&lt;em&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;span class=&quot;code2&quot;&gt;[结束]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;如果没有遇到断点，则继续执行到下一个断点或直到终止。&lt;span class=&quot;code2&quot;&gt;[继续]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;p expression &lt;/td&gt;
&lt;td&gt;打印&lt;em&gt;表达式的值&lt;/em&gt; &lt;span class=&quot;code2&quot;&gt;[打印]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l &lt;em&gt;optional_line&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;列出下一个&lt;em&gt;listsize&lt;/em&gt;行。如果给出&lt;em&gt;optional_line&lt;/em&gt;，列出以&lt;em&gt;optional_line&lt;/em&gt;为中心的行。&lt;span class=&quot;code2&quot;&gt;[列表]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;td&gt;显示当前行和函数以及使您到达那里的调用堆栈。&lt;span class=&quot;code2&quot;&gt;[在哪里]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;h &lt;em&gt;&lt;em&gt;optional_topic&lt;/em&gt;&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;&lt;em&gt;关于optional_topic&lt;/em&gt; 的帮助或帮助&lt;span class=&quot;code2&quot;&gt;[帮助]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;退出 gdb &lt;span class=&quot;code2&quot;&gt;[退出]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; &lt;/p&gt;
&lt;h2&gt;命令参数表&lt;/h2&gt;
&lt;pre class=&quot;language-bash highlighter-hljs&quot;&gt;&lt;code&gt;Command class: aliases

ni -- Step one instruction
rc -- Continue program being debugged but run it in reverse
rni -- Step backward one instruction
rsi -- Step backward exactly one instruction
si -- Step one instruction exactly
stepping -- Specify single-stepping behavior at a tracepoint
tp -- Set a tracepoint at specified line or function
tty -- Set terminal for future runs of program being debugged
where -- Print backtrace of all stack frames
ws -- Specify single-stepping behavior at a tracepoint

Command class: breakpoints

awatch -- Set a watchpoint for an expression
break -- Set breakpoint at specified line or function
break-range -- Set a breakpoint for an address range
catch -- Set catchpoints to catch events
catch assert -- Catch failed Ada assertions
catch catch -- Catch an exception
catch exception -- Catch Ada exceptions
catch exec -- Catch calls to exec
catch fork -- Catch calls to fork
catch load -- Catch loads of shared libraries
catch signal -- Catch signals by their names and/or numbers
catch syscall -- Catch system calls by their names and/or numbers
catch throw -- Catch an exception
catch unload -- Catch unloads of shared libraries
catch vfork -- Catch calls to vfork

clear -- Clear breakpoint at specified line or function
commands -- Set commands to be executed when a breakpoint is hit
condition -- Specify breakpoint number N to break only if COND is true
delete -- Delete some breakpoints or auto-display expressions
delete bookmark -- Delete a bookmark from the bookmark list
delete breakpoints -- Delete some breakpoints or auto-display expressions
delete checkpoint -- Delete a checkpoint (experimental)
delete display -- Cancel some expressions to be displayed when program stops
delete mem -- Delete memory region
delete tracepoints -- Delete specified tracepoints
delete tvariable -- Delete one or more trace state variables
disable -- Disable some breakpoints
disable breakpoints -- Disable some breakpoints
disable display -- Disable some expressions to be displayed when program stops
disable frame-filter -- GDB command to disable the specified frame-filter
disable mem -- Disable memory region
disable pretty-printer -- GDB command to disable the specified pretty-printer
disable tracepoints -- Disable specified tracepoints
disable type-printer -- GDB command to disable the specified type-printer
dprintf -- Set a dynamic printf at specified line or function
enable -- Enable some breakpoints
enable breakpoints -- Enable some breakpoints
enable breakpoints count -- Enable breakpoints for COUNT hits
enable breakpoints delete -- Enable breakpoints and delete when hit
enable breakpoints once -- Enable breakpoints for one hit
enable count -- Enable breakpoints for COUNT hits
enable delete -- Enable breakpoints and delete when hit
enable display -- Enable some expressions to be displayed when program stops
enable frame-filter -- GDB command to disable the specified frame-filter
enable mem -- Enable memory region
enable once -- Enable breakpoints for one hit

enable pretty-printer -- GDB command to enable the specified pretty-printer
enable tracepoints -- Enable specified tracepoints
enable type-printer -- GDB command to enable the specified type printer
ftrace -- Set a fast tracepoint at specified line or function
hbreak -- Set a hardware assisted breakpoint
ignore -- Set ignore-count of breakpoint number N to COUNT
rbreak -- Set a breakpoint for all functions matching REGEXP
rwatch -- Set a read watchpoint for an expression
save -- Save breakpoint definitions as a script
save breakpoints -- Save current breakpoint definitions as a script
save gdb-index -- Save a gdb-index file
save tracepoints -- Save current tracepoint definitions as a script
skip -- Ignore a function while stepping
skip delete -- Delete skip entries
skip disable -- Disable skip entries
skip enable -- Enable skip entries
skip file -- Ignore a file while stepping
skip function -- Ignore a function while stepping
strace -- Set a static tracepoint at specified line
tbreak -- Set a temporary breakpoint
tcatch -- Set temporary catchpoints to catch events
tcatch assert -- Catch failed Ada assertions
tcatch catch -- Catch an exception
tcatch exception -- Catch Ada exceptions
tcatch exec -- Catch calls to exec
tcatch fork -- Catch calls to fork
tcatch load -- Catch loads of shared libraries
tcatch signal -- Catch signals by their names and/or numbers
tcatch syscall -- Catch system calls by their names and/or numbers
tcatch throw -- Catch an exception
tcatch unload -- Catch unloads of shared libraries

tcatch vfork -- Catch calls to vfork
thbreak -- Set a temporary hardware assisted breakpoint
trace -- Set a tracepoint at specified line or function
watch -- Set a watchpoint for an expression

Command class: data

agent-printf -- Agent-printf &quot;printf format string&quot;
append -- Append target code/data to a local file
append binary -- Append target code/data to a raw binary file
append binary memory -- Append contents of memory to a raw binary file
append binary value -- Append the value of an expression to a raw binary file
append memory -- Append contents of memory to a raw binary file
append value -- Append the value of an expression to a raw binary file
call -- Call a function in the program
disassemble -- Disassemble a specified section of memory
display -- Print value of expression EXP each time the program stops
dump -- Dump target code/data to a local file
dump binary -- Write target code/data to a raw binary file
dump binary memory -- Write contents of memory to a raw binary file
dump binary value -- Write the value of an expression to a raw binary file
dump ihex -- Write target code/data to an intel hex file
dump ihex memory -- Write contents of memory to an ihex file
dump ihex value -- Write the value of an expression to an ihex file
dump memory -- Write contents of memory to a raw binary file
dump srec -- Write target code/data to an srec file
dump srec memory -- Write contents of memory to an srec file
dump srec value -- Write the value of an expression to an srec file
dump tekhex -- Write target code/data to a tekhex file
dump tekhex memory -- Write contents of memory to a tekhex file
dump tekhex value -- Write the value of an expression to a tekhex file

dump value -- Write the value of an expression to a raw binary file
explore -- Explore a value or a type valid in the current context
explore type -- Explore a type or the type of an expression valid in the current
explore value -- Explore value of an expression valid in the current context
find -- Search memory for a sequence of bytes
init-if-undefined -- Initialize a convenience variable if necessary
mem -- Define attributes for memory region or reset memory region handling to
output -- Like &quot;print&quot; but don&#x27;t put in value history and don&#x27;t print newline
print -- Print value of expression EXP
print-object -- Ask an Objective-C object to print itself
printf -- Printf &quot;printf format string&quot;
ptype -- Print definition of type TYPE
restore -- Restore the contents of FILE to target memory
set -- Evaluate expression EXP and assign result to variable VAR
set ada -- Prefix command for changing Ada-specfic settings
set ada trust-PAD-over-XVS -- Enable or disable an optimization trusting PAD types over XVS types
set agent -- Set debugger&#x27;s willingness to use agent as a helper
set annotate -- Set annotation_level
set architecture -- Set architecture of target
set args -- Set argument list to give program being debugged when it is started
set auto-load -- Auto-loading specific settings
set auto-load gdb-scripts -- Enable or disable auto-loading of canned sequences of commands scripts
set auto-load libthread-db -- Enable or disable auto-loading of inferior specific libthread_db
set auto-load local-gdbinit -- Enable or disable auto-loading of .gdbinit script in current directory
set auto-load python-scripts -- Set the debugger&#x27;s behaviour regarding auto-loaded Python scripts
set auto-load safe-path -- Set the list of files and directories that are safe for auto-loading
set auto-load scripts-directory -- Set the list of directories from which to load auto-loaded scripts
set auto-load-scripts -- Set the debugger&#x27;s behaviour regarding auto-loaded Python scripts
set auto-solib-add -- Set autoloading of shared library symbols
set backtrace -- Set backtrace specific variables
set backtrace limit -- Set an upper bound on the number of backtrace levels

set backtrace past-entry -- Set whether backtraces should continue past the entry point of a program
set backtrace past-main -- Set whether backtraces should continue past &quot;main&quot;
set basenames-may-differ -- Set whether a source file may have multiple base names
set breakpoint -- Breakpoint specific settings
set breakpoint always-inserted -- Set mode for inserting breakpoints
set breakpoint auto-hw -- Set automatic usage of hardware breakpoints
set breakpoint condition-evaluation -- Set mode of breakpoint condition evaluation
set breakpoint pending -- Set debugger&#x27;s behavior regarding pending breakpoints
set build-id-core-loads -- Set whether CORE-FILE loads the build-id associated files automatically
set build-id-verbose -- Set debugging level of the build-id locator
set can-use-hw-watchpoints -- Set debugger&#x27;s willingness to use watchpoint hardware
set case-sensitive -- Set case sensitivity in name search
set charset -- Set the host and target character sets
set check -- Set the status of the type/range checker
set check range -- Set range checking
set check type -- Set strict type checking
set circular-trace-buffer -- Set target&#x27;s use of circular trace buffer
set coerce-float-to-double -- Set coercion of floats to doubles when calling functions
set complaints -- Set max number of complaints about incorrect symbols
set confirm -- Set whether to confirm potentially dangerous operations
set cp-abi -- Set the ABI used for inspecting C++ objects
set data-directory -- Set GDB&#x27;s data directory
set dcache -- Use this command to set number of lines in dcache and line-size
set dcache line-size -- Set dcache line size in bytes (must be power of 2)
set dcache size -- Set number of dcache lines
set debug -- Generic command for setting gdb debugging flags
set debug arch -- Set architecture debugging
set debug auto-load -- Set auto-load verifications debugging
set debug check-physname -- Set cross-checking of &quot;physname&quot; code against demangler
set debug coff-pe-read -- Set coff PE read debugging
set debug displaced -- Set displaced stepping debugging

set debug dwarf2-die -- Set debugging of the dwarf2 DIE reader
set debug dwarf2-read -- Set debugging of the dwarf2 reader
set debug entry-values -- Set entry values and tail call frames debugging
set debug expression -- Set expression debugging
set debug frame -- Set frame debugging
set debug infrun -- Set inferior debugging
set debug jit -- Set JIT debugging
set debug libthread-db -- Set libthread-db debugging
set debug lin-lwp -- Set debugging of GNU/Linux lwp module
set debug notification -- Set debugging of async remote notification
set debug observer -- Set observer debugging
set debug overload -- Set debugging of C++ overloading
set debug parser -- Set parser debugging
set debug record -- Set debugging of record/replay feature
set debug remote -- Set debugging of remote protocol
set debug serial -- Set serial debugging
set debug stap-expression -- Set SystemTap expression debugging
set debug symtab-create -- Set debugging of symbol table creation
set debug target -- Set target debugging
set debug timestamp -- Set timestamping of debugging messages
set debug xml -- Set XML parser debugging
set debug-file-directory -- Set the directories where separate debug symbols are searched for
set debugvarobj -- Set varobj debugging
set default-collect -- Set the list of expressions to collect by default
set demangle-style -- Set the current C++ demangling style
set detach-on-fork -- Set whether gdb will detach the child of a fork
set directories -- Set the search path for finding source files
set disable-randomization -- Set disabling of debuggee&#x27;s virtual address space randomization
set disassemble-next-line -- Set whether to disassemble next source line or insn when execution stops
set disassembly-flavor -- Set the disassembly flavor
set disconnected-dprintf -- Set whether dprintf continues after GDB disconnects

set disconnected-tracing -- Set whether tracing continues after GDB disconnects
set displaced-stepping -- Set debugger&#x27;s willingness to use displaced stepping
set dprintf-channel -- Set the channel to use for dynamic printf
set dprintf-function -- Set the function to use for dynamic printf
set dprintf-style -- Set the style of usage for dynamic printf
set dump-excluded-mappings -- Set whether gcore should dump mappings marked with the VM_DONTDUMP flag
set editing -- Set editing of command lines as they are typed
set endian -- Set endianness of target
set environment -- Set environment variable value to give the program
set exec-direction -- Set direction of execution
set exec-done-display -- Set notification of completion for asynchronous execution commands
set exec-wrapper -- Set a wrapper for running programs
set extended-prompt -- Set the extended prompt
set extension-language -- Set mapping between filename extension and source language
set filename-display -- Set how to display filenames
set follow-exec-mode -- Set debugger response to a program call of exec
set follow-fork-mode -- Set debugger response to a program call of fork or vfork
set frame-filter -- Prefix command for &#x27;set&#x27; frame-filter related operations
set frame-filter priority -- GDB command to set the priority of the specified frame-filter
set gnutarget -- Set the current BFD target
set height -- Set number of lines in a page for GDB output pagination
set history -- Generic command for setting command history parameters
set history expansion -- Set history expansion on command input
set history filename -- Set the filename in which to record the command history
set history save -- Set saving of the history record on exit
set history size -- Set the size of the command history
set host-charset -- Set the host character set
set inferior-tty -- Set terminal for future runs of program being debugged
set input-radix -- Set default input radix for entering numbers
set interactive-mode -- Set whether GDB&#x27;s standard input is a terminal
set language -- Set the current source language

set libthread-db-search-path -- Set search path for libthread_db
set listsize -- Set number of source lines gdb will list by default
set logging -- Set logging options
set logging file -- Set the current logfile
set logging off -- Disable logging
set logging on -- Enable logging
set logging overwrite -- Set whether logging overwrites or appends to the log file
set logging redirect -- Set the logging output mode
set max-user-call-depth -- Set the max call depth for non-python user-defined commands
set may-insert-breakpoints -- Set permission to insert breakpoints in the target
set may-insert-fast-tracepoints -- Set permission to insert fast tracepoints in the target
set may-insert-tracepoints -- Set permission to insert tracepoints in the target
set may-interrupt -- Set permission to interrupt or signal the target
set may-write-memory -- Set permission to write into target memory
set may-write-registers -- Set permission to write into registers
set mem -- Memory regions settings
set mem inaccessible-by-default -- Set handling of unknown memory regions
set multiple-symbols -- Set the debugger behavior when more than one symbol are possible matches
set non-stop -- Set whether gdb controls the inferior in non-stop mode
set observer -- Set whether gdb controls the inferior in observer mode
set opaque-type-resolution -- Set resolution of opaque struct/class/union types (if set before loading symbols)
set osabi -- Set OS ABI of target
set output-radix -- Set default output radix for printing of values
set overload-resolution -- Set overload resolution in evaluating C++ functions
set pagination -- Set state of GDB output pagination
set powerpc -- Various PowerPC-specific commands
set powerpc exact-watchpoints -- Set whether to use just one debug register for watchpoints on scalars
set powerpc soft-float -- Set whether to use a soft-float ABI
set powerpc vector-abi -- Set the vector ABI
set print -- Generic command for setting how things print
set print address -- Set printing of addresses

set print array -- Set prettyprinting of arrays
set print array-indexes -- Set printing of array indexes
set print asm-demangle -- Set demangling of C++/ObjC names in disassembly listings
set print demangle -- Set demangling of encoded C++/ObjC names when displaying symbols
set print elements -- Set limit on string chars or array elements to print
set print entry-values -- Set printing of function arguments at function entry
set print frame-arguments -- Set printing of non-scalar frame arguments
set print inferior-events -- Set printing of inferior events (e.g.
set print max-symbolic-offset -- Set the largest offset that will be printed in &amp;lt;symbol+1234&amp;gt; form
set print null-stop -- Set printing of char arrays to stop at first null char
set print object -- Set printing of object&#x27;s derived type based on vtable info
set print pascal_static-members -- Set printing of pascal static members
set print pretty -- Set prettyprinting of structures
set print repeats -- Set threshold for repeated print elements
set print sevenbit-strings -- Set printing of 8-bit characters in strings as \nnn
set print static-members -- Set printing of C++ static members
set print symbol -- Set printing of symbol names when printing pointers
set print symbol-filename -- Set printing of source filename and line number with &amp;lt;symbol&amp;gt;
set print thread-events -- Set printing of thread events (such as thread start and exit)
set print type -- Generic command for setting how types print
show print type methods -- Set printing of methods defined in classes
show print type typedefs -- Set printing of typedefs defined in classes
set print union -- Set printing of unions interior to structures
set print vtbl -- Set printing of C++ virtual function tables
set prompt -- Set gdb&#x27;s prompt
set python -- Prefix command for python preference settings
set python print-stack -- Set mode for Python stack dump on error
set radix -- Set default input and output number radices
set ravenscar -- Prefix command for changing Ravenscar-specific settings
set ravenscar task-switching -- Enable or disable support for GNAT Ravenscar tasks
set record -- Set record options

set record full -- Set record options
set record full insn-number-max -- Set record/replay buffer limit
set record full memory-query -- Set whether query if PREC cannot record memory change of next instruction
set record full stop-at-limit -- Set whether record/replay stops when record/replay buffer becomes full
set record function-call-history-size -- Set number of function to print in &quot;record function-call-history&quot;
set record instruction-history-size -- Set number of instructions to print in &quot;record instruction-history&quot;
set remote -- Remote protocol specific variables
set remote P-packet -- Set use of remote protocol `P&#x27; (set-register) packet
set remote TracepointSource-packet -- Set use of remote protocol `TracepointSource&#x27; (TracepointSource) packet
set remote X-packet -- Set use of remote protocol `X&#x27; (binary-download) packet
set remote Z-packet -- Set use of remote protocol `Z&#x27; packets
set remote access-watchpoint-packet -- Set use of remote protocol `Z4&#x27; (access-watchpoint) packet
set remote agent-packet -- Set use of remote protocol `QAgent&#x27; (agent) packet
set remote allow-packet -- Set use of remote protocol `QAllow&#x27; (allow) packet
set remote attach-packet -- Set use of remote protocol `vAttach&#x27; (attach) packet
set remote binary-download-packet -- Set use of remote protocol `X&#x27; (binary-download) packet
set remote breakpoint-commands-packet -- Set use of remote protocol `BreakpointCommands&#x27; (breakpoint-commands) packet
set remote conditional-breakpoints-packet -- Set use of remote protocol `ConditionalBreakpoints&#x27; (conditional-breakpoints) packet
set remote conditional-tracepoints-packet -- Set use of remote protocol `ConditionalTracepoints&#x27; (conditional-tracepoints) packet
set remote disable-btrace-packet -- Set use of remote protocol `Qbtrace:off&#x27; (disable-btrace) packet
set remote disable-randomization-packet -- Set use of remote protocol `QDisableRandomization&#x27; (disable-randomization) packet
set remote enable-btrace-packet -- Set use of remote protocol `Qbtrace:bts&#x27; (enable-btrace) packet
set remote exec-file -- Set the remote pathname for &quot;run&quot;
set remote fast-tracepoints-packet -- Set use of remote protocol `FastTracepoints&#x27; (fast-tracepoints) packet
set remote fetch-register-packet -- Set use of remote protocol `p&#x27; (fetch-register) packet
set remote get-thread-information-block-address-packet -- Set use of remote protocol `qGetTIBAddr&#x27; (get-thread-information-block-address) packet
set remote get-thread-local-storage-address-packet -- Set use of remote protocol `qGetTLSAddr&#x27; (get-thread-local-storage-address) packet

set remote hardware-breakpoint-limit -- Set the maximum number of target hardware breakpoints
set remote hardware-breakpoint-packet -- Set use of remote protocol `Z1&#x27; (hardware-breakpoint) packet
set remote hardware-watchpoint-length-limit -- Set the maximum length (in bytes) of a target hardware watchpoint
set remote hardware-watchpoint-limit -- Set the maximum number of target hardware watchpoints
set remote hostio-close-packet -- Set use of remote protocol `vFile:close&#x27; (hostio-close) packet
set remote hostio-open-packet -- Set use of remote protocol `vFile:open&#x27; (hostio-open) packet
set remote hostio-pread-packet -- Set use of remote protocol `vFile:pread&#x27; (hostio-pread) packet
set remote hostio-pwrite-packet -- Set use of remote protocol `vFile:pwrite&#x27; (hostio-pwrite) packet
set remote hostio-readlink-packet -- Set use of remote protocol `vFile:readlink&#x27; (hostio-readlink) packet
set remote hostio-unlink-packet -- Set use of remote protocol `vFile:unlink&#x27; (hostio-unlink) packet
set remote hwbreak-feature-packet -- Set use of remote protocol `hwbreak-feature&#x27; (hwbreak-feature) packet
set remote install-in-trace-packet -- Set use of remote protocol `InstallInTrace&#x27; (install-in-trace) packet
set remote interrupt-on-connect -- Set whether interrupt-sequence is sent to remote target when gdb connects to
set remote interrupt-sequence -- Set interrupt sequence to remote target
set remote kill-packet -- Set use of remote protocol `vKill&#x27; (kill) packet
set remote library-info-packet -- Set use of remote protocol `qXfer:libraries:read&#x27; (library-info) packet
set remote library-info-svr4-packet -- Set use of remote protocol `qXfer:libraries-svr4:read&#x27; (library-info-svr4) packet
set remote memory-map-packet -- Set use of remote protocol `qXfer:memory-map:read&#x27; (memory-map) packet
set remote memory-read-packet-size -- Set the maximum number of bytes per memory-read packet
set remote memory-write-packet-size -- Set the maximum number of bytes per memory-write packet
set remote noack-packet -- Set use of remote protocol `QStartNoAckMode&#x27; (noack) packet
set remote osdata-packet -- Set use of remote protocol `qXfer:osdata:read&#x27; (osdata) packet
set remote p-packet -- Set use of remote protocol `p&#x27; (fetch-register) packet
set remote pass-signals-packet -- Set use of remote protocol `QPassSignals&#x27; (pass-signals) packet
set remote program-signals-packet -- Set use of remote protocol `QProgramSignals&#x27; (program-signals) packet
set remote query-attached-packet -- Set use of remote protocol `qAttached&#x27; (query-attached) packet
set remote read-aux-vector-packet -- Set use of remote protocol `qXfer:auxv:read&#x27; (read-aux-vector) packet
set remote read-btrace-packet -- Set use of remote protocol `qXfer:btrace&#x27; (read-btrace) packet
set remote read-fdpic-loadmap-packet -- Set use of remote protocol `qXfer:fdpic:read&#x27; (read-fdpic-loadmap) packet
set remote read-sdata-object-packet -- Set use of remote protocol `qXfer:statictrace:read&#x27; (read-sdata-object) packet
set remote read-siginfo-object-packet -- Set use of remote protocol `qXfer:siginfo:read&#x27; (read-siginfo-object) packet

set remote read-spu-object-packet -- Set use of remote protocol `qXfer:spu:read&#x27; (read-spu-object) packet
set remote read-watchpoint-packet -- Set use of remote protocol `Z3&#x27; (read-watchpoint) packet
set remote reverse-continue-packet -- Set use of remote protocol `bc&#x27; (reverse-continue) packet
set remote reverse-step-packet -- Set use of remote protocol `bs&#x27; (reverse-step) packet
set remote run-packet -- Set use of remote protocol `vRun&#x27; (run) packet
set remote search-memory-packet -- Set use of remote protocol `qSearch:memory&#x27; (search-memory) packet
set remote set-register-packet -- Set use of remote protocol `P&#x27; (set-register) packet
set remote software-breakpoint-packet -- Set use of remote protocol `Z0&#x27; (software-breakpoint) packet
set remote static-tracepoints-packet -- Set use of remote protocol `StaticTracepoints&#x27; (static-tracepoints) packet
set remote supported-packets-packet -- Set use of remote protocol `qSupported&#x27; (supported-packets) packet
set remote symbol-lookup-packet -- Set use of remote protocol `qSymbol&#x27; (symbol-lookup) packet
set remote system-call-allowed -- Set if the host system(3) call is allowed for the target
set remote target-features-packet -- Set use of remote protocol `qXfer:features:read&#x27; (target-features) packet
set remote threads-packet -- Set use of remote protocol `qXfer:threads:read&#x27; (threads) packet
set remote trace-buffer-size-packet -- Set use of remote protocol `QTBuffer:size&#x27; (trace-buffer-size) packet
set remote traceframe-info-packet -- Set use of remote protocol `qXfer:trace-frame-info:read&#x27; (traceframe-info) packet
set remote unwind-info-block-packet -- Set use of remote protocol `qXfer:uib:read&#x27; (unwind-info-block) packet
set remote verbose-resume-packet -- Set use of remote protocol `vCont&#x27; (verbose-resume) packet
set remote write-siginfo-object-packet -- Set use of remote protocol `qXfer:siginfo:write&#x27; (write-siginfo-object) packet
set remote write-spu-object-packet -- Set use of remote protocol `qXfer:spu:write&#x27; (write-spu-object) packet
set remote write-watchpoint-packet -- Set use of remote protocol `Z2&#x27; (write-watchpoint) packet
set remoteaddresssize -- Set the maximum size of the address (in bits) in a memory packet
set remotebaud -- Set baud rate for remote serial I/O
set remotebreak -- Set whether to send break if interrupted
set remotecache -- Set cache use for remote targets
set remoteflow -- Set use of hardware flow control for remote serial I/O
set remotelogbase -- Set numerical base for remote session logging
set remotelogfile -- Set filename for remote session recording
set remotetimeout -- Set timeout limit to wait for target to respond
set remotewritesize -- Set the maximum number of bytes per memory write packet (deprecated)
set schedule-multiple -- Set mode for resuming threads of all processes

set scheduler-locking -- Set mode for locking scheduler during execution
set script-extension -- Set mode for script filename extension recognition
set serial -- Set default serial/parallel port configuration
set solib-absolute-prefix -- Set an alternate system root
set solib-search-path -- Set the search path for loading non-absolute shared library symbol files
set stack-cache -- Set cache use for stack access
set step-mode -- Set mode of the step operation
set stop-on-solib-events -- Set stopping for shared library events
set struct-convention -- Set the convention for returning small structs
set substitute-path -- Usage: set substitute-path FROM TO
set sysroot -- Set an alternate system root
set target-async -- Set whether gdb controls the inferior in asynchronous mode
set target-charset -- Set the target character set
set target-file-system-kind -- Set assumed file system kind for target reported file names
set target-wide-charset -- Set the target wide character set
set tcp -- TCP protocol specific variables
set tcp auto-retry -- Set auto-retry on socket connect
set tcp connect-timeout -- Set timeout limit for socket connection
set tdesc -- Set target description specific variables
set tdesc filename -- Set the file to read for an XML target description
set trace-buffer-size -- Set requested size of trace buffer
set trace-commands -- Set tracing of GDB CLI commands
set trace-notes -- Set notes string to use for current and future trace runs
set trace-stop-notes -- Set notes string to use for future tstop commands
set trace-user -- Set the user name to use for current and future trace runs
set trust-readonly-sections -- Set mode for reading from readonly sections
set tui -- TUI configuration variables
set tui active-border-mode -- Set the attribute mode to use for the active TUI window border
set tui border-kind -- Set the kind of border for TUI windows
set tui border-mode -- Set the attribute mode to use for the TUI window borders
set unwind-on-terminating-exception -- Set unwinding of stack if std::terminate is called while in call dummy

set unwindonsignal -- Set unwinding of stack if a signal is received while in a call dummy
set use-coredump-filter -- Set whether gcore should consider /proc/PID/coredump_filter
set use-deprecated-index-sections -- Set whether to use deprecated gdb_index sections
set variable -- Evaluate expression EXP and assign result to variable VAR
set verbose -- Set verbosity
set watchdog -- Set watchdog timer
set width -- Set number of characters where GDB should wrap lines of its output
set write -- Set writing into executable and core files
undisplay -- Cancel some expressions to be displayed when program stops
whatis -- Print data type of expression EXP
x -- Examine memory: x/FMT ADDRESS

Command class: files

add-symbol-file -- Load symbols from FILE
add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file
cd -- Set working directory to DIR for debugger and program being debugged
core-file -- Use FILE as core dump for examining memory and registers
directory -- Add directory DIR to beginning of search path for source files
edit -- Edit specified file or function
exec-file -- Use FILE as program for getting contents of pure memory
file -- Use FILE as program to be debugged
forward-search -- Search for regular expression (see regex(3)) from last line listed
generate-core-file -- Save a core file with the current state of the debugged process
list -- List specified function or line
load -- Dynamically load FILE into the running program
nosharedlibrary -- Unload all shared object library symbols
path -- Add directory DIR(s) to beginning of search path for object files
pwd -- Print working directory
remote -- Manipulate files on the remote system
remote delete -- Delete a remote file

remote get -- Copy a remote file to the local system
remote put -- Copy a local file to the remote system
reverse-search -- Search backward for regular expression (see regex(3)) from last line listed
search -- Search for regular expression (see regex(3)) from last line listed
section -- Change the base address of section SECTION of the exec file to ADDR
sharedlibrary -- Load shared object library symbols for files matching REGEXP
symbol-file -- Load symbol table from executable file FILE

Command class: internals

flushregs -- Force gdb to flush its register cache (maintainer command)
maintenance -- Commands for use by GDB maintainers
maintenance agent -- Translate an expression into remote agent bytecode for tracing
maintenance agent-eval -- Translate an expression into remote agent bytecode for evaluation
maintenance agent-printf -- Translate an expression into remote agent bytecode for evaluation and display the bytecodes
maintenance check-symtabs -- Check consistency of psymtabs and symtabs
maintenance cplus -- C++ maintenance commands
maintenance cplus first_component -- Print the first class/namespace component of NAME
maintenance cplus namespace -- Deprecated placeholder for removed functionality
maintenance demangle -- Demangle a C++/ObjC mangled name
maintenance deprecate -- Deprecate a command
maintenance dump-me -- Get fatal error; make debugger dump its core
maintenance info -- Commands for showing internal info about the program being debugged
maintenance info bfds -- List the BFDs that are currently open
maintenance info breakpoints -- Status of all breakpoints
maintenance info program-spaces -- Info about currently known program spaces
maintenance info psymtabs -- List the partial symbol tables for all object files
maintenance info sections -- List the BFD sections of the exec and core files
maintenance info symtabs -- List the full symbol tables for all object files
maintenance internal-error -- Give GDB an internal error
maintenance internal-warning -- Give GDB an internal warning

maintenance packet -- Send an arbitrary packet to a remote target
maintenance print -- Maintenance command for printing GDB internal state
maintenance print architecture -- Print the internal architecture configuration
maintenance print c-tdesc -- Print the current target description as a C source file
maintenance print cooked-registers -- Print the internal register configuration including cooked values
maintenance print dummy-frames -- Print the contents of the internal dummy-frame stack
maintenance print msymbols -- Print dump of current minimal symbol definitions
maintenance print objfiles -- Print dump of current object file definitions
maintenance print psymbols -- Print dump of current partial symbol definitions
maintenance print raw-registers -- Print the internal register configuration including raw values
maintenance print reggroups -- Print the internal register group names
maintenance print register-groups -- Print the internal register configuration including each register&#x27;s group
maintenance print registers -- Print the internal register configuration
maintenance print remote-registers -- Print the internal register configuration including each register&#x27;s
maintenance print statistics -- Print statistics about internal gdb state
maintenance print symbols -- Print dump of current symbol definitions
maintenance print target-stack -- Print the name of each layer of the internal target stack
maintenance print type -- Print a type chain for a given symbol
maintenance set -- Set GDB internal variables used by the GDB maintainer
maintenance set dwarf2 -- Set DWARF 2 specific variables
maintenance set dwarf2 always-disassemble -- Set whether `info address&#x27; always disassembles DWARF expressions
maintenance set dwarf2 max-cache-age -- Set the upper bound on the age of cached dwarf2 compilation units
maintenance set internal-error -- Configure what GDB does when internal-error is detected
maintenance set internal-error corefile -- Set whether GDB should create a core file of GDB when internal-error is detected
maintenance set internal-error quit -- Set whether GDB should quit when an internal-error is detected
maintenance set internal-warning -- Configure what GDB does when internal-warning is detected
maintenance set internal-warning corefile -- Set whether GDB should create a core file of GDB when internal-warning is detected
maintenance set internal-warning quit -- Set whether GDB should quit when an internal-warning is detected
maintenance set profile -- Set internal profiling
maintenance set show-debug-regs -- Set whether to show variables that mirror the x86 debug registers

maintenance show -- Show GDB internal variables used by the GDB maintainer
maintenance show dwarf2 -- Show DWARF 2 specific variables
maintenance show dwarf2 always-disassemble -- Show whether `info address&#x27; always disassembles DWARF expressions
maintenance show dwarf2 max-cache-age -- Show the upper bound on the age of cached dwarf2 compilation units
maintenance show internal-error -- Show what GDB does when internal-error is detected
maintenance show internal-error corefile -- Show whether GDB will create a core file of GDB when internal-error is detected
maintenance show internal-error quit -- Show whether GDB will quit when an internal-error is detected
maintenance show internal-warning -- Show what GDB does when internal-warning is detected
maintenance show internal-warning corefile -- Show whether GDB will create a core file of GDB when internal-warning is detected
maintenance show internal-warning quit -- Show whether GDB will quit when an internal-warning is detected
maintenance show profile -- Show internal profiling
maintenance show show-debug-regs -- Show whether to show variables that mirror the x86 debug registers
maintenance space -- Set the display of space usage
maintenance time -- Set the display of time usage
maintenance translate-address -- Translate a section name and address to a symbol
maintenance undeprecate -- Undeprecate a command

Command class: obscure

checkpoint -- Fork a duplicate process (experimental)
compare-sections -- Compare section data on target to the exec file
complete -- List the completions for the rest of the line as a command
ignore-errors -- Execute a single command
monitor -- Send a command to the remote monitor (remote targets only)
python -- Evaluate a Python command
python-interactive -- Start an interactive Python prompt
record -- Start recording
record btrace -- Start branch trace recording
record delete -- Delete the rest of execution log and start recording it anew
record full -- Start full execution recording

record full restore -- Restore the execution log from a file
record function-call-history -- Prints the execution history at function granularity
record goto -- Restore the program to its state at instruction number N
record instruction-history -- Print disassembled instructions stored in the execution log
record save -- Save the execution log to a file
record stop -- Stop the record/replay target
restart -- Restart &amp;lt;n&amp;gt;: restore program context from a checkpoint
stop -- There is no `stop&#x27; command

Command class: running

advance -- Continue the program up to the given location (same form as args for break command)
attach -- Attach to a process or file outside of GDB
continue -- Continue program being debugged
detach -- Detach a process or file previously attached
detach checkpoint -- Detach from a checkpoint (experimental)
detach inferiors -- Detach from inferior ID (or list of IDS)
disconnect -- Disconnect from a target
finish -- Execute until selected stack frame returns
handle -- Specify how to handle signals
inferior -- Use this command to switch between inferiors
interrupt -- Interrupt the execution of the debugged program
jump -- Continue program being debugged at specified line or address
kill -- Kill execution of program being debugged
kill inferiors -- Kill inferior ID (or list of IDs)
next -- Step program
nexti -- Step one instruction
reverse-continue -- Continue program being debugged but run it in reverse
reverse-finish -- Execute backward until just before selected stack frame is called
reverse-next -- Step program backward
reverse-nexti -- Step backward one instruction

reverse-step -- Step program backward until it reaches the beginning of another source line
reverse-stepi -- Step backward exactly one instruction
run -- Start debugged program
signal -- Continue program with the specified signal
start -- Run the debugged program until the beginning of the main procedure
step -- Step program until it reaches a different source line
stepi -- Step one instruction exactly
target -- Connect to a target machine or process
target child -- Unix child process (started by the &quot;run&quot; command)
target core -- Use a core file as a target
target exec -- Use an executable file as a target
target extended-remote -- Use a remote computer via a serial line
target multi-thread -- Threads and pthreads support
target ravenscar -- Ravenscar tasks support
target record -- Log program while executing and replay execution from log
target record-btrace -- Collect control-flow trace and provide the execution history
target record-core -- Log program while executing and replay execution from log
target record-full -- Log program while executing and replay execution from log
target remote -- Use a remote computer via a serial line
target spu -- SPU multi-architecture support
target tfile -- Use a trace file as a target
task -- Use this command to switch between Ada tasks
thread -- Use this command to switch between threads
thread apply -- Apply a command to a list of threads
thread apply all -- Apply a command to all threads
thread find -- Find threads that match a regular expression
thread name -- Set the current thread&#x27;s name
until -- Execute until the program reaches a source line greater than the current

Command class: stack


backtrace -- Print backtrace of all stack frames
bt -- Print backtrace of all stack frames
down -- Select and print stack frame called by this one
frame -- Select and print a stack frame
return -- Make selected stack frame return to its caller
select-frame -- Select a stack frame without printing anything
up -- Select and print stack frame that called this one

Command class: status

info -- Generic command for showing things about the program being debugged
info address -- Describe where symbol SYM is stored
info all-registers -- List of all registers and their contents
info args -- Argument variables of current stack frame
info auto-load -- Print current status of auto-loaded files
info auto-load gdb-scripts -- Print the list of automatically loaded sequences of commands
info auto-load libthread-db -- Print the list of loaded inferior specific libthread_db
info auto-load local-gdbinit -- Print whether current directory .gdbinit file has been loaded
info auto-load python-scripts -- Print the list of automatically loaded Python scripts
info auto-load-scripts -- Print the list of automatically loaded Python scripts
info auxv -- Display the inferior&#x27;s auxiliary vector
info bookmarks -- Status of user-settable bookmarks
info breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)
info checkpoints -- IDs of currently known checkpoints
info classes -- All Objective-C classes
info common -- Print out the values contained in a Fortran COMMON block
info copying -- Conditions for redistributing copies of GDB
info dcache -- Print information on the dcache performance
info display -- Expressions to display when program stops
info extensions -- All filename extensions associated with a source language
info files -- Names of targets and files being debugged

info float -- Print the status of the floating point unit
info frame -- All about selected stack frame
info frame-filter -- List all registered Python frame-filters
info functions -- All function names
info handle -- What debugger does when program gets various signals
info inferiors -- IDs of specified inferiors (all inferiors if no argument)
info line -- Core addresses of the code for a source line
info locals -- Local variables of current stack frame
info macro -- Show the definition of MACRO
info macros -- Show the definitions of all macros at LINESPEC
info mem -- Memory region attributes
info os -- Show OS data ARG
info pretty-printer -- GDB command to list all registered pretty-printers
info probes -- Show available static probes
info probes all -- Show information about all type of probes
info probes stap -- Show information about SystemTap static probes
info proc -- Show /proc process information about any running process
info proc all -- List all available /proc info
info proc cmdline -- List command line arguments of the process
info proc cwd -- List current working directory of the process
info proc exe -- List absolute filename for executable of the process
info proc mappings -- List of mapped memory regions
info proc stat -- List process info from /proc/PID/stat
info proc status -- List process info from /proc/PID/status
info program -- Execution status of the program
info record -- Info record options
info registers -- List of integer registers and their contents
info scope -- List the variables local to a scope
info selectors -- All Objective-C selectors
info set -- Show all GDB settings
info sharedlibrary -- Status of loaded shared object libraries

info signals -- What debugger does when program gets various signals
info skip -- Display the status of skips
info source -- Information about the current source file
info sources -- Source files in the program
info stack -- Backtrace of the stack
info static-tracepoint-markers -- List target static tracepoints markers
info symbol -- Describe what symbol is at location ADDR
info target -- Names of targets and files being debugged
info tasks -- Provide information about all known Ada tasks
info terminal -- Print inferior&#x27;s saved terminal status
info threads -- Display currently known threads
info tracepoints -- Status of specified tracepoints (all tracepoints if no argument)
info tvariables -- Status of trace state variables and their values
info type-printers -- GDB command to list all registered type-printers
info types -- All type names
info variables -- All global and static variable names
info vector -- Print the status of the vector unit
info vtbl -- Show the virtual function table for a C++ object
info warranty -- Various kinds of warranty you do not have
info watchpoints -- Status of specified watchpoints (all watchpoints if no argument)
info win -- List of all displayed windows
macro -- Prefix for commands dealing with C preprocessor macros
macro define -- Define a new C/C++ preprocessor macro
macro expand -- Fully expand any C/C++ preprocessor macro invocations in EXPRESSION
macro expand-once -- Expand C/C++ preprocessor macro invocations appearing directly in EXPRESSION
macro list -- List all the macros defined using the `macro define&#x27; command
macro undef -- Remove the definition of the C/C++ preprocessor macro with the given name
show -- Generic command for showing things about the debugger
show ada -- Generic command for showing Ada-specific settings
show ada trust-PAD-over-XVS -- Show whether an optimization trusting PAD types over XVS types is activated
show agent -- Show debugger&#x27;s willingness to use agent as a helper

show annotate -- Show annotation_level
show architecture -- Show architecture of target
show args -- Show argument list to give program being debugged when it is started
show auto-load -- Show auto-loading specific settings
show auto-load gdb-scripts -- Show whether auto-loading of canned sequences of commands scripts is enabled
show auto-load libthread-db -- Show whether auto-loading inferior specific libthread_db is enabled
show auto-load local-gdbinit -- Show whether auto-loading .gdbinit script in current directory is enabled
show auto-load python-scripts -- Show the debugger&#x27;s behaviour regarding auto-loaded Python scripts
show auto-load safe-path -- Show the list of files and directories that are safe for auto-loading
show auto-load scripts-directory -- Show the list of directories from which to load auto-loaded scripts
show auto-load-scripts -- Show the debugger&#x27;s behaviour regarding auto-loaded Python scripts
show auto-solib-add -- Show autoloading of shared library symbols
show backtrace -- Show backtrace specific variables
show backtrace limit -- Show the upper bound on the number of backtrace levels
show backtrace past-entry -- Show whether backtraces should continue past the entry point of a program
show backtrace past-main -- Show whether backtraces should continue past &quot;main&quot;
show basenames-may-differ -- Show whether a source file may have multiple base names
show breakpoint -- Breakpoint specific settings
show breakpoint always-inserted -- Show mode for inserting breakpoints
show breakpoint auto-hw -- Show automatic usage of hardware breakpoints
show breakpoint condition-evaluation -- Show mode of breakpoint condition evaluation
show breakpoint pending -- Show debugger&#x27;s behavior regarding pending breakpoints
show build-id-core-loads -- Show whether CORE-FILE loads the build-id associated files automatically
show build-id-verbose -- Show debugging level of the build-id locator
show can-use-hw-watchpoints -- Show debugger&#x27;s willingness to use watchpoint hardware
show case-sensitive -- Show case sensitivity in name search
show charset -- Show the host and target character sets
show check -- Show the status of the type/range checker
show check range -- Show range checking
show check type -- Show strict type checking
show circular-trace-buffer -- Show target&#x27;s use of circular trace buffer

show coerce-float-to-double -- Show coercion of floats to doubles when calling functions
show commands -- Show the history of commands you typed
show complaints -- Show max number of complaints about incorrect symbols
show confirm -- Show whether to confirm potentially dangerous operations
show convenience -- Debugger convenience (&quot;$foo&quot;) variables and functions
show copying -- Conditions for redistributing copies of GDB
show cp-abi -- Show the ABI used for inspecting C++ objects
show data-directory -- Show GDB&#x27;s data directory
show dcache -- Show dcachesettings
show dcache line-size -- Show dcache line size
show dcache size -- Show number of dcache lines
show debug -- Generic command for showing gdb debugging flags
show debug arch -- Show architecture debugging
show debug auto-load -- Show auto-load verifications debugging
show debug check-physname -- Show cross-checking of &quot;physname&quot; code against demangler
show debug coff-pe-read -- Show coff PE read debugging
show debug displaced -- Show displaced stepping debugging
show debug dwarf2-die -- Show debugging of the dwarf2 DIE reader
show debug dwarf2-read -- Show debugging of the dwarf2 reader
show debug entry-values -- Show entry values and tail call frames debugging
show debug expression -- Show expression debugging
show debug frame -- Show frame debugging
show debug infrun -- Show inferior debugging
show debug jit -- Show JIT debugging
show debug libthread-db -- Show libthread-db debugging
show debug lin-lwp -- Show debugging of GNU/Linux lwp module
show debug notification -- Show debugging of async remote notification
show debug observer -- Show observer debugging
show debug overload -- Show debugging of C++ overloading
show debug parser -- Show parser debugging
show debug record -- Show debugging of record/replay feature

show debug remote -- Show debugging of remote protocol
show debug serial -- Show serial debugging
show debug stap-expression -- Show SystemTap expression debugging
show debug symtab-create -- Show debugging of symbol table creation
show debug target -- Show target debugging
show debug timestamp -- Show timestamping of debugging messages
show debug xml -- Show XML parser debugging
show debug-file-directory -- Show the directories where separate debug symbols are searched for
show debugvarobj -- Show varobj debugging
show default-collect -- Show the list of expressions to collect by default
show demangle-style -- Show the current C++ demangling style
show detach-on-fork -- Show whether gdb will detach the child of a fork
show directories -- Show the search path for finding source files
show disable-randomization -- Show disabling of debuggee&#x27;s virtual address space randomization
show disassemble-next-line -- Show whether to disassemble next source line or insn when execution stops
show disassembly-flavor -- Show the disassembly flavor
show disconnected-dprintf -- Show whether dprintf continues after GDB disconnects
show disconnected-tracing -- Show whether tracing continues after GDB disconnects
show displaced-stepping -- Show debugger&#x27;s willingness to use displaced stepping
show dprintf-channel -- Show the channel to use for dynamic printf
show dprintf-function -- Show the function to use for dynamic printf
show dprintf-style -- Show the style of usage for dynamic printf
show dump-excluded-mappings -- Show whether gcore should dump mappings marked with the VM_DONTDUMP flag
show editing -- Show editing of command lines as they are typed
show endian -- Show endianness of target
show environment -- The environment to give the program
show exec-direction -- Show direction of execution (forward/reverse)
show exec-done-display -- Show notification of completion for asynchronous execution commands
show exec-wrapper -- Show the wrapper for running programs
show extended-prompt -- Show the extended prompt
show extension-language -- Show mapping between filename extension and source language

show filename-display -- Show how to display filenames
show follow-exec-mode -- Show debugger response to a program call of exec
show follow-fork-mode -- Show debugger response to a program call of fork or vfork
show frame-filter -- Prefix command for &#x27;show&#x27; frame-filter related operations
show frame-filter priority -- GDB command to show the priority of the specified frame-filter
show gnutarget -- Show the current BFD target
show height -- Show number of lines in a page for GDB output pagination
show history -- Generic command for showing command history parameters
show history expansion -- Show history expansion on command input
show history filename -- Show the filename in which to record the command history
show history save -- Show saving of the history record on exit
show history size -- Show the size of the command history
show host-charset -- Show the host character set
show inferior-tty -- Show terminal for future runs of program being debugged
show input-radix -- Show default input radix for entering numbers
show interactive-mode -- Show whether GDB&#x27;s standard input is a terminal
show language -- Show the current source language
show libthread-db-search-path -- Show the current search path or libthread_db
show listsize -- Show number of source lines gdb will list by default
show logging -- Show logging options
show logging file -- Show the current logfile
show logging overwrite -- Show whether logging overwrites or appends to the log file
show logging redirect -- Show the logging output mode
show max-user-call-depth -- Show the max call depth for non-python user-defined commands
show may-insert-breakpoints -- Show permission to insert breakpoints in the target
show may-insert-fast-tracepoints -- Show permission to insert fast tracepoints in the target
show may-insert-tracepoints -- Show permission to insert tracepoints in the target
show may-interrupt -- Show permission to interrupt or signal the target
show may-write-memory -- Show permission to write into target memory
show may-write-registers -- Show permission to write into registers
show mem -- Memory regions settings

show mem  inaccessible-by-default -- Show handling of unknown memory regions
show multiple-symbols -- Show how the debugger handles ambiguities in expressions
show non-stop -- Show whether gdb controls the inferior in non-stop mode
show observer -- Show whether gdb controls the inferior in observer mode
show opaque-type-resolution -- Show resolution of opaque struct/class/union types (if set before loading symbols)
show osabi -- Show OS ABI of target
show output-radix -- Show default output radix for printing of values
show overload-resolution -- Show overload resolution in evaluating C++ functions
show pagination -- Show state of GDB output pagination
show paths -- Current search path for finding object files
show powerpc -- Various PowerPC-specific commands
show powerpc exact-watchpoints -- Show whether to use just one debug register for watchpoints on scalars
show powerpc soft-float -- Show whether to use a soft-float ABI
show powerpc vector-abi -- Show the vector ABI
show print -- Generic command for showing print settings
show print address -- Show printing of addresses
show print array -- Show prettyprinting of arrays
show print array-indexes -- Show printing of array indexes
show print asm-demangle -- Show demangling of C++/ObjC names in disassembly listings
show print demangle -- Show demangling of encoded C++/ObjC names when displaying symbols
show print elements -- Show limit on string chars or array elements to print
show print entry-values -- Show printing of function arguments at function entry
show print frame-arguments -- Show printing of non-scalar frame arguments
show print inferior-events -- Show printing of inferior events (e.g.
show print max-symbolic-offset -- Show the largest offset that will be printed in &amp;lt;symbol+1234&amp;gt; form
show print null-stop -- Show printing of char arrays to stop at first null char
show print object -- Show printing of object&#x27;s derived type based on vtable info
show print pascal_static-members -- Show printing of pascal static members
show print pretty -- Show prettyprinting of structures
show print repeats -- Show threshold for repeated print elements
show print sevenbit-strings -- Show printing of 8-bit characters in strings as \nnn

show print static-members -- Show printing of C++ static members
show print symbol -- Show printing of symbol names when printing pointers
show print symbol-filename -- Show printing of source filename and line number with &amp;lt;symbol&amp;gt;
show print thread-events -- Show printing of thread events (such as thread start and exit)
show print type -- Generic command for showing type-printing settings
show print type methods -- Show printing of methods defined in classes
show print type typedefs -- Show printing of typedefs defined in classes
show print union -- Show printing of unions interior to structures
show print vtbl -- Show printing of C++ virtual function tables
show prompt -- Show gdb&#x27;s prompt
show python -- Prefix command for python preference settings
show python print-stack -- Show the mode of Python stack printing on error
show radix -- Show the default input and output number radices
show ravenscar -- Prefix command for showing Ravenscar-specific settings
show ravenscar task-switching -- Show whether support for GNAT Ravenscar tasks is enabled
show record -- Show record options
show record full -- Show record options
show record full insn-number-max -- Show record/replay buffer limit
show record full memory-query -- Show whether query if PREC cannot record memory change of next instruction
show record full stop-at-limit -- Show whether record/replay stops when record/replay buffer becomes full
show record function-call-history-size -- Show number of functions to print in &quot;record function-call-history&quot;
show record instruction-history-size -- Show number of instructions to print in &quot;record instruction-history&quot;
show remote -- Remote protocol specific variables
show remote P-packet -- Show current use of remote protocol `P&#x27; (set-register) packet
show remote TracepointSource-packet -- Show current use of remote protocol `TracepointSource&#x27; (TracepointSource) packet
show remote X-packet -- Show current use of remote protocol `X&#x27; (binary-download) packet
show remote Z-packet -- Show use of remote protocol `Z&#x27; packets
show remote access-watchpoint-packet -- Show current use of remote protocol `Z4&#x27; (access-watchpoint) packet
show remote agent-packet -- Show current use of remote protocol `QAgent&#x27; (agent) packet
show remote allow-packet -- Show current use of remote protocol `QAllow&#x27; (allow) packet
show remote attach-packet -- Show current use of remote protocol `vAttach&#x27; (attach) packet

show remote binary-download-packet -- Show current use of remote protocol `X&#x27; (binary-download) packet
show remote breakpoint-commands-packet -- Show current use of remote protocol `BreakpointCommands&#x27; (breakpoint-commands) packet
show remote conditional-breakpoints-packet -- Show current use of remote protocol `ConditionalBreakpoints&#x27; (conditional-breakpoints) packet
show remote conditional-tracepoints-packet -- Show current use of remote protocol `ConditionalTracepoints&#x27; (conditional-tracepoints) packet
show remote disable-btrace-packet -- Show current use of remote protocol `Qbtrace:off&#x27; (disable-btrace) packet
show remote disable-randomization-packet -- Show current use of remote protocol `QDisableRandomization&#x27; (disable-randomization) packet
show remote enable-btrace-packet -- Show current use of remote protocol `Qbtrace:bts&#x27; (enable-btrace) packet
show remote exec-file -- Show the remote pathname for &quot;run&quot;
show remote fast-tracepoints-packet -- Show current use of remote protocol `FastTracepoints&#x27; (fast-tracepoints) packet
show remote fetch-register-packet -- Show current use of remote protocol `p&#x27; (fetch-register) packet
show remote get-thread-information-block-address-packet -- Show current use of remote protocol `qGetTIBAddr&#x27; (get-thread-information-block-address) packet
show remote get-thread-local-storage-address-packet -- Show current use of remote protocol `qGetTLSAddr&#x27; (get-thread-local-storage-address) packet
show remote hardware-breakpoint-limit -- Show the maximum number of target hardware breakpoints
show remote hardware-breakpoint-packet -- Show current use of remote protocol `Z1&#x27; (hardware-breakpoint) packet
show remote hardware-watchpoint-length-limit -- Show the maximum length (in bytes) of a target hardware watchpoint
show remote hardware-watchpoint-limit -- Show the maximum number of target hardware watchpoints
show remote hostio-close-packet -- Show current use of remote protocol `vFile:close&#x27; (hostio-close) packet
show remote hostio-open-packet -- Show current use of remote protocol `vFile:open&#x27; (hostio-open) packet
show remote hostio-pread-packet -- Show current use of remote protocol `vFile:pread&#x27; (hostio-pread) packet
show remote hostio-pwrite-packet -- Show current use of remote protocol `vFile:pwrite&#x27; (hostio-pwrite) packet
show remote hostio-readlink-packet -- Show current use of remote protocol `vFile:readlink&#x27; (hostio-readlink) packet
show remote hostio-unlink-packet -- Show current use of remote protocol `vFile:unlink&#x27; (hostio-unlink) packet
show remote hwbreak-feature-packet -- Show current use of remote protocol `hwbreak-feature&#x27; (hwbreak-feature) packet
show remote install-in-trace-packet -- Show current use of remote protocol `InstallInTrace&#x27; (install-in-trace) packet
show remote interrupt-on-connect --         Show whether interrupt-sequence is sent to remote target when gdb connects to

show remote interrupt-sequence -- Show interrupt sequence to remote target
show remote kill-packet -- Show current use of remote protocol `vKill&#x27; (kill) packet
show remote library-info-packet -- Show current use of remote protocol `qXfer:libraries:read&#x27; (library-info) packet
show remote library-info-svr4-packet -- Show current use of remote protocol `qXfer:libraries-svr4:read&#x27; (library-info-svr4) packet
show remote memory-map-packet -- Show current use of remote protocol `qXfer:memory-map:read&#x27; (memory-map) packet
show remote memory-read-packet-size -- Show the maximum number of bytes per memory-read packet
show remote memory-write-packet-size -- Show the maximum number of bytes per memory-write packet
show remote noack-packet -- Show current use of remote protocol `QStartNoAckMode&#x27; (noack) packet
show remote osdata-packet -- Show current use of remote protocol `qXfer:osdata:read&#x27; (osdata) packet
show remote p-packet -- Show current use of remote protocol `p&#x27; (fetch-register) packet
show remote pass-signals-packet -- Show current use of remote protocol `QPassSignals&#x27; (pass-signals) packet
show remote program-signals-packet -- Show current use of remote protocol `QProgramSignals&#x27; (program-signals) packet
show remote query-attached-packet -- Show current use of remote protocol `qAttached&#x27; (query-attached) packet
show remote read-aux-vector-packet -- Show current use of remote protocol `qXfer:auxv:read&#x27; (read-aux-vector) packet
show remote read-btrace-packet -- Show current use of remote protocol `qXfer:btrace&#x27; (read-btrace) packet
show remote read-fdpic-loadmap-packet -- Show current use of remote protocol `qXfer:fdpic:read&#x27; (read-fdpic-loadmap) packet
show remote read-sdata-object-packet -- Show current use of remote protocol `qXfer:statictrace:read&#x27; (read-sdata-object) packet
show remote read-siginfo-object-packet -- Show current use of remote protocol `qXfer:siginfo:read&#x27; (read-siginfo-object) packet
show remote read-spu-object-packet -- Show current use of remote protocol `qXfer:spu:read&#x27; (read-spu-object) packet
show remote read-watchpoint-packet -- Show current use of remote protocol `Z3&#x27; (read-watchpoint) packet
show remote reverse-continue-packet -- Show current use of remote protocol `bc&#x27; (reverse-continue) packet
show remote reverse-step-packet -- Show current use of remote protocol `bs&#x27; (reverse-step) packet
show remote run-packet -- Show current use of remote protocol `vRun&#x27; (run) packet
show remote search-memory-packet -- Show current use of remote protocol `qSearch:memory&#x27; (search-memory) packet
show remote set-register-packet -- Show current use of remote protocol `P&#x27; (set-register) packet
show remote software-breakpoint-packet -- Show current use of remote protocol `Z0&#x27; (software-breakpoint) packet
show remote static-tracepoints-packet -- Show current use of remote protocol `StaticTracepoints&#x27; (static-tracepoints) packet

show remote supported-packets-packet -- Show current use of remote protocol `qSupported&#x27; (supported-packets) packet
show remote symbol-lookup-packet -- Show current use of remote protocol `qSymbol&#x27; (symbol-lookup) packet
show remote system-call-allowed -- Show if the host system(3) call is allowed for the target
show remote target-features-packet -- Show current use of remote protocol `qXfer:features:read&#x27; (target-features) packet
show remote threads-packet -- Show current use of remote protocol `qXfer:threads:read&#x27; (threads) packet
show remote trace-buffer-size-packet -- Show current use of remote protocol `QTBuffer:size&#x27; (trace-buffer-size) packet
show remote traceframe-info-packet -- Show current use of remote protocol `qXfer:trace-frame-info:read&#x27; (traceframe-info) packet
show remote unwind-info-block-packet -- Show current use of remote protocol `qXfer:uib:read&#x27; (unwind-info-block) packet
show remote verbose-resume-packet -- Show current use of remote protocol `vCont&#x27; (verbose-resume) packet
show remote write-siginfo-object-packet -- Show current use of remote protocol `qXfer:siginfo:write&#x27; (write-siginfo-object) packet
show remote write-spu-object-packet -- Show current use of remote protocol `qXfer:spu:write&#x27; (write-spu-object) packet
show remote write-watchpoint-packet -- Show current use of remote protocol `Z2&#x27; (write-watchpoint) packet
show remoteaddresssize -- Show the maximum size of the address (in bits) in a memory packet
show remotebaud -- Show baud rate for remote serial I/O
show remotebreak -- Show whether to send break if interrupted
show remotecache -- Show cache use for remote targets
show remoteflow -- Show use of hardware flow control for remote serial I/O
show remotelogbase -- Show numerical base for remote session logging
show remotelogfile -- Show filename for remote session recording
show remotetimeout -- Show timeout limit to wait for target to respond
show remotewritesize -- Show the maximum number of bytes per memory write packet (deprecated)
show schedule-multiple -- Show mode for resuming threads of all processes
show scheduler-locking -- Show mode for locking scheduler during execution
show script-extension -- Show mode for script filename extension recognition
show serial -- Show default serial/parallel port configuration
show solib-absolute-prefix -- Show the current system root
show solib-search-path -- Show the search path for loading non-absolute shared library symbol files
show stack-cache -- Show cache use for stack access
show step-mode -- Show mode of the step operation

show stop-on-solib-events -- Show stopping for shared library events
show struct-convention -- Show the convention for returning small structs
show substitute-path -- Usage: show substitute-path [FROM]
show sysroot -- Show the current system root
show target-async -- Show whether gdb controls the inferior in asynchronous mode
show target-charset -- Show the target character set
show target-file-system-kind -- Show assumed file system kind for target reported file names
show target-wide-charset -- Show the target wide character set
show tcp -- TCP protocol specific variables
show tcp auto-retry -- Show auto-retry on socket connect
show tcp connect-timeout -- Show timeout limit for socket connection
show tdesc -- Show target description specific variables
show tdesc filename -- Show the file to read for an XML target description
show trace-buffer-size -- Show requested size of trace buffer
show trace-commands -- Show state of GDB CLI command tracing
show trace-notes -- Show the notes string to use for current and future trace runs
show trace-stop-notes -- Show the notes string to use for future tstop commands
show trace-user -- Show the user name to use for current and future trace runs
show trust-readonly-sections -- Show mode for reading from readonly sections
show tui -- TUI configuration variables
show tui active-border-mode -- Show the attribute mode to use for the active TUI window border
show tui border-kind -- Show the kind of border for TUI windows
show tui border-mode -- Show the attribute mode to use for the TUI window borders
show unwind-on-terminating-exception -- Show unwinding of stack if std::terminate() is called while in a call dummy
show unwindonsignal -- Show unwinding of stack if a signal is received while in a call dummy
show use-coredump-filter -- Show whether gcore should consider /proc/PID/coredump_filter
show use-deprecated-index-sections -- Show whether to use deprecated gdb_index sections
show user -- Show definitions of non-python user defined commands
show values -- Elements of value history around item number IDX (or last ten)
show verbose -- Show verbosity
show version -- Show what version of GDB this is

show warranty -- Various kinds of warranty you do not have
show watchdog -- Show watchdog timer
show width -- Show number of characters where GDB should wrap lines of its output
show write -- Show writing into executable and core files

Command class: support

! -- Execute the rest of the line as a shell command
add-auto-load-safe-path -- Add entries to the list of directories from which it is safe to auto-load files
add-auto-load-scripts-directory -- Add entries to the list of directories from which to load auto-loaded scripts
alias -- Define a new command that is an alias of an existing command
apropos -- Search for commands matching a REGEXP
define -- Define a new command name
document -- Document a user-defined command
dont-repeat -- Don&#x27;t repeat this command
down-silently -- Same as the `down&#x27; command
echo -- Print a constant string
help -- Print list of commands
if -- Execute nested commands once IF the conditional expression is non zero
interpreter-exec -- Execute a command in an interpreter
make -- Run the ``make&#x27;&#x27; program using the rest of the line as arguments
overlay -- Commands for debugging overlays
overlay auto -- Enable automatic overlay debugging
overlay list-overlays -- List mappings of overlay sections
overlay load-target -- Read the overlay mapping state from the target
overlay manual -- Enable overlay debugging
overlay map-overlay -- Assert that an overlay section is mapped
overlay off -- Disable overlay debugging
overlay unmap-overlay -- Assert that an overlay section is unmapped
quit -- Exit gdb
shell -- Execute the rest of the line as a shell command

source -- Read commands from a file named FILE
up-silently -- Same as the `up&#x27; command
while -- Execute nested commands WHILE the conditional expression is non zero

Command class: tracepoints

actions -- Specify the actions to be taken at a tracepoint
collect -- Specify one or more data items to be collected at a tracepoint
end -- Ends a list of commands or actions
passcount -- Set the passcount for a tracepoint
save-tracepoints -- Save current tracepoint definitions as a script
tdump -- Print everything collected at the current tracepoint
teval -- Specify one or more expressions to be evaluated at a tracepoint
tfind -- Select a trace frame;
tfind end -- De-select any trace frame and resume &#x27;live&#x27; debugging
tfind line -- Select a trace frame by source line
tfind none -- De-select any trace frame and resume &#x27;live&#x27; debugging
tfind outside -- Select a trace frame whose PC is outside the given range (exclusive)
tfind pc -- Select a trace frame by PC
tfind range -- Select a trace frame whose PC is in the given range (inclusive)
tfind start -- Select the first trace frame in the trace buffer
tfind tracepoint -- Select a trace frame by tracepoint number
tsave -- Save the trace data to a file
tstart -- Start trace data collection
tstatus -- Display the status of the current trace data collection
tstop -- Stop trace data collection
tvariable -- Define a trace state variable
while-stepping -- Specify single-stepping behavior at a tracepoint

Command class: user-defined

Unclassified commands

add-inferior -- Add a new inferior
clone-inferior -- Clone inferior ID
eval -- Convert &quot;printf format string&quot;
function -- Placeholder command for showing help on convenience functions
function _memeq -- $_memeq - compare bytes of memory
function _regex -- $_regex - check if a string matches a regular expression
function _streq -- $_streq - check string equality
function _strlen -- $_strlen - compute string length
function caller_is -- Return True if the calling function&#x27;s name is equal to a string
function caller_matches -- Return True if the calling function&#x27;s name matches a string
function in_scope -- Return True if all the given variables or macros are in scope
jit-reader-load -- Load FILE as debug info reader and unwinder for JIT compiled code
jit-reader-unload -- Unload the currently loaded JIT debug info reader
pahole -- Show the holes in a structure
remove-inferiors -- Remove inferior ID (or list of IDs)
unset -- Complement to certain &quot;set&quot; commands
unset environment -- Cancel environment variable VAR for the program
unset exec-wrapper -- Disable use of an execution wrapper
unset substitute-path -- Usage: unset substitute-path [FROM]
unset tdesc -- Unset target description specific variables
unset tdesc filename -- Unset the file to read for an XML target description&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; &lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://sourceware.org/gdb/onlinedocs/gdb/&lt;/p&gt;
&lt;p&gt;https://github.com/hellogcc/100-gdb-tips&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c99d06f15be7cb086ab9a22e14f89745</guid>
<title>我月薪8000，为什么还是很焦虑？</title>
<link>https://toutiao.io/k/x8qb6x9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小老弟预测师来了一篇投稿，一起来看看&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受疫情影响，最近社会上多了一些负能量的信息，我观察到很多人的心态和情绪都受到了影响，表现出来就是&lt;strong&gt;“精神内耗”&lt;/strong&gt;，“对未来不确定性增强的强烈焦虑”，“做事情没有动力”，“跟他人抱怨自己的不满”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我也受到了较多的影响，表现出来就是情绪不稳定，容易焦虑和烦躁。坐车时和司机大哥聊天，他说我这种状态可能是&lt;strong&gt;抑郁症的前兆&lt;/strong&gt;。我立刻意识到问题的严重性，通过对情绪的觉察和分析，并经过一系列的自我调整和外界的帮助，我花了一周时间终于从这种不安烦躁的情绪中走了出来，&lt;strong&gt;终于可以真正的做到，拥抱变化，不逃避现实，积极的面对生活。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5535353535353535&quot; data-type=&quot;png&quot; data-w=&quot;990&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTA2gwkEDQcdB0pvZwPOLt7W0gro3BiarseZiaOzcBuwcsOn7D8Jz2kRhHV0PQ1iaEKcG63M8WnqxBOxw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;PS：注意这个“终于可以真正的做到，拥抱变化，不逃避现实，积极的面对生活”&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我将这些经历和技巧总结为解决情绪问题的经验，希望可以给大家一点温暖，一些正能量，以及一些从消极状态走出来的解决思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;识别负面情绪&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，从消极状态走出来的关键是什么呢？我认为是觉察到负面情绪对自己的影响以及意识到管理情绪的重要性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说觉察到负面情绪对自己的影响很重要呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想，适度的焦虑对生活是有益的，它会帮助我们更好的去努力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而过度的焦虑往往影响我们的进步，让我们进入一个“焦虑→无奈→痛苦→焦虑”的怪圈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，短期负面的情绪可以激发我们的进步，伟大的成功都是从痛苦的反思中得到的，但是长期的负面情绪，一定会把人搞垮，极端的是自己患上抑郁症或者躁郁症，或者对别人进行伤害。因此，及时识别出自己的负面情绪，找出它产生的原因，想办法解决它，让自己处于好的状态，是当下很重要的事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;情绪管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么说管理情绪很重要呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，情绪是关系管理，精力管理的重要一环。情绪不好的时候，自身的能量感会大大降低，对外会输出一些负能量，对内表现出就是做事的动力会慢慢降低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，情绪是时间管理，生活幸福度的重要一环，没有管理好情绪会导致“精神内耗”，进而做事的效率会大大降低，我们容易被未来的焦虑和担忧扰乱心神，很难专注于当下做的事情，那么工作效率就会降低，时间就管理不好，而这种很难专注的情况也会导致心流的次数和频率降低，进而我们的生活幸福度也会降低，而这些又会导致我们的情绪更加不好，似乎进入了一个死循环啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何调整我们的情绪呢？我认为有内部找改变和外部求温暖两种思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;情绪管理方法论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部找改变的话，可以用情绪ABC模型或者找偶像的思路，ABC模型是说一个事件用不同的信念可以产生不同的情绪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如天下雨了，有人感觉很痛苦，他觉得美好的计划有泡汤了；而有的人，可以去欣赏雨中的植物，在雨中跳个舞。因此，如果我们尝试找到事件的积极面，乐观面，可能可以调整我们的情绪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从这些角度进行思考：看看情绪受何影响，自己的担忧是什么，如果用积极的角度看它，可以得到怎样的解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找偶像的思路是说，可以多用一些历史名人或者伟大人物的事迹激励自我，天底下无新鲜事，我们的问题别人也遇到过，看看他们是用什么样的心态面对的，怎么处理的，也会让我们更加的有底气应对现在不确定性的世界。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8235294117647058&quot; data-type=&quot;png&quot; data-w=&quot;680&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTA2gwkEDQcdB0pvZwPOLt7W7Hs0CicWXV6XhP1MQhg1yAMKB2AVYBpq4BKE4EA6oBTqRhgQn488Ocg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;外部求温暖的话，可以用寻找正能量躲避负能量的思路。寻找正能量是说我们可以出去走走，感受美好的事物，和朋友聊点开心的事情，多关注美好的事情，多做一些可以产生心流的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;躲避负能量是说，在“觉察到负面情绪对自己的影响”这一步，我们要分析出影响自己产生负面情绪的事情是什么，然后离它远远的。这不是自欺欺人，这是撞了南墙后的随机应变，是愚公移山的另一种替代方案：绕道而行。打不过我跑还不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的一些认识可能有些抽象，具体分享下我是如何解决从情绪问题中走出来的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把焦虑的事情写下来，是一种直面问题的好方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出去走走，打打球，逛逛街，跟同学一起吃饭。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和朋友聊天，找些正能量的内容，发现自己很容易被正能量的人治愈，他治愈我自己也很快乐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读书，读书给人治愈，这个时候看些心灵鸡汤蛮治愈的，推荐《你的生命有哪些可能》。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看高人文章找温暖，我从一个大佬那里学来的道理就是：不确定性中更要保持好的心态和让我自己保持成长的状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远离负面信息源，少看群聊，或者看了不要参与他们的讨论。每一次自己输出负面，都是在助纣为虐，都是在伤害这个世界，不如多点正能量啊。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;改变心态，与其在真实世界里头破血流，不要被自己的恐惧吓死。我把疫情下的生活看成露天的密室逃脱，时刻保持危机感，但也要勇敢前进，这也是一种很有意思的体验。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，送大家一句话：世上只有一种英雄主义，就是在认清生活真相之后依然热爱生活。希望能给大家一点温暖，也希望这个世界多点爱～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小钗总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很不错的文章，预测师平时在群里很活跃，工作年限不长，是个多愁善感的&lt;strong&gt;小姑娘&lt;/strong&gt;，却不曾想居然有点抑郁症前期症状了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他没有说什么原因导致清晰低落，但多半也就是那几件事：&lt;strong&gt;爱别离、怨憎会、求不得&lt;/strong&gt;。文章围绕着&lt;strong&gt;焦虑&lt;/strong&gt;展开，而焦虑更多的是求不得。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是求不得，举个例子：一个Leader息量极大，&lt;strong&gt;信息量与能力不对等&lt;/strong&gt;，知道的太多，能做的太少，就会陷入&lt;strong&gt;极度忧虑&lt;/strong&gt;，这多半是心力出了问题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;欲望远远超出能力，如何能不焦虑&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些场景下会出现认知错位的现象，所谓认知错位即：你因为某个人或者某个环境，被强行拉到了某个层级，这属于被&lt;strong&gt;强行灌输认知&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长时间的耳濡目染，你认为那是你的认知，但毕竟没有亲身经历，会导致两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;细节不清晰&lt;/strong&gt;细节画马时候总有各种不确定，这种对局势的不可掌握性，和&lt;strong&gt;层级的不真实感&lt;/strong&gt;导致了焦虑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;观点不坚定&lt;/strong&gt;因为认知全部是被&lt;strong&gt;强行灌输&lt;/strong&gt;的，所以对于同等级认知是&lt;strong&gt;缺乏判断力&lt;/strong&gt;的，这种人很难有自己真实的观点，要么被不停带偏毫无立场，要么认死理打死不改。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;心里一个声音说懂了，身体操作却跟不上，这能不焦虑吗？值得注意的是，当前自媒体众多（包括我）经常输出认知，大家对此一定要警惕，要多看那种&lt;strong&gt;有案例的&lt;/strong&gt;，不然很难学到东西，甚至被带偏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回到焦虑问题本身，依旧是心脑体不协调导致：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9858490566037735&quot; data-type=&quot;png&quot; data-w=&quot;2120&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTA2gwkEDQcdB0pvZwPOLt7Wptqd0DhfnHVSiazT9WQAquUqDDyzZpia5jWicXxvD42shibgu5ic16xr6fg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;心力的底层是理想的大厦，小的理想家人身体健康；大的理想天下太平，你人生的理想是什么，那么你的时间就该用到对应的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体力是时间的选择，精力的分配，健康的体力是良好的&lt;strong&gt;身心状态&lt;/strong&gt;和&lt;strong&gt;人际关系&lt;/strong&gt;，心力与体力要高度统一，才能产生正循环。比如心中理想告诉自己该学习进步，实际动作却是在王者荣耀消耗体力，这必定导致焦虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想有大小，身体健康是理想，买台车也是理想，但心力不能太过涣散，心力更不能互相矛盾，&lt;strong&gt;三心两意&lt;/strong&gt;注定难以成就惊人的事业：&lt;strong&gt;心力可以大，但蓝图要坚固；心力可以小，但蓝图要清晰。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;体力是一个时间的问题，是一个选择问题，是你的时间要用到什么地方；&lt;/p&gt;&lt;p&gt;脑力是认知和思维框架，是时间的乘法，他能带来体力的价值最大化；&lt;/p&gt;&lt;p&gt;心力是告诉你所有的时间和技巧要服务于什么目标。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你如果现在感到焦虑，要问问是当前理想与时间精力不匹配，还是方法不对，找到哪里不对，才能对症下药，才能解除焦虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的分享就到这。如果本文对你有帮助的话，欢迎&lt;strong&gt;点赞&amp;amp;评论&amp;amp;在看&amp;amp;分享&lt;/strong&gt;，这对我非常重要，感谢🙏🏻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要更多交流可以加我微信：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5549076773566569&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTA2gwkEDQcdB0pvZwPOLt7Wke3RXUib1zY2jwicrVFbuIuq09KicFOeZOl4j0kk6uDfWktJhzeYUnhzw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26c00a8d102017c4cba3fbc77a9b1ecb</guid>
<title>【ECUG Con 2022】Go+ 的演进之路</title>
<link>https://toutiao.io/k/p8vlhky</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span data-docs-delta=&quot;[[20,&amp;quot;7 月 10 日，一年一度的 ECUG Con 2022 在线上圆满举行。许式伟作为七牛云 CEO、ECUG 社区发起人、Go+ 语言发明人，为大家来带了《Go+ 演进之路》的主题演讲。以下内容根据演讲实录整理。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|9:1&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;CUOk\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;l7gm\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/Wde4WuHoBUq7fsCv.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;87Lo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;大家好，欢迎来到 ECUG Con 2022。ECUG 大会从 2007 年开始，到今天已经第 15 个年头了，我基本每年都会为大家带来演讲。继上届大会之后，今年我想和大家继续分享 Go+ 的相关内容，聊聊 Go+ 的演进之路。我们会谈谈 Go+ 过去都发生了什么？我们现在正在做什么？以及我们未来会怎样继续去进行迭代？&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ylnz\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;R2I5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/fjDkc2xyMHJulg6j.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6i9d\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;7B5w\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;一、Go+ 历史的关键节点&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9o3y\&amp;quot;|32:2|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;纵观 Go+ 的发展历程，我们大概会分四个关键的节点。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;VBpq\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/MncCPiIdYPgeL1Q6.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5OLy\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;bZxe\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;首先是 0.5 版本及以前的「史前版本」。因为它当时叫做 qlang，其实和 Go+ 没有关系，所以叫「史前版本」。我们现在把 qlang 的代码，从 Go+ 移到我个人的 GitHub 下面了。之后是 0.6 到 0.7 的原型版本，主要是为了让大家看到 Go+ 到底长什么样，因为它和之前的  qlang 有非常大的不同，qlang 是一个脚本语言，Go+ 实际上是一个静态类型的语言。此后，我们从这个原型版本出发，让它能够更加接近工程的使用。比较重要的里程碑就是去年 1.0 版本的发布，Go+ 的目标和代码风格被正式确定下来。此后，我们基本上是延续这个目标和它的代码风格继续前进。今年上半年我们发布了 Go+ 的 1.1 版本，它实际上是 Go+ 的第一个工程化版本，它可以正式用于生产环境。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;toTB\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;qD7Y\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/Cc2bIFPWxGCdsidL.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;rjIQ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;GvaV\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t从 Go+ 1.0 开始，我们首先提出了「三位一体」的概念，即面向工程，STEM 教育和数据科学。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;G2c5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;zYlJ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;实际上我们谈的是全民编程，也就是人人都可以学编程。在今天我们可以看到，编程教育在未来，一定有越来越多的人会把它看作基础学科，和数学、语文、英语没有什么本质区别。这也是为什么 Go+ 会把 STEM 教育作为非常重要的支撑点。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;g8iK\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;hCRN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t那么 Go+ 1.0 都做到了什么呢？首先是确定了 Go+ 的代码风格，它是以命令行风格为基础，极尽可能去实现低门槛化。我们希望 7 到 8 岁的小朋友，就有能力学 Go+。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;sFyb\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;r1ob\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;另外一个很重要的点，是我们实现了类文件 Beta 版。它实际上试图实现面向对象、领域知识表达的低门槛化，也就是现在比较火的低代码领域。实际上面向对象虽然是好的东西，有助于对世界的抽象，但是它也带来了理解上的难度。因此如何去让这些高阶的工程概念低门槛化，Go+ 类文件是在这方面最重要的探索。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;MuLd\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;RN1S\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t另外 Go+ 1.0 在兼容 Go 语法方面取得了突破性的进展，这也是它最后被标为 1.0 的原因。我们在这个版本上，把大部分 Go 语法都实现了比较好的兼容性，基本上做到了在 Go 基础上去做扩展这样一个最底线的目标。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;cNbg\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5p94\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;谈到 Go+ 的目标，大家可能会有非常多的疑问，实际上从刚才的目标也可以看出，我们非常关注低门槛化。那谈到低门槛化，就不得不提 Python 这个语言。Python 的成功，到底告诉人们什么事情呢？&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;n3jS\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;0ZaS\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/3DymEqQxNfqrGFF2.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;tM1Z\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;CKR5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;首先第一个重要的点在于，它告诉我们性能并不是最重要的。虽然大家都比较看重性能，但单从性能来看的话，Python 在脚本语言里面我认为只能算二流，它其实并不快。因为性能其实是可以靠时间去解决的。语言的生命周期都非常长，Python 到今年已经有 32 年的历史了，它的性能问题是有机会可以靠时间来不断迭代解决的。但语言的特性并不能，每一步语言特性的选择都是未来的包袱。所以从这个视角来看，也希望大家对待语言，尽量避免唯性能论吧。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;E3Eh\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;E4p7\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;第二个点在于，它揭示了对语言来说最重要的是什么？或者说 Python 为什么能成功？其实我觉得，目标人群的选择是非常根因的东西。语言的特性跟目标人群的选择有关，所以语言特性的选择最重要。Python 从诞生之初，并没有给自己数据科学语言的定位，它认为应该让语言尽量精简，容易被理解、被学习。它其实是一个少有的低门槛语言，因为在我看来，真正可以称为低门槛的语言并不多。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;2avF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;0y9O\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t我们想一下大家熟知的语言，比如说 Ruby，大家都说它很简洁，但是其实它有非常多的语言魔法。所以它可能很强大，但是不能称之为易学习。所以在我心目中，能称得上是低门槛的语言 BASIC 算一个，面向教学领域的 Scratch 算一个，也就是说其实在低门槛领域进行探索的语言并没有那么多，但正因为 Python 面向了低门槛，所以它虽然没有将自己定位成数据科学语言，却成了数据科学的王者。这其实蛮讽刺的，因为有非常多专注于数据科学的语言都没有 Python 这么成功，我认为这背后有非常深刻的道理。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;a3jh\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;uAcs\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t从全民编程这个大的趋势来说，其实低门槛化是未来语言主流的发展趋势，Python 恰恰顺应了这个大潮流，使得它今天能够比最初我们看到的还要成功。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;SpR3\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Lbnw\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;那么 Python 到底还差什么？&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;MiHU\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;2anJ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/y9YSK1XJwX5B0yAs.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Z1Yv\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;KfrN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;首先从工程的视角来说，Python 这方面比较弱。谈 Python 有些人会想到 Go，因为从 Python 转向 Go 的程序员也不少，原因就在于 Go 是设计思想最接近 Python 的工程语言，使用者的心智负担也是非常低的。但是 Go 语言的设计者心中基本只有工程，大家看 Go 的官网就知道，它最关心的一个词是 scale。也就是如何实现一个大型的工程，实现一个代码量非常庞大，但是仍然在工程师掌控之中的工程。所以它没有在意低门槛，它在意的是如何去实现工程上的 scale。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;u82v\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;N6mN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t所以从这两方面去看， Go+ 既然是面向全民的编程，那么我们自然会去关注如何把 Go 和 Python 的优势融在一体，把 Go 的工程能力和 Python 的低门槛化结合。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;WzMa\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;lkYI\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t我们知道工程很庞大，去实现更庞大、更复杂的系统也是我们所关注的，但是 STEM 教育也好，数据科学也好，更关注的还是如何实现低门槛化。所以工程、STEM 教育、数据科学三位一体，实际是工程和低门槛的融合，这就是 Go+ 的目标。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;uACg\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;r7hj\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/TWVd0JAbNBi9k8CI.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;OAb4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;dUv7\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t它们融合之后的样貌，我们可以通过下面 Go+ 的代码范例来了解。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Y6AW\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;LkfP\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;下面的这个示例大家可能会想到 Shell 编程，很多程序员可能会觉得 Shell 脚本是比较低门槛的。它虽然在实现复杂任务上比较难用，但是它从理解上是大家最熟悉的，我们会看到 Go+ 的语法与 Shell 的非常接近。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;31mc\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;KbjM\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/YEKBBNbzVfwECTz8.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;0rlE\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ZMPG\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;4Re9\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;我们再看另外一个例子，就是用 Go+ 去做游戏。下图实际上是两个角色的对话，一个非常简单的游戏，它的代码也是非常简洁的。这里我们会看到命令行的影子，比如 onStart 这样的语句，是说在程序开始的时候，我们应该做什么。onMsg 是我收到一个消息以后要做什么。基本上有 onStart 和 onMsg 这样的事件机制，以及我们看到里面的代码有 say、有 broadcast（广播消息)。整个程序的流程，其实是通过事件加上 say 还有广播消息，这样几个很基础的元素组成。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6WwN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;KPgl\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/TQSltgcsJ7WWfuPy.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;lNIt\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;heH0\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t我们可以看到这是两个角色的对话。第一个角色在程序开始的时候，说你来自哪里，然后紧接着广播消息 1。另一个角色收到了消息 1 后，他就会说我来自英国。然后他再广播消息 2。角色一收到消息 2 以后，他就会说你们国家的天气怎么样。这样，整个时序就由消息驱动，两个角色之间的对话就形成了。这个程序非常简洁，通过它我们可以看到 Go+ 在表达自然的语义上，有天然优势，它的代码是非常通俗易懂的。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;JPy9\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;JnTM\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;从这两个例子中我们也可以看到，Go+ 虽然实际上是 Go 兼容的产物，但它的语法或者说建议的最佳实践风格，和 Go 是有非常大差异的。它甚至比 Python 还要简洁，因为它选择了命令行的风格。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;BK8X\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;hEvC\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t这里我们可以从工程的几个概念来理解。一是命令，它是一段代码的抽象化，最早期的语言如 FORTRAN，它的命令其实是和函数分开的。当然后来所有的高级语言，基本上都把命令和函数合为一体。但在 Go+ 里，命令和函数从代码风格上来说是有差别的，但是它们背后都是函数。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5IYF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;OOvI\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/rEpOpHMjvjb0P1KX.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;PKCr\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;lpId\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t所以在 Go+ 的代码风格上，我们选择了以命令风格为主体。因为命令的理解难度是最低的，小学生就能理解。其次是函数，这个概念初中生基本也就开始接触，比如三角函数。那结合计算机和数学中的函数，将两者互相印证，对初中生而言理解起来难度也不算高。基本上只要理解形参和实参的概念就可以了。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;W8JJ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;i86g\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;在面向对象中，类、方法这些概念，虽然它确实有助于抽象世界，但实际上面向对象编程的理解门槛是最高的。所以 Go+ 其实在极力避免让程序员用面向对象的写法。实际上在背后我们会使用面向对象的一些思想，但在语言语法上，我们尽量避免太过于面向对象化。所以 Go+ 1.0 中我们看到了它基本奠定了 Go+ 的代码风格和目标。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;cVb2\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;bviH\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/YIWcd9FGCO7uRCct.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;PHAa\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;oiYt\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t既然目标和风格都定了，基本上我们希望的第一件事情，就是能够实现工程，成为第一个可以用于实际生产环境的版本。为了实现这个目标，从优先级来说最重要的有两件事情。一个是对模块 Module 的支持，大家都知道 Go 对 Module 支持是很晚的，而 Go+ 在 1.1 版本基本上就兼容了 Go 的模块概念。我们实现了对模块比较完备的支持，和 Go 用起来的体验是非常一致的。另外一个很重要的特性是，我们实现了 Go 和 Go+ 的混合工程。这对用于生产环境是有非常大的帮助的。因为大部分程序员面临的第一个问题，就是 Go+ 用来做什么？历史的工程可能是 Go 写的，那如何把它转化成 Go+ 呢？其实不用转，因为你的 Go 工程，就是 Go+ 的工程，你只需要在上面写一些 Go+ 的函数就行了。这样一来，我们就可以非常轻松地去把 Go+ 用于生产环境。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;tQ21\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;MK4Q\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;接下来是提供 c2go 的预览，这是为后续版本服务的，它是一个非常难啃的骨头。我们也在 Go+ 1.1 版本基本把它实现了。Go+ 支持 C，实际上是引用了 c2go 这个项目。我们在这个版本实现了 c2go 最基础的能力。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;r2s5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;KheO\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/ZEWTUYoOdENdoGNs.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6bwY\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;lXuo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;我们看 Go+ 的版本演进，如果说 Go+ 1.0 版本是明目标、定风格，那么 1.1 版本是为了进生产环境。模块也好，Go/Go+ 混合编程也好，其实都是在为进入生产环境打基础。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;sfww\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;SIOh\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/jCZls37uzq4hWcJg.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;G68N\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5hU7\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;Go/Go+ 的混合编程，正如我刚才提到的，任何一个 Go 工程，只要在其中添加几个 Go+ 的源代码，然后去把 go 的命令换成 gop，就可以正常地去做 Go+ 开发了。这实际上把 Go+ 的适用门槛降到了最低。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;nmU9\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;cs2M\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;二、Go+ 当前节点：v1.2.x&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;hR1G\&amp;quot;|32:2|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ljV4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/0BwU39GEhE2Pz9JG.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;iegJ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5TzC\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;以上是 Go+ 的过去，下面我想和大家分享当前 Go+ 正在做的事情，也就是 Go+ 1.2  版本。这个版本我是把它定义为 Go+ 特色化形成的过程。我们预计在今年十二月份将 Go+ 1.2 版本正式发布。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;IaGE\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;o7av\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;我们说这个版本是特色化形成的过程，主要有这样几个原因。首先是我们在 1.0 版本中引入的类文件会转正，结束 Beta 过程。类文件是 Go+ 里非常重要的概念。第二个是 c2go，它对 Go+ 后续发展起着至关重要的作用。我们希望 Go+ 的 1.2 版本能够让 c2go 进入工程化，它的实现标志是至少完成了 sqlite3 的迁移。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;UqyM\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;IvdR\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;除了这两个很特色的功能外，Go/Go+ 混合编程也将得到增强。目前，Go/Go+ 的混合编程还不支持调用 Go 的泛型。我们知道 Go 的 1.18 版本，引入了非常重要的特性就是泛型，但现在 Go+ 还不支持 Go 的泛型。那我们在 1.2 版本也会去支持。我们不是在 Go+ 里去定义泛型，而是调用 Go 的泛型。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;vwm5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;TodT\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t基于这样方式，我们是让 Go+ 能够对泛型概念有最小化的能力，因为泛型是一个比较复杂的概念，但我们并不希望 Go+ 变得特别复杂。从长远来看，Go+ 对泛型实际上持非常开放的态度，也许有一天会全面支持泛型，但我们不会把它看成优先级很高的东西。如果真需要用泛型，我们希望是通过和 Go 的混合工程来达到。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;EGiE\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;fQgv\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;我们接下来重点讲讲这两个特色功能，类文件和 c2go。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;4E9r\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;q9Rp\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;先聊类文件。类文件最直白的一个解释，就是我们用一个文件去定义一个类。下图右侧就是用 Go 去写类的方法，想必大家非常熟悉。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9bpT\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;iXTi\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/kyZA3sughQPL2m7o.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;kVD7\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;NtPl\&amp;quot;|7:3|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t我们先定义一个叫 Rect 的结构体，它有长度和宽度两个成员，那我们再定义面积的成员方法，那就是长度和高度的乘积，这就是一个非常简单的程序。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;h1C4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;w17P\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t用类文件来实现这个能力的话，代码可以见上图左侧。我们基本上看不到任何面向对象的隐藏。我们定义了两个全局变量，一个叫宽度，一个叫高度，然后定义一个全局的方法叫面积，它是这两个全局变量的乘积。那这个代码比正常的面向对象代码看起来要简洁很多，非常容易被理解。但实际上它这两个文件是等价的。因为类文件最直接的能力，就是负责把一个看起来像是面向过程的代码，自动变成一个面向对象的方法。因为它没有引入任何新的语法，所以其实对中小学生也相对容易，不用去学新的知识。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;N1t6\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;8QIF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/ZJuFM685PFqvbF9A.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;autX\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;B2zP\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t但类文件做的并不只这些。实际上它还能够自定义基类，能够自定义整个程序执行的框架。我们最近 Go+ 的公众号也重点在谈类文件，大家可以去看一看。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;dsTx\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;Go+ 类文件：DSL vs. SDF&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;koJW\&amp;quot;|7:3|bullet-id:\&amp;quot;FykG\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;Go+ 类文件：ClassFile 机制详解&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;XDR7\&amp;quot;|7:3|bullet-id:\&amp;quot;FykG\&amp;quot;|bullet:\&amp;quot;circle\&amp;quot;|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;nJy7\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;https://mp.weixin.qq.com/s?__biz=MzA5MTAxNDg0OQ==&amp;amp;mid=2247484866&amp;amp;idx=1&amp;amp;sn=5584911fb73d00c673f551928177e126&amp;amp;chksm=9003966ca7741f7a27cd75e9fdc31ec460a37b2cf1b551a411c5d94159f9f9c7dfe772f4a243&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0711lfh16WvfS1dZBsfA6kLh&amp;amp;sharer_sharetime=1657523543875&amp;amp;sharer_shareid=ba6b59282f5511ed4b4f5b408dd9ddc5&amp;amp;version=3.1.20.90367&amp;amp;platform=mac#rd&amp;quot;,&amp;quot;16:\&amp;quot;https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzA5MTAxNDg0OQ%3D%3D%26mid%3D2247484866%26idx%3D1%26sn%3D5584911fb73d00c673f551928177e126%26chksm%3D9003966ca7741f7a27cd75e9fdc31ec460a37b2cf1b551a411c5d94159f9f9c7dfe772f4a243%26mpshare%3D1%26scene%3D1%26srcid%3D0711lfh16WvfS1dZBsfA6kLh%26sharer_sharetime%3D1657523543875%26sharer_shareid%3Dba6b59282f5511ed4b4f5b408dd9ddc5%26version%3D3.1.20.90367%26platform%3Dmac%23rd\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;JYF0\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;2bRU\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/pBKXEDHowObIrS08.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;DMs5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;bHzF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;提到类文件，就需要提到 Go+ 的一个设计哲学：Go+ 不支持领域专用语言，也就不是不支持 DSL，但 Go+ 却对专业领域友好（Specific Domain Friendly）。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ZPwW\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;YoeT\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t为什么说它是专业领域友好呢？从上文我们的举例中来看，第一个例子是 Shell 编程，或者叫 DevOps 的领域编程。我们可以看到 Go+ 的代码看起来非常接近于 Shell 编程。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Fbdt\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;EbAF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/mfSCItODosruIcpJ.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;623k\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;MAuZ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;实际上 Shell 编程更像是 DevOps 的 DSL，我们很少在 Shell 之外去用这个语言，它只用于非常基础的一些自动化（automation）。但是我们可以看到，Go+ 实际上是可以让语言本身的代码非常接近于 DSL，但实际上它却不是 DSL，它是非常正宗的 Go+ 语法。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;oCsz\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;YpM4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t同样的道理，我们可以看到在更复杂的游戏编程中，Go+ 也是非常的简洁的。而且它不仅简洁，更重要的是它同时也非常强大，它能够去做类似于《植物大战僵尸》这样比较复杂的游戏。当然我们没有去做 3D 游戏的引擎，如果要做，那么它依然是非常精简的 3D 游戏的引擎。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;VYZA\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;vn2g\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/52zqgFAOPdozgaZR.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6BCF\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;JdTP\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;正是因为 Go+ 引入了类文件，让它的语法看起来非常领域化。这意味着 Go+ 非常善于结合领域的特征去提炼领域知识。从而使得 Go+ 利于领域的开发。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5NFc\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;fz8C\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;当然我们类文件现在还在 Beta 的阶段，当前已经在 2D 的游戏、DevOps 这些领域做了一些实践。但是毕竟领域是非常多的，对类文件这个概念来说，最大的挑战是领域非常多，在有限的几个领域里试验是不够的，需要有更多的领域来验证类文件机制的普适性，判断它能否适应各个领域。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;xGzf\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6kBb\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/A0OAy1av0a0WdFJR.jpg!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;a37N\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;fiag\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;另外，我们还需要清除 Beta 版本类文件里面的一些不必要的约束。比如说，我们当前一个专业的领域只允许有一种工作类，在一些专业领域里显然很有可能会需要打破这个约束。所以我们接下来在 1.2 版本，会去消除掉类似这样的不必要约束。我们希望能够让一个专业领域有多种工作类，如此一来它的普适性就会更强。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;p1Kc\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;kYzi\&amp;quot;|7:3|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t 1.2 版本的第二个特色功能，就是刚才提到 c2go。c2go 的语法可能看起来有点像 cgo，但是它和 cgo 完全不可同日而语，cgo 用起来大家吐槽非常多，但是用 c2go 会觉得非常爽，因为我们基本做到了无缝对接 C 语言。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;xvsR\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;K3gq\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/nmIgS9bEBn7V51w1.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;niwo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;y0vO\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;首先，C 语言的代码是不需要经过额外包装的，直接就可以由 Go+ 来调用。其次，我们让 C 和 Go+ 的类型系统尽可能一致，极大化地降低了 C 和 Go+ 的对接成本。这样的话两者相互操作，类型上基本不用做转化。比如说在 C 语言里面的 void，就是无返回值、无参数的一个函数，到了 Go+ 里，基本上是一个 func()。那这样一个类型的映射，其实在 cgo 里面是做不到的。因为 cgo 需要做必要的函数调用约定转化，才能实现这样的调用。最后，我们把 C 翻译之后，它的数据结构内存布局和程序语义尽可能保持不变。也就是说 C 程序员，对 C 的代码的常规语义理解仍然是正确的。比如说字符串，它是以 &#x27;\\x00&#x27;，就是以 0 为结尾的，这些概念到了 Go+ 这边翻译以后，其实它仍然是正确的。这样也会有助大家不至于在语义上出现分歧。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;kJE0\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;85KN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;从下图的例子中我们可以看出，通过 c2go 的方式，我们实现了 C 的简洁调用。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5tyy\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;QDYl\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/0oW6dnYYyb6QOvVG.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;1LHt\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Ah0U\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;我们可以看到第一句是 import C，但是它和 Go 的语义是完全不同的，在 Go+ 里它其实是 C/github.com/goplus/libc 的缩写。那我们可以看出，这个例子中我们调用了 2 个 C 函数：printf 和 fprintf，使用了一个 C 变量 stderr。另外还有一个比较有意思的地方，是字符串，我们看到在 Go+ 的标准字符串前面写一个 C 前缀，就代表 Go+ 里传入 C 的字符串常量，这实际上是一个 Go+ 的语法。但是有了这个语法以后，会使得在 Go+ 里调用 C 的代码会非常精简，不至于像 cgo 一样，会有一个从 Go 字符串转化成 C 的字符串，并且最后还要释放它这样一个过程。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;1MtM\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;MWkJ\&amp;quot;|7:3|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t这是一个非常小的例子，但是我们可以看到 c2go 在表达上，是能够让大家感觉到好像 C 和 Go 的包是没有区别的。我们引入 C 的包和引入 Go 的包，基本使用上大差不差。而且在所有的细节上，都会让大家感觉 C 的模块好像就是 Go 的模块，当然同时也是 Go+ 的模块，这是我们希望能够达到的最终效果。这也是我们在 Go+ 里无缝兼容 C 的一个逻辑。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ZAS0\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;ZL4T\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t当然当前 c2go 还是一个预览版，它连 Beta 版都算不上。c2go 当前已经完成了 C 语法 99% 以上的兼容，它没有完成的部分，主要在于标准 C 库的迁移，它的完成度可能只有 5%，处在非常早期的阶段。对 c2go 来说，它最主要挑战首先在于跨平台。一方面是 C 标准库（libc）的跨平台，另一方面如何让 c2go 对所有的 C 工程都可以轻松实现跨平台能力，同样是非常重要的能力建设工作。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;2JQI\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;QecR\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/FPlw8w8mXVwzuRr3.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;jnoX\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;fHWj\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;单从 libc 本身来说，其实无论是 syscall、pthread，都有比较大的工作量。syscall 现在我们已经支持了 mac 版本，但 Linux 和 Windows 还没有支持，那 pthread 就更不用说了，这是我们接下来工作量最大的一个板块。所以 c2go 接下来最重要的是整个标准 C 库的迁移，它本身就是比较庞大的工作。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;eBbK\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;4HSe\&amp;quot;|7:3|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;以上就是当前 Go+ 1.2 版本想要解决的事情，当然还有支持 Go 模板调用的小细节，我们就不展开了。基本以上几个点构成了 Go+ 的特色能力，无论是类文件，还是对 C 的兼容，以及 Go 和 Go+ 的混合工程，都使得 Go+ 有了非常好的底子。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;tdDh\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;q8w0\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;三、Go+ 未来规划&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;WTA6\&amp;quot;|32:2|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;FZop\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t那么从 Go+ 的未来规划来说，大家都知道 Go+ 在谈工程和 STEM 教育、数据一体化，实际上到 v1.2 位置，Go+ 在数据科学领域做的事情是相对少的。会有一些非常有限的能力去实现，比如列表解析、range 表达式等等，但谈不上体系化，实际上 Go+ 的数据科学技术栈还是没有的。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;c3iv\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;FWH1\&amp;quot;|7:3|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t所以在 1.7 这个非常重要的大版本里面，我们希望 Go+ 自身数据科学的技术栈能够形成。然后到 2.0 又做了一个大的版本越级，我们希望 2.0 这个阶段，要能够支持 Python 语法。当然，不是说在 Go+ 里面去写 Python。实际上跟支持 C 比较类似，能够让 Go+ 无缝地去 import Python 的包，这样就使得 Python 数据科学领域历史的积累，都可以无缝变成 Go+ 的数据科学能力。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;FHuE\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Q1p4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/W76mpnglQHA9A43l.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;uwPo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9aW5\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t实际上这两个内容，都是面向数据科学的。原因在于，从工程和低门槛化的大方向来说，到 v1.2 版本基本上能力已经完备。Go+ 基本上不太会去在语法上花很多精力，这一点 Go+ 和 Go 是有非常相似的哲学，我们认为语法越少越好，而不是越多越好。所以，基本上到了 1.2 版本以后，Go+ 的语法比较定型了，我们不太会加各种稀奇古怪的语法。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;kMvK\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;cSQg\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t但是数据科学是 Go+ 最后的攻坚战，这并不是简单的一个语法聪明上能够解决的问题。因为 Go 的数据科学基础能力是比较薄的，当然也是因为 Go 本身兴起的时间比较短，所以它在服务端的工程实践居多。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;bszT\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;UDYz\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;那么数据科学底子这么薄的话，应该怎么办呢？v1.2 版本把 c2go 能力去工程化以后，为最后的数据科学攻坚战打下了重要基础。因为 Python 的基础是 C，我们如果对 C 做好了兼容，兼容 Python 就变得更加简单了。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;dh8s\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;QAam\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/kakccGCJ4BALaLV8.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;x4oS\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;6IfT\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;1.7 版本我们会关注什么？它的目标实际上是 Go+ 数据科学技术栈的形成，打造 Go+ 自身的数据科学能力，比如向量、矩阵等一些方面的探索。实际上即使有了这样的基础能力，它仍然还是比较单薄的。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;1M3A\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;eywv\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/A7MyDpNBKjL8Hu3O.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;HNtG\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;5toh\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;如何真正解决这个问题，让自己站在巨人的肩膀上？我们的设想是通过 c2go 来支持 Python 的数据科学底座（也就是 C 库那部分），1.7 版本我们希望能够把 Python 的 C 库部分进行兼容，从而走上 Go+ 和 Python 数据科学能力生态融合的道路。但是这个阶段我们对 Python 本身不会去做太多考虑，主要还是关注 Python 的 C 库部分。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;z1PA\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;TYsV\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/0qf04CCa3DSCqeBp.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;xjiP\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;e30E\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t但是到了 2.0 版本，我们就开始考虑把 Python 的语法也引入进来，让 Python 的包自然地成为 Go+ 生态的一部分。我们设想在 2.0 版本，至少要支持 CPython、NumPy、pandas 这三个工程。第一个是 Python 本身，其余两个是最知名的 Python 数据科学工程，有了它们以后，我们认为 Go+ 就具备了对数据科学的基础生态能力。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;tJh6\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;xTpz\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;这里为大家展示这三个工程的代码，列一下代码行的结构。我们看 Python 本身，大部分底座的代码是 C，但是有 65% 的 Python 的代码其实主要是一些标准库，这个是很容易理解的。但是最核心的能力都是 C 完成的，占 30% 多。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Htil\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;qDH6\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/oWKq4tFkGmKO4GM0.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;Maxj\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;UeyW\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;第二个就是 NumPy，NumPy 其实也是一样的做法，它最核心的能力就是 C 写的，还有少量的 C++。但是在这个基础上迭加了一个工具包，是用 Python 自己写的。从这个代码行可以看到，占比基本在 6:3、6:4 的样子。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;BHUo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;9EbY\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/V5hoLlBaMufKjPws.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;8PH4\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;SCjw\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;pandas 结构有非常大的差异，它本身大部分代码是 Python 写的，C 的部分比较少。基本上到了 2.0 版本才能比较好地支持 pandas，1.7 版本基本上还不太能支持 pandas，但已经可以支持 NumPy 了。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;8pV3\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;CvfZ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/m2FGrdSiSqWAYC8B.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;veVw\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;GpRM\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t总结一下 Go+ 的演进之路，我们的目标是实现工程、STEM 教育、数据科学的三位一体。这主要还是因为我们未来的语言，主流趋势是面向全民编程，也就是人人都可以学编程。实际上这个目标很难，但它是未来语言发展的主流趋势。目前鲜有语言在面向这样的趋势努力，Go+ 可以认为是第一个。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;1eHQ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;427N\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/klMhbwlVmJZqjMO9.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;mSMP\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;GBuo\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;今年内，Go+ 在工程化和低门槛融合的探索就将告一段落。从明年开始，我们将对数据科学发起最后的攻坚战。大家都知道，Go+ 诞生之初我们就在谈数据科学。但是实际真正去执行的时候，数据科学反而放到最后一点。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;mvAZ\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;f9Nt\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t原因在于数据科学真的是比较难的一件事情，对 Go 来说它的距离比较远。但是我们基本上有了 c2go 的基础，就会发现它对我们日后去做好数据科学，会产生很重要的支撑作用。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;XnWr\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;7aVk\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\t最后，我相信有了数据科学的支撑，Go+ 会是独一无二的。它的未来，值得我们共同期待。&amp;quot;,&amp;quot;0:\&amp;quot;%23000000\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;PrJw\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;XQnB\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;],[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/ggUS67L2VPmyx4l3.jpeg!thumbnail&amp;quot;},&amp;quot;0:\&amp;quot;%23000000\&amp;quot;|29:0|30:0|3:\&amp;quot;1920\&amp;quot;|4:\&amp;quot;auto\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;1080\&amp;quot;|ori-width:\&amp;quot;1920\&amp;quot;&amp;quot;],[20,&amp;quot;\n&amp;quot;,&amp;quot;24:\&amp;quot;viGN\&amp;quot;|7:3|direction:\&amp;quot;ltr\&amp;quot;|linespacing:\&amp;quot;150\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CUOk&quot; linespacing=&quot;150&quot;&gt;&lt;em ql-global=&quot;true&quot;&gt;7 月 10 日，一年一度的 ECUG Con 2022 在线上圆满举行。许式伟作为七牛云 CEO、ECUG 社区发起人、Go+ 语言发明人，为大家来带了《Go+ 演进之路》的主题演讲。以下内容根据演讲实录整理。&lt;/em&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CUOk&quot; linespacing=&quot;150&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;87Lo&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;1LgT&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSVyFvRHbf6BOCicWGcRZRia38yDfZUcmicrcHDr4kCwiaBTMe3onCgAgxiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ylnz&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ylnz&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;大家好，欢迎来到 ECUG Con 2022。ECUG 大会从 2007 年开始，到今天已经第 15 个年头了，我基本每年都会为大家带来演讲。继上届大会之后，今年我想和大家继续分享 Go+ 的相关内容，聊聊 Go+ 的演进之路。我们会谈谈 Go+ 过去都发生了什么？我们现在正在做什么？以及我们未来会怎样继续去进行迭代？&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;R2I5&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6i9d&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;wx0q&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSsbhBOfTwLhplAk2DE6IluGgwtu6GW4Qos78iajYFZCdQU1zPGeUZOicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;7B5w&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;h2 data-fold-block-container=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;一、Go+ 历史的关键节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span ql-global=&quot;true&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;VBpq&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;纵观 Go+ 的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;发展历程&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，我们大概会分四个关键的节点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5OLy&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;MFmG&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSe0YGCvOISD6zhAXAn0akdRwKlt5rHrXJ4NX6gy5Avzt7biaY4NAHoLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bZxe&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;toTB&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;首先是 v0.5 版本及以前的「史前版本」。因为它当时叫做 qlang，其实和 Go+ 没有关系，所以叫「史前版本」。我们现在把 qlang 的代码，从 Go+ 移到我个人的 GitHub 下面了。之后是 v0.6 到 v0.7 的原型版本，主要是为了让大家看到 Go+ 到底长什么样，因为它和之前的  qlang 有非常大的不同，qlang 是一个脚本语言，Go+ 实际上是一个静态类型的语言。此后，我们从这个原型版本出发，让它能够更加接近工程的使用。比较重要的里程碑就是去年 v1.0 版本的发布，Go+ 的目标和代码风格被正式确定下来。此后，我们基本上是延续这个目标和它的代码风格继续前进。今年上半年我们发布了 Go+ 的 1.1 版本，它实际上是 Go+ 的第一个工程化版本，它可以正式用于生产环境。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;qD7Y&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;rjIQ&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;kSPW&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSuSCWTssgajdoBfnmavE8tOAicXu9ick31tI0icRJyzEU3CjgHM9Js6IXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;GvaV&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;G2c5&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;从 Go+ 1.0 开始，我们首先提出了「三位一体」的概念，即面向工程，STEM 教育和数据科学。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;zYlJ&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;g8iK&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;实际上我们谈的是全民编程，也就是人人都可以学编程。在今天我们可以看到，编程教育在未来，一定有越来越多的人会把它看作基础学科，和数学、语文、英语没有什么本质区别。这也是为什么 Go+ 会把 STEM 教育作为非常重要的支撑点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;hCRN&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;sFyb&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;那么 Go+ 1.0 都做到了什么呢？首先是确定了 Go+ 的代码风格，它是以命令行风格为基础，极尽可能去实现低门槛化&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们希望 7 到 8 岁的小朋友，就有能力学 Go+。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;r1ob&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MuLd&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;另外一个很重要的点，是我们实现了类文件 Beta 版&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它实际上试图实现面向对象、领域知识表达的低门槛化&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;也就是现在比较火的低代码领域。实际上面向对象虽然是好的东西，有助于对世界的抽象，但是它也带来了理解上的难度。因此如何去让这些高阶的工程概念低门槛化，Go+ 类文件&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是在这&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;方面最重要的探索。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;RN1S&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cNbg&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;另外 Go+ 1.0 在兼容 Go 语法方面取得了突破性的进展，这也是它最后被标为 1.0 的原因。我们在这个版本上，把大部分 Go 语法都实现了比较好的兼容性，基本上做到了在 Go 基础上去做扩展这样一个最底线的目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5p94&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;n3jS&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;谈到 Go+ 的目标，大家可能会有非常多的疑问，实际上从刚才的目标也可以看出，我们非常关注低门槛化。那谈到低门槛化，就不得不提 Python 这个语言。Python 的成功，到底告诉人们什么事情呢？&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;0ZaS&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tM1Z&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;jFEF&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSGhCcoEObbVwWgfUBtb2PPeE2BbsUnjgzK9Tf9IBZY9CGialY38Zt6IQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CKR5&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;E3Eh&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;首先第一个重要的点在于，它告诉我们性能并不是最重要的。虽然大家都比较看重性能，但单从性能来看的话，Python 在脚本语言里面我认为只能算二流&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它其实并不快&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;因为性能其实是可以靠时间去解决的。语言的生命周期都非常长，Python 到今年已经有 32 年的历史了，它的性能问题&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是有机会&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;可以靠时间来不断迭代解决的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。但&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;语言的特性&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;并&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;不能&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;每一步语言特性的选择都是未来的包袱。所以从这个视角来看，也希望大家对待语言，尽量避免唯性能论吧。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;E4p7&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2avF&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;第二个点在于，它揭示了对语言来说最重要的是什么？或者说 Python 为什么能成功？其实我觉得，目标人群的选择是非常根因的东西。语言的特性跟目标人群的选择有关，所以语言特性的选择最重要。Python 从诞生之初，并没有给自己数据科学语言的定位，它认为应该让语言尽量精简，容易被理解、被学习。它其实是一个少有的低门槛语言，因为在我看来，真正可以称为低门槛的语言并不多。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;0y9O&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;a3jh&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们想一下大家熟知的语言，比如说 Ruby，大家都说它很简洁，但是其实它有非常多的语言魔法。所以它可能很强大，但是不能称之为易学习。所以在我心目中，能称得上是低门槛的语言 BASIC 算一个，面向教学领域的 Scratch 算一个，也就是说其实在低门槛领域进行探索的语言并没有那么多，但正因为 Python 面向了低门槛，所以它虽然没有将自己定位成数据科学语言，却成了数据科学的王者。这其实蛮讽刺的，因为有非常多专注于数据科学的语言都没有 Python 这么成功，我认为这背后有非常深刻的道理。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uAcs&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SpR3&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;从全民编程这个大的趋势来说，其实低门槛化是未来语言主流的发展趋势，Python 恰恰顺应了这个大潮流，使得它今天能够比最初我们看到的还要成功。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Lbnw&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MiHU&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;那么 Python 到底还差什么？&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2anJ&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Z1Yv&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;3myE&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSCgyRHuck8aibiae107tadXztzluTXAVmPBzMOHaSHsJ7c4g8Ln2Tic7NA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;KfrN&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;u82v&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;首先从工程的视角来说，Python 这方面比较弱。谈 Python 有些人会想到 Go，因为从 Python 转向 Go 的程序员也不少，原因就在于 Go 是设计思想最接近 Python 的工程语言，使用者的心智负担&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;也&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是非常低的。但是 Go 语言的设计者心中基本只有工程，大家看 Go 的官网就知道，它最关心的一个词是 scale。也就是如何实现一个大型的工程，实现一个代码量非常庞大，但是仍然在工程师掌控之中的工程。所以它没有在意低门槛，它在意的是如何去实现工程上的 scale。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;N6mN&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;WzMa&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;所以从这两方面去看， Go+ 既然是面向全民的编程，那么我们自然会去关注如何把 Go 和 Python 的优势融在一体，把 Go 的工程能力和 Python 的低门槛化结合。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lkYI&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uACg&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们知道工程很庞大，去实现更庞大、更复杂的系统也是我们所关注的，但是 STEM 教育也好，数据科学也好，更关注的还是如何实现低门槛化。所以工程、STEM 教育、数据科学三位一体，实际是工程和低门槛的融合，这就是 Go+ 的目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;r7hj&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;OAb4&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;enid&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSq5M6X1Jtan22kddRwZUKs7GyIgicJqNrVPZ3NpricXYohnY0lCnG54aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dUv7&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Y6AW&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;它们融合之后的样貌，我们可以通过下面 Go+ 的代码范例来了解。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LkfP&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;31mc&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;下面的这个示例大家可能会想到 Shell 编程，很多程序员可能会觉得 Shell 脚本是比较低门槛的。它虽然在实现复杂任务上比较难用，但是它从理解上是大家最熟悉的，我们会看到 Go+ 的语法与 Shell 的非常接近。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;KbjM&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;0rlE&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;xY4O&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSeZKQWevEpjDDclic8B3YZdWFiaP51tjV3MtydYnGc06HK8Pfnz8CicMzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZMPG&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;4Re9&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6WwN&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们再看另外一个例子，就是用 Go+ 去做游戏。下图实际上是两个角色的对话，一个非常简单的游戏，它的代码也是非常简洁的。这里我们会看到命令行的影子，比如 onStart 这样的语句，是说在程序开始的时候，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;应该做什么。onMsg 是我收到一个消息以后&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;要&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;做什么&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;基本上有 onStart 和 onMsg 这样的事件机制，以及我们看到里面的代码有 say、有&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; broadcast（&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;广播消息&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;)&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。整个程序的流程，其实是通过事件&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;加上 &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;say &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;还有&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;广播消息，这样几个很基础的元素组成。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;KPgl&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lNIt&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;go8T&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSaPbNmIKetGp0AZBlic25iaEhrSHQuMIKepb6YY8GlHibYE8W6fwZBByQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;heH0&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;JPy9&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们可以看到这是两个角色的对话&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;第一个角色在程序开始的时候，说你来自哪里，然后紧接着广播消息 1。另一个角色收到了消息 1 后，他就会说我来自英国。然后他再广播消息 2&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。角色一收到&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;消息 2 以后，他就会说你们国家的天气怎么样。这样&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;整个时序就由消息驱动，两个角色&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;之间&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;的对话就形成了。这个程序非常简洁，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;通过它我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;可以&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;看到&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; Go+ 在表达自然的语义上，有天然优势，它&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;代码是非常通俗易懂的。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;JnTM&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;BK8X&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;从这两个例子中我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;也&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;可以看到，Go+ 虽然实际上是 Go 兼容的产物，但它的语法或者说建议的最佳实践风格，和 Go 是有非常大差异的。它甚至比 Python 还要简洁，因为它选择了命令行的风格。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;hEvC&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5IYF&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;这里我们可以从工程的几个概念来理解。一是命令，它是一段代码的抽象化，最早期的语言如 FORTRAN，它的命令其实是和函数分开的。当然后来所有的高级语言，基本上都把命令和函数合为一体。但在 Go+ 里，命令和函数&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;从&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;代码风格上&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;来说&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是有差别的，但是它们背后都是函数。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;OOvI&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;PKCr&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;6ZU8&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSzw2Pbia673S8SgBtluMCEXicn5s2gAL9NjfSzoL6Cr2GFTCJoX033lHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lpId&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;W8JJ&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;所以在 Go+ 的代码风格上，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;选择了以命令风格为主体。因为命令的理解难度是最低的，小学生就能理解。其次是函数，这个概念初中生基本也就开始接触，比如三角函数。那结合计算机和数学中的函数，将两者互相印证，对初中生而言理解起来难度也不算高。基本上只要理解形参和实参的概念就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;i86g&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cVb2&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;在面向对象中，类、方法这些概念，虽然它确实有助于抽象&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;世界&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，但实际上面向对象编程的理解门槛是最高的。所以 Go+ 其实在极力避免让程序员用面向对象的写法。实际上&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;在&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;背后&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们会使用&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;面向对象的一些思想，但在语言语法上，我们尽量避免太过于面向对象化。所以 Go+ 1.0 中我们看到了它基本奠定了 Go+ 的代码风格和目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bviH&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;PHAa&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;UCld&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSohCD5ZkXh9moLshBDy95ZZs28GiaKseKBcIErMtiaf1unFsJJ7hicqSPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;oiYt&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tQ21&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;既然目标和风格都定了，基本上我们希望的第一件事情，就是能够实现工程，成为第一个可以用于实际生产环境的版本。为了实现这个目标，从优先级来说最重要的有两件事情。一个是对模块 Module 的支持，大家都知道 Go 对 Module 支持是很晚的，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;而&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; Go+ 在 1.1 版本基本上&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;就&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;兼容了 Go 的模块概念。我们实现了对模块比较完备的支持，和 Go 用起来的体验是非常一致的。另外一个很重要的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;特性&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们实现了 Go 和 Go+ 的混合工程。这对用于生产环境是有非常大的帮助的。因为大部分程序员面临的第一个问题，就是 Go+ 用来做什么？历史的工程可能是 Go 写的，那如何把它转化成 Go+ 呢？其实不用转，因为你的 Go 工程，就是 Go+ 的工程，你只需要在上面写一些 Go+ 的函数就行了。这样一来，我们就可以非常轻松地去把 Go&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;+ &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;用于生产环境。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MK4Q&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;r2s5&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;接下来是提供 c2go 的预览，这是为后续版本服务的，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是一个非常难啃的骨头。我们也在 Go+ 1.1 版本基本把它实现了。Go+ 支持 C，实际上是引用了 c2go&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; 这个项目。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们在这个版本实现了 c2go 最基础的能力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;KheO&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6bwY&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;AgSR&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSoCWPJ8zSs7X1Mo3obruXp9Aricp6SfE0cKKnl3N58aKcX5UQLYERoHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lXuo&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;sfww&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们看 Go+ 的版本&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;演进&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;如果&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;说 Go+ 1.0 版本是明目标、定风格，那&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;么&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; 1.1 版本是为了进生产环境。模块也好，Go&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;/Go&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;+ 混合&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;编程&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;也好，其实都是在为进入生产环境打基础。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SIOh&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;G68N&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;yfVB&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSrcQuxpyRA7ZzdCKs5R8FISbfEk3x99HEHYcjyw0BJyNpZtrY1JE0Vw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5hU7&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;nmU9&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;Go/&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;Go+ 的混合&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;编程&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，正如我刚才提到的，任何一个 Go 工程，只要在其中添加几个 Go+ 的源代码，然后去把 go 的命令换成 gop，就可以正常地去做 Go+ 开发了。这实际上把 Go+ 的使&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;用&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;门槛降到了最低。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cs2M&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;h2 data-fold-block-container=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;二、Go+ 当前节点：v1.2.x&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ljV4&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;iegJ&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;87VN&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLS34bJW30MzA8grXpVA8Hp1glKwxqyJD7vXGhwVY6zXMM0zJvFhndyPA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5TzC&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;IaGE&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;以上是 Go+ 的过去，下面我想和大家分享当前 Go+ 正在做的事情，也就是 Go+ v1.2  版本。这个版本我是把它定义为 Go+ 特色化形成的过程。我们预计在今年十二月份将 Go+ v1.2 版本正式发布。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;o7av&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;UqyM&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们说这个版本是特色化形成的过程，主要有这样几个原因。首先是我们在 1.0 版本中引入的类文件会转正，结束 Beta 过程。类文件是 Go+ 里非常重要的概念。第二个是 c2go，它对 Go+ 后续发展起着至关重要的作用。我们希望 Go+ 的 v1.2 版本能够让 c2go 进入工程化，它的实现标志&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;至少完成了 sqlite3 的迁移。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;IvdR&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;vwm5&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;除&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;了这两个很特色的功能&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;外&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;Go/Go+ &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;混合编程也&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;将&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;得到增强&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;目前&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，Go/Go&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;+ 的混合编程还不支持调用 Go 的泛型。我们知道 Go 的 v1.18 版本，引入了非常重要的特性就是泛型，但现在 Go+ 还不支持 Go 的泛型。那我们在 v1.2 版本也会去支持。我们不是在 Go+ 里去定义泛型，而是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;调&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;用 Go 的泛型。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;TodT&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;EGiE&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;基于这样方式，我们是让 Go+ 能够对泛型概念有最小化的能力，因为泛型是一个比较复杂的概念，但我们并不希望 Go+ 变得特别复杂。从长远来看，Go+ 对泛型实际上持非常开放的态度，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;也许有一天会全面支持泛型，但&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们不会把它看成优先级&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;很&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;高的东西。如果&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;真&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;需要用泛型，我们希望&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;通过和 Go 的混合工程来达到。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;fQgv&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;4E9r&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;接下来重点&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;讲讲这两个特色功能，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;类文件和 c2go。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;q9Rp&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9bpT&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;先聊&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;类文件&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;类文件最直白的一个解释，就是我们用一个文件去定义一个类。下图右侧就是用 Go 去写类的方法，想必大家非常熟悉。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;iXTi&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;kVD7&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;mCje&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSqyv6b3bUCFQUnWccBd4dBwllSPrCP8fuGZDRWmK0CIxlSibal7TXzAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;NtPl&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;h1C4&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们先定义一个叫 Rect 的结构体，它有长度和宽度两个成员，那我们再定义面积的成员方法，那就是长度和高度的乘积，这就是一个非常简单的程序。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;w17P&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;N1t6&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;用类文件来实现这个能力的话，代码可以见上图左侧。我们基本上看不到任何面向对象的隐藏。我们定义了两个全局变量，一个叫宽度，一个叫高度，然后定义一个全局的方法叫面积，它是这两个全局变量的乘积。那这个代码比正常的面向对象代码看起来要简洁很多，非常容易被理解。但实际上它这两个文件是等价的。因为类文件最直接的能力，就是负责把一个看起来像是面向过程的代码，自动变成一个面向对象的方法。因为它没有引入任何新的语法，所以其实对中小学生也相对容易，不用去学新的知识。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;8QIF&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;autX&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;sA20&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSX3FlTGib3iaB0oZPde9SRLBicCREo7s6lVUyzs60Q0RzWJyVjhv88fLUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;B2zP&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dsTx&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;但类文件做的并不只这些。实际上它还能够自定义基类，能够自定义整个程序执行的框架。我们最近 Go+ 的公众号也重点在谈类文件，大家可以去看一看。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2bRU&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;DMs5&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;SzSY&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSnpCe7ujTbrQrzesicOm9wEiadNGUwoCDNvmWxtDpa5oKoibZf6qenzRzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bHzF&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZPwW&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;提到类文件，就需要提到 Go+ 的一个设计哲学：Go+ 不支持领域专用语言，也就不是不支持 DSL，但 Go+ 却对专业领域友好（Specific Domain Friendly）。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;YoeT&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Fbdt&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;为什么&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;说&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它是专业领域友好呢？从上文我们的举例中来看，第一个例子是 Shell 编程，或者叫 DevOps 的领域编程。我们可以看到 Go+ 的代码看起来非常接近于 Shell 编程。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;EbAF&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;623k&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;KOna&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSZNGQrhpmSwUtG6EM6ZoeWArD8ttLzOb8g4ZR60c036SibicBN3sibJpKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MAuZ&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;oCsz&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;实际上 Shell 编程更像是 DevOps 的 DSL，我们很少在 Shell 之外去用这个语言，它只用于非常基础的一些自动化（automation）。但是我们可以看到，Go+ 实际上是可以让语言本身的代码非常接近于 DSL&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;但&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;实际上它却&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;不是 DSL，它是非常正宗的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; Go+ &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;语法。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;YpM4&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;VYZA&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;同样的道理，我们可以看到在&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;更&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;复杂的游戏编程中，Go+ 也是非常的简洁的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;而且它不仅简洁，更重要的是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它同时也&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;非常强大，它能够去做类似于《植物大战僵尸》这样比较复杂的游戏。当然我们没有去做 3D 游戏的引擎，如果要做，那么它依然是非常精简的 3D 游戏的引擎。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;vn2g&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6BCF&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;uVdE&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSnHTUTqEb7WPfghaXLKELzVYqjZIbGI45liaAYiazPyIuSZZMIPIiaWmeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;JdTP&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5NFc&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;正&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是因为 Go+ 引入了类文件，让它的语法看起来非常领域化。这意味着 Go+ 非常善于结合领域的特征去提炼领域知识。从而使得 Go+ 利于领域的开发&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;fz8C&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xGzf&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;当然我们类文件现在还在 Beta 的阶段，当前已经在 2D 的游戏、DevOps 这些领域做了一些实践。但是毕竟领域是非常多的，对类文件这个概念来说，最大的挑战是领域非常多，在有限的几个领域里试验是不够的，需要有更多的领域来验证类文件机制的普适性，判断它能否适应各个领域。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6kBb&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;a37N&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;3wvn&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSnyOhTicuibCBOdUbL2ZXCwqpnuRCroo4RJqhAUiaMbEUL21N2j7OWYjug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;fiag&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;p1Kc&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;另外，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;还&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;需要清除 Beta 版本类文件里面的一些不必要的约束。比如说&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;当前&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;一个专业的领域只&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;允许&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;有一&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;种&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;工作类，在&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;一些&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;专业领域里显然&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;很&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;有可能会&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;需要&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;打破这个约束&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。所以&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们接下来在 v1.2 版本，会去消除掉&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;类似这样的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;不必要约束&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;我们希望能够让一个专业领域有多&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;种&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;工作类，如此一来它的普适性就&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;会&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;更强。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;kYzi&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xvsR&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;v1.2 版本的第二个特色功能，就是刚才提到 c2go。c2go 的语法可能看起来有点像 cgo，但是它和 cgo 完全不可同日而语，cgo 用起来大家吐槽非常多，但是用 c2go 会觉得非常爽，因为我们基本做到了无缝对接 C 语言。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;K3gq&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;niwo&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;37VQ&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSptRTI5ribr6sWepVIrsUJxj856TAttMrkAQIhwbb5KOzxvibonwSxgSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;y0vO&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;kJE0&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;首先，C 语言的代码是不需要经过额外包装的，直接就可以由 Go+ 来调用。其次，我们让 C 和 Go+ 的类型系统尽可能一致，极大化地降低了 C 和 Go+ 的对接成本。这样的话两者相互操作，类型上基本不用做转化。比如说在 C 语言里面的 void，就是无返回值、无参数的一个函数，到了 Go+ 里，基本上是一个 func()。那这样一个类型的映射，其实在 cgo 里面是做不到的。因为 cgo 需要做必要的函数调用约定转化，才能实现这样的调用。最后，我们把 C 翻译之后，它的数据结构内存布局和程序语义尽可能保持不变。也就是说 C 程序员，对 C 的代码的常规语义理解仍然是正确的。比如说字符串，它是以 &#x27;\x00&#x27;，就是以 0 为结尾的，这些概念到了 Go+ 这边翻译以后，其实它仍然是正确的。这样也会有助大家不至于在语义上出现分歧。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;85KN&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5tyy&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;从下图的例子中我们可以看出，通过 c2go 的方式，我们实现了 C 的简洁调用。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;QDYl&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1LHt&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;hicK&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSACVibv6A3PVuBK3FsOIuOh1FlF4ss81xI62mlJQCv6Zzh1dsjr2LKeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ah0U&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1MtM&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;我们可以看到第一句是 import C，但是它和 Go 的语义是完全不同的，在 Go+ 里它其实是 C/github.com/goplus/libc 的缩写。那我们可以看出，这个例子中我们调用了 2 个 C 函数：printf 和 fprintf，使用了一个 C 变量 stderr。另外还有一个比较有意思的地方，是字符串，我们看到在 Go+ 的标准字符串前面写一个 C 前缀，就代表 Go+ 里传入 C 的字符串常量，这实际上是一个 Go+ 的语法。但是有了这个语法以后，会使得在 Go+ 里调用 C 的代码会非常精简，不至于像 cgo 一样，会有一个从 Go 字符串转化成 C 的字符串，并且最后还要释放它这样一个过程。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MWkJ&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZAS0&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;这是一个非常小的例子，但是我们可以看到 c2go 在表达上，是能够让大家感觉到好像 C 和 Go 的包是没有区别的。我们引入 C 的包和引入 Go 的包，基本使用上大差不差。而且在所有的细节上，都会让大家感觉 C 的模块好像就是 Go 的模块，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;当然同时也&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是 Go+ 的模块，这是我们希望能够达到的最终效果。这也是我们在 Go+ 里无缝兼容 C 的一个逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZL4T&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2JQI&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;当然&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;当前&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; c2go 还是一个预览版，它连 Beta 版都算不上。c2go 当前已经完成了 C 语法 99% 以上的兼容，它没有完成的部分，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;主要&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;在于标准 C 库&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;的迁移，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;它的完成度可能只有 5%，处在非常早期的阶段。对 c2go 来说，它最主要挑战首先在于跨平台&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。一方面是 C &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;标准库&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;（libc）的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;跨平台&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，另一方面&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;如何让 c2go 对所有的 C 工程都&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;可以轻松&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;实现跨平台能力，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;同样&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;非常&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;重要的能力建设工作。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;QecR&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;jnoX&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;mBEp&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLS7H7UajhU6TwA5bB2kw9jrMNrLbneWLq7pHbvcvFkficWoUhehiat92Jg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;fHWj&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;eBbK&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;单&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;从 libc 本身来说，其实无论是 syscall、pthread，都有比较大的工作量。syscall 现在我们已经支持了 mac 版本，但 Linux 和 Windows 还没有支持，那 pthread 就更不用说了，这是我们接下来工作量最大的一个板块。所以 c2go &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;接下来&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;最重要的是整个标准 C 库的迁移，它本身就是比较庞大的工作。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;4HSe&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tdDh&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;以上就是当前 Go+ v1.2 版本想要解决的事情，当然还有支持 Go 模板调用的小细节，我们就不展开了。基本以上几个点构成了 Go+ 的特色能力，无论是类文件，还是对 C 的兼容，以及 Go 和 Go+ 的混合工程，都使得 Go+ 有了非常好的底子。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;q8w0&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;h2 data-fold-block-container=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;三、Go+ 未来规划&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;FZop&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;c3iv&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;那么从 Go+ 的未来规划来说，大家都知道 Go+ 在谈工程和 STEM 教育、数据一体化，实际上&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;到 v&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;1.2&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt; 为止&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;Go+ 在&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;数据科学领域做的事情是相对少的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;会有一些非常有限的能力去实现&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;比如列表解析、range 表达式等等，但&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;谈不上体系化，实际&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;上 Go+ 的数据科学技术栈还是没有的。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;FWH1&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;FHuE&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;所以在 v1.7 这个非常重要的大版本里面，我们希望 Go+ 自身数据科学的技术栈能够形成。然后到 v2.0 又做了一个大的版本越级，我们希望 v2.0 这个阶段，要能够支持 Python 语法。当然，不是说在 Go+ 里面去写 Python。实际上跟支持 C 比较类似，能够让 Go+ 无缝地去 import Python 的包，这样就使得 Python 数据科学领域历史的积累，都可以无缝变成 Go+ 的数据科学能力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Q1p4&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uwPo&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;Ynii&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSMwFAZvc4SZ3d2Z1kTJaLUsE1iao1kzjTEy6HCg0UAjCVIbqbABwNeZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9aW5&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;kMvK&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;实际上这两个内容，都是面向数据科学的。原因在于，从工程和低门槛化的大方向来说，到 &lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;v&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;1.2 版本基本上能力已经完备。Go+ 基本上不太会去在语法上花很多精力，这一点 Go+ 和 Go 是有非常相似的哲学，我们认为语法越少越好，而不是越多越好。所以，基本上到了 v1.2 版本以后，Go+ 的语法比较定型了，我们不太会加各种稀奇古怪的语法。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cSQg&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bszT&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;但是数据科学是 Go+ 最后的攻坚战，它&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;并&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;不是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;简单的一个&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;语法创新&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;上能够解决的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;问题。&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;Go 的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;数据科学基础能力&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;是&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;比较薄&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;的&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;，当然也是因为 Go 本身兴起的时间比较短，所以它在服务端的工程实践居多。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;UDYz&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dh8s&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;那&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;么&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;数据科学底子这么薄的话，应该怎么办呢？&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;v&lt;/span&gt;&lt;span ql-global=&quot;true&quot;&gt;1.2 版本把 c2go 能力去工程化以后，为最后的数据科学攻坚战打下了重要基础。因为 Python 的基础是 C，我们如果对 C 做好了兼容，兼容 Python 就变得更加简单了。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;QAam&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;x4oS&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;69fg&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSYd9MXcL3AMlzGEBBSuiaslQibv5iagcDqbNZyh4FN7hEU7uN1L5FRsbqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6IfT&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1M3A&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;v1.7 版本我们会关注什么？它的目标实际上是 Go+ 数据科学技术栈的形成，打造 Go+ 自身的数据科学能力，比如向量、矩阵等一些方面的探索。实际上即使有了这样的基础能力，它仍然还是比较单薄的。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;eywv&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;HNtG&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;c0HP&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSZvK541ozo4HZjCM8NRTyeFNNYAuORWwp4eOxHl0POTC8dVSb8cVtMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;5toh&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;z1PA&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;如何真正解决这个问题，让自己站在巨人的肩膀上？我们的设想是通过 c2go 来支持 Python 的数据科学底座（也就是 C 库那部分），v1.7 版本我们希望能够把 Python 的 C 库部分进行兼容，从而走上 Go+ 和 Python 数据科学能力生态融合的道路。但是这个阶段我们对 Python 本身不会去做太多考虑，主要还是关注 Python 的 C 库部分。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;TYsV&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xjiP&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;ulsy&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLS9jOpEBXxz0HEs3Rgib3cuxZuXonzRuHK7GK7etOR4RG8VQeUMKxoEtA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;e30E&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tJh6&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;但是到了 v2.0 版本，我们就开始考虑把 Python 的语法也引入进来，让 Python 的包自然地成为 Go+ 生态的一部分。我们设想在 v2.0 版本，至少要支持 CPython、NumPy、pandas 这三个工程。第一个是 Python 本身，其余两个是最知名的 Python 数据科学工程，有了它们以后，我们认为 Go+ 就具备了对数据科学的基础生态能力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xTpz&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Htil&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;这里为大家展示这三个工程的代码，列一下代码行的结构。我们看 Python 本身，大部分底座的代码是 C，但是有 65% 的 Python 的代码其实主要是一些标准库，这个是很容易理解的。但是最核心的能力都是 C 完成的，占 30% 多。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;qDH6&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Maxj&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;8kQT&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSs3xMDqZTxKnRhyT0Rp0Grm1ibLrLDcXWDI91Kw2FcG4ZUXPmZ5IdjCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;UeyW&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;BHUo&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;第二个就是 NumPy，NumPy 其实也是一样的做法，它最核心的能力就是 C 写的，还有少量的 C++。但是在这个基础上迭加了一个工具包，是用 Python 自己写的。从这个代码行可以看到，占比基本在 6:3、6:4 的样子。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9EbY&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;8PH4&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;lR8W&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSxR4ibrjFe2lPsO2yGHj8ibe97VHrfvpJ5bfPWBgu0ic6Z9EkHynicaNa6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SCjw&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;8pV3&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;pandas 结构有非常大的差异，它本身大部分代码是 Python 写的，C 的部分比较少。基本上到了 v2.0 版本才能比较好地支持 pandas，v1.7 版本基本上还不太能支持 pandas，但已经可以支持 NumPy 了。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CvfZ&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;veVw&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;wyj2&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSInRrGCT27DBJ3KxhnbFFxcEgApZO7qMDnVFNMibVicUExrJc8LYOVicgQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;GpRM&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1eHQ&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;总结一下 Go+ 的演进之路，我们的目标是实现工程、STEM 教育、数据科学的三位一体。这主要还是因为我们未来的语言，主流趋势是面向全民编程，也就是人人都可以学编程。实际上这个目标很难，但它是未来语言发展的主流趋势。目前鲜有语言在面向这样的趋势努力，Go+ 可以认为是第一个。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;427N&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;mSMP&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;8VCx&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSZzxwWicoZIMBypaRnhUTAFPCw5cURQoB0biaJUo8Bk2icCUI3nVf6Rehw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;GBuo&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;mvAZ&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;今年内，Go+ 在工程化和低门槛融合的探索就将告一段落。从明年开始，我们将对数据科学发起最后的攻坚战。大家都知道，Go+ 诞生之初我们就在谈数据科学。但是实际真正去执行的时候，数据科学反而放到最后一点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;f9Nt&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;XnWr&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;原因在于数据科学真的是比较难的一件事情，对 Go 来说它的距离比较远。但是我们基本上有了 c2go 的基础，就会发现它对我们日后去做好数据科学，会产生很重要的支撑作用。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;7aVk&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;PrJw&quot; linespacing=&quot;150&quot;&gt;&lt;span ql-global=&quot;true&quot;&gt;最后，我相信有了数据科学的支撑，Go+ 会是独一无二的。它的未来，值得我们共同期待。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;XQnB&quot; linespacing=&quot;150&quot; ql-global=&quot;true&quot;&gt; &lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;viGN&quot; linespacing=&quot;150&quot;&gt;&lt;span line-inline=&quot;eS9Z&quot; ql-global=&quot;true&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gTTOTQN4Eyw7ms9qF7aLZ412SwlTJoLSohicyzSsPe10wlfY8YR57V42wSMMojLuhdhGVmkvmb4K2rd8ExY6mvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>79f7e05ba8dfb6b64e4158c37adbf0f4</guid>
<title>99%的Java程序员会踩的6个坑</title>
<link>https://toutiao.io/k/7p252z0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为Java程序员的你，不知道有没有踩过一些基础知识的坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，某个bug，你查了半天，最后发现竟然是一个非常低级的错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，某些代码，这一批数据功能正常，但换了一批数据就出现异常了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，你可能会看着某行代码目瞪口呆，心里想：这行代码为什么会出错？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊99%的Java程序员踩过，或者即将踩的6个坑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 用==号比较的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在项目中有没有见过，有些同事对&lt;code&gt;Integer&lt;/code&gt;类型的两个参数使用&lt;code&gt;==&lt;/code&gt;号比较是否相等？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我见过的，那么这种用法对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的回答是看具体场景，不能说一定对，或不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些状态字段，比如：orderStatus有：-1(未下单)，0（已下单），1（已支付），2（已完成），3（取消），5种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果用==判断是否相等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1 == orderStatus2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：是false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会反驳，Integer中不是有范围是：&lt;code&gt;-128-127&lt;/code&gt;的缓存吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是false？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Integer的构造方法：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5iaBHnViapJticHCqLe6Wia8ssrSlWZq63k5j9ficeY7bExKDZWOmibnwibcU6ibBcO3TR2m4M4rBQLF5icrkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实并没有用到&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存是在哪里用的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;valueOf&lt;/code&gt;方法中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.226457399103139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5iaBHnViapJticHCqLe6Wia8ssrvFy5C83usf3EmGrGaunuqnwNOFmNQsX3U2TSdO7DFf4HFBxDWfDesg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的判断改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String orderStatus1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;String orderStatus2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Integer.valueOf(orderStatus1) == Integer.valueOf(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：还真是true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要养成良好编码习惯，尽量少用==判断两个Integer类型数据是否相等，只有在上述非常特殊的场景下才相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而应该改成使用&lt;code&gt;equals&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1.equals(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果为true。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Objects.equals的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在有这样一个需求：判断当前登录的用户，如果是我们指定的系统管理员，则发送一封邮件。系统管理员没有特殊的字段标识，他的用户id=888，在开发、测试、生产环境中该值都是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求真的太容易实现了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;UserInfo userInfo = CurrentUser.getUserInfo();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(userInfo)) {&lt;br/&gt;   log.info(&lt;span&gt;&quot;请先登录&quot;&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.equals(userInfo.getId(),&lt;span&gt;888L&lt;/span&gt;)) {&lt;br/&gt;   sendEmail(userInfo):&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从当前登录用户的上下文中获取用户信息，判断一下，如果用户信息为空，则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果获取到的用户信息不为空，接下来判断用户id是否等于888。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果等于888，则发送邮件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不等于888，则啥事也不干。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们用id=888的系统管理员账号登录之后，做了相关操作，满怀期待的准备收邮件的时候，却发现收了个寂寞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，发现UserInfo类是这样定义的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserInfo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String address;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，有些小伙伴可能会说：没看出什么问题呀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要说的是这个代码确实有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们重点看看它的equals方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object a, Object b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (a == b) || (a != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; a.equals(b));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;equals方法的判断逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;该方法先判断对象a和b的引用是否相等，如果相等则直接返回true。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果引用不相等，则判断a是否为空，如果a为空则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果a不为空，调用对象的equals方法进一步判断值是否相等。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就要从&lt;code&gt;Integer&lt;/code&gt;的&lt;code&gt;equals&lt;/code&gt;方法说起来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的equals方法具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (obj &lt;span&gt;instanceof&lt;/span&gt; Integer) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value == ((Integer)obj).intValue();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先判断参数obj是否是Integer类型，如果不是，则直接返回false。如果是Integer类型，再进一步判断int值是否相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而上面这个例子中b是long类型，所以Integer的equals方法直接返回了false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果调用了Integer的equals方法，必须要求入参也是Integer类型，否则该方法会直接返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有Byte、Short、Double、Float、Boolean和Character也有类似的equals方法判断逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的坑有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Long类型和Integer类型比较，比如：用户id的场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Byte类型和Integer类型比较，比如：状态判断的场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Double类型和Integer类型比较，比如：金额为0的判断场景。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想进一步了解Objects.equals方法的问题，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247493176&amp;amp;idx=1&amp;amp;sn=c445625478a7f8122a6715b64fe6770c&amp;amp;chksm=c0e83ed0f79fb7c6cf2992d24e98f60fd78ca89525b5a3cc07f79dc801dd8e381b1fce03bf5c&amp;amp;token=1508828007&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Objects.equals有坑&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. BigDecimal的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会把一些小数类型的字段（比如：金额），定义成&lt;code&gt;BigDecimal&lt;/code&gt;，而不是&lt;code&gt;Double&lt;/code&gt;，避免丢失精度问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Double时可能会有这种场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; amount1 = &lt;span&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; amount2 = &lt;span&gt;0.03&lt;/span&gt;;&lt;br/&gt;System.out.println(amount2 - amount1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下预计amount2 - amount1应该等于0.01&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是执行结果，却为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.009999999999999998&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际结果小于预计结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Double类型的两个参数相减会转换成二进制，因为Double有效位数为16位这就会出现存储小数位数不够的情况，这种情况下就会出现误差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常识告诉我们使用&lt;code&gt;BigDecimal&lt;/code&gt;能避免丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用BigDecimal能避免丢失精度吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中定义了两个BigDecimal类型参数，使用构造函数初始化数据，然后打印两个参数相减后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.0099999999999999984734433411404097569175064563751220703125&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不科学呀，为啥还是丢失精度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jdk&lt;/code&gt;中&lt;code&gt;BigDecimal&lt;/code&gt;的&lt;code&gt;构造方法&lt;/code&gt;上有这样一段描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2511013215859031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5iaBHnViapJticHCqLe6Wia8ssrboM6u6RLqicPgmfXjaMJAcPZ5SUwGDEs4GtKK9ysJoljEXDPiaHGEDWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的意思是此构造函数的结果可能不可预测，可能会出现创建时为0.1，但实际是0.1000000000000000055511151231257827021181583404541015625的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，使用BigDecimal构造函数初始化对象，也会丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能不丢失精度呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.02&lt;/span&gt;));&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.03&lt;/span&gt;));&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;Double.toString&lt;/code&gt;方法，对double类型的小数进行转换，这样能保证精度不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更好的办法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = BigDecimal.valueOf(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = BigDecimal.valueOf(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;BigDecimal.valueOf&lt;/code&gt;方法初始化BigDecimal类型参数，也能保证精度不丢失。在新版的阿里巴巴开发手册中，也推荐使用这种方式创建BigDecimal参数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Java8 filter的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;code&gt;Java8&lt;/code&gt;中的&lt;code&gt;Stream&lt;/code&gt;用法，大家肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过对&lt;code&gt;集合&lt;/code&gt;的&lt;code&gt;Stream&lt;/code&gt;操作，可以实现：遍历集合、过滤数据、排序、判断、转换集合等等，N多功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里重点说说数据的过滤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有Java8之前，我们过滤数据一般是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;filterUser&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; userList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isEmpty(userList)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    List&amp;lt;User&amp;gt; resultList = Lists.newArrayList();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(User user: userList) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(user.getId() &amp;gt; &lt;span&gt;1000&lt;/span&gt; &amp;amp;&amp;amp; user.getAge() &amp;gt; &lt;span&gt;18&lt;/span&gt;)   {&lt;br/&gt;           resultList.add(user);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常需要另一个集合辅助完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用Java8的&lt;code&gt;filter&lt;/code&gt;功能，代码会变得简洁很多，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;filterUser&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; userList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isEmpty(userList)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList.stream()&lt;br/&gt;    .filter(user -&amp;gt; user.getId() &amp;gt; &lt;span&gt;1000&lt;/span&gt; &amp;amp;&amp;amp; user.getAge() &amp;gt; &lt;span&gt;18&lt;/span&gt;)&lt;br/&gt;    .collect(Collectors.toList());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码简化了很多，完美。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你对过滤后的数据，做修改了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; userList = queryUser();&lt;br/&gt;List&amp;lt;User&amp;gt; filterList = filterUser(userList);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(User user: filterList) {&lt;br/&gt;   user.setName(user.getName() + &lt;span&gt;&quot;测试&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(User user: userList) {&lt;br/&gt;   System.out.println(user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你当时可能只是想修改过滤后的数据，但实际上，你会把元素数据一同修改了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意不意外，惊不惊喜？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其根本原因是：过滤后的集合中，保存的是对象的引用，该引用只有一份数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，只要有一个地方，把该引用对象的&lt;code&gt;成员变量&lt;/code&gt;的值，做修改了，其他地方也会同步修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5496575342465754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaBHnViapJticHCqLe6Wia8ssr4iaaIDtChBkZCRm0N8Dwy9rvVfmuSiath1j2qpwTJbMNGH279u0NOOZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 自动拆箱的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Java5&lt;/code&gt;之后，提供了&lt;code&gt;自动装箱&lt;/code&gt;和&lt;code&gt;自动拆箱&lt;/code&gt;的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动装箱是指：JDK会把基本类型，自动变成包装类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等价于：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而自动拆箱是指：JDK会把包装类型，自动转换成基本类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; sum = integer + &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等价于：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; sum = integer.intValue() + &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际工作中，我们在使用自动拆箱时，往往忘记了判空，导致出现&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 运算&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要对传入的数据进行计算，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(add(&lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;2&lt;/span&gt;)));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Integer &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(Integer a, Integer b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果传入了null值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(add(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;2&lt;/span&gt;)));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;则会直接报错。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 传参&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们定义的某个方法是基本类型，但实际上传入了包装类，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Integer a = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Integer b = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    System.out.println(add(a, b));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Integer &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt; b)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现add方法报&lt;code&gt;NullPointerException&lt;/code&gt;异常，你可能会懵逼，int类型怎么会出现空指针异常呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这个问题出在：Integer类型的参数，其实际传入值为null，JDK字段拆箱，调用了它的&lt;code&gt;intValue&lt;/code&gt;方法导致的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. replace的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候我们在使用字符串时，想把字符串比如：ATYSDFA*Y中的字符A替换成字符B，第一个想到的可能是使用replace方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想把所有的A都替换成B，很显然可以用replaceAll方法，因为非常直观，光从方法名就能猜出它的用途。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了：replace方法会替换所有匹配字符吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jdk的官方给出了答案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21832358674463936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5iaBHnViapJticHCqLe6Wia8ssrogn9kfhcJGQUJRqrg4ZTPaIFLibiautkI1aFou6camyfKicEKk2QpTt9A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1026&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会替换每一个匹配的字符串。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然replace和replaceAll都能替换所有匹配字符，那么他们有啥区别呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;replace&lt;/code&gt;有两个&lt;code&gt;重载&lt;/code&gt;的方法。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;其中一个方法的参数：char oldChar 和 char newChar，支持字符的替换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replace(&lt;span&gt;&#x27;A&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;B&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;另一个方法的参数是：CharSequence target 和 CharSequence replacement，支持字符串的替换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;replaceAll&lt;/code&gt;方法的参数是：String regex 和 String replacement，即基于&lt;code&gt;正则表达式&lt;/code&gt;的替换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如对普通字符串进行替换：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replaceAll(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用正则表达替换（将*替换成C）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replaceAll(&lt;span&gt;&quot;\\*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，将&lt;code&gt;*&lt;/code&gt;替换成&lt;code&gt;C&lt;/code&gt;使用replace方法也可以实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙们看到看到二者的区别了没？使用replace方法无需对特殊字符进行转义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，千万注意，切勿使用如下写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replace(&lt;span&gt;&quot;\\*&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法会导致字符串无法替换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有个小问题，如果我只想替换第一个匹配的字符串该怎么办?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;replaceFirst&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;source.replaceFirst(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;&quot;B&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，这里内容都很基础，但越基础的东西，越容易大意失荆州，更容易踩坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，统计一下，这些坑一个都没踩过的同学，麻烦举个手。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>