<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8500a5a12c13d6b4af963f41a99877a4</guid>
<title>百万并发场景中倒排索引与位图计算的实践</title>
<link>https://toutiao.io/k/dfgdurs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h6&gt;作者：京东物流 郎元辉&lt;/h6&gt;

&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;Promise时效控单系统作为时效域的控制系统，在用户下单前、下单后等多个节点均提供服务，是用户下单黄金链路上的重要节点；控单系统主要逻辑是针对用户请求从规则库中找出符合条件的最优规则，并将该规则的时效控制结果返回客户端，比如因为临时疫情等原因针对仓、配、商家、客户四级地址等不同维度进行精细粒度的时效控制。&lt;/p&gt;

&lt;p&gt;该系统也是Promise侧并发量最大的系统，双11高峰集群流量TPS在百万级别，对系统的性能要求非常高，SLA要求在5ms以内，因此&lt;strong&gt;对海量请求在规则库(几十万)中如何快速正确匹配规则是该系统的技术挑战点&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;朴素的解决方案&lt;/h2&gt;

&lt;p&gt;按照朴素的思想，在工程建设上，通过异步方式将规则库逐行缓存到Redis，Key为规则条件,Value为规则对应结果；当用户请求过来时，对请求Request(a,b,c,d..)中的参数做全组合，根据全组合出的Key尝试找出所有可能命中的规则，再从中筛选出最优的规则。如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e67282f34ac4ab09513d8d8e5cc78b0%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;31.png&quot;/&gt;
﻿﻿&lt;/p&gt;

&lt;p&gt;该方案面临的问题是全组合的时间复杂度是2&lt;strong&gt;n,n≈12；&lt;/strong&gt;算法的时间复杂度高且算法稳定性差**，最差情况一次请求需要4096次计算和读取操作。当然在工程上我们可以使用本地缓存做一些优化，但是无法解决最根本的性能问题。架构简图如下所示：&lt;/p&gt;

&lt;p&gt;[]()&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ad4bf2cef04104b0a098b7497c7f00%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;32.png&quot;/&gt;
﻿﻿&lt;/p&gt;

&lt;h2&gt;新的解决方案&lt;/h2&gt;

&lt;p&gt;上面方案是从行的角度看待匹配定位的，能够命中的行的每一列必然也是符合条件的，这里面存在某种隐约的内在联系。能否反过来思考这个问题，为此我们尝试进行新的方案，当然架构简图依然如上图所示，核心优化的是命中算法。&lt;/p&gt;

&lt;p&gt;新的方案整体采用&lt;strong&gt;列的倒排索引和倒排索引位运算&lt;/strong&gt;的方式，使得&lt;strong&gt;计算复杂度由原来的2&lt;/strong&gt;n降至n**，且算法稳定性有非常好的保证。其中列的倒排索引是对每列的值和所分布的行ID(即Posting List)建立KV关系，倒排索引位运算是对符合条件的列倒排索引进行列间的位运算，即通过联合查询以便快速找到符合条件的规则行。&lt;/p&gt;

&lt;h2&gt;算法详细设计&lt;/h2&gt;

&lt;h3&gt;1.预计算生成列的倒排索引和位图&lt;/h3&gt;

&lt;p&gt;通过对每列的值进行分组合并生成Posting List，建立列值和Posting List的KV关系。以下图为例,列A可生成的倒排索引为：301={1},201={2,3,4,5}等，需要说明的一点，空值也是一种候选项，也需要生成KV关系，如nil={7}。&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;br/&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da5be9d1ad444642902b0dd12f924d43%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;33.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.生成列的倒排索引对应位图&lt;/h3&gt;

&lt;p&gt;将步骤1的倒排索引转成成位图，方便后续的位图计算，转换规则为行ID对应位图的下标位（步骤1、2可以合并操作）。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1137f2a3e8c4d6396f1a713d29ecd5c%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;34.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;h3&gt;3.根据用户请求查找列位图，通过位图计算生成候选规则集&lt;/h3&gt;

&lt;p&gt;将用户请求中的入参作为Key，查找符合条件的位图，对每一列进行列内和空值做||运算，最后列间位图做&amp;amp;运算，得到的结果是候选规则集，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132a206090f948d59fce31522a8475f3%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;45.png&quot;/&gt;
[]()&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;h3&gt;4.从候选规则库中，根据业务优先级排序，查找最优的规则&lt;/h3&gt;

&lt;p&gt;以候选规则为基点，按照业务优先级排序，进行逐级位运算&amp;amp;，当遍历完或位运算为0时，找到最后不为空的即为最优规则，该过程是从候选规则库逐渐缩小最优范围的过程。需要说明某列当用户请求位图不存在时，需要使用对应的空位图进行参与，以B列为例，入参B_1102不存在，需要使用B_nil参与&amp;amp;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecd134aaba54ecdada9c4f6678f67c4%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;56.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;h2&gt;复杂度分析&lt;/h2&gt;

&lt;p&gt;通过上面的例子我们可以看到，在时间复杂度方面查找候选规则集时，进行一轮||运算，一轮&amp;amp;运算；在查找最优规则时进行一轮&amp;amp;运算，所以&lt;strong&gt;整体复杂度是3n≈n&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在空间复杂度方面，相比原来的行式存储，倒排索引的存储方式，每列都需要存储行ID，相当于多了 &lt;strong&gt;(n-1)*Posting List存储空间&lt;/strong&gt;，当然这是粗略计算，因为实际上行ID的存储最终转换为位图存储，在空间上有非常大的压缩空间。&lt;/p&gt;

&lt;h2&gt;工程问题-压缩位图&lt;/h2&gt;

&lt;p&gt;如果倒排索引位图非常稀疏，系统会存在非常大的空间浪费。我们举一个极端case，若千万规则库中命中的行ID是第1000万位，按照传统方式BitSet进行存储，需要消耗1.2MB空间，在内存中占用存在严重浪费，有没有压缩优化方案，在RoaringBitMap压缩位图方案中我们找到，相同场景在压缩位图方式下仅占144bytes；即使在1000万的位图空间，我们随机存储1万个值，两者比也是在31K vs 2MB，&lt;strong&gt;近100倍的差距&lt;/strong&gt;，总的来说RoaringBitMap压缩率非常大。&lt;/p&gt;

&lt;p&gt;RoaringBitMap本质上是将大块的bitmap拆分成各个小块，其中每个小块在需要存储数据的时候才会存在，所以当进行交集或并集运算的时候，RoaringBitMap只需要去计算存在的块而不需要像bitmap那样对整个大块进行计算，既做到了压缩的存储又做到计算性能的提升。&lt;/p&gt;

&lt;p&gt;以下图821697800为例，对应的16进制数为30FA1D08， 其中高16 位为30FA，低16位为1D08。先用二分查找从一级索引（即Container Array）中找到数值为 30FA 的容器，该容器是一个Bitmap容器,然后在该容器查找低16位的数值1D08，即十进制下7432，在Bitmap中找到相应的位置，将其置为1即可。&lt;/p&gt;

&lt;p&gt;﻿
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a65df52f9c45dda9e33aa780889e74%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;57.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;p&gt;﻿  &lt;/p&gt;

&lt;h2&gt;适用场景分析&lt;/h2&gt;

&lt;p&gt;回顾上面的设计方案我们可以看到，这种方式仅适用于PostingList简单如行ID的形式，如果是复杂对象就不适合用位图来存储。另外仅适用于等值查询，不适用于like、in的范围查询，为什么有这种局限性？因为这种方式依赖于搜索条件的空间，在方案中我们将值的条件作为搜索的Key，值的条件空间希望尽可能是一个有限的、方便穷举的、小的空间。而范围查询导致这个空间变成难以穷举、近乎无限扩张的、所以不适用。&lt;/p&gt;

&lt;h2&gt;其他优化方式&lt;/h2&gt;

&lt;p&gt;除了使用位运算的方式对倒排索引加速，考虑到Posting List的有序性，还有其他的方式比如使用跳表、Hash表等方式，以ES中采用的跳表为例，进行&amp;amp;运算实际就是在查找两个有序Posting List公共部分，以相互二分查找的形式，将时间复杂度控制在log(n)的级别。&lt;/p&gt;

&lt;p&gt;具体参见&lt;a href=&quot;https://time.geekbang.org/column/article/221292?utm_source=related_read&amp;amp;utm_medium=article&amp;amp;utm_term=related_read&quot;&gt;工业界如何利用跳表、哈希表、位图进行倒排索引加速？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c121b520dd4af3823805ee026a68f8%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;38.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4af6e7f5a3eafcdb3be254778b60654e</guid>
<title>如何设计组件化链路？</title>
<link>https://toutiao.io/k/quzh3k0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-msg__text-area&quot;&gt;
                    &lt;p class=&quot;weui-msg__title warn&quot;&gt;The content has been deleted by the author.&lt;/p&gt;
            &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb5825c1fecde118a1aed6004a9ff69a</guid>
<title>写给大忙人看的 Go 语言快速指南（中文翻译）</title>
<link>https://toutiao.io/k/a60flbu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry marked-body js-toc-content&quot; itemprop=&quot;articleBody&quot;&gt;&lt;p&gt;Go是一种非常受欢迎的编程语言，它具有内置的并发支持和众多其他优秀的特性。在众多现代语言中，Go在基本语言设计方面格外出众。&lt;/p&gt;&lt;p&gt;首先，Go是一种非常简洁的语言，它的简洁性使其与像Lua这样的简单语言相似。Go设计时十分注重简洁主义 &amp;amp;mldr;&lt;/p&gt;&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;Go是一种非常受欢迎的编程语言，它具有内置的并发支持和众多其他优秀的特性。在众多现代语言中，Go在基本语言设计方面格外出众。&lt;/p&gt;&lt;p&gt;首先，Go是一种非常简洁的语言，它的简洁性使其与像Lua这样的简单语言相似。Go设计时十分注重简洁主义。&lt;/p&gt;&lt;p&gt;其次，Go非常重视语言的稳定性，与许多其他语言形成了鲜明的对比。Go更像C语言，自从40多年前创建以来几乎没有任何改变。&lt;/p&gt;&lt;p&gt;最近Go 1.18中引入的泛型是一个例外，但这显然是必要的改变。&lt;/p&gt;&lt;p&gt;第三，在标准库方面，Go是一种&quot;综合性&quot;编程语言，它提供了开发专业软件所需的所有功能，而无需过多依赖外部库。&lt;/p&gt;&lt;p&gt;本书是Go编程语言的&quot;迷你&quot;语言参考手册，它概述了现代Go编程语言（1.18和1.19）的所有基本功能。虽然它是作为参考手册而写的，但你几乎可以从头到尾阅读它，并且应该能够了解Go语言的整体概念（但不一定是所有的细节）。&lt;/p&gt;&lt;p&gt;值得注意的是，与教程风格的书籍不同，本书有大量交叉引用，如果您之前没有使用Go编程的经验，可能会发现很难阅读本书的某些部分。&lt;/p&gt;&lt;p&gt;本书也是我在2022年自由职业期间翻译的一本书，借此机会巩固自己对Go的相关知识。&lt;/p&gt;&lt;h1 id=&quot;阅读地址&quot;&gt;阅读地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://code-zatan.gitbook.io/a-quick-guide-to-the-go-programming-language-for-busy-coders/&quot;&gt;写给大忙人看的Go语言快速指南&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1beff8dd6b77ee3f3d1c287aad90ca2</guid>
<title>彻底学透 Redis，建议收藏</title>
<link>https://toutiao.io/k/dtraxtu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你好，我叫码哥，可以叫我靓仔&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 管道&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们通常使用 Redis 的方式是，发送命令，命令排队，Redis 执行，然后返回结果，这个过程称为Round trip time(简称RTT, 往返时间)。但是如果有多条命令需要执行时，需要消耗 N 次 RTT，经过 N 次 IO 传输，这样效率明显很低。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是 Redis 管道（pipeline）便产生了，一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将&lt;em&gt;多个命令&lt;/em&gt;发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），减少了 RTT，提升了效率&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;重要说明&lt;/strong&gt;: 使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 发布订阅&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;发布订阅是一种消息模式，发送者（sub）发送消息，订阅者（pub）接收消息&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7328687572590011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jZCicJY2ug3olFfZ7m0Y8IQI3icBoURp9Ihp5wllFxAf96ssnIu9gfWvw/640?wx_fmt=png&amp;amp;random=0.16124612770612146&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，发布订阅基于频道实现的，同一个频道可以有多个订阅者，多个发布者。其中任意一个发布者发布消息到频道中，所以订阅者都可以收到该消息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;发布订阅 Redis 演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我在服务器上启动了 4 个 Redis 客户端，2 个订阅者，2 个发布者，订阅者订阅的频道为 channel01&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3234946871310508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jZkaOyHtyr5unPFBibkhESFX0kiby74uJPpEMQ8Jl4qFoT2icZ7UuD1aTw/640?wx_fmt=png&amp;amp;random=0.5331072286879976&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：发布者 1 往 channel01 中发送消息 &quot;wugongzi&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35798319327731093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j7miciciaZQjnwXw4LDiaPmlhs6PYNeJRf2cYw4piaewmCQB2MgoMMvfBLxA/640?wx_fmt=png&amp;amp;random=0.7107839681184107&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 1 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6912114014251781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jxjicZXU82hzuFmLIdswWegyic7icGswyE0IEsV3JPQ3lESZGJVvaPPN9w/640?wx_fmt=png&amp;amp;random=0.932801702642438&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 2 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7142857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j2jeG6bmibrRhMkKrvqo9G2jH3GsZbu0hOOFHVoib5sqwkSHjKYQOPKKA/640?wx_fmt=png&amp;amp;random=0.2957567053663015&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：发布者 2 往频道中发布消息 &quot;hello-redis&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2148962148962149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jhl56JNzQ6mZDdibwT1K4FnEv2A48IMGhbtPWtWQl0OBosZaOrTShIBg/640?wx_fmt=png&amp;amp;random=0.4554117703504412&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 1 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9268867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jVYoianCF0YXJIePphNuxXKSq3NoZnzMZ7QjZS2vkbs2CRZRLlwt0p2w/640?wx_fmt=png&amp;amp;random=0.4084262064096338&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 2 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9147465437788018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jNwN3gyNJSDbJX0kNhsEkZeciaiaZZ6t0gmAR7cRMwNTuRTKbwsDXIgEw/640?wx_fmt=png&amp;amp;random=0.0549752796242815&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 同时支持订阅多个频道：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7017114914425427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jic6iaicrMLMmLmWDYHicbiakibiaBYWl2XRaRJGv3YicT8icICWicuhpicscfpIqg/640?wx_fmt=png&amp;amp;random=0.3368015515822096&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 过期策略&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过期时间使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 可以给每个 key 都设置一个过期时间，过期时间到达后，Redis 会自动删除这个 key。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际生产中，我们还是要求必须要为每个 Redis 的 Key 设置一个过期时间，如果不设置过期时间，时间一久，Redis 内存就会满了，有很多冷数据，依然存在。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置过期时间的命令：EXPIRE key seconds&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用过程中有一点需要注意，就是在每次更新 Redis 时，都需要重新设置过期时间，如果不设置，那个 key 就是永久的，下面给大家演示一下如何使用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.475177304964539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jyoMGV6MiaehDicQx1iaesvbNnb7nklDYoTBdzz6JY3aw2HvD8OuHuUiaicw/640?wx_fmt=png&amp;amp;random=0.5586942244204203&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过期删除策略&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis keys过期有两种方式：被动和主动方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一些客户端尝试访问过期 key 时，Redis 发现 key 已经过期便删除掉这些 key&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，这样是不够的，因为有些过期的 keys，可能永远不会被访问到。 无论如何，这些 keys 应该过期，所以 Redis 会定时删除这些 key&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体就是Redis每秒10次做的事情：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试随机的20个keys进行相关过期检测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除所有已经过期的keys。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有多于25%的keys过期，重复步奏1&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个平凡的概率算法，基本上的假设是，Redis的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事务基本使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务可以一次执行多条命令，Redis 事务有如下特点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MULTI&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;EXEC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;DISCARD&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;WATCH&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 几个命令来实现，MULTI 命令用于开启事务，EXEC 用于提交事务，DISCARD 用于放弃事务，WATCH 可以为 Redis 事务提供 check-and-set （CAS）行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0227920227920229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jL1W3E9nJM0b4s8Sic8deBmks2FaeKKiaIEzzg0vvvfxHEv6OITCyjodQ/640?wx_fmt=png&amp;amp;random=0.3889124070730787&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事务发生错误&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reids 事务发生错误分为两种情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：事务提交前发生错误，也就是在发送命令过程中发生错误，看演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5039494470774092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j6gpNicNVZgpHlZR3J0iaQSicqtFylGhZ7NlMcZofnMeqQaZnNcWdJI0Jg/640?wx_fmt=png&amp;amp;random=0.5303901933630635&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我故意将 incr 命令写错，从结果我们可以看到，这条 incr 没有入队，并且事务执行失败，k1 和 k2 都没有值&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：事务提交后发生错误，也就是在执行命令过程中发生错误，看演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287569573283859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0juz7HgSwuGGlnicmR86kauLxjIMniaiae1y8eicHZIHK4VicStOs0oZZcPLQ/640?wx_fmt=png&amp;amp;random=0.6915067831550987&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的事务命令中，我给 k1 设置了一个 d，然后执行自增命令，最后获取 k1 的值，我们发现第二条命令执行发生了错误，但是整个事务依然提交成功了，从上面现象中可以得出，&lt;strong&gt;Redis 事务不支持回滚操作&lt;/strong&gt;。如果支持的话，整个事务的命令都不应该被执行。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么 Redis 不支持回滚&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下是这种做法的优点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 incr 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 incr ， 回滚是没有办法处理这些情况的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;放弃事务&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当执行 discard 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0038022813688212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jMTgZ90Zl59k768hnd4d0Ja0C8T1hrBAF0V7ZiagKmYtRlicOeeelibvPQ/640?wx_fmt=png&amp;amp;random=0.4380218120697472&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;263&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WATCH 命令使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;watch 使得 exec 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8434504792332268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jvEgFnL0ia3puuA1ZkSFbd5fZ91W20Ev5QDdibqibvyK37SgUjOLNvLyXQ/640?wx_fmt=png&amp;amp;random=0.7640523923259128&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我用 watch 命令监听了 k1 和 k2，然后开启事务，在事务提交之前，k1 的值被修改了，watch 监听到 k1 值被修改，所以事务没有被提交。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 脚本和事务&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reids 持久化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么需要持久化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道 Redis 是内存数据库，主打高性能，速度快。相比 Redis 而言，MySQL 的数据则是保存再硬盘中（其实也有内存版的 MySQL 数据库，但是价格极其昂贵，一般公司不会使用），速度慢，但是稳定性好。你想想 Redis 数据保存在内存中，一旦服务器宕机了，数据岂不是全部都没了，这将会出现很大问题。所以 Redis 为了弥补这一缺陷，提供数据持久化机制，即使服务器宕机，依然可以保证数据不丢失。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;持久化简介&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 提供了两种持久化机制 RDB 和 AOF，适用于不同场景&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB 持久化是通过在指定时间间隔对数据进行快照，比如在 8 点钟对数据进行持久化，那么 Redis 会 fork 一个子进程将 8 点那一刻内存中的数据持久化到磁盘上。触发 RDB 持久化有以下几种方法&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 持久化方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、执行 save 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行 save 命令进行持久会阻塞 Redis，备份期间 Redis 无法对外提供服务，&lt;strong&gt;一般不建议使用&lt;/strong&gt;，使用场景为 Redis 服务器需要停机维护的情况下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、执行 bgsave 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;bgsave 命令不会阻塞 Redis 主进程，持久化期间 Redis 依然可以正常对外提供服务&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、通过配置文件中配置的 save 规则来触发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4558303886925795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j4LhazAicrsjibhdSwxVGRsv47NQX7iazEHWELzBztT7uvibFoib1TwianFsQ/640?wx_fmt=png&amp;amp;random=0.16968829594073265&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;283&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 900 1：900s 内有 1 个 key 发生变化，则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 300 10：300s 内有 10 个 key 发生变化，则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 60 10000：60s 内有 10000 个 key 发生变化（新增、修改、删除），则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save &quot;&quot;：该配置表示关闭 RDB 持久化&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 持久化原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 进行 RDB 时，会 fork 一个子进程来进行数据持久化，这样不妨碍 Redis 继续对外提供服务，提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;曾经面试官出过这样面试题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如 Redis 在 8 点触发了 RDB 持久化，持久化用时 2 分钟，在持久化期间，Redis 中有 100 个 key 被修改了，那么 RDB 文件中的 key 是 8 点那一刻的数据，还是变化的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先不要看答案，自己思考 1 分钟，一个问题只有你自己思考了，才能印象深刻。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，下面我们一起来看下这张图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5009107468123861&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jl5WibYNL8NC5GMbBswQcTiawQeqMgqY8Hjs40snVYjYtOVEAc0L3BovA/640?wx_fmt=png&amp;amp;random=0.4056195687710038&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中我们可以清晰的看到，Redis 备份时，fork 了一个子进程，子进程去做持久化的工作，子进程中的 key 指向了 8 点那一刻的数据，后面 k1 的值修改了，redis 会在内存中创建一个新的值，然后主进程 k1 指针指向新的值，子进程 k1 指针依然指向 19，这样 Redis 持久化的就是 8 点那一刻的数据，不会发生变化。同时，从图中我们也可以看到，Redis 持久化时并不是将内存中数据全部拷贝一份进行备份。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果备份间隔时间较长，RDB 会丢失较多的数据。比如 8 点备份一次，8 点半服务器宕机，那么这半小时内的数据就会丢失了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF 持久化是通过日志的方式，记录每次 Redis 的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以Redis 协议追加保存每次写的操作到文件末尾。Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 持久化配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 是否开启 aof no：关闭；yes: 开启&lt;/span&gt;&lt;br/&gt;appendonly no&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 文件名&lt;/span&gt;&lt;br/&gt;appendfilename &lt;span&gt;&quot;appendonly.aof&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 同步策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# appendfsync always  # 每个命令都写入磁盘，性能较差&lt;/span&gt;&lt;br/&gt;appendfsync everysec  &lt;span&gt;# 每秒写一次磁盘，Redis 默认配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# appendfsync no      # 由操作系统执行，默认Linux配置最多丢失30秒&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 重写期间是否同步&lt;/span&gt;&lt;br/&gt;no-appendfsync-on-rewrite no&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重写触发策略&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-percentage 100 &lt;span&gt;# 触发重写百分比 （指定百分比为0，将禁用aof自动重写功能）&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-min-size 64mb &lt;span&gt;# 触发自动重写的最低文件体积（小于64mb不自动重写）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加载aof时如果有错如何处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 no ，发现错误就会停止，必须修复后才能重新加载。&lt;/span&gt;&lt;br/&gt;aof-load-truncated yes&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 中是否使用 rdb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 开启该选项，触发AOF重写将不再是根据当前内容生成写命令。而是先生成RDB文件写到开头，再将RDB生成期间的发生的增量写命令附加到文件末尾。&lt;/span&gt;&lt;br/&gt;aof-use-rdb-preamble yes&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 文件写入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;aof 文件是命令追加的方式，先将命令写入缓冲区，时间到了再写如磁盘中&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;appendfsync always    &lt;span&gt;# 每个命令都写入磁盘，性能较差&lt;/span&gt;&lt;br/&gt;appendfsync everysec  &lt;span&gt;# 每秒写一次磁盘，Redis 默认配置&lt;/span&gt;&lt;br/&gt;appendfsync no        &lt;span&gt;# 由操作系统执行，默认Linux配置最多丢失30秒&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面配置就是何时写入磁盘中&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 重写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;aof 文件虽然丢失的数据少，但是随着时间的增加，aof 文件体积越来越大，占用磁盘空间越来越大，恢复时间长。所以 redis 会对 aof 文件进行重写，以减少 aof 文件体积&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面以一个例子说明&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-- 重写前的 aof&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 20&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 40&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 35&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k3 34&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 19&lt;br/&gt;&lt;br/&gt;-- 这里 k1 最终的值为 35，k2 最终值为 19，所以不需要写入两个命令&lt;br/&gt;-- 重写后&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 35&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k3 34&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 19&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;混合持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Redis 4.0 版本开始，引入了混合持久化机制，纯AOF方式、RDB+AOF方式，这一策略由配置参数&lt;/span&gt;&lt;code&gt;&lt;span&gt;aof-use-rdb-preamble&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;no：按照AOF格式写入命令，与4.0前版本无差别；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混合持久化优点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大大减少了 aof 文件体积&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快了 aof 文件恢复速度，前面是 rdb ，恢复速度快&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 数据恢复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：纯 AOF&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恢复时，取出 AOF 中命令，一条条执行恢复&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：RDB+AOF&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先执行 RDB 加载流程，执行完毕后，再取出余下命令，开始一条条执行&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 实时性更好，丢失数据更少&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于相同的数据集合，AOF 文件通常会比 RDB 文件大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特定的 fsync 策略下，AOF 会比 RDB 略慢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 恢复速度比 RDB 慢&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式锁介绍&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;学习过 Java 的同学，应该对锁都不陌生。Java 中多个线程访问共享资源时，会出现并发问题，我们通常利用 synchronized 或者 Lock 锁来解决多线程并发访问从而出现的安全问题。细心的同学可能已经发现了， synchronized 或者 Lock 锁解决线程安全问题在单节点情况下是可行的，但是如果服务部署在多台服务器上，本地锁就失效了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式场景下，需要采用新的解决方案，就是今天要说的 Redis 分布式锁。日常业务中，类似抢红包，秒杀等场景都可以使用 Redis 分布式锁来解决并发问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式锁特点&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式在保障安全、高可用的情况下需要具备以下特性&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥性：任意一个时刻，只能有一个客户端获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性：锁只能被持久的客户端删除，不能被其他人删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用，高性能：加锁和解锁消耗的性能少，时间短&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;锁超时：当客户端获取锁后出现故障，没有立即释放锁，该锁要能够在一定时间内释放，否则其他客户端无法获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可重入性：客户端获取到锁后，在持久锁期间可以再次获取到该锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案一：SETNX 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 提供了一个获取分布式锁的命令 SETNX&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;setnx key value&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果获取锁成功，redis 返回 1，获取锁失败 redis 返回 0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354523227383863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jdqtYzLiaT4G7HKEIx52aSSTWcIm8e5Ze7Auu7lfiazAMQZh04Y2SAoUQ/640?wx_fmt=png&amp;amp;random=0.18636350476979135&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;客户端使用伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1,v1) == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 执行逻辑&lt;/span&gt;&lt;br/&gt;     ....&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt;() {&lt;br/&gt;        &lt;br/&gt;    }&lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 执行完成后释放锁&lt;/span&gt;&lt;br/&gt;        del k1;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个命令看似可以达到我们的目的，但是不符合分布式锁的特性，如果客户端在执行业务逻辑过程中，服务器宕机了，finally 中代码还没来得及执行，锁没有释放，也就意味其他客户端永远无法获取到这个锁&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案二：SETNX + EXPIRE&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方案获取锁之后，立即给锁加上一个过期时间，这样即使客户端没有手动释放锁，锁到期后也会自动释放&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0223463687150838&quot; data-type=&quot;png&quot; data-w=&quot;358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jSRSFuy6ic1onxOznjH5phM2mbMiaia7xibPJ7ZAjMjnLG50jIgkprUPJibw/640?wx_fmt=png&amp;amp;random=0.7840977315093971&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们来看下伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1, v1) == &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    expire(key, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;//.... 你的业务逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方案很完美，既可以获取到，又不用担心客户端宕机。等等，这里面真的没有问题吗？再仔细瞅瞅，一瞅就瞅出问题来了&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1, v1) == &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;// 再刚获取锁之后，想要给锁设置过期时间，此时服务器挂了&lt;/span&gt;&lt;br/&gt;    expire(key, &lt;span&gt;10&lt;/span&gt;); &lt;span&gt;// 这条命令没有执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;//.... 你的业务逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的 setnx 命令和 expire 命令不是原子性的，他们之间执行需要一定的等等时间，虽然这个时间很短，但是依然有极小概率出现问题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;使用 Lua 脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然 setnx 和 expire 两个命令非原子性，那么我们让其符合原子性即可，通过 Lua 脚本即可实现。Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体实现如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;setnx&#x27;&lt;/span&gt;,KEYS[1],ARGV[1]) == 1 &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;   redis.call(&lt;span&gt;&#x27;expire&#x27;&lt;/span&gt;,KEYS[1],ARGV[2])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样应该没问题了吧，看似上面的几个问题都很好解决了。不对，再想想，肯定还有没考虑到的&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再来看一段伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 执行 lua 脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取 k1 锁，过期时间 10 s&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (execlua()==&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        buyGoods();&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6255380200860832&quot; data-type=&quot;png&quot; data-w=&quot;1394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j0hPSJVFIcbu3icBuSMmr1ajZuPSEMbjePz9a9tS9E3OvhzSplxB8n3Q/640?wx_fmt=png&amp;amp;random=0.6737068050849393&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中我们可以很清晰发现问题所在&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端 A 还未执行完毕，客户端 B 就获取到了锁，这样就可能导致并发问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端 A 执行完毕，开始删除锁。但此时的锁为 B 所有，相当于删除了属于客户端 B 的锁，这样肯定会发生问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案四：SET EX PX NX + 校验唯一随机值，再删除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然锁有可能被别的客户端删除，那么在删除锁的时候我们加上一层校验，判断释放锁是当前客户端持有的，如果是当前客户端，则允许删除，否则不允许删除。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;EX second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：设置键的过期时间为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 秒。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value EX second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SETEX key second value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PX millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：设置键的过期时间为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 毫秒。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value PX millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PSETEX key millisecond value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：只在键不存在时，才对键进行设置操作。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value NX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SETNX key value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;XX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：只在键已经存在时，才对键进行设置操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(resource_name, random_value, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;s) == &lt;span&gt;1&lt;/span&gt;）{ &lt;span&gt;//加锁, value 传入一个随机数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  &lt;span&gt;//业务处理&lt;/span&gt;&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;// 判断 value 是否相等, 相等才释放锁, 这里判断和删除是非原子性, 真实场景下可以将这两步放入 Lua 脚本中执行&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (random_value.equals(jedis.get(resource_name))) {&lt;br/&gt;         jedis.del(lockKey); &lt;span&gt;//释放锁&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lua 脚本如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&quot;get&quot;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&quot;del&quot;&lt;/span&gt;,KEYS[1])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此方案解决了锁被其他客户端解除的问题，但是依然没有解决锁过期释放，但是业务还没有执行完成的问题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redisson框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案四中并没有解决方法未执行完成，锁就超时释放的问题。这里有个方案大家比较容易想到，那就是锁的超时时间设置长一点，比如2min，一个接口执行时间总不能比 2 min 还长，那你就等着领盒饭吧，哈哈哈。但是这么做，一来是不能每个锁都设置这么久超时时间，二来是如果接口出现异常了，锁只能 2 min 后才能释放，其他客户端等待时间较长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题早就有人想到了，并给出了解决方案，开源框架 Redisson 解决了这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5883084577114428&quot; data-type=&quot;png&quot; data-w=&quot;804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j6WBlCKQ5WddXCQFOAIE7oWCIsCDGU8FrgBEW3fL3jyx6R1xISsaQtw/640?wx_fmt=png&amp;amp;random=0.8792207864280699&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redisson 在方法执行期间，会不断的检测锁是否到期，如果发现锁快要到期，但是方法还没有执行完成，便会延长锁的过期时间，从而解决了锁超时释放问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redlock&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面所介绍的分布式锁，都是在单台 Redis 服务器下的解决方案。真实的生产环境中，我们通常会部署多台 Redis 服务器，也就是集群模式，这种情况上述解决方案就失效了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于集群 Redis，Redis 的作者 antirez 提出了另一种解决方案，Redlock 算法&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redlock 算法大致流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7625&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0juIt0zaKPMW5QHFXuLrUe8MG8y4T6LQF8TaHxWKjdftANuoHw4A4Qow/640?wx_fmt=png&amp;amp;random=0.4016757215005047&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、获取当前Unix时间，以毫秒为单位。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、如果因为某些原因，获取锁失败（&lt;em&gt;没有&lt;/em&gt;在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt; 简单总结一下就是客户端向 Redis 集群中所有服务器发送获取锁的请求，只有半数以上的锁获取成功后，才代表锁获取成功，否则锁获取失败。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群的三种模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在生产环境中，我们使用 Redis 通常采用集群模式，因为单机版 Redis 稳定性可靠性较低，而且存储空间有限。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 支持三种集群模式&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制模式，有一个主，多个从，从而实现读写分离。主机负责写请求，从机负责读请求，减轻主机压力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26366120218579236&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jhhYEMnsCdQJzn6pe3icLwxfZWjAgSd1PQuRVeibKfHx39c44eHsdymRg/640?wx_fmt=png&amp;amp;random=0.22686800259705708&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5512295081967213&quot; data-type=&quot;png&quot; data-w=&quot;976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTOcoPpZzhQLHqvVOh5yd9giaCFbXNEfqUgXIN8IohEpwkvaVibz74MaA/640?wx_fmt=png&amp;amp;random=0.6779851845067002&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从数据库启动成功后，连接主数据库，发送 SYNC 命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（&lt;strong&gt;从数据库初始化完成&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（&lt;strong&gt;从数据库初始化完成后的操作&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持主从复制，主机会自动将数据同步到从机，可以进行读写分离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主从不具备容错和恢复能力，一旦主机挂了，那么整个集群处理可读状态，无法处理写请求，会丢失数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主机宕机后无法自动恢复，只能人工手动恢复&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群存储容量有限，容量上线就是主库的内存的大小，无法存储更多内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;###哨兵集群&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵，我们经常在电视剧中看到一些放哨的，哨兵的作用和这些放哨的差不多，起到监控作用。一旦 Redis 集群出现问题了，哨兵会立即做出相应动作，应对异常情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式是基于主从复制模式上搭建的，因为主从复制模式情况下主服务器宕机，会导致整个集群不可用，需要人工干预，所以哨兵模式在主从复制模式下引入了哨兵来监控整个集群，哨兵模式架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7422818791946308&quot; data-type=&quot;png&quot; data-w=&quot;745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jtuMzqm4enkY4fyBYEmbsVaXhcnAC1QS0jmahdLD5DQfyjGg27HP4Zw/640?wx_fmt=png&amp;amp;random=0.378912921304267&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵会不断地检查主节点和从节点是否运作正常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;自动故障转移（Automatic failover）&lt;/strong&gt;：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;配置提供者（Configuration provider）&lt;/strong&gt;：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;通知（Notification）&lt;/strong&gt;：哨兵可以将故障转移的结果发送给客户端。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;下线判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 下线分为主观下线和客观下线两种&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主观下线：单台哨兵任务主库处于不可用状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客观下线：整个哨兵集群半数以上的哨兵都认为主库处于可不用状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵集群中任意一台服务器判断主库不可用时，此时会发送命令给哨兵集群中的其他服务器确认，其他服务器收到命令后会确认主库的状态，如果不可用，返回 YES，可用则返回 NO，当有半数的服务器都返回 YES，说明主库真的不可用，此时需要重新选举&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5426356589147286&quot; data-type=&quot;jpeg&quot; data-w=&quot;2322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jnlOibfic8iblejg3B4kibY2nP67I9bN0jhoHd8p3WgXLwdtsGP40qqm1vg/640?wx_fmt=jpeg&amp;amp;random=0.9688652998736997&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主库选举&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当哨兵集群判定主库下线了，此时需要重新选举出一个新的主库对外提供服务。那么该由哪个哨兵来完成这个新库选举和切换的动作呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意：这里不能让每个哨兵都去选举，可能会出现每个哨兵选举出的新主库都不同，这样就没法判定，所以需要派出一个代表&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵代表选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵的选举机制其实很简单，就是一个Raft选举算法： &lt;strong&gt;选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;任何一个想成为 Leader 的哨兵，要满足两个条件：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一，拿到半数以上的赞成票；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;新库选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面已经选举出了哨兵代表，此时代表需要完成新主库的选择，新库的选择需要满足以下几个标准&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新库需要处于健康状态，也就是和哨兵之间保持正常的网络连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;salve-priority&lt;/span&gt;&lt;/code&gt;&lt;span&gt;从节点优先级最高（redis.conf）的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择复制偏移量最大，只复制最完整的从节点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面一小节哨兵已经选举出了新的主库，故障转移要实现新老主库之间的切换&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;故障转移流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5997830802603037&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTia9m3qSAe6O5Q689Hxricjmpl4Hib4hEOuDd5QLicBjHQKbt1ybeloIuw/640?wx_fmt=png&amp;amp;random=0.5338738046927538&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵模式优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实现了集群的监控，故障转移，实现了高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有主从复制模式的所有优点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群存储容量有限，容量上线就是主库的内存的大小，无法存储更多内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cluser 集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 的哨兵模式实现了高可用了，但是每台 Redis 服务器上存储的都是相同的数据，浪费内存，而且很难实现容量上的扩展。所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，&lt;strong&gt;也就是说每台 Redis 节点上存储不同的内容&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redis 集群的数据分片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群没有使用一致性hash, 而是引入了 &lt;strong&gt;哈希槽&lt;/strong&gt;的概念.&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;节点 A 包含 0 到 5500号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点 B 包含5501 到 11000 号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点 C 包含11001 到 16384号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;环境：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vmware 虚拟机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CentOS 7&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 6.0.6&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为我是在本机上演示的，所以用的虚拟机&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集群信息如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;master&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6379.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6380.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6381.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：准备三个 redis.conf 配置文件，配置文件信息如下&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# redis6379.conf    master&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 包含命令，有点复用的意思&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6379.pid&lt;br/&gt;port    6379&lt;br/&gt;dbfilename dump6379.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6379.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis6380.conf    slave1&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6380.pid&lt;br/&gt;port    6380&lt;br/&gt;dbfilename dump6380.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6380.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 最后一行设置了主节点的 ip 端口&lt;/span&gt;&lt;br/&gt;replicaof 127.0.0.1 6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis6381.conf    slave2&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6381.pid&lt;br/&gt;port    6381&lt;br/&gt;dbfilename dump6381.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6381.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 最后一行设置了主节点的 ip 端口&lt;/span&gt;&lt;br/&gt;replicaof 127.0.0.1 6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;## 注意 redis.conf 要调整一项，设置后台运行，对咱们操作比较友好&lt;/span&gt;&lt;br/&gt;daemonize yes&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：启动服务器&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-- 首先启动 6379 这台服务器，因为他是主库（启动命令在 redis 安装目录的 bin 目录下）&lt;br/&gt;../bin/redis-server redis6379.conf&lt;br/&gt;-- 接口启动 6380 和 6381&lt;br/&gt;../bin/redis-server redis6380.conf&lt;br/&gt;../bin/redis-server redis6381.conf&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三步：用客户端连接服务器&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;cd&lt;/span&gt; bin&lt;br/&gt;redis-cli -p 6379&lt;br/&gt;redis-cli -p 6380&lt;br/&gt;redis-cli -p 6381&lt;br/&gt;&lt;br/&gt;这里我开了三个窗口分别连接三台 redis 服务器，方便查看&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 6379 客户端输入命令： info replication 可用查看集群信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6642201834862386&quot; data-type=&quot;png&quot; data-w=&quot;545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jfKj0UTbV8cKA47Hn7zTDA7TzXwXMAtWb8VDSgMDukYUCZ40TchBwjQ/640?wx_fmt=png&amp;amp;random=0.4535142205236311&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第四步：数据同步&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在集群已经搭建好了，我们在 6379 服务器写入几条数据，看下可不可以同步到 6380 和 6381&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6379：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35128205128205126&quot; data-type=&quot;png&quot; data-w=&quot;390&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jwn62a33KeOC57m4Q2jEXwEbwfWFQHHVUWhdbmicyAhyqkGPS0LPUY4g/640?wx_fmt=png&amp;amp;random=0.7336346243927414&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6380：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5749318801089919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jWtAUeJZiaF0XPxtxDn889IefibLrBRd2y2MhC9TJOkiaxXbkmVckgsQyg/640?wx_fmt=png&amp;amp;random=0.9077540820945631&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;367&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6381：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.361244019138756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jYe6b47x9SpoTEPwBpNMYpXib1BZnwxj6gV2285UnRiaEsDRMuzGpK98w/640?wx_fmt=png&amp;amp;random=0.7282853023446518&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;418&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中可用看出，数据已经成功同步了&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵集群是在主从复制的基础上构建的，相当于是主从+哨兵&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搭建哨兵模式分为两步：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;搭建主从复制集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加哨兵配置&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式节点信息如下，一主二从，三个哨兵组成一个哨兵集群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;master&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6379.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6380.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6381.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6381&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel1.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel2.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel3.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26381&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制集群的配置同上，这里就不再赘述，下面主要介绍下哨兵的配置，哨兵的配置文件其实非常简单&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 文件内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# sentinel1.conf&lt;/span&gt;&lt;br/&gt;port 26379&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;span&gt;# sentinel2.conf&lt;/span&gt;&lt;br/&gt;port 26380&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;span&gt;# sentinel3.conf&lt;/span&gt;&lt;br/&gt;port 26381&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件创建好了以后就可以启动了，首先启动主从服务器，然后启动哨兵&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;../bin/redis-server redis6379.conf&lt;br/&gt;../bin/redis-server redis6380.conf&lt;br/&gt;../bin/redis-server redis6381.conf&lt;br/&gt;&lt;br/&gt;-- 启动哨兵&lt;br/&gt;../bin/redis-sentinel sentinel1.conf &lt;br/&gt;../bin/redis-sentinel sentinel2.conf &lt;br/&gt;../bin/redis-sentinel sentinel3.conf &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.377491961414791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j5aIY6nOeibMW54njDI1Z0a5xIkFr6kP615AAWC3OoIDnMTVaSibagiaJA/640?wx_fmt=png&amp;amp;random=0.9036448846001819&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1555&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从哨兵的启动日志中我们可用看到主从服务器的信息，以及其他哨兵节点的信息&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从同步功能上面已经演示过了，这里主要测试一下哨兵的故障转移&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我手动将主节点停掉，在 6379 上执行 shutdown 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时我们观察一下哨兵的页面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4626865671641791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jqADulpCE8oxo8hptgF6yh6RY9ZC1y45DewUv40dUB6O8nFfKMTcciaQ/640?wx_fmt=png&amp;amp;random=0.819906181075247&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵检测到了 6379 下线，然后选举出了新的主库 6380&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时我们通过 info replication 命令查看集群信息，发现 6380 已经是主库了，他有一个从节点 6381&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5098360655737705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jNEZLboicBicmLJEeDX7ibaPxjZxMw4DDW6Fk3fhpkibWiaArxtkD5CF6kyQ/640?wx_fmt=png&amp;amp;random=0.7949051846788313&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我手动将 6379 启动，看下 6379 会不会重新变成主库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4847605224963715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jYyhnHuDlLYlffBd0wQOcPHTWYLPdiaTkTo4u09wIia88JKGFsjx8tpBQ/640?wx_fmt=png&amp;amp;random=0.9967648860480147&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重新启动后，我们发现 6379 变成了 80 的从库&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cluser 集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官方推荐，Cluser 集群至少要部署 3 台以上的 master 节点，最好使用 3 主 3 从&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7001.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7001&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7002.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7002&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7003.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7003&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7004.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7004&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7006.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7005&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7006.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7006&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件内容如下，6 个配置文件信息基本相同，编辑好一份后其他文件直接复制修改端口即可&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 端口&lt;/span&gt;&lt;br/&gt;port 7001  &lt;br/&gt;&lt;span&gt;# 启用集群模式&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;br/&gt;&lt;span&gt;# 根据你启用的节点来命名，最好和端口保持一致，这个是用来保存其他节点的名称，状态等信息的&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes_7001.conf &lt;br/&gt;&lt;span&gt;# 超时时间&lt;/span&gt;&lt;br/&gt;cluster-node-timeout 5000&lt;br/&gt;appendonly yes&lt;br/&gt;&lt;span&gt;# 后台运行&lt;/span&gt;&lt;br/&gt;daemonize yes&lt;br/&gt;&lt;span&gt;# 非保护模式&lt;/span&gt;&lt;br/&gt;protected-mode no &lt;br/&gt;pidfile  redis_7001.pid&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后分别启动 6 个节点&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;../bin/redis-server redis7001.conf&lt;br/&gt;../bin/redis-server redis7002.conf&lt;br/&gt;../bin/redis-server redis7003.conf&lt;br/&gt;../bin/redis-server redis7004.conf&lt;br/&gt;../bin/redis-server redis7005.conf&lt;br/&gt;../bin/redis-server redis7006.conf&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动集群&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# --cluster-replicas 1 命令的意思是创建master的时候同时创建一个slave&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006  --cluster-replicas 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动过程有个地方需要输入 yes 确认：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15089163237311384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jOLiavc7PkNSqb6mfNtTLjk6YeoI7fA2iafJsOIWnGGwJ3yYhTLPQomEA/640?wx_fmt=png&amp;amp;random=0.4605689354700546&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动成功后可用看到控制台输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12996632996632998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jHDj1JZ5qbGE2AVKBwbhedFFrCIcFF19KHbxas7XctfiaPQbWGrmzm5w/640?wx_fmt=png&amp;amp;random=0.04272848378632821&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1485&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 个 master 节点，3 个 slave 节点，&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[0]槽位：0-5460&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[1]槽位：5461-10922&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[2]槽位：10923-16383&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;连接 7001 服务器&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis-cli -p 7001 -c 集群模式下需要加上 -c 参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31281198003327787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTuUMTBctN3pIbSGoiblzHXp1RcKXBiakYJ4BnKstiaXSGJ9pPygcRNaicg/640?wx_fmt=png&amp;amp;random=0.9317448817045257&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中可用看出，k1 被放到 7003 主机上了，我们此时获取 k1 ，可用正常获取到&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;登录 7003 也可以正常拿到数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23382045929018788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jnNfzesxPoNsqKcbpNquBAxYwDSjBtLib7JcPrlFnZibUupxf30uX6Opg/640?wx_fmt=png&amp;amp;random=0.8581943808899719&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 缓存问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在服务端中，数据库通常是业务上的瓶颈，为了提高并发量和响应速度，我们通常会采用 Redis 来作为缓存，让尽量多的数据走 Redis 查询，不直接访问数据库。同时 Redis 在使用过程中也会出现各种各样的问题，面对这些问题我们该如何处理？&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透是指，当缓存和数据中都没有对应记录，但是客户端却一直在查询。比如黑客攻击系统，不断的去查询系统中不存在的用户，查询时先走缓存，缓存中没有，再去查数据库；或者电商系统中，用户搜索某类商品，但是这类商品再系统中根本不存在，这次的搜索应该直接返回空&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;网关层增加校验，进行用户鉴权，黑名单控制，接口流量控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于同一类查询，如果缓存和数据库都没有获取到数据，那么可用用一个空缓存记录下来，过期时间 60s，下次遇到同类查询，直接取出缓存中的空数据返回即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用布隆过滤器，布隆过滤器可以用来判断某个元素是否存在于集合中，利用布隆过滤器可以过滤掉一大部分无效请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿是指，缓存中数据失效，在高并发情况下，所有用户的请求全部都打到数据库上，短时间造成数据库压力过大&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;接口限流、熔断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加锁，当第一个用户请求到时，如果缓存中没有，其他用户的请求先锁住，第一个用户查询数据库后立即缓存到 Redis，然后释放锁，这时候其他用户就可以直接查询缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存雪崩&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存雪崩是指 Redis 中大批量的 key 在同一时间，或者某一段时间内一起过期，造成多个 key 的请求全部无法命中缓存，这些请求全部到数据库中，给数据库带来很大压力。与缓存击穿不同，击穿是指一个 key 过期，雪崩是指很多 key 同时过期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存过期时间设置成不同时间，不要再统一时间过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存污染&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存污染是指，由于历史原因，缓存中有很多 key 没有设置过期时间，导致很多 key 其实已经没有用了，但是一直存放在 redis 中，时间久了，redis 内存就被占满了&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存尽量设置过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置缓存淘汰策略为最近最少使用的原则，然后将这些数据删除&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;转自：wugongzi&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;链接：https://www.cnblogs.com/wugongzi/p/16827473.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247497323&amp;amp;idx=1&amp;amp;sn=387d84d644ce6351a05ebca8f8c46df5&amp;amp;chksm=c27fb45df5083d4ba108d4583e019c33941d7d1bd1d6d3f41edd03c0bf81185e43af8861f43c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;把Redis当作队列来用，真的合适‍吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;把Redis当作队列来用，真的合适吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247501704&amp;amp;idx=1&amp;amp;sn=af9a053eb008905af604265600fa50f9&amp;amp;chksm=c27f85bef5080ca8c0ae469a1bc673dc295955c8ac5e59b76a22cdfa48a2653ff749960e032d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;掘地三尺搞定 Redis 与 MySQL ‍数据一致性问题&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「码哥字节」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd9aa17cad88c18a42cd4449b73984db</guid>
<title>下一代 TCP：网络演进的平台</title>
<link>https://toutiao.io/k/5qrfwzh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;随着今年TCP最新规范RFC 9293的发布，IETF对过去几十年TCP的发展做处理阶段性总结，同时也是下一阶段发展的起点。随着网络规模的扩大和发展，也许有一天TCP会消失，或者演变为基于业务的可编程平台，相信今后会有很多好玩的东西出现。原文: [TCP: The &quot;P&quot; is for Platform](https://systemsapproach.substack.com/p/tcp-the-p-is-for-platform &quot;TCP: The &quot;P&quot; is for Platform&quot;)&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着最近TCP新规范(&lt;span&gt;RFC 9293&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;)的发布，我们需要反思TCP在过去几十年的发展，并想知道未来会发生什么。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传输控制协议(TCP)原始规范在1981年作为&lt;span&gt;RFC 793&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;发布。在过去的四十年里，TCP被证明是一个不死板的充满弹性的协议，有众多扩展和实现，因此很难跟踪所有变化，很容易错过某个重要特性。而刚刚发布的RFC 9293(2022年8月)，就是为了解决这个问题。作为一个重要的里程碑，RFC 793现在正式过时了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于经历了TCP大部分发展过程的人来说，阅读RFC 9293就像在回忆中漫步，从愚蠢的窗口综合症到慢启动、快速重传、重复ACK、窗口缩放等等，TCP的历史就是一个系统演进的很好的研究案例。对研究人员来说，提出全新设计是很有诱惑力的想法，但TCP中有太多历史经验和包袱，任何替换方案都需要跨越非常高的门槛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们先忽略掉细节，退后一步看看&quot;系统演进&quot;的故事，其中有几件事让我印象深刻。对于初学者来说，我比较讨厌仅仅基于阅读RFC 9293(及其引用的其他RFC)来从头实现TCP。至于这么做是否可行本就是一个开放问题，多年来TCP一直是由其参考实现定义的，RFC更多的是描述性的而不是规范性的。这不是批评，因为从一开始IETF就偏爱基于实现来定义协议，而RFC 9293则是这一迭代过程中最新的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果由实现驱动规范，那么哪个实现是权威的？答案是当今占主导地位的开源实现，也就是最初由&lt;em&gt;BSD(Berkeley Software Distribution)&lt;/em&gt; Unix所作的实现。BSD及其后代一直延续到今天(最著名的是&lt;span&gt;FreeBSD&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;)，但最终在21世纪初被Linux所取代(现代许多商业操作系统都是从BSD或Linux派生出来的)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是Linux版本的TCP不仅仅是参考实现，可以认为Linux内核为TCP的发展提供了一个平台。在阅读RFC 9293的时候，我隐约记得在TCP扩展的鼎盛时期发表过一个RFC，标题为&quot;TCP扩展是有害的(TCP Extensions Considered Harmful)&quot;，我谷歌了一下，是&lt;span&gt;RFC 1263&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。(其实我也是该研究的合著者，可能我还写过什么东西，但现在早就忘记了。)该RFC介绍了TCP演化的一般机制，而这些机制比TCP扩展选项更合理(实质上是提出了今天被称为&lt;span&gt;语义版本控制&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;的东西)，但其中有一个和现在相关的结论:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;由于缺乏任何替代方案，TCP实际上已经成为实现其他协议的平台。它与内核提供了一个模糊的标准接口，运行在许多机器上，并有定义良好的分发路径。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这让我们陷入了一个模糊的两难处境，是将TCP作为平台来发展传输功能，还是作为Linux网络子系统。但实际上两者并没有区别，可选头字段可以作为向内核添加&quot;传输插件&quot;的一种方法。(这里我使用的是平台的一个简单定义，即它是一种工具或框架，可以随着时间的推移添加新功能。)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将Linux TCP作为可扩展框架的另一个例子是拥塞控制。《&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MTgxODgwNA==&amp;amp;action=getalbum&amp;amp;album_id=2460055314927255553#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;TCP拥塞控制详解&lt;/a&gt;》书中介绍的所有算法都可以在Linux内核中使用(可以选择激活)，在Linux内核中，与TCP本身一样，其实现就是算法的权威定义。因此，出现了一种用于拥塞控制的API，提供了定义良好的方法来不断适应TCP。考虑到特性开发速度，Linux现在提供了一种更为方便安全的方式，即通过&lt;span&gt;*eBPF*&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;(extended Berkeley Packet Filter)通过API动态的向内核注入新的拥塞控制逻辑，从而简化试验新算法或调整现有算法的难度，避开了等待相关Linux内核部署的障碍。还可以方便的定制每个流所使用的拥塞控制算法，以及显式的向决策进程开放设备级入口/出口队列。(这就是在Linux内核中支持&lt;span&gt;CoDel和ECN&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;的方式。)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这真是个好消息，但作为研究如何最有效发展软件的案例，结果还是喜忧参半。例如，就API而言，Linux TCP拥塞控制API不是特别直观，唯一的文档都在&lt;span&gt;代码&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;中。其次是其复杂性，虽然API可以将不同算法替换到TCP中，但理想的接口应该支持复用，使不同传输协议(如SCTP、QUIC)可以复用现有算法，而不必维护单独/平行实现。我们看到的第三个结果是，虽然Linux在使文件系统可替换方面做得很好(可以以&lt;span&gt;安全和高性能的方式&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;完成)，但这种方法并不适用于TCP，因为TCP在整个内核中有太多依赖。所有这些，再加上RFC 1263中所提到的TCP可选项的局限性，可能会让我们得出这样的结论，即TCP在这些年里的发展并没有触及其自身，我们至少会对失去的机会感到遗憾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此同时，云计算基于TCP发展了起来，其重点是提高特性开发速度。一旦能够决定连接的两端各自运行什么代码，(物理层之上的)协议标准就不那么重要了，云计算和现代应用很好利用了这一点。人们不得不怀疑，如今的TCP是否会在未来消失，不是因为会出现全新的替代品，而是因为有可能被云计算实践所取代。&lt;span&gt;QUIC&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;似乎是对这一假设的很好的测试，它既提供了TCP所没有的价值(设计良好且高效的请求/应答机制)，又提供了&lt;span&gt;持续集成和持续部署&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;新特性的现代方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可能的结果是网络作为整体成为一个&lt;span&gt;可编程平台&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;，从终端传输协议到网络交换机的转发流水线，提高所有特性的发布速度。平台越完整、敏捷，RFC所定义的规范就越有可能被淘汰。正如RFC 1263中所说:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;我们希望能够在更短的时间内设计和分发协议，而不是由标准委员会商定可接受的会议时间。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许我们正在接近实现这一目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。 &lt;br/&gt;微信公众号：DeepNoMind&lt;/em&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;RFC 9293: &lt;em&gt;https://www.rfc-editor.org/rfc/rfc9293&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2] &lt;/span&gt;&lt;p&gt;RFC 793: &lt;em&gt;https://www.rfc-editor.org/rfc/rfc793&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3] &lt;/span&gt;&lt;p&gt;FreeBSD: &lt;em&gt;https://www.freebsd.org&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4] &lt;/span&gt;&lt;p&gt;RFC 1263: &lt;em&gt;https://datatracker.ietf.org/doc/html/rfc1263&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5] &lt;/span&gt;&lt;p&gt;语义版本控制: &lt;em&gt;https://semver.org&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;p&gt;eBPF: &lt;em&gt;https://www.kernel.org/doc/html/latest/bpf/index.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;p&gt;TCP拥塞控制详解 | 6. 主动队列管理: &lt;em&gt;https://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247485957&amp;amp;idx=1&amp;amp;sn=ab8fec470c30d41f66dcb6d54c77060b&amp;amp;chksm=fc73b7decb043ec859ab33c90e2f6c23faabac3d0177e913982f67c65f3ad26862368ce35ca8&amp;amp;token=748652781&amp;amp;lang=zh_CN#rd&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8] &lt;/span&gt;&lt;p&gt;tcp_cong.c: &lt;em&gt;https://elixir.bootlin.com/linux/latest/source/net/ipv4/tcp_cong.c&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9] &lt;/span&gt;&lt;p&gt;High Velocity Kernel File Systems with Bento: &lt;em&gt;https://www.usenix.org/conference/fast21/presentation/miller&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10] &lt;/span&gt;&lt;p&gt;QUIC: &lt;em&gt;https://systemsapproach.substack.com/p/the-importance-of-thinking-across&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11] &lt;/span&gt;&lt;p&gt;边缘云之生命周期管理: &lt;em&gt;https://ops.systemsapproach.org/lifecycle.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12] &lt;/span&gt;&lt;p&gt;可编程平台: &lt;em&gt;https://www.youtube.com/watch?v=CcHBE7maCyo&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>