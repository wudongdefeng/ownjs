<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6dbf6ba1b3e361004ae0b5b64e26dee6</guid>
<title>SpringBoot 官方强烈推荐，连接池，太快了！</title>
<link>https://toutiao.io/k/zumxh7v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，我们就可以使用一个虚拟的池子，将这些资源保存起来，当使用的时候，我们就从池子里快速获取一个即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java 中，池化技术应用非常广泛，常见的就有数据库连接池、线程池等，本文主讲连接池，线程池我们将在后续的博客中进行介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;公用池化包 Commons Pool 2&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看一下 Java 中公用的池化包 Commons Pool 2，来了解一下对象池的一般结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我们的业务需求，使用这套 API 能够很容易实现对象的池化管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;!-- https:&lt;span&gt;//mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;2.11.1&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GenericObjectPool 是对象池的核心类，通过传入一个对象池的配置和一个对象的工厂，即可快速创建对象池。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;GenericObjectPool&lt;/span&gt;&lt;span&gt;( &lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; PooledObjectFactory&amp;lt;T&amp;gt; factory, &lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; GenericObjectPoolConfig&amp;lt;T&amp;gt; config)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的常用客户端 Jedis，就是使用 Commons Pool 管理连接池的，可以说是一个最佳实践。下图是 Jedis 使用工厂创建对象的主要代码块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象工厂类最主要的方法就是makeObject，它的返回值是 PooledObject 类型，可以将对象使用 new DefaultPooledObject&amp;lt;&amp;gt;(obj) 进行简单包装返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis.clients.jedis.JedisFactory，使用工厂创建对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; PooledObject&amp;lt;Jedis&amp;gt; &lt;span&gt;makeObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;  Jedis jedis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    jedis = &lt;span&gt;new&lt;/span&gt; Jedis(jedisSocketFactory, clientConfig);&lt;br/&gt;    &lt;span&gt;//主要的耗时操作&lt;/span&gt;&lt;br/&gt;    jedis.connect();&lt;br/&gt;    &lt;span&gt;//返回包装对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultPooledObject&amp;lt;&amp;gt;(jedis);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (JedisException je) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        jedis.quit();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (RuntimeException e) {&lt;br/&gt;        logger.warn(&lt;span&gt;&quot;Error while QUIT&quot;&lt;/span&gt;, e);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        jedis.close();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (RuntimeException e) {&lt;br/&gt;        logger.warn(&lt;span&gt;&quot;Error while close&quot;&lt;/span&gt;, e);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; je;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来介绍一下对象的生成过程，如下图，对象在进行获取时，将首先尝试从对象池里拿出一个，如果对象池中没有空闲的对象，就使用工厂类提供的方法，生成一个新的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;borrowObject&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Duration borrowMaxWaitDuration)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        create = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//首先尝试从池子中获取。&lt;/span&gt;&lt;br/&gt;        p = idleObjects.pollFirst();&lt;br/&gt;        &lt;span&gt;// 池子里获取不到，才调用工厂内生成新实例&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            p = create();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                create = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那对象是存在什么地方的呢？这个存储的职责，就是由一个叫作 LinkedBlockingDeque 的结构来承担的，它是一个双向的队列。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来看一下 GenericObjectPoolConfig 的主要属性：&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// GenericObjectPoolConfig本身的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxTotal = DEFAULT_MAX_TOTAL;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxIdle = DEFAULT_MAX_IDLE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minIdle = DEFAULT_MIN_IDLE;&lt;br/&gt;&lt;span&gt;// 其父类BaseObjectPoolConfig的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lifo = DEFAULT_LIFO;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; fairness = DEFAULT_FAIRNESS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxWaitMillis = DEFAULT_MAX_WAIT_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; evictorShutdownTimeoutMillis = DEFAULT_EVICTOR_SHUTDOWN_TIMEOUT_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numTestsPerEvictionRun = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; EvictionPolicy&amp;lt;T&amp;gt; evictionPolicy = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;// Only 2.6.0 applications set this &lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String evictionPolicyClassName = DEFAULT_EVICTION_POLICY_CLASS_NAME;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnCreate = DEFAULT_TEST_ON_CREATE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnBorrow = DEFAULT_TEST_ON_BORROW;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnReturn = DEFAULT_TEST_ON_RETURN;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testWhileIdle = DEFAULT_TEST_WHILE_IDLE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; blockWhenExhausted = DEFAULT_BLOCK_WHEN_EXHAUSTED;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数很多，要想了解参数的意义，我们首先来看一下一个池化对象在整个池子中的生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，池子的操作主要有两个：一个是业务线程，一个是检测线程。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6370370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3VRBsVia0W9NN5753icN3s62LaQfw6icr3xleZ36Np1UicQ2kURANbrBARA/640?wx_fmt=png&amp;amp;random=0.47793440579756963&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象池在进行初始化时，要指定三个主要的参数：&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;maxTotal 对象池中管理的对象上限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maxIdle 最大空闲数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;minIdle 最小空闲数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中maxTotal 和业务线程有关，当业务线程想要获取对象时，会首先检测是否有空闲的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有，则返回一个；否则进入创建逻辑。此时，如果池中个数已经达到了最大值，就会创建失败，返回空对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象在获取的时候，有一个非常重要的参数，那就是最大等待时间（maxWaitMillis），这个参数对应用方的性能影响是比较大的。该参数默认为 -1，表示永不超时，直到有对象空闲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，如果对象创建非常缓慢或者使用非常繁忙，业务线程会持续阻塞 （blockWhenExhausted 默认为 true），进而导致正常服务也不能运行。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39166666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3KbDCuSReAiaEesryvIWibU7Rdia0paeucwjSGDjGvcu4ddSjJpgEianu6g/640?wx_fmt=png&amp;amp;random=0.8021208315632211&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面试题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般面试官会问：你会把超时参数设置成多大呢？我一般都会把最大等待时间，设置成接口可以忍受的最大延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个正常服务响应时间 10ms 左右，达到 1 秒钟就会感觉到卡顿，那么这个参数设置成 500~1000ms 都是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时之后，会抛出 NoSuchElementException 异常，请求会快速失败，不会影响其他业务线程，这种 Fail Fast 的思想，在互联网应用非常广泛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带有evcit 字样的参数，主要是处理对象逐出的。池化对象除了初始化和销毁的时候比较昂贵，在运行时也会占用系统资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，连接池会占用多条连接，线程池会增加调度开销等。业务在突发流量下，会申请到超出正常情况的对象资源，放在池子中。等这些对象不再被使用，我们就需要把它清理掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超出minEvictableIdleTimeMillis 参数指定值的对象，就会被强制回收掉，这个值默认是 30 分钟；softMinEvictableIdleTimeMillis 参数类似，但它只有在当前对象数量大于 minIdle 的时候才会执行移除，所以前者的动作要更暴力一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有4 个 test 参数：testOnCreate、testOnBorrow、testOnReturn、testWhileIdle，分别指定了在创建、获取、归还、空闲检测的时候，是否对池化对象进行有效性检测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启这些检测，能保证资源的有效性，但它会耗费性能，所以默认为 false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产环境上，建议只将 testWhileIdle 设置为 true，并通过调整空闲检测时间间隔（timeBetweenEvictionRunsMillis），比如 1 分钟，来保证资源的可用性，同时也保证效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JMH 测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用连接池和不使用连接池，它们之间的性能差距到底有多大呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个简单的 JMH 测试例子（见仓库），进行一个简单的 set 操作，为 redis 的 key 设置一个随机值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Fork&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;@State&lt;/span&gt;(Scope.Benchmark) &lt;br/&gt;&lt;span&gt;@Warmup&lt;/span&gt;(iterations = &lt;span&gt;5&lt;/span&gt;, time = &lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;@Measurement&lt;/span&gt;(iterations = &lt;span&gt;5&lt;/span&gt;, time = &lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;@BenchmarkMode&lt;/span&gt;(Mode.Throughput) &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JedisPoolVSJedisBenchmark&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;   JedisPool pool = &lt;span&gt;new&lt;/span&gt; JedisPool(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Benchmark&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testPool&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;       Jedis jedis = pool.getResource(); &lt;br/&gt;       jedis.set(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, UUID.randomUUID().toString()); &lt;br/&gt;       jedis.close(); &lt;br/&gt;   } &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Benchmark&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testJedis&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;       Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;); &lt;br/&gt;       jedis.set(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, UUID.randomUUID().toString()); &lt;br/&gt;       jedis.close(); &lt;br/&gt;   } &lt;br/&gt;   &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将测试结果使用 meta-chart 作图，展示结果如下图所示，可以看到使用了连接池的方式，它的吞吐量是未使用连接池方式的 5 倍！&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3138888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3pcPQCFvwasP1DRnuMGicNHydbVu4JPzAre4T1FCpicXLe79jP3oIMYww/640?wx_fmt=png&amp;amp;random=0.2815531488115892&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库连接池 HikariCP&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HikariCP 源于日语“光る”，光的意思，寓意软件工作速度和光速一样快，它是 SpringBoot 中默认的数据库连接池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库是我们工作中经常使用到的组件，针对数据库设计的客户端连接池是非常多的，它的设计原理与我们在本文开头提到的基本一致，可以有效地减少数据库连接创建、销毁的资源消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同是连接池，它们的性能也是有差别的，下图是 HikariCP 官方的一张测试图，可以看到它优异的性能，官方的 JMH 测试代码见 Github。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.412962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3GsffgTLZhNyEELJwibB4qMrB27ard6biahSVxZMSw939uMtmJickqID9A/640?wx_fmt=png&amp;amp;random=0.46086954360338583&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt; &lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般面试题是这么问的：HikariCP 为什么快呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要有三个方面：&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HikariCP 对性能的一些优化操作，是非常值得我们借鉴的，在之后的博客中，我们将详细分析几个优化场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库连接池同样面临一个最大值（maximumPoolSize）和最小值（minimumIdle）的问题。这里同样有一个非常高频的面试题：你平常会把连接池设置成多大呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多同学认为，连接池的大小设置得越大越好，有的同学甚至把这个值设置成 1000 以上，这是一种误解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据经验，数据库连接，只需要 20~50 个就够用了。具体的大小，要根据业务属性进行调整，但大得离谱肯定是不合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HikariCP 官方是不推荐设置 minimumIdle 这个值的，它将被默认设置成和 maximumPoolSize 一样的大小。如果你的数据库Server端连接资源空闲较大，不妨也可以去掉连接池的动态调整功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，根据数据库查询和事务类型，一个应用中是可以配置多个数据库连接池的，这个优化技巧很少有人知道，在此简要描述一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务类型通常有两种：一种需要快速的响应时间，把数据尽快返回给用户；另外一种是可以在后台慢慢执行，耗时比较长，对时效性要求不高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这两种业务类型，共用一个数据库连接池，就容易发生资源争抢，进而影响接口响应速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然微服务能够解决这种情况，但大多数服务是没有这种条件的，这时就可以对连接池进行拆分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，在同一个业务中，根据业务的属性，我们分了两个连接池，就是来处理这种情况的。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3CUVN1lIcsOl2822cjjap3hMcWJpPXHKApLbLaom1xH25ZJjSOibLaTw/640?wx_fmt=png&amp;amp;random=0.1597479679866669&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HikariCP 还提到了另外一个知识点，在 JDBC4 的协议中，通过 Connection.isValid() 就可以检测连接的有效性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们就不用设置一大堆的 test 参数了，HikariCP 也没有提供这样的参数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结果缓存池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到了这里你可能会发现池（Pool）与缓存（Cache）有许多相似之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们之间的一个共同点，就是将对象加工后，存储在相对高速的区域。我习惯性将缓存看作是数据对象，而把池中的对象看作是执行对象。缓存中的数据有一个命中率问题，而池中的对象一般都是对等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑下面一个场景，jsp 提供了网页的动态功能，它可以在执行后，编译成 class 文件，加快执行速度；再或者，一些媒体平台，会将热门文章，定时转化成静态的 html 页面，仅靠 nginx 的负载均衡即可应对高并发请求（动静分离）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些时候，你很难说清楚，这是针对缓存的优化，还是针对对象进行了池化，它们在本质上只是保存了某个执行步骤的结果，使得下次访问时不需要从头再来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我通常把这种技术叫作结果缓存池（Result Cache Pool），属于多种优化手段的综合。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我来简单总结一下本文的内容重点：我们从 Java 中最通用的公用池化包 Commons Pool 2 说起，介绍了它的一些实现细节，并对一些重要参数的应用做了讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jedis 就是在 Commons Pool 2 的基础上封装的，通过 JMH 测试，我们发现对象池化之后，有了接近 5 倍的性能提升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来介绍了数据库连接池中速度很快的 HikariCP ，它在池化技术之上，又通过编码技巧进行了进一步的性能提升，HikariCP 是我重点研究的类库之一，我也建议你加入自己的任务清单中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说，当你遇到下面的场景，就可以考虑使用池化来增加系统性能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对象的创建或者销毁，需要耗费较多的系统资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象的创建或者销毁，耗时长，需要繁杂的操作和较长时间的等待&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象创建后，通过一些状态重置，可被反复使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将对象池化之后，只是开启了第一步优化。要想达到最优性能，就不得不调整池的一些关键参数，合理的池大小加上合理的超时时间，就可以让池发挥更大的价值。和缓存的命中率类似，对池的监控也是非常重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，可以看到数据库连接池连接数长时间保持在高位不释放，同时等待的线程数急剧增加，这就能帮我们快速定位到数据库的事务问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26296296296296295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tO7NEN7wjr4hbzZaEYFPvcXibSoIaSNW3LkJFASMnVuQIvqAznPTibemWjjoGXJjIMedoOichnoMHDFwwQLkakWtg/640?wx_fmt=png&amp;amp;random=0.8543590938968197&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平常的编码中，有很多类似的场景。比如 Http 连接池，Okhttp 和 Httpclient 就都提供了连接池的概念，你可以类比着去分析一下，关注点也是在连接大小和超时时间上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在底层的中间件，比如 RPC，也通常使用连接池技术加速资源获取，比如 Dubbo 连接池、 Feign 切换成 httppclient 的实现等技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，在不同资源层面的池化设计也是类似的。比如线程池，通过队列对任务进行了二层缓冲，提供了多样的拒绝策略等，线程池我们将在后续的文章中进行介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的这些特性，你同样可以借鉴到连接池技术中，用来缓解请求溢出，创建一些溢出策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现实情况中，我们也会这么做。那么具体怎么做？有哪些做法？这部分内容就留给大家思考了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb0238a46038bf967d2f4ab75d3f2bce</guid>
<title>解决方案｜电力行业应如何应对数字化转型危机</title>
<link>https://toutiao.io/k/lih4aoz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;背景与挑战&lt;/h1&gt;

&lt;p&gt;随着电网公司数字化转型工作的推进和云平台、大数据、物联网、移动化、智能化等新技术的应用，推进高效一体化网络排障定位与深入推进人工智能及大数据技术等在电网信息系统运维中的应用，以及运用前沿科技技术，提高生产管理效益，提升数字电网建设过程中数据的价值已成为电网公司数字化转型工作的必然要求。&lt;/p&gt;

&lt;p&gt;与此同时，伴随着电力行业数字化转型的不断发展，相关企业业务系统的不断更新与设备数量的大幅增加，由此引发了电力行业以下痛点：&lt;/p&gt;



&lt;p&gt;基于以上背景及痛点，如何在不植入探针或 Agent 的情况下监控业务链路运行情况，业务管理人员如何统计分析关键业务指标数据，运维人员如何准确定位故障、排查故障对电力行业相关企业来说均是极大的挑战。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dfc875fd3ca411e9333f545a57c053d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;场景需求分析&lt;/h1&gt;

&lt;p&gt;基于上述背景及挑战分析，电力行业具体包含以下运维场景需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;非侵入式监控：通过非侵入式手段或工具实现对业务拓扑和业务指标数据的监控；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;运维数据分析：统一收集、处理、分析业务系统运维数据、日志数据和关键指标数据；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统一处理展示：对业务系统的物理链路、逻辑拓扑以及指标数据进行集中监控展示；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;故障定位分析：统一告警信息收集、对故障进行关联分析，准确定位故障问题和根因，提升故障处理效率。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;解决方案&lt;/h1&gt;

&lt;h2&gt;整体产品技术架构&lt;/h2&gt;

&lt;p&gt;下图为整体产品技术架构，包含底层立体化监控与管理工具集、中层数字化运维数据中台、顶层数据价值与管理产品集。底层立体化监控与管理工具集包含基础设施监控（DOIM）、业务性能监控（DBPC）以及其他开源及非开源监控工具与日志分析（DOLA）；中层数字化运维数据中台包含数字化运维指标管理体系（DOMM）、面向服务的配置管理（CMDB）、智能分析（DOIA）、数字化运维数据库 (DODB )以及采控平台（DOCC)；顶层数据价值与管理产品集包含数字化运维监控中心（DOMC）、数字化运维事件管理（DOEM）数字化运维工作台、报告报表以及数字化运营服务管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1faec304094949a9b30d6696b5a854bf%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;产品列表及功能&lt;/h2&gt;

&lt;h3&gt;业务性能监控工具&lt;/h3&gt;

&lt;p&gt;下图为业务性能监控工具监控网络流量镜像的具体流程。通过抓取网络镜像流量的方式对业务数据进行分析。业务发起后，业务流量经过多层链路一体化展示，直观明了地展示业务在哪个层级消耗的时间情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09b86fba2e484fd08708fce5cdb16263%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;数字化运维数据库&lt;/h3&gt;

&lt;p&gt;数字化运维数据库能够实时高效的接入用户环境的多种数据源，收集用户环境中的IT和业务数据，进行统一的管理和存储，通过便捷和强大的建模分析工具，将数据进行关联分析、业务建模，结果实时输出给可视化以及其他应用。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据处理：通过数据处理pipeline对流式数据进行实时处理，内置多种数据处理组件以及数据处理模版，开箱即用，全方面满足数据预处理的要求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据存储：高性能的分布式列式存储数据库，大大减少数据对磁盘空间的占用，在相同容量下，能够对更大范围的数据进行实时查询。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据计算：丰富的聚合计算函数和强大的计算能力，充分利于 CPU 资源面。聚合查询的平均响应时间可在3秒以内，一些简单查询可以在毫秒级。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f97f05d7269e42c7a42ff5c93f03754d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;数字化运维算法平台&lt;/h3&gt;

&lt;p&gt;数字化运维算法平台包含指标异常检测、指标预测、日志模式识别、根因分析与推荐、多指标分析、告警降噪等6大 AIOps 场景的20余个智能算法。提供了丰富的算法库，开箱即用，能够支撑丰富的运维场景。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33c53011e61b47f0b8a73f433bff409b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;数字化运营指标体系管理平台&lt;/h3&gt;

&lt;p&gt;数字化运营指标体系管理平台作为上层应用侧产品监控中心重要的数据来源之一，帮助其通过整合业务与IT资源、指标、健康度、告警事件，围绕业务价值构建多维度的运维监控体系，以实现能够快速发现、分析并定位故障，达到全方位、立体化监控的能力。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;静态阈值&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动设定数据区间梯度&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据数值坐落区间获取指标健康度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;动态阈值&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选定算法进行指标异常检测&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;历史数据训练获得算法模型&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;算法结果判定指标健康度&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;健康度设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;生死线指标严重异常时，可一票决定健康度。健康度得分是表征对象健康状态的绝佳指示器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择参与计算的指标元素&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据业务情况分配元素的权重&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;生成健康素计算公式&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;数字化运维监控中心&lt;/h3&gt;

&lt;p&gt;数字化运维监控中心是一款全方位、立体化的实时监控产品，面向企业业务价值与 IT 运维的顶层规划，对业务数据以及基础设施、中间件、服务、应用、调用链等 IT 资源进行统一监控，并通过构建业务关联关系，结合指标、日志、告警等，帮助快速发现、分析并定位故障。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/353d1c7117da406c9a16e8da6cd33a39%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;数字化运维事件管理&lt;/h3&gt;

&lt;p&gt;数字化运维事件管理基于大数据技术和机器学习算法，统一接入与处理来自于各种监控系统的告警消息与数据指标，支持告警事件的过滤、通知、响应、处置、定级、跟踪以及多维分析，最终实现面向告警事件全生命周期的闭环管控。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e4cd1ef3827452a88f1e33fa3261519%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;整体方案流程&lt;/h2&gt;

&lt;p&gt;在数据采集侧，通过业务性能监控工具抓取旁路流量，获取业务系统监控数据，同时通过业务流程梳理，建立业务链路拓扑，实现基于业务实际链路的监控分析，监控数据通过kafka传递至运维数据库。&lt;/p&gt;

&lt;p&gt;运维数据库接收到数据后，对数据进行处理（包括字段提取、拆分、合并、格式转换等）并基于场景需求将不同数据存储到不同的数据库，同时通过查询引擎为应用场景提供数据支撑。&lt;/p&gt;

&lt;p&gt;最后，在监控中心对业务系统拓扑和数据指标进行统一展示，基于规则进行健康度分析和事件告警，通过智能运维算法和大数据分析，实现指标数据的趋势预测和对事件告警的根因分析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60e4da39e0134eaaafaf3a3e8692ec71%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;某电网企业案例分享&lt;/h1&gt;

&lt;h2&gt;需求分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;希望通过不植入代码的方式来监控业务层的指标数据，形成业务链路拓扑图，跟踪业务数据流向，并实时展示关键数据；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过指标历史数据，动态提供指标预测基线、预测数值范围；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对问题，能够进行根因分析，快速进行问题定位；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对接当前使用的告警系统，分析出数据结果后，通过当前正在使用的的告警系统去触发事件。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;云智慧解决方案&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过DBPC工具通过旁路镜像流量的方式获取实时业务数据，以非侵入的方式实现了对业务的监控；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建立运维大数据平台，实现对接收的数据进行统一存储和处理，并提取关键指标数据；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;利用智能算法，对历史数据进行学习，实现了对未来一段时间内的数据趋势预测；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过告警事件管理，对接客户现有告警系统，实现了告警信息的压缩、清洗，并且与现有的工单系统实现关联。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;FlyFish开源福利&lt;/h1&gt;

&lt;p&gt;云智慧已开源数据可视化编排平台 FlyFish 。通过配置数据模型为用户提供上百种可视化图形组件，零编码即可实现符合自己业务需求的炫酷可视化大屏。 同时，飞鱼也提供了灵活的拓展能力，支持组件开发、自定义函数与全局事件等配置， 面向复杂需求场景能够保证高效开发与交付。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;点击下方地址链接，欢迎大家给&lt;/strong&gt; &lt;strong&gt;FlyFish&lt;/strong&gt; &lt;strong&gt;点赞送 Star。参与组件开发，更有万元现金等你来拿。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub 地址： &lt;a href=&quot;https://github.com/CloudWise-OpenSource/FlyFish&quot;&gt;https://github.com/CloudWise-OpenSource/FlyFish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee 地址：&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;https://gitee.com/CloudWise/fly-fish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【飞鱼】加入AIOps社区飞鱼开发者交流群，与 FlyFish 项目 PMC 面对面交流～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1470684025d84f4ea11679754c22635b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2600f40947899c96e02f4adf577a110</guid>
<title>美团二面：加密后的数据如何进行模糊查询</title>
<link>https://toutiao.io/k/4vaukpl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;strong/&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击关注公众号，Java干货&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;及时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/em&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3ODcxMzQzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TNUwKhV0JpRmQZ5QvlZZvNdzX7ICmxzLeD6icmhocv2mrIOJEjicPL5DJ3VItG1w2RKB09zY1sl5uC6LHbuXoqjA/0?wx_fmt=png&quot; data-nickname=&quot;Java技术栈&quot; data-alias=&quot;javastack&quot; data-signature=&quot;专注分享Java技术干货，包括多线程、JVM、Spring Boot、Spring Cloud、Intellij IDEA、Dubbo、Zookeeper、Redis、架构设计、微服务、消息队列、Git、面试题、程序员攻略、最新动态等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道加密后的数据对模糊查询不是很友好，本篇就针对加密数据模糊查询这个问题来展开讲一讲实现的思路，希望对大家有所启发。&lt;/span&gt;&lt;em/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了数据安全我们在开发过程中经常会对重要的数据进行加密存储，常见的有：密码、手机号、电话号码、详细地址、银行卡号、信用卡验证码等信息，这些信息对加解密的要求也不一样，比如说密码我们需要加密存储，一般使用的都是不可逆的慢hash算法，慢hash算法可以避免暴力破解（典型的用时间换安全性）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在检索时我们既不需要解密也不需要模糊查找，直接使用密文完全匹配，但是手机号就不能这样做，因为手机号我们要查看原信息，并且对手机号还需要支持模糊查找，因此我们今天就针对可逆加解密的数据支持模糊查询来看看有哪些实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网上随便搜索了一下，关于《加密后的模糊查询》 的帖子很多，&lt;span&gt;另外，最新面试题整理好了，大家可以在&lt;/span&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot; href=&quot;&quot;&gt;Java面试库&lt;/a&gt;&lt;span&gt;小程序在线刷题。&lt;/span&gt;顺便整理了一下实现的方法，不得不说很多都是不靠谱的做法，甚至有一些沙雕做法，接下来我们就对这些做法来讲讲实现思路和优劣性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;如何对加密后的数据进行模糊查询&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我整理了一下对加密的数据模糊查询大致分为三类做法，如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;沙雕做法（不动脑思考直男的思路，只管实现功能从不深入思考问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常规做法（思考了查询性能问题，也会使用一些存储空间换性能等做法）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;超神做法（比较高端的做法从算法层面上思考）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就对这三种实现方法一一来讲讲实现思路和优劣性，首先我们先看沙雕做法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;沙雕做法&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将所有数据加载到内存中进行解密，解密后通过程序算法来模糊匹配&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将密文数据映射一份明文映射表，俗称tag表，然后模糊查询tag来关联密文数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;沙雕一&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看第一个做法，将所有数据加载到内存中进行解密，这个如果数据量小的话可以使用这个方式来做，这样做既简单又实惠，如果数据量大的话那就是灾难，我们来大致算一下。&lt;/p&gt;&lt;p&gt;一个英文字母(不分大小写)占一个字节的空间，一个中文汉字占两个字节的空间，用&lt;code&gt;DES&lt;/code&gt;来举例，&lt;code&gt;13800138000&lt;/code&gt;加密后的串&lt;code&gt;HE9T75xNx6c5yLmS5l4r6Q==&lt;/code&gt;占&lt;code&gt;24&lt;/code&gt;个字节。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;条数&lt;/th&gt;&lt;th&gt;Bytes&lt;/th&gt;&lt;th&gt;MB&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;100w&lt;/td&gt;&lt;td&gt;2400万&lt;/td&gt;&lt;td&gt;22.89&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1000w&lt;/td&gt;&lt;td&gt;2.4亿&lt;/td&gt;&lt;td&gt;228.89&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1亿&lt;/td&gt;&lt;td&gt;24亿&lt;/td&gt;&lt;td&gt;2288.89&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;轻则上百兆，重则上千兆，这样分分钟给应用程序整成&lt;code&gt;Out of memory&lt;/code&gt;，这样做如果数据少只有几百、几千、几万条时是完全可以这样做的，但是数据量大就强烈不建议了。&lt;/p&gt;&lt;p&gt;推荐一个 Spring Boot 基础实战教程：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;https://github.com/javastacks/spring-boot-best-practice&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;沙雕二&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看第二个做法，将密文数据映射一份明文映射表，然后模糊查询映射表来关联密文数据，what？？？！！！那我们为什么要对数据加密呢，直接不加密不是更好么！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们既然对数据加密肯定是有安全诉求才会这样做，增加一个明文的映射表就违背了安全诉求，这样做既不安全也不方便完全是脱裤子放x，多此一举，强且不推荐。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;常规做法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接下来看看常规的做法，也是最广泛使用的方法，此类方法及满足的数据安全性，又对查询友好。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在数据库实现加密算法函数，在模糊查询的时候使用&lt;code&gt;decode(key) like &#x27;%partial%&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过&lt;code&gt;key like &#x27;%partial%&#x27;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;常规一在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。常规二对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;常规一在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。常规二对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;常规一在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。常规二对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;常规一在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。常规二对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;常规一在数据库中实现与程序一致的加解密算法，修改模糊查询条件，使用数据库加解密函数先解密再模糊查找，这样做的优点是实现成本低，开发使用成本低，只需要将以往的模糊查找稍微修改一下就可以实现，但是缺点也很明显，这样做无法利用数据库的索引来优化查询，甚至有一些数据库可能无法保证与程序实现一致的加解密算法，但是对于常规的加解密算法都可以保证与应用程序一致。如果对查询性能要求不是特别高、对数据安全性要求一般，可以使用常见的加解密算法比如说AES、DES之类的也是一个不错的选择。如果公司有自己的算法实现，并且没有提供多端的算法实现，要么找个算法好的人去研究吃透补全多端实现，要么放弃使用这个办法。常规二对密文数据进行分词组合，将分词组合的结果集分别进行加密，然后存储到扩展列，查询时通过key like &#x27;%partial%&#x27;，这是一个比较划算的实现方法，我们先来分析一下它的实现思路。先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;先对字符进行固定长度的分组，将一个字段拆分为多个，比如说根据4位英文字符（半角），2个中文字符（全角）为一个检索条件，举个例子：&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;ningyu1&lt;/code&gt;使用4个字符为一组的加密方式，第一组ning ，第二组ingy ，第三组ngyu ，第四组gyu1 … 依次类推。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要检索所有包含检索条件4个字符的数据比如：ingy ，加密字符后通过 &lt;code&gt;key like “%partial%”&lt;/code&gt; 查库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道加密后长度会增长，增长的这部分长度存储就是我们要花费的额外成本，典型的使用成本来换取速度，密文增长的幅度随着算法不同而不同以DES举例，&lt;code&gt;13800138000&lt;/code&gt;加密前占11个字节，加密后的串&lt;code&gt;HE9T75xNx6c5yLmS5l4r6Q==&lt;/code&gt;占24个字节，增长是2.18倍，所以一个优秀的算法是多么的重要，能为公司节省不少成本，但是话又说回来算法工程师的工资也不低，所以我也不知道是节省成本还是增加成本，哈哈哈…你们自己算吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;回到主题，这个方法虽然可以实现加密数据的模糊查询，但是对模糊查询的字符长度是有要求的，以我上面举的例子模糊查询字符原文长度必须大于等于4个英文/数字，或者2个汉字，再短的长度不建议支持，因为分词组合会增多从而导致存储的成本增加，反而安全性降低。大家是否都对接过 淘宝、拼多多、JD他们的api，他们对平台订单数据中的用户敏感数据就是加密的同时支持模糊查询，使用就是这个方法，下面我整理了几家电商平台的密文字段检索方案的说明，感兴趣的可以查看下面链接。淘宝密文字段检索方案：https://open.taobao.com/docV3.htm?docId=106213&amp;amp;docType=1阿里巴巴文字段检索方案：https://jaq-doc.alibaba.com/docs/doc.htm?treeId=1&amp;amp;articleId=106213&amp;amp;docType=1拼多多密文字段检索方案：https://open.pinduoduo.com/application/document/browse?idStr=3407B605226E77F2京东密文字段检索方案：https://jos.jd.com/commondoc?listId=345ps. 基本上都是一样的，果然都是互相抄袭，连加密后的数据格式都一致。这个方法优点就是实现起来不算复杂，使用起来也较为简单，算是一个折中的做法，因为会有扩展字段存储成本会有升高，但是可利用数据库索引优化查询速度，推荐使用这个方法。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;回到主题，这个方法虽然可以实现加密数据的模糊查询，但是对模糊查询的字符长度是有要求的，以我上面举的例子模糊查询字符原文长度必须大于等于4个英文/数字，或者2个汉字，再短的长度不建议支持，因为分词组合会增多从而导致存储的成本增加，反而安全性降低。&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;回到主题，这个方法虽然可以实现加密数据的模糊查询，但是对模糊查询的字符长度是有要求的，以我上面举的例子模糊查询字符原文长度必须大于等于4个英文/数字，或者2个汉字，再短的长度不建议支持，因为分词组合会增多从而导致存储的成本增加，反而安全性降低。大家是否都对接过 淘宝、拼多多、JD他们的api，他们对平台订单数据中的用户敏感数据就是加密的同时支持模糊查询，使用就是这个方法，下面我整理了几家电商平台的密文字段检索方案的说明，感兴趣的可以查看下面链接。淘宝密文字段检索方案：https://open.taobao.com/docV3.htm?docId=106213&amp;amp;docType=1阿里巴巴文字段检索方案：https://jaq-doc.alibaba.com/docs/doc.htm?treeId=1&amp;amp;articleId=106213&amp;amp;docType=1拼多多密文字段检索方案：https://open.pinduoduo.com/application/document/browse?idStr=3407B605226E77F2京东密文字段检索方案：https://jos.jd.com/commondoc?listId=345ps. 基本上都是一样的，果然都是互相抄袭，连加密后的数据格式都一致。这个方法优点就是实现起来不算复杂，使用起来也较为简单，算是一个折中的做法，因为会有扩展字段存储成本会有升高，但是可利用数据库索引优化查询速度，推荐使用这个方法。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;大家是否都对接过 淘宝、拼多多、JD他们的api，他们对平台订单数据中的用户敏感数据就是加密的同时支持模糊查询，使用就是这个方法，下面我整理了几家电商平台的密文字段检索方案的说明，感兴趣的可以查看下面链接。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;回到主题，这个方法虽然可以实现加密数据的模糊查询，但是对模糊查询的字符长度是有要求的，以我上面举的例子模糊查询字符原文长度必须大于等于4个英文/数字，或者2个汉字，再短的长度不建议支持，因为分词组合会增多从而导致存储的成本增加，反而安全性降低。大家是否都对接过 淘宝、拼多多、JD他们的api，他们对平台订单数据中的用户敏感数据就是加密的同时支持模糊查询，使用就是这个方法，下面我整理了几家电商平台的密文字段检索方案的说明，感兴趣的可以查看下面链接。淘宝密文字段检索方案：https://open.taobao.com/docV3.htm?docId=106213&amp;amp;docType=1阿里巴巴文字段检索方案：https://jaq-doc.alibaba.com/docs/doc.htm?treeId=1&amp;amp;articleId=106213&amp;amp;docType=1拼多多密文字段检索方案：https://open.pinduoduo.com/application/document/browse?idStr=3407B605226E77F2京东密文字段检索方案：https://jos.jd.com/commondoc?listId=345ps. 基本上都是一样的，果然都是互相抄袭，连加密后的数据格式都一致。这个方法优点就是实现起来不算复杂，使用起来也较为简单，算是一个折中的做法，因为会有扩展字段存储成本会有升高，但是可利用数据库索引优化查询速度，推荐使用这个方法。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ps. 基本上都是一样的，果然都是互相抄袭，连加密后的数据格式都一致。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;回到主题，这个方法虽然可以实现加密数据的模糊查询，但是对模糊查询的字符长度是有要求的，以我上面举的例子模糊查询字符原文长度必须大于等于4个英文/数字，或者2个汉字，再短的长度不建议支持，因为分词组合会增多从而导致存储的成本增加，反而安全性降低。大家是否都对接过 淘宝、拼多多、JD他们的api，他们对平台订单数据中的用户敏感数据就是加密的同时支持模糊查询，使用就是这个方法，下面我整理了几家电商平台的密文字段检索方案的说明，感兴趣的可以查看下面链接。淘宝密文字段检索方案：https://open.taobao.com/docV3.htm?docId=106213&amp;amp;docType=1阿里巴巴文字段检索方案：https://jaq-doc.alibaba.com/docs/doc.htm?treeId=1&amp;amp;articleId=106213&amp;amp;docType=1拼多多密文字段检索方案：https://open.pinduoduo.com/application/document/browse?idStr=3407B605226E77F2京东密文字段检索方案：https://jos.jd.com/commondoc?listId=345ps. 基本上都是一样的，果然都是互相抄袭，连加密后的数据格式都一致。这个方法优点就是实现起来不算复杂，使用起来也较为简单，算是一个折中的做法，因为会有扩展字段存储成本会有升高，但是可利用数据库索引优化查询速度，推荐使用这个方法。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;这个方法优点就是实现起来不算复杂，使用起来也较为简单，算是一个折中的做法，因为会有扩展字段存储成本会有升高，但是可利用数据库索引优化查询速度，推荐使用这个方法。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;超神做法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。从算法层面思考，甚至会设计一个新算法来支持模糊查找这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。数据库中字符数据的模糊匹配加密方法：https://www.jiamisoft.com/blog/6542-zifushujumohupipeijiamifangfa.html这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.一种基于BloomFilter的改进型加密文本模糊搜索机制研究：http://kzyjc.cnjournals.com/html/2019/1/20190112.htm支持快速查询的数据库如何加密：https://www.jiamisoft.com/blog/5961-kuaisuchaxunshujukujiami.html基于Lucene的云端搜索与密文基础上的模糊查询：https://www.cnblogs.com/arthurqin/p/6307153.html基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。云存储中一种支持可验证的模糊查询加密方案：http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2017/7/PDF/160971.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。从算法层面思考，甚至会设计一个新算法来支持模糊查找这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。数据库中字符数据的模糊匹配加密方法：https://www.jiamisoft.com/blog/6542-zifushujumohupipeijiamifangfa.html这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.一种基于BloomFilter的改进型加密文本模糊搜索机制研究：http://kzyjc.cnjournals.com/html/2019/1/20190112.htm支持快速查询的数据库如何加密：https://www.jiamisoft.com/blog/5961-kuaisuchaxunshujukujiami.html基于Lucene的云端搜索与密文基础上的模糊查询：https://www.cnblogs.com/arthurqin/p/6307153.html基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。云存储中一种支持可验证的模糊查询加密方案：http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2017/7/PDF/160971.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;从算法层面思考，甚至会设计一个新算法来支持模糊查找&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。从算法层面思考，甚至会设计一个新算法来支持模糊查找这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。数据库中字符数据的模糊匹配加密方法：https://www.jiamisoft.com/blog/6542-zifushujumohupipeijiamifangfa.html这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.一种基于BloomFilter的改进型加密文本模糊搜索机制研究：http://kzyjc.cnjournals.com/html/2019/1/20190112.htm支持快速查询的数据库如何加密：https://www.jiamisoft.com/blog/5961-kuaisuchaxunshujukujiami.html基于Lucene的云端搜索与密文基础上的模糊查询：https://www.cnblogs.com/arthurqin/p/6307153.html基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。云存储中一种支持可验证的模糊查询加密方案：http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2017/7/PDF/160971.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。从算法层面思考，甚至会设计一个新算法来支持模糊查找这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。数据库中字符数据的模糊匹配加密方法：https://www.jiamisoft.com/blog/6542-zifushujumohupipeijiamifangfa.html这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.一种基于BloomFilter的改进型加密文本模糊搜索机制研究：http://kzyjc.cnjournals.com/html/2019/1/20190112.htm支持快速查询的数据库如何加密：https://www.jiamisoft.com/blog/5961-kuaisuchaxunshujukujiami.html基于Lucene的云端搜索与密文基础上的模糊查询：https://www.cnblogs.com/arthurqin/p/6307153.html基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。云存储中一种支持可验证的模糊查询加密方案：http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2017/7/PDF/160971.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568027&amp;amp;idx=2&amp;amp;sn=03ae9f5a9c45be5da3fcaa481f30bd9d&amp;amp;chksm=eb514faddc26c6bb1c3f14e8b63f5bab96f4fe05913cd1acad680ad82fd8b2901ef6e426303c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我们接下来看看优秀的做法，此类做法难度较高，都是从算法层面来考虑，有些甚至会设计一个新算法，虽然已有一些现成的算法参考，但是大多都是半成品无法拿来直接使用，所以还是要有人去深入研究和整合到自己的应用中去。从算法层面思考，甚至会设计一个新算法来支持模糊查找这个层面大多是专业算法工程师的研究领域，想要设计一个有序的、非不可逆的、密文长度不能增长过快的算法不是一件简单的事情，大致的思路是这样的，使用译码的方式进行加解密，保留密文和原文一样的顺序，从而支持密文模糊匹配，说的比较笼统因为我也不是这方面的专家没有更深一步的研究过，所以我从网上找了一些资料可以参考一下。数据库中字符数据的模糊匹配加密方法：https://www.jiamisoft.com/blog/6542-zifushujumohupipeijiamifangfa.html这里提到的Hill密码处理和模糊匹配加密方法FMES可以重点看看.一种基于BloomFilter的改进型加密文本模糊搜索机制研究：http://kzyjc.cnjournals.com/html/2019/1/20190112.htm支持快速查询的数据库如何加密：https://www.jiamisoft.com/blog/5961-kuaisuchaxunshujukujiami.html基于Lucene的云端搜索与密文基础上的模糊查询：https://www.cnblogs.com/arthurqin/p/6307153.html基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。云存储中一种支持可验证的模糊查询加密方案：http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2017/7/PDF/160971.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;基于Lucene的思路就跟我们上面介绍的常规做法二类似，对字符进行等长度分词，将分词后的结果集加密后存储，只不过存储的db不一样，一个是关系型数据库，一个是es搜索引擎。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们到这里对加密数据的检索方案全部介绍完了，我们首先提到的是网上搜索随处可见的沙雕做法，在这里也讲了不推荐使用这些沙雕做法，尽量使用常规做法，如果公司有专业算法方向人才的话不妨可以考虑基于算法层面的超神做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说从投入、产出比、及实现、使用成本来算的话常规做法二是非常推荐的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：ningyu1.github.io/20201230/encrypted-data-fuzzy-query.html&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;40&quot; data-backw=&quot;462&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/TNUwKhV0JpTGQqtlGfEHkjibtshlaDwVKzjqq2pnpmYC14bKxDtSuhpWZWfVcicj5PFsoSMzuzicKIWZbsBpGXiaicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247549468&amp;amp;idx=2&amp;amp;sn=50dca55eacad0848fee04222b2064841&amp;amp;chksm=eb50872adc270e3c12d8227c1f4ee4b8981a8a847602053fe44c6edd769600b1dbd52759ffec&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Boot 学习笔记，这个太全了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring Boot 学习笔记，这个太全了！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247554606&amp;amp;idx=2&amp;amp;sn=9436ec30386cf5220453cdfd06815330&amp;amp;chksm=eb509318dc271a0e6173f04e88962b5dc69d53c3b3f2680674998121d1581b6eefb96add4916&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;23 种设计模式实战（很全）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;23 种设计模式实战（很全）&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568213&amp;amp;idx=1&amp;amp;sn=7bb58cf6b1d43405757996ed8d333069&amp;amp;chksm=eb514e63dc26c775f3ebd0910a03661b54a58193756a62d669ec294db31e7592ce39cc6b2379&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Nacos 2.1.1 正式发布，真心强！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Nacos 2.1.1 正式发布，真心强！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568281&amp;amp;idx=1&amp;amp;sn=41e6cef864b84a9c896b47dd54bcffb4&amp;amp;chksm=eb514eafdc26c7b936cf8596dcea770a9df647283de52c328b61423c5f64d1ec9dd1daf9136e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阿里一面：Spring Bean 默认是单例的，高并发情况下，如何保证并发安全？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;阿里一面：Spring Bean 如何保证并发安全？&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;amp;mid=2247568290&amp;amp;idx=1&amp;amp;sn=c8c9f8b3da2b4b665eb2311982c8c5a6&amp;amp;chksm=eb514e94dc26c782b66cf763349b9a3fa16bf6c678fe798e1d53bd27377f5c4d5ff8ef75035e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;求求你们了，MyBatis 批量插入别再乱用 foreach 了，5000 条数据花了 14 分钟。。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MyBatis 批量插入别再乱用 foreach 了！&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;265&quot; data-backw=&quot;531&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TNUwKhV0JpQiar894HDic0yJSCHN19dmct0zTB1I3ib1uiaibB0XWIHOJdXWNmq4ZKHTVL6wS24ThQfY5ibqfqNKLung/640&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5004444444444445&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/TNUwKhV0JpQiar894HDic0yJSCHN19dmct0zTB1I3ib1uiaibB0XWIHOJdXWNmq4ZKHTVL6wS24ThQfY5ibqfqNKLung/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1125&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzI3ODcxMzQzMw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TNUwKhV0JpRmQZ5QvlZZvNdzX7ICmxzLeD6icmhocv2mrIOJEjicPL5DJ3VItG1w2RKB09zY1sl5uC6LHbuXoqjA/0?wx_fmt=png&quot; data-nickname=&quot;Java技术栈&quot; data-alias=&quot;javastack&quot; data-signature=&quot;专注分享Java技术干货，包括多线程、JVM、Spring Boot、Spring Cloud、Intellij IDEA、Dubbo、Zookeeper、Redis、架构设计、微服务、消息队列、Git、面试题、程序员攻略、最新动态等。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mpa-template-id=&quot;1536&quot; data-mpa-category=&quot;引导&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jZXlUHNuBN5a6JWIdk82cPD8FSSoqjutJcFTXQH1jWPa2pUnwgsOkb95nNBTkMiamwxeAHKFba0FdqKDthpdlibQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Spring Cloud 微服务最新教程！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb1128a391ff3d617120c4619a92d816</guid>
<title>云原生赋能智能网联汽车消息处理基础框架构建</title>
<link>https://toutiao.io/k/kbdi6na</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;近年来，汽车产业向「电气化、智能化、网联化、共享化」快速演进，「软件定义汽车」模式和 SOA 理念在汽车研发和设计领域逐渐深入。无论是作为智能网联汽车云端底座的 TSP 平台、基于单车智能 ADAS 的自动驾驶体系，还是实现软件定义汽车的 SOA 框架，均需要更加灵活的软件开发、迭代、复用和运行架构保障。&lt;/p&gt;
&lt;p&gt;云原生技术的快速发展和落地，大大改变了车联网应用传统的开发和运行方式。以其灵活、弹性、敏捷、自动化、高可用、易扩展等特性，为汽车行业智能网联和自动驾驶相关软件的开发和运行，提供了平台层面的助力，解决了车联网平台在新趋势下面临的上述挑战。&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;云原生：&lt;/strong&gt; 在 CNCF（云原生计算基金会）的定义中，云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文旨在深入分析云原生技术如何作用于车联网物联网基础设施构建，基于体系中最关键的车端消息采集、移动、处理和分析领域，结合 EMQ 相关数据基础设施软件，实现云原生的车联网基础设施架构。&lt;/p&gt;
&lt;h2 id=&quot;传统车联网平台构建的挑战&quot;&gt;传统车联网平台构建的挑战&lt;/h2&gt;
&lt;p&gt;传统车联网的消息处理框架在构建底层资源和运行平台端的整体框架时，往往采用本地数据中心虚拟机/物理机或云服务商虚拟机进行部署。此种模式在联网车辆快速增多、车端上传数据愈加复杂的场景下，通常会面临如下的痛点和挑战：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各大主机厂若想将在私有数据中心提供车联网服务的模式转变为通过公有云提供车联网服务，传统的以虚拟机为应用承载方式的架构会过于沉重，无法平滑实现车联网混合云迁移需求和混合云的部署模式；&lt;/li&gt;
&lt;li&gt;随着智能化和网联化的快速发展，车联网系统对于消息处理平台的软件迭代能力要求逐渐提高，传统的软件迭代模式无法应对智能网联对于车联网系统敏捷、灵活和快速的能力要求，针对纷繁复杂的消息处理需求和软件迭代也无法响应；&lt;/li&gt;
&lt;li&gt;车联网系统作为主机厂同终端客户最重要的实时沟通系统，需要具备极高的可靠性、可用性和可支撑性。消息处理平台作为核心应用组件，应具备弹性的资源获取能力和自动化伸缩、运维等运营支撑能力。传统的巨石型应用架构和虚拟机部署模式无法满足消息处理平台弹性和自复位的能力要求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;云原生技术赋能新一代车联网消息处理&quot;&gt;云原生技术赋能新一代车联网消息处理&lt;/h2&gt;
&lt;p&gt;CNCF（Cloud Native Computing Foundation）旗下项目中？以容器编排系统 Kubernetes 最为核心和基础。Kubernetes 通过将应用程序的容器组合成逻辑单元，以便于管理与服务发现，其为开源系统，可以自由地部署在企业内部、私有云、混合云或公有云，方便用户做出自由选择。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/0d5e91a11f099f3d034f387c4392795c.jpeg?imageMogr2/thumbnail/1520x&quot; alt=&quot;Kubernetes&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/0d5e91a11f099f3d034f387c4392795c.jpeg?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/0d5e91a11f099f3d034f387c4392795c.jpeg?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/0d5e91a11f099f3d034f387c4392795c.jpeg?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;越来越多的主机厂在业务平台的生产交付场景中，采用云原生技术打造以下能力，助力智能网联汽车的应用演进和发展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;统一部署&lt;/strong&gt;：提供屏蔽底层资源型基础设施差异，一次构建，多处使用的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;易于实施&lt;/strong&gt;：提供 CaaI(Config as an Infrastructure)，即配置即设施的能力，达到配置即运行时效果的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弹性扩容&lt;/strong&gt;：根据业务使用情况进行资源型资源的快速弹性伸缩，提供运行时伸缩，业务应用无感知的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控告警&lt;/strong&gt;：提供完善的监控告警体系，满足生产环境后期维护的可控性能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本迭代可控&lt;/strong&gt;：提供风险可控的版本变更手段，包括版本追溯与回滚的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基于-operator-的-emqx-云原生框架&quot;&gt;基于 Operator 的 EMQX 云原生框架&lt;/h2&gt;
&lt;p&gt;早期 EMQ 产品云原生部署采用的是 Helm 部署方式，Operator 模式的出现为实现自定义资源提供了标准的解决方案，解决了通用 Kubernetes 基础模型元素无法支撑不同业务领域下复杂自动化场景的痛点，为实现更加简单、高效的 EMQX 部署提供了全新的方式。&lt;/p&gt;
&lt;p&gt;简单来说，Operator 模式是一组自定义控制器的集合以及由这些控制器所管理的一系列自定义资源，我们将不再关注于 Pod（容器）、ConfigMap 等基础模型元素，而是将它们聚合为一个应用或者服务。Operator 通过控制器的协调循环来使自定义应用达到我们期望的状态，我们只需要关注该应用的期望状态，通过自定义控制器协调循环逻辑来达到 7*24 小时不间断的应用或者服务的声明周期管理。基于 Operator 的 EMQX 云原生框架，使得用户可以轻松基于 Kubernetes 的模式部署和运维 EMQX 集群。&lt;/p&gt;
&lt;h3 id=&quot;operator-vs-helm&quot;&gt;Operator VS Helm&lt;/h3&gt;
&lt;p&gt;Operator 的管理不仅限于 Pod，也可以是多个资源（比如 SVC 域名等）。从这个角度上来说，Operator 跟 Helm 一样，也是具有编排能力的。从编排角度来看，Helm 与 Operator 有非常多的共性，很难对两者的作用进行区分。Helm 也可以完成分布式系统的部署。&lt;/p&gt;
&lt;p&gt;那么 Operator 跟 Helm 又有什么样的区别呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Helm 的侧重点在于多种多个的资源管理，而对生命周期的管理主要包括创建更新和删除，Helm 通过命令驱动整个的生命周期。&lt;/li&gt;
&lt;li&gt;Operator 对于资源的管理则不仅是创建和交付。由于其可以通过 watch 的方式获取相关资源的变化事件，因此可以实现高可用、可扩展、故障恢复等运维操作。因此 Operator 对于生命周期的管理包括创建、故障恢复、高可用、升级、扩容缩容、异常处理以及最终的清理等等。&lt;/li&gt;
&lt;li&gt;如果把 Helm 比作 RPM，那么 Operator 就是 systemd。RPM 负责应用的安装、删除，而 systemd 则负责应用的启动、重启等等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;operator-工作原理&quot;&gt;Operator 工作原理&lt;/h3&gt;
&lt;p&gt;Operator 使用自定义资源（CR）管理应用及其组件的自定义 Kubernetes 控制器，自定义资源 Kubernetes 中 API 扩展，自定义资源配置 CRD 会明确 CR 并列出 Operator 用户可用的所有配置，Operator 监视 CR 类型并且采取特定于应用的操作，确保当前状态与该资源的理想状态相符。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/9f9901b43ae34d354a72742efeb03fe4.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;Operator 工作原理&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/9f9901b43ae34d354a72742efeb03fe4.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/9f9901b43ae34d354a72742efeb03fe4.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/9f9901b43ae34d354a72742efeb03fe4.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Operator 中主要有以下几种对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CRD：自定义资源的定义，Kubernetes API 服务器会为你所指定的每一个 CRD 版本生成 RESTful 的资源路径。一个 CRD 其实就是定义自己应用业务模型的地方，可以根据业务的需求，完全定制自己所需要的资源对象，如 EMQX Broker、EMQX Enterprise 等这些都是可以被 Kubernetes 直接操作和管理的自定义的资源对象。&lt;/li&gt;
&lt;li&gt;CR：自定义资源，即 CRD 的一个具体实例，是具体的可管理的 Kubernetes 资源对象，可以对其进行正常的生命周期管理，如创建、删除、修改、查询等，同时 CR 对象一般还会包含运行时的状态，如当前的 CR 的真实的状态是什么，用于观察和判断，CR 对象的真正所处于的状态。&lt;/li&gt;
&lt;li&gt;Controller：其实就是控制器真正的用武之地了，它会循环处理工作队列中的动作，按照逻辑协调应用当前状态至期望状态。如观察一个CR 对象被创建了之后，会根据实现的逻辑来处理 CR，让 CR 对象的状态以及 CR 对象所负责的业务逻辑慢慢向期望的状态上靠近，最终达到期望的效果。举例来说：如果定义了一个 EMQX Broker 的 Operator，那在创建 EMQX Broker 的时候，就会一直协调和观察 EMQX Broker 真正的集群是否已创建好，以及每个节点的状态和可用性是否健康。一旦发现不符合期望的状态就会继续协调，始终保持基于事件的机制不断检查和协调，以保证期望的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;emqx-在车联网场景中的云原生实践&quot;&gt;EMQX 在车联网场景中的云原生实践&lt;/h2&gt;
&lt;p&gt;基于 Operator 模式，我们提供了 &lt;a href=&quot;https://www.emqx.com/zh/emqx-kubernetes-operator&quot;&gt;EMQX Operator&lt;/a&gt; 来帮助客户在 Kubernetes 的环境上快速构建和管理 EMQX 集群。&lt;/p&gt;
&lt;p&gt;EMQX Operator 是一个用来帮助用户在 Kubernetes 的环境上快速创建和管理 EMQX 集群的工具。 它可以大大简化部署和管理 EMQX 集群的流程，将其变成一种低成本的、标准化的、可重复性的能力。&lt;/p&gt;
&lt;p&gt;
                &lt;img src=&quot;https://assets.emqx.com/images/fe40aadc70e7c9a875f72a5668b6b32e.png?imageMogr2/thumbnail/1520x&quot; alt=&quot;EMQX 在车联网场景中的云原生实践&quot; sizes=&quot;(max-width: 640px) 100vw, (max-width: 768px) 100vw, 1520px&quot; srcset=&quot;&amp;#10;                        https://assets.emqx.com/images/fe40aadc70e7c9a875f72a5668b6b32e.png?imageMogr2/thumbnail/640x   640w,&amp;#10;                        https://assets.emqx.com/images/fe40aadc70e7c9a875f72a5668b6b32e.png?imageMogr2/thumbnail/768x   768w,&amp;#10;                        https://assets.emqx.com/images/fe40aadc70e7c9a875f72a5668b6b32e.png?imageMogr2/thumbnail/1520x 1520w&amp;#10;                        &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为车联网的核心底层支撑组件，EMQX 可以通过 Kubernetes Operator 进行部署、管理和运维。通过基于云原生的消息处理平台，为车联网场景中的客户开发和运维部署带来了诸多好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无感和滚动更新：以云原生技术构建的车联网消息处理框架，可以轻松实现车联网应用的灰度发布，使得车联网系统升级迭代过程中无需中断服务，让车联网应用的使用者完全无感知，实现无感迭代和滚动更新，提升用户体验；&lt;/li&gt;
&lt;li&gt;统一监控：基于云原生技术，车联网系统的运维者可轻松进行应用集群和节点的监控和管理。通过与 Prometheus 等监控工具的集成，可以轻松获取车联网中最重要的消息处理平台的运行信息，从而更直观清晰地了解业务运行情况，进行相应的业务迭代；&lt;/li&gt;
&lt;li&gt;快速部署：云原生技术可以让车联网开发和运维人员快速部署和调整应用，无论是基于公有云还是私有云环境，均可以轻松部署相应的 EMQX 集群，实现对业务的支撑；&lt;/li&gt;
&lt;li&gt;标准化镜像：EMQX 基于云原生环境提供了标准化的官方容器镜像，当用户系统通过镜像来进行 EMQX 的部署和构建时，可基于标准化镜像进行相应的工作，对于车联网环境中的快速发布和多次构建等需求提供了很好的支撑；&lt;/li&gt;
&lt;li&gt;弹性伸缩：随着车联网应用的深入，整个消息处理框架所需要对接的应用逐步扩展和车联网规模的增大，消息处理平台对资源的弹性能力要求也越来越高，通过 Kubernetes 弹性灵活的资源支撑模式，可以针对应用的使用量进行资源获取、增加和释放，从而节省资源，降低运营成本；&lt;/li&gt;
&lt;li&gt;快速迭代：基于云原生框架构建的车联网应用，可利用持续集成和持续交付流水线实现应用的即时更新和发布，支撑业务对于车联网快速迭代的需求；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;随着云原生理念在各行业的深入，我们相信云原生也将为车联网领域的平台构建与应用开发模式注入新的动力。未来 EMQ 将围绕对 EMQX 新版本特性的支持，不断完善迭代 EMQX Operator，致力于在云原生模式下提供更加丰富可靠的数据基础设施能力，服务于车联网行业。&lt;/p&gt;
&lt;section class=&quot;promotion&quot;&gt;
    &lt;div&gt;&lt;p&gt;
        免费试用 EMQX Cloud
        &lt;/p&gt;&lt;p class=&quot;is-size-14 is-text-normal has-text-weight-normal&quot;&gt;全托管的云原生 MQTT 消息服务&lt;/p&gt;
    &lt;/div&gt;
    &lt;a href=&quot;https://www.emqx.com/zh/signup?continue=https://cloud.emqx.com/console/deployments/0?oper=new&quot; class=&quot;button is-gradient px-5&quot;&gt;开始试用 →&lt;/a&gt;
&lt;/section&gt;&lt;h2 id=&quot;本系列中的其它文章&quot;&gt;本系列中的其它文章&lt;/h2&gt;

&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f92128f71b9a0872b12a0f741e0649f</guid>
<title>解惑篇｜Docker和 K8s 到底啥关系？想学K8s，必须得先学 Docker 吗？</title>
<link>https://toutiao.io/k/yb1awja</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想学K8s，必须得先学会 Docker 吗？这是很多网友在开始琢磨着想要学 K8s 的时候都会冒出来的想法。那么今天我们就跟大家说说这个话题，要回答这个问题，我们需要先搞清楚 Docker 和 K8s 他们的角色是什么，相互之间是什么关系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;K8s 和 Docker 的关系&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 和 K8s 这两个经常一起出现，两者的Logo 看着也有一定联系一个是背上驮着集装箱的鲸鱼一个是船的舵轮。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5492063492063493&quot; data-type=&quot;png&quot; data-w=&quot;630&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7RgfQvj54sswiahCfMprgfHfg9ibib4b7Oh2glCxiaUAaDe4T4sdZRpTZKYNCsnptwCXMkJtz7Cg8obg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;kubernetes and docker&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过两者不能放在一个维度上讨论，Docker 是当前流行的 Linux 容器解决方案，利用 Namespaces 、Cgroups 以及联合文件系统UnionFS 实现了同一主机上容器进程间的相互隔离。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;311&quot; data-ratio=&quot;0.5568965517241379&quot; data-type=&quot;png&quot; data-w=&quot;580&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7RgfQvj54sswiahCfMprgfHicUFHCNiazQNoBo94V9hvfx84ibfFiciac8icnDCC2mZzhSj5niaxQZBwrczA/640?wx_fmt=png&quot;/&gt;&lt;span&gt;容器的原理&lt;/span&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NameSpaces：隔离进程，让进程只能访问到本命名空间里的挂载目录、PID、NetWork 等资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cgroups: 限制进程能使用的计算机系统各项资源的上限，包括 CPU、内存、磁盘、网络带宽等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;联合文件系统UnionFS : 保存一个操作系统的所有文件和目录，在它基础之上添加应用运行依赖的文件。创建容器进程的时候给进程指定Mount Namespace 把镜像文件挂载到容器里，用 chroot 把进程的 Root目录切换到挂载的目录里，从而让容器进程各自拥有独立的操作系统目录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 K8s 是拥有容器编排能力的集群管理解决方案，可以按照应用的定义调度各个运行着应用组件 Docker 容器，但是 Docker 并不是 K8s 对容器的唯一选择，K8s 的 容器运行时支持对接多种容器 ，比如CoreOS公司的Rkt容器（之前称为Rocket，现更名为Rkt），Apache 开源的 Mesos 容器等。只要容器实现了 K8s 容器运行时的接口约定，都能让 K8s 进行调度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6824324324324325&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7RgfQvj54sswiahCfMprgfHVnsAVod0D3h3wQRx0WDCZjfC2HojRZT5pSqJgxnhcOCV4fLkY3J9BQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;红框里的容器运行时负责对接具体的容器实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 公司也推出过自己的容器集群管理方案 Docker Swarm ，跟 K8s 算是竞品，但是在生产上几乎没人使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker Swarm 没有流行起来的深层次的原因就不深究了，从一些IT媒体的报道看，可能的原因是&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;跟 Docker 深度绑定，人天生对集权主义非常反感。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Docker 公司在大规模集群管理上的经验不足，不像谷歌那样能高屋建瓴地给出好的解决方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器用 Docker，需要学到什么程度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完 K8s 和 Docker 的关系后，我们已经有答案了，想学 K8s 不一定非得会 Docker。但是毕竟 Docker 还是目前最流行的 Linux 容器方案，绝大部分情况下我们还是会选择使用 Docker，那么我们 Docker 掌握到什么程度更易于我们学习 K8s 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个主要看我们想学会 K8s 干什么，即使运行在 K8s 之上的容器选择 Docker，如果我们是搭建一些基建类的软件，比如 MySQL、Redis之类的，因为这些组织已经提供了软件容器的镜像，我的使用体验是，完全用不到那些 Docker 的各种命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如要在 K8s 集群上运行一个 MySQL 应用，写好应用的清单文件（就是各种配置和期望的状态），然后直接运行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kubectl apply -f mysql.yaml &lt;/code&gt;就好，K8s 的容器运行时会根据清单文件里的镜像名，帮我们调 Docker 的接口去下载镜像、运行容器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;strategy:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;Recreate&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;mysql:5.7&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;superpass&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;3306&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-persistent-storage&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/var/lib/mysql&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;mysql-config&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/etc/mysql/conf.d/my.cnf&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;my.cnf&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面配置文件，有删减。完整可运行的案例，请参考：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，我们使用 K8s 除了搭建这种基础软件外，学 K8s 更多是让自己开发的服务能运行在 K8s 集群上，&lt;span&gt;依托 K8s 集群管理、调度的能力让服务变得&lt;/span&gt;&lt;span&gt;更具鲁&lt;/span&gt;&lt;span&gt;棒&lt;/span&gt;&lt;span&gt;性、更portable。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;这个时候 Docker 方面的技能就需要掌握基本的 Dockerfile 编写、打包上传镜像的命令。&lt;/span&gt;&lt;span&gt;这部分的几个简单的知识，感觉花个两小时就能掌握，这里推荐一下我以前的文章&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学会这几个简单的 Docker 知识就能支撑我们开始 K8s 的学习和练习啦，其他 Docker 相关的知识完全可以在做 K8s 练习时遇到问题、解决问题的过程中再学。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章把 Docker 和 K8s 的关系给大家做了一个解答，希望还在迟疑自己现有的知识储备能不能直接学 K8s 的，赶紧行动起来，K8s 是典型的入门有点难，后面越用越香。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;扫码关注公众号「网管叨bi叨」&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给网管个星标，第一时间吸我的知识 👆&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网管为大家整理了一本超实用的《Go 开发参考书》收集了70多条开发实践。去公众号回复【gocookbook】即刻领取！&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得有用就点个在看&lt;/span&gt;&lt;span&gt;  👇👇👇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>