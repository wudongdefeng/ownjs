<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5c78ef803dd7ae0f6e289e7e897303eb</guid>
<title>Spring 常见面试题总结</title>
<link>https://toutiao.io/k/o96473m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-9scqi7&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;7v8EVnCm&quot;&gt;首发于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide 在线网站&lt;/a&gt;：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring 常见面试题总结&lt;/a&gt;&lt;/blockquote&gt;&lt;p data-pid=&quot;nudy96yg&quot;&gt;最近在对 JavaGuide 的内容进行重构完善，同步一下最新更新，希望能够帮助你。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 基础&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring 框架?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;gK7cNc4l&quot;&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。&lt;/p&gt;&lt;p data-pid=&quot;9y3MEOYq&quot;&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Wzqeg5Zo&quot;&gt;Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。&lt;/p&gt;&lt;p data-pid=&quot;nkkpEFrV&quot;&gt;Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p&gt;&lt;p data-pid=&quot;KUbDkD9a&quot;&gt;  多提一嘴 ： &lt;b&gt;语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Z3LwOmca&quot;&gt;Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 包含的模块有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tKbFa114&quot;&gt;&lt;b&gt;Spring4.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring4.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;nXvexO22&quot;&gt;&lt;b&gt;Spring5.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring5.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;1FFgtFmt&quot;&gt;Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;p data-pid=&quot;iLr4QDIn&quot;&gt;Spring 各个模块的依赖关系如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring 各个模块的依赖关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Core Container&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Z_VVMrNv&quot;&gt;Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;K3646QSV&quot;&gt;&lt;b&gt;spring-core&lt;/b&gt; ：Spring 框架基本的核心工具类。&lt;/li&gt;&lt;li data-pid=&quot;9vF9JBGs&quot;&gt;&lt;b&gt;spring-beans&lt;/b&gt; ：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;e_L8kqkr&quot;&gt;&lt;b&gt;spring-context&lt;/b&gt; ：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;FXeHR3NT&quot;&gt;&lt;b&gt;spring-expression&lt;/b&gt; ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;AOP&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;k3Y99d18&quot;&gt;&lt;b&gt;spring-aspects&lt;/b&gt; ：该模块为与 AspectJ 的集成提供支持。&lt;/li&gt;&lt;li data-pid=&quot;huVeaLav&quot;&gt;&lt;b&gt;spring-aop&lt;/b&gt; ：提供了面向切面的编程实现。&lt;/li&gt;&lt;li data-pid=&quot;Ru-XhdwN&quot;&gt;&lt;b&gt;spring-instrument&lt;/b&gt; ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Data Access/Integration&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ut4kt8eN&quot;&gt;&lt;b&gt;spring-jdbc&lt;/b&gt; ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。&lt;/li&gt;&lt;li data-pid=&quot;u6CCJnXq&quot;&gt;&lt;b&gt;spring-tx&lt;/b&gt; ：提供对事务的支持。&lt;/li&gt;&lt;li data-pid=&quot;wMXqLx40&quot;&gt;&lt;b&gt;spring-orm&lt;/b&gt; ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。&lt;/li&gt;&lt;li data-pid=&quot;7TWjI5yE&quot;&gt;&lt;b&gt;spring-oxm&lt;/b&gt; ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。&lt;/li&gt;&lt;li data-pid=&quot;PQQ1os_S&quot;&gt;&lt;b&gt;spring-jms&lt;/b&gt; : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring Web&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ixrALGGU&quot;&gt;&lt;b&gt;spring-web&lt;/b&gt; ：对 Web 功能的实现提供一些最基础的支持。&lt;/li&gt;&lt;li data-pid=&quot;Fqkiq7ES&quot;&gt;&lt;b&gt;spring-webmvc&lt;/b&gt; ： 提供对 Spring MVC 的实现。&lt;/li&gt;&lt;li data-pid=&quot;Dm7DFm8K&quot;&gt;&lt;b&gt;spring-websocket&lt;/b&gt; ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。&lt;/li&gt;&lt;li data-pid=&quot;D33QNDHo&quot;&gt;&lt;b&gt;spring-webflux&lt;/b&gt; ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Messaging&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;RT4slfth&quot;&gt;&lt;b&gt;spring-messaging&lt;/b&gt; 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring Test&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;imfUldaz&quot;&gt;Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。&lt;/p&gt;&lt;p data-pid=&quot;e7_s0ZCP&quot;&gt;Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;552oxAOt&quot;&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;&lt;p data-pid=&quot;Lo53yncr&quot;&gt;Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;&lt;p data-pid=&quot;u94FbZd1&quot;&gt;下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sLPRMK7M&quot;&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tviio8fC&quot;&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;&lt;p data-pid=&quot;_tTViVxb&quot;&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;&lt;p data-pid=&quot;2SM3d5Pl&quot;&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring IoC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 Spring IoC 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;SBXNboai&quot;&gt;&lt;b&gt;IoC（Inverse of Control:控制反转）&lt;/b&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;&lt;p data-pid=&quot;fW1gtPK6&quot;&gt;&lt;b&gt;为什么叫控制反转？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;B6SckJBD&quot;&gt;&lt;b&gt;控制&lt;/b&gt; ：指的是对象创建（实例化、管理）的权力&lt;/li&gt;&lt;li data-pid=&quot;GLIM5TGd&quot;&gt;&lt;b&gt;反转&lt;/b&gt; ：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4LuYZ-w-&quot;&gt;将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/p&gt;&lt;p data-pid=&quot;bOszsPJG&quot;&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;&lt;p data-pid=&quot;eZbIM2rD&quot;&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;&lt;p data-pid=&quot;5kTCxP1X&quot;&gt;Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。&lt;/p&gt;&lt;p data-pid=&quot;FgGYn69z&quot;&gt;相关阅读：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring Bean？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;FmIDeai2&quot;&gt;简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。&lt;/p&gt;&lt;p data-pid=&quot;ns-UaZHb&quot;&gt;我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&amp;gt;
&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot;&amp;gt;
   &amp;lt;constructor-arg value=&quot;...&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;p7yBC_xT&quot;&gt;下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;wrhDSNuR&quot;&gt;&lt;code&gt;org.springframework.beans&lt;/code&gt;和 &lt;code&gt;org.springframework.context&lt;/code&gt; 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看&lt;/p&gt;&lt;h3&gt;&lt;b&gt;将一个类声明为 Bean 的注解有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;ruYnlbtH&quot;&gt;&lt;code&gt;@Component&lt;/code&gt; ：通用的注解，可标注任意类为 &lt;code&gt;Spring&lt;/code&gt; 组件。如果一个 Bean 不知道属于哪个层，可以使用&lt;code&gt;@Component&lt;/code&gt; 注解标注。&lt;/li&gt;&lt;li data-pid=&quot;pzCmtxnN&quot;&gt;&lt;code&gt;@Repository&lt;/code&gt; : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;&lt;li data-pid=&quot;L0-1d8MF&quot;&gt;&lt;code&gt;@Service&lt;/code&gt; : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;&lt;li data-pid=&quot;BvA9rlar&quot;&gt;&lt;code&gt;@Controller&lt;/code&gt; : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Component 和 @Bean 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;II1X1pC6&quot;&gt;&lt;code&gt;@Component&lt;/code&gt; 注解作用于类，而&lt;code&gt;@Bean&lt;/code&gt;注解作用于方法。&lt;/li&gt;&lt;li data-pid=&quot;w2N1fWU2&quot;&gt;&lt;code&gt;@Component&lt;/code&gt;通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 &lt;code&gt;@ComponentScan&lt;/code&gt; 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。&lt;code&gt;@Bean&lt;/code&gt; 注解通常是我们在标有该注解的方法中定义产生这个 bean,&lt;code&gt;@Bean&lt;/code&gt;告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;&lt;li data-pid=&quot;UKnx-hWg&quot;&gt;&lt;code&gt;@Bean&lt;/code&gt; 注解比 &lt;code&gt;@Component&lt;/code&gt; 注解的自定义性更强，而且很多地方我们只能通过 &lt;code&gt;@Bean&lt;/code&gt; 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 &lt;code&gt;Spring&lt;/code&gt;容器时，则只能通过 &lt;code&gt;@Bean&lt;/code&gt;来实现。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;vVHWsDfQ&quot;&gt;&lt;code&gt;@Bean&lt;/code&gt;注解使用示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Configuration
public class AppConfig {
    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;It87G_W3&quot;&gt;上面的代码相当于下面的 xml 配置&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;beans&amp;gt;
    &amp;lt;bean id=&quot;transferService&quot; class=&quot;com.acme.TransferServiceImpl&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;FoCf2n4m&quot;&gt;下面这个例子是通过 &lt;code&gt;@Component&lt;/code&gt; 无法实现的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean
public OneService getService(status) {
    case (status)  {
        when 1:
                return new serviceImpl1();
        when 2:
                return new serviceImpl2();
        when 3:
                return new serviceImpl3();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;注入 Bean 的注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;W8Ny18vq&quot;&gt;Spring 内置的 &lt;code&gt;@Autowired&lt;/code&gt; 以及 JDK 内置的 &lt;code&gt;@Resource&lt;/code&gt; 和 &lt;code&gt;@Inject&lt;/code&gt; 都可以用于注入 Bean。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Annotaion&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Source&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Autowired&lt;/td&gt;&lt;td&gt;org.springframework.bean.factory&lt;/td&gt;&lt;td&gt;Spring 2.5+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Resource&lt;/td&gt;&lt;td&gt;javax.annotation&lt;/td&gt;&lt;td&gt;Java JSR-250&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Inject&lt;/td&gt;&lt;td&gt;javax.inject&lt;/td&gt;&lt;td&gt;Java JSR-330&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-pid=&quot;gMlXPbS2&quot;&gt;&lt;code&gt;@Autowired&lt;/code&gt; 和&lt;code&gt;@Resource&lt;/code&gt;使用的比较多一些。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;@Autowired 和 @Resource 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;db5-J1mv&quot;&gt;&lt;code&gt;Autowired&lt;/code&gt; 属于 Spring 内置的注解，默认的注入方式为&lt;code&gt;byType&lt;/code&gt;（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。&lt;/p&gt;&lt;p data-pid=&quot;xGj9T4Tu&quot;&gt;&lt;b&gt;这会有什么问题呢？&lt;/b&gt; 当一个接口存在多个实现类的话，&lt;code&gt;byType&lt;/code&gt;这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。&lt;/p&gt;&lt;p data-pid=&quot;s5bI6VJh&quot;&gt;这种情况下，注入方式会变为 &lt;code&gt;byName&lt;/code&gt;（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 &lt;code&gt;smsService&lt;/code&gt; 就是我这里所说的名称，这样应该比较好理解了吧。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// smsService 就是我们上面所说的名称
@Autowired
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;C4wWKBB5&quot;&gt;举个例子，&lt;code&gt;SmsService&lt;/code&gt; 接口有两个实现类: &lt;code&gt;SmsServiceImpl1&lt;/code&gt;和 &lt;code&gt;SmsServiceImpl2&lt;/code&gt;，且它们都已经被 Spring 容器所管理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
@Autowired
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Autowired
private SmsService smsServiceImpl1;
// 正确注入  SmsServiceImpl1 对象对应的 bean
// smsServiceImpl1 就是我们上面所说的名称
@Autowired
@Qualifier(value = &quot;smsServiceImpl1&quot;)
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;MHg_onW7&quot;&gt;我们还是建议通过 &lt;code&gt;@Qualifier&lt;/code&gt; 注解来显示指定名称而不是依赖变量的名称。&lt;/p&gt;&lt;p data-pid=&quot;at6SLWxr&quot;&gt;&lt;code&gt;@Resource&lt;/code&gt;属于 JDK 提供的注解，默认注入方式为 &lt;code&gt;byName&lt;/code&gt;。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为&lt;code&gt;byType&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;hDkxhPVK&quot;&gt;&lt;code&gt;@Resource&lt;/code&gt; 有两个比较重要且日常开发常用的属性：&lt;code&gt;name&lt;/code&gt;（名称）、&lt;code&gt;type&lt;/code&gt;（类型）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public @interface Resource {
    String name() default &quot;&quot;;
    Class&amp;lt;?&amp;gt; type() default Object.class;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;G320hATB&quot;&gt;如果仅指定 &lt;code&gt;name&lt;/code&gt; 属性则注入方式为&lt;code&gt;byName&lt;/code&gt;，如果仅指定&lt;code&gt;type&lt;/code&gt;属性则注入方式为&lt;code&gt;byType&lt;/code&gt;，如果同时指定&lt;code&gt;name&lt;/code&gt; 和&lt;code&gt;type&lt;/code&gt;属性（不建议这么做）则注入方式为&lt;code&gt;byType&lt;/code&gt;+&lt;code&gt;byName&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
@Resource
private SmsService smsService;
// 正确注入 SmsServiceImpl1 对象对应的 bean
@Resource
private SmsService smsServiceImpl1;
// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
@Resource(name = &quot;smsServiceImpl1&quot;)
private SmsService smsService;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Uj-lq32C&quot;&gt;简单总结一下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;-31wNBNu&quot;&gt;&lt;code&gt;@Autowired&lt;/code&gt; 是 Spring 提供的注解，&lt;code&gt;@Resource&lt;/code&gt; 是 JDK 提供的注解。&lt;/li&gt;&lt;li data-pid=&quot;HhGDk3pn&quot;&gt;&lt;code&gt;Autowired&lt;/code&gt; 默认的注入方式为&lt;code&gt;byType&lt;/code&gt;（根据类型进行匹配），&lt;code&gt;@Resource&lt;/code&gt;默认注入方式为 &lt;code&gt;byName&lt;/code&gt;（根据名称进行匹配）。&lt;/li&gt;&lt;li data-pid=&quot;t8u991iM&quot;&gt;当一个接口存在多个实现类的情况下，&lt;code&gt;@Autowired&lt;/code&gt; 和&lt;code&gt;@Resource&lt;/code&gt;都需要通过名称才能正确匹配到对应的 Bean。&lt;code&gt;Autowired&lt;/code&gt; 可以通过 &lt;code&gt;@Qualifier&lt;/code&gt; 注解来显示指定名称，&lt;code&gt;@Resource&lt;/code&gt;可以通过 &lt;code&gt;name&lt;/code&gt; 属性来显示指定名称。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Bean 的作用域有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;sCHfawnI&quot;&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;adS_Yjmj&quot;&gt;&lt;b&gt;singleton&lt;/b&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;&lt;li data-pid=&quot;0x3m0pjU&quot;&gt;&lt;b&gt;prototype&lt;/b&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 &lt;code&gt;getBean()&lt;/code&gt; 两次，得到的是不同的 Bean 实例。&lt;/li&gt;&lt;li data-pid=&quot;wXGEz9oQ&quot;&gt;&lt;b&gt;request&lt;/b&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;&lt;li data-pid=&quot;DLjm42Xg&quot;&gt;&lt;b&gt;session&lt;/b&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;&lt;li data-pid=&quot;Fgsvnpcm&quot;&gt;&lt;b&gt;application/global-session&lt;/b&gt; （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;&lt;li data-pid=&quot;3TJKID3u&quot;&gt;&lt;b&gt;websocket&lt;/b&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;R_JdiDTV&quot;&gt;&lt;b&gt;如何配置 bean 的作用域呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;UWfZSu2j&quot;&gt;xml 方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wE_O5KFG&quot;&gt;注解方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Bean
@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public Person personPrototype() {
    return new Person();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;单例 Bean 的线程安全问题了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;1Og03y8Z&quot;&gt;大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。&lt;/p&gt;&lt;p data-pid=&quot;VQMo36iv&quot;&gt;常见的有两种解决办法：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;XhmClV0j&quot;&gt;在 Bean 中尽量避免定义可变的成员变量。&lt;/li&gt;&lt;li data-pid=&quot;qzl9CuAk&quot;&gt;在类中定义一个 &lt;code&gt;ThreadLocal&lt;/code&gt; 成员变量，将需要的可变成员变量保存在 &lt;code&gt;ThreadLocal&lt;/code&gt; 中（推荐的一种方式）。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;0kAYvkuM&quot;&gt;不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Bean 的生命周期了解么?&lt;/b&gt;&lt;/h3&gt;&lt;blockquote data-pid=&quot;IXFhwuGZ&quot;&gt; 下面的内容整理自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yemengying.com/2016/07/14/spring-bean-life-cycle/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;yemengying.com/2016/07/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;14/spring-bean-life-cycle/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ，除了这篇文章，再推荐一篇很不错的文章 ：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zrtqsk/p/3735273.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/zrtqsk/p/37&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;35273.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。&lt;br/&gt; &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;0zN289l-&quot;&gt;Bean 容器找到配置文件中 Spring Bean 的定义。&lt;/li&gt;&lt;li data-pid=&quot;YW1HJtU-&quot;&gt;Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。&lt;/li&gt;&lt;li data-pid=&quot;woHD83m4&quot;&gt;如果涉及到一些属性值 利用 &lt;code&gt;set()&lt;/code&gt;方法设置一些属性值。&lt;/li&gt;&lt;li data-pid=&quot;bZvRUqEQ&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanNameAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanName()&lt;/code&gt;方法，传入 Bean 的名字。&lt;/li&gt;&lt;li data-pid=&quot;4Ej1QW4L&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanClassLoaderAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanClassLoader()&lt;/code&gt;方法，传入 &lt;code&gt;ClassLoader&lt;/code&gt;对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;RC-CumvD&quot;&gt;如果 Bean 实现了 &lt;code&gt;BeanFactoryAware&lt;/code&gt; 接口，调用 &lt;code&gt;setBeanFactory()&lt;/code&gt;方法，传入 &lt;code&gt;BeanFactory&lt;/code&gt;对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;oIYb7yhI&quot;&gt;与上面的类似，如果实现了其他 &lt;code&gt;*.Aware&lt;/code&gt;接口，就调用相应的方法。&lt;/li&gt;&lt;li data-pid=&quot;u4S_QHO8&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code&gt;postProcessBeforeInitialization()&lt;/code&gt; 方法&lt;/li&gt;&lt;li data-pid=&quot;N-pE8a6t&quot;&gt;如果 Bean 实现了&lt;code&gt;InitializingBean&lt;/code&gt;接口，执行&lt;code&gt;afterPropertiesSet()&lt;/code&gt;方法。&lt;/li&gt;&lt;li data-pid=&quot;vlqIqrMO&quot;&gt;如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。&lt;/li&gt;&lt;li data-pid=&quot;TPHP8-71&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 &lt;code&gt;BeanPostProcessor&lt;/code&gt; 对象，执行&lt;code&gt;postProcessAfterInitialization()&lt;/code&gt; 方法&lt;/li&gt;&lt;li data-pid=&quot;H8kPiNZZ&quot;&gt;当要销毁 Bean 的时候，如果 Bean 实现了 &lt;code&gt;DisposableBean&lt;/code&gt; 接口，执行 &lt;code&gt;destroy()&lt;/code&gt; 方法。&lt;/li&gt;&lt;li data-pid=&quot;duK-vT4y&quot;&gt;当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;PGYKHLMf&quot;&gt;图示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;HxDrXf6p&quot;&gt;与之比较类似的中文版本:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;Spring AoP&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 AOP 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;2EIq20fg&quot;&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;&lt;p data-pid=&quot;_YhGCITC&quot;&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;b&gt;JDK Proxy&lt;/b&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;b&gt;Cglib&lt;/b&gt; 生成一个被代理对象的子类来作为代理，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot;/&gt;&lt;figcaption&gt;SpringAOPProcess&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;EobvLfPN&quot;&gt;当然你也可以使用 &lt;b&gt;AspectJ&lt;/b&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;&lt;p data-pid=&quot;oQUxgQQp&quot;&gt;AOP 切面编程设计到的一些专业术语：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;术语&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;目标(Target)&lt;/td&gt;&lt;td&gt;被通知的对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理(Proxy)&lt;/td&gt;&lt;td&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;连接点(JoinPoint)&lt;/td&gt;&lt;td&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切入点(Pointcut)&lt;/td&gt;&lt;td&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通知(Advice)&lt;/td&gt;&lt;td&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切面(Aspect)&lt;/td&gt;&lt;td&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Weaving(织入)&lt;/td&gt;&lt;td&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;b&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;RGLhiVth&quot;&gt;&lt;b&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/b&gt; Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;&lt;p data-pid=&quot;blSQt703&quot;&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，&lt;/p&gt;&lt;p data-pid=&quot;3HI6rsG6&quot;&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;AspectJ 定义的通知类型有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;F9iI7Ud8&quot;&gt;&lt;b&gt;Before&lt;/b&gt;（前置通知）：目标对象的方法调用之前触发&lt;/li&gt;&lt;li data-pid=&quot;n9Rz_UH1&quot;&gt;&lt;b&gt;After&lt;/b&gt; （后置通知）：目标对象的方法调用之后触发&lt;/li&gt;&lt;li data-pid=&quot;s487XRlG&quot;&gt;&lt;b&gt;AfterReturning&lt;/b&gt;（返回通知）：目标对象的方法调用完成，在返回结果值之后触发&lt;/li&gt;&lt;li data-pid=&quot;-b3mz5md&quot;&gt;&lt;b&gt;AfterThrowing&lt;/b&gt;（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。&lt;/li&gt;&lt;li data-pid=&quot;kKn6PK1p&quot;&gt;&lt;b&gt;Around&lt;/b&gt;： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;多个切面的执行顺序如何控制？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;O_cPRsP2&quot;&gt;1、通常使用&lt;code&gt;@Order&lt;/code&gt; 注解直接定义切面顺序&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 值越小优先级越高
@Order(3)
@Component
@Aspect
public class LoggingAspect implements Ordered {
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;BlsKQy6r&quot;&gt;&lt;b&gt;2、实现&lt;code&gt;Ordered&lt;/code&gt; 接口重写 &lt;code&gt;getOrder&lt;/code&gt; 方法。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Component
@Aspect
public class LoggingAspect implements Ordered {

    // ....

    @Override
    public int getOrder() {
        // 返回值越小优先级越高
        return 1;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;Spring MVC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;说说自己对于 Spring MVC 了解?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ZJlpHX35&quot;&gt;MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;oiPJZ9m-&quot;&gt;网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/iluwatar/java-design-patterns&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;java-design-patterns&lt;/a&gt;** 项目中就有关于 MVC 的相关介绍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;KZ-dSm4_&quot;&gt;想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。&lt;/p&gt;&lt;p data-pid=&quot;oUCRY22U&quot;&gt;&lt;b&gt;Model 1 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Ojq4C3dj&quot;&gt;很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。&lt;/p&gt;&lt;p data-pid=&quot;gLAcO_-3&quot;&gt;这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot;/&gt;&lt;figcaption&gt;mvc-mode1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;uGyosULX&quot;&gt;&lt;b&gt;Model 2 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;SahhrTFO&quot;&gt;学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MfjcX4tw&quot;&gt;Model:系统涉及的数据，也就是 dao 和 bean。&lt;/li&gt;&lt;li data-pid=&quot;gxlxwgIN&quot;&gt;View：展示模型中的数据，只是用来展示。&lt;/li&gt;&lt;li data-pid=&quot;5HwM1_YP&quot;&gt;Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OePaph3H&quot;&gt;Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。&lt;/p&gt;&lt;p data-pid=&quot;gj4Z27cK&quot;&gt;于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。&lt;/p&gt;&lt;p data-pid=&quot;OLeNDf1a&quot;&gt;&lt;b&gt;Spring MVC 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;xB0OW7d3&quot;&gt;随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。&lt;/p&gt;&lt;p data-pid=&quot;KSnlHZP0&quot;&gt;MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring MVC 的核心组件有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;QhbNnULh&quot;&gt;记住了下面这些组件，也就记住了 SpringMVC 的工作原理。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;5jTJ7hnr&quot;&gt;&lt;b&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;核心的中央处理器&lt;/b&gt;，负责接收请求、分发，并给予客户端响应。&lt;/li&gt;&lt;li data-pid=&quot;qhihpBNa&quot;&gt;&lt;b&gt;&lt;code&gt;HandlerMapping&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;处理器映射器&lt;/b&gt;，根据 uri 去匹配查找能处理的 &lt;code&gt;Handler&lt;/code&gt; ，并会将请求涉及到的拦截器和 &lt;code&gt;Handler&lt;/code&gt; 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;9nTue8Ub&quot;&gt;&lt;b&gt;&lt;code&gt;HandlerAdapter&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;处理器适配器&lt;/b&gt;，根据 &lt;code&gt;HandlerMapping&lt;/code&gt; 找到的 &lt;code&gt;Handler&lt;/code&gt; ，适配执行对应的 &lt;code&gt;Handler&lt;/code&gt;；&lt;/li&gt;&lt;li data-pid=&quot;vp99gvYb&quot;&gt;&lt;b&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;请求处理器&lt;/b&gt;，处理实际请求的处理器。&lt;/li&gt;&lt;li data-pid=&quot;6G4LFGQP&quot;&gt;&lt;b&gt;&lt;code&gt;ViewResolver&lt;/code&gt;&lt;/b&gt; ：&lt;b&gt;视图解析器&lt;/b&gt;，根据 &lt;code&gt;Handler&lt;/code&gt; 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 &lt;code&gt;DispatcherServlet&lt;/code&gt; 响应客户端&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;SpringMVC 工作原理了解吗?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tCwSMP_H&quot;&gt;&lt;b&gt;Spring MVC 原理如下图所示：&lt;/b&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;VIpptJmE&quot;&gt; SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。&lt;br/&gt; &lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ourokoQc&quot;&gt;&lt;b&gt;流程说明（重要）：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;bJrvA-40&quot;&gt;客户端（浏览器）发送请求， &lt;code&gt;DispatcherServlet&lt;/code&gt;拦截请求。&lt;/li&gt;&lt;li data-pid=&quot;JQtdCpTH&quot;&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 根据请求信息调用 &lt;code&gt;HandlerMapping&lt;/code&gt; 。&lt;code&gt;HandlerMapping&lt;/code&gt; 根据 uri 去匹配查找能处理的 &lt;code&gt;Handler&lt;/code&gt;（也就是我们平常说的 &lt;code&gt;Controller&lt;/code&gt; 控制器） ，并会将请求涉及到的拦截器和 &lt;code&gt;Handler&lt;/code&gt; 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;WBR92Nf0&quot;&gt;&lt;code&gt;DispatcherServlet&lt;/code&gt; 调用 &lt;code&gt;HandlerAdapter&lt;/code&gt;适配执行 &lt;code&gt;Handler&lt;/code&gt; 。&lt;/li&gt;&lt;li data-pid=&quot;c93y2oez&quot;&gt;&lt;code&gt;Handler&lt;/code&gt; 完成对用户请求的处理后，会返回一个 &lt;code&gt;ModelAndView&lt;/code&gt; 对象给&lt;code&gt;DispatcherServlet&lt;/code&gt;，&lt;code&gt;ModelAndView&lt;/code&gt; 顾名思义，包含了数据模型以及相应的视图的信息。&lt;code&gt;Model&lt;/code&gt; 是返回的数据对象，&lt;code&gt;View&lt;/code&gt; 是个逻辑上的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;Lf3tF4cG&quot;&gt;&lt;code&gt;ViewResolver&lt;/code&gt; 会根据逻辑 &lt;code&gt;View&lt;/code&gt; 查找实际的 &lt;code&gt;View&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;TUNj9_8G&quot;&gt;&lt;code&gt;DispaterServlet&lt;/code&gt; 把返回的 &lt;code&gt;Model&lt;/code&gt; 传给 &lt;code&gt;View&lt;/code&gt;（视图渲染）。&lt;/li&gt;&lt;li data-pid=&quot;uHwPY_aV&quot;&gt;把 &lt;code&gt;View&lt;/code&gt; 返回给请求者（浏览器）&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;统一异常处理怎么做？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Hwi9N9X9&quot;&gt;推荐使用注解的方式统一异常处理，具体会使用到 &lt;code&gt;@ControllerAdvice&lt;/code&gt; + &lt;code&gt;@ExceptionHandler&lt;/code&gt; 这两个注解 。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    @ExceptionHandler(BaseException.class)
    public ResponseEntity&amp;lt;?&amp;gt; handleAppException(BaseException ex, HttpServletRequest request) {
      //......
    }

    @ExceptionHandler(value = ResourceNotFoundException.class)
    public ResponseEntity&amp;lt;ErrorReponse&amp;gt; handleResourceNotFoundException(ResourceNotFoundException ex, HttpServletRequest request) {
      //......
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Z07RC1lV&quot;&gt;这种异常处理方式下，会给所有或者指定的 &lt;code&gt;Controller&lt;/code&gt; 织入异常处理的逻辑（AOP），当 &lt;code&gt;Controller&lt;/code&gt; 中的方法抛出异常的时候，由被&lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解修饰的方法进行处理。&lt;/p&gt;&lt;p data-pid=&quot;umFlqXGm&quot;&gt;&lt;code&gt;ExceptionHandlerMethodResolver&lt;/code&gt; 中 &lt;code&gt;getMappedMethod&lt;/code&gt; 方法决定了异常具体被哪个被 &lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解修饰的方法处理异常。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Nullable
 private Method getMappedMethod(Class&amp;lt;? extends Throwable&amp;gt; exceptionType) {
  List&amp;lt;Class&amp;lt;? extends Throwable&amp;gt;&amp;gt; matches = new ArrayList&amp;lt;&amp;gt;();
    //找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
  for (Class&amp;lt;? extends Throwable&amp;gt; mappedException : this.mappedMethods.keySet()) {
   if (mappedException.isAssignableFrom(exceptionType)) {
    matches.add(mappedException);
   }
  }
    // 不为空说明有方法处理异常
  if (!matches.isEmpty()) {
      // 按照匹配程度从小到大排序
   matches.sort(new ExceptionDepthComparator(exceptionType));
      // 返回处理异常的方法
   return this.mappedMethods.get(matches.get(0));
  }
  else {
   return null;
  }
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;wRA5FI7I&quot;&gt;从源代码看出：**&lt;code&gt;getMappedMethod()&lt;/code&gt;会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 框架中用到了哪些设计模式？&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;N1K6cL_6&quot;&gt;关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247485303%26idx%3D1%26sn%3D9e4626a1e3f001f9b0d84a6fa0cff04a%26chksm%3Dcea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41%26token%3D255050878%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《面试官:“谈谈 Spring 中都用到了那些设计模式?”。》&lt;/a&gt; 。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;IFH1ehuY&quot;&gt;&lt;b&gt;工厂设计模式&lt;/b&gt; : Spring 使用工厂模式通过 &lt;code&gt;BeanFactory&lt;/code&gt;、&lt;code&gt;ApplicationContext&lt;/code&gt; 创建 bean 对象。&lt;/li&gt;&lt;li data-pid=&quot;0hsOyvNS&quot;&gt;&lt;b&gt;代理设计模式&lt;/b&gt; : Spring AOP 功能的实现。&lt;/li&gt;&lt;li data-pid=&quot;L4lOcbGJ&quot;&gt;&lt;b&gt;单例设计模式&lt;/b&gt; : Spring 中的 Bean 默认都是单例的。&lt;/li&gt;&lt;li data-pid=&quot;qrKW9RWB&quot;&gt;&lt;b&gt;模板方法模式&lt;/b&gt; : Spring 中 &lt;code&gt;jdbcTemplate&lt;/code&gt;、&lt;code&gt;hibernateTemplate&lt;/code&gt; 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。&lt;/li&gt;&lt;li data-pid=&quot;cj2iAytq&quot;&gt;&lt;b&gt;包装器设计模式&lt;/b&gt; : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。&lt;/li&gt;&lt;li data-pid=&quot;w7BSWwFR&quot;&gt;&lt;b&gt;观察者模式:&lt;/b&gt; Spring 事件驱动模型就是观察者模式很经典的一个应用。&lt;/li&gt;&lt;li data-pid=&quot;epzq-ctk&quot;&gt;&lt;b&gt;适配器模式&lt;/b&gt; : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配&lt;code&gt;Controller&lt;/code&gt;。&lt;/li&gt;&lt;li data-pid=&quot;oELTsTvK&quot;&gt;......&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;Spring 事务&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;sHH3nNOf&quot;&gt;Spring/SpringBoot 模块下专门有一篇是讲 Spring 事务的，总结的非常详细，通俗易懂。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 管理事务的方式有几种？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;vktpz016&quot;&gt;&lt;b&gt;编程式事务&lt;/b&gt; ： 在代码中硬编码(不推荐使用) : 通过 &lt;code&gt;TransactionTemplate&lt;/code&gt;或者 &lt;code&gt;TransactionManager&lt;/code&gt; 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。&lt;/li&gt;&lt;li data-pid=&quot;_Getd0bq&quot;&gt;&lt;b&gt;声明式事务&lt;/b&gt; ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于&lt;code&gt;@Transactional&lt;/code&gt; 的全注解方式使用最多）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring 事务中哪几种事务传播行为?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ZQ4lFy6S&quot;&gt;&lt;b&gt;事务传播行为是为了解决业务层方法之间互相调用的事务问题&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;BXBP4lhI&quot;&gt;当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。&lt;/p&gt;&lt;p data-pid=&quot;JCQWQaQH&quot;&gt;正确的事务传播行为可能的值如下:&lt;/p&gt;&lt;p data-pid=&quot;xhfVN7tT&quot;&gt;&lt;b&gt;1.&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ve9qcBie&quot;&gt;使用的最多的一个事务传播行为，我们平时经常使用的&lt;code&gt;@Transactional&lt;/code&gt;注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。&lt;/p&gt;&lt;p data-pid=&quot;q9rmNhUm&quot;&gt;&lt;b&gt;&lt;code&gt;2.TransactionDefinition.PROPAGATION_REQUIRES_NEW&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;l5mDdz-u&quot;&gt;创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，&lt;code&gt;Propagation.REQUIRES_NEW&lt;/code&gt;修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。&lt;/p&gt;&lt;p data-pid=&quot;Ki5-ORmX&quot;&gt;&lt;b&gt;3.&lt;code&gt;TransactionDefinition.PROPAGATION_NESTED&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;buPRR_Z8&quot;&gt;如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于&lt;code&gt;TransactionDefinition.PROPAGATION_REQUIRED&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;_yj41NbJ&quot;&gt;&lt;b&gt;4.&lt;code&gt;TransactionDefinition.PROPAGATION_MANDATORY&lt;/code&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;FiurD77R&quot;&gt;如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）&lt;/p&gt;&lt;p data-pid=&quot;BKRzGoB4&quot;&gt;这个使用的很少。&lt;/p&gt;&lt;p data-pid=&quot;GzfyfQT1&quot;&gt;若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;vlWKKDRH&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_SUPPORTS&lt;/code&gt;&lt;/b&gt;: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。&lt;/li&gt;&lt;li data-pid=&quot;TwttbZiH&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NOT_SUPPORTED&lt;/code&gt;&lt;/b&gt;: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。&lt;/li&gt;&lt;li data-pid=&quot;tg0-Dw4j&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.PROPAGATION_NEVER&lt;/code&gt;&lt;/b&gt;: 以非事务方式运行，如果当前存在事务，则抛出异常。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring 事务中的隔离级别有哪几种?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;wUkJ278g&quot;&gt;和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：&lt;code&gt;Isolation&lt;/code&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public enum Isolation {

    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),

    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),

    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),

    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),

    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);

    private final int value;

    Isolation(int value) {
        this.value = value;
    }

    public int value() {
        return this.value;
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;txkM8Jzd&quot;&gt;下面我依次对每一种事务隔离级别进行介绍：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;B4zKVeby&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_DEFAULT&lt;/code&gt;&lt;/b&gt; :使用后端数据库默认的隔离级别，MySQL 默认采用的 &lt;code&gt;REPEATABLE_READ&lt;/code&gt; 隔离级别 Oracle 默认采用的 &lt;code&gt;READ_COMMITTED&lt;/code&gt; 隔离级别.&lt;/li&gt;&lt;li data-pid=&quot;T75dNcAo&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_UNCOMMITTED&lt;/code&gt;&lt;/b&gt; :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，&lt;b&gt;可能会导致脏读、幻读或不可重复读&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;hHIaSC1u&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_READ_COMMITTED&lt;/code&gt;&lt;/b&gt; : 允许读取并发事务已经提交的数据，&lt;b&gt;可以阻止脏读，但是幻读或不可重复读仍有可能发生&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;czKCxWgt&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_REPEATABLE_READ&lt;/code&gt;&lt;/b&gt; : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，&lt;b&gt;可以阻止脏读和不可重复读，但幻读仍有可能发生。&lt;/b&gt;&lt;/li&gt;&lt;li data-pid=&quot;ckkXmANy&quot;&gt;&lt;b&gt;&lt;code&gt;TransactionDefinition.ISOLATION_SERIALIZABLE&lt;/code&gt;&lt;/b&gt; : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，&lt;b&gt;该级别可以防止脏读、不可重复读以及幻读&lt;/b&gt;。但是这将严重影响程序的性能。通常情况下也不会用到该级别。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Transactional(rollbackFor = Exception.class)注解了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;T6TirREk&quot;&gt;&lt;code&gt;Exception&lt;/code&gt; 分为运行时异常 &lt;code&gt;RuntimeException&lt;/code&gt; 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。&lt;/p&gt;&lt;p data-pid=&quot;PpatwKyf&quot;&gt;当 &lt;code&gt;@Transactional&lt;/code&gt; 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。&lt;/p&gt;&lt;p data-pid=&quot;yI8Dm1pr&quot;&gt;在 &lt;code&gt;@Transactional&lt;/code&gt; 注解中如果不配置&lt;code&gt;rollbackFor&lt;/code&gt;属性,那么事务只会在遇到&lt;code&gt;RuntimeException&lt;/code&gt;的时候才会回滚，加上 &lt;code&gt;rollbackFor=Exception.class&lt;/code&gt;,可以让事务在遇到非运行时异常时也回滚。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring Data JPA&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;c6TWPk_D&quot;&gt;JPA 重要的是实战，这里仅对小部分知识点进行总结。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何使用 JPA 在数据库中非持久化一个字段？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;BRnMc52U&quot;&gt;假如我们有下面一个类：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Entity(name=&quot;USER&quot;)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = &quot;ID&quot;)
    private Long id;

    @Column(name=&quot;USER_NAME&quot;)
    private String userName;

    @Column(name=&quot;PASSWORD&quot;)
    private String password;

    private String secrect;

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;s8m8_zGx&quot;&gt;如果我们想让&lt;code&gt;secrect&lt;/code&gt; 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;static String transient1; // not persistent because of static
final String transient2 = &quot;Satish&quot;; // not persistent because of final
transient String transient3; // not persistent because of transient
@Transient
String transient4; // not persistent because of @Transient
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Z7tzhh1F&quot;&gt;一般使用后面两种方式比较多，我个人使用注解的方式比较多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;JPA 的审计功能是做什么的？有什么用？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LxnvjSaw&quot;&gt;审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Data
@AllArgsConstructor
@NoArgsConstructor
@MappedSuperclass
@EntityListeners(value = AuditingEntityListener.class)
public abstract class AbstractAuditBase {

    @CreatedDate
    @Column(updatable = false)
    @JsonIgnore
    private Instant createdAt;

    @LastModifiedDate
    @JsonIgnore
    private Instant updatedAt;

    @CreatedBy
    @Column(updatable = false)
    @JsonIgnore
    private String createdBy;

    @LastModifiedBy
    @JsonIgnore
    private String updatedBy;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li data-pid=&quot;0zq-1zLB&quot;&gt;&lt;code&gt;@CreatedDate&lt;/code&gt;: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;qreSqpcS&quot;&gt;&lt;code&gt;@CreatedBy&lt;/code&gt; :表示该字段为创建人，在这个实体被 insert 的时候，会设置值&lt;br/&gt; &lt;code&gt;@LastModifiedDate&lt;/code&gt;、&lt;code&gt;@LastModifiedBy&lt;/code&gt;同理。&lt;br/&gt; &lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;实体之间的关联关系注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;MuN4kKhM&quot;&gt;&lt;code&gt;@OneToOne&lt;/code&gt; : 一对一。&lt;/li&gt;&lt;li data-pid=&quot;3LShrip3&quot;&gt;&lt;code&gt;@ManyToMany&lt;/code&gt; ：多对多。&lt;/li&gt;&lt;li data-pid=&quot;dcyHumc8&quot;&gt;&lt;code&gt;@OneToMany&lt;/code&gt; : 一对多。&lt;/li&gt;&lt;li data-pid=&quot;m3IL9GJv&quot;&gt;&lt;code&gt;@ManyToOne&lt;/code&gt; ：多对一。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;K_MkmCt8&quot;&gt;利用 &lt;code&gt;@ManyToOne&lt;/code&gt; 和 &lt;code&gt;@OneToMany&lt;/code&gt; 也可以表达多对多的关联关系。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring Security&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;IsLIcFTl&quot;&gt;Spring Security 重要的是实战，这里仅对小部分知识点进行总结。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;有哪些控制请求访问权限的方法？&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;212&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1494db71691bc4cfa4525eea0a0c5c5b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li data-pid=&quot;-LT3JWv-&quot;&gt;&lt;code&gt;permitAll()&lt;/code&gt; ：无条件允许任何形式访问，不管你登录还是没有登录。&lt;/li&gt;&lt;li data-pid=&quot;CM9ygmAL&quot;&gt;&lt;code&gt;anonymous()&lt;/code&gt; ：允许匿名访问，也就是没有登录才可以访问。&lt;/li&gt;&lt;li data-pid=&quot;0nTDes2c&quot;&gt;&lt;code&gt;denyAll()&lt;/code&gt; ：无条件决绝任何形式的访问。&lt;/li&gt;&lt;li data-pid=&quot;Ecfwp7iV&quot;&gt;&lt;code&gt;authenticated()&lt;/code&gt;：只允许已认证的用户访问。&lt;/li&gt;&lt;li data-pid=&quot;OahMS7UH&quot;&gt;&lt;code&gt;fullyAuthenticated()&lt;/code&gt; ：只允许已经登录或者通过 remember-me 登录的用户访问。&lt;/li&gt;&lt;li data-pid=&quot;Jpudjieh&quot;&gt;&lt;code&gt;hasRole(String)&lt;/code&gt; : 只允许指定的角色访问。&lt;/li&gt;&lt;li data-pid=&quot;CpFnE8BZ&quot;&gt;&lt;code&gt;hasAnyRole(String)&lt;/code&gt; : 指定一个或者多个角色，满足其一的用户即可访问。&lt;/li&gt;&lt;li data-pid=&quot;jchW6Nwy&quot;&gt;&lt;code&gt;hasAuthority(String)&lt;/code&gt; ：只允许具有指定权限的用户访问&lt;/li&gt;&lt;li data-pid=&quot;mss0dgRn&quot;&gt;&lt;code&gt;hasAnyAuthority(String)&lt;/code&gt; ：指定一个或者多个权限，满足其一的用户即可访问。&lt;/li&gt;&lt;li data-pid=&quot;j0yBNGB-&quot;&gt;&lt;code&gt;hasIpAddress(String)&lt;/code&gt; : 只允许指定 ip 的用户访问。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;hasRole 和 hasAuthority 有区别吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;0o8psI-O&quot;&gt;可以看看松哥的这篇文章：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring Security 中的 hasRole 和 hasAuthority 有区别吗？&lt;/a&gt;，介绍的比较详细。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何对密码进行加密？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;NLw9F3cO&quot;&gt;如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。&lt;/p&gt;&lt;p data-pid=&quot;6FQWXC4g&quot;&gt;Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 &lt;code&gt;PasswordEncoder&lt;/code&gt; ，如果你想要自己实现一个加密算法的话，也需要继承 &lt;code&gt;PasswordEncoder&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;wEIbY53p&quot;&gt;&lt;code&gt;PasswordEncoder&lt;/code&gt; 接口一共也就 3 个必须实现的方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;public interface PasswordEncoder {
    // 加密也就是对原始密码进行编码
    String encode(CharSequence var1);
    // 比对原始密码和数据库中保存的密码
    boolean matches(CharSequence var1, String var2);
    // 判断加密密码是否需要再次进行加密，默认返回 false
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-35ae091246ba4aa0a1d5213086866796_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TwLIMkYV&quot;&gt;官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;如何优雅更换系统使用的加密算法？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;4dLndKAH&quot;&gt;如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;pXoFTSAR&quot;&gt;推荐的做法是通过 &lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 兼容多种不同的密码加密方案，以适应不同的业务需求。&lt;/p&gt;&lt;p data-pid=&quot;sef0XNLm&quot;&gt;从名字也能看出来，&lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 &lt;code&gt;DelegatingPasswordEncoder&lt;/code&gt; 进行密码加密的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;DuEuwVD3&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 。这是我在大三开始准备秋招面试的时候创建的，已经维护了 4 年多了，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JvDdHJjF&quot;&gt;并且，这个项目还推出了一个PDF版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;I1vmxVEr&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Java 面试指北 》&lt;/a&gt; 是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;_WkIY1YQ&quot;&gt;为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;。虽然收费只有培训班/训练营的百分之一，但是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;里的内容质量更高，提供的服务也更全面。&lt;/p&gt;&lt;p data-pid=&quot;yVMURO6o&quot;&gt;欢迎准备 Java 面试以及学习 Java 的同学加入我的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;，干货非常多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。&lt;/p&gt;&lt;p data-pid=&quot;LWl-7FBh&quot;&gt;我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b242b634aeb1260fb4001cfecad8ae0a</guid>
<title>Go高性能之方法接收器 - 指针vs值</title>
<link>https://toutiao.io/k/ce3z1rn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body blogpost-body-html&quot;&gt;
&lt;p class=&quot;&quot;&gt;
&lt;h1 id=&quot;044c&quot; class=&quot;pw-post-title it iu iv bn iw ix iy iz ja jb jc jd je jf jg jh ji jj jk jl jm jn jo jp jq jr fx&quot; data-selectable-paragraph=&quot;&quot;/&gt;
&lt;/p&gt;
&lt;figure class=&quot;gm go jt ju jv jw gi gj paragraph-image&quot;&gt;

&lt;/figure&gt;
&lt;h2 class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot;&gt;示例&lt;/h2&gt;
&lt;p id=&quot;b728&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;如果您是 Go 新手，那么您一定遇到过方法和函数的概念。让我们找出两者之间的区别-&lt;/p&gt;
&lt;p id=&quot;f211&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;通过指定参数的类型、返回值和函数&lt;/strong&gt;体来声明函数。&lt;/p&gt;
&lt;pre class=&quot;lb lc ld le gu lf bt lg highlighter-hljs&quot;&gt;&lt;code&gt;type Person struct { 
    Name string 
    Age int 
}func NewPerson(name string, age int) *Person { 
  return &amp;amp;Person{ 
     Name: name, 
     Age: age, 
  } 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;c137&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;方法&lt;/strong&gt;只是一个带有接收器参数的函数。它使用相同的语法声明，并添加了&lt;strong class=&quot;kf iw&quot;&gt;接收者&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;lb lc ld le gu lf bt lg highlighter-hljs&quot;&gt;&lt;code&gt;func (p *Person) isAdult bool { 
  return p.Age &amp;gt; 18 
}&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;046b&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;在上面的方法声明中，我们在类型上声明了&lt;code class=&quot;fm ls lt lu lj b&quot;&gt;isAdult&lt;/code&gt;方法。&lt;code class=&quot;fm ls lt lu lj b&quot;&gt;*Person&lt;/code&gt;&lt;/p&gt;
&lt;p id=&quot;8909&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;现在我们将看到值接收器&lt;/strong&gt;和&lt;strong class=&quot;kf iw&quot;&gt;指针&lt;/strong&gt;接收器之间的区别&lt;strong class=&quot;kf iw&quot;&gt;&lt;em class=&quot;lv&quot;&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;b1d1&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;值接收者&lt;/strong&gt;复制类型并将其传递给函数。函数堆栈现在拥有一个相等的对象，但在内存上的不同位置。这意味着对传递的对象所做的任何更改都将保留在该方法的本地。原始对象将保持不变。&lt;/p&gt;
&lt;p id=&quot;deaf&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;指针接收器&lt;/strong&gt;将类型的地址传递给函数。函数堆栈具有对原始对象的引用。因此对传递对象的任何修改都会修改原始对象。&lt;/p&gt;
&lt;p id=&quot;e874&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;让我们通过示例来理解这一点-&lt;/p&gt;
&lt;pre class=&quot;language-go highlighter-hljs&quot;&gt;&lt;code&gt;package main
import (
  &quot;fmt&quot;
)
type Person struct {
    Name string
    Age  int
}
func ValueReceiver(p Person) {
    p.Name = &quot;John&quot;
    fmt.Println(&quot;Inside ValueReceiver : &quot;, p.Name)
}
func PointerReceiver(p *Person) {
    p.Age = 24
    fmt.Println(&quot;Inside PointerReceiver model: &quot;, p.Age)
}
func main() {
    p := Person{&quot;Tom&quot;, 28}
    p1:= &amp;amp;Person{&quot;Patric&quot;, 68}
    ValueReceiver(p)
fmt.Println(&quot;Inside Main after value receiver : &quot;, p.Name)
    PointerReceiver(p1)
fmt.Println(&quot;Inside Main after value receiver : &quot;, p1.Age)
}

------------
Inside ValueReceiver :  John
Inside Main after value receiver :  Tom
Inside PointerReceiver :  24
Inside Main after pointer receiver :  24&lt;/code&gt;&lt;/pre&gt;
&lt;p id=&quot;5d23&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;这表明具有值接收者的方法修改了对象的副本，而原始对象保持不变。Like- 通过 ValueReceiver 方法将一个人的姓名从 Tom 更改为 John，但这种更改并未反映在 main 方法中。另一方面，带有指针接收器的方法会修改实际对象。Like- 通过 PointerReceiver 方法将人的年龄从 68 岁更改为 24 岁，同样的变化反映在 main 方法中。您可以通过在指针或值接收器操作之前和之后打印出对象的地址来检查事实。&lt;/p&gt;
&lt;p id=&quot;0a49&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;那么如何在 Pointer 和 Value 接收器之间进行选择呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p id=&quot;9f6b&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;如果要更改方法中接收器的状态，操作它的值，请&lt;strong class=&quot;kf iw&quot;&gt;使用指针接收器&lt;/strong&gt;。使用按值复制的值接收器是不可能的。对值接收器的任何修改对于该副本都是本地的。如果您不需要操作接收器值，请&lt;strong class=&quot;kf iw&quot;&gt;使用值接收器&lt;/strong&gt;。&lt;/p&gt;
&lt;p id=&quot;e4fb&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;指针接收器避免在每个方法调用上复制值。如果接收器是一个大型结构，这可能会更有效，&lt;/p&gt;
&lt;p id=&quot;6b48&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot; data-selectable-paragraph=&quot;&quot;&gt;值接收器是并发安全的，而指针接收器不是并发安全的。因此，程序员需要照顾它。&lt;/p&gt;
&lt;h2 id=&quot;32e0&quot; class=&quot;pw-post-body-paragraph kd ke iv kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la io fx&quot;&gt;&lt;strong class=&quot;kf iw&quot;&gt;汇总：&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;mk ml gq gs mm mn&quot;&gt;
&lt;div class=&quot;mo o fo&quot;&gt;
&lt;div class=&quot;mp o db dy eo mq&quot;&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果接收者是 map、func 或 chan，不要使用指向它的指针。&lt;/li&gt;
&lt;li&gt;尽量对所有方法使用相同的接收器类型。&lt;/li&gt;
&lt;li&gt;如果接收者是一个切片并且该方法没有重新切片或重新分配切片，则不要使用指向它的指针。&lt;/li&gt;
&lt;li&gt;如果方法需要改变接收者，接收者必须是一个指针。&lt;/li&gt;
&lt;li&gt;如果接收者是包含&lt;code&gt;sync.Mutex&lt;/code&gt;或类似同步字段的结构，则接收者必须是指针以避免复制。&lt;/li&gt;
&lt;li&gt;如果接收器是大型结构或数组，则指针接收器效率更高。大有多大？假设它相当于将其所有元素作为参数传递给方法。如果感觉太大，那么对于接收器来说也太大了。&lt;/li&gt;
&lt;li&gt;函数或方法是否可以同时或在从此方法调用时改变接收者？调用方法时，值类型会创建接收器的副本，因此外部更新不会应用于此接收器。如果更改必须在原始接收器中可见，则接收器必须是指针。&lt;/li&gt;
&lt;li&gt;如果接收器是结构体、数组或切片，并且它的任何元素都是指向可能发生变化的东西的指针，则更喜欢指针接收器，因为它会使读者更清楚意图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果接收者是一个小数组或结构，它自然是一个值类型&lt;/strong&gt;（例如，类似&lt;code&gt;time.Time&lt;/code&gt;类型），没有可变字段和指针，或者只是一个简单的基本类型，如 int 或 string，&lt;strong&gt;则值接收器更好&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;值接收器可以减少可以生成的垃圾量；如果将值传递给值方法，则可以使用堆栈上的副本而不是在堆上分配。&lt;/strong&gt;（编译器试图巧妙地避免这种分配，但它并不总是成功。）不要在没有首先进行分析的情况下选择值接收器类型。&lt;/li&gt;
&lt;li&gt;最后，当有疑问时，使用指针接收器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;原文： https://medium.com/globant/go-method-receiver-pointer-vs-value-ffc5ab7acdb&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>219cf33b2f18b9cb35682f65182517b6</guid>
<title>从 npm 切换到 pnpm，真香！</title>
<link>https://toutiao.io/k/yu0q5bu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2951111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/T81bAV0NNNibeklzoB6icdvktw4HCOhSjmZcJLsw3zklDUrxmYyJxKibwNic4VEbia32dPIicdNHeicNUpPkAMsuVOsDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1125&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转转的 CI 系统和开发环境为什么要从 npm 切换到 pnpm 呢。因为在使用 npm 的时候，遇到几个问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;磁盘空间占用过大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首次安装速度慢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;幽灵依赖导致一些报错&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 pnpm 又是怎么解决上面的问题呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 pnpm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pnpm 是新一代包管理工具，为什么叫 pnpm 呢，是因为 pnpm 作者对现有的包管理工具，尤其是 npm 和 yarn 的性能特别失望，所以起名叫做 performance npm，即 pnpm（高性能 npm）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们今天要使用 pnpm，那 pnpm 有哪些优势呢&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、npm 的问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 npm@3 之前，node_modules 结构是干净、可预测的，因为 node_modules 中的每个依赖项都有自己的 node_modules 文件夹，在 package.json 中指定了所有依赖项，比如项目 a 依赖项目 b,项目 c 也依赖项目 b，这样如果 a 和 c 依赖的 b 的版本不一致，也不会出问题&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;node_modules&lt;br/&gt;└─ a&lt;br/&gt;   ├─ index.js&lt;br/&gt;   ├─ package.json&lt;br/&gt;   └─ node_modules&lt;br/&gt;      └─ b&lt;br/&gt;         ├─ index.js&lt;br/&gt;         └─ package.json&lt;br/&gt;   c&lt;br/&gt;   ├─ index.js&lt;br/&gt;   ├─ package.json&lt;br/&gt;   └─ node_modules&lt;br/&gt;      └─ b&lt;br/&gt;         ├─ index.js&lt;br/&gt;         └─ package.json&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面结构有两个严重的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;package 中经常创建太深的依赖树，这会导致 Windows 上的目录路径过长问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个 package 在不同的依赖项中需要时，它会被多次复制粘贴并生成多份文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上面的问题，npm 提出了 node_modules 扁平化结构，在 npm@3+ 和 yarn 中，node_modules 结构变成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;node_modules&lt;br/&gt;├─ a&lt;br/&gt;|  ├─ index.js&lt;br/&gt;|  └─ package.json&lt;br/&gt;└─ b&lt;br/&gt;|  ├─ index.js&lt;br/&gt;|  └─ package.json&lt;br/&gt;└─ c&lt;br/&gt;   ├─ index.js&lt;br/&gt;   └─ package.json&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hoist 机制下，b 包被提升到了顶层。如果同一个包的多个版本在项目中被依赖时，node_modules 结构又是怎么样的？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5174825174825175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/T81bAV0NNNibeklzoB6icdvktw4HCOhSjmI3macIpVXbQHxIm1whicKQicp8wyRk5v8s5y5ja1nqONOy7VQ1N8Ph3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包 B 1.0 被提升到了顶层，这里需要注意的是，多个版本的包只能有一个被提升上来，其余版本的包会嵌套安装到各自的依赖当中，至于哪个版本的包被提升，依赖于包的安装顺序！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扁平化之后，又引入了新的问题幽灵依赖，解释起来很简单，即某个包没有在 package.json 被依赖，但是用户却能够引用到这个包。还有 NPM doppelgangers 问题，当包有多个版本，会被重复安装多次。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、pnpm 的方案&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pnpm 使用的是 npm version 2.x 类似的树形结构，同时使用.pnpm 以平铺的形式储存着所有的包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们称.pnmp 为虚拟存储目录，该目录通过 &lt;code&gt;&amp;lt;package-name&amp;gt;@&amp;lt;version&amp;gt;&lt;/code&gt; 来实现相同模块不同版本之间隔离和复用，由于它只会根据项目中的依赖生成，并不存在提升，所以它不会存在之前提到的 Phantom dependencies 问题！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后使用 Store + Links 和文件资源进行关联。简单说 pnpm 会&lt;span&gt;把&lt;/span&gt;包下载到一个公共目录，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Store + hard link 的方式，不仅解决了项目中的 NPM doppelgangers 问题，项目之间也不存在该问题，从而完美解决了 npm3+和 yarn 中的包重复问题！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/T81bAV0NNNibeklzoB6icdvktw4HCOhSjmHvP52Dicmy3Uc8OP346kYOE70JS6N3tkibpKibHtccRYJGEbIKfGO6icwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2920&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、workspace&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pnpm 除了安装速度快，节省磁盘空间，避免幽灵依赖等优化，也内置了对 monorepo 的支持。使用起来比较简单，在项目根目录中新建 pnpm-workspace.yaml 文件，并声明对应的工作区就好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;packages:&lt;br/&gt;  &lt;span&gt;# 所有在 packages/ 子目录下的 package&lt;/span&gt;&lt;br/&gt;  - &lt;span&gt;&#x27;packages/**&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;切换到 pnpm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转转的 CI 系统。一共有 6 台机器，是前后端公用的。之前使用 npm 存在几个问题。第一个就是安装速度慢，导致编译时间过长。第二个是 node_modules 过大。导致每天必须清除一下机器上 node_modules，不然就会出现磁盘空间不足的问题。切换成 pnpm 之后，我们测试的结果，单台机器最少能节省了 30G 的空间，安装速度提升一倍以上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为直接从 npm 切换到 pnpm，大多数的项目都会存在幽灵依赖的问题。导致项目报错。我们的切换方案是在项目设置中勾选是否使用 pnpm。默认是 npm。单个项目在本地切换之后，在 CI 平台上设置成 pnpm 就完成了升级。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;切换 pnpm 的一些问题&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 pnpm install --shamefully-hoist&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果依赖一直有问题，可以使用 pnpm install --shamefully-hoist 创建一个扁平 node_modules 目录结构, 类似于 npm 或 yarn&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先使用 npm 安装，生成 package-lock.json, 安装缺少的包时，使用 lock 里面的版本&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;即使删除了 node_modules 和 lock 文件，安装时，特定的包还是报错&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们在升级时，一个包把最新的版本删除了。导致安装时一直失败。可以尝试使用 pnpm store prune 来删除&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a4f374529034f441751613b4ee4692d</guid>
<title>数据可视化设计指南</title>
<link>https://toutiao.io/k/amysims</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDI0ODY1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBsbESO4ibFCDqef4scQ0d37tBp3meC5icozRdMAmCZgNG0NTJnMXn3pVne9cibHIqibWzmQXeCeQRkONg/0?wx_fmt=png&quot; data-nickname=&quot;与数据同行&quot; data-alias=&quot;ysjtx_fyp&quot; data-signature=&quot;傅一平博士创办的大数据公众号，分享数据领域的实践经验、思考感悟和学习体会！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;傅一平评语：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;自己负责过大屏产品，也经常会对团队做的可视化产品指指点点，可视化好不好就是凭感觉，&lt;/span&gt;&lt;span&gt;很多人的感觉非常好，让他干数据可视化肯定没问题，但一个团队做的数据可视化总是能保持高水准也不容易，因为那种人总是少数吧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;牛逼的人能把感觉这种东西写出来，形成规则、模板和方法，比如本文说的一些东西，现在数据可视化产品也不少了，比如网易有数，我们可以尝试用用那些产品，也许可以事半功倍，虽然定制开发总是能解决问题，但的确成本太高了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，一个数据可视化设计能不能得到认可还得看数据本身的内涵，比如指标设置的是否科学，数据有没有故事可讲，那个考验的是做数据的真功夫，很多想Show的企业把这个本质忘了，一个大屏展示乱七八糟，除了颜色啥也没看到，苦了讲解员 ，“凡是大屏，皆是作秀”这种印象估计就是这么来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dyDu14T9ZVADGkApd1vMFWR71Pfq5B2Mmhdhys0AVKDLPYJYHkrCktzDibic80X1JeC3NnCCZ8JKLCH7aEFbm9Aw/640?wx_fmt=png&amp;amp;random=0.7687642463046447&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;正文&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在如今的工作中（尤其是 B 端）越来越多的会开始出现数据可视化的身影，对于一部分小伙伴来说这个概念是较为陌生的，面对这道无形之中提升的“门槛”我们常常会表现的手足无措。所以，为了让大家对于数据可视化不再那么束手无措，我希望能通过这篇文章和大家一起交流学习，解决一些属于我们共同的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么我们还是老规矩，想要了解一个事物首先需要知道的是它的定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.86015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpomDm6sUkqVNu3eENjhuFroia50djNgcnQmfpPyEiaFiby5qrLJ6EzRibzFw/640?wx_fmt=jpeg&amp;amp;random=0.3516563041061156&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h4&gt;数据可视化的基本信息&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1. 数据可视化的定义&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;较为笼统的来说数据可视化是一种由图形、图像、数字等元素组成的语言用于解释、呈现目标数据之间的关系。从这个定义上来看，数据可视化从外观层面来说是与图形、图像这些视觉元素密不可分，这也是数据可视化最为明显的特征。&lt;/p&gt;&lt;p&gt;而结合我们实际的生活与工作来说，数据可视化是一种以图形符号为主要表现形式，将不可见的、抽象的、复杂的、枯燥的、专业的、不直观的数据内容，有趣的、浅显的传递给用户的有效手段。用户可以通过这样的手段完成自己的目标（例如对选定范围内的数据进行分析，发现数据的周期与规律、迅速找到自己目标节点中的关键数值、对比几组数据以了解当下研究对象的情况等）这也是数据可视化最为明显的价值。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.221875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpokGZhqjqest2UKPK0VWx06jNmF8TWI44u4YsDUG9NAWQ3lxQ2ogc1ag/640?wx_fmt=jpeg&amp;amp;random=0.5034797332188912&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 可视化发展简史&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;关于可视化的发展史上可追溯至 1950 年，当时人们利用计算机创建出了首批图形图表，可以说是数据可视化图表最为早期的雏形，而在 50-60 年代的可视化中又以查尔斯·约瑟夫·米纳德的《1812－1813 对俄战争中法军人力持续损失示意图》为代表。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoHCsCXjRI8nT5m8swRRuvksHcYATsKF5oIAyuHyptf6LzvUPic3FEBSQ/640?wx_fmt=jpeg&amp;amp;random=0.9108203890678139&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;该图描绘了拿破仑的军队自离开波兰到俄罗斯边界后军力损失的状况，也是后世分析拿破仑对俄战争的重要数据分析资料，后来这种带状图被称为“桑基图”用来解释能量的流动。&lt;/p&gt;&lt;p&gt;而可视化真正被提到一个应用理论的高度是到了 1987 年布鲁斯·麦考梅克和马克沁·布朗所编写的美国国家科学基金会报告《Visualization in Scientific Computing》（科学计算之中的可视化），其意在强调了基于计算机的可视化技术方法的必要性，此时的概念已经与现在我们所接触的工作中的数据可视化是非常接近。&lt;/p&gt;&lt;p&gt;到了 90 年代初人们发起了一个称为“信息可视化”的研究领域旨在为许多应用领域（科学、商业、行政、财务、数字媒体）之中对于抽象的异质性数据集的分析工作提供支持，与前面提到的“科学可视化”交叉形成了现在耳熟能详的“数据可视化”，此时这个词汇才慢慢的被更多的专业领域的人所接受，并在之后互联网的不断发展中扩充着自己的分支。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoezsrkmJr51FhTOMu6PdSrKc39HbT1siaupyNBA9CcPP0KHibLTC1mqfw/640?wx_fmt=jpeg&amp;amp;random=0.3017912081223726&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;3. 为什么会使用数据可视化&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbponWmPuCrjF6VcN2YykCo0U0CEtnTfr0rMwUNzeGzSyUsBeDFdWhsFhg/640?wx_fmt=jpeg&amp;amp;random=0.5045955354667644&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;目前大量开始使用视觉可视化的原因其实非常简单大致的原因可以分为需要处理的数据量太大了和人脑不够用了。&lt;/p&gt;&lt;p&gt;据不完全统计 IBM 公司每天有 2.5 亿字节数据的吞吐量，麻省理工学院的研究科学家 Andrew McAfee 和 Erik Brynjolfsson 教授指出，如今在互联网上传递的数据量比过去 20 年的总和还多，而且根据 IDC 预测，到 2025 年将有 163 万亿 GB 的数据。&lt;/p&gt;&lt;p&gt;这是非常惊人的，而这么多需求的数据量单凭人脑的计算能力和处理能力来说是完全无法与之匹配的，研究表明人脑很难同时处理 5 组以上的抽象数据，所以这种单线程的处理方式就决定了需要借助外力。&lt;/p&gt;&lt;p&gt;而对于用户尤其是决策层的用户来说在现实的工作场景中经常需要同时处理超过 5 组以上的数据并需要对其建立精准的分析模型以便于做出最准确的决策所以基于这样的需求，数据可视化设计氤氲而生。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. 数据可视化的优势&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.459375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoUIl58dbnKLRj5aWPFzNCu3StFlg7NJNAPBSnSTnDoeHFA9hU3jTicicw/640?wx_fmt=jpeg&amp;amp;random=0.7816865464917988&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于数据可视化的需求来看，数据可视化的优势是显而易见的，可以概括为两点：认知减负和传递赋能。&lt;/p&gt;&lt;p&gt;认知减负是使用者在使用数据可视化工具时候的最直观感受，当所面对的庞大的、复杂的枯燥海量数据集变成了图像化、通俗化、形象化的视觉符号时，我们会本能的放下对于面对冰冷数据时候的抗拒和戒备，这是因为人对于一目了然更加接近自己熟悉的有趣事物的时候，会更为亲切和愿意去主动理解。而且被处理过、规划过的简洁直观表现形式，能更为直接的让使用者看到数据与数据之间的关联，进而分析出其潜在关系，在人对数据的认知这个环节上降低了识别成本和分析成本。&lt;/p&gt;&lt;p&gt;传递赋能上图像传递更接近人类最本能的获取信息的方式，比起文字来说图像更像是一个解密的步骤，通过解开文字描述这重“密码”将最本质的信息进行呈现，而且对比文字，图像所能够承载的信息其实更为广泛，而且人类读图的效率要远远高于阅读文字。&lt;/p&gt;&lt;p&gt;无论是一个约定俗成的语义符号形象还是符合语境的配色都能够起到比文字直白表述更为强烈的深入人心效果，并且图解的形式并不受限于语言的障碍，极大的降低了沟通成本。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5. 使用目标&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.53671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpowvCxNlXZGSu8JEXxuXPpJ0n5DxIaRI42jiaZMIsDD8iaCYlLxNBnHkxA/640?wx_fmt=jpeg&amp;amp;random=0.7739231061100891&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于用户的使用目标来说，使用数据可视化其实就像是一个侦探用“蛛网图”辅助自己梳理思绪进行破案的过程：将一些有关的，但是较为零散信息数据用一根根线索穿插起来，形成体系化的联系，方便使用者迅速把握各个节点之间的关系进行推导。&lt;/p&gt;&lt;p&gt;所以说我们在设计数据可视化的时候并不是对我们拿到的数据的无脑映射，而是要基于用户的目标经过一定的处理和优化后才能进行呈现，随时记住我们是给用户在打辅助，所以我们每一步的设计一定要基于用户的思考。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpolT8EiaRfYUPY6soHtyA36VYHft9A3ibU3hT5JZZ5RkaXchgh7BD8mCrg/640?wx_fmt=jpeg&amp;amp;random=0.041017176822280677&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用户的期望是能够高效、清晰、简洁地完成数据的对比、关键节点的查询、每组数据之间的分析等一系列交互，提升自己的工作效率，降低自己的学习和使用成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;6. 应用场景&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.68671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoiaxqgD9mO4ibTqmgMicAlRu5vF1eEzKeCEibVNzaum0vGG4DjicaqDqsn5A/640?wx_fmt=jpeg&amp;amp;random=0.40664573224466993&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据可视化的应用领域较为广泛涉及医疗、统计、管理、金融、娱乐、人工智能等一系列领域，在 UI 的设计中我们最常接触到的包括：PC 后台的数据概览、数据可视化大屏、游戏 UI、后台实时监控等。&lt;/p&gt;&lt;h4&gt;设计师们的任务&lt;/h4&gt;&lt;p&gt;当我们大致了解了数据可视化的历史、使用原因、优势、用户目标、应用领域后下面就要切入我们设计师最为关心的话题：我们在设计中的任务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 设计难点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.55859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoUNLT87tDsSaicmMStylIiboT6WmCPuJtoVqGB22ItJdGOot541rnOcag/640?wx_fmt=jpeg&amp;amp;random=0.37077608539205476&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据可视化作为一门跨领域的学科，本身对于从业者而言就有着一定的综合素质要求，但由于国内教育并没有垂直教学学科，所以在现在的阶段从业人员一部分由纯视觉设计专业的同学组成，另一部分由纯工科类型的专业的同学组成。&lt;/p&gt;&lt;p&gt;于是这就导致了非视觉设计师在进行设计时，会将全副精力放在强数据的准确性、合理性上，从而让视觉的易读性上有一定的损失，表现形式也较为单一枯燥，视觉感官较差，反观视觉设计师通常会将数据可视化在视觉表现形式上过度用力，虽然营造了很好的视觉体验，但是从其实用度、可用性上来说会大打折扣。&lt;/p&gt;&lt;p&gt;于是设计的难点很多时候就会集中在平衡视觉与实用之间的关系。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 设计目标&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo6J4Ab925J4SVIo2lL6Zgvko6z20Tucuibt452Jcxq8O2V6dFqaSud1w/640?wx_fmt=jpeg&amp;amp;random=0.15479291291984842&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过以上分析，不难看出设计的主要目标，而面对这句较为抽象的“把握设计与实用之间的平衡”其实无外乎也就是拆解到功能和视觉这两个方面。&lt;/p&gt;&lt;p&gt;从功能上来说，我的目标是提升用户的数据阅读效率、让用户能够迅速 Touch 到目标信息，提升交互效率，一切都是以结果为导向，以解决用户问题为导向，一定记住人们不愿意接受未处理过的数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpopia6iaprGlQMOGcJWMDUAZMHFfp4OE46wiaia0icnQyONDssYTabruVriacA/640?wx_fmt=jpeg&amp;amp;random=0.8974351421745708&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;而从视觉上来说，我们的目标是处理好在视觉上各个模块之间的统一、透气关系，将数据进行可视化的同时尽量提升感官上的审美体验与传达上的有趣。&lt;/p&gt;&lt;p&gt;以上会作为后文中我们每一步设计的指导和检验的方式，从实际操作的维度上来说二者也并不是五十比五十的分配，遵循的原则是：体验一定要让位于功能，所以在视觉的层面发挥的空间其实需要比较克制。&lt;/p&gt;&lt;h4&gt;案例制作&lt;/h4&gt;&lt;p&gt;了解了数据可视化的设计难点，明确了数据可视化的设计目标，那么我下面进入我们最重点的环节：可视化页面案例制作，由于数据可视化的形式较多，这次我们以工作中经常接触得到的 PC 页面数据概览页为例。&lt;/p&gt;&lt;h5&gt;1. 明确性质&lt;/h5&gt;&lt;p&gt;同样的，细化到数据概览这个分支项目，我们同样需要明确了解其基础定义和性质，严格意义上来说数据概览部分属于 Dashboard design（仪表盘设计）的一种，其主要的目的和功能可分为分析和操作两块。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpojp1VM11W6cHWy5mYnGd0njR71gjLk9zGNexQTqJibEVgNmH0XRNn6iaw/640?wx_fmt=jpeg&amp;amp;random=0.3159547536575149&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.83125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbponJX7XA93xPnQnBMcibPxEib9WGROS3icbgfibYCxA3kJsDEYZv01fSNricg/640?wx_fmt=jpeg&amp;amp;random=0.8323480339181399&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;所以从综合的角度来说数据概览部分可以理解为：&lt;/p&gt;&lt;p&gt;其它模块的摘要视图，并显示来自应用程序各个部分的关键信息，从这点上来说建议此模块可以在其余模块设计完后再进行设计，如此有利于设计师从一个全局的视角切入进行设计，理解上也会更加透彻，否则很可能会陷入在你设计其他模块的时候不断地返回对其进行修改的怪圈。&lt;/p&gt;&lt;p&gt;它也是核心功能、常用功能的快速操作助手和快捷页面跳转（有点类似于导航），交互功能的排布和关键信息的显示，其共同的要求点是显而易见的，即明确各个模块之间的层级，做好顺序、优先级排布。这就需要你对业务目标有一定的了解，记住，对业务目标不了解，你的设计将毫无意义。&lt;/p&gt;&lt;p&gt;你可以通过查询一些内部资料、报告、也可以询问产品经理等相关负责人，还可以通过用户调研得出，这里不展开说，在动手之前你需要搞清楚：各模块之间优先级如何、你需要在一张单独的图表内展示多少变量、想展示一段时间内的值是项目和项目之间还是组与组之间、每段变量中有多少关键数据需要展示等问题。&lt;/p&gt;&lt;h5&gt;2. 定义模块优先级&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.815625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoEmhEwArq1WQtBWaQHd4JWLZvKhrB0jQeGUl8t2qhiciarBPO74x3rMiaQ/640?wx_fmt=jpeg&amp;amp;random=0.8768959518250332&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如上图所示，在工作中我们接到需求的时候是面对一堆冗杂的数据集，组成了若干个模块，但是正如上文所说，我们并不能对其进行无脑的可视化映射，所以首先要做的就是要对各个模块进行优先级的梳理排序&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.815625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpocs84OvYaXsicdKic6848SPY5SCJwvGu4o1XztF9mcVzItcvthMgVuf8g/640?wx_fmt=jpeg&amp;amp;random=0.26454394628261757&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;明确了各个模块的优先级排布之后，我们开始对每一个单独模块进行可视化转化，即哪一个部分分别用什么类型的可视化形式表现，这一步非常类似于土地使用规划，当你在将土地划分完后，为每一块土地定义其使用类型。&lt;/p&gt;&lt;h5&gt;3. 明确图表选择&lt;/h5&gt;&lt;p&gt;想准确的将图表与所要表现的数据进行对应，需要了解图表本身所包含的基本元素。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.58046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoFdGkGib5FcQmxOiaVNqVb46xMw2TD5U7BjKia04J1ob1aOq5uLnwbxiclQ/640?wx_fmt=jpeg&amp;amp;random=0.47685919415066547&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在这些元素中正常情况下一定在图表中的有：标题、时间范围、图形主体，经常出现的有：坐标系、图例、提示信息，有时候会有的有：切换选项和值域。&lt;/p&gt;&lt;p&gt;知道了这些重要的基础信息了，那么在面对这么多图表的时候我们该如何正确的选择来进行使用呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo6W7Fslx7diaB8MKD5yo7LLJBygWdfibtdIcdicLWnKtbZUQn0Tal3JxEQ/640?wx_fmt=jpeg&amp;amp;random=0.3558154565925187&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其实和之前说的一样：基于目的来进行思考，所谓的基于目的来进行思考也就是要明确你所确立的数据指标需要分析的维度，而日常使用的数据需要分析的维度无外乎：比较、构成、分布联系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;比较类图表&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.60859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbponIpNicutHSDibNgnldktLaLuazKvnFibWyHfjQUAjYdUL4GLJfkXxt8BQ/640?wx_fmt=jpeg&amp;amp;random=0.5955621867671721&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;比较类图表应该是大家最为熟悉的范畴，第一时间能够想到的就是柱状图，这也是运用最为广泛的图表之一，经常出现在 PC 端之中，用于描述分类数据之间的对比，描述的数据可以是地区、品类甚至一个时间周期，但由于其扩展能力有限，所以一般不建议项目超过 12 条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo9H6lrliaDd69WQATuORDcSDeRQbYDuyMnW2UkSHKKOp1MlHfh1fmzHw/640?wx_fmt=jpeg&amp;amp;random=0.20704865007651407&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;条形图与柱状图类似，看上去只是交换了 X 轴与 Y 轴，功能和承载数据种类较为类似，但不同的是，条形所能承载的项目数量相对于柱状图而言更多，由于其优良的纵向延展性一般用于手机端较多，而且从上到下的阅读方式符合人眼阅读习惯，所以也会经常用于排行榜的设计中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoOqOJE2wHqWY4YXPLuicd86KYroiaMIVWRYcEhYfibKIuf2GmTlDicXRDcg/640?wx_fmt=jpeg&amp;amp;random=0.2448269817310591&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;分组条形图是条形图的衍生之一用于比较多个变量在不同区域之间的数量关系，比如当想比较同样一款衣服和鞋子在四个门店中的一个季度的营业额时就可以使用分组条形图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoPR20LsoCVe7LH6OsnkbicFeAXyrQ0nTZhmiallibMwibFS50QrJxiaCWUSw/640?wx_fmt=jpeg&amp;amp;random=0.09289087188232625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双向条形图表适合比较两组以上的分类数据比较，和分组条形图较为类似，但是由于自身外观特征更适合用于比较两组意义相反的数据，也正是如此，双向条形图的组内二级分类数量一般不要超过 3 条最好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.60859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoyEbypkoic4WniaIpDAvNuyaiaCQv5axVu7dSEmu9ysDME3ZNIZHNFuqvg/640?wx_fmt=jpeg&amp;amp;random=0.1567593818949693&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;折线图与前者最大的不同就在于在坐标轴中加入了连续类别这个概念，数据基于时间等因素变得动态了起来，注重变化趋势的展现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.60859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo8YUYf2JeBveuEa55pZRvutkSCRL78QhOpdRqEv6ricXFUOMvBg37EJA/640?wx_fmt=jpeg&amp;amp;random=0.8441965468146864&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;面积图是折线图的延伸，除了表示变化趋势之外还能比较所选范围内积累的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoHsTYROLTibczNJEmBQWyMScdaN9uE90RNvviamApU2O7XpfE00iayibXVw/640?wx_fmt=jpeg&amp;amp;random=0.2803876064629274&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;玫瑰图应该算是可视化图表中的“网红”，因为我们从小学的课本中就知道它还有一个别称叫“南丁格尔玫瑰图”。它是一种圆形的直方图，使用半径长短表示数值大小，其特点就在于因为其独特的外观可以将数值之间的差距在视觉层面进行放大，和将坐标轴范围缩小来提升视觉上数值的碾压是一个道理，发布会吹水最爱，但是要注意的是这不是一个表示占比构成的图，因为玫瑰图的每一份角度是一样的，一定要和饼状图等图区分开来，它用来表示的还是数值与数值之间的大小&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.62109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoQmqJz3T5S1b23Zx0T49xsQ1TeCd7gI7iazbKUJv56ISqIjcp3zaGUWA/640?wx_fmt=jpeg&amp;amp;random=0.36362275611479933&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;雷达图经常用于分析一些多维的性能数据、评分数据，经常打游戏的朋友应该不陌生，有多少五边形选手可以扣个 1，每一项指标越接近圆心说明状态越差，越向外说明越佳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.63828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoHLDoA9ZqxKx8uK94J3OsOfa7UUXjRp3iaxm32wDicopRdmq72wMWIGsQ/640?wx_fmt=jpeg&amp;amp;random=0.33461061840373696&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;子弹图用于比较当前数值与目标之间的关系，比如看当前业绩是否达标，也可以通过标记划分区域来进行更好的评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.58671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoRM1EKxO4EGJ67j5oJbL5nVx5icsnohNzuKgk1GlHMqkCDfRfYx7lOiag/640?wx_fmt=jpeg&amp;amp;random=0.8367396437315542&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;漏斗图适用于业务流程比较规范、周期长、环节多的单流程单项分析，一定要有清晰的环节，比如监控买家从浏览到最后下单的数量统计以求得转化率，不适合无逻辑、无流程的分类对比。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;构成类图表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpohoG2Y3eLsFiaR22Ym3QHhxDPG4vuCibk1B6cujrEbl0s1mFM8GoTr29Q/640?wx_fmt=jpeg&amp;amp;random=0.0899599290465285&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;构成类图表整体上来说主要用于观察部分和整体的占比关系，最经典的莫过于饼状图，这个不用多说，通过每一份半圆角度所占整个圆的大小来表示部分和整体的关系，但是由于其所占面积较大，经常会让视觉过于集中，影响注意力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.60234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpozLoVRjGwBjcFsUaj4uRB4lUfCYxTRSUe5KygibWQ45ywljHgvDudC6A/640?wx_fmt=jpeg&amp;amp;random=0.5764296439657006&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相对于饼状图而言，环状图十分有效的避免的干扰视觉的问题，其本质是将饼图中间掏空，功能与饼图基本一致，但是视觉上做到了轻量化，目前在日常设计中较为常用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.63046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoO3rkHuFmfP1mOzcyEnTx33icttwFsjHMXpaiaKaug9GPJNTkThj8bibow/640?wx_fmt=jpeg&amp;amp;random=0.9389162607474975&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;旭日图相当于前面二者的结合，适用于展示多层级数据的占比关系，距离圆心越近代表层级越高，下一层级的总和构成上一层级，存在一定的父子层级关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo3iac78DvYQHohAoBeI10V6tbsia8oOiaE8OjzZxh1pqnnIpEKmAXYfPYw/640?wx_fmt=jpeg&amp;amp;random=0.6771217354614409&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;堆叠面积图出了可以表达趋势外，其优势在于能够表达总量和分量的构成关系，堆叠面积图上的最大的面积代表了所有的数据量的总和，是一个整体。各个叠起来的面积表示各个数据量的大小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoq2RgkIsXpb6KfUKIwmLOTZRw0s1MkwVrsmRygpCPB9ygmOtmwicLYgQ/640?wx_fmt=jpeg&amp;amp;random=0.8967646027912981&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;堆叠柱状图的优势在于它既可以表达一级分类的比较，同时还能看出二级分类在其一级分类中的占比，但是缺点在于二级分类并不是按照同一基准线对齐的，相比于堆叠面积图更为常用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.61484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo1rg7p9zGYnBqHFhpZzzW2GGNWvUfOhR5vNEurLq5UD8mX022N4kia0g/640?wx_fmt=jpeg&amp;amp;random=0.3844814499184457&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;瀑布图用表达两个数值之间的变化过程，过程值为正的时候，向上加，过程值为负的时候向下减。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分布联系类图表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;分布联系类地图在这两年在国人的心中其实已经非常熟悉了，因为疫情今年的地图可视化的应用经常出现在我们的生活中，地图可以结合不同的表达方式：&lt;/p&gt;&lt;p&gt;可以结合散点、可以结合动画、还可以结合引导线以及热力图的方式，图的形式使用视具体的业务需求来定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.58984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpot3qr34ibWTH57LhlzV3C3KGZYJBo8CXicoeOdyGc7wUQ6sJXj9n7Ty7w/640?wx_fmt=jpeg&amp;amp;random=0.6844802092626208&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后就是气泡图，这是在查看分布关系中最为经典的视觉模型，用气泡的面积大小表示数量，结合辅助线可以更好地观察分布情况&lt;/p&gt;&lt;h5&gt;4. 匹配图表 重构布局&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbponASibaDeXwxPLRxibtE8gk8vKb0w8tcR51dbxFrr5kGUalb4pLqbvszg/640?wx_fmt=jpeg&amp;amp;random=0.6299607064902684&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;当我们对每种图表的功能和使用范围有了一个较为明确的认知之后，下面我们就可以对我们之前所规划好的优先级的模块进行可视化形式（图表）的匹配了。&lt;/p&gt;&lt;p&gt;进行匹配过后，我们将对布局进行重构，整体重构需要遵循的原则是&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;布局层级明确，首屏尽量曝光更多内容&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;统一透气，具有呼吸感&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;布局层级明确，首屏尽量曝光更多内容&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从首屏曝光更多内容来说，主要是因为基于分析类的数据概览工作场景和 Analytical dashboard 自身特征决定的，用户希望能够通过仅仅一屏的的大小进行对各类信息的情况有基本的把控，达到一眼全局的目的，其主要注意力都会放在首屏，所以我们需要尽可能的在首屏安排更多的信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoInxdoCogeJkick42mo66Njo2SztA1OQiaAqjI9FaS7zmKm4MFw7R2d9Q/640?wx_fmt=jpeg&amp;amp;random=0.7669050442871568&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.82265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoLiaBYKXmmDk4j8rgWt8xrKnTkL3Y8C8sHRbd3JgHmfma0pFhSgUpzIQ/640?wx_fmt=jpeg&amp;amp;random=0.3027482221771409&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然首屏内容也并不是越多越好，一般建议也尽量不要超过 7 组模块，而在层级明确这块儿主要是根据人眼阅读习惯所产生的优先级排布：正常情况下都是左上为优先级最高，而右下优先级较低，这是无数经典的眼动测试和设计总结产生的最常用结论，就不展开叙述了，所以当我们按照优先级、首屏曝光更多内容的原则进行处理后会得到如上图的布局。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;统一透气 具有呼吸感&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.98515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo63s5vDqAh859y1YIq89f1mjpI4b8KaDMToibQCEOZVgTdF7JJrsmuPw/640?wx_fmt=jpeg&amp;amp;random=0.7026267322000257&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这主要是视觉层面的问题，统一透气的要求在首页概览中可以依靠栅格系统来解决，它可以有效的保持页面布局一致性，为页面建立基础布局框架，将页面中的所有元素都捆绑在一个体系之中，同时还能有效解决适配问题。&lt;/p&gt;&lt;h5&gt;5. 模块拆解&lt;/h5&gt;&lt;p&gt;完成了大规划之后，下面我们开始对一个一个的模块进行拆解，同样的以目标指导设计，边设计边验证&lt;/p&gt;&lt;p&gt;&lt;strong&gt;层级明确 突出重点&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.51484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo7qdQ29fnJ0WCpesWK77a8P112ZibfueveyQJhx2pkIWUd6JDIB72YqA/640?wx_fmt=jpeg&amp;amp;random=0.34687193044253495&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;和大规划一样，单独到每一个图表同样要时刻注意层级的梳理，销售渠道部分很明确应该是运用一个折线图的形式，由于业务目标上来说更关注销售额而不是销售额和订单数的比较，所以我们选用了一个带有切换选项的折线图形式。&lt;/p&gt;&lt;p&gt;但是我们会很容易发现在读图时会出现较大的视觉干扰，并没有能够很好地突出重点信息，视觉层级不清晰、混乱。&lt;/p&gt;&lt;p&gt;于是我们对没有重点的视觉层级进行梳理，像之前划分模块那样，对视觉元素进行高、中、低的 P0、P1、P2 的设定，提升易读性&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoXQ9BgiaTJHk6mWVBxpjSYW6iatN2Pm57lAf9P7FtDVKwGIzQKbbgqzibw/640?wx_fmt=jpeg&amp;amp;random=0.39844602955278474&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo8SiaYROQoWqLibqqV1YoN2fgf4jv0TmWNjRlWg7JIKK0iahD8AxT0eia1A/640?wx_fmt=jpeg&amp;amp;random=0.6263503574672744&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;P0：层级最高的自然是重点信息突出部分，所以我们需要在其之上做加法，给予内容异形悬停样式进行具体强调，配合投影加强视觉效果，有效传递用户，拉开与别的元素的层级，同时数据部分用特殊字体并适当加大字号进行设计，方便用户第一时间能够看到所要强调的数据具体值。&lt;/p&gt;&lt;p&gt;P1: 其次就是主体图形部分，这是用户需要看到的重要部分，在使用场景中会长时间盯视，所以采用更低的明度与更高的饱和色颜色确保易读性，但是也不致于会让用户太晃眼产生视觉疲劳，最后考虑到该模块所处位置属于页面中较为核心的地带，给予一定的颜色透明度渐变装饰，在强化主体图形的同时不致于太显单薄。&lt;/p&gt;&lt;p&gt;P2：前两者都是一定程度的做加法，那么层级最低的元素需要开始做减法，此时轴线、刻度、切换选项等元素需要弱化视觉层级，降低透明度，尤其是背后的刻度线与背景的明度对比大概控制在 1.6:1 上较为合适。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.28828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo1lRsVseRTta6vPCvaxpls5c0OsWQ8K0ELy3atyr9XL3zqt7xVgxAbQ/640?wx_fmt=jpeg&amp;amp;random=0.10422669209591073&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;销售总额、订单数、渠道数同属于一个数据统计的范畴，最忌讳的就是把以上提供的三个信息给做平，让用户抓不住重点，面对这样的情况还是一样，确立需要突出的重点信息给予特殊文字和大小的设计，选择合适的主体图形。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.96171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoWYJ95ZSH57dys4wuLNQppc7nX7mHV1vARgF2blb6OYPxNvBr1X5XXQ/640?wx_fmt=jpeg&amp;amp;random=0.7350717814898782&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;但在这里需要注意的是由于在这个模块中 P0 是金额数、订单数、渠道数这些重要值，所以可视化图形需要适当为其让步，不要放在阅读中心位置，按照 P1 来进行处理，而订单数、转换率这样的标题就成了 P2 需要适当降低透明度和文字大小，不干扰主要信息的表达。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;统一营造&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;说到统一，最先想到的一定是色彩，无非也就是需要处理好对立统一关系，而这其中统一的比例又要大于对立，配色上尽量选用同类色系，不宜太过花哨，尤其是对于 B 端而言，建议在可能的情况下不要超过 5 种，而且主色、辅助色，对比色的比例建议控制在 6:3:1 的比例（但不绝对），既能做到有所区别又不致于过于绚丽干扰视觉。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpovd3PNpEhdRwdvum03OKkvL7JWK1UNcscGTibmW5HYhfic46UAKUMzgxw/640?wx_fmt=jpeg&amp;amp;random=0.500281828719555&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你的主色不一定要迁就你的品牌色，但是一定要是如上文说的尽量低明度高饱和，以适应于长时间的注视。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.540625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpowGyJMCgUI0xs4LFwxvmxFcxCLcYFv0hcKTcMpWNLN2N4YgQhwaLW6g/640?wx_fmt=jpeg&amp;amp;random=0.844285355933335&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;颜色过后就是字体，字体的使用需要极为谨慎，如果可以尽量只出现一种字体（但不要超过三种），并且只采用基础字体，正常情况下都是将其作为一个需要被降噪了的视觉元素来对待（比如降低透明度），在 PC 端中尽量也不要出现较多不同的字号、字重，造成没有必要的视觉干扰。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.69296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpouwoZk9jELP4IlticsicczzIfDUR6MTW8O4E8GmMlcFFojs03yxW9qeeA/640?wx_fmt=jpeg&amp;amp;random=0.2162976783839201&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了字体之外，在统一感的营造上卡片的布局结构也需要尽量保持一致，这是为了提升易用性，同一个产品内，相同布局会给予用户相同交互、相同功能的暗示，也更容易培养用户习惯，提升操作效率。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;呼吸适中&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;呼吸感是留白的艺术，很考验设计师的排版能力，在单独的模块内，元素与元素之间尽量不要用实线进行间隔，可以的话利用亲密性原则通过元素间距的远近进行布局。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoA5LoOdYbzEYjASZ6niaCVUTawHvyAicGpkHaX3aRO6ubVwC5SZSLpticA/640?wx_fmt=jpeg&amp;amp;random=0.9607883815371037&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而柱状图的设计上，柱与柱之间的间距最好大于柱宽的 1.5 倍，这样才显得视觉上较为透气，不致于太臃肿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoKJkMQ08ZQzamibRKSvPPOhP2wRxwWebUqcrbjIbctMZxxsViciafyj37w/640?wx_fmt=jpeg&amp;amp;random=0.08507810134095561&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;最后就是模块中的边距留白部分，这点一定要重视，不然不仅你的版心会变散，还会严重影响你的页面呼吸感。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;细节处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.51640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoxM6BCrSLGSh29MWSG2jvVxyMmXwZ7SloNmaJ7zWQ18Niafn0QwEGRlQ/640?wx_fmt=jpeg&amp;amp;random=0.4335649678541429&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;细节上首先要说的就是横纵坐标轴上的文字，上面的文字一定不要过长，最好的方式是将文字进行精简。然后横、竖排对齐处理，如果实在不能精简那么再进行斜排的方式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoLibE4iaGia3icVIrtSXyDicbjFYOl58RtS8VIPXI0VFZRv4yyU8q3WZIXQw/640?wx_fmt=jpeg&amp;amp;random=0.9222073066853944&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二点就是横纵坐标轴有的时候会因为需要展示的数据过多而过于密集影响阅读，这个时候可以采用适当增加一个值域的划定的方式来进行坐标间距的缩放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpoDcy7UExzqgCFRxsg0HWtaBzK3xtprXFBFZH1IRWdFdvf9WfGvIQH0g/640?wx_fmt=jpeg&amp;amp;random=0.6861541482145919&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三点就是，在排行榜等模块可以适当增加一些小设计，比如金、银、铜的设计，提升情感化元素的融入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpo0K2qwALqBMy2RebicK4ia3XFUfNSrjStGHh7y2LibJVlt7Aa9dQQAsX9g/640?wx_fmt=jpeg&amp;amp;random=0.6110639422486572&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四点就是，尽量不要选用一些 3D 的酷炫效果来做可视化，因为这种效果很容易对数据进行遮挡和扭曲，不是非常适用于高效阅读，也不适合 PC 页面上的交互，而且也不利于开发，比较得不偿失。&lt;/span&gt;&lt;/p&gt;&lt;h5&gt;6. 组装自检&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.99765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/12kticsQR1ssY2mHU8Q2Xclft2uRGzbpobpqC3l7hVfn1PMA1AbVHkpm1mLofpvegiaSWnSsM05KCe3sZh5PgWDw/640?wx_fmt=jpeg&amp;amp;random=0.01800086690274072&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;当所有的模块设计完成后，像拼高达一样进行组装，组装完成后适当调整其过于干扰视觉的地方，然后进行自检。&lt;/p&gt;&lt;p&gt;自检不只是从检查你的视觉、你的模块间的布局，更重要的是带入使用角色来进行检查，你可以模仿用户使用中的各种需求场景，对已经制作好的页面进行交互和阅读，看是否能够快速高效地完成使用目标。&lt;/p&gt;&lt;p&gt;当然除了自己之外，你还能在有条件的情况下找专家用户进行使用，即使记录使用中存在的问题并及时进行调整，当初步使用大致无问题后便可以交付。&lt;/p&gt;&lt;h4&gt;结语&lt;/h4&gt;&lt;p&gt;好了以上就是在 B 端设计中对于数据可视化尤其是 PC 端数据概览的设计探讨，当然其实关于数据可视化的范围还远远不止于此，感谢你能够耐心看到最后，我们后续再见。&lt;/p&gt;&lt;p&gt;&lt;span&gt;免责声明：本文资料来自网络收集和整理，所有文字和图片版权归属于原作者所有，且仅代表作者个人观点，与本公众号无关，文章仅供读者学习交流使用，并请自行核实相关内容，如文章内容涉及侵权，请联系后台管理员删除&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整理：微信公众号@5WPuss   &lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;508462604&quot; data-ratio=&quot;0.11052631578947368&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBsBYSDtf5PsebibaWibPrb2pJgqibG1Ofib3ygwnPkDQ7zZnzONLyKjuoAy0nrsvux6pC8ibialk2n3gHCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNDI0ODY1OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBsbESO4ibFCDqef4scQ0d37tBp3meC5icozRdMAmCZgNG0NTJnMXn3pVne9cibHIqibWzmQXeCeQRkONg/0?wx_fmt=png&quot; data-nickname=&quot;与数据同行&quot; data-alias=&quot;ysjtx_fyp&quot; data-signature=&quot;傅一平博士创办的大数据公众号，分享数据领域的实践经验、思考感悟和学习体会！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;508462601&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11052631578947368&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0picKDW2SVG0x8ZLO79NPSHfUeyu1c22j9RcZrxbvNmn1rJvIYXdSuVVg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;508462603&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0phMcwdicuLTbTN6eYGf4qUvIccIScFH1NJ4GicibNykk16iaicdeVetVvqFw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;508462602&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10789473684210527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0pS95nEJT8H5pQa2Fhibgic3gLcIfeweqeqmgVyOdCjyQfmzYyeD41ViaKw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;508462605&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1085714285714285&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBvelVDaaECmibKwBQzYWNl0piakr9hOHIQcIp7IdxCN9prg55iaUYNuicpLlPLvBhQyQ5SYWnzMibau76A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;38&quot; data-backw=&quot;278&quot; data-fileid=&quot;508462606&quot; data-ratio=&quot;0.13421052631578947&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hFm2L5m7fBu17iaEWDibxVATAq6l4UyeUs6GCy780B6EX0z5qiagCNLStYCX6cUYDWleXP1PpNg0ZtHh4xokz8picg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655955422&amp;amp;idx=1&amp;amp;sn=7b93e862bfb38db7424f10ebc7c9537b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655956767&amp;amp;idx=1&amp;amp;sn=59c191dc85fb95103ff7bca2a8379adc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;阿里新推出「瓴羊DaaS」，有没有前途？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655955577&amp;amp;idx=1&amp;amp;sn=2a96de387179da996aa73d936b0de539&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;中国的软件公司为什么做不出产品？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655947898&amp;amp;idx=1&amp;amp;sn=45f9209243c9268e3a8ac3c86a5e9973&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据可视化，看这一篇就够了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655946705&amp;amp;idx=1&amp;amp;sn=dc5d13119f9aee92b2403ba0951b8bd0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;产品经理装逼词汇大全&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655945939&amp;amp;idx=1&amp;amp;sn=635027052b2fd60771e1177b13bcd1c9&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数智凤巢，浙江移动大数据团队发布“低代码”城市实验室产品V2.0&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655944885&amp;amp;idx=1&amp;amp;sn=451691eb50993b681e6f4c95ffeb95e3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;网易严选 x 网易有数：数据产品+数据中台双引擎模式实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655943608&amp;amp;idx=1&amp;amp;sn=4980eb2f6d2458d88bded66ad4996875&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据产品经理的成长之路&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655940100&amp;amp;idx=1&amp;amp;sn=24021640b01b21b0f7953eb3396895d4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;中国移动浙江公司大数据产品手册发布！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655936030&amp;amp;idx=1&amp;amp;sn=b266824e8362c4083e60a6acda08e979&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;贝壳DMP平台建设实践&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655952484&amp;amp;idx=1&amp;amp;sn=b7be8c536402f6016802624f5acb2080&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655951859&amp;amp;idx=1&amp;amp;sn=80a17c3200adb06728ae73b01a7828eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;查看全部文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;查看全部文章&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwNDI0ODY1OA==&amp;amp;mid=2655951859&amp;amp;idx=1&amp;amp;sn=80a17c3200adb06728ae73b01a7828eb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;阅读原文&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;”查看更多精彩文章，公众号推送规则变了，如果您想及时收到推送，麻烦右下角点个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;或者把本号&lt;/span&gt;&lt;span&gt;&lt;strong&gt;置顶&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/ol&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aee867b5120273aebf2188b72224eb3d</guid>
<title>RabbitMQ、RocketMQ 和 Kafka 三元归一</title>
<link>https://toutiao.io/k/iji5qc0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23693379790940766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/IP70Vic417DOjMRrV3RrW2HaXlrTFpEI1EYiaJaJkfYOvEuQc3F6RibYXS9oMIvvJNCywron0Wd809g43gmTHlqEA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ各组件的功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker ：一个RabbitMQ实例就是一个Broker&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Virtual Host ：虚拟主机。&lt;strong&gt;相当于MySQL的DataBase&lt;/strong&gt;，一个Broker上可以存在多个vhost，vhost之间相互隔离。每个vhost都拥有自己的队列、交换机、绑定和权限机制。vhost必须在连接时指定，默认的vhost是/。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Exchange ：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Queue ：消息队列，用来保存消息直到发送给消费者。它是消息的容器。一个消息可投入一个或多个队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Banding ：绑定关系，用于&lt;strong&gt;消息队列和交换机之间的关联&lt;/strong&gt;。通过路由键（&lt;strong&gt;Routing Key&lt;/strong&gt;）将交换机和消息队列关联起来。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Channel ：管道，一条双向数据流通道。不管是发布消息、订阅队列还是接收消息，这些动作都是通过管道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了管道的概念，以复用一条TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Connection ：生产者/消费者 与broker之间的TCP连接。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Publisher ：消息的生产者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Consumer ：消息的消费者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Message ：消息，它是由消息头和消息体组成。消息头则包括&lt;strong&gt;Routing-Key&lt;/strong&gt;、&lt;strong&gt;Priority&lt;/strong&gt;（优先级）等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2636363636363636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8kx2HROoG0XQ3cMBfu2yIPD6lFudWLBLZNCLzPX6VoZuGrOGzvxT50Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RabbitMQ的多种交换机类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange 分发消息给 Queue 时， Exchange 的类型对应不同的分发策略，有3种类型的 Exchange ：&lt;strong&gt;Direct&lt;/strong&gt;、&lt;strong&gt;Fanout&lt;/strong&gt;、&lt;strong&gt;Topic&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Direct&lt;/strong&gt;：消息中的 Routing Key 如果和 Binding 中的 Routing Key 完全一致， Exchange 就会将消息分发到对应的队列中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Fanout&lt;/strong&gt;：每个发到 Fanout 类型交换机的消息都会分发到所有绑定的队列上去。Fanout交换机没有 Routing Key 。&lt;strong&gt;它在三种类型的交换机中转发消息是最快的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Topic交换机通过模式匹配分配消息，将 Routing Key 和某个模式进行匹配。它只能识别两个&lt;strong&gt;通配符&lt;/strong&gt;：&lt;strong&gt;&quot;#&quot;和&quot;*&quot;&lt;/strong&gt;。### 匹配0个或多个单词， * 匹配1个单词。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;TTL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TTL（Time To Live）：生存时间。RabbitMQ支持消息的过期时间，一共2种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;生产者的消息确认机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Confirm机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何实现Confirm确认消息？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8oyiaFSeu45TJTTLuSqNRFH26wtvFKViaqSjJRlib7prcicdQzicL0eibCoVQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在channel上开启确认模式&lt;/strong&gt;：channel.confirmSelect()&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在channel上开启监听&lt;/strong&gt;：addConfirmListener ，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8vQZqppRiaedhb9FDwKx1yPNc48E6IraDHDOh5pE95qod9XKAuYNiaBzg/640?wx_fmt=jpeg&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Return消息机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Return Listener&lt;strong&gt;用于处理一些不可路由的消息&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的消息生产者，通过指定一个Exchange和Routing，把消息送达到某一个队列中去，然后我们的消费者监听队列进行消息的消费处理操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候我们需要监听这种不可达消息，就需要使用到Returrn Listener。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基础API中有个关键的配置项 Mandatory ：如果为true，监听器会收到路由不可达的消息，然后进行处理。如果为false，broker端会自动删除该消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样，通过监听的方式， chennel.addReturnListener(ReturnListener rl) 传入已经重写过handleReturn方法的ReturnListener。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消费端ACK与NACK&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费端进行消费的时候，如果由于业务异常可以进行日志的记录，然后进行补偿。但是对于服务器宕机等严重问题，我们需要&lt;strong&gt;手动ACK&lt;/strong&gt;保障消费端消费成功。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;// deliveryTag：消息在mq中的唯一标识&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// multiple：是否批量(和qos设置类似的参数)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// requeue：是否需要重回队列。或者丢弃或者重回队首再次消费。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;basicNack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt; multiple, &lt;span&gt;boolean&lt;/span&gt; requeue)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如上代码，消息在&lt;strong&gt;消费端重回队列&lt;/strong&gt;是为了对没有成功处理消息，把消息重新返回到Broker。一般来说，实际应用中都会关闭重回队列（&lt;strong&gt;避免进入死循环&lt;/strong&gt;），也就是设置为false。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列DLX&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;死信队列（DLX Dead-Letter-Exchange）：当消息在一个队列中变成死信之后，它会被重新推送到另一个队列，这个队列就是死信队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个队列中有死信时，&lt;span&gt;RabbitMQ&lt;/span&gt;就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;阿里巴巴双十一官方指定消息产品，支撑阿里巴巴集团所有的消息服务，历经十余年高可用与高可靠的严苛考验，是阿里巴巴交易链路的核心产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rocket：火箭的意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5727272727272728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8Zv0lI93aq2Bjgcj6HicSWRYdY9icNy1fTNafiaqdicLHU5MKAMnFWhb2fQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的核心概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他有以下核心概念：Broker 、 Topic 、 Tag 、 MessageQueue 、 NameServer 、 Group 、 Offset 、 Producer 以及 Consumer 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中转角色，负责&lt;strong&gt;存储消息&lt;/strong&gt;，转发消息。&lt;strong&gt;Broker&lt;/strong&gt;是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将&lt;strong&gt;Topic&lt;/strong&gt;信息注册到NameServer，顺带一提底层的通信和连接都是&lt;strong&gt;基于Netty实现&lt;/strong&gt;的。&lt;strong&gt;Broker&lt;/strong&gt;负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。官网上有数据显示：具有&lt;strong&gt;上亿级消息堆积能力&lt;/strong&gt;，同时可&lt;strong&gt;严格保证消息的有序性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：主题！它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。&lt;strong&gt;Topic&lt;/strong&gt;与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Tag&lt;/strong&gt;：标签！可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的&lt;strong&gt;Tag&lt;/strong&gt;来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有&lt;strong&gt;Tag&lt;/strong&gt;。标签有助于保持您的代码干净和连贯，并且还可以为&lt;span&gt;RabbitMQ&lt;/span&gt;提供的查询系统提供帮助。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt;：一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NameServer&lt;/strong&gt;：类似Kafka中的ZooKeeper，但NameServer集群之间是&lt;strong&gt;没有通信&lt;/strong&gt;的，相对ZK来说更加&lt;strong&gt;轻量&lt;/strong&gt;。它主要负责对于源数据的管理，包括了对于&lt;strong&gt;Topic&lt;/strong&gt;和路由信息的管理。每个Broker在启动的时候会到NameServer注册，Producer在发送消息前会根据Topic去NameServer&lt;strong&gt;获取对应Broker的路由信息&lt;/strong&gt;，Consumer也会定时获取 Topic 的路由信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Producer&lt;/strong&gt;：生产者，支持三种方式发送消息：&lt;strong&gt;同步、异步和单向&lt;/strong&gt;单向发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，且&lt;strong&gt;没有回调函数&lt;/strong&gt;。异步发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，&lt;strong&gt;有回调函数&lt;/strong&gt;。同步发送 ：消息发出去后，等待服务器响应成功或失败，才能继续后面的操作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消费者，支持 PUSH 和 PULL 两种消费模式，支持&lt;strong&gt;集群消费&lt;/strong&gt;和&lt;strong&gt;广播消费&lt;/strong&gt;集群消费 ：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。广播消费 ：会发给消费者组中的每一个消费者进行消费。相当于&lt;strong&gt;RabbitMQ&lt;/strong&gt;的发布订阅模式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Group&lt;/strong&gt;：分组，一个组可以订阅多个Topic。分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Offset&lt;/strong&gt;：在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为Java Long类型，64位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为Message Queue是一个长度无限的数组，&lt;strong&gt;Offset&lt;/strong&gt;就是下标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延时消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源版的RocketMQ不支持任意时间精度，仅支持特定的level，例如定时5s，10s，1min等。其中，level=0级表示不延时，level=1表示1级延时，level=2表示2级延时，以此类推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延时等级如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;messageDelayLevel=&lt;span&gt;1s&lt;/span&gt; &lt;span&gt;5s&lt;/span&gt; &lt;span&gt;10s&lt;/span&gt; &lt;span&gt;30s&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;m &lt;span&gt;2&lt;/span&gt;m &lt;span&gt;3&lt;/span&gt;m &lt;span&gt;4&lt;/span&gt;m &lt;span&gt;5&lt;/span&gt;m &lt;span&gt;6&lt;/span&gt;m &lt;span&gt;7&lt;/span&gt;m &lt;span&gt;8&lt;/span&gt;m &lt;span&gt;9&lt;/span&gt;m &lt;span&gt;10&lt;/span&gt;m &lt;span&gt;20&lt;/span&gt;m &lt;span&gt;30&lt;/span&gt;m &lt;span&gt;1&lt;/span&gt;h &lt;span&gt;2&lt;/span&gt;h&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;顺序消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为 分区有序 或者 全局有序 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事务消息&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30363636363636365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx85jVmCy4mE5EiaXYkRjicsVBnrhX6bhAibXx0qeO9CJ7oUicLa75mfhMLHw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息队列MQ提供类似X/Open XA的分布式事务功能，通过消息队列MQ事务消息能达到分布式事务的最终一致。上图说明了事务消息的大致流程：正常事务消息的发送和提交、事务消息的补偿流程。另外，搜索公众号前端技术精选后台回复“前端”，获取一份惊喜礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息发送及提交：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送half消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务端响应消息写入结果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;事务消息的补偿流程：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Producer收到回查消息，检查回查消息对应的本地事务的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;根据本地事务状态，重新Commit或RollBack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;其中，补偿阶段用于解决消息Commit或Rollback发生超时或者失败的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息状态：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事务消息共有三种状态：提交状态、回滚状态、中间状态：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.CommitTransaction：提交事务，它允许消费者消费此消息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.RollbackTransaction：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TransactionStatus.Unkonwn：中间状态，它代表需要检查消息队列来确定消息状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;RocketMQ的高可用机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ是天生支持分布式的，可以配置主从以及水平扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息消费的高可用（主从）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Consumer的配置文件中，并不需要设置是从Master读还是从Slave读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。&lt;strong&gt;RocketMQ目前还不支持把Slave自动转成Master&lt;/strong&gt;，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息发送高可用（配置多个主节点）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从复制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同步复制&lt;/strong&gt;：同步复制方式是等Master和Slave均写成功后才反馈给客户端写成功状态。如果Master出故障， Slave上有全部的备份数据，容易恢复同步复制会增大数据写入延迟，降低系统吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异步复制&lt;/strong&gt;：异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通常情况下，应该把Master和Save配置成同步刷盘方式，主从之间配置成异步的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer负载均衡：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer端，每个实例在发消息的时候，默认会&lt;strong&gt;轮询&lt;/strong&gt;所有的Message Queue发送，以达到让消息平均落在不同的Queue上。而由于Queue可以散落在不同的Broker，所以消息就发送到不同的Broker下，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4618181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8eXicp5eGicAWOhGnhSRZZguUGSYLFWThVdzVMkuO3jpfkOop3n5BQK4g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;Consumer负载均衡：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果Consumer实例的数量比Message Queue的总数量还多的话，&lt;strong&gt;多出来的Consumer实例将无法分到Queue&lt;/strong&gt;，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让Queue的总数量大于等于Consumer的数量。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费者的集群模式：启动多个消费者就可以保证消费者的负载均衡（均摊队列）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;默认使用的是均摊队列&lt;/strong&gt;：会按照Queue的数量和实例的数量平均分配Queue给每个实例，这样每个消费者可以均摊消费的队列，如下图所示6个队列和三个生产者。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;另外一种平均的算法&lt;strong&gt;环状轮流分Queue&lt;/strong&gt;的形式，每个消费者，均摊不同主节点的一个消息队列，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于广播模式并不是负载均衡的，要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;死信队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列。死信队列的名称是 %DLQ%+ConsumGroup 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;死信队列具有以下特性：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列对应一个Group ID， 而不是对应单个消费者实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果一个Group ID未产生死信消息，消息队列RocketMQ不会为其创建相应的死信队列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Kafka是一个分布式、支持分区的、多副本的，&lt;strong&gt;基于ZooKeeper&lt;/strong&gt;协调的分布式消息系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于Hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，Web/Nginx日志、访问日志，消息服务等等，用&lt;strong&gt;Scala语言编写&lt;/strong&gt;。属于Apache基金会的顶级开源项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先看一下Kafka的架构图 ：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5490909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmdiabXTfZO37o8ksMOz2cxpVbibHjK1CMfaeA83leU7ge8JFj3jbBTL2A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Kafka的核心概念&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka中有几个核心概念：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Topic&lt;/strong&gt;：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Producer&lt;/strong&gt;：消息生产者，向Broker发送消息的客户端&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：消息消费者，从Broker读取消息的客户端&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConsumerGroup&lt;/strong&gt;：每个Consumer属于一个特定的ConsumerGroup，一条消息可以被多个不同的ConsumerGroup消费，但是一个ConsumerGroup中只能有一个Consumer能够消费该消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Partition&lt;/strong&gt;：物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Leader&lt;/strong&gt;：每个Partition有多个副本，其中有且仅有一个作为Leader，Leader是负责数据读写的Partition。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Follower&lt;/strong&gt;：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，Leader会把这个Follower从 ISR列表 中删除，重新创建一个Follower。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Offset&lt;/strong&gt;：偏移量。Kafka的存储文件都是按照offset.kafka来命名，用Offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以这么来理解Topic，Partition和Broker：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个Topic，代表逻辑上的一个业务数据集，比如订单相关操作消息放入订单Topic，用户相关操作消息放入用户Topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在Topic内部划分多个Partition来分片存储数据，不同的Partition可以位于不同的机器上，相当于&lt;strong&gt;分布式存储&lt;/strong&gt;。每台机器上都运行一个Kafka的进程Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka核心总控制器Controller&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka集群中会有一个或者多个Broker，其中有一个Broker会被选举为控制器（Kafka Controller），可以理解为 Broker-Leader ，它负责管理整个 集群中所有分区和副本的状态。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;Partition-Leader&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Controller选举机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kafka集群启动的时候，选举的过程是集群中每个Broker都会尝试在ZooKeeper上创建一个 /controller临时节点，ZooKeeper会保证有且仅有一个Broker能创建成功，这个Broker就会成为集群的总控器Controller。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个Controller角色的Broker宕机了，此时ZooKeeper临时节点会消失，集群里其他Broker会一直监听这个临时节 点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，ZooKeeper又会保证有一个Broker成为新的Controller。具备控制器身份的Broker需要比其他普通的Broker多一份职责，具体细节如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监听Broker相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/ids/节点添加BrokerChangeListener，用来处理Broker增减的变化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;监听Topic相关的变化&lt;/strong&gt;。为ZooKeeper中的/brokers/topics节点添加TopicChangeListener，用来处理Topic增减的变化；为ZooKeeper中的/admin/delete_topics节点添加TopicDeletionListener，用来处理删除Topic的动作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从ZooKeeper中读取获取当前所有与Topic、Partition以及Broker有关的信息并进行相应的管理 。对于所有Topic所对应的ZooKeeper中的/brokers/topics/节点添加PartitionModificationsListener，用来监听Topic中的分区分配变化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更新集群的元数据信息，同步到其他普通的Broker节点中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Partition副本选举Leader机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller感知到分区Leader所在的Broker挂了，Controller会从ISR列表（参数&lt;br/&gt;unclean.leader.election.enable=false的前提下）里挑第一个Broker作为Leader（第一个Broker最先放进ISR列表，可能是同步数据最多的副本），如果参数unclean.leader.election.enable为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选Leader，这种设置，可以提高可用性，但是选出的新Leader有可能数据少很多。副本进入ISR列表有两个条件：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本节点不能产生分区，必须能与ZooKeeper保持会话以及跟Leader副本网络连通&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本能复制Leader上的所有写操作，并且不能落后太多。（与Leader副本同步滞后的副本，是由replica.lag.time.max.ms配置决定的，超过这个时间都没有跟Leader同步过的一次的副本会被移出ISR列表）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;消费者消费消息的Offset记录机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个Consumer会定期将自己消费分区的Offset提交给Kafka内部Topic：consumer_offsets，提交过去的时候，key是consumerGroupId+topic+分区号，value就是当前Offset的值，Kafka会定期清理Topic里的消息，最后就保留最新的那条数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为__consumer_offsets可能会接收高并发的请求，Kafka默认给其分配50个分区（可以通过&lt;br/&gt;offsets.topic.num.partitions设置），这样可以通过加机器的方式抗大并发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance就是说 如果消费组里的消费者数量有变化或消费的分区数有变化，Kafka会重新分配消费者与消费分区的关系 。比如consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：Rebalance只针对subscribe这种不指定分区消费的情况，如果通过assign这种消费方式指定了分区，Kafka不会进行Rebalance。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下情况可能会触发消费者Rebalance：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组里的Consumer增加或减少了&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态给Topic增加了分区&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;消费组订阅了更多的Topic&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Rebalance过程中，消费者无法从Kafka消费消息，这对Kafka的TPS会有影响，如果Kafka集群内节点较多，比如数百 个，那重平衡可能会耗时极多，所以应尽量避免在系统高峰期的重平衡发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rebalance过程如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45454545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RCpZW5tIPyCQwzyVNwT3dx8t9xtcSvqMQEPbwdRkIxRuPBtPVXVEB3CMfHvtiaicqUYW4iaFJMFMz8gg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot;/&gt;&lt;span&gt;&lt;strong&gt;第一阶段：选择组协调器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组协调器GroupCoordinator：每个consumer group都会选择一个Broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者Rebalance。consumer group中的每个consumer启动时会向Kafka集群中的某个节点发送FindCoordinatorRequest请求来查找对应的组协调器GroupCoordinator，并跟其建立网络连接。组协调器选择方式：通过如下公式可以选出consumer消费的Offset要提交到__consumer_offsets的哪个分区，这个分区Leader对应的Broker就是这个consumer group的coordinator公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;hash(consumer group id) % 对应主题的分区数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二阶段：加入消费组JOIN GROUP&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在成功找到消费组所对应的GroupCoordinator之后就进入加入消费组的阶段，在此阶段的消费者会向GroupCoordinator发送JoinGroupRequest请求，并处理响应。然后GroupCoordinator从一个consumer group中选择第一个加入group的consumer作为Leader（消费组协调器），把consumer group情况发送给这个Leader，接着这个Leader会负责制定分区方案。另外，搜索公众号Python人工智能技术后台回复“名著”，获取一份惊喜礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三阶段（SYNC GROUP）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各个consumer，他们会根据指定分区的Leader Broker进行网络连接以及消息消费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者Rebalance分区分配策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要有三种Rebalance的策略：range 、 round-robin 、 sticky 。&lt;strong&gt;默认情况为range分配策略&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设一个主题有10个分区（0-9），现在有三个consumer消费：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;range策略：按照分区序号排序分配 ，假设n＝分区数／消费者数量 = 3， m＝分区数%消费者数量 = 1，那么前 m 个消 费者每个分配 n+1 个分区，后面的（消费者数量－m ）个消费者每个分配 n 个分区。比如分区0~ 3给一个consumer，分区4~ 6给一个consumer，分区7~9给一个consumer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;round-robin策略：轮询分配 ，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sticky策略：初始时分配策略与round-robin类似，但是在rebalance的时候，需要保证如下两个原则：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配要尽可能均匀 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分区的分配尽可能与上次分配的保持相同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下：consumer1除了原有的0~ 3，会再分配一个7 consumer2除了原有的4~ 6，会再分配8和9。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer发布消息机制剖析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、写入方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer采用push模式将消息发布到broker，每条消息都被append到patition中，属于顺序写磁盘（&lt;strong&gt;顺序写磁盘 比 随机写 效率要高，保障 kafka 吞吐率&lt;/strong&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;pre mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UXcBIdyPOYfUfaibicSXbZSrkFL9jwZRTUz8aKA1zXq1GDV8Z7uXeep6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NjYxNDc2OQ==&amp;amp;mid=2247494973&amp;amp;idx=1&amp;amp;sn=3845f08876076eaafe1457a48b752f20&amp;amp;chksm=fbc0f823ccb77135921333d9cd41569f223cd85ffea3095a8ced1e711263f8698e0884a5cce0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍牛逼啊！接私活必备的 N 个开源项目！赶快收藏吧‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;牛逼啊！接私活必备的 N 个开源项目！赶快收藏吧&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;2、消息路由&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;hash&lt;/span&gt;(key)%分区数&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;3、写入流程&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8072727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmlFddwXPVicP6tGz7ankHjcOlv6OcQL3w4uMlbwz64SHeVG9IXaUgoMA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer先从ZooKeeper的 &quot;/brokers/…/state&quot; 节点找到该partition的leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;producer将消息发送给该leader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader将消息写入本地log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;followers从leader pull消息，写入本地log后向leader发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;HW与LEO&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HW俗称高水位 ，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO（log-end-offset）作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志分段存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，消息在分区内是分段存储的， 每个段的消息都存储在不一样的log文件里，Kafka规定了一个段位的log文件最大为1G，做这个限制目的是为了方便把log文件加载到内存去操作：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;1 ### 部分消息的&lt;span&gt;offset&lt;/span&gt;索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;index&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;2 ### 如果要定位消息的&lt;span&gt;offset&lt;/span&gt;会先在这个文件里快速定位，再去&lt;span&gt;log&lt;/span&gt;文件里找具体消息 &lt;br/&gt;&lt;br/&gt;3 00000000000000000000&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;4 ### 消息存储文件，主要存&lt;span&gt;offset&lt;/span&gt;和消息体 &lt;br/&gt;&lt;br/&gt;5 00000000000000000000&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;6 ### 消息的发送时间索引文件，&lt;span&gt;kafka&lt;/span&gt;每次往分区发4&lt;span&gt;K&lt;/span&gt;(可配置)消息就会记录一条当前消息的发送时间戳与对应的&lt;span&gt;offset&lt;/span&gt;到&lt;span&gt;timeindex&lt;/span&gt;文件， &lt;br/&gt;&lt;br/&gt;7 ### 如果需要按照时间来定位消息的&lt;span&gt;offset&lt;/span&gt;，会先在这个文件里查找 &lt;br/&gt;&lt;br/&gt;8 00000000000000000000&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;9 &lt;br/&gt;&lt;br/&gt;10 00000000000005367851&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;11 00000000000005367851&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;12 00000000000005367851&lt;span&gt;.timeindex&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;13 &lt;br/&gt;&lt;br/&gt;14 00000000000009936472&lt;span&gt;.index&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;15 00000000000009936472&lt;span&gt;.log&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;16 00000000000009936472&lt;span&gt;.timeindex&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这个9936472之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka Broker有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是1GB。一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做log rolling，正在被写入的那个日志段文件，叫做active log segment。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后附一张ZooKeeper节点数据图&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5690909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmrRDONQiaC4jwSibjwtibufRSbznQicJj3ONolhvDbzNAlh6wthsCd9Ubgw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;MQ带来的一些问题、及解决方案&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;如何保证顺序消费？&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;如何实现延迟消费？&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3327272727272727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmplS5SF0nJ7ofXsg8quUjyRWLonV7hSVyDsg0QurFtRLaaH3o57qeuQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的可靠性投递&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Broker--&amp;gt;消费者：手动ACK&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生产者--&amp;gt;Broker：两种方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;数据库持久化：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单数据和生成的&lt;span&gt;Message&lt;/span&gt;进行持久化操作（一般情况下插入数据库，这里如果分库的话可能涉及到分布式事务）&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.将&lt;span&gt;Message&lt;/span&gt;发送到Broker服务器中&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.通过RabbitMQ的Confirm机制，在producer端，监听服务器是否ACK。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.如果ACK了，就将&lt;span&gt;Message&lt;/span&gt;这条数据状态更新为已发送。如果失败，修改为失败状态。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.分布式定时任务查询数据库&lt;span&gt;3&lt;/span&gt;分钟（这个具体时间应该根据的时效性来定）之前的发送失败的消息&lt;br/&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.重新发送消息，记录发送次数&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果发送次数过多仍然失败，那么就需要人工排查之类的操作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6854545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmy4rhX42iciaolFsTzwNSYJ5qGUdiawRutBQofb7tSUXKFicEuJmfXjFlTQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;优点：能够保证消息百分百不丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：第一步会涉及到分布式事务问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息的延迟投递：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;流程图中，颜色不同的代表不同的&lt;span&gt;message&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;.将业务订单持久化&lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.发送一条&lt;span&gt;Message&lt;/span&gt;到broker(称之为主&lt;span&gt;Message&lt;/span&gt;)，再发送相同的一条到不同的队列或者交换机(这条称为确认&lt;span&gt;Message&lt;/span&gt;)中。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.主&lt;span&gt;Message&lt;/span&gt;由实际业务处理端消费后，生成一条响应&lt;span&gt;Message&lt;/span&gt;。之前的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service应用处理入库。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;~&lt;span&gt;6&lt;/span&gt;.实际业务处理端发送的确认&lt;span&gt;Message&lt;/span&gt;由&lt;span&gt;Message&lt;/span&gt; Service接收后，将原&lt;span&gt;Message&lt;/span&gt;状态修改。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.如果该条&lt;span&gt;Message&lt;/span&gt;没有被确认，则通过rpc调用重新由producer进行全过程。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33090909090909093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmjEfxDGXNpPLJOygefrkg1f2ar0yciaUlj5QW62535bSO5P6D5OYlwdA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;优点：相对于持久化方案来说响应速度有所提升&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：系统复杂性有点高，万一消息都失败了，消息存在丢失情况，仍需Confirm机制做补偿。扩展：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjM3MDEyMg==&amp;amp;mid=2247534656&amp;amp;idx=2&amp;amp;sn=2781baec773a9340091436c521430648&amp;amp;chksm=e8dae9e5dfad60f33204393e3c333800e8fb8dd39fd43064d496b665cd31c0a61b742f2f23b2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍接私活儿‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;接私活儿&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生产者弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Producer在把Message发送Broker的过程中，因为网络问题等发生丢失，或者Message到了Broker，但是出了问题，没有保存下来。针对这个问题，&lt;span&gt;RocketMQ&lt;/span&gt;对Producer发送消息设置了3种方式：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;同步发送&lt;br/&gt;异步发送&lt;br/&gt;单向发送&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;Broker弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Broker接收到Message暂存到内存，Consumer还没来得及消费，Broker挂掉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以通过 持久化 设置去解决：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建Queue的时候设置持久化，保证Broker持久化Queue的元数据，但是不会持久化Queue里面的消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将Message的deliveryMode设置为2，可以将消息持久化到磁盘，这样只有Message支持化到磁盘之后才会发送通知Producer ack&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这两步过后，即使Broker挂了，Producer肯定收不到ack的，就可以进行重发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者弄丢数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Consumer有消费到Message，但是内部出现问题，Message还没处理，Broker以为Consumer处理完了，只会把后续的消息发送。这时候，就要 关闭autoack，消息处理过后，进行手动ack , 多次消费失败的消息，会进入 死信队列 ，这时候需要人工干预。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;生产者弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置了 acks=all ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Broker弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时一般是要求起码设置如下 4 个参数：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;replication.factor&lt;br/&gt;min.insync.replicas&lt;br/&gt;acks=all&lt;br/&gt;retries=MAX&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者弄丢数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要 关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;如何保证消息的幂等？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;以 RocketMQ 为例，下面列出了消息重复的场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发送时消息重复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投递时消息重复&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列&lt;span&gt;RocketMQ&lt;/span&gt;版的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负载均衡时消息重复（包括但不限于网络抖动、Broker重启以及消费者应用重启）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当消息队列RocketMQ版的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到重复消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，有什么解决方案呢？直接上图。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1189591078066914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDm2L8ia4D2TFytFpGdcARb3kbKaVLt1p3o0PsZTlibaU0cXSm6LUDAvlag/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1076&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;如何解决消息积压的问题？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;关于这个问题，有几个点需要考虑：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何快速让积压的消息被消费掉？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;临时写一个消息分发的消费者，把积压队列里的消息均匀分发到N个队列中，同时一个队列对应一个消费者，相当于消费速度提高了N倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;修改前：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5664739884393064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmCial2cgvviaOGMyPOzib2E5oxUYZWP4QIpSiczAOFH2rIcfGe3ZpjJLiaIQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1038&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;修改后：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.68&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/OKUeiaP72uRwJqJgNd6pRoAUsG8b6nicDmCNrHYgLCHZNNDw0TME7uicSsuHnJrhW55gyibuWXyaeeYicEIZe6zw41A/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;other&quot; data-w=&quot;1100&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;积压时间太久，导致部分消息过期，怎么处理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;批量重导。在业务不繁忙的时候，比如凌晨，提前准备好程序，把丢失的那批消息查出来，重新导入到MQ中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息大量积压，MQ磁盘被写满了，导致新消息进不来了，丢掉了大量消息，怎么处理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个没办法。谁让【消息分发的消费者】写的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;链接：jianshu.com/p/2975d354fca5&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;（版权归原作者所有，侵删）&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-before-oversubscription-url=&quot;https://mmbiz.qlogo.cn/mmbiz_gif/HbjXqFK3L72957xsibH48vUn4119YSdqKzKaWGu3iaLPF8MpDeGzGJRDyXEjp2hEX6VE5ruWP2uibv4tVibOrwYIaA/0?wx_fmt=gif&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/US10Gcd0tQEfcffueY0reDaT8agHibMbk6Pqc4ibhiccO8Pz07m9jJ4eyuPZVomxWiac5FdicwB3aOub11CqBzXQrjw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7185185185185186&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QFzRdz9libEa0J6uBEmJSsusCngZf5tUsHnDPvWW0f4RASUkKy4UmdvEhtP7jLfKQoViaCNG39G7AFoh1o8ibTibMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>