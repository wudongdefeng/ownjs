<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4b547f60ae6119ec23bb22066050bdf7</guid>
<title>优质网站同好者周刊（第 074 期） | 倾城博客</title>
<link>https://toutiao.io/k/wjiq1dv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%91%E7%8E%B0&quot;&gt;&lt;code&gt;发现&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%9B%E4%B8%9A%E8%80%85&quot;&gt;&lt;code&gt;创业者&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;BetaList provides an overview of upcoming internet startups. Discover and get early access to the future.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/betalist.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Discover and get early access to tomorrow&#x27;s startups | BetaList&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://betalist.com/&quot;&gt;BetaList&lt;/a&gt; ，是一个在线平台 ， 使用户能够发现、并尽早接触最新的互联网创业公司的社区。它由制造商和早期采用者（adopters）组成，是早期采用者发现即将推出，以及最近推出的互联网初创公司的地方，也是初创公司创始人与世界分享他们的初创公司，并获得早期用户反馈的地方。如果您拥有初创公司，您可以提交您的网站至 &lt;code&gt;betaList&lt;/code&gt;，当然您也可以在 BetaList 做广告，以便得到更多的曝光。&lt;/p&gt;&lt;p&gt;对于更多普通用户，您可以在 BetaList 了解当年一些创业的想法和实现，从而汲取灵感，相信无论对于您创业，或者高效工作、快乐生活，都有一定参考价值。如果您想了解更多关于 BetaList，可以参见 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://betalist.com/faq&quot;&gt;BetaList FAQ&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62d01a5f65fb1506218fa5da&quot;&gt;倾城之链 - Discover and get early access to tomorrow&#x27;s startups | BetaList&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%89%E8%B6%A3&quot;&gt;&lt;code&gt;有趣&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85&quot;&gt;&lt;code&gt;独立开发者&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%BA%A7%E5%93%81&quot;&gt;&lt;code&gt;产品&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：habits, habits tracker, build habits, habit tracker, consistency, be consistent, create habit, good habit, atomic habits, garden, habits garden, procrastination&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Build habits to grow a garden. Turn your daily tasks into a game with friends. Achieving your goals has never been so easy, fast, and fun!&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/habitsgarden.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Beat procrastination with a gamified habit tracker - Habits Garden&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://habitsgarden.com/&quot;&gt;Habits Garden&lt;/a&gt; ，习惯花园，一款在线产品应用，旨在用游戏的形式，来让你养成一个习惯，从而战胜拖延症，比如读书，戒烟，学英语等等。其内在逻辑是，它利用游戏的令人上瘾的力量，来帮助您养成与朋友一起玩乐的好习惯。具体是：通过挑战任务，来完成目标，获得奖励，然后重复，从而帮助养成习惯。每天打卡获得钻石，钻石可以用来种树，进而种植一个美妙的花园。您也可以邀请好友一起来，查看他们的习惯，互相激励，争夺每周排行榜！&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://habitsgarden.com/&quot;&gt;Habits Garden&lt;/a&gt; 界面设计非常简洁好看，还有音效和动画；作者不打算提供 IOS 或 Android 应用，您可以将 Habits Garden &lt;strong&gt;添加到您的主屏幕&lt;/strong&gt;（通过&lt;code&gt;浏览器&lt;/code&gt;），它的行为就像一个原生应用程序。您可以在智能手机、平板电脑和笔记本电脑上，使用习惯追踪器。habits garden 免费可用，当免费试用期（7 天）结束后，游戏功能被锁定（花园、任务、奖励等），您的帐户被切换到 Free-Forever Habit Tracker Plan。您可以免费使用最令人满意的习惯跟踪器，继续完成您的日常习惯！值得一提的是：该产品是作者（ @marc_louvion ）独立完成，目前在巴厘岛，天天冲浪，这个产品。每月给他带来数百美元的收入。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62d00b7765fb1506218fa5d8&quot;&gt;倾城之链 - Beat procrastination with a gamified habit tracker - Habits Garden&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E8%80%85&quot;&gt;&lt;code&gt;独立开发者&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%91%E7%8E%B0&quot;&gt;&lt;code&gt;发现&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：独立开发者, 全栈开发, UI设计, DecoHack&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为独立创造者提供独立见解，发现新产品，内容包含不限于新闻洞察、行业分析、产品推荐、推特精选、产品运营、产品设计、UI 设计、技术开发、生活方式等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.decohack.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Decohack-独立开发者灵感周刊&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.decohack.com/&quot;&gt;Decohack&lt;/a&gt; ，独立开发者在线灵感周刊，旨在为独立创造者提供独立见解，发现新产品，内容包含不限于新闻洞察、行业分析、产品推荐、推特精选、产品运营、产品设计、UI 设计、技术开发、生活方式等。&lt;/p&gt;&lt;h3 id=&quot;作者为什么要做-decohack&quot;&gt;&lt;a href=&quot;#%E4%BD%9C%E8%80%85%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A-decohack&quot; aria-label=&quot;作者为什么要做 decohack permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;作者为什么要做 DecoHack？&lt;/h3&gt;&lt;p&gt;DecoHack 的定位是：帮助独立开发者发现新产品方向（国内国外），帮助有想法的人，设计制作和运营自己的互联网产品，打造持续被动收入，体现个人价值。&lt;/p&gt;&lt;p&gt;希望国内的独立互联网创造者拓展自己的能力范围：需求洞察能力，行业分析能力，产品思维，产品设计方法流程，产品运营能力，产品上架公司注册等问题。&lt;/p&gt;&lt;h3 id=&quot;decohack-会有什么内容&quot;&gt;&lt;a href=&quot;#decohack-%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%86%85%E5%AE%B9&quot; aria-label=&quot;decohack 会有什么内容 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;DecoHack 会有什么内容？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;新闻洞察：收集每周相关的新闻资讯；&lt;/li&gt;&lt;li&gt;灵感推荐：每周推荐 N 款独立开发者项目，分析其功能及市场情况；&lt;/li&gt;&lt;li&gt;资源推荐：每周好资源；&lt;/li&gt;&lt;li&gt;产品分析：每周分析一款产品（APP 或者网站），包含产品日活，新增下载使用，收入，产品公司团队调研，产品开发成；本，技术难度等；&lt;/li&gt;&lt;li&gt;好文推荐：推荐独立开发者相关好文章；&lt;/li&gt;&lt;li&gt;下饭视频：如题，不限制，下饭；&lt;/li&gt;&lt;li&gt;推特精选：Twitter 上很优秀的内容；&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;关于作者&quot;&gt;&lt;a href=&quot;#%E5%85%B3%E4%BA%8E%E4%BD%9C%E8%80%85&quot; aria-label=&quot;关于作者 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;关于作者&lt;/h3&gt;&lt;p&gt;作者本职工作是一个互联网产品设计师，之前学的是软件开发专业，所以除了工作之外，一直都在做一些产品设计和开发相关的事情，再之前有创业做过很多产品，也做过产品运营和广告投放的工作。目前全职搬砖，这个订阅是其闲暇时间的产出。&lt;/p&gt;&lt;p&gt;DecoHack，会在每周一早上 9 点，通过微信及邮件推送，也会在「竹白」上发布。熟悉 RSS 订阅的朋友，也可以在 RSS 来订阅。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62cedc0b65fb1506218fa5d3&quot;&gt;倾城之链 - Decohack-独立开发者灵感周刊&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%9C%8D%E5%8A%A1&quot;&gt;&lt;code&gt;服务&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Flutter&quot;&gt;&lt;code&gt;Flutter&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Appwrite provides web and mobile developers with a set of easy-to-use and integrate REST APIs to manage their core backend needs.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/appwrite.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Appwrite - Open-Source End-to-End Backend Server&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://appwrite.io/&quot;&gt;Appwrite&lt;/a&gt; 为 Web、移动和 Flutter 开发人员，提供安全的开源后端服务器，🚀又名 100% 开源 Firebase 替代品。它被打包成一组 Docker 微服务。Appwrite 抽象了从头开始构建现代后端 API 所需的复杂性和重复性，使你能够更快地构建安全的应用程序。&lt;/p&gt;&lt;p&gt;使用 appwrite，你可以轻松地将你的应用程序，与用户认证和多种登录方式、用于存储和查询用户和团队数据的数据库、存储和文件管理、图像处理、云功能以及更多服务整合在一起。它具备以下功能特征：&lt;/p&gt;&lt;h3 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#%E6%95%B0%E6%8D%AE%E5%BA%93&quot; aria-label=&quot;数据库 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;数据库&lt;/h3&gt;&lt;p&gt;存储、查询和管理对应用文档的访问控制；&lt;/p&gt;&lt;h3 id=&quot;身份验证和用户&quot;&gt;&lt;a href=&quot;#%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E5%92%8C%E7%94%A8%E6%88%B7&quot; aria-label=&quot;身份验证和用户 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;身份验证和用户&lt;/h3&gt;&lt;p&gt;使用多种登录方法对用户进行身份验证、确认和管理；&lt;/p&gt;&lt;h3 id=&quot;贮存&quot;&gt;&lt;a href=&quot;#%E8%B4%AE%E5%AD%98&quot; aria-label=&quot;贮存 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;贮存&lt;/h3&gt;&lt;p&gt;上传、下载和预览您的应用和用户文件；&lt;/p&gt;&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#%E5%8A%9F%E8%83%BD&quot; aria-label=&quot;功能 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;功能&lt;/h3&gt;&lt;p&gt;在安全和隔离的环境中运行您的后端代码以自定义您的应用程序；&lt;/p&gt;&lt;h3 id=&quot;地理与本地化&quot;&gt;&lt;a href=&quot;#%E5%9C%B0%E7%90%86%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%8C%96&quot; aria-label=&quot;地理与本地化 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;地理与本地化&lt;/h3&gt;&lt;p&gt;检测您的用户位置、区域设置并获取与 GEO 相关的数据；&lt;/p&gt;&lt;h3 id=&quot;隐私&quot;&gt;&lt;a href=&quot;#%E9%9A%90%E7%A7%81&quot; aria-label=&quot;隐私 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;隐私&lt;/h3&gt;&lt;p&gt;拥有您的数据。在您的基础架构上轻松设置 Appwrite 自托管解决方案；&lt;/p&gt;&lt;h3 id=&quot;安全&quot;&gt;&lt;a href=&quot;#%E5%AE%89%E5%85%A8&quot; aria-label=&quot;安全 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安全&lt;/h3&gt;&lt;p&gt;为传输中和静止的后端 API 提供端到端的安全性；&lt;/p&gt;&lt;p&gt;Appwrite，功能强大，且具备安全性和灵活性；您可以利用 Appwrite 服务加速您在任何平台上的开发。值得一提的是，Appwrite 后端服务器设计为在容器环境中运行。运行服务器就像从终端运行一个命令一样简单。您可以使用 docker-compose 在本地主机上运行 Appwrite，也可以在任何其他容器编排工具（如 &lt;a href=&quot;https://nicelinks.site/post/5b2cad0a34c03342fda0f37e&quot;&gt;Kubernetes&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5b7036890f8719053c094d68&quot;&gt;Docker&lt;/a&gt; Swarm 或 Rancher）上运行 Appwrite。此外，Appwrite 设计合理，使用简单，可快速上手，没有额外依赖，文档详细，跨平台一致性良好。如果您有兴趣了解更多，可参见：&lt;a href=&quot;https://github.com/appwrite/appwrite&quot;&gt;Appwrite Github&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62cd24bbac177b7aff5e1a70&quot;&gt;倾城之链 - Appwrite - Open-Source End-to-End Backend Server&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Deno&quot;&gt;&lt;code&gt;Deno&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2&quot;&gt;&lt;code&gt;个人博客&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/JavaScript&quot;&gt;&lt;code&gt;JavaScript&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Ryan&#x27;s Blog, built and deployed on Deno.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/tinyclouds.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Ryan Dahl&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://tinyclouds.org/&quot;&gt;Ryan&#x27;s Blog&lt;/a&gt; ，基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 构建和部署， &lt;a href=&quot;https://github.com/ry/tinyclouds&quot;&gt;在 Github 开源&lt;/a&gt; ，可在不到 10 秒的时间内完成部署。Ryan Dahl，出生于 1981 年，美国的软件工程师，是 “&lt;a href=&quot;https://nicelinks.site/post/5f376ebe1751843ef894c899&quot;&gt;Node.js&lt;/a&gt;”、“&lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt;” 的开发者，使得编程语言 JavaScript 可运行在非浏览器环境，为 Web 前端发展做出了巨大贡献。在 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://tinyclouds.org/&quot;&gt;Ryan&#x27;s Blog&lt;/a&gt; ，您可以读到 Ryan Dahl 关于 Deno、技术、思想等内容。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62cc2079ac177b7aff5e1a6e&quot;&gt;倾城之链 - Ryan Dahl&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Electron&quot;&gt;&lt;code&gt;Electron&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;跨平台&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Tauri is a framework for building tiny, blazing fast binaries for all major desktop platforms. Developers can integrate any front-end framework that compiles to HTML, JS and CSS for building their user interface.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/tauri.app.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Build smaller, faster, and more secure desktop applications with a web frontend | Tauri Apps&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://tauri.app/&quot;&gt;Tauri&lt;/a&gt; 是一个框架，用于为所有主要的桌面平台构建微小、快速的二进制文件，旨在为多平台部署构建优化、安全且独立于前端的应用程序。开发人员可以整合任何可以编译成 HTML、JS 和 CSS 的前端框架，以构建他们的用户界面。应用程序的后端是一个来自 rust 的二进制文件，带有一个前端可以与之交互的 API。&lt;/p&gt;&lt;h3 id=&quot;如何开始使用&quot;&gt;&lt;a href=&quot;#%E5%A6%82%E4%BD%95%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8&quot; aria-label=&quot;如何开始使用 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;如何开始使用&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# npm
npm create tauri-app

# yarn
yarn create tauri-app

# pnpm
pnpm create tauri-app
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://tauri.app/&quot;&gt;Tauri&lt;/a&gt; 具备如下功能特性：&lt;/p&gt;&lt;h3 id=&quot;兼容性良好&quot;&gt;&lt;a href=&quot;#%E5%85%BC%E5%AE%B9%E6%80%A7%E8%89%AF%E5%A5%BD&quot; aria-label=&quot;兼容性良好 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;兼容性良好&lt;/h3&gt;&lt;p&gt;与任何前端框架的兼容性意味着您不必更改堆栈。&lt;/p&gt;&lt;h3 id=&quot;安全-1&quot;&gt;&lt;a href=&quot;#%E5%AE%89%E5%85%A8-1&quot; aria-label=&quot;安全 1 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安全&lt;/h3&gt;&lt;p&gt;Tauri 团队的首要任务是推动我们的最高优先事项和最大的创新。&lt;/p&gt;&lt;h3 id=&quot;开源&quot;&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90&quot; aria-label=&quot;开源 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;开源&lt;/h3&gt;&lt;p&gt;由于 MIT 或 MIT/Apache 2.0 许可（如果适用），重新许可和重新分发是可能的。&lt;/p&gt;&lt;h3 id=&quot;体积小&quot;&gt;&lt;a href=&quot;#%E4%BD%93%E7%A7%AF%E5%B0%8F&quot; aria-label=&quot;体积小 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;体积小&lt;/h3&gt;&lt;p&gt;通过使用操作系统的原生网络渲染器，Tauri 应用的大小可以小于 600KB。&lt;/p&gt;&lt;h3 id=&quot;跨平台&quot;&gt;&lt;a href=&quot;#%E8%B7%A8%E5%B9%B3%E5%8F%B0&quot; aria-label=&quot;跨平台 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;跨平台&lt;/h3&gt;&lt;p&gt;捆绑所有主要桌面平台的二进制文件（移动和 WASM 即将推出）。&lt;/p&gt;&lt;h3 id=&quot;建立在-rust-之上&quot;&gt;&lt;a href=&quot;#%E5%BB%BA%E7%AB%8B%E5%9C%A8-rust-%E4%B9%8B%E4%B8%8A&quot; aria-label=&quot;建立在 rust 之上 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;建立在 Rust 之上&lt;/h3&gt;&lt;p&gt;以性能和安全为中心，Rust 是下一代应用程序的语言。&lt;/p&gt;&lt;p&gt;除此之外，&lt;code&gt;tauri&lt;/code&gt; 还具备自动更新、原生通知、数据存储、核心插件系统等。Tauri 是一个工具包，可帮助开发人员为主要桌面平台制作应用程序；几乎使用现有的任何前端框架。核心是用 Rust 构建的，CLI 利用 Node.js 使 Tauri 成为一种真正的多语言方法来创建和维护出色的应用程序。&lt;/p&gt;&lt;p&gt;在基于前端技术，而构建桌面应用工具中，&lt;a href=&quot;https://nicelinks.site/post/5b17d4a597006c5273505e1b&quot;&gt;Electron&lt;/a&gt; 无疑是其中的佼佼者；&lt;code&gt;tauri&lt;/code&gt; 则有意成为 Electron 替代品，主张使用 Web 前端构建更小、更快、更安全的桌面应用程序。对 Tauri 和 Electron 区别感兴趣的朋友，可参见 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://github.com/tauri-apps/tauri#comparison-between-tauri-and-electron&quot;&gt;Tauri 和 Electron 的比较&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62cc1748ac177b7aff5e1a6c&quot;&gt;倾城之链 - Build smaller, faster, and more secure desktop applications with a web frontend | Tauri Apps&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;林断山明竹隐墙，乱蝉衰草小池塘。&lt;br/&gt;翻空白鸟时时见，照水红蕖细细香。&lt;br/&gt;村舍外，古城旁，杖藜徐步转斜阳。&lt;br/&gt;&lt;strong&gt;殷勤昨夜三更雨，又得浮生一日凉&lt;/strong&gt;。&lt;br/&gt;──宋 · 苏轼《鹧鸪天》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h3&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ac2e94c684c54a33796f06a496ba3cb</guid>
<title>基于 CRON 库扩展的分布式 Crontab 的实现</title>
<link>https://toutiao.io/k/kx9h6j4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：熊喵君，原文链接：&lt;/span&gt;&lt;span&gt;https://pandaychen.github.io/2022/01/16/A-GOLANG-CRONTAB-V3-ANALYSIS/&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x00 前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;cron&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 是一个用于管理定时任务的库（单机），基于 Golang 实现 Linux 中 crontab 的功能&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x01 使用&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linux 的 crontab&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;crontab 基本格式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 文件格式說明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# ┌──分钟（0 - 59）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# │ ┌──小时（0 - 23）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# │ │ ┌──日（1 - 31）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# │ │ │ ┌─月（1 - 12）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# │ │ │ │ ┌─星期（0 - 6，表示从周日到周六）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# │ │ │ │ │&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# * * * * * 被执行的命令&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础例子&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用法极丰富，V3 版本也支持标准的 &lt;code&gt;crontab&lt;/code&gt; 格式，具体用法细节可以参考 &lt;span&gt;此文&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    job := cron.New(&lt;br/&gt;        cron.WithSeconds(), // 添加秒级别支持，默认支持最小粒度为分钟（如需秒级精度则必须设置）&lt;br/&gt;    )&lt;br/&gt;    // 每秒钟执行一次&lt;br/&gt;    job.AddFunc(&lt;span&gt;&quot;* * * * * *&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        fmt.Printf(&lt;span&gt;&quot;task run: %v\n&quot;&lt;/span&gt;, time.Now())&lt;br/&gt;    })&lt;br/&gt;    job.Run()   // 启动&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他典型的用法还有如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; cronJobDemo int&lt;br/&gt;&lt;br/&gt;func (c cronJobDemo) &lt;span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;5s func trigger&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    c := cron.New(&lt;br/&gt;            cron.WithSeconds(),&lt;br/&gt;    )&lt;br/&gt;    c.AddFunc(&lt;span&gt;&quot;0 * * * *&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { fmt.Println(&lt;span&gt;&quot;Every hour on the half hour&quot;&lt;/span&gt;) })&lt;br/&gt;    c.AddFunc(&lt;span&gt;&quot;30 3-6,20-23 * * *&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { fmt.Println(&lt;span&gt;&quot;.. in the range 3-6am, 8-11pm&quot;&lt;/span&gt;) })&lt;br/&gt;    c.AddFunc(&lt;span&gt;&quot;CRON_TZ=Asia/Tokyo 30 04 * * *&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { fmt.Println(&lt;span&gt;&quot;Runs at 04:30 Tokyo time every day&quot;&lt;/span&gt;) })&lt;br/&gt;    c.AddFunc(&lt;span&gt;&quot;@every 5m&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() { fmt.Println(&lt;span&gt;&quot;every 5m, start 5m fron now&quot;&lt;/span&gt;) }) // 容易理解的格式&lt;br/&gt;    // 通过 AddJob 注册&lt;br/&gt;    var cJob cronJobDemo&lt;br/&gt;    c.AddJob(&lt;span&gt;&quot;@every 5s&quot;&lt;/span&gt;, cJob)&lt;br/&gt;    c.Start()&lt;br/&gt;    // c.Stop()&lt;br/&gt;&lt;br/&gt;    select {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x02 代码分析&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;核心数据结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 cron 库的整体逻辑，最关键的两个数据结构就是 &lt;code&gt;Entry&lt;/code&gt; 和 &lt;code&gt;Cron&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;code&gt;Job&lt;/code&gt;：抽象一个定时任务，cron 调度一个 &lt;code&gt;Job&lt;/code&gt;，就去执行 &lt;code&gt;Job&lt;/code&gt; 的 &lt;code&gt;Run()&lt;/code&gt; 方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Job interface {&lt;br/&gt;    Run()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;FuncJob&lt;/code&gt;：&lt;code&gt;FuncJob&lt;/code&gt; 实际就是一个 &lt;code&gt;func()&lt;/code&gt; 类型，实现了 &lt;code&gt;Run()&lt;/code&gt; 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; FuncJob func()&lt;br/&gt;func (f FuncJob) &lt;span&gt;&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;() { &lt;br/&gt;    f() &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际应用中，我们需要对 &lt;code&gt;Job&lt;/code&gt; 结构做一些扩展，于是就有了 &lt;code&gt;JobWrapper&lt;/code&gt;，使用修饰器机制加工 Job（传入一个 &lt;code&gt;Job&lt;/code&gt;，返回一个 &lt;code&gt;Job&lt;/code&gt;），有点像 gin 中间件，&lt;strong&gt;包装器可以在执行实际的 Job 前后添加一些逻辑&lt;/strong&gt;，然后使用一个 &lt;code&gt;Chain&lt;/code&gt; 将这些 &lt;code&gt;JobWrapper&lt;/code&gt; 组合到一起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如给 &lt;code&gt;Job&lt;/code&gt; 添加这样一些属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;Job&lt;/code&gt; 回调方法中捕获 &lt;code&gt;panic&lt;/code&gt; 异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;Job&lt;/code&gt; 上次运行还未结束，推迟本次执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;Job&lt;/code&gt; 上次运行还未结束，跳过本次执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;记录每个 &lt;code&gt;Job&lt;/code&gt; 的执行情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; JobWrapper func(Job) Job&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Chain struct {&lt;br/&gt;  wrappers []JobWrapper&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewChain(c ...JobWrapper) Chain {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Chain{c}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;code&gt;Chain&lt;/code&gt; 结构&lt;code&gt;Chain&lt;/code&gt; 是 &lt;code&gt;JobWrapper&lt;/code&gt; 的数组，调用 &lt;code&gt;Chain&lt;/code&gt; 对象的 &lt;code&gt;Then(j Job)&lt;/code&gt; 方法应用这些 &lt;code&gt;JobWrapper&lt;/code&gt;，返回最终的 &lt;code&gt;Job&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Chain struct {&lt;br/&gt;  wrappers []JobWrapper&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewChain(c ...JobWrapper) Chain {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Chain{c}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (c Chain) Then(j Job) Job {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := range c.wrappers {&lt;br/&gt;      // 注意：应用 JobWrapper 的顺序&lt;br/&gt;    j = c.wrappers[len(c.wrappers)-i-1](j &lt;span&gt;&quot;len(c.wrappers &quot;&lt;/span&gt;len(c.wrappers)-i-1&lt;span&gt;&quot;)-i-1&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; j&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;code&gt;Schedule&lt;/code&gt;：描述一个 job 如何循环执行的抽象，需要实现&lt;code&gt;Next&lt;/code&gt;方法，此方法返回任务下次被调度的时间&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Schedule describes a job&lt;span&gt;&#x27;s duty cycle.&lt;br/&gt;type Schedule interface {&lt;br/&gt; // Next returns the next activation time, later than the given time.&lt;br/&gt; // Next is invoked initially, and then each time the job is run.&lt;br/&gt; Next(time.Time) time.Time&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt; 的实例化结构有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ConstantDelaySchedule&lt;/code&gt;：&lt;span&gt;实现&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SpecSchedule&lt;/code&gt;：&lt;span&gt;实现&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，默认选择，提供了对 Cron 表达式的解析能力&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、&lt;code&gt;Entry&lt;/code&gt; 结构：抽象了一个 job
每当使用 &lt;code&gt;AddJob&lt;/code&gt; 注册一个定时调用策略，就会为该策略生成唯一的 &lt;code&gt;Entry&lt;/code&gt;，&lt;code&gt;Entry&lt;/code&gt; 里会存储被执行的时间、需要被调度执行的实体 &lt;code&gt;Job&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Entry struct {&lt;br/&gt;    ID EntryID          // job id，可以通过该 id 来删除 job&lt;br/&gt;    Schedule Schedule   // 用于计算 job 下次的执行时间&lt;br/&gt;    Next time.Time      // job 下次执行时间&lt;br/&gt;    Prev time.Time      // job 上次执行时间，没执行过为 0&lt;br/&gt;    WrappedJob Job      // 修饰器加工过的 job&lt;br/&gt;    Job Job             // 未经修饰的 job，可以理解为 AddFunc 的第二个参数&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、&lt;code&gt;Cron&lt;/code&gt;&lt;span&gt;结构&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;：关于 &lt;code&gt;Cron&lt;/code&gt; 结构，有一些细节，&lt;code&gt;entries&lt;/code&gt; 为何设计为一个指针 &lt;code&gt;slice&lt;/code&gt;？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Cron keeps track of any number of entries, invoking the associated func as&lt;br/&gt;// specified by the schedule. It may be started, stopped, and the entries may&lt;br/&gt;// be inspected &lt;span&gt;while&lt;/span&gt; running.&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cron struct {&lt;br/&gt;    entries   []*Entry          // 所有 Job 集合&lt;br/&gt;    chain     Chain             // 装饰器链&lt;br/&gt;    stop      chan struct{}     // 停止信号&lt;br/&gt;    add       chan *Entry       // 用于异步增加 Entry&lt;br/&gt;    remove    chan EntryID      // 用于异步删除 Entry&lt;br/&gt;    snapshot  chan chan []Entry&lt;br/&gt;    running   bool              // 是否正在运行&lt;br/&gt;    logger    Logger&lt;br/&gt;    runningMu sync.Mutex        // 运行时锁&lt;br/&gt;    location  *time.Location    // 时区相关&lt;br/&gt;    parser    Parser            // Cron 解析器&lt;br/&gt;    nextID    EntryID&lt;br/&gt;    jobWaiter sync.WaitGroup    // 并发控制，正在运行的 Job&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;entries 成员&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才说到 &lt;code&gt;entries&lt;/code&gt; 为何设计为指针 &lt;code&gt;slice&lt;/code&gt;，原因在于 cron 核心逻辑中，每次循环开始时都会对 &lt;code&gt;Cron.entries&lt;/code&gt; 进行排序，排序字段依赖于每个 &lt;code&gt;Entry&lt;/code&gt; 结构的 &lt;code&gt;Next&lt;/code&gt; 成员，排序依赖于下面的原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;按照触发时间正向排序，越先触发的越靠前&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;IsZero&lt;/code&gt; 的任务向后面排&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于可能存在相同周期的任务 Job，所以排序是不稳定的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// byTime is a wrapper &lt;span&gt;for&lt;/span&gt; sorting the entry array by time&lt;br/&gt;// (with zero time at the end).&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; byTime []*Entry&lt;br/&gt;&lt;br/&gt;func (s byTime) Len() int      { &lt;span&gt;return&lt;/span&gt; len(s) }&lt;br/&gt;func (s byTime) Swap(i, j int) { s[i], s[j] = s[j], s[i] }&lt;br/&gt;func (s byTime) Less(i, j int) bool {&lt;br/&gt; // Two zero &lt;span&gt;times&lt;/span&gt; should &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;.&lt;br/&gt; // Otherwise, zero is &lt;span&gt;&quot;greater&quot;&lt;/span&gt; than any other time.&lt;br/&gt; // (To sort it at the end of the list.)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; s[i].Next.&lt;span&gt;&lt;span&gt;IsZero&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; s[j].Next.&lt;span&gt;&lt;span&gt;IsZero&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;    // 排序的原则，s[i] 比 s[j] 先触发&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s[i].Next.Before(s[j].Next)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x03 内置 JobWrapper 介绍&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Recover：捕捉 panic，避免进程异常退出&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此 wrapper 比较好理解，在执行内层的 Job 逻辑前，添加 recover() 调用。如果 Job.Run() 执行过程中有 panic。这里的 recover() 会捕获到，输出调用堆栈&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// cron.go&lt;br/&gt;func Recover(logger Logger) JobWrapper {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; func(j Job) Job {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FuncJob(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      defer &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; r := recover(); r != nil {&lt;br/&gt;          const size = 64 &amp;lt;&amp;lt; 10&lt;br/&gt;          buf := make([]byte, size)&lt;br/&gt;          buf = buf[:runtime.Stack(buf, &lt;span&gt;false&lt;/span&gt;)]&lt;br/&gt;          err, ok := r.(error)&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;            err = fmt.Errorf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, r)&lt;br/&gt;          }&lt;br/&gt;          logger.Error(err, &lt;span&gt;&quot;panic&quot;&lt;/span&gt;, &lt;span&gt;&quot;stack&quot;&lt;/span&gt;, &lt;span&gt;&quot;...\n&quot;&lt;/span&gt;+string(buf))&lt;br/&gt;        }&lt;br/&gt;      }()&lt;br/&gt;      j.Run()&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DelayIfStillRunning&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现了已有任务运行推迟的逻辑。核心是通过一个（任务共用的）互斥锁 &lt;code&gt;sync.Mutex&lt;/code&gt;，每次执行任务前获取锁，执行结束之后释放锁。所以在上一个任务结束前，下一个任务获取锁会阻塞，从而保证的任务的串行执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// chain.go&lt;br/&gt;func DelayIfStillRunning(logger Logger) JobWrapper {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; func(j Job) Job {&lt;br/&gt;    var mu sync.Mutex&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FuncJob(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      start := time.Now()&lt;br/&gt;      // 下一个任务阻塞等待获取锁&lt;br/&gt;      mu.Lock()&lt;br/&gt;      defer mu.Unlock()&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; dur := time.Since(start); dur &amp;gt; time.Minute {&lt;br/&gt;        logger.Info(&lt;span&gt;&quot;delay&quot;&lt;/span&gt;, &lt;span&gt;&quot;duration&quot;&lt;/span&gt;, dur)&lt;br/&gt;      }&lt;br/&gt;      j.Run()&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SkipIfStillRunning&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 &lt;code&gt;DelayIfStillRunning&lt;/code&gt; 机制不一样，该方法是跳过执行，通过无缓冲 channel 机制实现。执行任务时，从通道中取值，如果成功，执行，否则跳过。执行完成之后再向通道中发送一个值，确保下一个任务能执行。初始发送一个值到通道中，保证第一个任务的执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func SkipIfStillRunning(logger Logger) JobWrapper {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; func(j Job) Job {&lt;br/&gt;    // 定义一个无缓冲 channel&lt;br/&gt;    var ch = make(chan struct{}, 1)&lt;br/&gt;    ch &amp;lt;- struct{}{}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FuncJob(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;      select {&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; v := &amp;lt;-ch:&lt;br/&gt;        j.Run()&lt;br/&gt;        ch &amp;lt;- v&lt;br/&gt;      default:&lt;br/&gt;        logger.Info(&lt;span&gt;&quot;skip&quot;&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    })&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x04 核心方法分析&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AddJob 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AddJob&lt;/code&gt; 方法通过两种方法将任务节点 entry 添加到 &lt;code&gt;Cron.entries&lt;/code&gt; 中：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化时，直接 &lt;code&gt;append&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行状态下，通过 channel 方式异步添加，避免加锁&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// AddJob adds a Job to the Cron to be run on the given schedule.&lt;br/&gt;// The spec is parsed using the time zone of this Cron instance as the default.&lt;br/&gt;// An opaque ID is returned that can be used to later remove it.&lt;br/&gt;func (c *Cron) AddJob(spec string, cmd Job) (EntryID, error) {&lt;br/&gt; schedule, err := c.parser.Parse(spec)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; 0, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c.Schedule(schedule, cmd), nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Schedule adds a Job to the Cron to be run on the given schedule.&lt;br/&gt;// The job is wrapped with the configured Chain.&lt;br/&gt;func (c *Cron) Schedule(schedule Schedule, cmd Job) EntryID {&lt;br/&gt; c.runningMu.Lock()&lt;br/&gt; defer c.runningMu.Unlock()&lt;br/&gt; c.nextID++&lt;br/&gt; entry := &amp;amp;Entry{&lt;br/&gt;  ID:         c.nextID,&lt;br/&gt;  Schedule:   schedule,&lt;br/&gt;  WrappedJob: c.chain.Then(cmd),&lt;br/&gt;  Job:        cmd,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !c.running {&lt;br/&gt;        // 直接加&lt;br/&gt;  c.entries = append(c.entries, entry)&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        // 异步&lt;br/&gt;  c.add &amp;lt;- entry&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; entry.ID&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;run 方法&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;run 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cron 的核心 &lt;code&gt;run()&lt;/code&gt; 方法的实现如下，这个是很经典的 &lt;code&gt;for-select&lt;/code&gt; 异步处理模型，避免的对 &lt;code&gt;entries&lt;/code&gt; 加锁，非常值得借鉴。其核心有如下几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个定时任务（集）的实现，内部采用排序数组，取数组首位元素的时间作为&lt;code&gt;timer&lt;/code&gt;触发时间（感觉可以优化为最小堆？）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个 &lt;code&gt;entry&lt;/code&gt; 都包含了该 &lt;code&gt;entry&lt;/code&gt; 下一次执行的绝对时间，本轮执行完成后立即计算下一轮时间，等待下次循环时排序更新&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次循环开始对 &lt;code&gt;cron.entries&lt;/code&gt; 按下次执行时间升序排序，只需要对第一个 &lt;code&gt;entry&lt;/code&gt; 启动定时器即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时器事件触发时，轮询 &lt;code&gt;cron.entries&lt;/code&gt; 里需要执行的 &lt;code&gt;entries&lt;/code&gt; 直到第一个不满足条件的，由于数组是升序，后面无需再遍历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时，第一个定时器处理结束开启下次定时器时，也只需要更新执行过的 &lt;code&gt;cron.entries&lt;/code&gt; 的 &lt;code&gt;Next&lt;/code&gt;（下次执行时间），不需要更新所有的 &lt;code&gt;cron.entries&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Cron&lt;/code&gt;内部数据结构的维护，采用&lt;code&gt;channel&lt;/code&gt;实现无锁机制，缺点是可能会有误差（ms级），不过在此项目是能够容忍的，以 &lt;code&gt;Job&lt;/code&gt;&lt;/p&gt;&lt;p&gt;异步添加为例（运行中添加&lt;code&gt;entry&lt;/code&gt;，走异步方式，有&lt;code&gt;duration&lt;/code&gt;的延迟）：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;某个 &lt;code&gt;Job&lt;/code&gt; 之间的 &lt;code&gt;delta&lt;/code&gt; 差，可能多出了 &lt;code&gt;duration&lt;/code&gt; 的延迟，可以容忍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;定时器实现里，会扫描所有当前时间之前的 &lt;code&gt;cron.entries&lt;/code&gt; 来执行，增加了容错&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func (c *Cron) &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    c.logger.Info(&lt;span&gt;&quot;start&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    // 初始化，计算每个 Job 下次的执行时间&lt;br/&gt;    now := c.now()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, entry := range c.entries {&lt;br/&gt;        entry.Next = entry.Schedule.Next(now)&lt;br/&gt;        c.logger.Info(&lt;span&gt;&quot;schedule&quot;&lt;/span&gt;, &lt;span&gt;&quot;now&quot;&lt;/span&gt;, now, &lt;span&gt;&quot;entry&quot;&lt;/span&gt;, entry.ID, &lt;span&gt;&quot;next&quot;&lt;/span&gt;, entry.Next)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    // 在 dead loop，进行任务调度&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        // 根据下一次的执行时间，对所有 Job 排序&lt;br/&gt;        sort.Sort(byTime(c.entries))&lt;br/&gt;&lt;br/&gt;        // 计时器，用于没有任务可调度时的阻塞操作&lt;br/&gt;        var timer *time.Timer&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; len(c.entries) == 0 || c.entries[0].Next.&lt;span&gt;&lt;span&gt;IsZero&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            // 无任务可调度，设置计时器到一个很大的值，把下面的 &lt;span&gt;for&lt;/span&gt; 阻塞住&lt;br/&gt;            timer = time.NewTimer(100000 * time.Hour)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            // 有任务可调度了，计时器根据第一个可调度任务的下次执行时间设置&lt;br/&gt;            // 排过序，所以第一个肯定是最先被执行的&lt;br/&gt;            timer = time.NewTimer(c.entries[0].Next.Sub(now))&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;            select {&lt;br/&gt;            // 有 Job 到了执行时间&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; now = &amp;lt;-timer.C:&lt;br/&gt;                now = now.In(c.location)&lt;br/&gt;                c.logger.Info(&lt;span&gt;&quot;wake&quot;&lt;/span&gt;, &lt;span&gt;&quot;now&quot;&lt;/span&gt;, now)&lt;br/&gt;                // 检查所有 Job，执行到时的任务&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; _, e := range c.entries {&lt;br/&gt;                    // 可能存在相同时间出发的任务&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; e.Next.After(now) || e.Next.&lt;span&gt;&lt;span&gt;IsZero&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                        // 后面都不需要遍历了！&lt;br/&gt;                        &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    // 执行 Job 的 func()&lt;br/&gt;                    c.startJob(e.WrappedJob)&lt;br/&gt;&lt;br/&gt;                    // 保存上次执行时间&lt;br/&gt;                    e.Prev = e.Next&lt;br/&gt;                    // 设置 Job 下次的执行时间&lt;br/&gt;                    e.Next = e.Schedule.Next(now)&lt;br/&gt;                    c.logger.Info(&lt;span&gt;&quot;run&quot;&lt;/span&gt;, &lt;span&gt;&quot;now&quot;&lt;/span&gt;, now, &lt;span&gt;&quot;entry&quot;&lt;/span&gt;, e.ID, &lt;span&gt;&quot;next&quot;&lt;/span&gt;, e.Next)&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;            // 添加新 Job&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; newEntry := &amp;lt;-c.add:&lt;br/&gt;                timer.Stop()        // 必须注意，这里停止定时器，避免内存泄漏！&lt;br/&gt;                now = c.now()&lt;br/&gt;                newEntry.Next = newEntry.Schedule.Next(now)&lt;br/&gt;                c.entries = append(c.entries, newEntry)&lt;br/&gt;                c.logger.Info(&lt;span&gt;&quot;added&quot;&lt;/span&gt;, &lt;span&gt;&quot;now&quot;&lt;/span&gt;, now, &lt;span&gt;&quot;entry&quot;&lt;/span&gt;, newEntry.ID, &lt;span&gt;&quot;next&quot;&lt;/span&gt;, newEntry.Next)&lt;br/&gt;&lt;br/&gt;            // 获取所有 Job 的快照&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; replyChan := &amp;lt;-c.snapshot:&lt;br/&gt;                replyChan &amp;lt;- c.entrySnapshot()&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            // 停止调度&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &amp;lt;-c.stop:&lt;br/&gt;                timer.Stop()&lt;br/&gt;                c.logger.Info(&lt;span&gt;&quot;stop&quot;&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            // 根据 entryId 删除一个 Job&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; id := &amp;lt;-c.remove:&lt;br/&gt;                timer.Stop()&lt;br/&gt;                now = c.now()&lt;br/&gt;                c.removeEntry(id)&lt;br/&gt;                c.logger.Info(&lt;span&gt;&quot;removed&quot;&lt;/span&gt;, &lt;span&gt;&quot;entry&quot;&lt;/span&gt;, id)&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的代码的核心流程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3622262773722629&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/otNtibX96l98og8X4NoK6iaMFFpttiaib0bIl4VPFCOd9QhGibllGDaYVIibBBYibsnqjZiauIH0PTZTxfRSfdibKBas7aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;image&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x05 小结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文分析了基于 Golang 实现的单机定时任务库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;0x06 参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;golang cron v3 定时任务&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;v3-repo&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Go 每日一库之 cron&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;GO 编程模式：修饰器&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;cron: &lt;em&gt;https://github.com/robfig/cron/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;此文: &lt;em&gt;https://segmentfault.com/a/1190000023029219&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;实现: &lt;em&gt;https://github.com/robfig/cron/blob/v3/constantdelay.go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;实现: &lt;em&gt;https://pandaychen.github.io/2021/10/05/A-GOLANG-CRONTAB-V3-BASIC-INTRO/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;结构: &lt;em&gt;https://github.com/robfig/cron/blob/v3/cron.go#L13&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;golang cron v3 定时任务: &lt;em&gt;https://blog.cugxuan.cn/2020/06/04/Go/golang-cron-v3/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;v3-repo: &lt;em&gt;https://github.com/robfig/cron/tree/v3&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Go 每日一库之 cron: &lt;em&gt;https://segmentfault.com/a/1190000023029219&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;GO 编程模式：修饰器: &lt;em&gt;https://coolshell.cn/articles/17929.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e743f64cab55da04a542d17864115ea5</guid>
<title>MySQL六十六问，两万字+五十图详解！有点六！</title>
<link>https://toutiao.io/k/5cpvhga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小夕。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一篇都是上万字，几十图，基本上涵盖了面试的主要知识点，这期MySQL结束之后，这个系列可能会暂时告一段落，作为面渣逆袭系列第一阶段的收官之作，大家多多&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;哦！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NjM5NTc5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/NP2dQRIKOrIGH3JlT3ZfickrsCetmiaoSvG9EpFE9gUR2vsWEDiaqQyGFwMApu48aK1G4l7hvtaucB36hHib2gImuw/0?wx_fmt=png&quot; data-nickname=&quot;小夕学算法&quot; data-alias=&quot;&quot; data-signature=&quot;小夕用动画、漫和五种编程语言（Java、C++、Python、JS、PHP）为大家讲解算法，并分享大厂经历和面试真题。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5143769968051118&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAA9scDm1Vb8eOhakhez2rD1EPH1UUkoHFkw9zRp86VnN98ryqowFmxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;figcaption&gt;MySQ Logo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为SQL Boy，基础部分不会有人不会吧？面试也不怎么问，基础掌握不错的小伙伴可以&lt;strong&gt;跳过&lt;/strong&gt;这一部分。当然，可能会现场写一些SQL语句，SQ语句可以通过牛客、LeetCode、LintCode之类的网站来练习。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 什么是内连接、外连接、交叉连接、笛卡尔积呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内连接（inner join）：取得两张表中满足存在连接匹配关系的记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外连接（outer join）：不只取得两张表中满足存在连接匹配关系的记录，还包括某张表（或两张表）中不满足匹配关系的记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;交叉连接（cross join）：显示两张表所有记录一一对应，没有匹配关系进行筛选，它是笛卡尔积在SQL中的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;笛卡尔积：是数学中的一个概念，例如集合A={a,b}，集合B={1,2,3}，那么A✖️B={&amp;lt;a,o&amp;gt;,&amp;lt;a,1&amp;gt;,&amp;lt;a,2&amp;gt;,&amp;lt;b,0&amp;gt;,&amp;lt;b,1&amp;gt;,&amp;lt;b,2&amp;gt;,}。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 那MySQL 的内连接、左连接、右连接有有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的连接主要分为内连接和外连接，外连接常用的有左连接、右连接。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7867494824016563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAJdwv5WrKicicnfjibkTQGVkEzVbJOkO79tXUoFSOYIc3HvL3AttOQKajg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;figcaption&gt;MySQL-joins-来源菜鸟教程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.说一下数据库的三大范式？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.608955223880597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAFzgicQAGibibNk0kHXfibCic50G7ibwPwmcD6GNGRICNyVNI2PKyTl08Pv0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;数据库三范式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一范式：数据表中的每一列（每个字段）都不可以再拆分。例如用户表，用户地址还可以拆分成国家、省份、市，这样才是符合第一范式的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。例如订单表里，存储了商品信息（商品价格、商品类型），那就需要把商品ID和订单ID作为联合主键，才满足第二范式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三范式：在满足第二范式的基础上，表中的非主键只依赖于主键，而不依赖于其他非主键。例如订单表，就不能存储用户信息（姓名、地址）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAU3uBNicc5JpkkDpgmAahDAjdUkgwMHwPFIbtVXowJxAfMXdoPJnK2ag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;figcaption&gt;你设计遵守范式吗？&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三大范式的作用是为了控制数据库的冗余，是对空间的节省，实际上，一般互联网公司的设计都是反范式的，通过冗余一些数据，避免跨表跨库，利用空间换时间，提高性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.varchar与char的区别？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27370689655172414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAxo5S9LpPQicRAvBgqbGVggucib8VFkvNBNoj9XNFfGHAqa3yRUibGftlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;figcaption&gt;varchar&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;char&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;char表示定长字符串，长度是固定的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果插入数据的长度小于char的固定长度时，则用空格填充；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于char来说，最多能存放的字符个数为255，和编码无关&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;varchar&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;varchar表示可变长字符串，长度是可变的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;插入的数据是多长，就按照多长来存储；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于varchar来说，最多能存放的字符个数为65532&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常的设计，对于长度相对固定的字符串，可以使用char，对于长度不确定的，使用varchar更合适一些。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.blob和text有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;blob用于存储二进制数据，而text用于存储大字符串。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;blob没有字符集，text有一个字符集，并且根据字符集的校对规则对值进行排序和比较&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.DATETIME和TIMESTAMP的异同？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相同点&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;两个数据类型存储时间的表现格式一致。均为 &lt;code&gt;YYYY-MM-DD HH:MM:SS&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个数据类型都包含「日期」和「时间」部分。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两个数据类型都可以存储微秒的小数秒（秒后6位小数秒）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;区别&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7874564459930313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAP72A3ia5LEvv8IibSQEibmzDasjkBMKnBHO2bSLf1u8ex8gxIntBTMvSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;figcaption&gt;DATETIME和TIMESTAMP的区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;日期范围&lt;/strong&gt;：DATETIME 的日期范围是 &lt;code&gt;1000-01-01 00:00:00.000000&lt;/code&gt; 到 &lt;code&gt;9999-12-31 23:59:59.999999&lt;/code&gt;；TIMESTAMP 的时间范围是&lt;code&gt;1970-01-01 00:00:01.000000&lt;/code&gt; UTC&lt;code&gt; 到 ``2038-01-09 03:14:07.999999&lt;/code&gt; UTC&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;存储空间&lt;/strong&gt;：DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;时区相关&lt;/strong&gt;：DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;默认值&lt;/strong&gt;：DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间(CURRENT_TIMESTAMP)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.MySQL中 in 和 exists 的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。我们可能认为exists比in语句的效率要高，这种说法其实是不准确的，要区分情景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果查询的两个表大小相当，那么用in和exists差别不大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.MySQL里记录货币用什么字段类型比较好？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;货币在数据库中MySQL常用Decimal和Numric类型表示，这两种类型被MySQL实现为同样的类型。他们被用于保存与货币有关的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如salary DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以不使用float或者double的原因：因为float和double是以二进制存储的，所以有一定的误差。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.MySQL怎么存储emoji😊?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL可以直接使用字符串存储emoji。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是需要注意的，utf8 编码是不行的，MySQL中的utf8是阉割版的 utf8，它最多只用 3 个字节存储字符，所以存储不了表情。那该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要使用utf8mb4编码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; blogs &lt;span&gt;modify&lt;/span&gt; &lt;span&gt;content&lt;/span&gt; &lt;span&gt;text&lt;/span&gt; &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.drop、delete与truncate的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三者都表示删除，但是三者有一些差别：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;delete&lt;/th&gt;&lt;th&gt;truncate&lt;/th&gt;&lt;th&gt;drop&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;类型&lt;/td&gt;&lt;td&gt;属于DML&lt;/td&gt;&lt;td&gt;属于DDL&lt;/td&gt;&lt;td&gt;属于DDL&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;回滚&lt;/td&gt;&lt;td&gt;可回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;td&gt;不可回滚&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除内容&lt;/td&gt;&lt;td&gt;表结构还在，删除表的全部或者一部分数据行&lt;/td&gt;&lt;td&gt;表结构还在，删除表中的所有数据&lt;/td&gt;&lt;td&gt;从数据库中删除表，所有数据行，索引和权限也会被删除&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;删除速度&lt;/td&gt;&lt;td&gt;删除速度慢，需要逐行删除&lt;/td&gt;&lt;td&gt;删除速度快&lt;/td&gt;&lt;td&gt;删除速度最快&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.UNION与UNION ALL的区别？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果使用UNION ALL，不会合并重复的记录行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;效率 UNION 高于 UNION ALL&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.count(1)、count(*) 与 count(列名) 的区别？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20081967213114754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAxzhPC4RBHqwna18k7MMp8fMXeS6iabjugq8Go6Gc4jqibiaqvUeYBJkCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;figcaption&gt;三种计数方式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行效果&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;执行速度&lt;/strong&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;列名为主键，count(列名)会比count(1)快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;列名不为主键，count(1)会比count(列名)快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果表多个列并且没有主键，则 count（1） 的执行效率优于 count（*）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有主键，则 select count（主键）的执行效率是最优的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果表只有一个字段，则 select count（*）最优。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.一条SQL查询语句的执行顺序？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16828929068150209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAJia5p5MjGibHTuIqF5N5exiaOwHFGYsrcKFrE0NoDaLrU4ShT6vRYwvUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;figcaption&gt;查询语句执行顺序&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;FROM&lt;/strong&gt;：对FROM子句中的左表&amp;lt;left_table&amp;gt;和右表&amp;lt;right_table&amp;gt;执行笛卡儿积（Cartesianproduct），产生虚拟表VT1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;ON&lt;/strong&gt;：对虚拟表VT1应用ON筛选，只有那些符合&amp;lt;join_condition&amp;gt;的行才被插入虚拟表VT2中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;JOIN&lt;/strong&gt;：如果指定了OUTER JOIN（如LEFT OUTER JOIN、RIGHT OUTER JOIN），那么保留表中未匹配的行作为外部行添加到虚拟表VT2中，产生虚拟表VT3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1）～步骤3），直到处理完所有的表为止&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;WHERE&lt;/strong&gt;：对虚拟表VT3应用WHERE过滤条件，只有符合&amp;lt;where_condition&amp;gt;的记录才被插入虚拟表VT4中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;GROUP BY&lt;/strong&gt;：根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;CUBE|ROLLUP&lt;/strong&gt;：对表VT5进行CUBE或ROLLUP操作，产生表VT6&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;HAVING&lt;/strong&gt;：对虚拟表VT6应用HAVING过滤器，只有符合&amp;lt;having_condition&amp;gt;的记录才被插入虚拟表VT7中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;SELECT&lt;/strong&gt;：第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt;：去除重复数据，产生虚拟表VT9&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt;：将虚拟表VT9中的记录按照&amp;lt;order_by_list&amp;gt;进行排序操作，产生虚拟表VT10。11）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;LIMIT&lt;/strong&gt;：取出指定行的记录，产生虚拟表VT11，并返回给查询用户&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库架构&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.说说 MySQL 的基础架构?&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9368421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlApPFbnzibZp66puhMnSOCic8J15Ay5kTFIhk6jD4dDmzicxdJqHWhJicrTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;570&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL逻辑架构图主要分三层：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端：最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server层：大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储引擎层：第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。Server层通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.一条 SQL 查询语句在 MySQL 中如何执行的？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先检查该语句&lt;code&gt;是否有权限&lt;/code&gt;，如果没有权限，直接返回错误信息，如果有权限会先查询缓存 (MySQL8.0 版本以前)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有缓存，分析器进行&lt;code&gt;语法分析&lt;/code&gt;，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误，比如关键词是否正确等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语法解析之后，MySQL的服务器会对查询的语句进行优化，确定执行的方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完成查询优化后，按照生成的执行计划&lt;code&gt;调用数据库引擎接口&lt;/code&gt;，返回执行结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储引擎&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.MySQL有哪些常见存储引擎？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45714285714285713&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAASfX19otcwKw4iarJjaZI5woAYdrftSvic8SVCsrAZFrsPZ4UxSXIQwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;主要存储引擎&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要存储引擎以及功能如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能&lt;/th&gt;&lt;th&gt;MylSAM&lt;/th&gt;&lt;th&gt;MEMORY&lt;/th&gt;&lt;th&gt;InnoDB&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存储限制&lt;/td&gt;&lt;td&gt;256TB&lt;/td&gt;&lt;td&gt;RAM&lt;/td&gt;&lt;td&gt;64TB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持事务&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持全文索引&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持树索引&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持哈希索引&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持数据缓存&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;N/A&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;支持外键&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;No&lt;/td&gt;&lt;td&gt;Yes&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL5.5之前，默认存储引擎是MylSAM，5.5之后变成了InnoDB。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB支持的哈希索引是自适应的，InnoDB会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MySQL 5.6开始InnoDB支持全文索引。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.那存储引擎应该怎么选择？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致上可以这么选择：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大多数情况下，使用默认的InnoDB就够了。如果要提供提交、回滚和恢复的事务安全（ACID 兼容）能力，并要求实现并发控制，InnoDB 就是比较靠前的选择了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果数据表主要用来插入和查询记录，则 MyISAM 引擎提供较高的处理效率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存的 MEMORY 引擎中，MySQL 中使用该引擎作为临时表，存放查询的中间结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用哪一种引擎可以根据需要灵活选择，因为存储引擎是基于表的，所以一个数据库中多个表可以使用不同的引擎以满足各种性能和实际需求。使用合适的存储引擎将会提高整个数据库的性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.InnoDB和MylSAM主要有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:MySQL8.0都开始慢慢流行了，如果不是面试，MylSAM其实可以不用怎么了解。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5948103792415169&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAVBRAvPgSJRUaaibEJ8ZSzVP5AfonhA8iaF0HUgATPYpflbWvGSXeFIBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;figcaption&gt;InnoDB和MylSAM主要有什么区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.  存储结构&lt;/strong&gt;：每个MyISAM在磁盘上存储成三个文件；InnoDB所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 事务支持&lt;/strong&gt;：MyISAM不提供事务支持；InnoDB提供事务支持事务，具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3  最小锁粒度&lt;/strong&gt;：MyISAM只支持表级锁，更新时会锁住整张表，导致其它查询和更新都会被阻塞InnoDB支持行级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4. 索引类型&lt;/strong&gt;：MyISAM的索引为聚簇索引，数据结构是B树；InnoDB的索引是非聚簇索引，数据结构是B+树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.  主键必需&lt;/strong&gt;：MyISAM允许没有任何索引和主键的表存在；InnoDB如果没有设定主键或者非空唯一索引，**就会自动生成一个6字节的主键(用户不可见)**，数据是主索引的一部分，附加索引保存的是主索引的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6. 表的具体行数&lt;/strong&gt;：MyISAM保存了表的总行数，如果select count(*) from table;会直接取出出该值;
InnoDB没有保存表的总行数，如果使用select count(*) from table；就会遍历整个表;但是在加了wehre条件后，MyISAM和InnoDB处理的方式都一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7.  外键支持&lt;/strong&gt;：MyISAM不支持外键；InnoDB支持外键。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;日志&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.MySQL日志文件有哪些？分别介绍下作用？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5049833887043189&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlArgg6g5QFdXa31nKYtDX3B8vsN2icvsibDwzGPb2O2ia3ygQ6ZFN5NrO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;figcaption&gt;MySQL主要日志&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL日志文件有很多，包括 ：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;错误日志&lt;/strong&gt;（error log）：错误日志文件对MySQL的启动、运行、关闭过程进行了记录，能帮助定位MySQL问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;（slow query log）：慢查询日志是用来记录执行时间超过 long_query_time 这个变量定义的时长的查询语句。通过慢查询日志，可以查找出哪些查询语句的执行效率很低，以便进行优化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一般查询日志&lt;/strong&gt;（general log）：一般查询日志记录了所有对MySQL数据库请求的信息，无论请求是否正确执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;二进制日志&lt;/strong&gt;（bin log）：关于二进制日志，它记录了数据库所有执行的DDL和DML语句（除了数据查询语句select、show等），以事件形式记录并保存在二进制文件中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有两个InnoDB存储引擎特有的日志文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重做日志&lt;/strong&gt;（redo log）：重做日志至关重要，因为它们记录了对于InnoDB存储引擎的事务日志。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;回滚日志&lt;/strong&gt;（undo log）：回滚日志同样也是InnoDB引擎提供的日志，顾名思义，回滚日志的作用就是对数据进行回滚。当事务对数据库进行修改，InnoDB引擎不仅会记录redo log，还会生成对应的undo log日志；如果事务执行失败或调用了rollback，导致事务需要回滚，就可以利用undo log中的信息将数据回滚到修改之前的样子。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.binlog和redo log有什么区别？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;bin log会记录所有与数据库有关的日志记录，包括InnoDB、MyISAM等存储引擎的日志，而redo log只记InnoDB存储引擎的日志。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记录的内容不同，bin log记录的是关于一个事务的具体操作内容，即该日志是逻辑日志。而redo log记录的是关于每个页（Page）的更改的物理情况。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;写入的时间不同，bin log仅在事务提交前进行提交，也就是只写磁盘一次。而在事务进行的过程中，却不断有redo ertry被写入redo log中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;写入的方式也不相同，redo log是循环写入和擦除，bin log是追加写入，不会覆盖已经写的文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.一条更新语句怎么执行的了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新语句的执行是Server层和引擎层配合完成，数据除了要写入表中，还要记录相应的日志。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.532051282051282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA9ibweibpG51PemKibYQotVX30ARkMXABZHPBiaICGKPmSxeg0oOZj1Tr5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;figcaption&gt;update执行&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行器先找引擎获取ID=2这一行。ID是主键，存储引擎检索数据，找到这一行。如果ID=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行器拿到引擎给的行数据，把这个值加上1，比如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log里面，此时redo log处于prepare状态。然后告知执行器执行完成了，随时可以提交事务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行器生成这个操作的binlog，并把binlog写入磁盘。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交（commit）状态，更新完成。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，MySQL在执行更新语句的时候，在服务层进行语句的解析和执行，在引擎层进行数据的提取和存储；同时在服务层对binlog进行写入，在InnoDB内进行redo log的写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，在对redo log写入时有两个阶段的提交，一是binlog写入之前&lt;code&gt;prepare&lt;/code&gt;状态的写入，二是binlog写入之后&lt;code&gt;commit&lt;/code&gt;状态的写入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.那为什么要两阶段提交呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要两阶段提交呢？直接提交不行吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以假设不采用两阶段提交的方式，而是采用“单阶段”进行提交，即要么先写入redo log，后写入binlog；要么先写入binlog，后写入redo  log。这两种方式的提交都会导致原先数据库的状态和被恢复后的数据库的状态不一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先写入redo log，后写入binlog：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写完redo log之后，数据此时具有&lt;code&gt;crash-safe&lt;/code&gt;能力，因此系统崩溃，数据会恢复成事务开始之前的状态。但是，若在redo log写完时候，binlog写入之前，系统发生了宕机。此时binlog没有对上面的更新语句进行保存，导致当使用binlog进行数据库的备份或者恢复时，就少了上述的更新语句。从而使得&lt;code&gt;id=2&lt;/code&gt;这一行的数据没有被更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8282352941176471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAOBXe6HLIHogdRaULSPiamaY86qRD2IADlYS3QgJd2ygRovdzhrQAxlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;figcaption&gt;先写redo log，后写bin log的问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先写入binlog，后写入redo log：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写完binlog之后，所有的语句都被保存，所以通过binlog复制或恢复出来的数据库中id=2这一行的数据会被更新为a=1。但是如果在redo log写入之前，系统崩溃，那么redo log中记录的这个事务会无效，导致实际数据库中&lt;code&gt;id=2&lt;/code&gt;这一行的数据并没有更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8433734939759037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAAtSHeCRYryRibyvzcXztBRWSYqxjcuvTWcuxXVBGL6MtjSsL1RRUf6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;figcaption&gt;先写bin log，后写redo log的问题&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.redo log怎么刷入磁盘的知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redo log的写入不是直接落到磁盘，而是在内存中设置了一片称之为&lt;code&gt;redo log buffer&lt;/code&gt;的连续内存空间，也就是&lt;code&gt;redo 日志缓冲区&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44880174291938996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAYnM4iakEw5bbxkE8hra02YHR4YoDfkl9kwRgXakhkpb1TvxNGUmrcRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;&lt;figcaption&gt;redo log缓冲&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么时候会刷入磁盘？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在如下的一些情况中，log buffer的数据会刷入磁盘：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;log buffer 的大小是有限的，如果不停的往这个有限大小的 log buffer 里塞入日志，很快它就会被填满。如果当前写入 log buffer 的redo 日志量已经占满了 log buffer 总容量的大约&lt;strong&gt;一半&lt;/strong&gt;左右，就需要把这些日志刷新到磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在事务提交时，为了保证持久性，会把log buffer中的日志全部刷到磁盘。注意，这时候，除了本事务的，可能还会刷入其它事务的日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个后台线程，大约每秒都会刷新一次&lt;code&gt;log buffer&lt;/code&gt;中的&lt;code&gt;redo log&lt;/code&gt;到磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重做日志缓存、重做日志文件都是以&lt;strong&gt;块（block）&lt;/strong&gt;的方式进行保存的，称之为&lt;strong&gt;重做日志块（redo log block）&lt;/strong&gt;,块的大小是固定的512字节。我们的redo log它是固定大小的，可以看作是一个逻辑上的 &lt;strong&gt;log group&lt;/strong&gt;，由一定数量的&lt;strong&gt;log block&lt;/strong&gt; 组成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.255700325732899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAxA66UJ4dnVWCBFXbIkVkv2p3nIVsXeUGX8COBtOB3BSibtf2dhPKA1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;figcaption&gt;redo log分块和写入&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的写入方式是从头到尾开始写，写到末尾又回到开头循环写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有两个标记位置：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;write pos&lt;/code&gt;是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。&lt;code&gt;checkpoint&lt;/code&gt;是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到磁盘。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4811594202898551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAgzrpDZGmrZ6bYrHia3UGkXXyfwp54gKC2eWeAyzichaFoojmeexWG5xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;figcaption&gt;write pos和checkpoint&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;write_pos&lt;/code&gt;追上&lt;code&gt;checkpoint&lt;/code&gt;时，表示redo log日志已经写满。这时候就不能接着往里写数据了，需要执行&lt;code&gt;checkpoint&lt;/code&gt;规则腾出可写空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的&lt;strong&gt;checkpoint规则&lt;/strong&gt;，就是checkpoint触发后，将buffer中日志页都刷到磁盘。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SQL 优化&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.慢SQL如何定位呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢SQL的监控主要通过两个途径：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4935064935064935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA7vZCX9AXG5lOO6XEPPl1VY4h92DVwEZzexmnm5kSjc4yUHdMHh0t7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;figcaption&gt;发现慢SQL&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;慢查询日志&lt;/strong&gt;：开启MySQL的慢查询日志，再通过一些工具比如mysqldumpslow去分析对应的慢查询日志，当然现在一般的云厂商都提供了可视化的平台。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务监控&lt;/strong&gt;：可以在业务的基建中加入对慢SQL的监控，常见的方案有字节码插桩、连接池扩展、ORM框架过程，对服务运行中的慢SQL进行监控和告警。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.有哪些方式优化慢SQL？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢SQL的优化，主要从两个方面考虑，SQL语句本身的优化，以及数据库设计的优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0144356955380578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA0JUMcI0E4lic2YGjiaVB7M77a3UMnepr3IB9E0gR0IGclqEtNcY7Gchg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;figcaption&gt;SQL优化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免不必要的列&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是老生常谈，但还是经常会出的情况，SQL查询的时候，应该只查询需要的列，而不要包含额外的列，像&lt;code&gt;slect *&lt;/code&gt; 这种写法应该尽量避免。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分页优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据量比较大，分页比较深的情况下，需要考虑分页的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; = &lt;span&gt;9&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;190289&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;延迟关联&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.* &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; a, &lt;br/&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; = &lt;span&gt;9&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;190289&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt; ) b&lt;br/&gt; &lt;span&gt;where&lt;/span&gt; a.id = b.id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;书签方式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;书签方式就是找到limit第一个参数对应的主键值，根据这个主键值再去过滤并limit&lt;/p&gt;&lt;p&gt;例如：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt;&lt;br/&gt;  (&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;level&lt;/span&gt; = &lt;span&gt;9&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;190&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;索引优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合理地设计和使用索引，是优化慢SQL的利器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;利用覆盖索引&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB使用非主键索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如对于如下查询：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; city=&lt;span&gt;&#x27;上海&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_city_name (city, &lt;span&gt;name&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;低版本避免使用or查询&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，高版本引入了索引合并，解决了这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;避免使用 != 或者 &amp;lt;&amp;gt; 操作符&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL中，不等于操作符会导致查询引擎放弃查询索引，引起全表扫描，即使比较的字段上有索引&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，把&lt;code&gt;column&amp;lt;&amp;gt;’aaa’，改成column&amp;gt;’aaa’ or column&amp;lt;’aaa’&lt;/code&gt;，就可以使用索引了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适当使用前缀索引&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适当地使用前缀所云，可以降低索引的空间占用，提高索引的查询效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，邮箱的后缀都是固定的“&lt;code&gt;@xxx.com&lt;/code&gt;”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;alter table &lt;span&gt;test&lt;/span&gt; add index index2(email(6));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;避免列上函数运算&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要避免在列字段上进行算术运算或其他表达式运算，否则可能会导致存储引擎无法正确使用索引，从而影响了查询的效率&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt; = &lt;span&gt;50&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;month&lt;/span&gt;(updateTime) = &lt;span&gt;7&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正确使用联合索引&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用联合索引的时候，注意最左匹配原则。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JOIN优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化子查询&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小表驱动大表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关联查询的时候要拿小表去驱动大表，因为关联的时候，MySQL内部会遍历驱动表，再去连接被驱动表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如left join，左表就是驱动表，A表小于B表，建立连接的次数就少，查询速度就被加快了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; A &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; B ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;适当增加冗余字段&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;避免使用JOIN关联太多的表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《阿里巴巴Java开发手册》规定不要join超过三张表，第一join太多降低查询的速度，第二join的buffer会占用更多的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不可避免要join多张表，可以考虑使用数据异构的方式异构到ES中查询。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排序优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;利用索引扫描做排序&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;--建立索引（date,staff_id,customer_id）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; staff_id, customer_id &lt;span&gt;from&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;date&lt;/span&gt; = &lt;span&gt;&#x27;2010-01-01&#x27;&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; staff_id,customer_id;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;UNION优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;条件下推&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.怎么看执行计划（explain），如何理解其中各个字段的含义？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain是sql优化的利器，除了优化慢sql，平时的sql编写，也应该先explain，查看一下执行计划，看看是否还有优化的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 select 语句之前增加&lt;code&gt;explain &lt;/code&gt;关键字，就会返回执行计划的信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13425925925925927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA4Eor5hoaFOaPgm3XdLpR4LULvYrUH907CrEyKxqc2rf4pX0Ng6SOgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;explain&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3884297520661157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAIlXgULdhKTxs2HicvKWCmmSwSfGjofeuf7xiaL3tTultalrJSBXZdO2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;968&quot;/&gt;&lt;figcaption&gt;explain&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;id&lt;/strong&gt; 列：MySQL会为每个select语句分配一个唯一的id值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;select_type&lt;/strong&gt; 列，查询的类型，根据关联、union、子查询等等分类，常见的查询类型有SIMPLE、PRIMARY。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;table&lt;/strong&gt; 列：表示 explain 的一行正在访问哪个表。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt; 列：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。&lt;/p&gt;&lt;p&gt;性能从最优到最差分别为：system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; fulltext &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; unique_subquery &amp;gt; index_subquery &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;system&lt;/p&gt;&lt;p&gt;&lt;code&gt;system&lt;/code&gt;：当表仅有一行记录时(系统表)，数据量很少，往往不需要进行磁盘IO，速度非常快&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;const&lt;/p&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt;：表示查询时命中 &lt;code&gt;primary key&lt;/code&gt; 主键或者 &lt;code&gt;unique&lt;/code&gt; 唯一索引，或者被连接的部分是一个常量(&lt;code&gt;const&lt;/code&gt;)值。这类扫描效率极高，返回数据量少，速度非常快。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;eq_ref&lt;/p&gt;&lt;p&gt;&lt;code&gt;eq_ref&lt;/code&gt;：查询时命中主键&lt;code&gt;primary key&lt;/code&gt; 或者 &lt;code&gt;unique key&lt;/code&gt;索引， &lt;code&gt;type&lt;/code&gt; 就是 &lt;code&gt;eq_ref&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ref_or_null&lt;/p&gt;&lt;p&gt;&lt;code&gt;ref_or_null&lt;/code&gt;：这种连接类型类似于 ref，区别在于 &lt;code&gt;MySQL&lt;/code&gt;会额外搜索包含&lt;code&gt;NULL&lt;/code&gt;值的行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;index_merge&lt;/p&gt;&lt;p&gt;&lt;code&gt;index_merge&lt;/code&gt;：使用了索引合并优化方法，查询使用了两个以上的索引。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;unique_subquery&lt;/p&gt;&lt;p&gt;&lt;code&gt;unique_subquery&lt;/code&gt;：替换下面的 &lt;code&gt;IN&lt;/code&gt;子查询，子查询返回不重复的集合。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;index_subquery&lt;/p&gt;&lt;p&gt;&lt;code&gt;index_subquery&lt;/code&gt;：区别于&lt;code&gt;unique_subquery&lt;/code&gt;，用于非唯一索引，可以返回重复值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;range&lt;/p&gt;&lt;p&gt;&lt;code&gt;range&lt;/code&gt;：使用索引选择行，仅检索给定范围内的行。简单点说就是针对一个有索引的字段，给定范围检索数据。在&lt;code&gt;where&lt;/code&gt;语句中使用 &lt;code&gt;bettween...and&lt;/code&gt;、&lt;code&gt;&amp;lt;&lt;/code&gt;、&lt;code&gt;&amp;gt;&lt;/code&gt;、&lt;code&gt;&amp;lt;=&lt;/code&gt;、&lt;code&gt;in&lt;/code&gt; 等条件查询 &lt;code&gt;type&lt;/code&gt; 都是 &lt;code&gt;range&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;index&lt;/p&gt;&lt;p&gt;&lt;code&gt;index&lt;/code&gt;：&lt;code&gt;Index&lt;/code&gt; 与&lt;code&gt;ALL&lt;/code&gt; 其实都是读全表，区别在于&lt;code&gt;index&lt;/code&gt;是遍历索引树读取，而&lt;code&gt;ALL&lt;/code&gt;是从硬盘中读取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ALL&lt;/p&gt;&lt;p&gt;就不用多说了，全表扫描。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;possible_keys&lt;/strong&gt; 列：显示查询可能使用哪些索引来查找，使用索引优化sql的时候比较重要。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;key&lt;/strong&gt; 列：这一列显示 mysql 实际采用哪个索引来优化对该表的访问，判断索引是否失效的时候常用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;key_len&lt;/strong&gt; 列：显示了 MySQL使用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt; 列：ref 列展示的就是与索引列作等值匹配的值，常见的有：const（常量），func，NULL，字段名。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt; 列：这也是一个重要的字段，MySQL查询优化器根据统计信息，估算SQL要查到结果集需要扫描读取的数据行数，这个值非常直观显示SQL的效率好坏，原则上rows越少越好。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt; 列：显示不适合在其它列的额外信息，虽然叫额外，但是也有一些重要的信息：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Using index：表示MySQL将使用覆盖索引，以避免回表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Using where：表示会在存储引擎检索之后再进行过滤&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Using temporary ：表示对查询结果排序时会使用一个临时表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引可以说是MySQL面试中的重中之重，一定要彻底拿下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.能简单说一下索引的分类吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从三个不同维度对索引分类：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9342327150084317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAet8wSFdic7DwJkiaWdL8SztOdnLFsGB8QqgShqzWpH0OerbkCgtrwQww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;593&quot;/&gt;&lt;figcaption&gt;索引分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如从基本使用使用的角度来讲：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主键索引: InnoDB主键是默认的索引，数据列不允许重复，不允许为NULL，一个表只能有一个主键。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.为什么使用索引会加快查询？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的查询方法，是按照表的顺序遍历的，不论查询几条数据，MySQL需要将表的数据从头到尾遍历一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们添加完索引之后，MySQL一般通过BTREE算法生成一个索引文件，在查询数据库时，找到索引文件进行遍历，在比较小的索引数据里查找，然后映射到对应的数据，能大幅提升查找的效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和我们通过书的目录，去查找对应的内容，一样的道理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6766304347826086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAZe90adjlbObo3PV99ibPxFoe3sujzRdficQMTDvrgSysMPSr5KfuR2bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;368&quot;/&gt;&lt;figcaption&gt;索引加快查询远离&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.创建索引有哪些注意点？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引虽然是sql性能优化的利器，但是索引的维护也是需要成本的，所以创建索引，也要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;索引应该建在查询应用频繁的字段&lt;/p&gt;&lt;p&gt;在用于 where 判断、 order 排序和 join 的(on)字段上创建索引。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;索引的个数应该适量&lt;/p&gt;&lt;p&gt;索引需要占用空间；更新时候也需要维护。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;区分度低的字段，例如性别，不要建索引。&lt;/p&gt;&lt;p&gt;离散度太低的字段，扫描的行数降低的有限。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;频繁更新的值，不要作为主键或者索引&lt;/p&gt;&lt;p&gt;维护索引文件需要成本；还会导致页分裂，IO次数增多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;组合索引把散列性高(区分度高)的值放在前面&lt;/p&gt;&lt;p&gt;为了满足最左前缀匹配原则&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建组合索引，而不是修改单列索引。&lt;/p&gt;&lt;p&gt;组合索引代替多个单列索引（对于单列索引，MySQL基本只能使用一个索引，所以经常使用多个条件查询时更适合使用组合索引）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;过长的字段，使用前缀索引。当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过截取字段的前面一部分内容建立索引，这个就叫前缀索引。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不建议用无序的值(例如身份证、UUID )作为索引&lt;/p&gt;&lt;p&gt;当主键具有不确定性，会造成叶子节点频繁分裂，出现磁盘存储的碎片化&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.索引哪些情况下会失效呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查询条件包含or，可能导致索引失效&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果字段类型是字符串，where时一定用引号括起来，否则会因为隐式类型转换，索引失效&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;like通配符可能导致索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在索引列上使用mysql的内置函数，索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对索引列运算（如，+、-、*、/），索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;索引字段上使用（！= 或者 &amp;lt; &amp;gt;，not in）时，可能会导致索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;索引字段上使用is null， is not null，可能导致索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;左连接查询或者右连接查询查询关联的字段编码格式不一样，可能导致索引失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;MySQL优化器估计使用全表扫描要比使用索引快,则不使用索引。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.索引不适合哪些场景呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据量比较少的表不适合加索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新比较频繁的字段也不适合加索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;离散低的字段不适合加索引（如性别）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.索引是不是建的越多越好呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不是。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;索引会占据磁盘空间&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;索引虽然会提高查询效率，但是会降低更新表的效率&lt;/strong&gt;。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.MySQL索引用的什么数据结构了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL的默认存储引擎是InnoDB，它采用的是B+树结构的索引。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B+树：只有叶子节点才会存储数据，非叶子节点只存储键值。叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3383873190902826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAhvw5hr2vUkPyZLEvfNOtYyJAVnqObqZIv24nhhIbibh2tdg6Ic1R2VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1451&quot;/&gt;&lt;figcaption&gt;B+树索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这张图里，有两个重点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最外面的方块，的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（粉色所示）和指针（黄色/灰色所示），如根节点磁盘包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、4、5……、65。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表，可以进行范围查询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.那一棵B+树能存储多少条数据呢？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41725978647686834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA11aW1Wn8KwnEJDgicOwAw9h4t9Ug05p65Z2DGDxjDU45wqhZL3QeiarQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1124&quot;/&gt;&lt;figcaption&gt;B+树存储数据条数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384/14=1170 个这样的 单元(键值+指针)，代表有 1170 个指针。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 1170*1170*16=&lt;strong&gt;21902400&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;35.为什么要用 B+ 树，而不用普通二叉树？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从几个维度去看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不用普通二叉树？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;普通二叉树存在退化的情况，如果它退化成链表，相当于全表扫描。平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不用平衡二叉树呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读取数据的时候，是从磁盘读到内存。如果树这种数据结构作为索引，那每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块，但是平衡二叉树可是每个节点只存储一个键值和数据的，如果是 B+ 树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就降下来啦，查询效率就快。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;36.为什么用 B+ 树而不用 B 树呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B+相比较B树，有这些优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;它是 B Tree 的变种，B Tree 能解决的问题，它都能解决。&lt;/p&gt;&lt;p&gt;B Tree 解决的两大问题：每个节点存储更多关键字；路数更多&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;扫库、扫表能力更强&lt;/p&gt;&lt;p&gt;如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵 B+Tree 拿到所有的数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B+Tree 的磁盘读写能力相对于 B Tree 来说更强，IO次数更少&lt;/p&gt;&lt;p&gt;根节点和枝节点不保存数据区， 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多，IO次数更少。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;排序能力更强&lt;/p&gt;&lt;p&gt;因为叶子节点上有下一个数据区的指针，数据形成了链表。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;效率更加稳定&lt;/p&gt;&lt;p&gt;B+Tree 永远是在叶子节点拿到数据，所以 IO 次数是稳定的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;37.Hash 索引和 B+ 树索引区别是什么？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B+ 树可以进行范围查询，Hash 索引不能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B+ 树支持联合索引的最左侧原则，Hash 索引不支持。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B+ 树支持 order by 排序，Hash 索引不支持。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Hash 索引在等值查询上比 B+ 树效率更高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B+ 树使用 like 进行模糊查询的时候，like 后面（比如 % 开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;38.聚簇索引与非聚簇索引的区别？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先理解聚簇索引不是一种新的索引，而是而是一种&lt;strong&gt;数据存储方式&lt;/strong&gt;。聚簇表示数据行和相邻的键值紧凑地存储在一起。我们熟悉的两种存储引擎——MyISAM采用的是非聚簇索引，InnoDB采用的是聚簇索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;索引的数据结构是树，聚簇索引的索引和数据存储在一棵树上，树的叶子节点就是数据，非聚簇索引索引和数据不在一棵树上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4397076735688185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAA04CuPza6b2e7zGSQGsChvr5lWbImu6HB3EVq5kVTBj32AsK7Fsg4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;figcaption&gt;聚簇索引和非聚簇索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个表中只能拥有一个聚簇索引，而非聚簇索引一个表可以存在多个。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;聚簇索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；索引，索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;聚簇索引：物理存储按照索引排序；非聚集索引：物理存储不按照索引排序；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;39.回表了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在InnoDB存储引擎里，利用辅助索引查询，先通过辅助索引找到主键索引的键值，再通过主键值查出主键索引里面没有符合要求的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如:select * from user where name = ‘张三’;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44038929440389296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAGZFsgibdWEyMVFmt1eNkoAonCgmaj0W5F6z78wgBE0pnfMGiczDh32JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;figcaption&gt;InnoDB回表&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;40.覆盖索引了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在辅助索引里面，不管是单列索引还是联合索引，如果 select 的数据列只用辅助索引中就能够取得，不用去查主键索引，这时候使用的索引就叫做覆盖索引，避免了回表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，&lt;code&gt;select name from user where name = ‘张三’;&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4440389294403893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlATrp6ic806RvqObNiaCo9mdgzFtONbibl06G3l6jQjhOxXafeqrtMdQ5cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;figcaption&gt;覆盖索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;41.什么是最左前缀原则/最左匹配原则？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：最左前缀原则、最左匹配原则、最左前缀匹配原则这三个都是一个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最左匹配原则&lt;/strong&gt;：在InnoDB的联合索引中，查询的时候只有匹配了前一个/左边的值之后，才能匹配下一个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据最左匹配原则，我们创建了一个组合索引，如 (a1,a2,a3)，相当于创建了（a1）、(a1,a2)和 (a1,a2,a3) 三个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么不从最左开始查，就无法匹配呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有一个user表，我们给 name 和 age 建立了一个组合索引。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;ALTER TABLE user add INDEX &lt;span&gt;comidx_name_phone&lt;/span&gt; &lt;span&gt;(name,age)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组合索引在 B+Tree 中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 (name 在左边，age 在右边)。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3952569169960474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAFtburUeuD6BVIAGQb6aBxwmcHibZxkCTt9SsibgNxaicWGVMFWicIaIiaQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1518&quot;/&gt;&lt;figcaption&gt;组合索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这张图可以看出来，name 是有序的，age 是无序的。当 name 相等的时候， age 才是有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候我们使用&lt;code&gt; where name= ‘张三‘ and age = ‘20 ‘&lt;/code&gt;去查询数据的时候， B+Tree 会优先比较 name 来确定下一步应该搜索的方向，往左还是往右。如果 name 相同的时候再比较age。但是如果查询条件没有 name，就不知道下一步应该查哪个 节点，因为建立搜索树的时候 name 是第一个比较因子，所以就没用上索引。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;42.什么是索引下推优化？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引条件下推优化&lt;code&gt;（Index Condition Pushdown (ICP) ）&lt;/code&gt;是MySQL5.6添加的，用于优化数据查询。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不使用索引条件下推优化时存储引擎通过索引检索到数据，然后返回给MySQL Server，MySQL Server进行过滤条件的判断。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当使用索引条件下推优化时，如果存在某些被索引的列的判断条件时，MySQL Server将这一部分判断条件&lt;strong&gt;下推&lt;/strong&gt;给存储引擎，然后由存储引擎通过判断索引是否符合MySQL Server传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一张表，建了一个联合索引（name, age），查询语句：&lt;code&gt;select * from t_user where name like &#x27;张%&#x27; and age=10;&lt;/code&gt;，由于&lt;code&gt;name&lt;/code&gt;使用了范围查询，根据最左匹配原则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不使用ICP，引擎层查找到&lt;code&gt;name like &#x27;张%&#x27;&lt;/code&gt;的数据，再由Server层去过滤&lt;code&gt;age=10&lt;/code&gt;这个条件，这样一来，就回表了两次，浪费了联合索引的另外一个字段&lt;code&gt;age&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7448107448107448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAI2ewBy4YABUl8pxPOuS8AH2ictP1BPjJHfLE89e7RHwFRXBeiajNgMKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;figcaption&gt;没有使用ICP&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，使用了索引下推优化，把where的条件放到了引擎层执行，直接根据&lt;code&gt;name like &#x27;张%&#x27; and age=10&lt;/code&gt;的条件进行过滤，减少了回表的次数。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7121951219512195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAOYn4ymvWuu5G1c2PMJbERSwpOAAqvJTmk7dvXX3IiaMIfPYzTUpxe9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot;/&gt;&lt;figcaption&gt;使用ICP&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;43.MySQL中有哪几种锁，列举一下？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4170141784820684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA55t7XUODqqMsLicsjYqBjT0hbFiczK9Xgicz4WUZerXvGyEXQxY41q5bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1199&quot;/&gt;&lt;figcaption&gt;MySQL中的锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果按锁粒度划分，有以下3种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表锁：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低;不会出现死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页锁：开销和加锁速度介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果按照兼容性，有两种，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;共享锁（S Lock）,也叫读锁（read lock），相互不阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排他锁（X Lock），也叫写锁（write lock），排它锁是阻塞的，在一定时间内，只有一个请求能执行写入，并阻止其它锁读取正在写入的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;44.说说InnoDB里的行锁实现?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿这么一个用户表来表示行级锁，其中插入了4行数据，主键值分别是1,6,8,12，现在简化它的聚簇索引结构，只保留数据记录。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14303030303030304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAGq5GpvIderRaiceKApvMu717mDzuwqT1uCicu7Oouich3xD7cVHf7Qonw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;figcaption&gt;简化的主键索引&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB的行锁的主要实现如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如&lt;code&gt;select * from t where id =6 for update;&lt;/code&gt;就会将&lt;code&gt;id=6&lt;/code&gt;的记录锁定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15712545676004872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlARvX4u6GAD5qiavicNkqzLSN6gJl29TKo6RIv67ibGWgUZOKhmnALd5Mbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;figcaption&gt;记录锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁(Gap Locks) 的间隙指的是两个记录之间逻辑上尚未填入数据的部分,是一个&lt;strong&gt;左开右开空间&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1822600243013366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAcOrdZ3C7w7f4alys7jia8qHtRx4syCMWo2qdhBeibxhlfssUC3JKY3bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1646&quot;/&gt;&lt;figcaption&gt;间隙锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个&lt;code&gt;record&lt;/code&gt;，此时就会将对应的间隙区间锁定。例如&lt;code&gt;select * from t where id =3 for update;&lt;/code&gt;或者&lt;code&gt;select * from t where id &amp;gt; 1 and id &amp;lt; 6 for update;&lt;/code&gt;就会将(1,6)区间锁定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;临键指的是间隙加上它右边的记录组成的&lt;strong&gt;左开右闭区间&lt;/strong&gt;。比如上述的(1,6]、(6,8]等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19515151515151516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlArOUZS6xX04IcEbdtbaxibknmUu4MibG0Pl6SNVVVFNSTsuSFBnPYB8MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;figcaption&gt;临键锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分&lt;code&gt;record&lt;/code&gt;记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如&lt;code&gt;select * from t where id &amp;gt; 5 and id &amp;lt;= 7 for update;&lt;/code&gt;会锁住(4,7]、(7,+∞)。mysql默认行锁类型就是&lt;code&gt;临键锁(Next-Key Locks)&lt;/code&gt;。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;间隙锁(Gap Locks)&lt;/code&gt;和&lt;code&gt;临键锁(Next-Key Locks)&lt;/code&gt;都是用来解决幻读问题的，在&lt;code&gt;已提交读（READ COMMITTED）&lt;/code&gt;隔离级别下，&lt;code&gt;间隙锁(Gap Locks)&lt;/code&gt;和&lt;code&gt;临键锁(Next-Key Locks)&lt;/code&gt;都会失效！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是行锁的三种实现算法，除此之外，在行上还存在插入意向锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Insert Intention Lock 插入意向锁&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个事务在插入一条记录时需要判断一下插入位置是不是被别的事务加了意向锁 ，如果有的话，插入操作需要等待，直到拥有 gap锁 的那个事务提交。但是事务在等待的时候也需要在内存中生成一个 锁结构 ，表明有事务想在某个 间隙 中插入新记录，但是现在在等待。这种类型的锁命名为 Insert Intention Locks ，也就是插入意向锁 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我们有个T1事务，给(1,6)区间加上了意向锁，现在有个T2事务，要插入一个数据，id为4，它会获取一个（1,6）区间的插入意向锁，又有有个T3事务，想要插入一个数据，id为3，它也会获取一个（1,6）区间的插入意向锁，但是，这两个插入意向锁锁不会互斥。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20365853658536584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlARG0YTBILtnUd4cckv6j2TlWv7oIVw4ZLSAmun18MzPqTTnZQ3AANOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot;/&gt;&lt;figcaption&gt;插入意向锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;45.意向锁是什么知道吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁是一个表级锁，不要和插入意向锁搞混。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁的出现是为了支持InnoDB的多粒度锁，它解决的是表锁和行锁共存的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要给一个表加表锁的时候，我们需要根据去判断表中有没有数据行被锁定，以确定是否能加成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如没有意向锁，那么我们就得遍历表中所有数据行来判断有没有行锁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了意向锁这个表级锁之后，则我们直接判断一次就知道表中是否有数据行被锁定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了意向锁之后，要执行的事务A在申请行锁（写锁）之前，数据库会自动先给事务A申请表的意向排他锁。当事务B去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务B申请表的互斥锁时会被阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6821305841924399&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlARmbhYWaHAKibYRibgtHz07HXDAMO8REEUEQaylmhCKSh69yLX9Lia1JJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;figcaption&gt;意向锁&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;46.MySQL的乐观锁和悲观锁了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;（Pessimistic Concurrency Control）：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;悲观锁认为被它保护的数据是极其不安全的，每时每刻都有可能被改动，一个事务拿到悲观锁后，其他任何事务都不能对该数据进行修改，只能等待锁被释放才可以执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库中的行锁，表锁，读锁，写锁均为悲观锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;乐观锁（Optimistic Concurrency Control）&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁认为数据的变动不会太频繁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁通常是通过在表中增加一个版本(version)或时间戳(timestamp)来实现，其中，版本最为常用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务在从数据库中取数据时，会将该数据的版本也取出来(v1)，当事务对数据变动完毕想要将其更新到表中时，会将之前取出的版本v1与数据中最新的版本v2相对比，如果v1=v2，那么说明在数据变动期间，没有其他事务对数据进行修改，此时，就允许事务对表中的数据进行修改，并且修改时version会加1，以此来表明数据已被变动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果，v1不等于v2，那么说明数据变动期间，数据被其他事务改动了，此时不允许数据更新到表中，一般的处理办法是通知用户让其重新操作。不同于悲观锁，乐观锁通常是由开发者实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;47.MySQL 遇到过死锁问题吗，你是如何解决的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排查死锁的一般步骤是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）查看死锁日志 show engine innodb status;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）找出死锁 sql&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）分析 sql 加锁情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）模拟死锁案发&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）分析死锁日志&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）分析死锁结果&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这只是一个简单的流程说明，实际上生产中的死锁千奇百怪，排查和解决起来没那么简单。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;48.MySQL 事务的四大特性说一下？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7776141384388807&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlASq9aicA76S7obu9086leicicQYV8WZ2fFpWbcOnV94dZOIdY37X5xgabw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;figcaption&gt;事务四大特性&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原子性：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致性：指在事务开始之前和事务结束以后，数据不会被破坏，假如 A 账户给 B 账户转 10 块钱，不管成功与否，A 和 B 的总金额是不变的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其它事务运行效果。简言之，就是事务之间是进水不犯河水的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持久性：表示事务完成以后，该事务对数据库所作的操作更改，将持久地保存在数据库之中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;49.那ACID靠什么保证的呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务的&lt;strong&gt;隔离性&lt;/strong&gt;是通过数据库锁的机制实现的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务的&lt;strong&gt;一致性&lt;/strong&gt;由undo log来保证：undo log是逻辑日志，记录了事务的insert、update、deltete操作，回滚的时候做相反的delete、update、insert操作来恢复数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务的&lt;strong&gt;原子性&lt;/strong&gt;和&lt;strong&gt;持久性&lt;/strong&gt;由redo log来保证：redolog被称作重做日志，是物理日志，事务提交的时候，必须先将事务的所有日志写入redo log持久化，到事务的提交操作才算完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5432960893854749&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlApG8m5iaWoUuD4GOibMzfz9tiaZXIj92tEvM7BmIm0NumgI8MZV7PSxR5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;figcaption&gt;ACID靠什么保证&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;50.事务的隔离级别有哪些？MySQL 的默认隔离级别是什么？&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34475806451612906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlABt3cfSGZzQE4COyiayoSxv0SBy1sxCnG4YcmSE45HMeNnMKdMS7td9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;figcaption&gt;事务的四个隔离级别&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读未提交（Read Uncommitted）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读已提交（Read Committed）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可重复读（Repeatable Read）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;串行化（Serializable）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL默认的事务隔离级别是可重复读 (Repeatable Read)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;51.什么是幻读，脏读，不可重复读呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;事务 A、B 交替执行，事务 A 读取到事务 B 未提交的数据，这就是&lt;strong&gt;脏读&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是&lt;strong&gt;不可重复读&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;事务 A 查询一个范围的结果集，另一个并发事务 B 往这个范围中插入 / 删除了数据，并静悄悄地提交，然后事务 A 再次查询相同的范围，两次读取得到的结果集不一样了，这就是&lt;strong&gt;幻读&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的隔离级别，在并发事务下可能会发生的问题：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;隔离级别&lt;/th&gt;&lt;th&gt;脏读&lt;/th&gt;&lt;th&gt;不可重复读&lt;/th&gt;&lt;th&gt;幻读&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Read Uncommited  读取未提交&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Read Commited 读取已提交&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Repeatable Read 可重复读&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Serialzable 可串行化&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;52.事务的各个隔离级别都是如何实现的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读未提交&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读未提交，就不用多说了，采取的是读不加锁原理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务读不加锁，不阻塞其他事务的读和写&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务写阻塞其他事务写，但不阻塞其他事务读；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读取已提交&amp;amp;可重复读&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读取已提交和可重复读级别利用了&lt;code&gt;ReadView&lt;/code&gt;和&lt;code&gt;MVCC&lt;/code&gt;，也就是每个事务只能读取它能看到的版本（ReadView）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;READ COMMITTED：每次读取数据前都生成一个ReadView&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;REPEATABLE READ ：在第一次读取数据时生成一个ReadView&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;串行化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行化的实现采用的是读写都加锁的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行化的情况下，对于同一行事务，&lt;code&gt;写&lt;/code&gt;会加&lt;code&gt;写锁&lt;/code&gt;，&lt;code&gt;读&lt;/code&gt;会加&lt;code&gt;读锁&lt;/code&gt;。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;53.MVCC了解吗？怎么实现的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。关于它的实现，要抓住几个关键点，&lt;strong&gt;隐式字段、undo日志、版本链、快照读&amp;amp;当前读、Read View&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;版本链&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于InnoDB存储引擎，每一行记录都有两个隐藏列&lt;strong&gt;DB_TRX_ID、DB_ROLL_PTR&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DB_TRX_ID&lt;/code&gt;，事务ID，每次修改时，都会把该事务ID复制给&lt;code&gt;DB_TRX_ID&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;，回滚指针，指向回滚段的undo日志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15780730897009967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlA49nHbkPW8RrfhCkyyC4gsGeyVtjkMhS5xvcOMfVtjE3tCDNQCn4X6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1204&quot;/&gt;&lt;figcaption&gt;表隐藏列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有一张&lt;code&gt;user&lt;/code&gt;表，表中只有一行记录，当时插入的事务id为80。此时，该条记录的示例图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24788732394366197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAwJ1UbvY3sNBEd01E1Jupaj1D2ib1vfqpbt0usUa7yo7dAwaTaicejjkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1420&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来有两个&lt;code&gt;DB_TRX_ID&lt;/code&gt;分别为&lt;code&gt;100&lt;/code&gt;、&lt;code&gt;200&lt;/code&gt;的事务对这条记录进行&lt;code&gt;update&lt;/code&gt;操作，整个过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42503259452411996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAic4fnyfNy48db4S0lYen1hbtLpJJPshLXHHy92ntnWBn8Qn1bjibotmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;figcaption&gt;update操作&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于每次变动都会先把&lt;code&gt;undo&lt;/code&gt;日志记录下来，并用&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;指向&lt;code&gt;undo&lt;/code&gt;日志地址。因此可以认为，&lt;strong&gt;对该条记录的修改日志串联起来就形成了一个&lt;code&gt;版本链&lt;/code&gt;，版本链的头节点就是当前记录最新的值&lt;/strong&gt;。如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7052096569250318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAibPhoUKbZdcatGkspCicTAUSibJPp8sJ7fdTEiccVp0icwXiaU6PsCSa250A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;figcaption&gt;MVCC&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ReadView&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别来说，都需要读取已经提交的事务所修改的记录，也就是说如果版本链中某个版本的修改没有提交，那么该版本的记录时不能被读取的。所以需要确定在&lt;code&gt;Read Committed&lt;/code&gt;和&lt;code&gt;Repeatable Read&lt;/code&gt;隔离级别下，版本链中哪个版本是能被当前事务读取的。于是就引入了&lt;code&gt;ReadView&lt;/code&gt;这个概念来解决这个问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Read View就是事务执行&lt;strong&gt;快照读&lt;/strong&gt;时，产生的读视图，相当于某时刻表记录的一个快照，通过这个快照，我们可以获取：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5392354124748491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAuUKpwDzldqJIHbxYAPibKx2f2sxNvuKDwt9h1kAk6Jnp0uBicpUian16g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;994&quot;/&gt;&lt;figcaption&gt;事务和ReadView&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;m_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务id 列表。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;min_trx_id ：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的 事务id ，也就是 m_ids 中的最小值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;max_trx_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;creator_trx_id ：表示生成该 ReadView 的事务的 事务id&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个 ReadView ，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果被访问版本的 DB_TRX_ID 属性值与 ReadView 中的 creator_trx_id 值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果被访问版本的 DB_TRX_ID 属性值小于 ReadView 中的 min_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 前已经提交，所以该版本可以被当前事务访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果被访问版本的 DB_TRX_ID 属性值大于 ReadView 中的 max_trx_id 值，表明生成该版本的事务在当前事务生成 ReadView 后才开启，所以该版本不可以被当前事务访问。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果被访问版本的 DB_TRX_ID 属性值在 ReadView 的 min_trx_id 和 max_trx_id 之间，那就需要判断一下trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;READ COMMITTED 是&lt;strong&gt;每次读取数据前都生成一个ReadView&lt;/strong&gt;，这样就能保证自己每次都能读到其它事务提交的数据；REPEATABLE READ 是在&lt;strong&gt;第一次读取数据时生成一个ReadView&lt;/strong&gt;，这样就能保证后续读取的结果完全一致。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;高可用/性能&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;54.数据库读写分离了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离的基本原理是将数据库读写操作分散到不同的节点上，下面是基本架构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0560538116591929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAsDHicjbuQibl42eK0SRQkJqCxFuhh65c3wOgo3qHntZJ61BDhuy6qzLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;读写分离&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离的基本实现是:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据库服务器搭建主从集群，一主一从、一主多从都可以。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库主机负责读写操作，从机只负责读操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务服务器将写操作发给数据库主机，将读操作发给数据库从机。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;55.那读写分离的分配怎么实现呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;程序代码封装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 &quot;中间层封装&quot; ） ，实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9865470852017937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAMhyhoib74lp5UJr2qQCkexH85ibr3AlO3VoOjSxfnuVIbKbH4JVj0naQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;figcaption&gt;业务代码封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前开源的实现方案中，淘宝的 TDDL (Taobao Distributed Data Layer, 外号：头都大了）是比较有名的。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;中间件封装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其基本架构是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0337078651685394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAjPmYGIcJPHoA8odmtO8L6Ew7d39E8HBCicq7bfUibo60yGRGrf4TvZ4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;figcaption&gt;数据库中间件&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;56.主从复制原理了解吗？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;master数据写入，更新binlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;master创建一个dump线程向slave推送binlog&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slave连接到master的时候，会创建一个IO线程接收binlog，并记录到relay log中继日志中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slave再开启一个sql线程读取relay log事件并在slave执行，完成同步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;slave记录自己的binglog&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38855054811205847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlALfVIb8SoTPHa23tmx1IraQwHE02hezyrSa6dTgTvcqPqguXkqrQNtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;figcaption&gt;主从复制&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;57.主从同步延迟怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从同步延迟的原因&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个服务器开放Ｎ个链接给客户端来连接的，这样有会有大并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有一个，当某个 SQL 在从服务器上执行的时间稍长 或者由于某个 SQL 要进行锁表就会导致，主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不一致， 也就是主从延迟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从同步延迟的解决办法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决主从复制延迟有几种常见的方法:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;写操作后的读操作指定发给数据库主服务器&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，注册账号完成后，登录时读取账号的读操作也发给数据库主服务器。这种方式和业务强绑定，对业务的侵入和影响较大，如果哪个新来的程序员不知道这样写代码，就会导致一个bug。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读从机失败后再读一次主机&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是通常所说的 &quot;二次读取&quot; ，二次读取和业务无绑定，只需要对底层数据库访问的 API 进行封装即可，实现代价较小，不足之处在于如果有很多二次读取，将大大增加主机的读操作压力。例如，黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;关键业务读写操作全部指向主机，非关键业务采用读写分离&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，对于一个用户管理系统来说，注册 + 登录的业务读写操作全部访问主机，用户的介绍、爰好、等级等业务，可以采用读写分离，因为即使用户改了自己的自我介绍，在查询时却看到了自我介绍还是旧的，业务影响与不能登录相比就小很多，还可以忍受。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;58.你们一般是怎么分库的呢？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7235772357723578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAKgYPQfsv3gibIXcqK5HZ830fN4EGQO0E1Dl3C0JicJIVjJIib1MpXXCQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;figcaption&gt;垂直分库&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;水平分库：以字段为依据，按照一定策略（hash、range 等），将一个库中的数据拆分到多个库中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6295025728987993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAdJGiaaEdtaURx5u8XwP4RS0V6w1jDEXLs4o7Jb8lzH1BMVajepMjRpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1166&quot;/&gt;&lt;figcaption&gt;水平分库&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;59.那你们是怎么分表的？&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;水平分表：以字段为依据，按照一定策略（hash、range 等），将一个表中的数据拆分到多个表中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7869718309859155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAU4Ml9pcwKsJmqb5eajclkvEic4xVRrMwxcVHJVKkRXvFVBZo2jFkKVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;figcaption&gt;表拆分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;60.水平分表有哪几种路由方式？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是路由呢？就是数据应该分到哪一张表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平分表主要有三种路由方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;范围路由&lt;/strong&gt;：选取有序的数据列 （例如，整形、时间戳等） 作为路由的条件，不同分段分散到不同的数据库表中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以观察一些支付系统，发现只能查一年范围内的支付记录，这个可能就是支付公司按照时间进行了分表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5405742821473158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAUj27yPZDlrg2kWx758wsomr9icdsIYFDiac7WJF5ghPjLRAwIfxyKEJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;figcaption&gt;范围路由&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至2000 万之间，具体需要根据业务选取合适的分段大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;范围路由的优点是可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。范围路由的一个比较隐含的缺点是分布不均匀，假如按照  1000 万来进行分表，有可能某个分段实际存储的数据量只有 1000 条，而另外一个分段实际存储的数据量有 900 万条。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Hash 路由&lt;/strong&gt;：选取某个列 （或者某几个列组合也可以） 的值进行 Hash 运算，然后根据 Hash 结果分散到不同的数据库表中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样以订单 id  为例，假如我们一开始就规划了 4个数据库表，路由算法可以简单地用 id % 4 的值来表示数据所属的数据库表编号，id 为 12的订单放到编号为 50的子表中，id为 13的订单放到编号为 61的字表中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6189759036144579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAu91CftXwyOqvsZZzYAwTObRf4aW6af73QndVc62TTWSIGvNUKVTIPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;figcaption&gt;Hash路由&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash 路由设计的复杂点主要体现在初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。而用了 Hash 路由后，增加子表数量是非常麻烦的，所有数据都要重分布。Hash 路由的优缺点和范围路由基本相反，Hash 路由的优点是表分布比较均匀，缺点是扩充新的表很麻烦，所有数据都要重分布。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置路由&lt;/strong&gt;：配置路由就是路由表，用一张独立的表来记录路由信息。同样以订单id 为例，我们新增一张 order_router 表，这个表包含 orderjd 和 tablejd 两列 , 根据 orderjd 就可以查询对应的 table_id。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5823714585519413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlACVDc3YFKj6BzPQ0HJxY95tGOuPXkWkw6xprdTu4PGkVqg7fEhHomKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot;/&gt;&lt;figcaption&gt;配置路由&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据） ，性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;61.不停机扩容怎么实现？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，不停机扩容，实操起来是个非常麻烦而且很有风险的操作，当然，面试回答起来就简单很多。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;建立好新的库表结构，数据写入久库的同时，也写入拆分的新库&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据迁移，使用数据迁移程序，将旧库中的历史数据迁移到新库&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用定时任务，新旧库的数据对比，把差异补齐&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6610800744878957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlARGdcCJZaMeRKibp6n0iaydUvX4euwaVaOHZ0244Unfhfg2ACeUgTr3kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;figcaption&gt;第一阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;第二阶段：在线双写，查询走新库&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;完成了历史数据的同步和校验&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;把对数据的读切换到新库&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5286506469500925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAMH4lAJSsZT14PQZEktbsyuwnYYq45cvA49e6srQKCwPrVIC83QJu3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;figcaption&gt;第二阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;第三阶段：旧库下线&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;旧库不再写入新的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;经过一段时间，确定旧库没有请求之后，就可以下线老库&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5241635687732342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWcxrhwchLbbpusoPaT2cOlAphRVz0icibMibEibILd3uFvxUlRjYQlAdslncr4LfbUPrfmTy4CAX2NUhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;figcaption&gt;第三阶段&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;62.常用的分库分表中间件有哪些？&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;63.那你觉得分库分表会带来什么问题呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从分库的角度来讲：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用关系型数据库，有很大一点在于它保证事务完整性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而分库之后单机事务就用不上了，必须使用分布式事务来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个库中的时候我们还可以利用 JOIN 来连表查询，而跨库了之后就无法使用 JOIN 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的解决方案就是&lt;strong&gt;在业务代码中进行关联&lt;/strong&gt;，也就是先把一个表的数据查出来，然后通过得到的结果再去查另一张表，然后利用代码来关联得到最终的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式实现起来稍微比较复杂，不过也是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有可以&lt;strong&gt;适当的冗余一些字段&lt;/strong&gt;。比如以前的表就存储一个关联 ID，但是业务时常要求返回对应的 Name 或者其他字段。这时候就可以把这些字段冗余到当前表中，来去除需要关联的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种方式就是&lt;strong&gt;数据异构&lt;/strong&gt;，通过binlog同步等方式，把需要跨库join的数据异构到ES等存储结构中，通过ES进行查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从分表的角度来看：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;跨节点的 count,order by,group by 以及聚合函数问题&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只能由业务代码来实现或者用中间件将各表中的数据汇总、排序、分页然后返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据的迁移，容量如何规划，未来是否可能再次需要扩容，等等，都是需要考虑的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库表被切分后，不能再依赖数据库自身的主键生成机制，所以需要一些手段来保证全局主键唯一。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;还是自增，只不过自增步长设置一下。比如现在有三张表，步长设置为3，三张表 ID 初始值分别是1、2、3。这样第一张表的 ID 增长是 1、4、7。第二张表是2、5、8。第三张表是3、6、9，这样就不会重复了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUID，这种最简单，但是不连续的主键插入会导致严重的页分裂，性能比较差。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式 ID，比较出名的就是 Twitter 开源的 sonwflake 雪花算法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;64.百万级别以上的数据如何删除？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;所以我们想要删除百万数据的时候可以先删除索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后删除其中无用数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除完成后重新创建索引创建索引也非常快&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;65.百万千万级大表如何添加字段？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当线上的数据库数据量到达几百万、上千万的时候，加一个字段就没那么简单，因为可能会长时间锁表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大表添加字段，通常有这些做法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过中间表转换过去&lt;/p&gt;&lt;p&gt;创建一个临时的新表，把旧表的结构完全复制过去，添加字段，再把旧表数据复制过去，删除旧表，新表命名为旧表的名称，这种方式可能回丢掉一些数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用pt-online-schema-change&lt;/p&gt;&lt;p&gt;&lt;code&gt;pt-online-schema-change&lt;/code&gt;是percona公司开发的一个工具，它可以在线修改表结构，它的原理也是通过中间表。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;先在从库添加 再进行主从切换&lt;/p&gt;&lt;p&gt;如果一张表数据量大且是热表（读写特别频繁），则可以考虑先在从库添加，再进行主从切换，切换后再将其他几个节点上添加字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;66.MySQL 数据库 cpu 飙升的话，要怎么处理呢？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排查过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）使用 top 命令观察，确定是 mysqld 导致还是其他原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）如果是 mysqld 导致的，show processlist，查看 session 情况，确定是不是有消耗资源的 sql 在运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）找出消耗高的 sql，看看执行计划是否准确， 索引是否缺失，数据量是否太大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）kill 掉这些线程 (同时观察 cpu 使用率是否下降)，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）进行相应的调整 (比如说加索引、改 sql、改内存参数)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）重新跑这些 SQL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[1]. 《高性能MySQL》&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[2]. 《MySQL技术内幕 InnoDB存储引擎》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[3]. 《MySQL实战45讲》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[4]. 《MySQL 是怎样运行的：从根儿上理解 MySQL》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[5].[快问快答，MySQL 面试夺命 20 问](https://mp.weixin.qq.com/s/aiD91w3ez48o-SiOAOSK-A)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[6]. 艾小仙 《我想进大厂》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[7].[100道MySQL数据库经典面试题解析（收藏版）](https://juejin.cn/post/6844904166939164680)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[8].[MySQL索引从基础到原理，看这一篇就够了](https://blog.csdn.net/sinat_40770656/article/details/114339535)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[9].[图文并茂的带你彻底理解悲观锁与乐观锁                ](https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247487996&amp;amp;idx=1&amp;amp;sn=cafae3423e5ffa903a0c0a94a355f981&amp;amp;source=41#wechat_redirect)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[10]. [最完整MySQL数据库面试题（2020最新版）](https://zhuanlan.zhihu.com/p/112857507)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[11]. [MySQL提升笔记（2）：存储引擎盘点](https://fighter3.blog.csdn.net/article/details/115741692)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[13].[不会看 Explain执行计划，劝你简历别写熟悉 SQL优化  ](https://juejin.cn/post/6844904163969630221)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[14]. [为了让你彻底弄懂 MySQL 事务日志，我通宵肝出了这份图解！](https://www.cxyxiaowu.com/10740.html)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[15]. 《极客时间 高并发系统设计40问》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[16]. 《极客时间 从零开始学架构》&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[17]. [在面试时被问到，为什么MySQL数据库数据量大了要进行分库分表？](https://www.zhihu.com/question/459955079)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[18]. [为了让你彻底弄懂 MySQL 事务日志，我通宵肝出了这份图解！](https://www.cxyxiaowu.com/10740.html)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[19]. [MySQL 三万字精华总结 + 面试100 问，和面试官扯皮绰绰有余（收藏系列](https://juejin.cn/post/6850037271233331208)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[20].[面试中的老大难-mysql事务和锁，一次性讲清楚！](https://juejin.cn/post/6855129007336521741#heading-13)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[21]. [一文彻底读懂MySQL事务的四大隔离级别  ](https://juejin.cn/post/6844904115353436174#heading-16)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[22].[MySQL存储引擎－－MyISAM与InnoDB区别](https://segmentfault.com/a/1190000008227211)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[23]. [解决死锁之路（终结篇） - 再见死锁](https://www.aneasystone.com/archives/2018/04/solving-dead-locks-four.html)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;[24]. [大众点评订单系统分库分表实践](https://tech.meituan.com/2016/11/18/dianping-order-db-sharding.html)&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n1147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;link&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3e3ead946dc715cf029477c08c4c8c96</guid>
<title>字节遭遇离职潮</title>
<link>https://toutiao.io/k/84iz6z1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-style-type=&quot;5&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;965972&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击关注#互联网架构师公众号，领取&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;架构师全套资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构师全套资料&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 都在这里&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100029587&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21&amp;amp;token=171858062&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;0、2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;0、&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T架构师学习资料干货分&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247527649&amp;amp;idx=1&amp;amp;sn=94a186f5825f71f2536454f2da1d1263&amp;amp;chksm=ea5fa187dd282891fa5020425d44c1fe70c7876f85a4f2ea5e03282ea6278fbd11e23ebf849e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;上千万行，十几G源码，浏览器为什么这么“变态”？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;上千万行，十几G源码，浏览器为什么这么“变态”？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;作者 ：Georgia Wells /Yoree Koh /Salvador Rodriguez&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源 ：WSJ&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;504025864&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/M0x913PTXTI76NibXEI1C7UyFWkdCxawRLMzPdmQFicdsG5yPgZW4d4dP3RDDicmE2wu4WbUkS8ynQBM4CeyYWvWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;span&gt; 和国内字节跳动的欣欣向荣对比，国外的TikTok正在面临离职潮，原因是不适应字节的“996”...&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家好，我是互联网架构师！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok上似乎有无穷无尽的消遣打趣、尽情舞动以及善意的恶作剧，它也因此自称是互联网上最快乐的地方。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但据TikTok美国办公室的员工说，推动TikTok成功的，是严苛的管理风格和高要求的内部文化，完全背离平台愉悦鼓舞的公众形象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些员工中有许多都曾供职于其他大型科技公司，他们说，TikTok一味强调效率和保密，其程度之甚，在业内并不多见。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随着TikTok继续保持高增长，上述情况日益助推着TikTok美国办公室的紧张气氛。TikTok是总部位于北京的字节跳动科技有限公司(ByteDance Ltd.)的子公司。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;据市场研究公司Sensor Tower，截至2022年第一季度，六年前创立的TikTok已在所有类型应用程序中创下了下载量最高的纪录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;截至2020年年中，TikTok美国业务部约有1500名员工，该公司去年表示，希望将这一数字增加至10,000人。他们的工作内容主要围绕将在中国开发的产品转化为面向美国受众的产品，同时开拓商机可观的美国广告市场。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;504025741&quot; data-ratio=&quot;0.1648148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M0x913PTXTI76NibXEI1C7UyFWkdCxawRN2UkxJLialTlYNff7pdOVGI1Pse0IpGZMHCn80eZ0TOHRKicBEllMzPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从工作文化融合的角度来看，TikTok正在进行最大胆的尝试，它需要连接全球两大科技强国。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok美国业务的总部设在洛杉矶，这里的一些员工抱怨称，他们常常睡眠不足，而且周末频繁加班，必须与地球另一端的同事开会，就导致这种情况更加严重了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有几个该公司的美国前员工说，他们在TikTok工作期间，平均每周要开85个小时的会，而且还要挤出额外的时间来完成自己的工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一人说，他在提供了医学实验室检查结果、证明自己的身体状况危及生命后，才说服老板不再让他连续熬夜工作。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些前员工提到，他们经历了严重的体重波动、压力或是情绪低谷，以至于到了得寻求治疗的地步。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一名前员工说，巨大的压力让她不敢缺席TikTok一场紧接着一场的会议，她甚至不敢中途走开去换卫生棉条，以至于血浸湿了裤子。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok的一些做法是借鉴于亚马逊(Amazon.com Inc.)，后者同样因高要求的工作文化著称。TikTok的高管时常告诉员工要“永远创业”，这来自亚马逊创始人贝佐斯(Jeff Bezos)鼓励创新、避免自满的名言“每天都是第一天”(Always Day 1)。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除此之外，TikTok办公室的墙上还醒目地贴着其他标语，例如“坦诚清晰”，而员工对这些理念的执行情况如何，会成为公司对他们的评判标准之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok表示，公司致力于“建立并培养一个强大的团队，使其能够支持公司不断成长的全球社群”，为实现这一目标，它已对自身做法及工作文化进行了一些调整。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok在一份书面声明中补充说，“我们鼓励透明和反馈的文化，并致力于打造一个公平的平台和企业，让我们的社群和员工都能茁壮成长。”&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEAEPVW8WQkibAVhIicsichNGNZf9Btc3aW7UfEbZbJzGP1PKTprGWtxZ0YJbyu59sMX6xygUZ6QLXWzRmtDHUicmg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;TikTok的美国办公室主要位于洛杉矶。&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对TikTok这样快速发展的科技企业来说，长时间的工作和紧迫的截止日期不算什么新鲜事，而外企员工睡眠周期被打乱的情况也并不少见。但一些在TikTok和其他科技企业都干过的人说，TikTok美国员工体现出的压力之大到了罕见的程度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些前员工曾在YouTube、Medium等社交媒体网站上讲述他们在TikTok美国办公室的经历。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有些人说，身处紧张氛围会让他们感到兴奋。其他许多人则提到了种种挑战，包括理解内部文件的意思，那些文件以中文撰写再用软件翻译成英文，其中的细微含义难以在译文中呈现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我已经数不清TikTok的工作经历让我在多少方面得到了锻炼，无论是产品策略、执行还是不同文化间的细微差别，我从TikTok学到的东西之多，超过了我最初的想象。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok前高级产品经理Melody Chu在Medium的一篇贴文里说，其工作职责是帮助创作者将内容变现。尽管如此，自称曾在Facebook、Roblox和Nextdoor都工作过的Chu还是在去年11月离开了TikTok。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;她说，很多次晚饭时间她得跟中国同事通电话，没法陪丈夫，这种情况之频繁，以致于夫妻俩去找过婚姻咨询师。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;她写道，她的体重急剧下降，睡眠也出现了问题。所有她想做的事，包括陪伴父母以及关注自身心理健康，统统让位给了TikTok。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;她写道，“早知去TikTok会让我失去这么多，（2020年6月时）我肯定不会接受这份工作。”但她也说，现在回想起来，她也不后悔去TikTok，因为通过这段经历，她向自己证明了她已具备成功所需的品质。Chu没有回复记者的采访请求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前TikTok员工帕贝尔·马丁内斯说，他被告知不要将某些数据同较低级别的员工分享。“我得到的信号是：‘我们不信任你们。’”他说。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;504025745&quot; data-ratio=&quot;0.1648148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M0x913PTXTI76NibXEI1C7UyFWkdCxawROBbl1ibKdY2ibEia2pYjfDrHpr3NCcPyMGVpcrtVQX1ceDaFW2dn4dayA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;许多TikTok员工之所以能忍受长时间的工作以及工作和生活间缺乏界限的情况，是因为如果其母公司上市，他们有可能拿到一笔数量可观的钱。“你想登上那艘火箭船。”今年2月之前担任TikTok广告销售全球客户总监的帕贝尔·马丁内斯(Pabel Martinez)说。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;马丁内斯说，尽管自己的项目按进度推进，他仍被要求整个周末加班，他拒绝这样，对此，一名主管回应说：“我们这里不是这样做事的。”他随后离开了TikTok。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大约一年前，由于中国监管机构敦促字节跳动关注数据安全问题，该公司暂时搁置了上市计划。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;据一位熟悉TikTok经营情况的人士说，该公司2021年的收入约为40亿美元，今年的营收有望达到120亿美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相比之下，现更名为Meta Platforms Inc.的Facebook在成立十年后，营收才达到120亿美元。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;据前员工说，TikTok常常会安排多个团队完成同一个项目，让它们相互竞争，看谁最先完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这一策略本意是为了推动员工尽快完成工作，但一些前员工指出，这让人们唯恐落后于其他同事，而当有的团队始终无法看到曙光时，员工心里容易产生挫败感。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;去年，常驻新加坡的周受资接替临时首席执行官瓦妮莎·帕帕斯(Vanessa Pappas)，出任TikTok首席执行官，后者目前担任TikTok首席运营官，工作地点位于洛杉矶。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;美国员工说，这一举动进一步巩固了TikTok在东方的权力基础。美国人凯文·梅耶尔(Kevin Mayer)曾于2020年初担任TikTok首席执行官，但大约三个月后离职，当时特朗普政府正试图迫使将TikTok出售给一家美国公司。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok既没有向员工提供组织结构图，也不允许员工自己制作和分享组织结构图。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于那些想阻止竞争对手挖人的中国企业来说，这是他们的常见做法。一些前员工说，他们曾被告知组织结构图没有必要，因为在TikTok的扁平式架构中，任何人之间都可以相互联系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如此一来，员工可能感到困惑，他们不知道该联系其他团队中的哪些人，或者给他们发信息的又是哪些人。据一些前员工说，纽约办公室人力资源和财务团队的成员几个月来一直不知道在加州，还有另一群人也从事同样的职能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok新加坡前员工Jamie Lim Yin Yin说，当她收到同事的电子邮件时，她只有去领英(LinkedIn)上查找一番，才知道他们属于哪个团队。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这样说好了，在我的浏览器上，领英的标签页总是开着的。”她在一段YouTube视频中说，视频讲述了她为何会在去年12月、入职仅四个月后就离开了TikTok。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一位TikTok发言人说，员工有途径查看彼此的档案。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;曾任TikTok广告销售客户总监的马丁内斯说，TikTok的展示文件里时常会出现数字被模糊处理或是被略掉的情况，他的主管曾指示他不要将某些数据同较低级别的员工分享。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我得到的信号是：‘我们不信任你们。’”他说，TikTok的保密程度与他供职过的其他科技公司有着很大不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;TikTok前员工Chloe Shih在一段视频中说，“当我该去睡觉的时候却发现公司大部分人都没睡，这让我晚上十分焦虑。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;504025744&quot; data-ratio=&quot;0.1648148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M0x913PTXTI76NibXEI1C7UyFWkdCxawRIEcpXUMFwtjibfy27sZu5HRRyjEic0NGNGGMn1XIVabWS2WA0Nickl0kg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;section&gt;&lt;span&gt;尽管TikTok吸引了大批一心想来此工作的求职者，但与此同时，它也在努力解决离职率较高的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;曾在加州山景城(Mountain View)工作的TikTok前工程团队主管Lucas Ou-Yang在一系列Twitter主题贴中写道，由于要跟上中国同事的节奏，还要根据他们的日程表来安排工作，在这种压力下，曾与他共事的所有10位产品经理全都在入职大约一年后辞职了。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;去年11月，工程部的一个部门主办了一场全体会议来讨论美国员工的离职潮问题，此后，公司高管批准了一项新政策：如果不是所有与会者都说中文，可以尝试用英语开会。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管TikTok提供有翻译选项，但一些前员工说，当会议语言不是他们所能理解的语言时，他们觉得错过了许多细节。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;去年，中国政府告诉各用人单位，一些中国科技公司实行的“996”工作安排（即早9点到晚9点上班，一周工作六天）是不合法的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;字节跳动表示，它会采取“1075”模式：即早10点到晚7点上班，一周工作五天。但许多员工表示，他们预计长时间工作的情况仍会持续。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些TikTok美国前员工谈到，为了参加与北京主管举行的网络会议，他们常常从周日下午就要开始上班，因为那时在中国已是周一上午。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我真的觉得，晚上工作到那么晚让我出现了睡眠紊乱。”曾在加州工作的前员工Chloe Shih在一段YouTube视频里说，“当我该去睡觉的时候却发现公司的大部分人都没睡，这让我晚上十分焦虑。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一些前员工说，有关工作和生活平衡的问题在几乎每一次全体会议上都会被提及。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure itemscope=&quot;&quot; itemtype=&quot;http://schema.org/ImageObject&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LEAEPVW8WQkibAVhIicsichNGNZf9Btc3aWsmiasH0SsicOQpbvQgsk6ARYyRatS5GKXlHJnXDNqL4OocBFR37o6eOw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;TikTok位于洛杉矶的办公室。&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;2021年年中，一些美国主管开始鼓励员工下班后将内部通讯工具上的通知设置为静音模式，以此减少他们不得不在深夜处理的请求数量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有人还建议员工在日程表上为自己留出休息时间。但一些前员工说，公司高层不会在意日程表上的计划，他们还是会在那些时间安排会议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“尽管会议时常会跨越不同时区，这一点在跨国公司很常见，但我们会继续着眼于通过不同方式为员工提供支持和灵活性。”上述TikTok发言人说。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;她还说，TikTok鼓励员工安排个人休假时间、留出不开会的时段，并且不鼓励在休息时间发送工作信息。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;风投公司Basis Set Ventures创始人兼管理合伙人兰雪棹说，中国科技行业竞争的激烈程度比美国更极端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“显然没有人想干到凌晨2点，”但如果员工不干这么久，他们就没法生存，她说，“这是人们试图了解中国的文化时会遗漏的一个背景。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以往，TikTok会经常将许多新招的美国员工派往北京待一周，让他们近距离感受中国的工作文化，学习字节跳动的工作方式。后来新冠疫情爆发，这些差旅也随之暂停。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除TikTok外，字节跳动旗下还有许多应用程序及服务，包括相当于中国版TikTok的抖音。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;504025742&quot; data-ratio=&quot;0.1648148148148148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/M0x913PTXTI76NibXEI1C7UyFWkdCxawRicXQWBux3qribh0tyLYYvmia10ZPBzcW4np9Zw8GKgSgxW4IVfB8u7aPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;许多科技初创公司会向新员工发放限制性股票单位(RSU)，以此吸引他们接受较低的薪酬，因为公司今后一旦上市，他们就有机会获得一笔不菲的收入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直到2020年夏天，TikTok才开始向大部分美国员工发放RSU，这也是员工薪酬及奖金方案的内容之一。然而当它这样做时，却没有将奖励计划覆盖至大部分美国在职员工，因此造成了一些人所说的困惑与失望。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TikTok开始允许一些员工将奖金转化为RSU，并且RSU可即刻授予。但一些前员工说，只有在连续两次绩效评估中拿到高分的员工，才能享受这一福利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们说，这些评估的考核标准之一是看员工是否遵循了办公室墙上的标语，也就是“字节范”(Byte Styles)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但许多员工感觉，诸如“追求极致”、“务实敢为”这类说法太过模糊，主管们完全有可能仅凭个人喜好来奖励员工。其他人则说，由于担心违背“开放谦逊”这条“字节范”，员工们不敢畅所欲言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据前员工说，开会时，TikTok美国主管会略过员工提出的有关RSU的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据知情人士说，在2021年4月的一场员工大会上，已在TikTok品牌对外合作部工作两年多的迪伦·荣克(Dylan Juhnke)询问美国人力资源负责人，公司高层为何连续50周都在回避有关薪酬的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他说，如果TikTok不打算回应此类问题，它应该直接说出来，而不是采取回避态度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一份电子邮件副本显示，不久后，公司高层通过邮件斥责了荣克那天在员工大会上的行为。据一位知情人士说，人力资源部还启动了一项调查，并就TikTok是否能解雇荣克一事进行过讨论。几个月后，荣克辞职了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TikTok没有就有关员工具体经历的说法发表评论，包括荣克这件事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TikTok自称是“快乐、有趣、多元化及惊喜体验”的大本营。在荣克离职时发布的一份内部备忘录中，他说，“TikTok对待员工的方式与TikTok平台代表的东西截然相反。”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Alibaba开源内网高并发编程手册.pdf&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2T架构师学习资料干货分享&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523100&amp;amp;idx=1&amp;amp;sn=82a70350577bde0bca6dd2dde811ca17&amp;amp;chksm=ea5f567add28df6cb6a780ff744c3ffdc79e498d2c2536ffb1853d8082ebfa986e1e5c43d532&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10000+TB 资源，阿里云盘，牛逼！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;10000+TB 资源，阿里云盘，牛逼！！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523863&amp;amp;idx=1&amp;amp;sn=4d2a2b5da60f14f3e8947e174d485c03&amp;amp;chksm=ea5f5371dd28da6791af6cb3a164c8052f1e77d7392cbbc87c5a73ccc6916b76eab29dbc9991&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本涵盖了Spring所有核心知识点总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;基本涵盖了Spring所有核心知识点总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;  · END ·&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRL358RWHQSLbUws79uyGm5RJ6WZibYJMAKUQibz8aYNA5LPSmbo1boibnD3IhggQ2F7kS37xgk3WXQ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cfac55eafc5d4ffd31e7689901088921</guid>
<title>开源数据质量解决方案——Apache Griffin入门宝典</title>
<link>https://toutiao.io/k/pqkj5w9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;pre data-highlight-status=&quot;highlighted&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;code&gt;提到格里芬—Griffin，大家想到更多的是篮球明星或者战队名，但在大数据领域Apache Griffin（以下简称Griffin）可是数据质量领域响当当的一哥。先说一句：Griffin是大数据质量监控领域唯一的Apache项目，懂了吧。&lt;/code&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;在不重视数据质量的大数据发展时期，Griffin并不能引起重视，但是随着数据治理在很多企业的全面开展与落地，数据质量的问题开始引起重视。&lt;/section&gt;&lt;section&gt;还是那句话，商用版的解决方案暂时不在本文的讨论范围内，目前大数据流动公众号对于数据治理工具的研究还是在开源方向，希望通过开源+二次开发结合的方式找到适合自己公司的数据治理工具箱。在未来有靠谱的商用方案，我们也会保持关注~&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正文共：&lt;/span&gt; &lt;span&gt;12094&lt;/span&gt;字 &lt;/p&gt;&lt;p&gt;&lt;span&gt;预计阅读时间：&lt;/span&gt; &lt;span&gt;31&lt;/span&gt;分钟&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;js_asyningdom rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEX5dyxQjztMzkGNsVRFhlC9fFPfa537ic6GicI5k9KQBIlicsiaE7DmsY8PA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;本文将从数据质量，Griffin简介，Griffin架构，Griffin快速入门，Griffin批数据实战，Griffin流数据实战整合六个部分进行介绍，目的是带大家快速的入门数据质量管理工具的使用。&lt;/section&gt;&lt;section&gt;本文档版权属于公众号：大数据流动 所有。未经授权，请勿转载与商用！&lt;/section&gt;&lt;section&gt;考虑到抄袭问题，Griffin后续的高阶技术文章可能会付费，也希望大家能尽早加入数据治理、Griffin等相关技术群，我会将最新的文章与资料实时同步。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;js_asyningdom rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXd92Cc7LDZibP8z3Oc7QaFJedHxoNso5aJOicbY5m1iaU1Zf6kfC4aykbA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;一、数据质量&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据质量管理（Data Quality Management），是指对数据从计划、获取、存储、共享、维护、应用、消亡生命周期的每个阶段里可能引发的各类数据质量问题，进行识别、度量、监控、预警等一系列管理活动，并通过改善和提高组织的管理水平使得数据质量获得进一步提高。&lt;/p&gt;&lt;p&gt;数据质量管理不是一时的数据治理手段，而是循环的管理过程。其终极目标是通过可靠的数据，提升数据在使用中的价值，并最终为企业赢得经济效益。&lt;/p&gt;&lt;p&gt;为什么会有数据质量管理呢？&lt;/p&gt;&lt;p&gt;大数据时代数据的核心不是“大”，而在于“有价值”，而有价值的关键在于“质量”。但现实是，数据往往存在很多问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;数据无法匹配&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据不可识别&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;时效性不强&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据不一致&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;。。。。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那么，解决数据质量要达到什么目标呢？&lt;/p&gt;&lt;p&gt;总结来说就是&lt;strong&gt;可信和可用&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;可信就是让数据具有实用性，准确性，及时性，完整性，有效性。&lt;/p&gt;&lt;p&gt;可用就是规范性和可读性。&lt;/p&gt;&lt;p&gt;数据质量可能不是数据治理的最核心部分，但可能会成为数据治理落地的做大障碍。&lt;/p&gt;&lt;p&gt;提高数据质量有多种方式，比如建立统一的数据标准、提高人员的意识与能力等等。&lt;/p&gt;&lt;p&gt;而一个提高数据质量的高生产力方式就是使用&lt;strong&gt;数据质量管理工具&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;数据质量管理工具成熟的并不多，所以本文就不做无用的对比了，我们直接进入正题：Apache Griffin。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;二、Griffin简介&lt;/h2&gt;&lt;p&gt;Griffin是一个开源的大数据数据质量解决方案，由eBay开源，它支持批处理和流模式两种数据质量检测方式，是一个基于Hadoop和Spark建立的数据质量服务平台 (DQSP)。它提供了一个全面的框架来处理不同的任务，例如定义数据质量模型、执行数据质量测量、自动化数据分析和验证，以及跨多个数据系统的统一数据质量可视化。&lt;/p&gt;&lt;p&gt;Griffin于2016年12月进入Apache孵化器，Apache软件基金会2018年12月12日正式宣布Apache Griffin毕业成为Apache顶级项目。&lt;/p&gt;&lt;p&gt;Griffin官网地址：https://griffin.apache.org/&lt;/p&gt;&lt;p&gt;Github地址：https://github.com/apache/griffin&lt;/p&gt;&lt;p&gt;在eBay的数据质量管理实践中，需要花费很长时间去修复数据质量的问题，不管是批处理还是流处理，解决数据质量问题的时间都是巨大的，由此一个统一的数据质量系统就应运而生了。&lt;/p&gt;&lt;p&gt;在官网的定义中，Apache Griffin也早就更新为了批和流（Batch and Streaming）数据质量解决方案。Apache Griffin已经在朝着数据质量的统一管理平台而努力了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5846394984326019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXT8A7wLdWCQ7ajxEibpicGbicRMicX58zROZf2QqSrLjRVODCmjQ2pjAptQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Griffin主要有如下的功能特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;度量：精确度、完整性、及时性、唯一性、有效性、一致性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异常监测：利用预先设定的规则，检测出不符合预期的数据，提供不符合规则数据的下载。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异常告警：通过邮件或门户报告数据质量问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可视化监测：利用控制面板来展现数据质量的状态。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实时性：可以实时进行数据质量检测，能够及时发现问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可扩展性：可用于多个数据系统仓库的数据校验。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可伸缩性：工作在大数据量的环境中，目前运行的数据量约1.2PB(eBay环境)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自助服务：Griffin提供了一个简洁易用的用户界面，可以管理数据资产和数据质量规则；同时用户可以通过控制面板查看数据质量结果和自定义显示内容。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Apache Giffin目前的数据源包括HIVE, CUSTOM, AVRO, KAFKA。Mysql和其他关系型数据库的扩展根据需要进行扩展。&lt;/p&gt;&lt;p&gt;当然Giffin也不是万能的，目前Griffin还是有很多的问题的，选择也要慎重：&lt;/p&gt;&lt;p&gt;Griffin的社区并不太活跃，可以共同讨论的人不多。&lt;/p&gt;&lt;p&gt;目前最新版本还是0.6，可能会有一些问题。&lt;/p&gt;&lt;p&gt;网上技术文档很少，当然这方面大数据流动也会不断的输出新的技术文档帮助大家。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;三、Griffin架构&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据质量模块是大数据平台中必不可少的一个功能组件，以下Griffin作为一个开源的大数据数据质量解决方案，它支持批处理和流模式两种数据质量检测方式，可以从不同维度（比如离线任务执行完毕后检查源端和目标端的数据数量是否一致、源表的数据空值数量等）度量数据资产，从而提升数据的准确度、可信度。&lt;/p&gt;&lt;p&gt;在Griffin的架构中，主要分为Define、Measure和Analyze三个部分，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.58578856152513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEX4E3QQH1cy6AQYp5dZPXOf3E7PyzemJ4zMtkg1XtQ0yib54Uy0ic1k6DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;p&gt;各部分的职责如下：&lt;/p&gt;&lt;p&gt;听起来有些晦涩，我们来看一下一个完整的Griffin任务的执行流程。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;js_asyningdom rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXWD56Y6AB2jNibUCxbnc7LUj80pPC8BMCiaz45Nwj8GBpJSOlhL0GpOMw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;Griffin 系统主要分为：数据收集处理层（Data Collection&amp;amp;Processing Layer）、后端服务层（Backend Service Layer）和用户界面（User Interface）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.300420168067227&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXv8K6zFlAibuAyib8Kqib5yVCZpnpqCF4hcd3Df548UOauonsQxIA5of2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据处理和存储层：&lt;/p&gt;&lt;p&gt;对于批量分析，数据质量模型将根据 hadoop 中的数据源计算 Spark 集群中的数据质量指标。&lt;/p&gt;&lt;p&gt;对于近实时分析，使用来自消息传递系统的数据，然后数据质量模型将基于 Spark 集群计算实时数据质量指标。对于数据存储，可以在后端使用Elasticsearch来满足前端请求。&lt;/p&gt;&lt;p&gt;Apache Griffin 服务：&lt;/p&gt;&lt;p&gt;项目有提供Restful 服务来完成 Apache Griffin 的所有功能，例如探索数据集、创建数据质量度量、发布指标、检索指标、添加订阅等。因此，开发人员可以基于这些 Web 开发自己的用户界面服务。&lt;/p&gt;&lt;p&gt;这种灵活性也让Griffin 得到了越来越多的应用。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;四、Griffin快速入门&lt;/h2&gt;&lt;p&gt;Griffin的最新版本为0.6.0，本文的安装部署也基于这个版本进行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6145092460881935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXNqRfxlBoQVC8TYgcdzas1WWeXGjPOuXibmzIduTEicKctoJib5yIhuxsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/p&gt;&lt;h4&gt;依赖准备&lt;/h4&gt;&lt;p&gt;JDK (1.8 or later versions)&lt;br/&gt;MySQL(version 5.6及以上)&lt;br/&gt;Hadoop (2.6.0 or later)&lt;br/&gt;Hive (version 2.x)&lt;br/&gt;Spark (version 2.2.1)&lt;br/&gt;Livy（livy-0.5.0-incubating）&lt;br/&gt;ElasticSearch (5.0 or later versions)&lt;/p&gt;&lt;p&gt;大部分CDH已经自带，这里特别说一下Livy和ElasticSearch如何部署。&lt;/p&gt;&lt;p&gt;Livy是一个Spark的Rest服务器。&lt;/p&gt;&lt;p&gt;https://livy.apache.org/&lt;/p&gt;&lt;p&gt;准备livy安装包。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将livy安装包解压到/opt/目录下&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;创建livy用户、log目录并将livy的home目录属主修改为livy:hadoop&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;useradd livy -g hadoop&lt;span&gt;mkdir&lt;/span&gt; /var/log/livy&lt;span&gt;mkdir&lt;/span&gt; /var/run/livy&lt;span&gt;chown&lt;/span&gt; livy:hadoop /var/log/livy&lt;span&gt;chown&lt;/span&gt; livy:hadoop /var/run/livy&lt;span&gt;chown&lt;/span&gt; -R livy:hadoop /opt/cloudera/apache-livy-0.6.0-incubating-bin/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.进入livy home目录，在conf目录下创建livy.conf、livy-env.sh、spark-blacklist.conf配置文件&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;livy.conf、livy-env.&lt;span&gt;sh、spark-blacklist.conf&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.修改配置文件livy.conf，添加如下内容&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;livy.&lt;span&gt;spark&lt;/span&gt;.&lt;span&gt;master&lt;/span&gt; = yarn&lt;br/&gt;livy.&lt;span&gt;spark&lt;/span&gt;.&lt;span&gt;deployMode&lt;/span&gt; = cluster&lt;br/&gt;livy.&lt;span&gt;environment&lt;/span&gt; = production&lt;br/&gt;livy.&lt;span&gt;impersonation&lt;/span&gt;.&lt;span&gt;enabled&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;csrf_protection&lt;/span&gt;.&lt;span&gt;enabled&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;port&lt;/span&gt; = &lt;span&gt;8998&lt;/span&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;session&lt;/span&gt;.&lt;span&gt;timeout&lt;/span&gt; = &lt;span&gt;3600000&lt;/span&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;recovery&lt;/span&gt;.&lt;span&gt;mode&lt;/span&gt; = recovery&lt;br/&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;recovery&lt;/span&gt;.&lt;span&gt;state&lt;/span&gt;-store=filesystem&lt;br/&gt;livy.&lt;span&gt;server&lt;/span&gt;.&lt;span&gt;recovery&lt;/span&gt;.&lt;span&gt;state&lt;/span&gt;-store.&lt;span&gt;url&lt;/span&gt;=&lt;span&gt;/tmp/&lt;/span&gt;livy&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.修改配置文件livy-env.sh，增加hadoop和Spark的配置信息，如下&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;JAVA_HOME&lt;/span&gt;=&lt;span&gt;/usr/&lt;/span&gt;java/jdk1&lt;span&gt;.8&lt;/span&gt;&lt;span&gt;.0_181&lt;/span&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;HADOOP_HOME&lt;/span&gt;=&lt;span&gt;/opt/&lt;/span&gt;cloudera/parcels/&lt;span&gt;CDH&lt;/span&gt;/lib/hadoop&lt;span&gt;export&lt;/span&gt; &lt;span&gt;SPARK_CONF_DIR&lt;/span&gt;=&lt;span&gt;/etc/&lt;/span&gt;spark2/conf&lt;span&gt;export&lt;/span&gt; &lt;span&gt;SPARK_HOME&lt;/span&gt;=&lt;span&gt;/opt/&lt;/span&gt;cloudera/parcels/&lt;span&gt;SPARK2&lt;/span&gt;-&lt;span&gt;2.3&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;.&lt;span&gt;cloudera2&lt;/span&gt;-&lt;span&gt;1.&lt;/span&gt;cdh6&lt;span&gt;.3&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;.&lt;span&gt;p0&lt;/span&gt;&lt;span&gt;.1041012&lt;/span&gt;/lib/spark2&lt;span&gt;export&lt;/span&gt; &lt;span&gt;HADOOP_CONF_DIR&lt;/span&gt;=&lt;span&gt;/etc/&lt;/span&gt;hadoop/conf&lt;span&gt;export&lt;/span&gt; &lt;span&gt;LIVY_LOG_DIR&lt;/span&gt;=&lt;span&gt;/var/&lt;/span&gt;log/livy&lt;span&gt;export&lt;/span&gt; &lt;span&gt;LIVY_PID_DIR&lt;/span&gt;=&lt;span&gt;/var/&lt;/span&gt;run/livy&lt;span&gt;export&lt;/span&gt; &lt;span&gt;LIVY_SERVER_JAVA_OPTS&lt;/span&gt;=&lt;span&gt;&quot;-Xmx2g&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6.修改配置文件spark-blacklist.conf&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;# Configuration override / blacklist. Defines a list of properties that users are not allowed&lt;/span&gt;&lt;span&gt;# to override when starting Spark sessions.&lt;/span&gt;#&lt;span&gt;# This file takes a list of property names (one per line). Empty lines and lines starting with &quot;#&quot;&lt;/span&gt;&lt;span&gt;# are ignored.&lt;/span&gt;#&lt;span&gt;# Disallow overriding the master and the deploy mode.&lt;/span&gt;spark.master&lt;br/&gt;spark.&lt;span&gt;submit.deployMode&lt;/span&gt;&lt;span&gt;# Disallow overriding the location of Spark cached jars.&lt;/span&gt;spark.yarn.&lt;span&gt;jar&lt;/span&gt;spark.yarn.&lt;span&gt;jars&lt;/span&gt;spark.yarn.archive&lt;span&gt;# Don&#x27;t allow users to override the RSC timeout.&lt;/span&gt;livy.rsc.server.idle-timeout&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;core-site.xml 的群集范围高级配置代码段（安全阀）”配置项增加如下内容&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hadoop.proxyuser.livy.groups&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;hadoop.proxyuser.livy.hosts&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;*&lt;span&gt;&amp;lt;/&lt;span&gt;value&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;property&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;8.在HDFS上创建livy的home目录&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;sudo -u hdfs hadoop fs -&lt;span&gt;mkdir&lt;/span&gt; /user/livy&lt;br/&gt;sudo -u hdfs hadoop fs -&lt;span&gt;chown&lt;/span&gt; livy:supergroup /user/livy&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;9、启动livy服务&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;livy&lt;span&gt;-&lt;/span&gt;server &lt;span&gt;start&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;elasticsearch5安装，安装包也已下载在资料包中。&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt; wget &lt;span&gt;https:&lt;/span&gt;/&lt;span&gt;/artifacts.elastic.co/downloads&lt;/span&gt;&lt;span&gt;/elasticsearch/elasticsearch&lt;/span&gt;-&lt;span&gt;5.6&lt;/span&gt;.&lt;span&gt;15&lt;/span&gt;.tar.gz&lt;span&gt;# tar -zxvf elasticsearch-5.6.15&lt;/span&gt;&lt;span&gt;# cd elasticsearch-5.6.15&lt;/span&gt;&lt;span&gt;# sh ./bin/elasticsearch&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;配置准备&lt;/h4&gt;&lt;p&gt;1、首先在mysql中初始化quartz数据库，这里需要用到脚本Init_quartz_mysql_innodb.sql。&lt;/p&gt;&lt;p&gt;脚本可以加griffin群，领取资料包下载。&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;mysql -u &lt;span&gt;&amp;lt;&lt;span&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt; -p &lt;span&gt;&amp;lt;&lt;span&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt; &amp;lt; Init_quartz_mysql_innodb.sql&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、Hadoop和Hive：&lt;/p&gt;&lt;p&gt;从Hadoop服务器拷贝配置文件到Livy服务器上，这里假设将配置文件放在/usr/data/conf目录下。&lt;/p&gt;&lt;p&gt;在Hadoop服务器上创建/home/spark_conf目录，并将Hive的配置文件hive-site.xml上传到该目录下：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;#创建/home/spark_conf目录&lt;/span&gt;hadoop fs -&lt;span&gt;mkdir&lt;/span&gt; -p /home/spark_conf&lt;span&gt;#上传hive-site.xml&lt;/span&gt;hadoop fs -put hive-site.xml /home/spark_conf/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、设置环境变量：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;#!/bin/bash&lt;/span&gt;&lt;span&gt;export&lt;/span&gt; JAVA_HOME=/data/jdk1.8.0_192&lt;span&gt;#spark目录&lt;/span&gt;&lt;span&gt;export&lt;/span&gt; SPARK_HOME=/usr/data/spark-2.1.1-bin-2.6.3&lt;span&gt;#livy命令目录&lt;/span&gt;&lt;span&gt;export&lt;/span&gt; LIVY_HOME=/usr/data/livy/bin&lt;span&gt;#hadoop配置文件目录&lt;/span&gt;&lt;span&gt;export&lt;/span&gt; HADOOP_CONF_DIR=/usr/data/conf&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4、配置启动Livy&lt;/p&gt;&lt;p&gt;更新livy/conf下的livy.conf配置文件：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;livy.server.host&lt;/span&gt; = &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;livy.spark.master&lt;/span&gt; = yarn&lt;span&gt;livy.spark.deployMode&lt;/span&gt; = cluster&lt;span&gt;livy.repl.enable-hive-context&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;启动livy：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;livy&lt;span&gt;-&lt;/span&gt;server &lt;span&gt;start&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5、Elasticsearch配置：&lt;/p&gt;&lt;p&gt;在ES里创建griffin索引：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;curl -XPUT http:&lt;span&gt;//es:9200/griffin -d &#x27;&lt;/span&gt;{    &lt;span&gt;&quot;aliases&quot;&lt;/span&gt;: {},    &lt;span&gt;&quot;mappings&quot;&lt;/span&gt;: {        &lt;span&gt;&quot;accuracy&quot;&lt;/span&gt;: {            &lt;span&gt;&quot;properties&quot;&lt;/span&gt;: {                &lt;span&gt;&quot;name&quot;&lt;/span&gt;: {                    &lt;span&gt;&quot;fields&quot;&lt;/span&gt;: {                        &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;: {                            &lt;span&gt;&quot;ignore_above&quot;&lt;/span&gt;: &lt;span&gt;256&lt;/span&gt;,                            &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    },                    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;text&quot;&lt;/span&gt;&lt;br/&gt;                },                &lt;span&gt;&quot;tmst&quot;&lt;/span&gt;: {                    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;date&quot;&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    },    &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {        &lt;span&gt;&quot;index&quot;&lt;/span&gt;: {            &lt;span&gt;&quot;number_of_replicas&quot;&lt;/span&gt;: &lt;span&gt;&quot;2&quot;&lt;/span&gt;,            &lt;span&gt;&quot;number_of_shards&quot;&lt;/span&gt;: &lt;span&gt;&quot;5&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来进行源码编译打包。&lt;/p&gt;&lt;p&gt;Griffin的源码结构很清晰，主要包括griffin-doc、measure、service和ui四个模块，其中griffin-doc负责存放Griffin的文档，measure负责与spark交互，执行统计任务，service使用spring boot作为服务实现，负责给ui模块提供交互所需的restful api，保存统计任务，展示统计结果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXKY0Pl53zgJC5ib1StBFticoc6yfxLk3POXcsRsZvmBghfPYy1qvVUDiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/p&gt;&lt;p&gt;源码导入构建完毕后，需要修改配置文件，具体修改的配置文件如下：&lt;/p&gt;&lt;p&gt;application.properties：mysql，hive，es配置&lt;/p&gt;&lt;p&gt;quartz.properties&lt;/p&gt;&lt;p&gt;sparkProperties.json&lt;/p&gt;&lt;p&gt;配置文件修改好后，在idea里的terminal里执行如下maven命令进行编译打包：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;mvn -Dmaven.&lt;span&gt;test&lt;/span&gt;.skip=&lt;span&gt;true&lt;/span&gt; clean &lt;span&gt;install&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令执行完成后，会在service和measure模块的target目录下分别看到service-0.6.0.jar和measure-0.6.0.jar两个jar，将这两个jar分别拷贝到服务器目录下。&lt;/p&gt;&lt;p&gt;1、使用如下命令将measure-0.4.0.jar这个jar上传到HDFS的/griffin文件目录里：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;#改变jar名称&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; &lt;span&gt;measure-0&lt;/span&gt;.&lt;span&gt;6.0&lt;/span&gt;.jar griffin&lt;span&gt;-measure&lt;/span&gt;.jar&lt;span&gt;#上传griffin-measure.jar到HDFS文件目录里&lt;/span&gt;hadoop fs &lt;span&gt;-put&lt;/span&gt; &lt;span&gt;measure-0&lt;/span&gt;.&lt;span&gt;6.0&lt;/span&gt;.jar /griffin/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、运行service-0.6.0.jar，启动Griffin管理后台：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;nohup &lt;span&gt;java &lt;/span&gt;-&lt;span&gt;jar &lt;/span&gt;service&lt;span&gt;-0&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;jar&amp;gt;service.out &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&amp;gt;&amp;amp;&lt;span&gt;1&lt;/span&gt; &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;几秒钟后，我们可以访问Apache Griffin的默认UI(默认情况下，spring boot的端口是8080)。&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;http:&lt;span&gt;//IP:8080&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;部分结果展示界面如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675824175824175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXpaQMUIiayheiaXmPW7HyXsKh7v35hrKFQNWSzK79KGGxwcKicSiaxVePMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2184&quot;/&gt;&lt;/p&gt;&lt;h2&gt;五、Griffin批数据实战&lt;/h2&gt;&lt;p&gt;官网给出了批处理数据的例子。&lt;/p&gt;&lt;p&gt;1、在hive里创建表demo_src和demo_tgt：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;--create hive tables here. hql script&lt;/span&gt;&lt;span&gt;--&lt;span&gt;Note:&lt;/span&gt; replace hdfs location with your own path&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;EXTERNAL&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `demo_src`(&lt;br/&gt;  `id` &lt;span&gt;bigint&lt;/span&gt;,&lt;br/&gt;  `age` &lt;span&gt;int&lt;/span&gt;,&lt;br/&gt;  `&lt;span&gt;desc&lt;/span&gt;` string) &lt;br/&gt;PARTITIONED &lt;span&gt;BY&lt;/span&gt; (&lt;br/&gt;  `dt` string,&lt;br/&gt;  `&lt;span&gt;hour&lt;/span&gt;` string)&lt;span&gt;ROW&lt;/span&gt; FORMAT DELIMITED&lt;br/&gt;  FIELDS TERMINATED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;&#x27;|&#x27;&lt;/span&gt;LOCATION  &lt;span&gt;&#x27;hdfs:///griffin/data/batch/demo_src&#x27;&lt;/span&gt;;&lt;span&gt;--&lt;span&gt;Note:&lt;/span&gt; replace hdfs location with your own path&lt;/span&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;EXTERNAL&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; `demo_tgt`(&lt;br/&gt;  `id` &lt;span&gt;bigint&lt;/span&gt;,&lt;br/&gt;  `age` &lt;span&gt;int&lt;/span&gt;,&lt;br/&gt;  `&lt;span&gt;desc&lt;/span&gt;` string) &lt;br/&gt;PARTITIONED &lt;span&gt;BY&lt;/span&gt; (&lt;br/&gt;  `dt` string,&lt;br/&gt;  `&lt;span&gt;hour&lt;/span&gt;` string)&lt;span&gt;ROW&lt;/span&gt; FORMAT DELIMITED&lt;br/&gt;  FIELDS TERMINATED &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;&#x27;|&#x27;&lt;/span&gt;LOCATION  &lt;span&gt;&#x27;hdfs:///griffin/data/batch/demo_tgt&#x27;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、生成测试数据：&lt;/p&gt;&lt;p&gt;从http://griffin.apache.org/data/batch/地址下载所有文件到Hadoop服务器上，然后使用如下命令执行gen-hive-data.sh脚本：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;nohup&lt;/span&gt; ./gen-hive-data.sh&amp;gt;gen.out 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意观察gen.out日志文件，如果有错误，视情况进行调整。这里我的测试环境Hadoop和Hive安装在同一台服务器上，因此直接运行脚本。&lt;/p&gt;&lt;p&gt;3、通过UI界面创建统计任务&lt;/p&gt;&lt;p&gt;选择DataAssets&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7009345794392523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXPl9ZjUHGKysHGQyrYeNpXKjuibuoZdgpWMCL1eiczT8blFeALqIWBHUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;214&quot;/&gt;&lt;/p&gt;&lt;p&gt;在该页面可以看到数据资产展示&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14932562620423892&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXoWibBP5D7NOGERFB5M0FyyreldqWcos8uDYOFdMZWopQ7YECgIFF2Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;&lt;/p&gt;&lt;p&gt;点击Measures，创建度量页面&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17349857006673022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXObVD5lLoSmOubO3AWG2heKOQJibMJYWooVS9FiacgrKmvvKhnKECB8oA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1049&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过下面的步骤来一步步创建&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2739420935412027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXWUsZgWsULI1n8n3L7Av74nkh6MMmkRxs7cE6ubaZjSp2qicnU3zfnzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;449&quot;/&gt;&lt;/p&gt;&lt;p&gt;选择数据源&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.559610705596107&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXjXp1paxBD6bfRgrNlKbqpZ1c65Q3nLtVkV1PvsjibjE9dPzbAMicHQnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;p&gt;选择目标&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5567765567765568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXhVqicswVK3sk7JSxw4Uu54nwOeJKN7OkmwATib96f1icTK7HLPceYNrKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/p&gt;&lt;p&gt;将两者关联&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5726817042606517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXBWCEQoOWeKCHNoeA68hUiaHBehGhlDMJoAJbk1juatS8KnWHv6h5ArA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/p&gt;&lt;p&gt;设置一些参数&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5698529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXpcicZkgf4D5abD2KDHwFymibOejuFhcdSna5ylTCOWXnBkSS5GPn08HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;p&gt;配置好提交&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5687732342007435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXrLa2kNjOzEnGvgz1GQMKQhZJZOpDxMXFdzsppoic07qcqTdviaibrJuyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/p&gt;&lt;p&gt;新增定时任务&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18877551020408162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXIZZlRk9oyjbriaLicloomDrhNDN22FEVZnN7heibqlO81s7mDYGJiaTEMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;p&gt;用cron表达式建立任务&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6745932415519399&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXv1FTicbcc9TLYia4NlkcBf6dWtouRNnlTk5coNpdSKSia9Zs83s2xakbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;799&quot;/&gt;&lt;/p&gt;&lt;p&gt;点击DQ Metrics，看到效果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9774696707105719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXL9NTg6IuNatrYD5ukbTjrT7vTIgRSJo93EiartGysXxIgtyXLx9piclw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;六、Griffin流数据实战&lt;/h2&gt;&lt;p&gt;还会参考官网的例子。&lt;/p&gt;&lt;p&gt;示例流数据如下：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Apple&quot;&lt;/span&gt;, &lt;span&gt;&quot;color&quot;&lt;/span&gt;: &lt;span&gt;&quot;red&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;: &lt;span&gt;&quot;2018-09-12_06:00:00&quot;&lt;/span&gt;}&lt;br/&gt;{&lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Banana&quot;&lt;/span&gt;, &lt;span&gt;&quot;color&quot;&lt;/span&gt;: &lt;span&gt;&quot;yellow&quot;&lt;/span&gt;, &lt;span&gt;&quot;time&quot;&lt;/span&gt;: &lt;span&gt;&quot;2018-09-12_06:01:00&quot;&lt;/span&gt;}&lt;br/&gt;...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;官方也提供了测试数据的脚本https://griffin.apache.org/data/streaming/（已存资料包）&lt;/p&gt;&lt;p&gt;通过脚本可以源源不断将数据写入Kafka&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;#!/bin/bash&lt;/span&gt;&lt;span&gt;#create topics&lt;/span&gt;kafka-topics.sh --create --zookeeper hadoop101:2181 --replication-factor 1 --partitions 1 --topic &lt;span&gt;source&lt;/span&gt;kafka-topics.sh --create --zookeeper hadoop101:2181 --replication-factor 1 --partitions 1 --topic target&lt;span&gt;#every minute&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; +e&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;br/&gt;  /opt/module/data/gen-data.sh  &lt;span&gt;sleep&lt;/span&gt; 90&lt;span&gt;done&lt;/span&gt;&lt;span&gt;set&lt;/span&gt; -e&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Flink部分就是简单接收Kafka数据，然后再发向下游，部分代码片段如下：&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();&lt;br/&gt;FlinkKafkaConsumer010&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; kafkaconsumer =                &lt;span&gt;new&lt;/span&gt; FlinkKafkaConsumer010&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(inputTopic, &lt;span&gt;new&lt;/span&gt; SimpleStringSchema(), properties);&lt;br/&gt;        DataStream&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; dataStream = env.addSource(kafkaconsumer);&lt;br/&gt;&lt;br/&gt;DataStream&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; target = dataStream.add...&lt;span&gt;//具体处理逻辑&lt;/span&gt;target..addSink(&lt;span&gt;new&lt;/span&gt; FlinkKafkaProducer010&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(                &lt;span&gt;&quot;hadoop101:9092&quot;&lt;/span&gt;,                &lt;span&gt;&quot;target&quot;&lt;/span&gt;,                &lt;span&gt;new&lt;/span&gt; SimpleStringSchema()&lt;br/&gt;        ));&lt;br/&gt;        outMap.&lt;span&gt;print&lt;/span&gt;();&lt;br/&gt;        env.execute();&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配合env.json&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;spark&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;log.level&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;WARN&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;checkpoint.dir&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;hdfs:///griffin/checkpoint&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;batch.interval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;20s&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;process.interval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;1m&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;init.clear&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.default.parallelism&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.task.maxFailures&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.streaming.kafkaMaxRatePerPartition&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.streaming.concurrentJobs&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.yarn.maxAppAttempts&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.yarn.am.attemptFailuresValidityInterval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;1h&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.yarn.max.executor.failures&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;120&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.yarn.executor.failuresValidityInterval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;1h&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;spark.hadoop.fs.hdfs.impl.disable.cache&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;sinks&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;console&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;hdfs&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;hdfs:///griffin/persist&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;elasticsearch&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;method&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;post&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;api&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;http://es:9200/griffin/accuracy&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;griffin.checkpoint&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;zk&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;hosts&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;zk:2181&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;griffin/infocache&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;lock.path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;lock&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;mode&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;persist&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;init.clear&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;close.clear&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;dq.json&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;streaming_accu&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;process.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;streaming&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;data.sources&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;src&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;baseline&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;connectors&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;kafka&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;version&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0.8&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;kafka.config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;kafka:9092&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;group.id&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;griffin&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;auto.offset.reset&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;largest&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;auto.commit.enable&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;topics&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;source&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;key.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;value.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;pre.proc&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;dsl.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;df-opr&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;rule&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;from_json&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;checkpoint&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;json&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;file.path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;hdfs:///griffin/streaming/dump/source&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;info.path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;source&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;ready.time.interval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;10s&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;ready.time.delay&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;time.range&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;-5m&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;updatable&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;tgt&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;connectors&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;kafka&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;version&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0.8&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;kafka.config&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;bootstrap.servers&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;kafka:9092&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;group.id&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;griffin&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;auto.offset.reset&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;largest&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;auto.commit.enable&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;false&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;topics&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;target&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;key.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;value.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;java.lang.String&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;pre.proc&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;dsl.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;df-opr&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&quot;rule&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;from_json&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;checkpoint&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;json&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;file.path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;hdfs:///griffin/streaming/dump/target&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;info.path&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;target&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;ready.time.interval&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;10s&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;ready.time.delay&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;time.range&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;-1m&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;]&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;evaluate.rule&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;rules&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;dsl.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;griffin-dsl&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;dq.type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;accuracy&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;out.dataframe.name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;accu&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;rule&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;src.id = tgt.id AND src.name = tgt.name AND src.color = tgt.color AND src.time = tgt.time&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;details&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;source&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;src&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;target&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;tgt&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;miss&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;miss_count&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;total&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;total_count&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;matched&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;matched_count&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;out&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;metric&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;accu&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;type&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;record&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;missRecords&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;sinks&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;CONSOLE&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;HDFS&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提交任务&lt;/p&gt;&lt;pre data-highlight-status=&quot;highlighted&quot;&gt;&lt;code&gt;spark-submit &lt;span&gt;--class&lt;/span&gt; org&lt;span&gt;.apache&lt;/span&gt;&lt;span&gt;.griffin&lt;/span&gt;&lt;span&gt;.measure&lt;/span&gt;&lt;span&gt;.Application&lt;/span&gt; &lt;span&gt;--master&lt;/span&gt; yarn &lt;span&gt;--deploy-mode&lt;/span&gt; client &lt;span&gt;--queue&lt;/span&gt; default \&lt;span&gt;--driver-memory&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;g &lt;span&gt;--executor-memory&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;g &lt;span&gt;--num-executors&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; \&lt;br/&gt;&amp;lt;path&amp;gt;/griffin-measure&lt;span&gt;.jar&lt;/span&gt; \&lt;br/&gt;&amp;lt;path&amp;gt;/env&lt;span&gt;.json&lt;/span&gt; &amp;lt;path&amp;gt;/dq&lt;span&gt;.json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;七、总结&lt;/h2&gt;&lt;p&gt;数据管理工具目前来说还是非常匮乏的，Griffin提供的不仅仅是实现，还有数据质量管理的思路，这对于我们自研数据质量管理系统也是非常的宝贵的。&lt;/p&gt;&lt;p&gt;数据治理道路任重道远，欢迎加入相关交流群，我们共同学习进步~&lt;/p&gt;&lt;p&gt;进入学习交流群领取学习资料包：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3138586956521739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEX0ibop0xFDmHqYlXD4QBKIrNmoqdq5mINibGompSqccrdey0jSViarLSPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了更专注效率才能更高，目前数据治理相关学习交流群按不同方向做了区分，欢迎扫码加入：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5587266739846323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEXuzWp6D1eIp3R7CwppujNz52NExCWibFZ9tFZCrJ4YP2ANpGV6oiaSv5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外 &lt;strong&gt;数据治理工具箱&lt;/strong&gt; 知识星球也已成立，这是一个数据治理落地实践方向的知识星球。大数据流动发布的数据治理相关文章与资料（包括付费内容）都将在知识星球进行&lt;strong&gt;长期同步&lt;/strong&gt;。星球的目标是收集数据治理实践工具的相关资料，并定期组织实战学习小组，让数据治理的相关资料可以长久的保存，同时也解决文章被频繁抄袭的问题，欢迎大家加入。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.531523642732049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mqibsuEhdUyK6vzupmxrtM2QXTouwZicEX3QiamLzicT3I0YXYkcY1lWn1NJaEevibf9n3u71Q8VAVMLdjY0JJRRE3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后提醒，文档版权为公众号 &lt;strong&gt;大数据流动&lt;/strong&gt; 所有，请勿商用。相关技术问题以及安装包可以联系笔者&lt;strong&gt;独孤风&lt;/strong&gt;加入相关技术交流群讨论获取。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>