<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>92f47082e1e161b20337c0751c5b006d</guid>
<title>京东面试：MQ 消息丢失、重复、积压问题，如何解决？</title>
<link>https://toutiao.io/k/1unx53z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官在面试候选人时，如果发现候选人的简历中写了在项目中使用了&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MQ 技术（如 Kafka、RabbitMQ、RocketMQ），基本都会抛出一个问题：在使用 MQ 的时候，怎么确保消息 100% 不丢失？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在实际工作中很常见，既能考察候选者对于 MQ 中间件技术的掌握程度，又能很好地区分候选人的能力水平。接下来，我们就从这个问题出发，探讨你应该掌握的基础知识和答题思路，以及延伸的面试考点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以京东系统为例，用户在购买商品时，通常会选择用京豆抵扣一部分的金额，在这个过程中，交易服务和京豆服务通过 MQ 消息队列进行通信。在下单时，交易服务发送“扣减账户 X 100 个京豆”的消息给 MQ 消息队列，而京豆服务则在消费端消费这条命令，实现真正的扣减操作。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18796296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaOLG75wzrQhoHvvjich4uzuzbsJkTkreibEWhu1XxTMy2QJPryDzxSnQA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;那在这个过程中你会遇到什么问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例分析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要知道，在互联网面试中，引入 MQ 消息中间件最直接的目的是：做系统解耦合流量控制，追其根源还是为了解决互联网系统的高可用和高性能问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;系统解耦：&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用MQ消息队列，可以隔离系统上下游环境变化带来的不稳定因素，比如京豆服务的系统需求无论如何变化，交易服务不用做任何改变，即使当京豆服务出现故障，主交易流程也可以将京豆服务降级，实现交易服务和京豆服务的解耦，做到了系统的高可用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;流量控制：&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;遇到秒杀等流量突增的场景，通过 MQ 还可以实现流量的“削峰填谷”的作用，可以根据下游的处理能力自动调节流量。不过引入 MQ虽然实现了系统解耦合流量控制，也会带来其他问题。&lt;/p&gt;&lt;p&gt;引入 MQ 消息中间件实现系统解耦，会影响系统之间数据传输的一致性。&lt;br/&gt;在分布式系统中，如果两个节点之间存在数据同步，就会带来数据一致性的问题。同理，在这一讲你要解决的就是：消息生产端和消息消费端的消息数据一致性问题（也就是如何确保消息不丢失）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而引入MQ 消息中间件解决流量控制， 会使消费端处理能力不足从而导致消息积压，这也是你要解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你能发现，问题与问题之间往往是环环相扣的，面试官会借机考察你解决问题思路的连贯性和知识体系的掌握程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那面对“在使用 MQ 消息队列时，如何确保消息不丢失”这个问题时，你要怎么回答呢？首先，你要分析其中有几个考点，比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何知道有消息丢失？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哪些环节可能丢消息？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何确保消息不丢失？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;候选人在回答时，要先让面试官知道你的分析思路，然后再提供解决方案：网络中的数据传输不可靠，想要解决如何不丢消息的问题，首先要知道哪些环节可能丢消息，以及我们如何知道消息是否丢失了，最后才是解决方案（而不是上来就直接说自己的解决方案）。就好比“架构设计”“架构”体现了架构师的思考过程，而“设计”才是最后的解决方案，两者缺一不可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例解答&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看消息丢失的环节，一条消息从生产到消费完成这个过程，可以划分三个阶段，分别为消息生产阶段，消息存储阶段和消息消费阶段。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18796296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaOLG75wzrQhoHvvjich4uzuzbsJkTkreibEWhu1XxTMy2QJPryDzxSnQA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;strong&gt;消息生产阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack&lt;br/&gt;确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息存储阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回ack。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息消费阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给&lt;br/&gt;Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案看似万无一失，每个阶段都能保证消息的不丢失，但在分布式系统中，故障不可避免，作为消息生产端，你并不能保证 MQ 是不是弄丢了你的消息，消费者是否消费了你的消息，所以，本着 Design for Failure 的设计原则，你还是需要一种机制，来 Check 消息是否丢失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;紧接着，你还可以向面试官阐述怎么进行消息检测？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;总体方案解决思路为：在消息生产端，给每个发出的消息都指定一个全局唯一 ID，或者附加一个连续递增的版本号，然后在消费端做对应的版本校验。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具体怎么落地实现呢？&lt;/strong&gt;&lt;br/&gt;你可以利用拦截器机制。在生产端发送消息之前，通过拦截器将消息版本号注入消息中（版本号可以采用连续递增的 ID 生成，也可以通过分布式全局唯一 ID生成）。然后在消费端收到消息后，再通过拦截器检测版本号的连续性或消费状态，这样实现的好处是消息检测的代码不会侵入到业务代码中，可以通过单独的任务来定位丢失的消息，做进一步的排查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里需要你注意：&lt;/strong&gt;&lt;br/&gt;如果同时存在多个消息生产端和消息消费端，通过版本号递增的方式就很难实现了，因为不能保证版本号的唯一性，此时只能通过全局唯一 ID 的方案来进行消息检测，具体的实现原理和版本号递增的方式一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你已经知道了哪些环节（消息存储阶段、消息消费阶段）可能会出问题，并有了如何检测消息丢失的方案，然后就要给出解决防止消息丢失的设计方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回答完“如何确保消息不会丢失？” 之后，面试官通常会追问“怎么解决消息被重复消费的问题？”&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：在消息消费的过程中，如果出现失败的情况，通过补偿的机制发送方会执行重试，重试的过程就有可能产生重复的消息，那么如何解决这个问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实可以换一种说法，就是如何解决消费端幂等性问题（幂等性，就是一条命令，任意多次执行所产生的影响均与一次执行的影响相同），只要消费端具备了幂等性，那么重复消费消息的问题也就解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是来看扣减京豆的例子，将账户 X 的金豆个数扣减 100 个，在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41944444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaZNUNRyiciciclojurMAM20Leq7gFJYciby5IiaVRv4oWzKNI02yXiclmfsow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;strong&gt;最简单的实现方案，就是在数据库中建一张消息日志表，&lt;/strong&gt;&lt;br/&gt;这个表有两个字段：消息 ID 和消息执行状态。这样，我们消费消息的逻辑可以变为：在消息日志表中增加一条消息记录，然后再根据消息记录，异步操作更新用户京豆余额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们每次都会在插入之前检查是否消息已存在，所以就不会出现一条消息被执行多次的情况，这样就实现了一个幂等的操作。当然，基于这个思路，不仅可以使用关系型数据库，也可以通过 Redis 来代替数据库实现唯一约束的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我多说一句，想要解决“消息丢失”和“消息重复消费”的问题，有一个前提条件就是要实现一个全局唯一 ID 生成的技术方案。这也是面试官喜欢考察的问题，你也要掌握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，全局唯一 ID 生成的实现方法有数据库自增主键、UUID、Redis，Twitter-Snowflake 算法，我总结了几种方案的特点，你可以参考下。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4564814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaZol162ib2Gv7XGLIyYUkwaH8oAlcGU7PXb9pznnzJ53vWq8zCnapkWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;我提醒你注意，无论哪种方法，如果你想同时满足简单、高可用和高性能，就要有取舍，所以你要站在实际的业务中，说明你的选型所考虑的平衡点是什么。我个人在业务中比较倾向于选择 Snowflake 算法，在项目中也进行了一定的改造，主要是让算法中的 ID 生成规则更加符合业务特点，以及优化诸如时钟回拨等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当然，除了“怎么解决消息被重复消费的问题？”之外，面试官还会问到你“消息积压”。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原因在于消息积压反映的是性能问题，解决消息积压问题，可以说明候选者有能力处理高并发场景下的消费能力问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你在解答这个问题时，依旧要传递给面试官一个这样的思考过程：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果出现积压，那一定是性能问题，想要解决消息从生产到消费上的性能问题，就首先要知道哪些环节可能出现消息积压，然后在考虑如何解决。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为消息发送之后才会出现积压的问题，所以和消息生产端没有关系，又因为绝大部分的消息队列单节点都能达到每秒钟几万的处理能力，相对于业务逻辑来说，性能不会出现在中间件的消息存储上面。毫无疑问，出问题的肯定是消息消费阶段，&lt;br/&gt;&lt;strong&gt;那么从消费端入手，如何回答呢？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果是线上突发问题，要临时扩容，增加消费端的数量，与此同时，降级一些非核心的业务。通过扩容和降级承担流量，这是为了表明你对应急问题的处理能力。&lt;/p&gt;&lt;p&gt;其次，才是排查解决异常问题，如通过监控，日志等手段分析是否消费端的业务逻辑代码出现了问题，优化消费端的业务处理逻辑。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果是消费端的处理能力不足，可以通过水平扩容来提供消费端的并发处理能力&lt;br/&gt;&lt;strong&gt;但这里有一个考点需要特别注意，&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那就是在扩容消费者的实例数的同时，必须同步扩容主题 Topic&lt;br/&gt;的分区数量，确保消费者的实例数和分区数相等。如果消费者的实例数超过了分区数，由于分区是单线程消费，所以这样的扩容就没有效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Kafka 中，一个 Topic 可以配置多个 Partition（分区），数据会被写入到多个分区中，但在消费的时候，Kafka 约定一个分区只能被一个消费者消费，Topic 的分区数量决定了消费的能力，所以，可以通过增加分区来提高消费者的处理能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结 至此，我们讲解了 MQ 消息队列的热门问题的解决方案，无论是初中级还是高级研发工程师，本篇文章的内容都是你需要掌握的，你都可以从这几点出发，与面试官进行友好的交流。我来总结一下今天的重点内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何确保消息不会丢失？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你要知道一条消息从发送到消费的每个阶段，是否存在丢消息，以及如何监控消息是否丢失，最后才是如何解决问题，方案可以基于“ MQ 的可靠消息投递&lt;br/&gt;”的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何保证消息不被重复消费？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在进行消息补偿的时候，一定会存在重复消息的情况，那么如何实现消费端的幂等性就这道题的考点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何处理消息积压问题？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这道题的考点就是如何通过 MQ&lt;br/&gt;实现真正的高性能，回答的思路是，本着解决线上异常为最高优先级，然后通过监控和日志进行排查并优化业务逻辑，最后是扩容消费端和分片的数量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答问题的时候，你需要特别注意的是，让面试官了解到你的思维过程，这种解决问题的能力是面试官更为看中的，比你直接回答一道面试题更有价值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：一个天蝎座的程序猿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://blog.csdn.net/qq_45566762/article/details/123787373&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651517204&amp;amp;idx=2&amp;amp;sn=eb911348d66090f5af9af3eb74ebc0e9&amp;amp;chksm=bd259d6b8a52147d30997d8699b879fb3fb92d6866de454d67ce06ef05d910502e08431df942&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514792&amp;amp;idx=1&amp;amp;sn=765ef6d4c521d6a74d9e47e07999bf8f&amp;amp;chksm=bd258bd78a5202c1caf1ffa5e9de1db1b94b87b170e978b0c9c7da462f00d21782c47fe8ad2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;选 Redis 做 MQ 的人，是水平欠缺么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;选 Redis 做 MQ 的人，是水平欠缺么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>765e9c92bd42e03169403e5904b1731c</guid>
<title>面试官：Redis 大 key 要如何处理？</title>
<link>https://toutiao.io/k/adi7th7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：小林coding&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来聊聊，关于 Redis 大 key 的四个问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是 Redis 大 key？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大 key 会造成什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何找到大 key ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何删除大 key？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是 Redis 大 key？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，下面这两种情况被称为大 key：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;String 类型的值大于 10 KB；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash、List、Set、ZSet 类型的元素的个数超过 5000个；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大 key 会造成什么问题？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 key 会带来以下四种影响：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;客户端超时阻塞&lt;/strong&gt;。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;引发网络阻塞&lt;/strong&gt;。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;阻塞工作线程&lt;/strong&gt;。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存分布不均&lt;/strong&gt;。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何找到大 key ？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、redis-cli --bigkeys 查找大key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 redis-cli --bigkeys 命令查找大 key：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用的时候注意事项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方式的不足之处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、使用 SCAN 命令查找大 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于集合类型来说，有两种方法可以获得它占用的内存大小：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：&lt;code&gt;LLEN&lt;/code&gt; 命令；Hash 类型：&lt;code&gt;HLEN&lt;/code&gt; 命令；Set 类型：&lt;code&gt;SCARD&lt;/code&gt; 命令；Sorted Set 类型：&lt;code&gt;ZCARD&lt;/code&gt; 命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不能提前知道写入集合的元素大小，可以使用 &lt;code&gt;MEMORY USAGE&lt;/code&gt; 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、使用 RdbTools 工具查找大 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rdb dump.rdb -c memory --bytes 10240 -f redis.csv&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何删除大 key？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，删除大 key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、分批次删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 Hash&lt;/strong&gt;，使用 &lt;code&gt;hscan&lt;/code&gt; 命令，每次获取 100 个字段，再用 &lt;code&gt;hdel&lt;/code&gt; 命令，每次删除 1 个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_hash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;    large_hash_key =&lt;span&gt;&quot;xxx&quot;&lt;/span&gt; &lt;span&gt;#要删除的大hash键名&lt;/span&gt;&lt;br/&gt;    cursor = &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; cursor != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;# 使用 hscan 命令，每次获取 100 个字段&lt;/span&gt;&lt;br/&gt;        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; data.items():&lt;br/&gt;                &lt;span&gt;# 再用 hdel 命令，每次删除1个字段&lt;/span&gt;&lt;br/&gt;                r.hdel(large_hash_key, item[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 List&lt;/strong&gt;，通过 &lt;code&gt;ltrim&lt;/code&gt; 命令，每次删除少量元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_list_key = &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;  &lt;span&gt;#要删除的大list的键名&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; r.llen(large_list_key)&amp;gt;&lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;#每次只删除最右100个元素&lt;/span&gt;&lt;br/&gt;      r.ltrim(large_list_key, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;-101&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 Set&lt;/strong&gt;，使用 &lt;code&gt;sscan&lt;/code&gt; 命令，每次扫描集合中 100 个元素，再用 &lt;code&gt;srem&lt;/code&gt; 命令每次删除一个键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_set&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_set_key = &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;   &lt;span&gt;# 要删除的大set的键名&lt;/span&gt;&lt;br/&gt;  cursor = &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; cursor != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;# 使用 sscan 命令，每次扫描集合中 100 个元素&lt;/span&gt;&lt;br/&gt;    cursor, data = r.sscan(large_set_key, cursor=cursor, count=&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; data:&lt;br/&gt;      &lt;span&gt;# 再用 srem 命令每次删除一个键&lt;/span&gt;&lt;br/&gt;      r.srem(large_size_key, item)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 ZSet&lt;/strong&gt;，使用 &lt;code&gt;zremrangebyrank&lt;/code&gt; 命令，每次删除 top 100个元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_sortedset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;large_sortedset_key&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_sortedset_key=&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; r.zcard(large_sortedset_key)&amp;gt;&lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;# 使用 zremrangebyrank 命令，每次删除 top 100个元素&lt;/span&gt;&lt;br/&gt;    r.zremrangebyrank(large_sortedset_key,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、异步删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Redis 4.0 版本开始，可以采用&lt;strong&gt;异步删除&lt;/strong&gt;法，&lt;strong&gt;用 unlink 命令代替 del 来删除&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐阅读：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247518397&amp;amp;idx=1&amp;amp;sn=c75e71eca9127474d60d9ea9bdcb546a&amp;amp;chksm=f98dcc17cefa450181debb590e79958d247ef9ffbbb94a36f5726b19829eec598acce24b31dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;字节二面，差点没答好&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;字节二面，差点没答好&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247517757&amp;amp;idx=2&amp;amp;sn=67d56ebc0accd449c75ec6c36fca8645&amp;amp;chksm=f98dc297cefa4b811a2cf04d60b5f28f8e2d59e1281cf3e433579bb164767342b0499f6f689a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：如何用 Redis 实现分布式锁？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：如何用 Redis 实现分布式锁？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247516338&amp;amp;idx=2&amp;amp;sn=481c0c5ba605eddbc4824056d941a261&amp;amp;chksm=f98dc418cefa4d0ec4e8e3e2a1c1badc6cb66b5c20775ff785b8ef0da708cf8eb0a1c42c236f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：你确定 Redis 是单线程的进程吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：你确定 Redis 是单线程的进程吗？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>815aeb00916ba6707e1dfae633db6a4d</guid>
<title>研发效能度量：单人效率考核内卷？</title>
<link>https://toutiao.io/k/k472bnu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiax4y7V46AgLpDu0ia4DJziax1sM4icuWyEapFKPhwf6PKLX9FJ27Qnu9OPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文通过对研发效能度量领域6个常见问题的分析，阐述了作者对于研发效能度量的6点思考。因部分观点的抽象层次较高，建议收藏后细读，相信对帮助大家理清研发效能度量理念、建立度量体系会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;随着近几年市场和政策对于数字化转型的重视，研发效能的话题也是铺天盖地而来，从百度指数可看出，从21年下半年开始，“研发效能”四个字开始成为了热门词汇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxIuDcbyOGibLYicbbicEu3U0qkibibb7NAjbaRntQpib6HHsAeBLlXtObbicaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业界里面也因此有了许多的研发效能标准，比如阿里的五组效能度量指标，百度的工程能力白皮书里包含的效能度量体系，腾讯PCG的EPC模型，以及最新出炉的由中国信通院牵头的《研发运营一体化（DevOps）通用效能度量模型》等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;从这些度量体系的整体架构我们都可以看出整个度量体系的趋势都会是分层、分对象、分阶段，目标管理、动机驱动，从不同的维度去可视化、透明化研发这个黑盒子，回顾历史以期望可以得到预测性。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;笔者曾参与国内多家金融企业度量体系建设过程，在此想和大家分享一些在研发效能度量体系建设过程中的思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;问题一：我们公司想进行敏捷/DevOps转型，已经咨询过好多工具DevOps平台厂商，研发效能度量不就是引入一个工具就可以了么？&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念一：对抗复杂系统的演化需要熵减&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;虽然大多数组织都有研发的一系列流程、规范，甚至工具的支撑，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本质上来说软件开发还是属于一个复杂的领域&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而不是类似以往工业时代的有序的、生产线类型的系统。仅仅引入一个工具而不是做研发效能操作系统的整体升级，很有可能达不到最开始所期待的效果。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;为何将软件研发定义为一个复杂的系统？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;George Rzevski 教授层提供了一套复杂性的最佳标准：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交互-复杂系统由大量参与丰富交互的不同组件（代理）组成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自主-代理在很大程度上是自主的，但受制于某些法律、规则或规范；没有中央控制，但代理行为不是随机的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;涌现-复杂系统的整体行为从代理的交互中“涌现”，因此是不可预测的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;远离平衡-复杂系统“远离平衡”，因为频繁发生的破坏性事件不允许系统返回平衡&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非线性-非线性偶尔会导致微不足道的输入被放大为极端事件（蝴蝶效应)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自组织-复杂系统能够自组织以应对破坏性事件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;共同进化-复杂系统与其环境不可逆转的共同进化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9717514124293786&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxe1kNsfNl0PjHBws55hibX3NfIr1DOKzwgy1a8ZiaVaT0ngVQPnVUBh6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来自 cynefin.io&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Joseph多年前在一个大会上和300多名参会的软件开发人员做了一场Cynefin的“Butterfly stamping”工作坊，目的探索软件开发作为一个整体是否可以被认为是一个复杂的领域，他们得到了以下的共识：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件开发是一个丰富的领域，在所有不同领域都有多个方面和活动。这些方面和活动之间的交互本身往往是复杂的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;软件开发是一个具有自相似特征的多层次领域，即活动通常由子活动组成，每个子活动可能位于与基本活动不同的域中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;活动往往更侧重于繁杂和复杂的领域，与软件开发的编码方面相关的活动落在繁杂（或有时简单）的领域，而与项目管理相关的活动则落在复杂的（有时是混乱的）领域。处理与计算机交互的任务倾向于在有序域中，处理与其他人交互的任务倾向于在无序（即，复杂和混乱）域中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;绝大多数的软件研发任务和活动都属于复杂领域。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;复杂系统的演化，我们需要提到另一个概念：熵。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;鲁道夫.克劳修斯发现热力学第二定律时定义了熵，熵是无序的混乱程度，熵增是世界上一切事物发展的自然倾向，即从井然有序走向混乱无序，最终灭亡。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果把一个组织看成生命体：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;负熵&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;负熵是指能带来熵减的负熵因子，比如物质、能量、信息等，这些都是人的负熵，新的成员、新的知识、简化管理这些就是组织的负熵。比如说华为公司倡导的“日落法”，每增加一个新的流程环节要减少两个老的流程环节，这些简化管理的动作，也是一种负熵。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;说明：本节关于“熵”的内容，参考了纪录片《宇宙的奇迹：时间之箭》，感兴趣的同学，可以自行搜索观看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当组织的外部业务环境从工业时代转到IT时代，甚至以后会进入数字化智能时代，组织内的员工从70、80后的主力军变换到Z世代时，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;研发领域的管理方式的探索已经成为了在复杂系统如何更好地进行演化的命题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的观点是，复杂领域下的管理方式就需要不断吸取外部的优秀负熵，以开放的心态和组织形式来促使组织逆向做功，从而让组织从无序混乱转向有序发展。&lt;strong&gt;&lt;span&gt;一套工具所收集下来的指标只是助力，组织需要了解这些指标背后设定的含义，以及如何让组织内的成员理解这些度量指标。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;问题2：我们老大说2022年的目标就是把那几个北极星指标做到行业第一，这可怎么落地呀？&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念二：负熵也要长期主义&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;管理大师德鲁克说过，所有企业管理，说到底都是目标管理。许多时候企业乱成一团，都是目标不一致的结果，小张有小张的心思，小李有小李的想法，每个人各有想法，公司就无法聚焦目标，也就无法共同发力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;德鲁克认为，并不是有了工作才有目标，而是有了目标才能确定每个人的工作。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;企业的使命和任务，必须转化为目标。如果一个领域没有目标，这个领域的工作必然被忽视。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于目标的设定，史蒂芬.柯维在《高效能人士的七个习惯》中提出的“以终为始”思维方式就是一种很好的实现目标的方式。做事前认清方向，确立目标，逐步推进。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;比如我们在前几篇文章中谈到，组建产品部落的初衷，也是基于组织业务目标聚合跨职能人才在一起，为了共同的业务目标更实施产品的设计、交付和运营。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;483&quot; data-ratio=&quot;0.43485763589301124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDJq89XNTtz6WPGjMILD4jQA4cIeVnVqtHibmJ5tYPTr2AgBh3MfuJteUKze7gVa6rNejGEQDX8QuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1159&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，组织将研发效能的目标，定义为短期之内提升北极星指标是合理的么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，大多数组织都有提升效能的意愿，从组织面临的内外部因素影响可知，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在外部业务已经趋向于饱和或者萎缩时，组织会抓紧时间练内功，也就是聚焦于研发效能的提升。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那什么是研发部门的效能度量目标？我们可以尝试用以下问题和管理层对齐组织效能提升的思路：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果研发效能提升了，你可以看到哪些方面会有变化？变化的这些方面又会有哪些信号出现？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果研发效能提升了，在现有的组织关系中，你觉得哪些关系会有变化？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果10分代表您期待的未来，0分代表最糟糕的情况，您现在可以觉得组织效能是多少分呢？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果需要提升研发效能，你期望多久可以看到效果？（越快越好的这种答案对这个问题没有帮助）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上述问题，有助于我们去理解组织领导层对于研发效能提升的焦虑度，同时我们也需要了解到，管理者也经常会被追问到的一个问题，就是一段时间内资源投入的合理程度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ROI是深入人心的衡量方法，合理的资源投入产效管理对组织最终的经济效益的确起到关键作用，原则上来说，产效管理的核心在于科学化的资源规划与分配和数字化的产效衡量与管理，问题在于：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;多长的时间内？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何定义合理的资源投入？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单来说，在管理者的任期内，已经投入了多少研发资源达到了多少业务效果，未来打算投入多少研发资源达到多少的业务效果？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两个问题中的任何一个，对于管理者来说都不是一个容易回答的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;抛开无限游戏的说法，最佳解可能就是在有限的时间以内，分阶段的设置目标。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些组织出于对研发效能建设短期目标的追求，不是搞单元测试覆盖率，就是CI/CD3个月从零开始覆盖所有系统。如果把每一个工程实践的提升都看做是一个小的变革，首先得考虑组织的变革准备度，以及你打算实施的变革饱和度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;变革饱和度过高时，团队反而会因为要去解决一些不紧急的技术债而拖延业务交付的时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个研发效能的建设就好像是一个基建工程，要想实现飞轮效应，我们就不可能在超短的时间内就达到。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxgVYe9jv1QqZkibdr6MHsHvEMmttxEvYx1hXNlSU4yOwSmFJXV3LLbkw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;现阶段我们做的大多数还是破除0到1的过程，从靠管理者个人主观的感受团队的忙闲程度，到依据积累的历史数据以及和同行同形态的团队相对比找差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;受制于组织内部的文化、能力水平，外部的大环境业务形态变化影响，只有当历史数据积累了一定时间以后，组织的合理资源投入才能有一个相对客观的数据展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;问题3：代码行数、测试案例数、个人所负责的故事这些我们都收集到了，是不是应该针对个人搞个排名啊，年末了也好发奖金。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念三：关注球队，而非球员&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;一场球赛结束，你猜上台获奖的会是一个团队还是一个球员？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然我们都很通常会很欣赏那些明星球员，但是一场球赛的胜负核心还是在于团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxkCY22wNtNhkZHT98ORASVxnZ9N863b5URPEv0rwvc7T54aZ5R5Lb7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;4185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 / 来自Pexels，基于CC0协议&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;依据真实事件改编的电影《点球成金》中，职业经理人Billy在球队缺钱、明星成员接二连三被挖走的逆境中通过挖掘出一批平凡的选手，这些人或者年龄很大，或身体有恙，或打球姿势诡异，或个人生活混乱，最终依靠这个团队取到了他心中的梦想——冠军杯。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一场球赛中，有的球员负责冲锋，有的负责防守，除了个人能力以外更多是团队的协作。同样的，一个研发团队中，有的擅长编码，有的擅长沟通，有的擅长架构设计，他们也许都称之为程序员，职责也相同，在团队中发挥的作用范围或对象却有可能天差地别。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;单人效率考核的内卷&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;在组织开始注重效能的初期，有的管理者会喜欢对比单个人员的繁忙程度用来衡量“生产率”或“效率”，也就是一个常常加班的员工就比一个正常下班的员工更容易得到老板的欣赏，在“电影院效应”下，组织中重复低价值的工作的场景会越来越多，实际造成不必要的资源浪费，也就是俗称的“内卷”。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当球队管理者不去关注团队进球数多少，而去一心关注单个球员进球数时，球员自身更容易打乱自己的节奏。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;因此，在研发效能度量体系中，我们会推荐以团队的效能度量为主，个人的数据可以做极端异常值的分析。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如一个团队中，若有成员的代码提交量一直保持非常低的水平，可能管理者会需要关注此成员被分配的工作和能力是否匹配，另一个配套的管理手段是把团队人数拆小以后，类似每日站会的实践也能提前发现此类问题。&lt;span&gt;（关于这个问题，可以查看我上一篇小队划分的文章，在文末有链接）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从另一个方面来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;将成员的各项指标建立数据模型，给人物贴上标签，按照团队的需要进行指标选择，从大量以往不可定量中快速找出团队的最优解。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这也是电影中Billy给我们的启示，即如何用最低的成本创造最大的价值，更多的是一种商业化的考量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;问题4：我们公司从前年开始就已经有一套完备的指标体系，搞来搞去也没有什么新的指标好添加的，那几个指标大家都看熟了&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念四：指标也有生命周期，需要演进&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;软件业界中曾流行过的CMMI和敏捷流畅度模型等，都是依据演化的思路。组织的不同形态对应着不同的阶段，在软件研发的演化过程中因为加入了许多的变量，指标本身也是有着生命周期，需要演进的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在2020年3月出版的《谷歌软件工程》中，谷歌将整个软件生命周期的度量管理分为了两部分：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在研发阶段工作的度量就由项目的PH(Project Health)值来进行度量。它取代了之前谷歌使用了八年的Test Certified(2008～2016)，一个很重要原因是，TC标准是静态的，当团队达到某个级别以后，就没有再进一步的动力提升级别，甚至项目实际情况已经降级了。&lt;strong&gt;&lt;span&gt;这和业界中许多组织过了CMMI3评级后就一直停滞不前，甚至倒退的情况有些类似。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;说说冒烟移测率&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;在我参与的度量体系搭建实践中，就曾有冒烟移测率这个指标。指标初始设定的原因，是因为有些团队开发提交测试给测试团队时的质量过差，导致测试团队的资源消耗过多，且缺陷的修复导致项目周期较长，在以提升开发团队质量内建能力的前提下，此指标可作为核心指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在持续观测了一段时间以后，提测质量守护的情况在有些团队已经稳定且基本为100%，若再持续观测此指标意义就不大，就可以把此指标放入监控指标中。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在之前，&lt;span&gt;Agilean&lt;/span&gt;也提出过一个研发效能提升过程中指标演进路线图（文末推荐阅读有链接），供大家参考：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4912863070539419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxkf6EFYvc1ODZ5vAa1VywGhPEdqQ6PiamEvu3BlaeV3KH2nicPs8J50Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1205&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;问题5：我们这里不管用什么指标，下面的人总是要做数据，那要指标来有什么用呢？&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念五：不能因噎废食&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;钱塘莫美于西湖，金陵莫美于后湖。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;南京城里的后湖由于其得天独厚的优势，“&lt;span&gt;周遭四十里，中突数洲，断岸千尺&lt;/span&gt;”被明朝设为黄册的存放地，也就是国家绝密档案库，当时的天下郡、县编制赋役都存于此，甚至有了“黄册、里甲制、鱼鳞图册在手，天下透明”的说法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxYIWJ31iaSgJvjYkThema5FdRquB9KUDqdDno9Ltm5cup8WTvicRrYHeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1920&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 / 南京后湖，来自Pixabay&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;朱元璋为了让黄册可以得到很好的防护，可以说是殚精竭虑，整个玄武湖被整整封锁了近300年。结果呢，为了修改里面的数据，下面的人想了无数的方法，最狠的一招，是本来使用黄檗汁来做染黄使书籍防虫，被人替换为石黄，招致蠹鱼把黄册直接给吃掉了，神不知鬼不觉的把数据给消失掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，一旦涉及到利益时，人类的想象力和智慧是无穷的。上头有多少条政策，下面就有多少条对策。汉代搞案户比民，民间就敢舍匿虚田；隋唐有大索貌阅，民间士子就敢冒籍取解；宋代搞衙前差役，老百姓就会析居避役、鬻田减户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;同样的，研发团队要是按照代码行数来统计员工的奖金，那代码的隐形技术债估计也&lt;strong&gt;&lt;span&gt;不&lt;/span&gt;&lt;/strong&gt;会少。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从数据运营角度说，我们看到的是趋势，分析的是异常，开放性系统中我们一般会经历以下三个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阶段一：部门内部的数据共享&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单个研发部门内部的数据收集及趋势呈现，有助于CTO改善部门内的管理方式及提升部门研发能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阶段二：组织内部的数据共享&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;组织内部各个部门研发效能数据的共享，可以在一定程度上透明化组织的整个研发部门数字化运营能力，有利于组织从全局层面做资源规划和分配的决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阶段三：跨组织的数据共享&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发效能的兴起加上标准的制定，不同组织都开始有意识的收集自身组织的数据，随着有效数据的清洗和治理，之后同行业之间就可以达到数据共享及行业的趋势预测。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;德鲁克说，管理的本质，其实就是激发和释放每一个人的善意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;用数据来说话或者数据驱动是为了消除主观偏见，更多的人能在更短的时间内达成共识。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不排除在实际操作中我们因为某些原因在某一个阶段设定了一些不合理的指标，小步试错，指标的设定也是有假设-验证-修改这样不停迭代的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;span&gt;问题6：我是搞度量的，公司的度量体系也搭建了，数据也收集了，接下来明年还能规划个啥呢？&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;&lt;span&gt;理念六：情景化度量而非控制型度量&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;下图是一个团队的时效图，从图上你可以看出什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.563036303630363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiax393xGVJnv6nEwVj3ySPFZbQ9hASwnoUPjv5clMLEFpicW4S3DuuERbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1515&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同颜色的线条表示不同的前置时间，从图中可以看出，深蓝色最上面的那根时长是在增加的，而由上往下的第三根浅蓝色的线条时长在减少。对应的表示整个团队的研发时效在增加，而需求排期的时间在减少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你不是团队的成员或者你完全不知道团队的情况，你可以知道这样变化的原因么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家说，我可以推测呀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;是的，假设-验证-反馈是一个科学化的正向反馈循环。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Keniberg提出过一个数据的验证模型DIBB，即DATA-INSIGHT-BELIEF-BET。从客观数据出发，激发洞见，设定假设，运营验证。从度量的方式来说，我们就是通过数据治理的方式来做组织的研发数据运营，帮助组织实现数据驱动的持续改善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48480463096960924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxVA6mXbg9ApEffyUTDOpficFAtd9cmeAf9uSQJBCGicibAhlqo4Ay7j9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在日益复杂难测的组织环境中，管理者们可以看到，完全是流程性的从上而下的命令-控制性管理方式已经开始褪去光环，来自于军事领域的Mission Command管理方式更适合现今不确定性较高的组织管理领域。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以从不同的团队数据中，得到不同的团队数据特征，并不要求所有的团队展现出来的都是一样的数据行为模式。当然，要选择控制型度量还是情景度量的判断因素可能有：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101324&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;组织中的员工能力高低&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组织的目标是防范错误还是创新&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组织中的决策模式是中央集权还是高度分散&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;团队的价值观是否一致，是否易达成共识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们观察到组织的研发效能度量可能会经历4个不同阶段的流畅度，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;流畅度是指某个组织在面临压力时研发效能度量数据可视化呈现的方式。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果有足够的时间待在课堂里，每个人都能做到遵循一系列良好实践，但真正的流畅度是一种有技巧的日常实践，即使当你为其它事分心的时候，这种流畅度也不会离你而去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对于研发效能度量来说，我们更关注于团队的研发效能度量流畅度，而非个人流畅度。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而团队的流畅度则更多地取决于团队中每个成员的能力，也取决于管理结构、关系、组织的文化等方面。请别误会，这并不是说团队的流畅度低下要归咎于个人，也不是说一个高水平成员的存在就能够保证整个团队的流畅度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaialXb0YyiaMDNyicdNwVLTIupGwsnibHLiaxO2zEdGtLNgibb2nSCqzOiaBibibItpVQrH6xyZt19DOWZHzRLFQncR6SnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>abf196e65856877494dfafab942aa08d</guid>
<title>任务流执行器是如何工作的？</title>
<link>https://toutiao.io/k/3udmds2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近在整一个 OpenAPI 编排器，想到 npm-run-all 的任务流。&lt;/span&gt;&lt;span&gt;看了一下这个 6 年前的源码。&lt;/span&gt;&lt;span&gt;npm-run-all&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt; 是一个用来并行或者串行运行多个 npm 脚本的 CLI 工具。&lt;/span&gt;&lt;span&gt;阅读完本文，你能收获到：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;了解整个流程概览；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;了解核心模块逻辑，入口分析、参数解析、任务流、任务执行等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MjcxNTQ0Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png&quot; data-nickname=&quot;全栈修仙之路&quot; data-alias=&quot;FerRoad&quot; data-signature=&quot;专注分享 TS、Vue3、前端架构和源码解析等技术干货。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;流程概览&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直入主题，整个 npm-run-all 的整体执行流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.636887608069164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/as7amCkh7umAnIdv55oCSGe6dWHk4EIu2CqdInJBhb9ZZEwzEhMyD53icHiawO3lndKTKUAQ8cdg3MaeJLXkVTWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;347&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在终端敲入命令，实际上会去调用 bin/xx/index.js 函数，然后调用 bootstrap 去分发不同命令不同参数的逻辑。help 和 version 比较简单，本文不做分析。任务控制方面，会先调用 npmRunAll 做参数解析，然后执行 runTasks 执行任务组中任务，全部任务执行后返回结果，结束整个流程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;入口分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm-run-all&lt;/code&gt; 包支持三条命令，我们看到源码根目录的 package.json 文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;npm-run-all&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;version&quot;&lt;/span&gt;: &lt;span&gt;&quot;4.1.5&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;description&quot;&lt;/span&gt;: &lt;span&gt;&quot;A CLI tool to run multiple npm-scripts in parallel or sequential.&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;bin&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;run-p&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/run-p/index.js&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;run-s&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/run-s/index.js&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;npm-run-all&quot;&lt;/span&gt;: &lt;span&gt;&quot;bin/npm-run-all/index.js&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;main&quot;&lt;/span&gt;: &lt;span&gt;&quot;lib/index.js&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;files&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;bin&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;lib&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;docs&quot;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;engines&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;node&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;gt;= 4&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bin 下面定义的命令脚本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;run-p，简化使用的脚本，代表并行执行脚本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;run-s，简化使用的脚本，代表串行执行脚本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;npm-run-all，复杂命令，通过 --serial 和 --parallel 参数实现前两者一样的效果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接看到 &lt;code&gt;bin/npm-run-all/index.js&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;../common/bootstrap&quot;&lt;/span&gt;)(&lt;span&gt;&quot;npm-run-all&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中，如果是执行 run-p 这条命令，则函数传入的参数是 &lt;code&gt;run-p&lt;/code&gt;，&lt;code&gt;run-s&lt;/code&gt; 同理。bootstrap 通过参数的不同，将任务分发到 bin 下不同目录中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;.&lt;br/&gt;├── common&lt;br/&gt;│   ├── bootstrap.js&lt;br/&gt;│   ├── parse-cli-args.js&lt;br/&gt;│   └── version.js&lt;br/&gt;├── npm-run-all&lt;br/&gt;│   ├── help.js&lt;br/&gt;│   ├── index.js&lt;br/&gt;│   └── main.js&lt;br/&gt;├── run-p&lt;br/&gt;│   ├── help.js&lt;br/&gt;│   ├── index.js&lt;br/&gt;│   └── main.js&lt;br/&gt;└── run-s&lt;br/&gt;    ├── help.js&lt;br/&gt;    ├── index.js&lt;br/&gt;    └── main.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;照着上述代码结构，结合 &lt;code&gt;../common/bootstrap&lt;/code&gt; 代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;use strict&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;bootstrap&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; argv = process.argv.slice(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (argv[&lt;span&gt;0&lt;/span&gt;]) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;-h&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;--help&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;`../&lt;span&gt;${name}&lt;/span&gt;/help`&lt;/span&gt;)(process.stdout)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;-v&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;--version&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;./version&quot;&lt;/span&gt;)(process.stdout)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;// https://github.com/mysticatea/npm-run-all/issues/105&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// Avoid MaxListenersExceededWarnings.&lt;/span&gt;&lt;br/&gt;            process.stdout.setMaxListeners(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            process.stderr.setMaxListeners(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            process.stdin.setMaxListeners(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// Main&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;`../&lt;span&gt;${name}&lt;/span&gt;/main`&lt;/span&gt;)(&lt;br/&gt;                argv,&lt;br/&gt;                process.stdout,&lt;br/&gt;                process.stderr&lt;br/&gt;            ).then(&lt;br/&gt;                &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// I&#x27;m not sure why, but maybe the process never exits&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// on Git Bash (MINGW64)&lt;/span&gt;&lt;br/&gt;                    process.exit(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                },&lt;br/&gt;                () =&amp;gt; {&lt;br/&gt;                    process.exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;                }&lt;br/&gt;            )&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bootstrap 函数依据调用的命令调用不同目录下的 help、version 或者调用 main 函数，达到了差异消除的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再把目光放在 &lt;code&gt;process.stdout.setMaxListeners(0)&lt;/code&gt; 这是啥玩意？打开 &lt;span&gt;issue 链接&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，通过报错信息和翻阅官方文档：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;By default &lt;code&gt;EventEmitter&lt;/code&gt;s will print a warning if more than &lt;code&gt;10&lt;/code&gt; listeners are added for a particular event. This is a useful default that helps finding memory leaks. The &lt;code&gt;emitter.setMaxListeners()&lt;/code&gt; method allows the limit to be modified for this specific &lt;code&gt;EventEmitter&lt;/code&gt; instance. The value can be set to &lt;code&gt;Infinity&lt;/code&gt; (or &lt;code&gt;0&lt;/code&gt;) to indicate an unlimited number of listeners.&lt;/p&gt;&lt;p&gt;默认情况下，如果为特定事件添加了超过 10 个侦听器，EventEmitters 将发出警告。这是一个有用的默认值，有助于发现内存泄漏。emitter.setMaxListeners() 方法允许为这个特定的 EventEmitter 实例修改限制。该值可以设置为 Infinity（或 0）以指示无限数量的侦听器。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要处理这个情况呢？因为用户可能这么使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ run-p a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你永远想象不到用户会怎么使用你的工具！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参数解析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析完不同命令的控制逻辑，我们进入核心的 npmRunAll 函数，参数解析部分逻辑如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;npmRunAll&lt;/span&gt;(&lt;span&gt;args, stdout, stderr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; stdin = process.stdin&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; argv = parseCLIArgs(args)&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; () {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3759124087591241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/as7amCkh7umAnIdv55oCSGe6dWHk4EIuDfSjrRvEsiaXuyzFsGoaSu4x5rbhrsfJhsrOoSM1YwGQusKSiahzwseg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析处理所有标准输入流参数，最终生成并返回 ArgumentSet 实例 set。parseCLIArgsCore 只看控制任务流执行的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addGroup&lt;/span&gt;(&lt;span&gt;groups, initialValues&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    groups.push(&lt;span&gt;Object&lt;/span&gt;.assign(&lt;br/&gt;        { &lt;span&gt;parallel&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;patterns&lt;/span&gt;: [] },&lt;br/&gt;        initialValues || {}&lt;br/&gt;    ))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;parseCLIArgsCore&lt;/span&gt;(&lt;span&gt;set, args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;LOOP&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; args.length; ++i) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; arg = args[i]&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (arg) {&lt;br/&gt;       &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;-s&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;--sequential&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;--serial&quot;&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;set&lt;/span&gt;.singleMode &amp;amp;&amp;amp; arg === &quot;-s&quot;) {&lt;br/&gt;                    &lt;span&gt;set&lt;/span&gt;.silent = true&lt;br/&gt;                    break&lt;br/&gt;                }&lt;br/&gt;                if (&lt;span&gt;set&lt;/span&gt;.singleMode) {&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Invalid Option: &lt;span&gt;${arg}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;                }&lt;br/&gt;                addGroup(&lt;span&gt;set&lt;/span&gt;.groups)&lt;br/&gt;                break&lt;br/&gt;&lt;br/&gt;            case &quot;-p&quot;:&lt;br/&gt;            case &quot;--parallel&quot;:&lt;br/&gt;                if (&lt;span&gt;set&lt;/span&gt;.singleMode) {&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;`Invalid Option: &lt;span&gt;${arg}&lt;/span&gt;`&lt;/span&gt;)&lt;br/&gt;                }&lt;br/&gt;                addGroup(&lt;span&gt;set&lt;/span&gt;.groups, { parallel: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;: {&lt;br/&gt;                &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将任务都装到 &lt;code&gt;groups&lt;/code&gt; 数组中，如果是并行任务（传了 &lt;code&gt;-p&lt;/code&gt;、&lt;code&gt;--parallel&lt;/code&gt; 参数），就给任务加上 &lt;code&gt;{ parallel: true }&lt;/code&gt; 标记。默认是 &lt;code&gt;{ parallel: false }&lt;/code&gt;，即串行任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;执行任务组&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入这一小节之前，我们就 npm-run-all 源码在 scripts 下加一条 debug 命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ &lt;span&gt;&quot;node ./bin/npm-run-all/index.js lint test&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析完参数生成的 &lt;code&gt;argv.groups&lt;/code&gt; 如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[{&lt;br/&gt;  &lt;span&gt;paralles&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;patterns&lt;/span&gt;: [&lt;span&gt;&#x27;lint&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;]&lt;br/&gt;}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个数组结果，我们再看任务执行流程会更加明朗。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// bin/npm-run-all/main.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;npmRunAll&lt;/span&gt;(&lt;span&gt;args, stdout, stderr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 省略解析参数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 执行任务&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; promise = argv.groups.reduce(&lt;br/&gt;            &lt;span&gt;(&lt;span&gt;prev, group&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 分组中没有任务，直接返回 null&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (group.patterns.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; prev&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; prev.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; runAll(&lt;br/&gt;                    group.patterns, &lt;span&gt;// [&#x27;lint&#x27;, &#x27;test&#x27;]&lt;/span&gt;&lt;br/&gt;                    {&lt;br/&gt;                        &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;                       &lt;span&gt;// 是否并行执行&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;parallel&lt;/span&gt;: group.parallel,&lt;br/&gt;                       &lt;span&gt;// 并行的最大数量&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;maxParallel&lt;/span&gt;: group.parallel ? argv.maxParallel : &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                        &lt;span&gt;// 一个任务失败后继续执行其他任务&lt;/span&gt;&lt;br/&gt;                       &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;arguments&lt;/span&gt;: argv.rest,&lt;br/&gt;                        &lt;span&gt;// 这个📌用于当任务以0码退出时，终止全部任务&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;race&lt;/span&gt;: group.parallel &amp;amp;&amp;amp; argv.race,&lt;br/&gt;                        &lt;span&gt;//……&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                ))&lt;br/&gt;            },&lt;br/&gt;            &lt;span&gt;Promise&lt;/span&gt;.resolve(&lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        )&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; promise&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (err) { &lt;br/&gt;        &lt;span&gt;//eslint-disable-next-line no-console&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.error(&lt;span&gt;&quot;ERROR:&quot;&lt;/span&gt;, err.message)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(err)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码解析完命令行中的参数之后，通过 reduce 拼接所有任务组的结果。任务组就是 npm-run-all 支持同时配置并行和串行的任务，并生成多个任务组。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ npm-run-all -p a b -s c d e&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述命令会生成两个任务组，并行任务组是 [&#x27;a&#x27;, &#x27;b&#x27;]，串行任务组是 [&#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]。就会执行两次 &lt;code&gt;runAll&lt;/code&gt;。接下来就看看单个任务组的执行逻辑：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// lib/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;npmRunAll&lt;/span&gt;(&lt;span&gt;patternOrPatterns, options&lt;/span&gt;) &lt;/span&gt;{ &lt;span&gt;//eslint-disable-line complexity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 省略一系列参数格式化和默认值处理……&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; patterns = parsePatterns(patternOrPatterns, args)&lt;br/&gt;        &lt;span&gt;// 省略非法参数报错和参数之间的校验……&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.resolve()&lt;br/&gt;            .then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (taskList != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; { taskList, &lt;span&gt;packageInfo&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt; }&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; readPackageJson()&lt;br/&gt;            })&lt;br/&gt;            .then(&lt;span&gt;&lt;span&gt;x&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 从 package.json 中匹配任务&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;// 🌰中 patterns 是 [&#x27;lint&#x27;, &#x27;tests&#x27;]，所以 lint 和 test 这两个任务一定要从 package.json 的 scripts 中能查看到&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;const&lt;/span&gt; tasks = matchTasks(x.taskList, patterns)&lt;br/&gt;                &lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; runTasks(tasks, {&lt;br/&gt;                    &lt;span&gt;// 省略上面格式化和校验后的参数……&lt;/span&gt;&lt;br/&gt;                })&lt;br/&gt;            })&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.reject(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(err.message))&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码将参数的处理和校验全部省略掉了，看到核心的逻辑 &lt;code&gt;matchTasks&lt;/code&gt; 和 &lt;code&gt;runTasks&lt;/code&gt;。&lt;code&gt;matchTasks&lt;/code&gt; 通过读取 &lt;code&gt;package.json&lt;/code&gt; 下 &lt;code&gt;scripts&lt;/code&gt; 中的命令，然后判断任务组 &lt;code&gt;patterns&lt;/code&gt; 中的任务是否都存在于 &lt;code&gt;taskList&lt;/code&gt; 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就来到了本小节的核心逻辑——调用 &lt;code&gt;runTasks&lt;/code&gt; 依次执行每个任务组中的任务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;runTasks&lt;/span&gt;(&lt;span&gt;tasks, options&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;// 任务组中不存在任务，直接返回空数组&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (tasks.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            resolve([])&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;// 结果数组&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; results = tasks.map(&lt;span&gt;&lt;span&gt;task&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({ &lt;span&gt;name&lt;/span&gt;: task, &lt;span&gt;code&lt;/span&gt;: &lt;span&gt;undefined&lt;/span&gt; }))&lt;br/&gt;        &lt;span&gt;// 任务队列&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; queue = tasks.map(&lt;span&gt;(&lt;span&gt;task, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; ({ &lt;span&gt;name&lt;/span&gt;: task, index }))&lt;br/&gt;        &lt;span&gt;// 用于判断并行的时候任务是否全部完成&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; promises = []&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; error = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; aborted = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * Done.&lt;br/&gt;         * &lt;span&gt;@returns &lt;span&gt;{void}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;done&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * Aborts all tasks.&lt;br/&gt;         * &lt;span&gt;@returns &lt;span&gt;{void}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;abort&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// ……&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * Runs a next task.&lt;br/&gt;         * &lt;span&gt;@returns &lt;span&gt;{void}&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;           &lt;span&gt;// 任务被终止了，则不需要再往下执行了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (aborted) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;           &lt;span&gt;// 并行时，只有满足 queue 和 promises 的长度都为 0，才可以判断任务组完成 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (queue.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (promises.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    done()&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; task = queue.shift()&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; promise = runTask(task.name, optionsClone)&lt;br/&gt;&lt;br/&gt;            promises.push(promise)&lt;br/&gt;            promise.then(&lt;br/&gt;                &lt;span&gt;(&lt;span&gt;result&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;                   &lt;span&gt;// 完成一个任务，就将其从 promises 中删除&lt;/span&gt;&lt;br/&gt;                    remove(promises, promise)&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (aborted) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (result.code) {&lt;br/&gt;                        error = &lt;span&gt;new&lt;/span&gt; NpmRunAllError(result, results)&lt;br/&gt;                        &lt;span&gt;// 失败后不继续执行后续的任务，则直接终止整个任务组&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!options.continueOnError) {&lt;br/&gt;                            abort()&lt;br/&gt;                            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;// Aborts all tasks if options.race is true.&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (options.race &amp;amp;&amp;amp; !result.code) {&lt;br/&gt;                        abort()&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;// Call the next task.&lt;/span&gt;&lt;br/&gt;                    next()&lt;br/&gt;                },&lt;br/&gt;                (thisError) =&amp;gt; {&lt;br/&gt;                    remove(promises, promise)&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (!options.continueOnError || options.race) {&lt;br/&gt;                        error = thisError&lt;br/&gt;                        abort()&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    next()&lt;br/&gt;                }&lt;br/&gt;            )&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;// 最大并发数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; max = options.maxParallel&lt;br/&gt;        &lt;span&gt;// 对比任务数量、配置的并发数、取较小者。这是为了防止配置的 maxParallel 比实际执行的任务数量还大的情况&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; end = (&lt;span&gt;typeof&lt;/span&gt; max === &lt;span&gt;&quot;number&quot;&lt;/span&gt; &amp;amp;&amp;amp; max &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            ? &lt;span&gt;Math&lt;/span&gt;.min(tasks.length, max)&lt;br/&gt;            : tasks.length&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; end; ++i) {&lt;br/&gt;            next()&lt;br/&gt;        }&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通过队列，依次执行组中的每一条任务，任务成功后将结果存入 result，然后调用 next 执行下一个任务；可以通过 abort 终止全部任务；通过 done 完成整个队列的状态更新，并将结果返回。&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;串行机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，通过一张图和本小节的示例，来更好地理解串行机制：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5579847908745247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/as7amCkh7umAnIdv55oCSGe6dWHk4EIuMnFQUQiaKqYYRTjEYqrVRCn1oEHyHberCcClp9AVKkKK6vhW1ZZbXZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从左到右得流程，讲解一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始化时，根据任务组的 patterns，生成任务队列；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;计算完任务数量 end 之后，执行 next 函数。此时会从任务队列中取出 lint 任务，调用 runTask 去执行该任务（图2所示）。（runTask 的细节放到下一小节分析。）执行完成后，会执行以下子任务：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果配置了 &lt;code&gt;aggregateOutput&lt;/code&gt; 参数，会将任务的输出流写入到内存流；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新 result.code，如果配置了失败不继续执行（!continueOnError） 或者 race 参数，就直接调用 abort 终止整个任务队列，返回结果；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;如果成功或配置失败了继续执行其他任务（ continueOnError），就去任务队列中取出下一个任务（图3所示），会去执行 test 任务，重复上一步骤的逻辑。最终任务队列中没有其他任务了，此时也会执行 done 函数，结束整个任务组，并将 results 返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;并行机制&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并行机制的不同就在于初始的时候会调用多次 next 函数，并且会判断当前是否还有正在执行的任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.699523052464229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/as7amCkh7umAnIdv55oCSGe6dWHk4EIu2kUegN7wc8xIaUGM0RGkEE3nCfgdytcTAAClwH1icZCQcV5iaoGlWia7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1887&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是我们执行以下命令的流程图：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ node ./bin/npm-run-all/index.js  -p lint &lt;span&gt;test&lt;/span&gt; --max-parallel 2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令的意思是并行执行 lint 和 test 任务，并且最大并发数是 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上面的流程图：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初始时还是会创建一个任务队列，并将 lint 和 test 两个任务添加到队列中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后在首次执行时，因为我们是并发执行，所以会调用两次 next 函数，promises 数组会保存两个 promise 实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 lint 任务先完成（此时 test 任务还在执行，即 test promise 还未结束），此时会再调用 next 函数。此时会判断任务队列和正在进行的任务队列是否为空，如果是的话就调用 done 返回结果，否则什么都不做，等待其他任务执行完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当 test 任务也完成时（假设此时 lint 任务已经完成），同样也会再次执行 next。但此时 queue 和 promises 两个数组的长度都是 0，就执行 done 逻辑，输出任务组的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节我们学习了任务组中的任务不管是串行机制还是并行机制，都通过&lt;strong&gt;任务队列&lt;/strong&gt;依次执行。不同的是，串行是首次只执行一次 next，并行根据参数执行多次 next。当满足队列为空并且所有任务都完成，就结束当前任务组，并将缓存在 results 中的结果返回。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单个任务如何执行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完任务组的串行和并行机制，这一小节就来了解单个任务是如何被执行的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;module&lt;/span&gt;.exports = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;runTask&lt;/span&gt;(&lt;span&gt;task, options&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; cp = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; promise = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 包装输出、输入、错误信息流……&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 在输出流中写入任务名称&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (options.printName &amp;amp;&amp;amp; stdout != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            stdout.write(createHeader(&lt;br/&gt;                task,&lt;br/&gt;                options.packageInfo,&lt;br/&gt;                options.stdout.isTTY&lt;br/&gt;            ))&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 执行命令的 npm 路径，npm-cli 的路径&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; npmPath = options.npmPath || process.env.npm_execpath&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; npmPathIsJs = &lt;span&gt;typeof&lt;/span&gt; npmPath === &lt;span&gt;&quot;string&quot;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;/\.m?js/&lt;/span&gt;.test(path.extname(npmPath))&lt;br/&gt;        &lt;span&gt;// 执行路径，一般是全局的 bin/node 路径&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; execPath = (npmPathIsJs ? process.execPath : npmPath || &lt;span&gt;&quot;npm&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;// 判断是不是 yarn&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; isYarn = path.basename(npmPath || &lt;span&gt;&quot;npm&quot;&lt;/span&gt;).startsWith(&lt;span&gt;&quot;yarn&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; spawnArgs = [&lt;span&gt;&quot;run&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (npmPathIsJs) {&lt;br/&gt;            spawnArgs.unshift(npmPath)&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!isYarn) {&lt;br/&gt;            &lt;span&gt;Array&lt;/span&gt;.prototype.push.apply(spawnArgs, options.prefixOptions)&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (options.prefixOptions.indexOf(&lt;span&gt;&quot;--silent&quot;&lt;/span&gt;) !== &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;            spawnArgs.push(&lt;span&gt;&quot;--silent&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;Array&lt;/span&gt;.prototype.push.apply(spawnArgs, parseArgs(task).map(cleanTaskArg))&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;// 执行命令&lt;/span&gt;&lt;br/&gt;        cp = spawn(execPath, spawnArgs, spawnOptions)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 省略输出流格式化……&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// Register&lt;/span&gt;&lt;br/&gt;        cp.on(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, (err) =&amp;gt; {&lt;br/&gt;            cp = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;            reject(err)&lt;br/&gt;        })&lt;br/&gt;        cp.on(&lt;span&gt;&quot;close&quot;&lt;/span&gt;, (code, signal) =&amp;gt; {&lt;br/&gt;            cp = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;// 成功后返回任务名称、状态&lt;/span&gt;&lt;br/&gt;            resolve({ task, code, signal })&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 给当前的promise挂上静态方法，用于结束当前子进程任务&lt;/span&gt;&lt;br/&gt;    promise.abort = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;abort&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cp != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            cp.kill()&lt;br/&gt;            cp = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; promise&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runTask 做了四件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;格式化标准输入、输出流，添加一些任务名称头部信息之类的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取任务的执行器，获取 npm-cli、node 等路径信息，然后拼接整个任务的执行命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用封装后的 spawn 执行命令，并监听 error 和 close 事件用于返回执行结果；因为系统的不一致，所以 spawn 通过 cross-spawn 做了一层封装。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给当前任务挂上了 abort 的静态方法，用于结束当前进程；当在任务组执行 abort 方法时，实际会调用这个静态方法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扫码查看 &lt;span&gt;&lt;strong&gt;轻松学 TypeScript&lt;/strong&gt;&lt;/span&gt; 系列视频教程&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0DdhYZrspnt0P0Y9lRYywOiaibuq2KGSGGeM20BkcxZ6XCY2HpkoTRf6UdwNdfl7SzZAcD6jy4ntUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;（目前已更新&lt;strong&gt; 19 &lt;/strong&gt;期）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人会问为什么要去看一个 6 年前写的源码？语法老旧、甚至还能看到&lt;span&gt;标记声明&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 。但我想表达的是，&lt;code&gt;npm-run-all&lt;/code&gt; 这个包的核心逻辑——通过任务队列去实现串行和并行的任务流模型是非常经典的，类似 continueOnError、race 这样的逻辑控制节点也随处可见。例如当前非常先进的构建系统 &lt;span&gt;Turborepo&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; ，它对 pipeline 的控制逻辑也能复用这个任务流模型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;npm-run-all: &lt;em&gt;https://www.npmjs.com/package/npm-run-all&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;issue 链接: &lt;em&gt;https://github.com/mysticatea/npm-run-all/issues/105&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;标记语法: &lt;em&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label#browser_compatibility&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Turborepo: &lt;em&gt;https://turborepo.org/docs/core-concepts/pipelines&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71bc7d741315f5a321683e21b0a70aab</guid>
<title>32 道 Spring 常见面试总结（附详细参考答案），我经常拿来面试别人</title>
<link>https://toutiao.io/k/vmbw17y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-9scqi7&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;zvkfAIab&quot;&gt;首发于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide 在线网站&lt;/a&gt;：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring 常见面试题总结&lt;/a&gt;&lt;/blockquote&gt;&lt;p data-pid=&quot;t48c5Bod&quot;&gt;最近在对 JavaGuide 的内容进行重构完善，同步一下最新更新，希望能够帮助你。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 基础&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring 框架?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;i1NBKkV_&quot;&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。&lt;/p&gt;&lt;p data-pid=&quot;38CpyAg8&quot;&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7XlxHliz&quot;&gt;Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。&lt;/p&gt;&lt;p data-pid=&quot;WMe-HBZ1&quot;&gt;Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p&gt;&lt;p data-pid=&quot;T_frrzZh&quot;&gt;  多提一嘴 ： &lt;b&gt;语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;8GrdyTh4&quot;&gt;Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 包含的模块有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;d5hVj1P-&quot;&gt;&lt;b&gt;Spring4.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring4.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Esivw2dB&quot;&gt;&lt;b&gt;Spring5.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring5.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TJD_HRfd&quot;&gt;Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;p data-pid=&quot;TzDpak8y&quot;&gt;Spring 各个模块的依赖关系如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring 各个模块的依赖关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Core Container&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;m0Vrd8VL&quot;&gt;Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;i-Udk49h&quot;&gt;&lt;b&gt;spring-core&lt;/b&gt; ：Spring 框架基本的核心工具类。&lt;/li&gt;&lt;li data-pid=&quot;-_QpCS62&quot;&gt;&lt;b&gt;spring-beans&lt;/b&gt; ：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;3BJestPe&quot;&gt;&lt;b&gt;spring-context&lt;/b&gt; ：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;qnyeY0ST&quot;&gt;&lt;b&gt;spring-expression&lt;/b&gt; ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;AOP&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;0DdS6DJu&quot;&gt;&lt;b&gt;spring-aspects&lt;/b&gt; ：该模块为与 AspectJ 的集成提供支持。&lt;/li&gt;&lt;li data-pid=&quot;95r0WE5Q&quot;&gt;&lt;b&gt;spring-aop&lt;/b&gt; ：提供了面向切面的编程实现。&lt;/li&gt;&lt;li data-pid=&quot;T_hBsnGK&quot;&gt;&lt;b&gt;spring-instrument&lt;/b&gt; ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Data Access/Integration&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;DA3kSEG4&quot;&gt;&lt;b&gt;spring-jdbc&lt;/b&gt; ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。&lt;/li&gt;&lt;li data-pid=&quot;KRkn9OQk&quot;&gt;&lt;b&gt;spring-tx&lt;/b&gt; ：提供对事务的支持。&lt;/li&gt;&lt;li data-pid=&quot;PwAkXOzU&quot;&gt;&lt;b&gt;spring-orm&lt;/b&gt; ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。&lt;/li&gt;&lt;li data-pid=&quot;7lS_CDkO&quot;&gt;&lt;b&gt;spring-oxm&lt;/b&gt; ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。&lt;/li&gt;&lt;li data-pid=&quot;pvOK5TZ2&quot;&gt;&lt;b&gt;spring-jms&lt;/b&gt; : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring Web&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;kPdLK_Ag&quot;&gt;&lt;b&gt;spring-web&lt;/b&gt; ：对 Web 功能的实现提供一些最基础的支持。&lt;/li&gt;&lt;li data-pid=&quot;p-ixTyVO&quot;&gt;&lt;b&gt;spring-webmvc&lt;/b&gt; ： 提供对 Spring MVC 的实现。&lt;/li&gt;&lt;li data-pid=&quot;uf0cEFAl&quot;&gt;&lt;b&gt;spring-websocket&lt;/b&gt; ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。&lt;/li&gt;&lt;li data-pid=&quot;swzXm0ql&quot;&gt;&lt;b&gt;spring-webflux&lt;/b&gt; ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Messaging&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;0FU9DXOS&quot;&gt;&lt;b&gt;spring-messaging&lt;/b&gt; 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring Test&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;sD3V41th&quot;&gt;Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。&lt;/p&gt;&lt;p data-pid=&quot;hrNQ_sZM&quot;&gt;Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;WTaWWIah&quot;&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;&lt;p data-pid=&quot;qzayFgrX&quot;&gt;Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;&lt;p data-pid=&quot;KCudy2cQ&quot;&gt;下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;eoDUqwpe&quot;&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q3RbJ1ZG&quot;&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;&lt;p data-pid=&quot;cYPoAbUu&quot;&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;&lt;p data-pid=&quot;br5ypV5F&quot;&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring IoC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 Spring IoC 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;_kdBjvmW&quot;&gt;&lt;b&gt;IoC（Inverse of Control:控制反转）&lt;/b&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;&lt;p data-pid=&quot;48OxSyn-&quot;&gt;&lt;b&gt;为什么叫控制反转？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;JI_TUrNY&quot;&gt;&lt;b&gt;控制&lt;/b&gt; ：指的是对象创建（实例化、管理）的权力&lt;/li&gt;&lt;li data-pid=&quot;t5PSuvqI&quot;&gt;&lt;b&gt;反转&lt;/b&gt; ：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;GWqolc05&quot;&gt;将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/p&gt;&lt;p data-pid=&quot;G2IBfAcj&quot;&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;&lt;p data-pid=&quot;j6uuhGwr&quot;&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;&lt;p data-pid=&quot;iDS1lAjf&quot;&gt;Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。&lt;/p&gt;&lt;p data-pid=&quot;QuvfWkhE&quot;&gt;相关阅读：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring Bean？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tREpF7hs&quot;&gt;简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。&lt;/p&gt;&lt;p data-pid=&quot;CEcokO1u&quot;&gt;我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;pRqfzGbk&quot;&gt;下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;0Mub_iuf&quot;&gt;org.springframework.beans和 org.springframework.context 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看&lt;/p&gt;&lt;h3&gt;&lt;b&gt;将一个类声明为 Bean 的注解有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;YlRADxNm&quot;&gt;@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。&lt;/li&gt;&lt;li data-pid=&quot;k6wQYVO-&quot;&gt;@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;&lt;li data-pid=&quot;O1dgwjYU&quot;&gt;@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;&lt;li data-pid=&quot;f5OapWoq&quot;&gt;@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Component 和 @Bean 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;xy-ds-X3&quot;&gt;@Component 注解作用于类，而@Bean注解作用于方法。&lt;/li&gt;&lt;li data-pid=&quot;fkcZUfK0&quot;&gt;@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;&lt;li data-pid=&quot;M-d9l9kU&quot;&gt;@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ZdVry_Go&quot;&gt;@Bean注解使用示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;KFct29sE&quot;&gt;上面的代码相当于下面的 xml 配置&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transferService&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.acme.TransferServiceImpl&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;mWTl__L1&quot;&gt;下面这个例子是通过 @Component 无法实现的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;注入 Bean 的注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;2cPfZnOc&quot;&gt;Spring 内置的 @Autowired 以及 JDK 内置的 @Resource 和 @Inject 都可以用于注入 Bean。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Annotaion&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Source&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Autowired&lt;/td&gt;&lt;td&gt;org.springframework.bean.factory&lt;/td&gt;&lt;td&gt;Spring 2.5+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Resource&lt;/td&gt;&lt;td&gt;javax.annotation&lt;/td&gt;&lt;td&gt;Java JSR-250&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Inject&lt;/td&gt;&lt;td&gt;javax.inject&lt;/td&gt;&lt;td&gt;Java JSR-330&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;Ge225ACS&quot;&gt;@Autowired 和@Resource使用的比较多一些。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;@Autowired 和 @Resource 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Z7KU5GkS&quot;&gt;Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。&lt;/p&gt;&lt;p data-pid=&quot;bHoiWhDe&quot;&gt;&lt;b&gt;这会有什么问题呢？&lt;/b&gt; 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。&lt;/p&gt;&lt;p data-pid=&quot;QIqWZ-67&quot;&gt;这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// smsService 就是我们上面所说的名称
@Autowired
private SmsService smsService;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;LaXvI4z5&quot;&gt;举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsServiceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入  SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// smsServiceImpl1 就是我们上面所说的名称
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;smsServiceImpl1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;zU9bsxj2&quot;&gt;我们还是建议通过 @Qualifier 注解来显示指定名称而不是依赖变量的名称。&lt;/p&gt;&lt;p data-pid=&quot;n657xaF_&quot;&gt;@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。&lt;/p&gt;&lt;p data-pid=&quot;Ptbedm2e&quot;&gt;@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;jqQZyRiw&quot;&gt;如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsServiceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;smsServiceImpl1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;-UaQIws7&quot;&gt;简单总结一下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;-2keCio9&quot;&gt;@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。&lt;/li&gt;&lt;li data-pid=&quot;g1ded-v1&quot;&gt;Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。&lt;/li&gt;&lt;li data-pid=&quot;P7Uwn-4s&quot;&gt;当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Bean 的作用域有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;gGKqZoMB&quot;&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zRxa5A5O&quot;&gt;&lt;b&gt;singleton&lt;/b&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;&lt;li data-pid=&quot;HfPvdoFB&quot;&gt;&lt;b&gt;prototype&lt;/b&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。&lt;/li&gt;&lt;li data-pid=&quot;yW8gM9wM&quot;&gt;&lt;b&gt;request&lt;/b&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;&lt;li data-pid=&quot;aeNFSz1B&quot;&gt;&lt;b&gt;session&lt;/b&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;&lt;li data-pid=&quot;zfpzLyaE&quot;&gt;&lt;b&gt;application/global-session&lt;/b&gt; （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;&lt;li data-pid=&quot;t7BLtbO4&quot;&gt;&lt;b&gt;websocket&lt;/b&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Wdap7ETM&quot;&gt;&lt;b&gt;如何配置 bean 的作用域呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;29giT_HY&quot;&gt;xml 方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;UMCqoKq7&quot;&gt;注解方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SCOPE_PROTOTYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;personPrototype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;单例 Bean 的线程安全问题了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;E_4_mWHp&quot;&gt;大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。&lt;/p&gt;&lt;p data-pid=&quot;ExRxpR-Z&quot;&gt;常见的有两种解决办法：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;eTV1EOca&quot;&gt;在 Bean 中尽量避免定义可变的成员变量。&lt;/li&gt;&lt;li data-pid=&quot;KUCz4zQ7&quot;&gt;在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;MB7k8ziy&quot;&gt;不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Bean 的生命周期了解么?&lt;/b&gt;&lt;/h3&gt;&lt;blockquote data-pid=&quot;oampAYZw&quot;&gt; 下面的内容整理自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yemengying.com/2016/07/14/spring-bean-life-cycle/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;yemengying.com/2016/07/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;14/spring-bean-life-cycle/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ，除了这篇文章，再推荐一篇很不错的文章 ：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zrtqsk/p/3735273.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/zrtqsk/p/37&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;35273.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。  &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;qd-_Toh4&quot;&gt;Bean 容器找到配置文件中 Spring Bean 的定义。&lt;/li&gt;&lt;li data-pid=&quot;9JVRpXBt&quot;&gt;Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。&lt;/li&gt;&lt;li data-pid=&quot;MFG_N1Dq&quot;&gt;如果涉及到一些属性值 利用 set()方法设置一些属性值。&lt;/li&gt;&lt;li data-pid=&quot;3h09eSOd&quot;&gt;如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。&lt;/li&gt;&lt;li data-pid=&quot;z-LEAXdZ&quot;&gt;如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;KV0BiiqN&quot;&gt;如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;1779JQyl&quot;&gt;与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。&lt;/li&gt;&lt;li data-pid=&quot;Rq_SSfz4&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法&lt;/li&gt;&lt;li data-pid=&quot;Ds902rmV&quot;&gt;如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。&lt;/li&gt;&lt;li data-pid=&quot;9_H6FYLc&quot;&gt;如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。&lt;/li&gt;&lt;li data-pid=&quot;C9L9qkjM&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法&lt;/li&gt;&lt;li data-pid=&quot;AmUizyp5&quot;&gt;当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。&lt;/li&gt;&lt;li data-pid=&quot;szyswK-N&quot;&gt;当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;2WeqIgNz&quot;&gt;图示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;jIkD0nHY&quot;&gt;与之比较类似的中文版本:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;Spring AoP&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 AOP 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;OXXJZruw&quot;&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;&lt;p data-pid=&quot;C_-lAJri&quot;&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;b&gt;JDK Proxy&lt;/b&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;b&gt;Cglib&lt;/b&gt; 生成一个被代理对象的子类来作为代理，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot;/&gt;&lt;figcaption&gt;SpringAOPProcess&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;NDONXps6&quot;&gt;当然你也可以使用 &lt;b&gt;AspectJ&lt;/b&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;&lt;p data-pid=&quot;IjfseH-n&quot;&gt;AOP 切面编程设计到的一些专业术语：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;术语&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;目标(Target)&lt;/td&gt;&lt;td&gt;被通知的对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理(Proxy)&lt;/td&gt;&lt;td&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;连接点(JoinPoint)&lt;/td&gt;&lt;td&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切入点(Pointcut)&lt;/td&gt;&lt;td&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通知(Advice)&lt;/td&gt;&lt;td&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切面(Aspect)&lt;/td&gt;&lt;td&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Weaving(织入)&lt;/td&gt;&lt;td&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;QZYNjqVz&quot;&gt;&lt;b&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/b&gt; Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;&lt;p data-pid=&quot;cito6I0x&quot;&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，&lt;/p&gt;&lt;p data-pid=&quot;GpGyl7Qa&quot;&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;AspectJ 定义的通知类型有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;hRntEfQu&quot;&gt;&lt;b&gt;Before&lt;/b&gt;（前置通知）：目标对象的方法调用之前触发&lt;/li&gt;&lt;li data-pid=&quot;qsGNYMXI&quot;&gt;&lt;b&gt;After&lt;/b&gt; （后置通知）：目标对象的方法调用之后触发&lt;/li&gt;&lt;li data-pid=&quot;ygUb0DaU&quot;&gt;&lt;b&gt;AfterReturning&lt;/b&gt;（返回通知）：目标对象的方法调用完成，在返回结果值之后触发&lt;/li&gt;&lt;li data-pid=&quot;_DY3DiFW&quot;&gt;&lt;b&gt;AfterThrowing&lt;/b&gt;（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。&lt;/li&gt;&lt;li data-pid=&quot;zmhtoksK&quot;&gt;&lt;b&gt;Around&lt;/b&gt;： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;多个切面的执行顺序如何控制？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Fu46aNTv&quot;&gt;1、通常使用@Order 注解直接定义切面顺序&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 值越小优先级越高
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ordered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;zH_0pO7a&quot;&gt;&lt;b&gt;2、实现Ordered 接口重写 getOrder 方法。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ordered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 返回值越小优先级越高
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;Spring MVC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;说说自己对于 Spring MVC 了解?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;r7QDh2Pn&quot;&gt;MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;17wSFqs-&quot;&gt;网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/iluwatar/java-design-patterns&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;java-design-patterns&lt;/a&gt;** 项目中就有关于 MVC 的相关介绍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4D9V8YJP&quot;&gt;想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。&lt;/p&gt;&lt;p data-pid=&quot;J8z4Bygh&quot;&gt;&lt;b&gt;Model 1 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;a9agJY0E&quot;&gt;很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。&lt;/p&gt;&lt;p data-pid=&quot;MbYU0ZvK&quot;&gt;这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot;/&gt;&lt;figcaption&gt;mvc-mode1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tREuwrw1&quot;&gt;&lt;b&gt;Model 2 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;uvGBmEL1&quot;&gt;学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MyzUfVoa&quot;&gt;Model:系统涉及的数据，也就是 dao 和 bean。&lt;/li&gt;&lt;li data-pid=&quot;JHavbVzg&quot;&gt;View：展示模型中的数据，只是用来展示。&lt;/li&gt;&lt;li data-pid=&quot;9Fe7J2f0&quot;&gt;Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Vdg7Q4n5&quot;&gt;Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。&lt;/p&gt;&lt;p data-pid=&quot;7vweY6uf&quot;&gt;于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。&lt;/p&gt;&lt;p data-pid=&quot;uTxGBasn&quot;&gt;&lt;b&gt;Spring MVC 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;OeCnWUxx&quot;&gt;随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。&lt;/p&gt;&lt;p data-pid=&quot;lf4AkWXf&quot;&gt;MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring MVC 的核心组件有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;DfpzHp_4&quot;&gt;记住了下面这些组件，也就记住了 SpringMVC 的工作原理。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;mZxPPCMD&quot;&gt;&lt;b&gt;DispatcherServlet&lt;/b&gt; ：&lt;b&gt;核心的中央处理器&lt;/b&gt;，负责接收请求、分发，并给予客户端响应。&lt;/li&gt;&lt;li data-pid=&quot;yLi7x_oB&quot;&gt;&lt;b&gt;HandlerMapping&lt;/b&gt; ：&lt;b&gt;处理器映射器&lt;/b&gt;，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;HzJ4Y3xl&quot;&gt;&lt;b&gt;HandlerAdapter&lt;/b&gt; ：&lt;b&gt;处理器适配器&lt;/b&gt;，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；&lt;/li&gt;&lt;li data-pid=&quot;6C4YD2DR&quot;&gt;&lt;b&gt;Handler&lt;/b&gt; ：&lt;b&gt;请求处理器&lt;/b&gt;，处理实际请求的处理器。&lt;/li&gt;&lt;li data-pid=&quot;-tZkpf5f&quot;&gt;&lt;b&gt;ViewResolver&lt;/b&gt; ：&lt;b&gt;视图解析器&lt;/b&gt;，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;SpringMVC 工作原理了解吗?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;WTtjFr8P&quot;&gt;&lt;b&gt;Spring MVC 原理如下图所示：&lt;/b&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;m1HSkGtd&quot;&gt; SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。  &lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TWiYsFIn&quot;&gt;&lt;b&gt;流程说明（重要）：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;Kt6pgw1S&quot;&gt;客户端（浏览器）发送请求， DispatcherServlet拦截请求。&lt;/li&gt;&lt;li data-pid=&quot;G7q1kTx7&quot;&gt;DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;xLBSI4VD&quot;&gt;DispatcherServlet 调用 HandlerAdapter适配执行 Handler 。&lt;/li&gt;&lt;li data-pid=&quot;--qaNoGQ&quot;&gt;Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。&lt;/li&gt;&lt;li data-pid=&quot;XX3SBhgT&quot;&gt;ViewResolver 会根据逻辑 View 查找实际的 View。&lt;/li&gt;&lt;li data-pid=&quot;nwviXbuz&quot;&gt;DispaterServlet 把返回的 Model 传给 View（视图渲染）。&lt;/li&gt;&lt;li data-pid=&quot;kjnpTAOB&quot;&gt;把 View 返回给请求者（浏览器）&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;统一异常处理怎么做？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;J_xbRa4X&quot;&gt;推荐使用注解的方式统一异常处理，具体会使用到 @ControllerAdvice + @ExceptionHandler 这两个注解 。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ResponseBody&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GlobalExceptionHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleAppException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//......
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResourceNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ErrorReponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleResourceNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResourceNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//......
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;GE_1EL41&quot;&gt;这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。&lt;/p&gt;&lt;p data-pid=&quot;zV1kWuD_&quot;&gt;ExceptionHandlerMethodResolver 中 getMappedMethod 方法决定了异常具体被哪个被 @ExceptionHandler 注解修饰的方法处理异常。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getMappedMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mappedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAssignableFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 不为空说明有方法处理异常
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 按照匹配程度从小到大排序
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionDepthComparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 返回处理异常的方法
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mappedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;gxNGu5g2&quot;&gt;从源代码看出：getMappedMethod()会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。&lt;/p&gt;&lt;p data-pid=&quot;Zsg3bAYV&quot;&gt;由于篇幅过多，部分内容没有放出来，你可以点击下面的链接进行在线阅读，体验更好一些。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_120x160.jpg&quot; data-image-width=&quot;361&quot; data-image-height=&quot;741&quot; data-text=&quot;Spring 常见面试题总结&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;DCZRDsnx&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 。这是我在大三开始准备秋招面试的时候创建的，已经维护了 4 年多了，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;x3TMP6mg&quot;&gt;并且，这个项目还推出了一个PDF版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;p77rmSsZ&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Java 面试指北 》&lt;/a&gt; 是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QUWht3wd&quot;&gt;为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;。虽然收费只有培训班/训练营的百分之一，但是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;里的内容质量更高，提供的服务也更全面。&lt;/p&gt;&lt;p data-pid=&quot;3Y-AzN2P&quot;&gt;欢迎准备 Java 面试以及学习 Java 的同学加入我的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;，干货非常多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。&lt;/p&gt;&lt;p data-pid=&quot;DKBMAlDc&quot;&gt;我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>