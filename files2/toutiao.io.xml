<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>29815189d6e84cd053bfbb9592582a30</guid>
<title>Spring 之 Bean 生命周期源码解析</title>
<link>https://toutiao.io/k/5b3p9e1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;h1&gt;Bean的生命周期&lt;/h1&gt;&lt;p&gt;Spring最重要的功能就是帮助程序员创建对象(也就是IOC)，而启动Spring就是为创建对象做准备，所以我们要先明白Spring到底是怎么去创建Bean的，也就是先弄明白Bean的生命周期。&lt;/p&gt;&lt;p&gt;Bean的生命周期是指：&lt;strong&gt;在SpringBean中，一个Bean是如何生成、如何销毁的。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Bean的生命周期流程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5964125560538116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/75hyljzwsBbNhoWfbAZEmfoRoiaS0hq1yPbXyP5MD7Qp9Ds7qNntwTBngqT8g8wkiaHibnJLfLJEyPqEOPaw78oQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注册BeanDefinition&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;合并BeanDefinition&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;加载类&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实例化前处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;推断构造函数&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实例化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BeanDefinition后置处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性填充&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行Aware&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初始化前置处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初始化后置处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注册销毁接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;1.注册BeanDefinition&lt;/h1&gt;&lt;h2&gt;BeanDefinition是什么&lt;/h2&gt;&lt;p&gt;BeanDefinition中存在很多属性用来描述一个Bean的特点，比如：&lt;/p&gt;&lt;h2&gt;为什么需要BeanDefinition&lt;/h2&gt;&lt;p&gt;Spring IOC容器本质上是一个ConcurrentHashMap，key为Bean的Name，Value为Bean的实例对象。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.05527638190954774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/75hyljzwsBbNhoWfbAZEmfoRoiaS0hq1yUW1Nia6nL9OvgyuTcK0rMjYCevpgu8Bn2raumMWLiatOqQsjlIhcCALA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;6368&quot;/&gt;&lt;/p&gt;&lt;p&gt;也许你会说，我通过反射机制实例化一个目标对象，以Bean类型名称为key，目标对象为value，存入IOC容器中，不就可以了吗？Spring为什么要搞这么复杂？&lt;/p&gt;&lt;p&gt;我想，Spring之所以这样设计的目的，是可定制性及扩展性。Spring作为一个容器框架，通过IOC(控制反转)和DI(依赖注入)实现Bean之间依赖关系的管理以及Bean的生命周期管理。要实现Bean依赖关系的管理，必然要识别出依赖关系，并把这些信息保存下来以供创建Bean实例时使用 ；要实现Bean的生命周期管理，必然要识别出Bean有哪些生命周期扩展点以及每个扩展点的处理逻辑，并把这些信息保存下来以供创建Bean实例时使用。&lt;/p&gt;&lt;p&gt;这些信息可以看作是Bean的元数据信息，它们应该保存在哪儿呢？&lt;/p&gt;&lt;p&gt;说到这儿，你应该已经恍然大悟了，这些元数据信息就保存在BeanDefinition中，这些元数据信息将会用于指导Bean的创建及生命周期管理。&lt;/p&gt;&lt;h2&gt;怎么注册BeanDefinition&lt;/h2&gt;&lt;p&gt;在Spring中，我们经常会通过以下几种方式来定义Bean&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&amp;lt;bean /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;@Component(@Service，@Controller等)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这些，我们可以称之为&lt;strong&gt;声明式定义Bean&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我们还可以&lt;strong&gt;编程式定义Bean&lt;/strong&gt;，即直接通过BeanDefinition，比如：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.13986013986013987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/75hyljzwsBbNhoWfbAZEmfoRoiaS0hq1yQja6KQDbiaCteOnyMicCsK0r5OeaYoicneLdribyDe6V5yzibEd6icj9o7QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;6864&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们还可以通过BeanDefinition设置Bean的其他属性，比如：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.14285714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/75hyljzwsBbNhoWfbAZEmfoRoiaS0hq1ywas2U15Qt2Q2hh5DmqgF0frDajVXApsT2wthBerkKvpk3CGTdgEWnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4256&quot;/&gt;&lt;/p&gt;&lt;h1&gt;2.合并BeanDefinition&lt;/h1&gt;&lt;p&gt;通过扫描得到所有BeanDefinition之后，就可以根据BeanDefinition创建Bean对象了，但是在Spring中支持父子BeanDefinition。&lt;/p&gt;&lt;p&gt;父子BeanDefinition实际用的比较少，使用是这样的，比如：&lt;/p&gt;&lt;p&gt;这么定义的情况下，child是单例Bean。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;parent&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.zhouyu.service.Parent&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;prototype&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;child&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.zhouyu.service.Child&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;但是这么定义的情况下，child就是原型Bean了。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;parent&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.zhouyu.service.Parent&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;prototype&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;child&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.zhouyu.service.Child&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;parent&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;因为child的父BeanDefinition是parent，所以会继承parent上所定义的scope属性，当然，其他属性也会继承。而在根据child来生成Bean对象之前，需要进行BeanDefinition的合并，得到完整child的BeanDefinition。&lt;/p&gt;&lt;h1&gt;3.加载类&lt;/h1&gt;&lt;p&gt;BeanDefinition合并之后，就可以先去创建Bean对象了，而创建Bean就必须先实例化对象，而实例化就必须先加载BeanDefinition中对应的class，在AbstractAutowireCapableBeanFactory类的createBean方法中，一开始就会调用：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&lt;/span&gt;&lt;span&gt; resolvedClass &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; resolveBeanClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mbd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; beanName&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;这行代码就是去加载类，方法是这么实现的：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mbd&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;hasBeanClass&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mbd&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getBeanClass&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getSecurityManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;!=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;AccessController&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;doPrivileged&lt;/span&gt;&lt;span&gt;((&lt;/span&gt;&lt;span&gt;PrivilegedExceptionAction&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&amp;gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        doResolveBeanClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mbd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; typesToMatch&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;span&gt; getAccessControlContext&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; doResolveBeanClass&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;mbd&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; typesToMatch&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasBeanClass&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;beanClass &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;如果beanClass属性的类型是Class，就直接返回；如果不是，则会根据类名进行加载(doResolveBeanClass方法所做的事情)&lt;/p&gt;&lt;p&gt;doResolveBeanClass方法会利用BeanFactory设置的类加载器来加载类，如果没有设置，则默认使用ClassUtils.getDefaultClassLoader()所返回的类加载器来加载。&lt;/p&gt;&lt;p&gt;ClassUtils.getDefaultClassLoader()&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优先返回当前线程中的ClassLoader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程中类加载器为null的情况下，返回ClassUtils类的类加载器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果ClassUtils的类加载器为null，那么则表示是Bootstrap类加载器加载的ClassUtils类，那么则返回APP ClassLoader&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;也许你会有一个疑问，为什么不在扫描指定路径下就加载类呢？&lt;/p&gt;&lt;p&gt;我们都知道在Java中只有在真正使用一个类时，才会使用类加载器去加载该类对应的Class文件。Spring启动扫描时，如果指定的路径比较宽泛，那么扫描的类时非常多的，如果在Spring启动时就把这些类全部加载进JVM中，这样就不太好了。Spring启动扫描时，使用了ASM技术去解析类的信息，并不会真正的加载类。&lt;/p&gt;&lt;h1&gt;4.实例化前置处理&lt;/h1&gt;&lt;p&gt;当前BeanDefinition对应的类加载成功后，就可以实例化对象了，但是。。。&lt;/p&gt;&lt;p&gt;在Spring中，实例化对象之前，Spring提供了一个扩展点，允许用户来控制在某个或某些Bean实例化之前做一些启动动作。这个扩展点叫&lt;strong&gt;InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()&lt;/strong&gt;。如果postProcessBeforeInstantiation()方法返回一个非空对象，表示不需要Spring来实例化，而且后续的Spring依赖注入也不会进行了，会跳过一些步骤，直接执行初始化后置处理这一步。&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CustomBeanPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;InstantiationAwareBeanPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; postProcessBeforeInstantiation&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&lt;/span&gt;&lt;span&gt; beanClass&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; beanName&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BeansException&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;userService&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;beanName&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;实例化前&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;h1&gt;5.实例化&lt;/h1&gt;&lt;p&gt;在这个步骤中就会根据BeanDefinition去创建一个对象了。&lt;/p&gt;&lt;h2&gt;5.1 Supplier创建对象&lt;/h2&gt;&lt;p&gt;首先判断BeanDefinition中是否设置了Supplier，如果设置了则调用Supplier的get()得到对象。&lt;/p&gt;&lt;p&gt;我们可以使用BeanDefinition对象来设置Supplier，比如：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;AbstractBeanDefinition&lt;/span&gt;&lt;span&gt; beanDefinition &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BeanDefinitionBuilder&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;genericBeanDefinition&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getBeanDefinition&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;beanDefinition&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setInstanceSupplier&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Supplier&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;UserService&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;context&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;registerBeanDefinition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;userService&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; beanDefinition&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;h2&gt;5.2 工厂方法创建对象&lt;/h2&gt;&lt;p&gt;如果没有设置Supplier，则检查BeanDefinition中是否设置了factoryMethod，也就是工厂方法，有两种方法可以设置factoryMethodName，比如：&lt;/p&gt;&lt;p&gt;方式一：直接指定factory-method属性&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;userService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.test.service.UserService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;factory-method&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;createUserService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;方式二：同时指定factory-bean和factory-method属性&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;commonService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;com.test.service.CommonService&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;bean&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;userService1&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;factory-bean&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;commonService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;factory-method&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;createUserService&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，我们通过@Bean所定义的BeanDefinition，是存在factoryMethod和factoryBean的，也就是和方式二类似，factoryMethod就是@Bean注解的方法，factoryBean就是配置类的Bean实例。&lt;/p&gt;&lt;h2&gt;5.3 推断构造方法&lt;/h2&gt;&lt;p&gt;如果没有设置Supplier，也没有指定factory-bean和factory-method，就需要选择一个构造方法来进行实例化了。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先检查是否指定了具体的构造方法或构造方法参数值，或者在BeanDefinition中缓存了具体的构造方法或构造方法参数值，如果存在那么就直接使用该构造方法进行实例化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果没有确定的构造方法或构造方法参数值，那么&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果没有确定的构造方法，那么则找出类中所有的构造方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果只有一个无参的构造方法，那么直接使用无参的构造方法进行实例化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果有多个可用的构造方法，根据getBean指定的构造方法参数值对这些构造方法的匹配程度进行打分，找到一个最匹配的。匹配程度打分的算法很复杂，这里就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;6.BeanDefinition后置处理&lt;/h1&gt;&lt;p&gt;Bean对象实例化出来之后，接下来就应该给对象的属性进行赋值了。在真正给属性进行赋值之前，Spring又提供了一个扩展点 &lt;strong&gt;MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()&lt;/strong&gt;，可以对此时的BeanDefinition进行加工，比如：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CustomMergedBeanDefinitionPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;MergedBeanDefinitionPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; postProcessMergedBeanDefinition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;RootBeanDefinition&lt;/span&gt;&lt;span&gt; beanDefinition&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;&amp;lt;?&amp;gt;&lt;/span&gt;&lt;span&gt; beanType&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; beanName&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;userService&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;beanName&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;      beanDefinition&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPropertyValues&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;orderService&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;OrderService&lt;/span&gt;&lt;span&gt;());&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;p&gt;在Spring中，AutowiredAnnotationBeanPostProcessor就是一个MergedBeanDefinitionPostProcessor，它的postProcessMergedBeanDefinition方法中会去查找注入点，并缓存在AutowiredAnnotationBeanPostProcessor的对象的一个Map中(injectionMetadataCache)。&lt;/p&gt;&lt;h1&gt;7.实例化后&lt;/h1&gt;&lt;p&gt;在处理完BeanDefinition后，Spring又设计了一个扩展点：&lt;strong&gt;InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()&lt;/strong&gt;，利用这个扩展点可以对Bean实例对象进行处理。&lt;/p&gt;&lt;h1&gt;8.属性填充&lt;/h1&gt;&lt;p&gt;这个步骤中，就会处理@Autowired、@Resource等注解，也是通过&lt;strong&gt;instantiationAwareBeanPostProcessor.postProcessProperties()&lt;/strong&gt;扩展点来实现的，我们甚至可以实现自定义的自动注入功能，比如：&lt;/p&gt;&lt;pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;CustomInstantiationAwareBeanPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;InstantiationAwareBeanPostProcessor&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;PropertyValues&lt;/span&gt;&lt;span&gt; postProcessProperties&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;PropertyValues&lt;/span&gt;&lt;span&gt; pvs&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; bean&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; beanName&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BeansException&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;userService&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;beanName&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;Field&lt;/span&gt;&lt;span&gt; field &lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bean&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getClass&lt;/span&gt;&lt;span&gt;().&lt;/span&gt;&lt;span&gt;getFields&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;isAnnotationPresent&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;ZhouyuInject&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                    field&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setAccessible&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                        field&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&quot;123&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;IllegalAccessException&lt;/span&gt;&lt;span&gt; e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                        e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;printStackTrace&lt;/span&gt;&lt;span&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pvs&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt;&lt;h2&gt;@Value实现原理&lt;/h2&gt;&lt;p&gt;@Value可以指定目标bean的名字，如果指定了目标bean的名字，则根据指定的名字从容器中查找到目标表，赋值给@Value注解的属性高。&lt;/p&gt;&lt;h2&gt;@Autowired实现原理&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;先根据type查找bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检查BeanDefinition的autowireCandidate属性，为true表示通过筛选&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检查BeanDefinition的beanClass属性是否和当前注入点的type匹配，匹配则通过筛选&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检查BeanDefinition的qualifier属性是否和当前注入点的qualifier属性匹配，匹配则通过筛选&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果第1步没有找到bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果isRequired为true，直接报错&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果isRequired为false，返回null&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果第1步找到唯一匹配的bean，直接返回&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果第一步找到多个bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从多个bean中选择标注了@Primary注解的Bean，如果有多个bean标注了@Primary会报错&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果没有找到标注@Primary的bean，看是否定义了@Priority，如果定义了则获取优先级最高的bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果没有定义优先级，则根据属性名或方法参数名查找，如果找到了直接返回；如果找不到，且isRequired属性为true，直接报错；否则返回null&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;@Resource实现原理&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果@Resource指定了name属性，则只会根据name指定的名称获取bean，如果找不到则报错&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果没有指定name属性，则以当前注入点名称（属性名）为名称进行查找，如果找到，直接返回；如果找不到，则根据注入点类型继续查找。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;9.执行Aware&lt;/h1&gt;&lt;p&gt;完成了属性赋值之后，Spring会执行一些Aware回调，包括：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BeanNameAware：回传beanName给bean对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BeanClassLoaderAware：回传classLoader给bean对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BeanFactoryAware：回传beanFactory给对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;10.初始化前置处理&lt;/h1&gt;&lt;p&gt;初始化前，也是Spring提供的一个扩展点：&lt;strong&gt;BeanPostProcessor.postProcessBeforeInitialization()&lt;/strong&gt;，利用这个扩展点，可以对进行了依赖注入的Bean进行加工处理。&lt;/p&gt;&lt;p&gt;在Spring中，&lt;strong&gt;InitDestroyAnnotationBeanPostProcessor&lt;/strong&gt;、&lt;strong&gt;ApplicationContextAwareProcessor&lt;/strong&gt;实现了这个扩展点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;BeanPostProcessor.postProcessBeforeInitialization&lt;/strong&gt;()：执行@PostConstruct标注的方法&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ApplicationContextAwareProcessor.postProcessBeforeInitialization&lt;/strong&gt;：执行其他@Aware的回调&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;EnvironmentAware：回传环境变量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;EmbeddedValueResolverAware：回传占位符解析器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ResourceLoaderAware：回传资源加载器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ApplicationEventPublisherAware：回传事件发布器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MessageSourceAware：回传国际化资源&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ApplicationStartupAware：回传应用其他监听对象，可忽略&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ApplicationContextAware：回传Spring容器ApplicationContext&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;11.初始化&lt;/h1&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查看当前Bean实例对象是否实现了InitializingBean接口 ，如果实现了就调用afterPropertiesSet()方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行BeanDefinition中指定的初始化方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;12.初始化后置处理&lt;/h1&gt;&lt;p&gt;这是Bean创建过程中的最后一个步骤，也是Spring提供的一个扩展点：&lt;strong&gt;BeanPostProcessor.postProcessAfterInitialization()&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;可以在这个步骤中，对Bean进行最终处理，Spring中的AOP就是基于这个扩展点实现的， postProcessAfterInitialization()方法返回的对象才是最终的Bean对象。&lt;/p&gt;&lt;h1&gt;13.注册销毁接口&lt;/h1&gt;&lt;p&gt;Bean的销毁是发生在Spring容器关闭过程中的。&lt;/p&gt;&lt;p&gt;在Bean创建过程中，在初始化后置处理之后，有一个步骤会判断当前创建的Bean是不是DisposableBean：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当前Bean是否实现了Disposablebean接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;或者，当前Bean是否实现了AutoCloseable接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;BeanDefinition中是否指定了destoryMethod&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;是否有被@PreDestory标注的方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;把符合上述任意一个条件的Bean适配成DisposableBeanAdapter对象，并存入disposableBeans中(一个LinkedHashMap)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在Spring容器关闭时：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先发布ContextClosedEvent事件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用lifecycleProcessor的onClose()方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;销毁单例Bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;遍历所有disposableBeans，把每个disposableBean从单例池中移除&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;调用disposableBean的destroy方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果被其他Bean依赖了，销毁其他Bean&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果还包含了innerBeans，将这些Bean从单例池中移除掉&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;以上就是我对Spring Bean生命周期源码的粗浅理解，Spring源码博大精深，以上解析未能面面俱到，亦或有错漏之处，欢迎大家批评指正。附赠我自己整理的关于Spring Bean生命周期思维导图链接，欢迎大家按需自取：&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://www.processon.com/view/link/60bf2df5e0b34d0950a5d052&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ab1232cb43e3593dab8909a80b74caa</guid>
<title>独立开发变现周刊（第75期）：我的 SaaS 模板代码库每月赚 4 千美元</title>
<link>https://toutiao.io/k/ef49oxe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body-box nuxt-content&quot;&gt;&lt;h1 id=&quot;独立开发变现周刊第75期我的saas模板代码库每月赚4千美元&quot;&gt;&lt;a href=&quot;#%E7%8B%AC%E7%AB%8B%E5%BC%80%E5%8F%91%E5%8F%98%E7%8E%B0%E5%91%A8%E5%88%8A%E7%AC%AC75%E6%9C%9F%E6%88%91%E7%9A%84saas%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81%E5%BA%93%E6%AF%8F%E6%9C%88%E8%B5%9A4%E5%8D%83%E7%BE%8E%E5%85%83&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;独立开发变现周刊（第75期）：我的SaaS模板代码库每月赚4千美元&lt;/h1&gt;
&lt;p&gt;分享独立开发、产品变现相关内容，每周五发布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1、html2canvas: 使用JavaScript网页截图&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2、Ezindie: 明星产品的开源替代项目&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;3、Sidekick: 一个让你变的专注的生产力浏览器桌面应用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4、我的SaaS模板开发套件每月赚4千美元&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1html2canvas-使用javascript网页截图&quot;&gt;&lt;a href=&quot;#1html2canvas-%E4%BD%BF%E7%94%A8javascript%E7%BD%91%E9%A1%B5%E6%88%AA%E5%9B%BE&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;1、html2canvas: 使用JavaScript网页截图&lt;/h2&gt;
&lt;p&gt;这是一个开源JS库，Github上有26K的Star，允许你直接在用户浏览器上对网页或部分网页进行“截屏”。截图是基于DOM的，因此可能不是100%准确的真实表示，因为它不制作实际的截图，而是基于页面上可用的信息构建截图。&lt;/p&gt;
&lt;p&gt;它不需要来自服务器的任何渲染，因为整个图像是在客户机的浏览器上创建的。但是，由于它严重依赖浏览器，这个库不适合在nodejs中使用。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzteb4xj31t00u0dla.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/niklasvh/html2canvas&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;html2canvas开源地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2ezindie-明星产品的开源替代项目&quot;&gt;&lt;a href=&quot;#2ezindie-%E6%98%8E%E6%98%9F%E4%BA%A7%E5%93%81%E7%9A%84%E5%BC%80%E6%BA%90%E6%9B%BF%E4%BB%A3%E9%A1%B9%E7%9B%AE&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;2、Ezindie: 明星产品的开源替代项目&lt;/h2&gt;
&lt;p&gt;市场上有很多优秀的产品，同时开源代码里也有类似产品的开源替代，这些开源项目能帮我们快速的实现产品。所以我整理了一些知名产品的开源替代项目，放到的ezindie网站上，今后如果有类似产品的需求，可以及时参考。这个集合页面会不断更新迭代。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzwcs5hj30u01bdtd5.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.ezindie.com/open-source-alternative&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ezindie的开源项目替代&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3sidekick-一个让你变的专注的生产力浏览器桌面应用&quot;&gt;&lt;a href=&quot;#3sidekick-%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BD%A0%E5%8F%98%E7%9A%84%E4%B8%93%E6%B3%A8%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A1%8C%E9%9D%A2%E5%BA%94%E7%94%A8&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;3、Sidekick: 一个让你变的专注的生产力浏览器桌面应用&lt;/h2&gt;
&lt;p&gt;Sidekick是一款面向知识工作者的生产力浏览器。是Mac上的一款桌面端应用，它集成了所有的web应用程序，以帮助保持组织和高效，同时加快你的工作流程。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzw4xxwj31sm0rsn1i.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消除标签混乱：会话帮助你分组，保存和打开标签，而不混乱。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvy21dj31320ogwhr.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多账户帮助您在Gmail、Slack、concept和messenger中的不同账户之间跳转，而无需注销。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvr0ymj313i0pmacx.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.meetsidekick.com/&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Sikekick官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4我的saas模板开发套件每月赚4千美元&quot;&gt;&lt;a href=&quot;#4%E6%88%91%E7%9A%84saas%E6%A8%A1%E6%9D%BF%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E6%AF%8F%E6%9C%88%E8%B5%9A4%E5%8D%83%E7%BE%8E%E5%85%83&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;4、我的SaaS模板开发套件每月赚4千美元&lt;/h2&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvnhz8j309y09y74n.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hi, 我是Alexandro，墨西哥人，我正在开发SaasRock，具有开箱即用的功能，如认证、订阅、验证、事件和Webhooks、定价计划构建器、博客、权限等。使用Remix、Tailwind CSS和Prisma构建，并与Stripe的支付功能、Postmark的邮件功能和Zapier的Webhooks功能进行了很好的集成。托管在Vercel上，使用Supabase作为数据库。&lt;/p&gt;
&lt;p&gt;我的目标用户是全栈开发人员和低代码工程师，他们希望用强大的初始代码库快速构建SaaS应用。&lt;/p&gt;
&lt;p&gt;SaasRock目前的月收入为4380美元。我在今年3月19日开始开发，并在6月1日进行了预发布。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvk96oj30nm0fijsm.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;你是怎么想到这个想法的&quot;&gt;&lt;a href=&quot;#%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E6%83%B3%E5%88%B0%E8%BF%99%E4%B8%AA%E6%83%B3%E6%B3%95%E7%9A%84&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;你是怎么想到这个想法的?&lt;/h3&gt;
&lt;p&gt;我是C#的开发人员，工作了8年，但我想开始构建web应用程序，所以我学习了Vue2，为我的客户建立了两个网站。&lt;/p&gt;
&lt;p&gt;我喜欢前端的Vue和后端的 .NET，所以我建立了一个叫做NetcoreSaas的样板，一个基于 .NET、Vue和Tailwind CSS的SaaS代码库。我在AppSumo上发布了这款模板，总共获得了大约50名用户。&lt;/p&gt;
&lt;p&gt;但我觉得我的开发可以更快，于是将Vue2应用迁移到Vue3，然后是React，然后是slvelte。结果是相同的样板，但有不同的前端，我称之为saasfrontend。过了一段时间，我从中赚到了765美元。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvh99mj30nm06yt9b.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我发现了Remix，一个专注于web标准的全栈JavaScript框架。我立刻意识到这是一个完美的解决方案，所以我在7天内构建了“the Remix SaaS kit”(现在的SaasRock)的v0.0.1版本，并在24小时内免费提供。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzvd764j30nm0xi41q.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这条推文很受欢迎，因为Remix团队转发了它，我获得了超过1000次的下载:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzv8qbdj30nm0egwgl.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这一点上，我决定开源其他SaaS套件，并专注于SaasRock。&lt;/p&gt;
&lt;h3 id=&quot;描述下启动业务的过程&quot;&gt;&lt;a href=&quot;#%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%90%AF%E5%8A%A8%E4%B8%9A%E5%8A%A1%E7%9A%84%E8%BF%87%E7%A8%8B&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;描述下启动业务的过程&lt;/h3&gt;
&lt;p&gt;所有这些都是我自己启动的。我为saasrock的域名支付了大约300美元，为logo支付了250美元(我没有使用)，为托管+数据库支付了70美元/月。&lt;/p&gt;
&lt;p&gt;这是网站第一次发布时的样子:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzv4aj2j30nm0cbab2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是它现在的样子:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzv16prj30nm0djjsk.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于每个网站我发布我需要:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;购买一个域名&lt;/li&gt;
&lt;li&gt;创建Stripe帐户&lt;/li&gt;
&lt;li&gt;创建一个邮戳服务器&lt;/li&gt;
&lt;li&gt;创建一个Gmail帐户谷歌工作区与我的域&lt;/li&gt;
&lt;li&gt;创建一个Twitter账户&lt;/li&gt;
&lt;li&gt;创建一个Instagram账号&lt;/li&gt;
&lt;li&gt;创建一个自定义标志和插图Canva&lt;/li&gt;
&lt;li&gt;使用Cloudflare设置域&lt;/li&gt;
&lt;li&gt;将我的代码提交到私有的GitHub存储库&lt;/li&gt;
&lt;li&gt;创建Supabase数据库服务器&lt;/li&gt;
&lt;li&gt;部署到Vercel&lt;/li&gt;
&lt;li&gt;在IH、Medium、Dev.to、HN、hashnode和LinkedIn上发表博文&lt;/li&gt;
&lt;li&gt;在twitter上发布博文&lt;/li&gt;
&lt;li&gt;使用ConvertKit发送我的通讯订阅博客文章&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要有3个阶段:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段:免费24小时 - 3月28日&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于v0.0.1，我获得了大约1000个gumroad“客户”(每人0美元)，我的手机通知一直响个不停。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzuxkk2j30nm0f0di2.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终结果:1066人下载了Remix SaaS套件v0.0.1。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzurkn1j30nm1cdgqs.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段:Remix SaaS套件 — 3月29日 — 299美元&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二天，我将口gumroad的价格从0美元调整到299美元。第一天，我得到了2个客户，第二天又有一个客户，到4月底，我得到了19个客户，总计3063美元(我给几乎所有要求的人都提供了折扣)。&lt;/p&gt;
&lt;p&gt;April Remix SaaS套件客户:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzuibo9j30nm19djuj.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Remix SaaS套件的整体分析:&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzucc86j30nm0qp408.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个阶段，我遇到了我的产品/营销导师和朋友Chris Kluis。他主动提出帮助我编写样板，因为他对SaaS应用程序很感兴趣。他指出了两件事:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到一个与Remix脱钩的域名，并新域名做发布&lt;/li&gt;
&lt;li&gt;每月从299美元改为99美元。&lt;/li&gt;
&lt;li&gt;于是我把它命名为saasrock.com。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第三阶段：SaasRock发布前 — 6月1日 — 99美元/月&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在发布前，Chris和我决定推出一个核心版和一个企业版。&lt;/p&gt;
&lt;p&gt;$99/m:构建SaaS所需的一切。
$149/m:核心+企业功能:单点登录，附属+推荐，HelpDesk…&lt;/p&gt;
&lt;p&gt;在推出saasrock.com两天之后，我获得了第一个99美元的订阅者。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzu8xhkj30nm0jw75c.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;截至9月15日，也就是发行前的3个月，我已经拥有69名用户，并获得了8000美元的收益。虽然还不足以让你全职工作，但足以让你知道Remix SaaS样板的市场是有潜力的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uzu36yvj30nm0hwjsl.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;自推出以来是什么有效地吸引和留住了客户&quot;&gt;&lt;a href=&quot;#%E8%87%AA%E6%8E%A8%E5%87%BA%E4%BB%A5%E6%9D%A5%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E6%95%88%E5%9C%B0%E5%90%B8%E5%BC%95%E5%92%8C%E7%95%99%E4%BD%8F%E4%BA%86%E5%AE%A2%E6%88%B7&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;自推出以来，是什么有效地吸引和留住了客户?&lt;/h3&gt;
&lt;p&gt;启动Discord是关键。通过这种方式，围绕SaasRock的社区正在成长，每个人都在分享他们对SaasRock应该往何处发展的想法。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uztzkx4j30nm0nmabd.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，得到关于我和产品的反馈和好评会让我有动力去回馈!&lt;/p&gt;
&lt;p&gt;排名前三的话题是:&lt;/p&gt;
&lt;p&gt;#general - 我会让每个人都知道我现在在做什么，以及我接下来要做什么。&lt;/p&gt;
&lt;p&gt;#反馈 - 成员们会通知我他们遇到的错误并反馈他们的问题，有时他们互相帮助是如此的高兴。&lt;/p&gt;
&lt;p&gt;#enterprise - 我们谈论即将到来的企业功能。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uztuwuwj30nm0futa9.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总的来说，我认为discord服务可以让我在建立社区的同时与终端用户保持联系，这对SaasRock的前景来说是一个很好的证明。&lt;/p&gt;
&lt;h3 id=&quot;通过创业你学到了什么特别有用的东西吗&quot;&gt;&lt;a href=&quot;#%E9%80%9A%E8%BF%87%E5%88%9B%E4%B8%9A%E4%BD%A0%E5%AD%A6%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E7%89%B9%E5%88%AB%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%9C%E8%A5%BF%E5%90%97&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;通过创业，你学到了什么特别有用的东西吗?&lt;/h3&gt;
&lt;p&gt;优秀的编码是不够的。我认为最好的营销策略是“打造高质量的产品，顾客就会来”。我意识到我需要尝试所有我能想到的策略: 每隔一天推特、YouTube视频和博客帖子。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uztqndmj30nm0ebabd.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的营销策略的关键是一切都是相互联系的。我创建了一个功能，我把它添加到更新日志中，我创建了一篇关于它的博客文章，我把我的想法发在推特上，我发布一个YouTube视频解释如何使用它。所以现在，对于我创建的每个功能，我都有一个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blog:IH, Dev.to, Medium, Hashnode, LinkedIn和我的博客。&lt;/li&gt;
&lt;li&gt;YouTube视频&lt;/li&gt;
&lt;li&gt;推特&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重点是开始写你喜欢做的事情，&lt;strong&gt;这样你就可以围绕它建立一个系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;https://tva1.sinaimg.cn/large/008vxvgGly1h72uztko5rj30nm0b0q47.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对其他想要起步的开发者有什么建议&quot;&gt;&lt;a href=&quot;#%E5%AF%B9%E5%85%B6%E4%BB%96%E6%83%B3%E8%A6%81%E8%B5%B7%E6%AD%A5%E7%9A%84%E5%BC%80%E5%8F%91%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;span class=&quot;icon icon-link&quot;/&gt;&lt;/a&gt;对其他想要起步的开发者有什么建议?&lt;/h3&gt;
&lt;p&gt;开始行动，经验比天赋更重要。&lt;/p&gt;
&lt;p&gt;我害怕开设一个youtube频道，因为我需要频繁地发布内容:&lt;/p&gt;
&lt;p&gt;1)我担心会失去质量，&lt;/p&gt;
&lt;p&gt;2)我担心不会说英语。&lt;/p&gt;
&lt;p&gt;我一开始没有发布长视频，而是在Twitter上分享了Loom的短视频。&lt;/p&gt;
&lt;p&gt;慢慢的，我开始获得信心，在两个月后，我开始了SaasRock的youtube频道，这最终成为我在这个项目中做出的最好的决定之一，因为它使我保持进度和动力。&lt;/p&gt;
&lt;p&gt;本次周刊结束，欢迎大家投稿，我们下周见！&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e38b73cb0b5b85ac9850cb1297475572</guid>
<title>30+ 个工作中常用到的前端小知识</title>
<link>https://toutiao.io/k/r0cxucz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjgwMDIzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/udZl15qqib0OiahcrjrJncW0GOiclg6Jic6IQHYeIGzfXSbZicLUeUxNyQVmPSelMxQxTSu8wAibsyXjy9U3pVfic7FGA/0?wx_fmt=png&quot; data-nickname=&quot;全栈前端精选&quot; data-alias=&quot;Just_FED&quot; data-signature=&quot;内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. JS为什么单线程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一个简单的原因就是，&lt;code&gt;js&lt;/code&gt;在设计之初只是进行一些简单的表单校验，这完全不需要多线程，单线程完全可以胜任这项工作。即便后来前端发展迅速，承载的能力越来越多，也没有发展到非多线程不可的程度。&lt;/p&gt;&lt;p&gt;而且还有一个主要的原因，设想一下，如果&lt;code&gt;js&lt;/code&gt;是多线程的，在运行时多个线程同时对&lt;code&gt;DOM&lt;/code&gt;元素进行操作，那具体以哪个线程为主就是个问题了，线程的调度问题是一个比较复杂的问题。&lt;/p&gt;&lt;p&gt;&lt;code&gt;HTML5&lt;/code&gt;新的标准中允许使用&lt;code&gt;new Worker&lt;/code&gt;的方式来开启一个新的线程，去运行一段单独的&lt;code&gt;js&lt;/code&gt;文件脚本，但是在这个新线程中严格的要求了可以使用的功能，比如说他只能使用&lt;code&gt;ECMAScript&lt;/code&gt;, 不能访问&lt;code&gt;DOM&lt;/code&gt;和&lt;code&gt;BOM&lt;/code&gt;。这也就限制死了多个线程同时操作&lt;code&gt;DOM&lt;/code&gt;元素的可能。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.使用css写出一个三角形角标&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;元素宽高设置为&lt;code&gt;0&lt;/code&gt;，通过&lt;code&gt;border&lt;/code&gt;属性来设置，让其它三个方向的&lt;code&gt;border&lt;/code&gt;颜色为透明或者和背景色保持一致，剩余一条&lt;code&gt;border&lt;/code&gt;的颜色设置为需要的颜色。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;div&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;5px&lt;/span&gt; solid #transparent;&lt;br/&gt;    &lt;span&gt;border-top-color&lt;/span&gt;: red;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3.水平垂直居中&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;我一般只使用两种方式&lt;code&gt;定位&lt;/code&gt;或者&lt;code&gt;flex&lt;/code&gt;，我觉得够用了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;div&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;100px&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;position&lt;/span&gt;: absolute;&lt;br/&gt;    &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;right&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;margin&lt;/span&gt;: auto;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;父级控制子集居中&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;.parent&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;display&lt;/span&gt;: flex;&lt;br/&gt;    &lt;span&gt;justify-content&lt;/span&gt;: center;&lt;br/&gt;    &lt;span&gt;align-items&lt;/span&gt;: center;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4. css一行文本超出...&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;overflow&lt;/span&gt;: &lt;span&gt;hidden&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;text-overflow&lt;/span&gt;&lt;span&gt;:ellipsis&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;white-space&lt;/span&gt;: &lt;span&gt;nowrap&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;5.多行文本超出显示...&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;display&lt;/span&gt;: &lt;span&gt;-webkit-box&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;-webkit-box-orient&lt;/span&gt;: &lt;span&gt;vertical&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;-webkit-line-clamp&lt;/span&gt;: 3;&lt;br/&gt;&lt;span&gt;overflow&lt;/span&gt;: &lt;span&gt;hidden&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;6.IOS手机容器滚动条滑动不流畅&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;overflow&lt;/span&gt;: &lt;span&gt;auto&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;-webkit-overflow-scrolling&lt;/span&gt;: &lt;span&gt;touch&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;7.修改滚动条样式&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;隐藏&lt;code&gt;div&lt;/code&gt;元素的滚动条&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;::-webkit-scrollbar&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;display&lt;/span&gt;: none;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;div::-webkit-scrollbar 滚动条整体部分&lt;/p&gt;&lt;p&gt;div::-webkit-scrollbar-thumb 滚动条里面的小方块，能向上向下移动（或往左往右移动，取决于是垂直滚动条还是水平滚动条）&lt;/p&gt;&lt;p&gt;div::-webkit-scrollbar-track 滚动条的轨道&lt;/p&gt;&lt;p&gt;div::-webkit-scrollbar-button 滚动条的轨道的两端按钮，允许通过点击微调小方块的位置。&lt;/p&gt;&lt;p&gt;div::-webkit-scrollbar-track-piece 内层轨道，滚动条中间部分&lt;/p&gt;&lt;p&gt;div::-webkit-scrollbar-corner 边角，即两个滚动条的交汇处&lt;/p&gt;&lt;p&gt;div::-webkit-resizer 两个滚动条的交汇处上用于通过拖动调整元素大小的小控件&lt;/p&gt;&lt;p&gt;注意此方案有兼容性问题，一般需要隐藏滚动条时我都是用一个色块通过定位盖上去，或者将子级元素调大，父级元素使用overflow-hidden截掉滚动条部分。暴力且直接。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;8.解决ios audio无法自动播放、循环播放的问题&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ios&lt;/code&gt;手机在使用&lt;code&gt;audio&lt;/code&gt;或者&lt;code&gt;video&lt;/code&gt;播放的时候，个别机型无法实现自动播放，可使用下面的代码&lt;code&gt;hack&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 解决ios audio无法自动播放、循环播放的问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; music = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;video&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; state = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;document&lt;/span&gt;.addEventListener(&lt;span&gt;&#x27;touchstart&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(state==&lt;span&gt;0&lt;/span&gt;){&lt;br/&gt;        music.play();&lt;br/&gt;        state=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;document&lt;/span&gt;.addEventListener(&lt;span&gt;&quot;WeixinJSBridgeReady&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;    music.play();&lt;br/&gt;}, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//循环播放&lt;/span&gt;&lt;br/&gt;music.onended = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;    music.load();&lt;br/&gt;    music.play();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;9.隐藏页面元素&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;display-none: 元素不会占用空间，在页面中不显示，子元素也不会显示。&lt;/p&gt;&lt;p&gt;opacity-0: 元素透明度将为&lt;code&gt;0&lt;/code&gt;，但元素仍然存在，绑定的事件仍旧有效仍可触发执行。&lt;/p&gt;&lt;p&gt;visibility-hidden：元素隐藏，但元素仍旧存在，占用空间，页面中无法触发该元素的事件。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;10.前端工程化&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;一提到前端工程化很多人想到的都是&lt;code&gt;webpack&lt;/code&gt;，这是不对的，&lt;code&gt;webpack&lt;/code&gt;仅仅是前端工程化中的一环。在整个工程化过程中他帮我们解决了绝大多数的问题，但并没有解决所有问题。&lt;/p&gt;&lt;p&gt;前端工程化是通过工具提升效率，降低成本的一种手段。&lt;/p&gt;&lt;p&gt;近些年被广泛的关注和探讨，究其原因主要是因为现代化前端应用功能要求不断提高，业务逻辑日益复杂，作为当下互联网时代唯一不可或缺的技术，前端可以说是占据了整个开发行业的半壁江山。从传统的网站，到现在的&lt;code&gt;H5&lt;/code&gt;,移动&lt;code&gt;App&lt;/code&gt;,桌面应用，以及小程序。前端技术几乎是无所不能的全面覆盖。&lt;/p&gt;&lt;p&gt;在这些表象的背后呢，实际上是行业对开发人员的要求发生了天翻地覆的变化，以往前端写demo，套模板，调页面这种刀耕火种的方式已经完全不符合当下对开发效率的要求，前端工程化就是在这样一个背景下被提上台面，成为前端工程师必备的手段之一。&lt;/p&gt;&lt;p&gt;一般来说前端工程包含，项目初始化，项目开发，提交，构建，部署，测试，监控等流程。工程化就是以工程的角度来解决这些问题。比如项目初始化我们一般使用&lt;code&gt;npm init&lt;/code&gt;, 创建页面模板使用&lt;code&gt;plop&lt;/code&gt;，我们喜欢使用&lt;code&gt;ES6+&lt;/code&gt;开发，但是需要通过&lt;code&gt;babel&lt;/code&gt;编码成&lt;code&gt;ES5&lt;/code&gt;，持续集成的时候我们使用&lt;code&gt;git/ci cd&lt;/code&gt;，但是为了保持开发规范我们引入了&lt;code&gt;ESLint&lt;/code&gt;，部署一般使用&lt;code&gt;git/cd&lt;/code&gt;或者&lt;code&gt;jenkins&lt;/code&gt;等等。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;11.contenteditable&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;html&lt;/code&gt;中大部分标签都是不可以编辑的，但是添加了&lt;code&gt;contenteditable&lt;/code&gt;属性之后，标签会变成可编辑状态。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;contenteditable&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过通过这个属性把标签变为可编辑状态后只有&lt;code&gt;input&lt;/code&gt;事件，没有&lt;code&gt;change&lt;/code&gt;事件。也不能像表单一样通过&lt;code&gt;maxlength&lt;/code&gt;控制最大长度。我也忘记我在什么情况下用到过了，后面想起来再补吧。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;12.calc&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;这是一个&lt;code&gt;css&lt;/code&gt;属性，我一般称之为&lt;code&gt;css&lt;/code&gt;表达式。可以计算&lt;code&gt;css&lt;/code&gt;的值。最有趣的是他可以计算不同单位的差值。很好用的一个功能，缺点是不容易阅读。接盘侠没办法一眼看出&lt;code&gt;20px&lt;/code&gt;是啥。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;div&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;calc&lt;/span&gt;(&lt;span&gt;25%&lt;/span&gt; - &lt;span&gt;20px&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;13.Date对象&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;获取当前时间毫秒值&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 方式一&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Date&lt;/span&gt;.now(); &lt;span&gt;// 1606381881650&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 方式二&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;() - &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 1606381881650&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 方式三&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().getTime() &lt;span&gt;// 1606381881650&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建&lt;code&gt;Date&lt;/code&gt;对象的兼容性问题。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// window和安卓支持，ios和mac不支持&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(&lt;span&gt;&#x27;2020-11-26&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;// window和安卓支持，ios和mac支持&lt;/span&gt;&lt;br/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(&lt;span&gt;&#x27;2020/11/26&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;14.Proxy和Object.defineProperty区别&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;的意思是代理，我一般叫他拦截器，可以拦截对象上的一个操作。用法如下，通过&lt;code&gt;new&lt;/code&gt;的方式创建对象，第一个参数是被拦截的对象，第二个参数是对象操作的描述。实例化后返回一个新的对象，当我们对这个新的对象进行操作时就会调用我们描述中对应的方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(target, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, property) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, property) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    deleteProperty(target, property) {&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;区别于&lt;code&gt;Object.definedProperty&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Object.defineProperty&lt;/code&gt;只能监听到属性的读写，而&lt;code&gt;Proxy&lt;/code&gt;除读写外还可以监听属性的删除，方法的调用等。&lt;/p&gt;&lt;p&gt;通常情况下我们想要监视数组的变化，基本要依靠重写数组方法的方式实现，这也是&lt;code&gt;Vue&lt;/code&gt;的实现方式，而&lt;code&gt;Proxy&lt;/code&gt;可以直接监视数组的变化。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; list = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; listproxy = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(list, {&lt;br/&gt;    &lt;span&gt;set&lt;/span&gt;(target, property, value) {&lt;br/&gt;        target[property] = value;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 标识设置成功&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;list.push(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;是以非入侵的方式监管了对象的读写，而&lt;code&gt;defineProperty&lt;/code&gt;需要按特定的方式定义对象的属性。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;15.Reflect&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;他是&lt;code&gt;ES2015&lt;/code&gt;新增的对象，纯静态对象也就是不能被实例画，只能通过静态方法的方式调用，和&lt;code&gt;Math&lt;/code&gt;对象类似，只能类似&lt;code&gt;Math.random()&lt;/code&gt;的方式调用。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;内部封装了一系列对对象的底层操作，一共&lt;code&gt;14&lt;/code&gt;个，其中&lt;code&gt;1&lt;/code&gt;个被废弃，还剩下&lt;code&gt;13&lt;/code&gt;个。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;的静态方法和&lt;code&gt;Proxy&lt;/code&gt;描述中的方法完全一致。也就是说&lt;code&gt;Reflect&lt;/code&gt;成员方法就是&lt;code&gt;Proxy&lt;/code&gt;处理对象的默认实现。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Proxy&lt;/code&gt;对象默认的方法就是调用了&lt;code&gt;Reflect&lt;/code&gt;内部的处理逻辑，也就是如果我们调用&lt;code&gt;get&lt;/code&gt;方法，那么在内部，&lt;code&gt;Reflect&lt;/code&gt;就是将&lt;code&gt;get&lt;/code&gt;原封不动的交给了&lt;code&gt;Reflect&lt;/code&gt;，如下。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; proxy = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt;(obj, {&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt;(target, property) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Reflect&lt;/span&gt;.get(target, property);&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Reflect&lt;/code&gt;和&lt;code&gt;Proxy&lt;/code&gt;没有绝对的关系，我们一般将他们两个放在一起讲是为了方便对二者的理解。&lt;/p&gt;&lt;p&gt;那为什么会有&lt;code&gt;Reflect&lt;/code&gt;对象呢，其实他最大的用处就是提供了一套统一操作&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;判断对象是否存在某一个属性，可以使用&lt;code&gt;in&lt;/code&gt;操作符，但是不够优雅，还可以使用&lt;code&gt;Reflect.has(obj, name)&lt;/code&gt;; 删除一个属性可以使用&lt;code&gt;delete&lt;/code&gt;，也可以使用&lt;code&gt;Reflect.deleteProperty(obj, name)&lt;/code&gt;; 获取所有属性名可以使用&lt;code&gt;Object.keys&lt;/code&gt;, 也可以使用&lt;code&gt;Reflect.ownKeys(obj)&lt;/code&gt;; 我们更推荐使用&lt;code&gt;Reflect&lt;/code&gt;的&lt;code&gt;API&lt;/code&gt;来操作对象，因为他才是未来。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;16.解析get参数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;通过&lt;code&gt;replace&lt;/code&gt;方法获取&lt;code&gt;url&lt;/code&gt;中的参数键值对，可以快速解析&lt;code&gt;get&lt;/code&gt;参数。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; q = {};&lt;br/&gt;location.search.replace(&lt;span&gt;/([^?&amp;amp;=]+)=([^&amp;amp;]+)/g&lt;/span&gt;,(_,k,v)=&amp;gt;q[k]=v);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(q); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;17.解析连接url&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;可以通过创建&lt;code&gt;a&lt;/code&gt;标签，给&lt;code&gt;a&lt;/code&gt;标签赋值&lt;code&gt;href&lt;/code&gt;属性的方式，获取&lt;code&gt;到协议&lt;/code&gt;，&lt;code&gt;pathname&lt;/code&gt;，&lt;code&gt;origin&lt;/code&gt;等&lt;code&gt;location&lt;/code&gt;对象上的属性。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 创建a标签&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; aEle = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 给a标签赋值href路径&lt;/span&gt;&lt;br/&gt;aEle.href = &lt;span&gt;&#x27;/test.html&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 访问aEle中的属性&lt;/span&gt;&lt;br/&gt;aEle.protocol; &lt;span&gt;// 获取协议&lt;/span&gt;&lt;br/&gt;aEle.pathname; &lt;span&gt;// 获取path&lt;/span&gt;&lt;br/&gt;aEle.origin;&lt;br/&gt;aEle.host;&lt;br/&gt;aEle.search;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;18.localStorage&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;localStorage&lt;/code&gt;是&lt;code&gt;H5&lt;/code&gt;提供的永久存储空间，一般最大可存储&lt;code&gt;5M&lt;/code&gt;数据，并且支持跨域隔离，他的出现极大提高了前端开发的可能性。&lt;code&gt;localStorage&lt;/code&gt;的使用很多人都知道&lt;code&gt;setItem&lt;/code&gt;，&lt;code&gt;getItem&lt;/code&gt;,&lt;code&gt;removeItem&lt;/code&gt;, 但他也可以直接以成员的方式操作。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 存储&lt;/span&gt;&lt;br/&gt;localStorage.name = &lt;span&gt;&#x27;yd&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 获取&lt;/span&gt;&lt;br/&gt;localStorage.name; &lt;span&gt;// yd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 删除&lt;/span&gt;&lt;br/&gt;&lt;span&gt;delete&lt;/span&gt; localStorage.name;&lt;br/&gt;&lt;span&gt;// 清除全部&lt;/span&gt;&lt;br/&gt;localStorage.clear();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 遍历&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; localStorage.length; i++) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; key = localStorage.key(i); &lt;span&gt;// 获取本地存储的Key&lt;/span&gt;&lt;br/&gt;    localStorage[key]; &lt;span&gt;// 获取本地存储的value&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;localStorage&lt;/code&gt;满了的情况下仍继续存储并不会覆盖其他的值，而是直接报错(&lt;code&gt;QuotaExceededError&lt;/code&gt;)，并且当前存储的值也会被清空。浏览器支持每个域名下存储&lt;code&gt;5M&lt;/code&gt;数据。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;19.sessionStorage&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;sessionStorage&lt;/code&gt;和&lt;code&gt;localStorage&lt;/code&gt;的区别是，存在当前会话，很多人理解的是浏览器关闭，这是不对的，假设你在&lt;code&gt;A&lt;/code&gt;页面存储了&lt;code&gt;sessionStorage&lt;/code&gt;，新开选项卡将&lt;code&gt;A&lt;/code&gt;页面的链接粘贴进去打开页面，&lt;code&gt;sessionStorage&lt;/code&gt;也是不存在的。&lt;/p&gt;&lt;p&gt;所以&lt;code&gt;sessionStorage&lt;/code&gt;存在的条件是页面间的跳转，&lt;code&gt;A&lt;/code&gt;页面存储了&lt;code&gt;sessionStorage&lt;/code&gt;，他要通过&lt;code&gt;超链接&lt;/code&gt;或者&lt;code&gt;location.href&lt;/code&gt;或者&lt;code&gt;window.open&lt;/code&gt;来打开另一个同域页面才能访问&lt;code&gt;sessionStorage&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这一点在混合开发嵌套&lt;code&gt;H5&lt;/code&gt;的开发模式中尤为重要，如果以新开&lt;code&gt;webview&lt;/code&gt;的方式打开页面，很可能&lt;code&gt;sessionStorage&lt;/code&gt;就没有了。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;20.会话cookie&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;cookie&lt;/code&gt;在设置的时候如果不设置过期时间，就表示是个会话&lt;code&gt;cookie&lt;/code&gt;，以前我以为关闭浏览器会话&lt;code&gt;cookie&lt;/code&gt;就消失了，然而...喜提&lt;code&gt;bug&lt;/code&gt;一个。&lt;/p&gt;&lt;p&gt;在多数情况下&lt;code&gt;windows&lt;/code&gt;系统或者安卓系统确实是这样的。但是在&lt;code&gt;macOS&lt;/code&gt;系统或者&lt;code&gt;ios&lt;/code&gt;系统中，关闭浏览器并不会清除掉会话&lt;code&gt;cookie&lt;/code&gt;，结束浏览器进程才行。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;21.标签模板字符串&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;模板字符串支持在前面添加一个函数，第一个参数是一个有固定内容组成的数组，后面参数依次为传入的变量，函数返回值为模板字符串真正展示的值。不过这个功能个人感觉没啥用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; tag = &lt;span&gt;(&lt;span&gt;params, ...args&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; params[&lt;span&gt;0&lt;/span&gt;] + args[&lt;span&gt;0&lt;/span&gt;]; &lt;span&gt;// 返回值为模板字符串的真实值。&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; str = tag&lt;span&gt;`hello &lt;span&gt;${&lt;span&gt;&#x27;world&#x27;&lt;/span&gt;}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;22.字符串常用的几个方法&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;1. includes();&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;字符串中是否包含某个字符串，这个不说了，其实就是&lt;code&gt;indexOf&lt;/code&gt;的替代方案，用起来更优雅，&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2. startsWith();&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;字符串是否为某个字符串开始，我一般用它判断&lt;code&gt;url&lt;/code&gt;是否有&lt;code&gt;http&lt;/code&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3. endsWith();&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;字符串是否为某个字符串结尾。判断后缀名的时候尤其有效。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4. repeat(number);&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;得到一个重复&lt;code&gt;number&lt;/code&gt;次的字符串。额...我也不知道什么时候有用，一般我用它造测试数据。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;5. &#x27;abc&#x27;.padEnd(5, &#x27;1&#x27;); // abc11;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;用给定的字符串在尾部拼接到指定长度，第一个参数为长度，第二个参数为用于拼接的值。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;6. &#x27;abc&#x27;.padStart(5, &#x27;1&#x27;); // 11abc;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;用给定的字符串在首部拼接到指定长度第一个参数为长度，第二个参数为用于拼接的值。首部补0？&lt;/p&gt;&lt;h2&gt;&lt;span&gt;23.数组快速去重&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;应该很多人都知道这个，数组转换成&lt;code&gt;Set&lt;/code&gt;, 再转换为数组，不过这种去重方式只能去除基本数据类型组成的数组。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;(arr);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr3 = [...arr2];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;24.Object.keys, values, entries&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;一般我们常用&lt;code&gt;Object.keys&lt;/code&gt;，返回一个对象的键组成的数组，其实还有&lt;code&gt;Object.values&lt;/code&gt;，返回对象值组成的数组，&lt;code&gt;Object.entries&lt;/code&gt;将对象转成数组，每个元素是键值对组成的数组，可以使用此功能快速将对象转为&lt;code&gt;Map&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;yd&#x27;&lt;/span&gt;, &lt;span&gt;age&lt;/span&gt;: &lt;span&gt;18&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.keys(obj); &lt;span&gt;// [&#x27;name&#x27;, &#x27;age&#x27;];&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.values(obj); &lt;span&gt;// [&#x27;yd&#x27;, 18];&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; l = &lt;span&gt;Object&lt;/span&gt;.entries(obj); &lt;span&gt;// [[&#x27;name&#x27;, &#x27;yd&#x27;], [&#x27;age&#x27;: 18]];&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; m = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Map&lt;/span&gt;(l);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;25.Object.getOwnPropertyDescriptors&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;获取对象的描述信息&lt;/p&gt;&lt;p&gt;&lt;code&gt;Object.assign&lt;/code&gt;复制时，将对象的属性和方法当做普通属性来复制，并不会复制完整的描述信息，比如&lt;code&gt;this&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; p1 = {&lt;br/&gt;    &lt;span&gt;a&lt;/span&gt;: &lt;span&gt;&#x27;y&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;b&lt;/span&gt;: &lt;span&gt;&#x27;d&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;get&lt;/span&gt; name() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.a}&lt;/span&gt; &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.b}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = &lt;span&gt;Object&lt;/span&gt;.assign({}, p1);&lt;br/&gt;&lt;br/&gt;p2.a = &lt;span&gt;&#x27;z&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;p2.name; &lt;span&gt;// y d; 发现并没有修改p2.a的值，是因为this仍旧指向p1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;Object.getOwnPropertyDescriptors&lt;/code&gt;获取完整描述信息&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; description = &lt;span&gt;Object&lt;/span&gt;.getOwnPropertyDescriptors(p1);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = &lt;span&gt;Object&lt;/span&gt;.defineProperty({}, description);&lt;br/&gt;&lt;br/&gt;p2.a = &lt;span&gt;&#x27;z&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;p2.name; &lt;span&gt;// z d&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;26.BigInt&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt;可以处理的最大数字是&lt;code&gt;2&lt;/code&gt;的&lt;code&gt;53&lt;/code&gt;次方 &lt;code&gt;- 1&lt;/code&gt;，这一点我们可以在&lt;code&gt;Number.MAX_SAFE_INTEGER&lt;/code&gt;中看到。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;consoel.log(&lt;span&gt;Number&lt;/span&gt;.MAX_SAFE_INTEGER); &lt;span&gt;//9007199254740991&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更大的数字则无法处理，&lt;code&gt;ECMAScript2020&lt;/code&gt;引入&lt;code&gt;BigInt&lt;/code&gt;数据类型来解决这个问题。通过把字母&lt;code&gt;n&lt;/code&gt;放在末尾, 可以运算大数据。&lt;/p&gt;&lt;p&gt;&lt;code&gt;BigInt&lt;/code&gt;可以使用算数运算符进行加、减、乘、除、余数及幂等运算。它可以由数字和十六进制或二进制字符串构造。此外它还支持&lt;code&gt;AND&lt;/code&gt;、&lt;code&gt;OR&lt;/code&gt;、&lt;code&gt;NOT&lt;/code&gt;和&lt;code&gt;XOR&lt;/code&gt;之类的按位运算。唯一无效的位运算是零填充右移运算符。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; bigNum = &lt;span&gt;100000000000000000000000000000n&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(bigNum * &lt;span&gt;2n&lt;/span&gt;); &lt;span&gt;// 200000000000000000000000000000n&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bigInt = BigInt(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(bigInt); &lt;span&gt;// 1n;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; bigInt2 = BigInt(&lt;span&gt;&#x27;2222222222222222222&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(bigInt2); &lt;span&gt;// 2222222222222222222n;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BigInt是一个大整数，所以他不能用来存储小数。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;27.??合并空运算符&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;假设变量&lt;code&gt;a&lt;/code&gt;不存在，我们希望给系统一个默认值，一般我们会使用&lt;code&gt;||&lt;/code&gt;运算符。但是在&lt;code&gt;javascript&lt;/code&gt;中空字符串，&lt;code&gt;0&lt;/code&gt;，&lt;code&gt;false&lt;/code&gt;都会执行&lt;code&gt;||&lt;/code&gt;运算符，所以&lt;code&gt;ECMAScript2020&lt;/code&gt;引入合并空运算符解决该问题，只允许在值为&lt;code&gt;null&lt;/code&gt;或未定义时使用默认值。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; name = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(name || &lt;span&gt;&#x27;yd&#x27;&lt;/span&gt;); &lt;span&gt;// yd;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(name ?? &lt;span&gt;&#x27;yd&#x27;&lt;/span&gt;); &lt;span&gt;// &#x27;&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;28.?可选链运算符&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;业务代码中经常会遇到这样的情况，&lt;code&gt;a&lt;/code&gt;对象有个属性&lt;code&gt;b&lt;/code&gt;,&lt;code&gt;b&lt;/code&gt;也是一个对象有个属性&lt;code&gt;c&lt;/code&gt;,&lt;/p&gt;&lt;p&gt;我们需要访问&lt;code&gt;c&lt;/code&gt;，经常会写成&lt;code&gt;a.b.c&lt;/code&gt;，但是如果&lt;code&gt;f&lt;/code&gt;不存在时，就会出错。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a = {&lt;br/&gt;    &lt;span&gt;b&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;: &lt;span&gt;123&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.b.c); &lt;span&gt;// 123;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.f.c); &lt;span&gt;// f不存在所以会报错&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;ECMAScript2020&lt;/code&gt;定义可选链运算符解决该问题，通过在&lt;code&gt;.&lt;/code&gt;之前添加一个&lt;code&gt;?&lt;/code&gt;将键名变成可选&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; person = {};&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(person?.profile?.age ?? &lt;span&gt;18&lt;/span&gt;); &lt;span&gt;// 18&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;29.import&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;code&gt;import&lt;/code&gt;是&lt;code&gt;ECMAScript2015&lt;/code&gt;当中定义的一套&lt;code&gt;ES Module&lt;/code&gt;模块系统，语法特性绝大多数浏览器已经支持了，通过给&lt;code&gt;script&lt;/code&gt;标签添加&lt;code&gt;type=module&lt;/code&gt;的属性就可以使用&lt;code&gt;ES Module&lt;/code&gt;的标准去执行&lt;code&gt;javascript&lt;/code&gt;代码了。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;module&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;this is es module&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;ES Module&lt;/code&gt;规范下，会采用严格模式(&lt;code&gt;use strict&lt;/code&gt;)运行&lt;code&gt;javascript&lt;/code&gt;代码。每个&lt;code&gt;ES Module&lt;/code&gt;都运行在单独的作用域中，也就意味着变量间不会互相干扰。外部&lt;code&gt;js&lt;/code&gt;文件是通过&lt;code&gt;CORS&lt;/code&gt;的方式请求的，所以要求我们外部的&lt;code&gt;js&lt;/code&gt;文件地址要支持跨域请求，也就是文件服务器要支持&lt;code&gt;CORS&lt;/code&gt;。我们可以在任意网站控制台输入下面代码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;script&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;script.type = &lt;span&gt;&#x27;module&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;script.innerHTML = &lt;span&gt;`import React from &#x27;https://cdn.bootcdn.net/ajax/libs/react/17.0.1/cjs/react-jsx-dev-runtime.development.js&#x27;;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;document&lt;/span&gt;.body.append(script);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现在&lt;code&gt;network&lt;/code&gt;中请求了&lt;code&gt;https://cdn.bootcdn.net/ajax/libs/react/17.0.1/cjs/react-jsx-dev-runtime.development.js&lt;/code&gt;资源。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ES Module&lt;/code&gt;的&lt;code&gt;script&lt;/code&gt;标签会延迟脚本加载，等待网页请求完资源之后才执行，和使用&lt;code&gt;deffer&lt;/code&gt;的方式加载资源相同。&lt;/p&gt;&lt;p&gt;需要注意的是，&lt;code&gt;import {} from &#x27;xx&#x27;&lt;/code&gt;导入模块的时候，并不是对象的解构，而是&lt;code&gt;import&lt;/code&gt;的固定语法，这一点很多人容易弄错。&lt;/p&gt;&lt;p&gt;并且&lt;code&gt;ECMAScript2020&lt;/code&gt;中&lt;code&gt;import&lt;/code&gt;开始支持动态导入功能，在此之前&lt;code&gt;import&lt;/code&gt;只能写在模块代码的顶部，一开始就要声明模块依赖的其它模块。支持动态引入后就可以按需引入对应的模块，这个功能我们早在&lt;code&gt;SPA&lt;/code&gt;中就已经用到了。动态导入返回的是一个&lt;code&gt;Promise&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;a.js&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; { a };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;b.js&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt;(&lt;span&gt;&#x27;./a.js&#x27;&lt;/span&gt;).then(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(data.a); &lt;span&gt;// 123;&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;30. 0.1 + 0.2 === 0.3 // false&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;0.1&lt;/span&gt;+&lt;span&gt;0.2&lt;/span&gt;); &lt;span&gt;// 0.30000000000000004&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;JS&lt;/code&gt;当中，&lt;code&gt;Number&lt;/code&gt;类型实际上是&lt;code&gt;double&lt;/code&gt;类型，运算小数时存在精度问题。因为计算机只认识二进制，在进行运算时，需要将其他进制的数值转换成二进制，然后再进行计算&lt;/p&gt;&lt;p&gt;小数用二进制表达时是无穷的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 将0.1转换成二进制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;0.1&lt;/span&gt;.toString(&lt;span&gt;2&lt;/span&gt;)); &lt;span&gt;// 0.0001100110011001100110011001100110011001100110011001101&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 将0.2转换成二进制&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;0.2&lt;/span&gt;.toString(&lt;span&gt;2&lt;/span&gt;));  &lt;span&gt;// 0.001100110011001100110011001100110011001100110011001101&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;双精度浮点数的小数部分最多支持&lt;code&gt;53&lt;/code&gt;位二进制位，所以两者相加后，因浮点数小数位的限制而截断的二进制数字，再转换为十进制，就成了&lt;code&gt;0.30000000000000004&lt;/code&gt;，这样在进行算术计算时会产生误差。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ES6 在Number&lt;/code&gt;对象上面，新增一个极小的常量&lt;code&gt;Number.EPSILON&lt;/code&gt;。根据规格，它表示&lt;code&gt;1&lt;/code&gt;与大于&lt;code&gt;1&lt;/code&gt;的最小浮点数之间的差。对于&lt;code&gt;64&lt;/code&gt;位浮点数来说，大于&lt;code&gt;1&lt;/code&gt;的最小浮点数相当于二进制的&lt;code&gt;1.00..001&lt;/code&gt;，小数点后面有连续&lt;code&gt;51&lt;/code&gt;个零。这个值减去&lt;code&gt;1&lt;/code&gt;之后，就等于&lt;code&gt;2的-52次方&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Number&lt;/span&gt;.EPSILON === &lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;-52&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Number&lt;/span&gt;.EPSILON&lt;br/&gt;&lt;span&gt;// 2.220446049250313e-16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Number&lt;/span&gt;.EPSILON.toFixed(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// &quot;0.00000000000000022204&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;实际上是&lt;code&gt;JavaScript&lt;/code&gt;能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。&lt;/p&gt;&lt;p&gt;引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;可以用来设置&lt;code&gt;能够接受的误差范围&lt;/code&gt;。比如，误差范围设为&lt;code&gt;2&lt;/code&gt;的&lt;code&gt;-50&lt;/code&gt;次方（即&lt;code&gt;Number.EPSILON * Math.pow(2, 2)&lt;/code&gt;），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(&lt;span&gt;0.1&lt;/span&gt; + &lt;span&gt;0.2&lt;/span&gt; - &lt;span&gt;0.3&lt;/span&gt;) &amp;lt; &lt;span&gt;Number&lt;/span&gt;.EPSILON &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;48&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：&lt;span&gt;https://juejin.cn/post/6908698827033837575&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &#x27;PingFang SC&#x27;, Cambria, Cochin, Georgia, Times, &#x27;Times New Roman&#x27;, serif; letter-spacing: 0px; text-align: left; white-space: normal; font-size: 16px; line-height: 1.6; word-break: break-word;&quot; data-darkmode-color-16072568501583=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;前端 社群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下方加 Nealyang 好友回复「 加群」即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;16&quot; data-cropselx2=&quot;163&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;178&quot; data-fileid=&quot;100016913&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/udZl15qqib0N4k0zoSSTiaUeicvTRStJYYmGWa6YpNqicxibYmM4oSD8oWs9X8b9DfK3CpUmGMWzIriaiaOf1L59t9nGA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; color: rgb(89, 89, 89); line-height: 26px;&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你有帮助，我想请你帮我2个小忙：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;1. 点个&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;，让更多人也能看到这篇文章&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b64d7517c9a24e6f8d1714e5bdc492d6</guid>
<title>vivo 互联网机器学习平台的建设与实践</title>
<link>https://toutiao.io/k/ewji5x7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo 互联网产品团队 - Wang xiao&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;随着广告和内容等推荐场景的扩展，算法模型也在不断演进迭代中。业务的不断增长，模型的训练、产出迫切需要进行平台化管理。vivo互联网机器学习平台主要业务场景包括游戏分发、商店、商城、内容分发等。本文将从业务场景、平台功能实现两个方面介绍vivo内部的机器学习平台在建设与实践中的思考和优化思路。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、写在前面&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;随着互联网领域的快速发展，数据体量的成倍增长以及算力的持续提升，行业内都在大力研发AI技术，实现业务赋能。算法业务往往专注于模型和调参，而工程领域是相对薄弱的一个环节。建设一个强大的分布式平台，整合各个资源池，提供统一的机器学习框架，将能大大加快训练速度，提升效率，带来更多的可能性，此外还有助于提升资源利用率。希望通过此文章，初学者能对机器学习平台，以及生产环境的复杂性有一定的认识。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、业务背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;截止2022年8月份，vivo在网用户2.8亿，应用商店日活跃用户数7000万+。AI应用场景丰富，从语音识别、图像算法优化、以及互联网常见场景，围绕着应用商店、浏览器、游戏中心等业务场景的广告和推荐诉求持续上升。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如何让推荐系统的模型迭代更高效，用户体验更好，让业务场景的效果更佳，是机器学习平台的一大挑战，如何在成本、效率和体验上达到平衡。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从下图可以了解到，整个模型加工运用的场景是串行可闭环的，对于用户的反馈需要及时进行特征更新，不断提升模型的效果，基于这个链路关系的基础去做效率的优化，建设一个通用高效的平台是关键。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34024179620034545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5l53Dxc3JTwan1wicia8XpNIdDJbyibqHhYK5DXkvXnpQ4GPlF97OJRw7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、vivo机器学习平台的设计思路&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 功能模块&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于上图业务场景的链路关系，我们可以对业务场景进行归类，根据功能不同，通用的算法平台可划分为三步骤：数据处理「对应通用的特征平台，提供特征和样本的数据支撑」、模型训练「对应通用的机器学习平台，用于提供模型的训练产出」、模型服务「对应通用的模型服务部署，用于提供在线模型预估」，三个步骤都可自成体系，成为一个独立的平台。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文将&lt;strong&gt;重点阐述模型训练部分&lt;/strong&gt;，在建设vivo机器学习平台过程中遇到的挑战以及优化思路。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5904995904995906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5lQpwlH5oN1blZy1FmAYiaFutcvQZErMYrzvFo8UocOGjMrpfM8icaHbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1221&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.数据处理，围绕数据相关的工作，包括采集、加工、标记和存储。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;其中，采集、加工、存储与大数据平台的场景相吻合，标记场景是算法平台所独有的。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据采集，&lt;/strong&gt;即从外部系统获得数据，使用Bees{vivo数据采集平台}来采集数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据加工，&lt;/strong&gt;即将数据在不同的数据源间导入导出，并对数据进行聚合、清洗等操作。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据标记，&lt;/strong&gt;是将人类的知识附加到数据上，产生样本数据，以便训练出模型能对新数据推理预测。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据存储，&lt;/strong&gt;根据存取的特点找到合适的存储方式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 模型训练，即创建模型的过程，包括特征工程、试验、训练及评估模型。&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;特征工程，&lt;/strong&gt;即通过算法工程师的知识来挖掘出数据更多的特征，将数据进行相应的转换后，作为模型的输入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;试验，&lt;/strong&gt;即尝试各种算法、网络结构及超参，来找到能够解决当前问题的最好的模型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;模型训练，&lt;/strong&gt;主要是平台的计算过程，平台能够有效利用计算资源，提高生产力并节省成本。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.模型部署，是将模型部署到生产环境中进行推理应用，真正发挥模型的价值。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过不断迭代演进，解决遇到的各种新问题，从而保持在较高的服务水平。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4. 对平台的通用要求，如扩展能力，运维支持，易用性，安全性等方面&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;由于机器学习从研究到生产应用处于快速发展变化的阶段，所以框架、硬件、业务上灵活的扩展能力显得非常重要。任何团队都需要或多或少的运维工作，出色的运维能力能帮助团队有效的管理服务质量，提升生产效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;易用性&lt;/strong&gt;对于小团队上手、大团队中新人学习都非常有价值，良好的用户界面也有利于深入理解数据的意义。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;安全性&lt;/strong&gt;则是任何软件产品的重中之重，需要在开发过程中尽可能规避。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 模型训练相关&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;模型训练包括了两个主要部分，一是算法工程师进行试验，找到对应场景的最佳模型及参数，称之为“&lt;strong&gt;模型试验&lt;/strong&gt;”，二是计算机训练模型的过程，主要侧重平台支持的能力，称之为“&lt;strong&gt;训练模型&lt;/strong&gt;”。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;建模是算法工程师的核心工作之一。建模过程涉及到很多数据工作，称为特征工程，主要是调整、转换数据。主要任务是要让数据发挥出最大的价值，满足业务诉求。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.2.1 模型试验&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;特征工作和超参调整是建模过程中的核心工作。特征工作主要对数据进行预处理，便于这部分输入模型的数据更好的表达信息，从而提升模型输出结果的质量。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;数据和特征工程决定模型质量的上限，而算法和超参是无限逼近这个上限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;超参调整包括选择算法、确认网络结构、初始参数，这些依赖于算法工程师丰富的经验，同时需要平台支持试验来测试效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;特征工程和超参调整是相辅相成的过程。加工完特征后，需要通过超参的组合来验证效果。效果不理想时，需要从特征工程、超参两个方面进行思索、改进，反复迭代后，才能达到理想的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5809199318568995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib542Ix52BrrC6tSEicRL7YsEeYlaBY9HbcpPXF5yuibZnw7ImOGsSlC0AA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1174&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3.2.2 训练模型&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;可通过标准化数据接口来提高快速试验的速度，也能进行试验效果的比较。底层支持docker操作系统级的虚拟化方案，部署速度快，同时能将模型直接部署上线。用户无需对训练模型进行更多定制化的操作，批量提交任务能节约使用者的时间，平台可以将一组参数组合的试验进行比较，提供更友好的使用界面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，由于训练的方向较多，需要算力管理自动规划任务和节点的分配，甚至可以根据负载情况，合理利用空闲资源。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、vivo机器学习平台实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;前面我们介绍了机器学习平台的背景和发展方向，现在我们来介绍下，平台在解决用户问题部分的困扰和解决思路。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.1 平台能力矩阵&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;机器学习平台主要目标是围绕模型训练进行深耕，并辅助用户进行模型决策，更快的进行模型部署。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以此为目标分为两个方向，训练框架的优化能够支撑大规模模型的分布式计算，调度能力优化能够支持批次模型的执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在调度能力上，&lt;/strong&gt;平台由原生k8s调度，单个训练调度的效率较低，升级为kube-batch批量调度，到以混合云精细化编排为目标，当前主要处于灵活性调度策略的形式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在训练框架上，&lt;/strong&gt;从原生Tensorflow模型，随着特征和样本规模的扩大，自研了超大规模的训练框架vlps，当前处于TensorFlow+vlps结合的新框架状态。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5Lx2dX8kM74iakkT2XsswTibxU8D9Nf1pIhpSMn6J0HDLyV562pQVGYSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 平台能力介绍&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;平台能力建设主要围绕模型试验和训练模型的运用，运用过程中遇到的痛点和难点如何解决，是我们在实践中的关键。同时，训练框架也是平台关键能力的体验，基于业务的复杂度，持续对框架进行优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;已覆盖公司内部算法工程师模型调试的工作，已达到亿级样本，百亿特征的规模。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;4.2.1 资源管理&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;痛点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;机器学习平台属于计算密集型的平台。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;业务场景不同，是否完全按照业务分组进行资源划分；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;资源池划分过小，会导致资源利用率低且没办法满足业务激增的资源诉求；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;资源不足以满足业务诉求时，会存在排队情况导致模型更新不及时；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何管理好算力，提效与降本的平衡，是平台资源管理的一个核心问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;资源管理的基本思路是将所有计算资源集中起来，按需分配，让资源使用率尽量接近100%。任何规模的资源都是有价值的。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;比如，一个用户，只有一个计算节点，有多条计算任务时，资源管理通过队列可减少任务轮换间的空闲时间，比手工启动每条计算任务要高效很多。多计算节点的情况，资源管理能自动规划任务和节点的分配，让计算节点尽量都在使用中，而不需要人为规划资源，并启动任务。多用户的情况下，资源管理可以根据负载情况，合理利用其它用户或组的空闲资源。随着节点数量的增加，基于有限算力提供更多业务支持是必经之路。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1.以配额限资源滥用：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;新增配额组和个人配额，减少业务之间的相互干扰，尽可能满足各组的资源需要，并且配额组支持临时扩容和共享，解决偶发性激增的资源诉求；限额后用户仅支持在有限资源下使用，让用户自我调节高优先级训练。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6460093896713615&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5NKTALSQ8cULDichzctzuA44tLmiaFEo1EfoRXibT0ulQdKRen6iaLaHYkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1065&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.以调度促资源优化：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;新增生产环境，确认模型已经正常迭代，在合理利用率的情况下切换至高优环境，提供更高性能的资源池；同时提供调度打分机制，围绕资源颗粒度、配置合理性等维度，让合理的训练资源更快的拉起，减少调度卡住情况；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上线多维度调度打分机制后，平台不合理训练任务有大幅度下降，资源效率提升。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;围绕并不限于以下维度：最大运行时长、排队时长、cpu&amp;amp;内存&amp;amp;gpu颗粒度和总需求量等。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5dNxDyjmQFgb7icG3E0TDWn37zXFzicibib9ic8zDTSsG71ibe7OQUMZuvERQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;4.2.2 框架自研&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;痛点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;随着样本和特征规模增加后，框架的性能瓶颈凸显，需要提升推理计算的效率。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;发展路径：&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;每一次的发展路径主要基于业务量的发展，寻求最佳的训练框架，框架的每一次版本升级都打包为镜像，支持更多模型训练。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35804195804195804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5tgABcMXD6OVicywy0BQGXylHP86D5ibMzrHnFL7NicibSzgJDU8aof3SuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;当前效果：&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32127659574468087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5YpCJ3gk1eib8ZsTWpC2VwHlJgaOzib6sxQNia3sNcn8wAHZB3VJDx9V3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;4.2.3 训练管理&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;痛点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如何支持多种分布式训练框架，满足算法工程师的业务诉求，让用户无需关心底层机器调度和运维；如何让算法工程师快速新建训练，执行训练，可查看训练状态，是训练管理的关键。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上传代码至平台的文件服务器和git都可以进行读取，同时在平台填写适量的参数即可快速发起分布式训练任务。同时还支持通过OpenAPI，便于开发者在脱离控制台的情况下也能完成机器学习业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;围绕训练模型相关的配置信息，分为基础信息设置、资源信息设置、调度依赖设置、告警信息设置和高级设置。在试验超参的过程中，经常需要对一组参数组合进行试验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;批量提交任务能节约使用者时间。平台也可以将这组结果直接进行比较，提供更友好的界面。训练读取文件服务器或git的脚本，即可快速执行训练。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;1.可视化高效创建训练&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5P8fD4zk8QyAFgyPjZozFtiazEnUSfibnfd3mvpiaJrI9zRpcJsTRicVN0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2. 准确化快速修改脚本&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.525&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5UyQF8h4s9XG7MwqTwtYjCBdhOEIKeX1JJrw7rMNDxTeliaZcCZIvTGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;3. 实时化监控训练变动&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5dZibg5COaM0A6xNO8icAwp0clczeoDiaA5ll32buant7EmH7laV7mw55g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;4.2.4 交互式开发&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;痛点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;算法工程师调试脚本成本较高，算法工程师和大数据工程师有在线调试脚本的诉求，可直接通过浏览器运行代码，同时在代码块下方展示运行结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;解决思路：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在交互式工具中进行试验、开发，如：jupyter notebook，提供所见即所得的交互式体验，对调试代码的过程非常方便。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在交互试验的场景下，需要独占计算资源。机器学习平台需要提供能为用户保留计算资源的功能。如果计算资源有限，可对每个用户申请的计算资源总量进行限制，并设定超时时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如，若一周内用户没有进行资源使用后， 就收回保留资源。在收回资源后，可继续保留用户的数据。重新申请资源后，能够还原上次的工作内容。在小团队中，虽然每人保留一台机器自己决定如何使用更方便，但是用机器学习平台来统一管理，资源的利用率可以更高。团队可以聚焦于解决业务问题，不必处理计算机的操作系统、硬件等出现的与业务无关的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5icb51ic1nkgguJ1OsvFe3ib5iaEb4GRqBvMfORLMeDM90c6PXhWHnQz9ez6dZrdGIRfcPlfD05cJw8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;目前vivo机器学习平台支撑了互联网领域的算法离线训练，使算法工程师更关注于模型策略的迭代优化，从而实现为业务赋能。未来我们会在以下方面继续探索：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;1.实现平台能力的贯通&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 加强框架层面的预研&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:113.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5ed3da1b2256073c32acfa7230894da</guid>
<title>观察和评价研发效能的趋势</title>
<link>https://toutiao.io/k/rtyytne</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;长久以来，如何有效&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MjY3OTgwMA==&amp;amp;mid=2652477217&amp;amp;idx=1&amp;amp;sn=063127414073aa8309c0c0e3a0a2e0c2&amp;amp;chksm=bd4fa5368a382c20c77d2ceec9c6b00536de144225c2bee388aad8e0fca647fb2f576881f090&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;衡量软件研发效能&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;衡量软件研发效能&lt;/a&gt;是所有研发管理者心心念念的事，但也一直是个未解的难题。从早期的人均代码行到人均功能点公式计算，再到基于故事点的迭代速率或人均吞吐量，业界一直在探索。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;有失偏颇的指标&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;9&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;人均代码行，若作为关键指标，与更优秀程序员应该用更优雅和少的代码这一逻辑相悖，且将软件编程这一脑力劳动等同于砌砖速度，显然是不合理的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;功能点计算，通过基于需求分析和设计后确定要修改的页面数、接口数等多种因素构成的复杂公式计算，看似客观，然而忽视了软件研发工作的多样性。渠道侧应用的界面更多，功能点数容易更大，但还有偏后端开发、基础平台开发、数据和报表开发、算法开发等多种类型的工作，前端开发也存在采用不同框架带来的差异性，不可能用几个公式客观衡量团队的产能；另外，越来越复杂的计算公式要依赖准确的设计，且很难让每个人都理解，需要人投入专门的时间来计算，这种没有价值创造的工作本来就是一种浪费。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;随着敏捷开发的发展，故事点作为一种基于团队集体评估复杂度的工具可用于衡量细粒度需求的大小。一些管理者于是考虑用人均故事点来衡量产能。然而故事点没有单位、不同团队故事点基准可以不同，以及评估的主观性特点，让人均故事点、迭代速率很难作为令人满意的效能衡量关键指标。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;关键的研发效能指标集&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;18&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;经过多年的探索总结，DevOps社区提出了衡量IT绩效的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MjY3OTgwMA==&amp;amp;mid=2652470540&amp;amp;idx=1&amp;amp;sn=24972614970cee8f6d79e539695893c0&amp;amp;chksm=bd4f4f1b8a38c60d96fa5bb5becd828fe7ecf1642629712c75c9aa8c738540fb061a09b67498&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;四个关键指标&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;四个关键指标&lt;/a&gt;，包括前置时间（或交付周期）、部署频率、部署失败率和线上失败恢复时长，简称“4 Key Metrics”。这是一个很好的方向。不过在实践中，我们发现实际要关心的关键指标其实不止这四个，例如生产缺陷率就是必不可少的关键结果，需求吞吐量也常常很受关注。下面是实践中常见的研发过程度量指标，其中部分是反映最终结果的关键效能指标。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5817805383022774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/aaVJqS7LaMLp78kxrajkVrjhDA3PNqsGkZsetbAuviapFQ4HM015ZHw5jicdYfofWSY8tM0mBia34vbjVaTsWficHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot; title=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;评价效能的关键原则&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;要观察和评价研发效能，就首先要定义什么是效能？简单一句话，&lt;strong&gt;效能就是团队能持续快速交付价值的能力&lt;/strong&gt;。目的是交付价值，其研发核心能力在于“响应力”与“稳健性”，同时，响应力这一概念又可以从“流动速率”和“资源速率”两个维度来观察。前者是指价值从明确到交付用户的周期时间，而后者是单位人力资源在单位时间里交付价值的数量，对创新与敏捷的要求使得前者的重要性更胜于后者。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;因此，要评价效能，这里就有几个关键原则：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何单一指标并不能合理地观察和评价一个团队的效能，否则会产生副作用。例如单一看吞吐量，会驱使团队一味拆需求，或牺牲质量；若单一看交付周期时间，可能驱使团队减少需求流入。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;评价效能尽可能看全局结果，而非阶段性表现，例如一次转测通过率这样的指标通常很重要，反映开发阶段内建质量的效果，然而用于评价效能不合适，它反映的不是团队整体表现。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;效能评价原始数据应该是来自工具的客观记录，不需要人工计算，不需要为评价浪费时间，且对所有团队是一视同仁的。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;考虑到软件研发工作种类的多样性和以脑力劳动为主的工作性质，研发效能的观察更多应关注团队的改进趋势，而非横向对比的绝对数值。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;那怎么才能更合理有效地达成观察和评价效能的目的呢？最直接的办法，也是最理想的，&lt;strong&gt;就是学会观察分析一组核心指标&lt;/strong&gt;，例如同时拿出4 Metrics的数据趋势，或者上面图中的关键效能指标数据趋势进行分析和观察。一些成熟的企业会将这些关键指标做成Dashboard（仪表盘），便于观察者一目了然分析全局状况。这就像做数字化运营的数据分析一样，只有通过一组数据的对比分析才能得到相对有效的洞察。强烈建议每一位效能管理者、过程改进者以驱动改进为目标，学会和习惯以这种方式来评价一个团队的效能情况。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;观察效能的综合评价指标&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;36&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;但这一理想方式对观察者要求较高，需要充分理解每一个指标的含义和内在逻辑，并且这样一组核心指标对于反映宏观的效能改进趋势还是不够直观，认知负载有点高。尤其对于一些管理层和外部人员，看不出整体效能到底是变好还是变差了。想要解决这个问题，我想到了一些类似的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;国家需要一些指标来持续观察一个经济体的整体经济状况，典型的像居民消费价格指数（CPI）、购买力平价指数（PPP），都是采用一篮子指标基于某种内在逻辑构成的复合指标。好处是：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;ol class=&quot;list-paddingleft-1&quot; start=&quot;1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;虽然不能说明问题根因在哪里，但能更直观反映全局表现&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其变化可综合多种因素的影响，可体现不同因素对整体评价的影响程度&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;降低了为使得单一指标好看而采取片面行为的可能性&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;于是，在实践案例中，我们设计了下面这样的概念公式，综合了六个要素来产生一个综合评价指数（研发效能CEI），可以以周或月进行统计：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;综合效能 = （交付吞吐量 &lt;em&gt;部署频率 &lt;/em&gt;发布成功率） / （需求交付周期 &lt;em&gt;线上稳定性 &lt;/em&gt;债务积压）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>