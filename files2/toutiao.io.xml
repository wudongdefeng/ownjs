<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>59716a025de684966faacc9d601de904</guid>
<title>35岁失业？我们如何拓宽财富渠道？</title>
<link>https://toutiao.io/k/jbfirzk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021年，随着各大互联网公司陆续裁员，“35岁危机”成了大家经常提起的话题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于互联网公司的加班强度确实非常大，人近中年，因各种家庭原因无法承受高强度加班的现象非常普遍，中年危机的问题在这个行业中更加突出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但其实各行业的中年从业者们，都背负着来自各方面的生活压力。金融圈的基金经理们由于不堪业绩下滑压力，崩溃自杀的案例时有发生。即使国企的从业者有时也面临着人员优化、竞争上岗的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那么作为一个普通人，面对行业变换的大潮，就真的只能随波逐流，毫无应对之法吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我的答案是否定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在人生的30岁至40岁，我们所有人都面临着一次职业生涯甚至是整个人生的转型，那就是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实现从“个人能力”到“个人财富”的转型。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;转型成功，我们会迈向人生新的高度；转型失败，就有可能一直从事低价值的重复性劳动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作为一名“理工男”，我们应该如何成功完成这次转型呢？在“人到中年”这个十字路口，怎样才能让自己的个人价值不降低，个人财富不缩水呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;希望本文能对你有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;实现从“能力”到“财富”的转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;坦率地讲，如果我们在35岁时由于失业而出现了财富危机，那么这个危机的种子肯定早在25岁时就种下了。因为25岁到35岁这段时间，大部分人不会思考一个关键性的问题：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何实现从“能力”到“财富”的转换？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;希望你读完本文，能成为那“一小部分人”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体来讲，这里的“财富”指什么，又包括哪些方面呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其&lt;/span&gt;&lt;span&gt;实《理工男谈理财：构建受益一生的财富体系》一书的第1节已经介绍了我&lt;/span&gt;&lt;span&gt;们最相关的财富项。这里我用一张典型的技术人员的发展路径图（如图1所示），帮助你更深入地理解这个概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7884097035040432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbQOCMjA3ROEo5QbtIfu8liadicQNP4Ye0VM3mmf7d5hv1vfPxd1JZYfpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1  科技行业从业者的不同发展路径&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从图1中的左半部分可以看到，只要你不是富二代，靠能力完成自己的原始财富积累就是一个必须经历的过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在财富积累的过程中，可能会出现这种情况：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;有些人因为频繁平级跳槽，甚至频繁更换职业方向，始终冲不破“用能力赚钱”这一圈层，因此终其一生，都只能在财富的初级赛道上打转。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们看到，完成财富积累的人，从四个方向突破到了“靠财富赚钱”的圈层。他们或是凭技术财富，或是依靠人脉、管理财富，或是拥有创业财富，或是依赖金融房产财富，完成了从“打工人”到“财富管理者”的转变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，让自己从多个方向突破到“靠财富赚钱”的圈层是更健康的方式。我想这样的从业者，无论如何都不会遭遇“35岁危机”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时你可能会说：从这四个方向突破都好难，感觉能做到的都是大咖，我们普通人真的能做到吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我先举两个例子，看看和我们一样的普通人是怎么在“35岁危机”前“突围”的。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;程序员小H的例子：从能力到财富的四个阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我想介绍的是程序员小H的例子。听完这个故事，你可以了解从能力到财富的积累路径。顺便说一句，因为我跟小H有一些交集，所以我可以保证这个故事的真实性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五年前，小H 30岁，他和我们大多数人一样，在某互联网公司重复着“996”的生活。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从那时起，他就开始思考这几个问题：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;自己未来的路到底在哪儿？目前的生活是不是自己想要的？自己35岁时，会不会像大家说的那样，遭遇职业生涯的危机？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;到了2022年，小H的状态是怎样的呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他有一个40万粉丝的微信公众号，是IT领域的头部大号；他出版的图书成了畅销书，一年卖出5万册。而早在2019年，小H就已经辞职，因为凭借他在行业内的影响力，通过广告、版权、技术社区带来的收入已经远远超过他作为程序员的收入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们前面提到，要想度过“35岁危机”，就一定要实现从能力到财富的积累。对比小H五年前和现在的状态，我们可以看到，五年前的小H只能通过“996”的付出来谋生，而五年后的小H已经有了三个非常有价值的、能够长期产生收益的财富项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这三大财富项分别是：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;媒体财富：IT类头部公众号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;版权财富：畅销书。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;人脉财富：技术社区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;那么这五年间，小H是如何实现从能力到财富的积累的呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我想大致分为如图2所示的几个阶段：探索阶段、积累阶段、收益阶段和正反馈阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11296296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbtKHLGkEtn5RtFLxwquy1Ojse4tPjG609icKybqoLX8ubIzSSaQA01jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2  从能力到财富的积累路径&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最初的探索阶段，小H在工作之余，尝试了多种可能产生收入的方向，比如利用自己的主业技能开发独立小游戏，利用自己的业余爱好投稿网文等，但都没有收到很好的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从2016年开始，小H想到了一种写公众号的特别方式：利用自己的专业优势为程序员讲解算法，并且采用新颖易懂的漫画形式。小H非常辛苦地坚持了一年，粉丝缓慢增长到1万人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个阶段往往是最艰难的，之后希望就来了，小H进入了积累阶段。&lt;/span&gt;&lt;span&gt;先是开始有收入了：公众号文章的阅读量与广告费成正比，一个1万粉丝的垂直领域公众号，大概会有1000~3000的阅读量，于是小H第一次获得了600元的广告收入。这之后，由于看到了成功的可能，小H投入了更多的精力，积累了更多公众号的写作和运营技巧，结识了更多圈内的人脉资源，一年之内让粉丝从1万迅速增长到10万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以说，到这里，小H已经成功完成了媒体财富的积累，后面的路就越走越顺了。凭借每个月稳定的广告收入，小H正式进入了依靠财富创收的收益阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这时，小H面临着一个选择：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;他可以用副业时间维持这个公众号，把它当作自己的一个收入来源；也可以进一步加大投入，基于这个公众号的资源“开枝散叶”，创造更多财富。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，小H选择了全职投入内容创作的事业中，正式进入了正反馈阶段。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在这个阶段，成功与否的关键点就在于&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;能不能建立起“由财富产生现金流，再通过现金流积攒更多财富”的正反馈（如图3所示）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6147443519619501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbXAQiaS4qqToR1MiatSbjgCa4EhfqibHck7QPjJniavvibP7Y10w7g2wh8Vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3  “创造财富-产生现金流-积累更多财富”的正反馈&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;让我们看看，小H是怎么建立起这个正反馈的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为小H在公众号上持续进行高质量的内容输出，所以出版社的编辑主动联系他出书。因为已经有了公众号提供的稳定现金流，所以小H可以全职投入内容创作。这样，他就有更多的时间把优质内容编写成书，并经过进一步的拔高提炼，形成深入浅出的高质量算法书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，由于小H在之前的几个阶段已经积累了大量粉丝，这本书一上市就自带热度，迅速畅销。这也进一步扩大了小H的影响力，扩充了他的收入来源。再之后，建立相应的知识社区、付费社群，产生了更大的现金流，技术社区中的讨论也丰富了小H的创作素材，便于进行更多的内容输出。这些都使小H在技术圈的影响力不断扩大，又反过来推动了公众号的扩张。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以看到，这一切终于形成了一个正反馈系统，小H的公众号、技术书、知识社区都是这个系统上能够互相助推的节点。如果你构建的体系发展到这一步，事情已经不用你来推动了，它会自己转起来。那么毫无疑问，这时你已经拥有了一座“金矿”，还用担心35岁时的事业危机吗？&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的创业故事：创业资源向财富资源的转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个例子，是我的创业故事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多熟悉我的读者知道，其实我的经历跟小H的有很多相似的地方：我也有自己的公众号，出版过不止一本技术畅销书，还在某线上教育平台有口碑不错的课程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但有一点，我跟小H不同：&lt;/span&gt;&lt;span&gt;我的所有副业都是为巩固主业服务的，并不是为了找寻一个能够替代主业的出路。但如果我愿意的话，也完全可以走上小H的道路。有了这样的选择，当然不担心失业之后一无所有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，你一定要清楚，讲小H的故事也不是想落入倡导大家都去写公众号文章的俗套。我只是希望，你能从这些例子中得到一些启发，理解从能力到财富转换的种种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下面我想跟你聊的，是我读研究生时的一段创业历程，也希望能给你一些启发。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是2006年进入清华大学计算机系读本科的，而我的创业经历从大学三年级，也就是2009年年初开始，贯穿了整个研究生阶段，一直到我开始第一份工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你是一名“80后”“95前”，那你一定知道2008到2010年，移动互联网的概念有多火。那几年创业的团队不胜枚举，我跟几位同学，以及校外的一些创业朋友，合伙创办了我们的移动互联网工作室“五点工作室”。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这个工作室的业务方向主要有以下三个。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）承接一些外包项目，产生切实的收益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）探索能够产生现金流的网赚项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）业余时间孵化我们的创业项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，这三条业务线都为我的人生积累了宝贵的财富。具体来讲，主要有以下几个非常切实的收益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在研究生毕业前，我通过接外包项目积累了40万元的存款，后来我用这些存款作为一部分首付款买了人生中的第一套商品房，帮助我及时赶上了房地产这趟车。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们利用机器学习和网络爬虫技术，搭建了一些垂直行业内容站，通过广告收入获得了稳定的现金流。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的创业项目被并购，让我持有了少量某上市公司的股票。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除此之外，这段经历不仅为我增加了很多技术实践的经验，还让我积累了大量产品、运营方面的知识，这些至今都对我的职业生涯有积极的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从我的故事中，你可以分析出哪些从能力到财富的转换呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;我觉得至少有以下三点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）把通过技术产生收入的能力转换成房地产这个优质财富项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）把机器学习的专业能力转换成优质的能产生现金流的网站或App财富。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）把创业的综合能力转换成已上市公司的股权财富。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;主动思考才能把握住财富机会&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我已经讲完了小H和我的故事，这时你可能想说：小H和你的成功都不具备代表性，因为这都是“时势造英雄”。一旦过了那个时间点，红利就消失了，不管创业还是公众号，都不容易成功了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事实果真如此吗？当然不是。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机会每时每刻都在出现，只要主动思考自身的优势，每个普通人都能找到适合自己的成功机会。把“锅”甩给“时代”，每天抱怨“内卷”和“生不逢时”，那是庸人才会做的事情，不是一个追求更好生活的普通人应该做的事情。当然，这个时代肯定存在着它的问题，但相比于改造这个时代，进行主动思考，改变自己，抓住身边的机会更务实一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回到正题，下面我再举几个用能力换财富的例子，希望给你一些行动方向上的启发。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面提到的小H，和我一样是一名理工男，是做算法题类的公众号成功的。其实只要结合自己的专业优势，懂得静下心来总结经验，在任何一个方向上都可以复制小H的成功。比如我的一位从事财务工作的朋友，一直在会计师事务所工作，他靠着熟练的Excel技巧出书、开课，照样获得了不菲的副业收入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面说的都是利用专业能力积累财富，下面再举个不一样的例子：我一位前同事，他利用的不是专业技能，而是自己的兴趣爱好。这位同事喜欢摄影，他一开始通过摄影作品赚了些小钱，后来就在节假日接一些婚庆摄影的单子，逐渐转型成了职业的婚庆摄影。现在，他不仅脱离了之前不喜欢的程序员行业，而且做婚庆摄影的收入居然超过了工程师的工资收入。这是一个典型的兴趣导向创业成功的例子。因为热爱这个行业，就有源源不断的动力支持他在这个领域做精、做深。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聚焦某个方向的小众市场进行投入，真的需要时运吗？我认为并不需要，需要的仅仅是你在一个方向上持续、深入钻研的能力。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;5&quot;&gt;5&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“榕树关系”：主业的健壮是一切副业的基础&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;讲了这么多发展副业的例子，你可能想说：“我们平常上班已经够累了，还会有精力培养副业吗？”这其实是个非常实际的问题。要回答这个问题，我们要先厘清主业和副业的关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对我来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;主业和副业最好的关系模式是“主业滋养副业，副业反馈主业”的“榕树关系”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个关系模式里，我们把主业比作榕树的主干，把副业比作由主干生发出的根。在开始的阶段，副业最好能够依附于你强壮的主业，从主业那里吸收营养，茁壮成长，成为你的“专业延伸财富”；而当副业长大后，它就能落地生根，反馈主业，让主业更健壮；再进一步，副业发展得好，还能像图4中的榕树一样，发展成一片榕树林，成为你新的财富增长点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6655555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbmHqfjUmyGPPRicCzH5dALBSf6lRRHtEQ65SWR4qLI37mesicE0mMw2ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4  独木成林的榕树&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接下来，我们再具体讲讲这里说的“榕树关系”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，如果你的主业不够健壮，在一开始的探索阶段，副业就不可能有一个较高的起点，你就很难在众多竞争者中脱颖而出。举个例子，如果小H没有把几百道算法题吃透，他怎么可能由此构建自己的知识体系，继而输出高质量的内容呢？我也是一样，如果上大学时，没有积累扎实的机器学习和编程功底，怎么能够靠它来创业和盈利呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;反过来讲，在探索阶段，副业其实也会支持、促进主业的发展。比如，算法题的精进肯定有助于小H的面试、跳槽，帮他拿到更好的Offer。而我对副业的投入，更是增加了我算法模型落地的能力，让我在研究生阶段就具备了大量的实践经验，这一点让我受益至今。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，由于小H和我的副业选择都和主业强相关，所以我们在副业上的时间投入，起到了类似于游戏中“双倍经验卡”的作用。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;对时间的高效利用，是你在没有实际收益的探索阶段把副业坚持下来的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我强烈建议你在开始一份副业之前，问自己下面这三个问题。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）这个副业是不是建立在我已有的技术或知识，或者坚持多年的兴趣爱好高点上的？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）这个副业能不能让我的主业也获益？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）我有没有可能坚持这个副业十年以上？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你都回答“是”，那就毫不犹豫地开启你的副业探索之旅吧。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;6&quot;&gt;6&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;本文讨论了如何拓展财富渠道的问题。关于这个问题，我们可以用“五个要点，一片榕树林”来总结。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;首先来看五个要点。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）要想35岁时没有失业危机，就要在25岁时开始思考从“能力”到“财富”转换的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）创立成功的副业要经历“探索-积累-收益-正反馈”四个典型阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）自己的副业一定要建立在主业的知识或技能高点，或者积累多年的爱好或特长上，否则没有竞争力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）探索阶段是最难的，在这个阶段寻找能够让主业也受益的副业方向，是平衡时间投入最有效的手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）坚持，坚持，坚持。最重要的事情说三遍，否则前面所有的分析都毫无意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后是“主业-副业的这片榕树林”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主业和副业最好的关系模式是“主业滋养副业，副业反馈主业”的“榕树关系”，如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7248062015503876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbSaBtc82GMSAkgoy8eib7bttcvePyb4FhmbibmVSIOZqaib7nXap4foe8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7706666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbcyicVuhASfBkQgKt7dic7qwicZHuHwCRmAAGvLuFMWc818r9KszXETSzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5  主业-副业和投资理财两片“榕树林”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，财富的“榕树林”又何止一片？在我们的财富双塔中，本章内容帮助你把个人发展的“榕树林”发展得枝繁叶茂，教给你的关于投资理财的各种技能也能组成另一片“榕树林”。关于如何发展投资理财这片“榕树林”，&lt;/span&gt;&lt;span&gt;在《理工男谈理财：构建受益一生的财富体系》一书的第3章会为大家&lt;/span&gt;&lt;span&gt;讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;107294&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JaFvPvvA2J1Clvz4XjNkCCVBtkQpCltfeUCXf9ZIy5iabeyU9OpE347LBN0rHfLxDmwibicgY4DKcwdFhQYbJkicNQ/640?wx_fmt=png&quot; data-w=&quot;59&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;7&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;思考题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我想和你讨论两个比较有意思的现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一个现象：在娱乐圈，明星“火”了之后，相比于只是接戏、拍戏，他们更热衷于开自己的工作室、影视公司，为什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个现象：很多真正有实力的互联网高管，即使年入千万，也还是要找机会离职创业，开办自己的公司，这又是为什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你能用本节能力换财富的思路，分析这两个现象背后的原因吗？&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot;&gt;本文节选自《理工男谈理财：构建受益一生的财富体系》一书，欢迎阅读本书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;6.621897810218978&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbiaiaPkG27ACVe6XTGsPxElHSZj2ZQ9wyo6EcTF6DzqMPct5aHmHBiaia7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;5.883280757097792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbneCJ2XSibyEHeTicOp3dPwAcDzVvQH3lgd2FmXAMgQ0kxanmul4QxwtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;131&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;131&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lvtTPFnuXVWCLJkfzsPTXbYWhFm1P232kSRcRFIV484ZextOsX8AzzxlJSLnU9bf4sLKicp78m9OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;131px&quot; title=&quot;理工男二维码.png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫码查看本书详情！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c3fbcf1ca8b2948c3505bb2e307f919</guid>
<title>我说 MySQL 单表超过 2000w 就要分库分表，面试官让我回去等通知？</title>
<link>https://toutiao.io/k/135oq4d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;「 &lt;/strong&gt;关注&lt;/span&gt;&lt;span&gt;&lt;strong&gt;“石杉的架构笔记”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大厂架构经验&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;倾囊相授&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;strong&gt;」&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa94uAA1BSamh6pwGZ3nHgOzf3Io5qH4xez8PsPPbHoicOqBD5h3CjS0k9YNHw5yTJ6BrH2kJUuTzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文章来源：【公众号：&lt;/span&gt;&lt;span&gt;程序员小富&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GHDOauYyUGbiaHXGx1ib5UxkKzSNtpMzY5tbbGdibG7icBSxlH783x1YTF0icAv8MWrmanB4u5qjyKfmYo1dDf7YbA/640?wx_fmt=gif&quot; data-w=&quot;100&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;不急于上手实战ShardingSphere框架，先来复习下分库分表的基础概念，技术名词大多晦涩难懂，不要死记硬背理解最重要，当你捅破那层窗户纸，发现其实它也就那么回事。&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;什么是分库分表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表是在海量数据下，由于单库、表数据量过大，导致数据库性能持续下降的问题，演变出的技术方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表是由&lt;code&gt;分库&lt;/code&gt;和&lt;code&gt;分表&lt;/code&gt;这两个独立概念组成的，只不过通常分库与分表的操作会同时进行，以至于我们习惯性的将它们合在一起叫做分库分表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41421143847487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInaRibtuhkoWXCSibia28DS90txOibrv7C4TIdKYnppibSXHD2z4lZguZorjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过一定的规则，将原本数据量大的数据库拆分成多个单独的数据库，将原本数据量大的表拆分成若干个数据表，使得单一的库、表性能达到最优的效果（响应速度快），以此提升整体数据库性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么分库分表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机数据库的存储能力、连接数是有限的，它自身就很容易会成为系统的瓶颈。当单表数据量在百万以里时，我们还可以通过添加从库、优化索引提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦数据量朝着千万以上趋势增长，再怎么优化数据库，很多操作性能仍下降严重。为了减少数据库的负担，提升数据库响应速度，缩短查询时间，这时候就需要进行分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么需要分库？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;容量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们给数据库实例分配的磁盘容量是固定的，数据量持续的大幅增长，用不了多久单机的容量就会承载不了这么多数据，解决办法简单粗暴，加容量！&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;连接数&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单机的容量可以随意扩展，但数据库的连接数却是有限的，在高并发场景下多个业务同时对一个数据库操作，很容易将连接数耗尽导致&lt;code&gt;too many connections&lt;/code&gt;报错，导致后续数据库无法正常访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;max_connections&lt;/code&gt;查看MySQL最大连接数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%max_connections%&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.173015873015873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInBUKBzcmPxvvjGbdGtueIYFoEqsN9nlauykBxqBa0gENlsZDaaiaeoOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将原本单数据库按不同业务拆分成订单库、物流库、积分库等不仅可以有效分摊数据库读写压力，也提高了系统容错性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么需要分表？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;做过报表业务的同学应该都体验过，一条SQL执行时间超过几十秒的场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致数据库查询慢的原因有很多，SQL没命中索引、like扫全表、用了函数计算，这些都可以通过优化手段解决，可唯独数据量大是MySQL无法通过自身优化解决的。慢的根本原因是&lt;code&gt;InnoDB&lt;/code&gt;存储引擎，聚簇索引结构的 B+tree 层级变高，磁盘IO变多查询性能变慢，详细原理自行查找一下，这里不用过多篇幅说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的开发手册中有条建议，单表行数超500万行或者单表容量超过2GB，就推荐分库分表，然而理想和实现总是有差距的，阿里这种体量的公司不差钱当然可以这么用，实际上很多公司单表数据几千万、亿级别仍然不选择分库分表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11318242343541944&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInkGJy6VW8WKq5qgKMlj35Gr8gImkTibcFpugZF6pR0QM1sHg6eMSvojQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1502&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;什么时候分库分表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;经常会有小伙伴问，到底什么情况下会用分库分表呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表要解决的是&lt;code&gt;现存海量数据&lt;/code&gt;访问的性能瓶颈，对&lt;code&gt;持续激增&lt;/code&gt;的数据量所做出的架构预见性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;是否分库分表的关键指标是数据量&lt;/strong&gt;，我们以&lt;code&gt;fire100.top&lt;/code&gt;这个网站的资源表 &lt;code&gt;t_resource&lt;/code&gt;为例，系统在运行初始的时候，每天只有可怜的几十个资源上传，这时使用单库、单表的方式足以支持系统的存储，数据量小几乎没什么数据库性能瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但某天开始一股神秘的流量进入，系统每日产生的资源数据量暴增至十万甚至上百万级别，这时资源表数据量到达千万级，查询响应变得缓慢，数据库的性能瓶颈逐渐显现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以MySQL数据库为例，单表的数据量在达到亿条级别，通过加索引、SQL调优等传统优化策略，性能提升依旧微乎其微时，就可以考虑做分库分表了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然MySQL存储海量数据时会出现性能瓶颈，那么我们是不是可以考虑用其他方案替代它？比如高性能的非关系型数据库&lt;code&gt;MongoDB&lt;/code&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以，但要看存储的数据类型！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在互联网上大部分公司的核心数据几乎是存储在关系型数据库（MySQL、Oracle等），因为它们有着&lt;code&gt;NoSQL&lt;/code&gt;如法比拟的稳定性和可靠性，产品成熟生态系统完善，还有核心的事务功能特性，也是其他存储工具不具备的，而评论、点赞这些非核心数据还是可以考虑用&lt;code&gt;MongoDB&lt;/code&gt;的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如何分库分表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;分库分表的核心就是对数据的分片（&lt;code&gt;Sharding&lt;/code&gt;）并相对均匀的路由在不同的库、表中，以及分片后对数据的快速定位与检索结果的整合。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库与分表可以从：垂直（纵向）和 水平（横向）两种纬度进行拆分。下边我们以经典的订单业务举例，看看如何拆分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInvcZoP6NdMzl9wr7icXnqYu0VOAD8XKvNJyic36OEC9DfsNgfJkLS5K3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;垂直拆分&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）垂直分库&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分库一般来说按照业务和功能的维度进行拆分，将不同业务数据分别放到不同的数据库中，核心理念 &lt;code&gt;专库专用&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按业务类型对数据分离，剥离为多个数据库，像订单、支付、会员、积分相关等表放在对应的订单库、支付库、会员库、积分库。不同业务禁止跨库直连，获取对方业务数据一律通过&lt;code&gt;API&lt;/code&gt;接口交互，这也是微服务拆分的一个重要依据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40665701881331406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInG73MELGmbElnUcz4Xll9Z1vibGQC0V5ia0SznS4OINWf09L5DQpNRwkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;figcaption&gt;垂直分库&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分库很大程度上取决于业务的划分，但有时候业务间的划分并不是那么清晰，比如：电商中订单数据的拆分，其他很多业务都依赖于订单数据，有时候界线不是很好划分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分库把一个库的压力分摊到多个库，提升了一些数据库性能，但并没有解决由于单表数据量过大导致的性能问题，所以就需要配合后边的分表来解决。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2）垂直分表&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直分表针对业务上字段比较多的大表进行的，一般是把业务宽表中比较独立的字段，或者不常用的字段拆分到单独的数据表中，是一种大表拆小表的模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：一张&lt;code&gt;t_order&lt;/code&gt;订单表上有几十个字段，其中订单金额相关字段计算频繁，为了不影响订单表&lt;code&gt;t_order&lt;/code&gt;的性能，就可以把订单金额相关字段拆出来单独维护一个&lt;code&gt;t_order_price_expansion&lt;/code&gt;扩展表，这样每张表只存储原表的一部分字段，通过订单号&lt;code&gt;order_no&lt;/code&gt;做关联，再将拆分出来的表路由到不同的库中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5129449838187702&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInqPGcugSXaKAVAMJL3xIBJMCQIJj5DoIxoL1EK9ic5ZWXH5n9mzib0LGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库它是以行为单位将数据加载到内存中，这样拆分以后核心表大多是访问频率较高的字段，而且字段长度也都较短，因而可以加载更多数据到内存中，减少磁盘IO，增加索引查询的命中率，进一步提升数据库性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;水平拆分&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上边垂直分库、垂直分表后还是会存在单库、表数据量过大的问题，当我们的应用已经无法在细粒度的垂直切分时，依旧存在单库读写、存储性能瓶颈，这时就要配合水平分库、水平分表一起了。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（1）水平分库&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平分库是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，以此实现水平扩展，是一种常见的提升数据库性能的方式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4723618090452261&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInTG3j8xBLV5zibIVkB0RhFT6XA6ib4yiasITIDDJ9I5ARYU04EQMqkVSNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;code&gt;db_orde_1&lt;/code&gt;、&lt;code&gt;db_order_2&lt;/code&gt;两个数据库内有完全相同的&lt;code&gt;t_order&lt;/code&gt;表，我们在访问某一笔订单时可以通过对订单的订单编号取模的方式 &lt;code&gt;订单编号 mod 2 （数据库实例数）&lt;/code&gt; ，指定该订单应该在哪个数据库中操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案往往能解决单库存储量及性能瓶颈问题，但由于同一个表被分配在不同的数据库中，数据的访问需要额外的路由工作，因此系统的复杂度也被提升了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2）水平分表&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平分表是在&lt;strong&gt;同一个数据库内&lt;/strong&gt;，把一张大数据量的表按一定规则，切分成多个结构完全相同表，而每个表只存原表的一部分数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：一张&lt;code&gt;t_order&lt;/code&gt;订单表有900万数据，经过水平拆分出来三个表，&lt;code&gt;t_order_1&lt;/code&gt;、&lt;code&gt;t_order_2&lt;/code&gt;、&lt;code&gt;t_order_3&lt;/code&gt;，每张表存有数据300万，以此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6375545851528385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInQKQHMMTrzaQJ9gtOBkXpzV0geic2PC2NDlibOo3ClAibUsQ0R8FEX6kjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1374&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平分表尽管拆分了表，但子表都还是在同一个数据库实例中，只是解决了单一表数据量过大的问题，并没有将拆分后的表分散到不同的机器上，还在竞争同一个物理机的CPU、内存、网络IO等。要想进一步提升性能，就需要将拆分后的表分散到不同的数据库中，达到分布式的效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5764705882352941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInUm6sQ78O1p1K0wMDYnv8wLsOucdiaiaTicQic7HK9cp5ZF0ehUKXfYqibzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据存在哪个库的表&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表以后会出现一个问题，一张表会出现在多个数据库里，到底该往哪个库的哪个表里存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边我们多次提到过&lt;code&gt;一定规则&lt;/code&gt; ，其实这个规则它是一种路由算法，决定了一条数据具体应该存在哪个数据库的哪张表里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有 &lt;code&gt;取模算法&lt;/code&gt; 、&lt;code&gt;范围限定算法&lt;/code&gt;、&lt;code&gt;范围+取模算法&lt;/code&gt; 、&lt;code&gt;预定义算法&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1、取模算法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键字段取模（对hash结果取余数 hash(XXX) mod N)，N为数据库实例数或子表数量）是最为常见的一种路由方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以&lt;code&gt;t_order&lt;/code&gt;订单表为例，先给数据库从 0 到 N-1进行编号，对 &lt;code&gt;t_order&lt;/code&gt;订单表中&lt;code&gt;order_no&lt;/code&gt;订单编号字段进行取模&lt;code&gt;hash(order_no) mod N&lt;/code&gt;，得到余数&lt;code&gt;i&lt;/code&gt;。&lt;code&gt;i=0&lt;/code&gt;存第一个库，&lt;code&gt;i=1&lt;/code&gt;存第二个库，&lt;code&gt;i=2&lt;/code&gt;存第三个库，以此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5263157894736842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInnapqp3zGVlFT0VNTiaJkZhxljnJlBJT5m5zRy4nLZ55pqUL42T7weQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同一笔订单数据会落在同一个库、表里，查询时用相同的规则，用&lt;code&gt;t_order&lt;/code&gt;订单编号作为查询条件，就能快速的定位到数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现简单，数据分布相对比较均匀，不易出现请求都打到一个库上的情况。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取模算法对集群的伸缩支持不太友好，集群中有N个数据库实&lt;code&gt;·hash(user_id) mod N&lt;/code&gt;，当某一台机器宕机，本应该落在该数据库的请求就无法得到处理，这时宕掉的实例会被踢出集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时机器数减少算法发生变化&lt;code&gt;hash(user_id) mod N-1&lt;/code&gt;，同一用户数据落在了在不同数据库中，等这台机器恢复，用&lt;code&gt;user_id&lt;/code&gt;作为条件查询用户数据就会少一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2、范围限定算法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;范围限定算法以某些范围字段，如&lt;/span&gt;&lt;code&gt;时间&lt;/code&gt;&lt;span&gt;或&lt;/span&gt;&lt;code&gt;ID区&lt;/code&gt;&lt;span&gt;拆分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户表&lt;code&gt;t_user&lt;/code&gt;被拆分成&lt;code&gt;t_user_1&lt;/code&gt;、&lt;code&gt;t_user_2&lt;/code&gt;、&lt;code&gt;t_user_3&lt;/code&gt;三张表，后续将&lt;code&gt;user_id&lt;/code&gt;范围为1 ~ 1000w的用户数据放入&lt;code&gt;t_user_1&lt;/code&gt;，1000~ 2000w放入&lt;code&gt;t_user_2&lt;/code&gt;，2000~3000w放入&lt;code&gt;t_user_3&lt;/code&gt;，以此类推。按日期范围划分同理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4913112164296998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInfk4pwUYkzFEPcUEmap3ogOSIK6X5aPEZ0oYrPlStwMR5iaXqpOqWnGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;单表数据量是可控的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;水平扩展简单只需增加节点即可，无需对其他分片的数据进行迁移&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;由于连续分片可能存在&lt;code&gt;数据热点&lt;/code&gt;，比如按时间字段分片时，如果某一段时间（双11等大促）订单骤增，存11月数据的表可能会被频繁的读写，其他分片表存储的历史数据则很少被查询，导致数据倾斜，数据库压力分摊不均匀。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3、范围 + 取模算法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免热点数据的问题，我们可以对上范围算法优化一下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们先通过范围算法定义每个库的用户表&lt;code&gt;t_user&lt;/code&gt;只存1000w数据，第一个&lt;code&gt;db_order_1&lt;/code&gt;库存放&lt;code&gt;userId&lt;/code&gt;从1 ~ 1000w，第二个库1000~2000w，第三个库2000~3000w，以此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6112565445026178&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseIn47gFXYHsvZd1ic5pspMuztPsMvr0dr22uV5cGD9Ap1ZWwNUTrTEq6cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个库里再把用户表&lt;code&gt;t_user&lt;/code&gt;拆分成&lt;code&gt;t_user_1&lt;/code&gt;、&lt;code&gt;t_user_2&lt;/code&gt;、&lt;code&gt;t_user_3&lt;/code&gt;等，对&lt;code&gt;userd&lt;/code&gt;进行取模路由到对应的表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有效的避免数据分布不均匀的问题，数据库水平扩展也简单，直接添加实例无需迁移历史数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4、地理位置分片&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;地理位置分片其实是一个更大的范围，按城市或者地域划分，比如华东、华北数据放在不同的分片库、表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5、预定义算法&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预定义算法是事先已经明确知道分库和分表的数量，可以直接将某类数据路由到指定库或表中，查询的时候亦是如此。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分库分表出来的问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了上边分库分表的拆分方式不难发现，相比于拆分前的单库单表，系统的数据存储架构演变到现在已经变得非常复杂。看几个具有代表性的问题，比如：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分页、排序、跨节点联合查询&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分页、排序、联合查询，这些看似普通，开发中使用频率较高的操作，在分库分表后却是让人非常头疼的问题。把分散在不同库中表的数据查询出来，再将所有结果进行汇总合并整理后提供给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：我们要查询11、12月的订单数据，如果两个月的数据是分散到了不同的数据库实例，则要查询两个数据库相关的数据，在对数据合并排序、分页，过程繁琐复杂。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5364238410596026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInA5QAJeiaTCypxqTSqy2Iqsqib0GfBBDtafkyLaPLbhicWDVd34qJxDAicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1510&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事务一致性&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表后由于表分布在不同库中，不可避免会带来跨库事务问题。后续会分别以阿里的&lt;code&gt;Seata&lt;/code&gt;和MySQL的&lt;code&gt;XA&lt;/code&gt;协议实现分布式事务，用来比较各自的优势与不足。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全局唯一的主键&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表后数据库表的主键ID业务意义就不大了，因为无法在标识唯一一条记录，例如：多张表&lt;code&gt;t_order_1&lt;/code&gt;、&lt;code&gt;t_order_2&lt;/code&gt;的主键ID全部从1开始会重复，此时我们需要主动为一条记录分配一个ID，这个全局唯一的ID就叫&lt;code&gt;分布式ID&lt;/code&gt;，发放这个ID的系统通常被叫发号器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多数据库高效治理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对多个数据库以及库内大量分片表的高效治理，是非常有必要，因为像某宝这种大厂一次大促下来，订单表可能会被拆分成成千上万个&lt;code&gt;t_order_n&lt;/code&gt;表，如果没有高效的管理方案，手动建表、排查问题是一件很恐怖的事。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;历史数据迁移&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表架构落地以后，首要的问题就是如何平滑的迁移历史数据，增量数据和全量数据迁移，这又是一个比较麻烦的事情，后边详细讲。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分库分表架构模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表架构主要有两种模式：&lt;code&gt;client&lt;/code&gt;客户端模式和&lt;code&gt;proxy&lt;/code&gt;代理模式&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;客户模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;client&lt;/code&gt;模式指分库分表的逻辑都在你的系统应用内部进行控制，应用会将拆分后的SQL直连多个数据库进行操作，然后本地进行数据的合并汇总等操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48293515358361777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseIn5NLhexuwavJEkxficshFgNu9LAmHXXyH6yql1rVqmlsFtQnibY8UHr8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;proxy&lt;/code&gt;代理模式将应用程序与MySQL数据库隔离，业务方的应用不在需要直连数据库，而是连接proxy代理服务，代理服务实现了MySQL的协议，对业务方来说代理服务就是数据库，它会将SQL分发到具体的数据库进行执行，并返回结果。该服务内有分库分表的配置，根据配置自动创建分片表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5072697899838449&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0OzaL5uW2aMzBtytGgvE1derMNyqseInzAdRSXqQoYic9mqKibcGgoibrtsdVKAv0gj2nM1Q7PaGhVnoPOjRsTKSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1238&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何抉择&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何选择&lt;code&gt;client&lt;/code&gt;模式和&lt;code&gt;proxy&lt;/code&gt;模式，我们可以从以下几个方面来简单做下比较。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（1）性能&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能方面&lt;code&gt;client&lt;/code&gt;模式表现的稍好一些，它是直接连接MySQL执行命令；&lt;code&gt;proxy&lt;/code&gt;代理服务则将整个执行链路延长了，应用-&amp;gt;代理服务-&amp;gt;MySQL，可能导致性能有一些损耗，但两者差距并不是非常大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（2）复杂度&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;client&lt;/code&gt;模式在开发使用通常引入一个jar可以；&lt;code&gt;proxy&lt;/code&gt;代理模式则需要搭建单独的服务，有一定的维护成本，既然是服务那么就要考虑高可用，毕竟应用的所有SQL都要通过它转发至MySQL。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（3）升级&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;client&lt;/code&gt;模式分库分表一般是依赖基础架构团队的Jar包，一旦有版本升级或者Bug修改，所有应用到的项目都要跟着升级。小规模的团队服务少升级问题不大，如果是大公司服务规模大，且涉及到跨多部门，那么升级一次成本就比较高；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;proxy&lt;/code&gt;模式在升级方面优势很明显，发布新功能或者修复Bug，只要重新部署代理服务集群即可，业务方是无感知的，但要保证发布过程中服务的可用性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（4）治理、监控&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;client&lt;/code&gt;模式由于是内嵌在应用内，应用集群部署不太方便统一处理；&lt;code&gt;proxy&lt;/code&gt;模式在对SQL限流、读写权限控制、监控、告警等服务治理方面更优雅一些。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-w=&quot;336&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>800cb8922bfcf05d9e9fb79eef12bfca</guid>
<title>快速绘制流程图「GitHub 热点速览 v.22.47」</title>
<link>https://toutiao.io/k/1kjjzsg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0gD3bPY8kBVofSfy0oEgiaAA29ib1nFgwEm1e0z8Klh4gTmKzQic23GnmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;5568&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;画流程图一直是研发的一个难题，如何画得通俗易懂已经够让人头疼了，还要美观大方。用 d2 的语法描述下流程，d2 会自动帮你生成一张配色极佳的流程图。说到研发的选择，本周特推的 choiceof.dev 罗列了众多开发过程中会遇到的选项，你可以自测下你同主流研发的契合度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本周周榜呢，有监控网络流量的 sniffnet，监控 API 流量的 kubeshark，还有以便不时之需的开发小抄 cheat.sh，记录日常事项的备忘录 memos 和音频转文字工具 buzz。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;/span&gt;&lt;code&gt;&lt;span&gt;新发布&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;实用&lt;/span&gt;&lt;/code&gt;&lt;span&gt; | &lt;/span&gt;&lt;code&gt;&lt;span&gt;有趣&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;/span&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6574923547400612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX04Ly2OobE4agPwJ6Ta9wbfxM9zvuxRMXljAH7QXE9Uyu18cdz67dk9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 文本变图表：d2&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：Go&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 本周刚开源并突破 5k star 关卡的“爆款”项目，只要用文本就可以生成对应的图表。比如下面这段语法讲得到一个流程图。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# Actors&lt;/span&gt;&lt;br/&gt;hans: Hans Niemann&lt;br/&gt;&lt;br/&gt;defendants: {&lt;br/&gt;  mc: Magnus Carlsen&lt;br/&gt;  playmagnus: Play Magnus Group&lt;br/&gt;  chesscom: Chess.com&lt;br/&gt;  naka: Hikaru Nakamura&lt;br/&gt;&lt;br/&gt;  mc -&amp;gt; playmagnus: Owns majority&lt;br/&gt;  playmagnus &amp;lt;-&amp;gt; chesscom: Merger talks&lt;br/&gt;  chesscom -&amp;gt; naka: Sponsoring&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Accusations&lt;/span&gt;&lt;br/&gt;hans -&amp;gt; defendants: &lt;span&gt;&#x27;sueing for $100M&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Offense&lt;/span&gt;&lt;br/&gt;defendants.naka -&amp;gt; hans: Accused of cheating on his stream&lt;br/&gt;defendants.mc -&amp;gt; hans: Lost &lt;span&gt;then&lt;/span&gt; withdrew with accusations&lt;br/&gt;defendants.chesscom -&amp;gt; hans: 72 page report of cheating&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2746331236897275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0JclcROZ7n3oOgKWCUGddRBZJafGCLSrF6TJogb4MotwSribHd7iaCf6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/terrastruct/d2&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 艰难选择：choiceof.dev&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主语言：TypeScript&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开发人员日常面对着非常艰难的选择，可能就是技术选型，当然也可能是简单的如何提交代码。choiceof.dev 给出了形形色色同开发相关的选项，有复杂的也有简单的。比如，下图如何提交代码，强制提交的占了 64%。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/bdebon/choiceof.dev&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4864652805021577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0jb8Aa0TpLF462c2yyAibJvChibTUuPPhicGnjHQebqAxo8ibDTGGNxRIMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2549&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 轻松监控网络流量：sniffnet&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：900+&lt;strong&gt;，&lt;/strong&gt;主语言：Rust&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;New&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 一个跨平台的网络流量监控工具，可快速、直观查看流量变化。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/GyulyVGC/sniffnet&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0R3NPFvBzkM9BDBba8dsCLMYWFaLWjJCDrsic6MyQ5GAgxzbyKy5xyyQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 音频转文本：buzz&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：550+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;转换音频为文本的工具，支持麦克风实时录入转文字，也支持导入已有音频文件。文本可以导出为 TXT、SRT、VTT 格式。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/chidiwilliams/buzz&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX01r0gphzbuibN12E0eMHrU1Vjy3YcvVHKzwBycNISoOKlUau0WvZ8NQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2400&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 高颜值备忘录：memos&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,850+&lt;strong&gt;，&lt;/strong&gt;主语言：TypeScript&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具备知识管理能力的备忘中心，可多人协作。特性：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持自托管，秒拉起来一个 Docker 应用；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持 Markdown 语法；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同组内成员协作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;自服务的 RESTful API；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/usememos/memos&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7193426042983565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0gP2AZUIKUgYjvkhzry8XYvMpCONvJKDQHuBSEgStrtibpBARXkEr0pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.4 研发小抄：cheat.sh&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,350+&lt;strong&gt;，&lt;/strong&gt;主语言：Python&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;非必要不小抄，cheat.sh 具有理想小抄的一切特性：简洁、快速、全面、低调、可辅助学习。它能在 100ms 内搜刮完 Stack Overflow 等网站，并返回你所需要的答案。支持 curl / 浏览器 / 编辑器交互。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/chubin/cheat.sh&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX0SzlbyMWV49HOufA5mXiaEdewjdHb5eDO6kuhEIibejCLOy3iaFQlRhMxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2.5 API 流量查看器：kubeshark&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：900+&lt;strong&gt;，&lt;/strong&gt;主语言：Golang&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为 K8s 的 API 流量查看器，kubeshark 支持对 K8s 所有集群的 API 流量和负载进行监控。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/kubeshark/kubeshark&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6221739130434782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMhKibftPWrpRyZkzicQysMX07qKN20aIyMku1OwBWMb1T50ZCD25AOqSx280nF2kwiayXMibWqDDvbMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2300&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期回顾：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上为 2022 年第 47 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top3 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>513530f11b60ec57e94ddf1ac579998f</guid>
<title>Rust 语法梳理与总结（中）</title>
<link>https://toutiao.io/k/js7q4md</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;楔子&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们继续来梳理 Rust 语法，本次让我们把目光聚焦于函数、闭包、泛型和 trait 上面，开始接下来的内容。并且在梳理的时候，同样会&lt;span&gt;对之前没有说的内容做一&lt;/span&gt;&lt;span&gt;个补充。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;函数（function）使用 fn 关键字来声明，函数的参数需要标注类型，就和变量一样。如果函数返回一个值，返回值的类型必须在箭头 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 之后指定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;函数的最后一个表达式将作为返回值，当然也可以在函数内使用 return 语句来提前返回一个值。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 一个返回布尔值的函数，判断 b 能够被 a 整除&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;is_divisible_by&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;u32&lt;/span&gt;, b: &lt;span&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; b == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        a % b == &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    false&lt;br/&gt;    false&lt;br/&gt;    true&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后函数参数默认都是不可变的，如果希望它可变，那么在声明的时候也要使用 mut 关键字。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;is_divisible_by&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;u32&lt;/span&gt;, &lt;span&gt;mut&lt;/span&gt; b: &lt;span&gt;u32&lt;/span&gt;) -&amp;gt; &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 此时 b 就是一个可变参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果 b 等于 0，那么就将它改成 1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; b == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        b = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    a % b == &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, is_divisible_by(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    false&lt;br/&gt;    true&lt;br/&gt;    true&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;既然提到了函数，那么就不得不提方法，方法是依附于某个对象的函数，在 impl 代码块内定义。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x: &lt;span&gt;f64&lt;/span&gt;,&lt;br/&gt;    y: &lt;span&gt;f64&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实现的代码块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Point {&lt;br/&gt;    &lt;span&gt;// 这是一个静态方法（static method）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 静态方法不需要被实例调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这类方法一般用作构造器（constructor）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;origin&lt;/span&gt;&lt;/span&gt;() -&amp;gt; Point {&lt;br/&gt;        Point { x: &lt;span&gt;0.0&lt;/span&gt;, y: &lt;span&gt;0.0&lt;/span&gt; }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 另一个静态方法，需要两个参数：&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;/span&gt;(x: &lt;span&gt;f64&lt;/span&gt;, y: &lt;span&gt;f64&lt;/span&gt;) -&amp;gt; Point {&lt;br/&gt;        Point { x: x, y: y }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 计算两个点之间的曼哈顿距离&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;distance&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;, other: &amp;amp;Point) -&amp;gt; &lt;span&gt;f64&lt;/span&gt; {&lt;br/&gt;        (&lt;span&gt;self&lt;/span&gt;.x - other.x).abs() + (&lt;span&gt;self&lt;/span&gt;.y - other.y).abs()&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 修改某个点的坐标&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;modify_x&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;mut&lt;/span&gt; &lt;span&gt;self&lt;/span&gt;, x: &lt;span&gt;f64&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.x = x;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;modify_y&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;mut&lt;/span&gt; &lt;span&gt;self&lt;/span&gt;, y: &lt;span&gt;f64&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.y = y;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; p1 = Point::new(&lt;span&gt;3.2&lt;/span&gt;, &lt;span&gt;1.4&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; p2 = Point::new(&lt;span&gt;4.3&lt;/span&gt;, &lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p1);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p2);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    Point { x: 3.2, y: 1.4 }&lt;br/&gt;    Point { x: 4.3, y: 1.5 }&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, p1.distance(&amp;amp;p2));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, p2.distance(&amp;amp;p1));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    1.1999999999999997&lt;br/&gt;    1.1999999999999997&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    p1.modify_x(&lt;span&gt;10.0&lt;/span&gt;);&lt;br/&gt;    p2.modify_y(&lt;span&gt;10.0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p1);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p2);&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    Point { x: 10.0, y: 1.4 }&lt;br/&gt;    Point { x: 4.3, y: 10.0 }&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;函数和方法本身还是很简单的，我们重点来看一下闭包。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;span&gt;包含两部分：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;函数，在 Rust 里面必须是匿名函数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;环境，由函数捕获的外层作用域中的变量组成；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们先来看看普通函数和匿名函数在语法上的区别。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;add1&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add2 = |a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b&lt;br/&gt;    };&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用 fn 关键字定义的是普通函数，而匿名函数没有函数名，并且要把参数所在的小括号换成 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;|...|&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。然后这里我们将匿名函数赋值给了变量 add2，因此在使用上，add1 和 add2 没有区别，普通函数和匿名函数都是函数。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看看闭包，闭包本质上也是一个匿名函数，但它可以捕获外层作用域的变量，而这是 fn 定义的普通函数所做不到的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; start = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b + start&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, add(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;));  &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;因为变量 start 是定义在 main 函数里面的，所以闭包 add 捕获了外层作用域（这里是 &lt;span&gt;m&lt;/span&gt;&lt;span&gt;ain 函数&lt;/span&gt;&lt;span&gt;的作用域&lt;/span&gt;）的变量。而我们说&lt;/span&gt;&lt;span&gt;普通函数&lt;/span&gt;&lt;span&gt;做不到这一点，&lt;/span&gt;&lt;span&gt;来验证一下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.34628378378378377&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGFwabEOJQqbGcEDemba2r0hibZGxkUGmBXMAuUyo4LndHGV1pMtxRfdjIVoJMNicKtF50ib0u2QXsYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都不用执行，IDE 就已经给出提示了。普通函数无法捕获外层作用域的变量，我们应该使用&lt;/span&gt;&lt;span&gt;&lt;strong&gt; || {...} &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;定义的闭包。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;捕获变量会产生额外开销&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;然后闭包还可以省略参数的类型，以及返回值类型。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 不指定参数的类型和返回值类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Rust 会根据我们后续的使用推断出来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |i, j| {&lt;br/&gt;        (i, j)&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;// 这里调用了两次 add，显然 Rust 会进行推断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 会将参数 i 推断为 f32，将 j 推断为 u16&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 然后返回的是 (i, j)，那么返回值类型就是 (f32, u16)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, add(&lt;span&gt;3.14&lt;/span&gt;, &lt;span&gt;666u16&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, add(&lt;span&gt;2.71f32&lt;/span&gt;, &lt;span&gt;777&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    (3.14, 666)&lt;br/&gt;    (2.71, 777)&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 一旦推断出来，那么参数和返回值类型就确定了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以下面的调用是不合法的，因为参数类型错了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// add(12, 13);  // 报错，将 12 改成 12.0，那么就没问题了&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;总的来说，Rust 的类型推断还是很智能的，但即便如此，我们也最好明确指定类型。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，如果代码块只有一行代码的话，那么大括号也可以省略。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |i, j| (i, j);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, add(&lt;span&gt;3.14&lt;/span&gt;, &lt;span&gt;666u16&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, add(&lt;span&gt;2.71f32&lt;/span&gt;, &lt;span&gt;777&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    (3.14, 666)&lt;br/&gt;    (2.71, 777)&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;注意：只有闭包才可以这么干，普通函数是不可以的。不过为了代码的可读性，还是不建议将大括号去掉，另外参数和返回值的类型最好也不要省略。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;将闭包作为参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;先来回顾一下函数是怎么作为参数的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;F&lt;/span&gt;&lt;/span&gt; = &lt;span&gt;fn&lt;/span&gt;(&lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// calc 接收三个参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 第一个参数：接收两个 i32 返回一个 i32 的函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 第二个参数和第三个参数均是 i32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;calc&lt;/span&gt;&lt;/span&gt;(op: F, a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;    op(a, b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, calc(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;));  &lt;span&gt;// 33&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;咦，参数 op 接收的是普通函数，而我们传递的 add 是一个闭包，为啥没报错呢？很简单，因为在 Rust 里面闭包本质上就是一个匿名函数，只不过它可以捕获外层作用域的变量罢了。但我们这里没有捕获，因此它和 fn 定义的普通函数是完全等价的，都是函数。如果我们将代码修改一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8583815028901735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFA2pKhuicSkiaeUDzLPRKrcP0Vz24PvWumS86h7dDJfjnvYZr0LakbpyGO9ic5OuV3HULAlbsn3VGibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到报错了，告诉我们类型不匹配。由于使用了外部的变量 start，所以闭包 add 就不能作为参数传递了，此时它和 fn 定义的普通函数不是完全等价的，&lt;span&gt;因为后者&lt;/span&gt;无法捕获外层作用域的变量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们要修改函数 calc 的第一个参数的类型，将它改成闭包类型，而这需要使用一个叫 Fn 的 trait 来实现（一会儿介绍 trait）。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;calc&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(op: T, a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;    T: &lt;span&gt;Fn&lt;/span&gt;(&lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;{&lt;br/&gt;    op(a, b)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 或者你还可以这么定义：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/*&lt;br/&gt;fn calc(op: impl Fn(i32, i32) -&amp;gt; i32,&lt;br/&gt;        a: i32, b: i32) -&amp;gt; i32 {}&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; start = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b + start&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, calc(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;)); &lt;span&gt;// 34&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, add(&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;)); &lt;span&gt;// 34&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上我们就将闭包作为参数传递了，另外传递一个 fn 关键字定义的普通函数也是可以的。虽然它不是闭包，但它实现了 Fn 这个 trait。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;calc&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(op: T, a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;T: &lt;span&gt;Fn&lt;/span&gt;(&lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;{&lt;br/&gt;    op(a, b)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; add = |a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;| -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, calc(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;)); &lt;span&gt;// 33&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;i32&lt;/span&gt;, b: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;i32&lt;/span&gt; {&lt;br/&gt;        a + b&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, calc(add, &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;)); &lt;span&gt;// 33&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在 Rust 里面，不管有没有捕获外层作用域的变量，匿名函数都是一个闭包。&lt;/span&gt;&lt;span&gt;只是在没有捕获的情况下，&lt;/span&gt;&lt;span&gt;它和 fn 定义的普通函数也是完全等价的。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;闭包作为返回值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;再来看看如何将闭包作为返回值，这中间会有一些和其它语言不一样的地方。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;login&lt;/span&gt;&lt;/span&gt;(username: &lt;span&gt;String&lt;/span&gt;, passwd: &lt;span&gt;String&lt;/span&gt;) -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;Fn&lt;/span&gt;() -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;move&lt;/span&gt; || {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; username.eq(&amp;amp;&lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;)) &amp;amp;&amp;amp;&lt;br/&gt;           passwd.eq(&amp;amp;&lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;123456&quot;&lt;/span&gt;)){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;欢迎来到编程教室&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;用户名密码错误&quot;&lt;/span&gt;)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; username = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; passwd = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; closure = login(username, passwd);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, closure());&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    欢迎来到编程教室&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; username = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; passwd = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;654321&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; closure = login(username, passwd);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, closure());&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    用户名密码错误&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;代码非常简单，调用 login 函数之后返回一个闭包，然后调用闭包的时候比较用户名和密码，返回不同的字符串。需要注意的是，字符串的 eq 方法的第一个参数接收的是引用，所以闭包中调用 username.eq 和 passwd.eq 时，拿到的是 username 和 passwd 两个字符串的引用，而不是字符串本身。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但问题是相比之前，这段闭包代码多了一个 move 关键字，这是干啥用的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们仔细想一下，当闭包返回之后，login 函数是不是调用结束了，它的相关参数是不是也就销毁了呢。那么后续调用闭包的时候，再使用 username 和 passwd 就会报错，因为引用的对象已经被销毁了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是 Rust 提供了 move 关键字，会将捕获的外部变量移动到闭包内部，确保闭包在调用的时候能够找得到。如果变量是可 Copy 的，那么移动的时候会拷贝一份；如果不是可 Copy 的，那么移动的时候就转移所有权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.462882096069869&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFA2pKhuicSkiaeUDzLPRKrcPqSokXQ2qpvPGpRY6aotMMuLwM5nu1iaZZ8zQqo124X4sPyU66jcovOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看这个例子，定义闭包的时候使用了 move 关键字，那么它会将外部变量，移动到闭包内部。所以在闭包的下面再使用 name 变量就会报错，因为所有权已经被转移了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于 age 则没有关系，因为它是可 Copy 的，&lt;span&gt;这种变量的数据都完全分配在栈上，不涉及到堆。而栈上数据在传递的时候只会拷贝一份，所以传递之后你的是你的，我的是我的，两者没有关系，自然也就不会出现所有权的转移，因为数据都是各自独立的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;但对于涉及到堆内存的变量来说就不一样了，由于 Rust 默认不会拷贝堆上数据，那么变量在传递之后就会出现两个栈上指针，指向同一份堆内存。于是 Rust 就会转移所有权，只让一个变量拥有操作堆内存的权利。所以 name 在移动之后就不能再用了，因为它已经失去了操作堆内存的权利。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然啦，对于当前这个例子，即使不使用 move 也是可以的，因为这是在 main 函数里面，闭包的存活时间没有超过它所捕获的变量。但之前那个例子不行，之前那个例子的闭包使用了 login 函数的两个参数，而在参数伴随 login 函数调用结束而销毁之后，闭包却依旧存活，因此报错。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Rust 闭包的实现和所有权的实现，在语义上是统一的。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;Fn、FnOnce、FnMut&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Rust 一切皆类型，并由 trait 掌握类型的行为逻辑。至于&lt;/span&gt;闭包类型则需要通过 Fn trait 来指定，但除了 Fn 之外，还有两个 trait，也就是 FnOnce 和 FnMut。那么它们之间有什么区别呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现此 trait 的闭包在使用外部变量的时候，可以夺走所有权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6301564722617354&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFA2pKhuicSkiaeUDzLPRKrcPasqmnqT3HuVmzic10AicEuIS22bSY2vib9hFKuJZftFTxLqicibqFPJqm8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到两个函数的函数体都是一样的，但使用 Fn trait 就有问题，而使用 FnOnce trait 则一切正常。原因就是对于 FnOnce 来说，它可以夺走外部变量的所有权，而 Fn 不能。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;FnOnce&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;古明地觉&quot;&lt;/span&gt;);&lt;br/&gt;    || {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_name = name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 拿到闭包，test 里变量 name 的所有权，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 会转移给闭包内部的 new_name 变量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; closure = test();&lt;br/&gt;    &lt;span&gt;// 调用闭包，结束之后 name 被回收&lt;/span&gt;&lt;br/&gt;    closure();&lt;br/&gt;    &lt;span&gt;// 如果再次调用，那么就会报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// closure()  // 报错，name 已被释放&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以这也是它叫 FnOnce 的原因，就是因为它在剥夺外部变量所有权的时候只能调用一次。但如果没有转移所有权，那么需要使用 move 关键字将变量移动到闭包内部，举个例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;FnOnce&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;我是闭包&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 在闭包中将 name 赋值给了 new_name&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 显然所有权会发生转移，这是很合理的&lt;/span&gt;&lt;br/&gt;    || {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_name = name;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;FnOnce&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;我是闭包&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 由于闭包内部用的都是 name 的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以这时候不会发生所有权的转移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但很明显这种情况是会出问题的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因为后续使用闭包的时候，name 已经被销毁了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以这里要通过 move，手动地将变量转移至闭包内部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;move&lt;/span&gt; || {  &lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_name = &amp;amp;name;  &lt;span&gt;// name 的引用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 这里拿到的也是 name 的引用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, name);&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以实现 FnOnce trait 的闭包，能够转移捕获的外部变量的&lt;span&gt;所有权&lt;/span&gt;。而如果不涉及所有权的转移，也就是通过引用的方式使用了外部变量，那么我们需要通过 move 关键字将变量移动到闭包内部，否则后续使用闭包的时候就会出问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意：我们上面捕获的变量是 String 类型，它没有实现 Copy trait，所以一直反复提到所有权。但如果捕获的变量实现了 Copy trait，那么一定要加 move，将变量移动到闭包内部。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Fn&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;实现此 trait 的闭包在使用外部变量的时候，需要满足一个条件：不可以在闭包内部夺走外部变量的所有权，必须以不可变引用的方式进行操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3494318181818182&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsFA2pKhuicSkiaeUDzLPRKrcPFbLErmoW5G9Pr5aqwPtZjpMU7eHXOUOXwPs5AlEDdDdhPQ2WYbAjsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;IDE 提示的很明显，我们不能在闭包内部转移外部变量的所有权，即便使用 move 关键字将变量移动到了闭包内部。不过对于实现了 Copy trait 的变量来说是可以的，因为我们说这种变量的数据都完全分配在栈上，传递之后数据都是各自独立的，不存在所有权的转移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但对于涉及到堆内存的变量来说就不一样了，由于 Rust 默认不会拷贝堆上数据，于是会转移所有权。但对于实现 Fn trait 的闭包，Rust 不允许转移外部变量的所有权，因此只能以引用的方式操作。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;Fn&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;&quot;satori&quot;&lt;/span&gt;.to_string();&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; age = &lt;span&gt;17&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; c = &lt;span&gt;move&lt;/span&gt; || {&lt;br/&gt;        &lt;span&gt;// 虽然在定义闭包的时候，将name移动到了闭包内部&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 但在使用 name 的时候，仍必须以引用的方式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 否则它的所有权就会转移给 new_name&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 而 Rust 不允许这种情况出现&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_name = &amp;amp;name;&lt;br/&gt;        &lt;span&gt;// age 是可 Copy 的，不涉及所有权的转移&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因此使用 age 和 &amp;amp;age 均可&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_age = age;&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;// age 依然有效，它是可 Copy 的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 在移动的时候会拷贝一份，所以不影响&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, age);&lt;br/&gt;    &lt;span&gt;// 但 name 就不行了，因为它被移动到了闭包内部&lt;/span&gt;&lt;br/&gt;    c&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以 Fn、FnOnce、FnMut 描述的都是闭包将以何种方式去捕获外部变量。对于当前的 Fn 来说，只能以引用的方式去捕获，而不能夺走所有权，即使我们使用 move 关键字将变量移动到了闭包内部。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;FnMut&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它和 Fn 一样都只能获取外部变量的引用，但 Fn 在使用的时候只能拿到不可变引用，而 FnMut 还可以获取可变引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.623718887262079&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ib8ibwulXslsGQJ6hWxUrwiaq3IrHjNzTHV2uVicZTWXibqONGjnibmWsQ8knqn5FabUJdy2MPpt3detf8lhtQPPWLiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;test1 函数是不合法的，实现 Fn trait &lt;span&gt;的闭包不可以获取外部变量的可变引用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;FnMut&lt;/span&gt;() -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; name = &lt;span&gt;&quot;komeiji&quot;&lt;/span&gt;.to_string();&lt;br/&gt;    &lt;span&gt;move&lt;/span&gt; || {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; new_name = &amp;amp;&lt;span&gt;mut&lt;/span&gt; name;&lt;br/&gt;        new_name.push_str(&lt;span&gt;&quot; satori&quot;&lt;/span&gt;);&lt;br/&gt;        name.clone()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 这里闭包也要声明为可变的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; c = test();&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    komeiji satori&lt;br/&gt;    komeiji satori satori&lt;br/&gt;    komeiji satori satori satori&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// name 的所有权自始至终在闭包内部&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 每一次调用都会对其进行修改&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;注意这段代码，里面有几个需要注意的地方。我们在闭包内部创建变量 new_name 的时候，只能将 name 的引用赋值给它，而不能是 name 本身，那样的话所有权就发生转移了。然后要修改字符串，那么 name 必须可变，new_name 也要是可变引用。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们返回了 name.clone()，问题来了，直接返回 name 不行吗？答案是不行，对于 Fn 和 FnMut 来说，Rust 不允许在闭包内部转移外部变量的所有权，纵使这个外部变量被移动到了闭包内部。所以返回 name 是不合法的，因为那样所有权就发生转移了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来写一个计数器的例子，我们先看用 Go 如何去写：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ticker 函数返回了一个闭包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 闭包在调用时会返回一个 uint32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 而闭包返回的 uint32 来自 ticker 里的 start 变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; start &lt;span&gt;uint32&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        start++&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; start&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; tk = ticker()&lt;br/&gt;    fmt.Println(tk()) &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;    fmt.Println(tk()) &lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;    fmt.Println(tk()) &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;还是很简单的，Go 的变量没啥可变不可变，所以读起来就非常简单，然后是 Rust。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;ticker&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; &lt;span&gt;FnMut&lt;/span&gt;() -&amp;gt; &lt;span&gt;u32&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 后续要修改 start，start 必须可变&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; start = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 闭包也要是可变的。然后还要使用 move 关键字&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 将 start 移动到闭包内部，这是必须的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 否则后续使用闭包的时候，会发现 start 已被销毁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; c = &lt;span&gt;move&lt;/span&gt; || {&lt;br/&gt;        start += &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        start&lt;br/&gt;    };&lt;br/&gt;    c&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 想在闭包内修改外部变量，则需要使用 FnMut&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 拿到闭包之后，也要声明为可变的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;mut&lt;/span&gt; c = ticker();&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, c());&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    1&lt;br/&gt;    2&lt;br/&gt;    3&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上我们就用 Rust 实现了一个定时器。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于 Fn、FnOnce、FnMut 我们再做一下总结：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你需要转移外部变量的所有权，使用 FnOnce，并且闭包只能调用一次；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你不需要转移所有权，并且也不需要修改外部变量，那么使用 Fn；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果你不需要转移所有权，但是需要修改外部变量，那么使用 FnMut；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;另外为避免出现悬空引用，记得使用 move 关键字将变量移动到闭包内部。一般来说，如果你将闭包作为了返回值，那么基本上都会使用 move。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来看一看泛型，泛型可以出现在结构体、枚举、函数、方法等结构中，用于增强类型的表达能力，以及减少重复代码。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 结构体使用泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T, W&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;    y: W,&lt;br/&gt;    z: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 枚举使用泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;Cell&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    Foo(T),&lt;br/&gt;    Bar(&lt;span&gt;String&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 函数使用泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(a: T, b: T) {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;用到了哪些泛型，必须提前用尖括号声明好。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// S1 的第一个元素的类型为单元结构体 T&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S1&lt;/span&gt;&lt;/span&gt;(T);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// S2 的第一个元素的类型为泛型 T&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这个 T 可以代表任意类型，至于具体代表哪一种&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 则看在实例化的时候，传递的值是什么&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S2&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(T);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们来实例化测试一下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S1&lt;/span&gt;&lt;/span&gt;(T);&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S2&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;&amp;gt;(T);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s1 = S1(T{});&lt;br/&gt;    &lt;span&gt;// 对单元结构体来说，写成 T 也是可以的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里我们将类型也指定一下&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s1: S1 = S1(T);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 然后是 S2 的实例化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = S2(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = S2(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = S2(&lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// 由于 S2 接收的是泛型 T，所以它可以代表任意类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里的 T 是单元结构体 T&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果没有定义这个单元结构体，那么这里就会报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = S2(T);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 然后是指定类型，在指定类型的同时&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 还要指定泛型所代表的类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2: S2&amp;lt;&lt;span&gt;u8&lt;/span&gt;&amp;gt; = S2(&lt;span&gt;33&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2: S2&amp;lt;&amp;amp;&lt;span&gt;str&lt;/span&gt;&amp;gt; = S2(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2: S2&amp;lt;&lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;f32&lt;/span&gt;&amp;gt;&amp;gt; = S2(&lt;span&gt;vec!&lt;/span&gt;[&lt;span&gt;3.14&lt;/span&gt;, &lt;span&gt;2.71&lt;/span&gt;, &lt;span&gt;1.414&lt;/span&gt;]);&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;因此这便是泛型，它可以代表任意类型，这样极大地增强了数据的表达能力。接下来，&lt;/span&gt;&lt;span&gt;我们将带泛型的结构体放到&lt;/span&gt;&lt;span&gt;函数参数里面。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(T);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 因为结构体 S 带了一个泛型 T，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所以在指定类型的时候，光有一个 S 是不够的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 我们还要将泛型指定好，比如 S&amp;lt;u32&amp;gt;，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 那么就只有当 S 实例的第一个元素为 u32 类型时，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 才能传给这里的 s 参数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;/span&gt;(s: S&amp;lt;&lt;span&gt;u32&lt;/span&gt;&amp;gt;) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;f1 被调用&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 针对的是 S(f64)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;/span&gt;(s: S&amp;lt;&lt;span&gt;f64&lt;/span&gt;&amp;gt;) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;f2 被调用&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    f1(S(&lt;span&gt;123&lt;/span&gt;));  &lt;span&gt;// f1 被调用&lt;/span&gt;&lt;br/&gt;    f2(S(&lt;span&gt;3.14&lt;/span&gt;)); &lt;span&gt;// f2 被调用&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后函数自身也是可以有泛型的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;S&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(T);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 泛型只是一个符号而已，它可以代表任意类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但具体是哪一种，则取决于我们传递的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 另外这里为了区分，刻意写成了 W，但写成 T 仍是可以的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;/span&gt;&amp;lt;W&amp;gt;(s: S&amp;lt;W&amp;gt;) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;函数被调用&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    f(S(&lt;span&gt;123&lt;/span&gt;));&lt;br/&gt;    f(S(&lt;span&gt;3.14&lt;/span&gt;));&lt;br/&gt;    f(S(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    函数被调用&lt;br/&gt;    函数被调用&lt;br/&gt;    函数被调用&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;函数 f 带了一个泛型 W，而参数 s 的类型是 S&amp;lt;W&amp;gt;。这就说明在调用函数的时候，只要传一个结构体 S 的实例即可，而不必管元素是什么类型，因为泛型可以代表任意类型。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上在确定泛型的时候，都是根据值推断出来的，我们也可以显式地告诉 Rust。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(s: T) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;函数被调用&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 调用时 T 会代表 i32&lt;/span&gt;&lt;br/&gt;    test(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 调用时 T 会代表 u8&lt;/span&gt;&lt;br/&gt;    test(&lt;span&gt;123u8&lt;/span&gt;);&lt;br/&gt;    test::&amp;lt;&lt;span&gt;u8&lt;/span&gt;&amp;gt;(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;通过 test::&amp;lt;u8&amp;gt; 则可以告诉编译器，在调用的时候，泛型 T 代表的是 u8 类型。当然啦，此时传递的也必须是一个合法的 u8 类型的值。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;泛型不影响性能，Rust 在编译期间会将泛型 T 替换成具体的类型，这个过程叫做单态化。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;方法中的泛型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;再来看看方法中的泛型。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T, U&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;    y: U&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 针对 i32、f64 实现的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 只有传递的 T、U 对应 i32、f64 才可以调用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Point&amp;lt;&lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;f64&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m1&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 m1 方法&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p1 = Point{x: &lt;span&gt;123&lt;/span&gt;, y: &lt;span&gt;3.14&lt;/span&gt;};&lt;br/&gt;    p1.m1();  &lt;span&gt;// 我是 m1 方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p2 = Point{x: &lt;span&gt;3.14&lt;/span&gt;, y: &lt;span&gt;123&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;//p2.m1();&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//调用失败，因为 T 和 U 不是 i32、f64，而是 f64、i32&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//所以 p2 无法调用 m1 方法&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;可能有人好奇了，声明方法的时候不考虑泛型可不可以，也就是 &lt;/span&gt;&lt;span&gt;impl Point {}&lt;/span&gt;&lt;span&gt;。答案是不可以，如果结构体中有泛型，那么声明方法的时候必须指定。&lt;/span&gt;&lt;span&gt;但这就&lt;/span&gt;&lt;span&gt;产生了一个问题，那就是只有指定类型的结构体才能调用方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如上述代码，只有当 x 和 y 分别为 i32、f64 时，才可以调用方法，如果我希望所有的结构体实例都可以调用呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T, U&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;    y: U&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 针对 K、f64 实现的方法，由于 K 是一个泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所以它可以代表任何类型（泛型只是一个符号）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 因此不管 T 最终是什么类型，i32 也好、&amp;amp;str 也罢&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// K 都可以接收，只要 U 是 f64 即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 然后注意：如果声明方法时结构体后面指定了泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 那么必须将使用的泛型在 impl 后面声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; &amp;lt;K&amp;gt; Point&amp;lt;K, &lt;span&gt;f64&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m1&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 m1 方法&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 此时 K 和 S 都是泛型，那么此时对结构体就没有要求了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 因为不管 T 和 W 代表什么，K 和 S 都能表示，因为它们都是泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; &amp;lt;K, S&amp;gt; Point&amp;lt;K, S&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m2&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 m2 方法&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这里我们没有使用泛型，所以也就无需在 impl 后面声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但很明显，此时结构体实例如果想调用 m3 方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 那么必须满足 T 是 u8，W 是 f64&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Point&amp;lt;&lt;span&gt;u8&lt;/span&gt;, &lt;span&gt;f64&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m3&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 m3 方法&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 显然 p1 可以同时调用 m1 和 m2 方法，但 m3 不行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因为 m3 要求 T 是一个 u8，而当前是 &amp;amp;str&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p1 = Point{x: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;, y: &lt;span&gt;3.14&lt;/span&gt;};&lt;br/&gt;    p1.m1();  &lt;span&gt;// 我是 m1 方法&lt;/span&gt;&lt;br/&gt;    p1.m2();  &lt;span&gt;// 我是 m2 方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 显然 p2 可以同时调用 m1、m2、m3&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 另外这里的 x 可以直接写成 123，无需在结尾加上 u8&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因为 Rust 看到我们调用了 m3 方法，会自动推断为 u8&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p2 = Point{x: &lt;span&gt;123u8&lt;/span&gt;, y: &lt;span&gt;3.14&lt;/span&gt;};&lt;br/&gt;    p2.m1();  &lt;span&gt;// 我是 m1 方法&lt;/span&gt;&lt;br/&gt;    p2.m2();  &lt;span&gt;// 我是 m2 方法&lt;/span&gt;&lt;br/&gt;    p2.m3();  &lt;span&gt;// 我是 m3 方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 显然 p3 只能调用 m2 方法，因为 m2 对 T 和 W 没有要求&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但是像 m3 就不能调用，因为它是为 &amp;lt;u8, f64&amp;gt; 实现的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只有当 T、W 为 u8、f64 时才可以调用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 显然此时是不满足的，因为都是 &amp;amp;str，至于 m1 方法也是同理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以 p3 只能调用 m2，这个方法是为 &amp;lt;K, S&amp;gt; 实现的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 而 K 和 S 也是泛型，可以代表任意类型，因此没问题&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p3 = Point{x: &lt;span&gt;&quot;3.14&quot;&lt;/span&gt;, y: &lt;span&gt;&quot;123&quot;&lt;/span&gt;};&lt;br/&gt;    p3.m2();  &lt;span&gt;// 我是 m2 方法&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;然后注意：我们上面的泛型本质上针对的还是结构体，而我们定义方法的时候也可以指定泛型，其语法和在函数中定义泛型是一样的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T, U&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;    y: U,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用 impl 时 Point 后面的泛型名称可以任意&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 比如我们之前起名为 K 和 S，但这样容易乱，因为字母太多了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 所以建议：使用 impl 时的泛型和定义结构体时的泛型保持一致即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt;&amp;lt;T, U&amp;gt; Point&amp;lt;T, U&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 方法类似于函数，它是一个独立的个体，可以有自己独立的泛型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 然后返回值，因为 Point 里面是泛型，可以代表任意类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 那么自然也可以是其它的泛型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m1&lt;/span&gt;&lt;/span&gt;&amp;lt;V, W&amp;gt;(&lt;span&gt;self&lt;/span&gt;, a: V, b: W) -&amp;gt; Point&amp;lt;U, W&amp;gt; {&lt;br/&gt;        &lt;span&gt;// 所以返回值的成员 x 的类型是 U，那么它应该来自于 self.y&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 成员 y 的类型是 W，它来自于参数 b&lt;/span&gt;&lt;br/&gt;        Point { x: &lt;span&gt;self&lt;/span&gt;.y, y: b }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// T 是 i32，U 是 f64&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p1 = Point { x: &lt;span&gt;123&lt;/span&gt;, y: &lt;span&gt;3.14&lt;/span&gt; };&lt;br/&gt;    &lt;span&gt;// V 是 &amp;amp;str，W 是 (i32, i32, i32)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, p1.m1(&lt;span&gt;&quot;xx&quot;&lt;/span&gt;, (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)))&lt;br/&gt;    &lt;span&gt;// Point { x: 3.14, y: (1, 2, 3) }&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上就是 Rust 的泛型，当然在工作中我们不会声明的这么复杂，这里只是为了更好地掌握泛型的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后注意一下方法里面的 self，不是说方法的第一个参数应该是引用吗？理论上是这样的，但此处不行，而且如果写成 &amp;amp;self 是会报错的，会告诉我们没有实现 Copy 这个 trait。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之所以会有这个现象，是因为我们在返回值当中将 self.y 赋值给了成员 x。那么问题来了，如果方法的第一个参数是引用，就意味着结构体在调用完方法之后还能继续用，那么结构体内部所有成员的值都必须有效，否则结构体就没法用了。这和动态数组相似，如果动态数组是有效的，那么内部的所有元素必须都是有效的，否则就可能访问非法的内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此在构建返回值、将 self.y 赋值给成员 x 的时候，就必须将 self.y 拷贝一份，并且还要满足拷贝完之后数据是各自独立的，互不影响。如果 self.y 的数据全部在栈上（可 Copy 的），那么这是没问题的；如果涉及到堆，那么只能转移 self.y 的所有权，因为 Rust 默认不会拷贝堆数据，但如果转移所有权，那么方法调用完之后结构体就不能用了，这与我们将第一个参数声明为引用的目的相矛盾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 Rust 要求 self.y 必须是可 Copy 的，也就是数据必须都在栈上，这样才能满足在不拷贝堆数据的前提下，让 self.y 赋值之后依旧保持有效。但问题是 self.y 的类型是 U，而 U 代表啥类型 Rust 又不知道，所以 Rust 认为 U 不是可 Copy 的，或者说没有实现 Copy 这个 trait，于是报错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此第一个参数必须声明为 self，&lt;/span&gt;&lt;span&gt;此时泛型是否实现 Copy 就不重要了，没实现的话会直接转移所有权。因为该&lt;span&gt;结构体实例在调用完方法之后会被销毁，不再被使用，那么此时可以转移内部成员的所有权&lt;/span&gt;。正所谓人都没了，还要这所有权有啥用，不如在销毁之前将成员值的所有权交给别人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;使用泛型和使用具体类型的速度是一样的，因此这就要求 Rust 在编译的时候能够推断出泛型的具体类型，所以类型要明确。&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;枚举中的泛型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;枚举也是支持泛型的，比如之前使用的 Option&amp;lt;T&amp;gt; 就是一种泛型，它的结构如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;Option&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    &lt;span&gt;Some&lt;/span&gt;(T),&lt;br/&gt;    &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;里面&lt;/span&gt;&lt;span&gt;的 T 可以代表任意类型，然后我们再来自定义一个枚举。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 签名中的泛型参数必须都要使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 比如函数签名的泛型，要全部体现在参数中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 枚举和结构体签名的泛型，要全部体现在成员中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;MyOption&lt;/span&gt;&lt;/span&gt;&amp;lt;A, B, C&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 这里 A、B、C 都是我们随便定义的，可以代指任意类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 具体是哪种类型，则看我们传递了什么&lt;/span&gt;&lt;br/&gt;    Some1(A),&lt;br/&gt;    Some2(B),&lt;br/&gt;    Some3(C),&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 泛型不影响效率，是因为 Rust 要进行单态化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 所以泛型究竟代表哪一种类型要提前确定好&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里必须要显式指定 x 的类型。枚举和结构体不同&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 结构体每个成员都要赋值，所以 Rust 能够基于赋的值推断出所有的泛型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但枚举的话，每次只会用到里面的一个成员&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果还有其它泛型，那么 Rust 就无法推断了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 比如这里只能推断出泛型 C 代表的类型，而 A 和 B 就无法推断了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因此每个泛型代表什么类型，需要我们手动指定好&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x: MyOption&amp;lt;&lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;f64&lt;/span&gt;, &lt;span&gt;u8&lt;/span&gt;&amp;gt; = MyOption::Some3(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;match&lt;/span&gt; x {&lt;br/&gt;        MyOption::Some1(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 i32&quot;&lt;/span&gt;),&lt;br/&gt;        MyOption::Some2(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 f64&quot;&lt;/span&gt;),&lt;br/&gt;        MyOption::Some3(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 u8&quot;&lt;/span&gt;),&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 泛型可以代表任意类型，指定啥都是可以的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; y: MyOption&amp;lt;&lt;span&gt;u8&lt;/span&gt;, &lt;span&gt;i32&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; =&lt;br/&gt;        MyOption::Some3(&lt;span&gt;String&lt;span&gt;::from(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;xxx&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;match&lt;/span&gt; y {&lt;br/&gt;        MyOption::Some1(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 u8&quot;&lt;/span&gt;),&lt;br/&gt;        MyOption::Some2(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 i32&quot;&lt;/span&gt;),&lt;br/&gt;        MyOption::Some3(v) =&amp;gt; &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;我是 String&quot;&lt;/span&gt;),&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    我是 u8&lt;br/&gt;    我是 String&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果觉&lt;/span&gt;&lt;span&gt;得上面的例子不好理解的话，那么再举个简单的例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;enum&lt;/span&gt; &lt;span&gt;MyOption&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    MySome1(T),&lt;br/&gt;    MySome2(&lt;span&gt;i32&lt;/span&gt;),&lt;br/&gt;    MySome3(T),&lt;br/&gt;    MyNone&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 这里我们没有指定 x 的类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这是因为 MyOption 只有一个泛型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 通过给 MySome1 传递的值，可以推断出 T 的类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x = MyOption::MySome1(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 同样的道理，Rust 可以自动推断，得出 T 是 &amp;amp;str&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x = MyOption::MySome3(&lt;span&gt;&quot;123&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 但此处就无法自动推断了，因为赋值的是 MySome2 成员&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 此时 Rust 获取不到任何有关 T 的信息，无法执行推断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 因此我们需要手动指定类型，但仔细观察一下声明&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 首先，如果没有泛型的话，那么直接 let x: MyOption = ... 即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但里面有泛型，所以此时除了类型之外，还要连同泛型一起指定&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 也就是 MyOption&amp;lt;f64&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x: MyOption&amp;lt;&lt;span&gt;f64&lt;/span&gt;&amp;gt; = MyOption::MySome2(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 当然泛型可以代表任意类型，此时的 T 则是一个 Vec&amp;lt;i32&amp;gt; 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x: MyOption&amp;lt;&lt;span&gt;Vec&lt;/span&gt;&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt;&amp;gt; = MyOption::MySome2(&lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以一定要注意：在声明变量的时候，如果 Rust 不能根据我们赋的值推断出泛型代表的类型，那么我们必须要手动声明类型，来告诉 Rust 泛型的相关信息，这样才可以执行单态化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust 一切皆类型&lt;/span&gt;&lt;span&gt;，并由 trait 掌握类型的行为逻辑，我们看个例子。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt;&amp;lt;T&amp;gt; Point&amp;lt;T&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; var = &lt;span&gt;self&lt;/span&gt;.x;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p = Point { x: &lt;span&gt;123&lt;/span&gt; };&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你觉得这段代码有问题吗？不用想，肯定是有问题的。因为方法 m 的第一个参数是引用，这就意味着方法调用完毕之后，结构体实例依旧保持有效，也意味着实例的所有成员值都保持有效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但在方法 m 里面，我们将成员 x 的值赋给了变量 var。如果成员 x 的类型不是可 Copy 的，也就是数据不全在栈上，还涉及到堆，那么就会转移所有权，因为 Rust 默认不会拷贝堆数据。&lt;/span&gt;&lt;span&gt;所以调用完方法 m 之后，成员&lt;/span&gt;&lt;span&gt; x &lt;/span&gt;&lt;span&gt;的值不再有效，进而使得结构体不再有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以 Rust 为了避免这一点，在赋值的时候强制要求 self.x 的类型必须是可 Copy 的，但泛型 T 可以代表任意类型，它不满足这一特性。或者说 T 最终代表的类型是不是可 Copy 的，Rust 是不知道的，所以 Rust 干脆认为它不是可 Copy 的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题来了，虽然 T 可以代表任意类型，但如果我们赋的值决定了 T 代表的类型一定是可 Copy 的，那么可不可以告诉 Rust，让编译器按照可 Copy 的类型来处理呢？答案是可以的，而实现这一功能的机制就叫做 trait。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;给泛型施加约束&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;trait 类似于 Go 里面的接口，相当于告诉编译器，某种类型具有哪些可以与其它类型共享的功能。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 这里便给泛型 T 施加了一个 Copy 的约束&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 此时的 T 代表的是实现了 Copy trait 的任意类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt;&amp;lt;T: &lt;span&gt;Copy&lt;/span&gt;&amp;gt; Point&amp;lt;T&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;m&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; var = &lt;span&gt;self&lt;/span&gt;.x;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; p = Point { x: &lt;span&gt;123&lt;/span&gt; };&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;此时这段代码就没问题了，因为 T 是可 Copy 的。并且当调用 p.m 的时候，编译器会检查成员 x 的值是不是可 Copy 的，如果不是，则不允许调用 p.m 方法。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是在定义方法时，在 impl 块里面指定了 trait，但结构体里面的泛型也是可以指定 trait 的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;use&lt;/span&gt; std::fmt::Display;&lt;br/&gt;&lt;span&gt;use&lt;/span&gt; std::fmt::&lt;span&gt;Debug&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 成员 x 的类型要实现 Display&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 成员 y 的类型要实现 Debug&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Point&lt;/span&gt;&lt;/span&gt;&amp;lt;T: Display, W: &lt;span&gt;Debug&lt;/span&gt;&amp;gt; {&lt;br/&gt;    x: T,&lt;br/&gt;    y: W&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// Display 要求变量能够以 &quot;{}&quot; 的方式打印&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Debug 要求变量能够以 &quot;{:?}&quot; 的方式打印&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s1 = Point{x: &lt;span&gt;123&lt;/span&gt;, y: &lt;span&gt;345&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = Point{x: &lt;span&gt;123&lt;/span&gt;, y: (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)};&lt;br/&gt;    &lt;span&gt;// 下面的 s3 不合法，因为元组没有实现 Display&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// let s3 = Point{x: (1, 2, 3), y: 123};&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;所以这就是 trait，它描述了类型的行为。如果我们希望某个类型的变量不受限制，但必须满足某个特性，那么便可以给泛型施加一些制约。比如定义一个函数，接收两个相同类型的变量，变量具体是什么类型不重要，只要能够比较大小即可。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;compare&lt;/span&gt;&lt;/span&gt;&amp;lt;T: &lt;span&gt;PartialOrd&lt;/span&gt;&amp;gt;(a: T, b: T) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; a &amp;gt; b {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;大于&quot;&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; a &amp;lt; b {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;小于&quot;&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;等于&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, compare(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, compare(&lt;span&gt;3.14&lt;/span&gt;, &lt;span&gt;2.71&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, compare(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, compare(&lt;span&gt;&quot;你好&quot;&lt;/span&gt;, &lt;span&gt;&quot;你好&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;    小于&lt;br/&gt;    大于&lt;br/&gt;    小于&lt;br/&gt;    等于&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果 compare 里面的 T 不使用 trait，那么它可以代表任意类型，显然会报错，因为不是所有类型的变量都能够比较。于是便可以使用 trait 给 T 施加一些约束，PartialOrd 表示 T 代表的类型必须能够比较。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果在调用 compare 时，传递的值不能比较，那么编译器就能够检查出来，从而报错。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;自定义 trait&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;标准库内置了很多 trait，但我们也可以自定义 trait。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// trait 类似 Go 里面的接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 然后里面可以定义一系列的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这里我们创建了一个名为 Summary 的 trait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 并在内部定义了一个 summary 方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;Summary&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// trait 里面的方法只需要写声明即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;summary&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Go 里面只要实现了接口里的所有方法，便实现了该接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但是在 Rust 里面必须显式地指明实现了哪一个 trait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// impl Summary for Girl 表示为类型 Girl 实现 Summary 这个 trait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Summary &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;summary&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// format! 宏用于拼接字符串，它的语法和 println! 一样&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 并且这两个宏都不会获取参数的所有权&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 比如这里的 self.name，format! 拿到的只是引用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;name: {}, age: {}&quot;&lt;/span&gt;, &lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = Girl{name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;), age: &lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, g.summary());  &lt;span&gt;// name: satori, age: 16&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;所以&lt;/span&gt;&lt;span&gt; trait 里面的方法只需要写上声明即可，&lt;/span&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;交给&lt;/span&gt;&lt;span&gt;具体的结构体来做。&lt;/span&gt;&lt;span&gt;当然啦，&lt;/span&gt;&lt;span&gt;trait 里面的方法&lt;/span&gt;&lt;span&gt;也是可以有默认实现的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;Summary&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 我们给方法指定了具体实现&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;summary&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Summary &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;// 如果要为类型实现 trait，那么要实现 trait 里面所有的方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这一点和 Go 的接口是相似的，但 Go 里面实现接口是隐式的&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只要你实现了某个接口所有的方法，那么默认就实现了该接口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但在 Rust 里面，必须要显式地指定实现了哪个 trait&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 同时还要实现该 trait 里的所有方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 但 Rust 的 trait 有一点特殊，Go 接口里面的方法只能是定义&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 而 trait 里面除了定义之外，也可以有具体的实现&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果 trait 内部已经实现了，那么这里就可以不用实现&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 不实现的话则用 trait 的默认实现，实现了则调用我们实现的&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 因此这里不需要定义任何的方法，它依旧实现了 Summary 这个 trait&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 只是我们仍然要通过 impl Summary for Girl 显式地告诉 Rust&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果只写 impl Girl，那么 Rust 则不认为我们实现了该 trait&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = Girl{name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;), age: &lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;    &lt;span&gt;// 虽然没有 summary 方法，但因为实现了 Summary 这个 trait&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 而 trait 内部有 summary 的具体实现，所以不会报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但如果 trait 里面的方法只有声明没有实现，那么就必须要我们手动实现了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, g.summary());  &lt;span&gt;// hello&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;总结一下就是 trait 里面可以有很多的方法，这个方法可以只有声明，也可以同时包含实现。如果要为类型实现某个 trait，那么要通过&lt;/span&gt;&lt;span&gt; impl xxx for &lt;/span&gt;&lt;span&gt;进行指定，并且实现该 trait 内部定义的所有方法。但如果 trait 的某个方法已经包含了具体实现，那么我们也可以不实现，会使用 trait 的默认实现。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;trait 作为参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;假设有一个函数，只要是实现了 info 方法，都可以作为参数传递进去，这时候应该怎么做呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Boy&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;    salary: &lt;span&gt;u32&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;People&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 为 Girl 和 Boy 实现 People 这个 trait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; People &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;{} {}&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; People &lt;span&gt;for&lt;/span&gt; Boy {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;{} {} {}&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age, &lt;span&gt;self&lt;/span&gt;.salary)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 定义一个函数，注意参数 p 的类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果是 p: xxx，则表示参数 p 的类型为 xxx&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果是 p: impl xxx，则表示参数 p 的类型任意，只要实现了xxx这个trait即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;impl&lt;/span&gt; People) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;    p.info()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = Girl {&lt;br/&gt;        name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;),&lt;br/&gt;        age: &lt;span&gt;16&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; b = Boy {&lt;br/&gt;        name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;可怜的我&quot;&lt;/span&gt;),&lt;br/&gt;        age: &lt;span&gt;26&lt;/span&gt;,&lt;br/&gt;        salary: &lt;span&gt;3000&lt;/span&gt;,&lt;br/&gt;    };&lt;br/&gt;    &lt;span&gt;// 只要实现了 People 这个 trait&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 那么实例都可以作为参数传递给 get_info&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, get_info(g)); &lt;span&gt;// satori 16&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, get_info(b)); &lt;span&gt;// 可怜的我 26 3000&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后以 trait 作为参数的时候，还有另外一种写法，我们之前一直在用：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 如果是 &amp;lt;T&amp;gt; 的话，那么 T 表示泛型，可以代表任意类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但这里是 &amp;lt;T: People&amp;gt;，那么就不能表示任意类型了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 它表示的应该是实现了 People 这个 trait 的任意类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;&amp;lt;T: People&amp;gt;(p: T) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;    p.info()&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上两种写法是等价的，但是第二种写法在参数比较多的时候，可以简化长度。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;&amp;lt;T: People&amp;gt;(p1: T, p2: T) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 否则话要这么写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;(p1: &lt;span&gt;impl&lt;/span&gt; People, p2: &lt;span&gt;impl&lt;/span&gt; People) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当然啦，一个类型并不仅仅可以实现一个 trait，而是可以实现任意多个 trait。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;    gender: &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;People&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;Female&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 不同的 trait 内部可以有相同的方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; People &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;{} {}&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; Female &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;{} {} {}&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age, &lt;span&gt;self&lt;/span&gt;.gender)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 这里在 impl People 前面加上了一个 &amp;amp;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 表示调用的时候传递的是引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info1&lt;/span&gt;&lt;/span&gt;(p: &amp;amp;&lt;span&gt;impl&lt;/span&gt; People) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, p.info())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info2&lt;/span&gt;&lt;/span&gt;&amp;lt;T: Female&amp;gt;(f: &amp;amp;T) {&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, f.info())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = Girl {&lt;br/&gt;        name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;),&lt;br/&gt;        age: &lt;span&gt;16&lt;/span&gt;,&lt;br/&gt;        gender: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;female&quot;&lt;/span&gt;)&lt;br/&gt;    };&lt;br/&gt;    get_info1(&amp;amp;g);  &lt;span&gt;// satori 16&lt;/span&gt;&lt;br/&gt;    get_info2(&amp;amp;g);  &lt;span&gt;// satori 16 female&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;不同 trait 内部的方法可以相同也可以不同，而 &lt;span&gt;Girl &lt;/span&gt;&lt;span&gt;同时实现了&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;eople 和 &lt;/span&gt;&lt;span&gt;Female 两个 trait，&lt;/span&gt;所以它可以传递给 get_info1，也可以传递给 get_info2。然后为 trait 实现了哪个方法，就调用哪个方法，所以两者的打印结果不一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么问题来了，如果我在定义函数的时候，要求某个参数同时实现以上两个 trait，该怎么做呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 我们只需要使用 + 即可&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 表示参数 p 的类型必须同时实现 People 和 Female 两个 trait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info1&lt;/span&gt;&lt;/span&gt;(p: &lt;span&gt;impl&lt;/span&gt; People + Female) {&lt;br/&gt;    &lt;span&gt;// 但由于 Poeple 和 Female 里面都有 info 方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 此时就不能使用 p.info() 了，这样 Rust 不知道该使用哪一个&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应该采用下面这种做法，此时需要手动将引用传过去&lt;/span&gt;&lt;br/&gt;    People::info(&amp;amp;p);&lt;br/&gt;    Female::info(&amp;amp;p);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果想接收引用的话，那么需要这么声明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 因为优先级的原因，需要将 impl People + Female 整体括起来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info2&lt;/span&gt;&lt;/span&gt;(p: &amp;amp;(&lt;span&gt;impl&lt;/span&gt; People + Female)) {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 或者使用泛型的写法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info3&lt;/span&gt;&lt;/span&gt;&amp;lt;T: People + Female&amp;gt;(p: T) {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;最后还有一个更加优雅的写法，在介绍闭包的时候用过：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 显然这种声明方式要更加优雅，如果没有 where 的话&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 那么这个 T 就是可以代表任意类型的泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但这里出现了 where&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 因此 T 就表示实现了 People 和 Female 两个 trait 的任意类型 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;&amp;lt;T&amp;gt;(p: T)&lt;br/&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;    T: People + Female&lt;br/&gt;{&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果要声明多个实现 trait 的泛型，那么使用逗号分隔。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_info&lt;/span&gt;&lt;/span&gt;&amp;lt;T, W&amp;gt;(p1: T, p2: W)&lt;br/&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt;    T: People + Female,&lt;br/&gt;    W: People + Female&lt;br/&gt;{&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;可以看出，Rust 的语法表达能力还是挺丰富的。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uuH2txxMvopuUUlCMEicOKPcPNQMQT9D5VfPIc3HJHpG35f2TOFcoaibsRXVAR8HZwnalFS0UrqiaWekgZndpWGrw/640?wx_fmt=png&quot; data-w=&quot;92&quot;/&gt; &lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;trait 作为返回值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/we88pydxh2KLkfvcv9xj7yItZZIluo6gGk90j9bOIE0LknQkfzXDiatxPjXRrfLOjczKQ3ZOCyUibmkdm376u8bQ/640?wx_fmt=png&quot; data-w=&quot;48&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;trait 也是可以作为返回值的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;,&lt;br/&gt;    gender: &lt;span&gt;String&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;People&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; People &lt;span&gt;for&lt;/span&gt; Girl {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;info&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;format!&lt;/span&gt;(&lt;span&gt;&quot;{} {}&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;self&lt;/span&gt;.name, &lt;span&gt;self&lt;/span&gt;.age)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;/span&gt;() -&amp;gt; &lt;span&gt;impl&lt;/span&gt; People {&lt;br/&gt;    Girl {&lt;br/&gt;        name: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;),&lt;br/&gt;        age: &lt;span&gt;16&lt;/span&gt;,&lt;br/&gt;        gender: &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;female&quot;&lt;/span&gt;),&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = init();&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, g.info());  &lt;span&gt;// satori 16&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;注意代码中的变量 g，它具体是什么类型 Rust 其实是不知道的。init 返回的不是一个具体的类型，因为&lt;span&gt;一个 trait 可以有很多种类型实现，返回任意一个都是可以的。这个时候我们应该显式地指定变量 g 的类型，即 &lt;/span&gt;&lt;/span&gt;&lt;span&gt;let g: Girl = init()&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后 trait 也是可以带泛型的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt;&lt;/span&gt;(&lt;span&gt;i32&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;trait&lt;/span&gt; &lt;span&gt;SomeTrait&lt;/span&gt;&lt;/span&gt;&amp;lt;T: &lt;span&gt;PartialOrd&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;compare&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;, n: T) -&amp;gt; &lt;span&gt;bool&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 为 Number 实现 T 为 i32 的 SomeTrait&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; SomeTrait&amp;lt;&lt;span&gt;i32&lt;/span&gt;&amp;gt; &lt;span&gt;for&lt;/span&gt; Number {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;compare&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;, n: &lt;span&gt;i32&lt;/span&gt;) -&amp;gt; &lt;span&gt;bool&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; &amp;gt;= n&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; num = Number(&lt;span&gt;66&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, num.compare(&lt;span&gt;67&lt;/span&gt;));  &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, num.compare(&lt;span&gt;65&lt;/span&gt;));  &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;以上就是 trait 相关的内容，如果一个 trait 里面没有定义任何方法，那么相当于不起任何约束作用，也就是空约束。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇文章我们复习了函数、闭包、泛型和 trait，内容还是蛮多的，建议私底下也可以多动手敲一敲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，Rust 的学习门槛确实不是一般的高，但努力总有收获。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a11e38f0c722c5cf5047bb7820690467</guid>
<title>数据湖架构落地实战</title>
<link>https://toutiao.io/k/79hj8q6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMDA4OTY3MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXdtvHKjv7OHYYSTQ2QOVuyAia3LaU56kibxKLlX5Lo9bgeUfz1R4JDmdW7ZGYSLqsiaBl3nTOwOmFOFQ/0?wx_fmt=png&quot; data-nickname=&quot;浪尖聊大数据&quot; data-alias=&quot;bigdatatip&quot; data-signature=&quot;主要分享大数据框架，如spark，flink，kafka，hbase原理源码，同时会分享数据仓库，图计算等浪尖擅长领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;与传统的数据架构要求整合、面向主题、固定分层等特点不同，数据湖为企业全员独立参与数据运营和应用创新提供了极大的灵活性，并可优先确保数据的低时延、高质量和高可用，给运营商数据架构优化提供了很好的参考思路。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;运营商数据架构的现状及挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从数据的系统归属上看，运营商数据可分为MSS（管理支撑系统）的面向人、财、物管理类数据，BSS（业务支撑系统）的面向客户和产品的营销及客户服务数据，OSS（运营支撑系统）的面向产品和网络的功能及运营服务数据，三者之间既相对松耦合，又有着紧密的协作关系，BSS和OSS的衔接点主要在产品及开通、排障服务，MSS和BSS、OSS的衔接点主要在参与人和资源。从数据分类来看，运营商的数据可分为作为企业核心的功能类实体数据、表示企业所有运营过程的活动类数据、体现内外部客户感知并围绕两大主线所产生的感知类指标数据以及与管理相关的人、财、物及流程数据。电信运营商数据范围示例如图1所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4563265306122449&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibkmusWhLoazAY28RlCjJqsYuMWibgicQ4rO0k5TENVXasTcZlcgYmQnQg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1225&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;由于国内运营商以两级经营模式为主体，系统的集约化建设程度相对较低，以分域（M/B/O）、分省建设为主，即便是同类系统的数据，因为分31个省市建设，各省市的业务管理模式、数据模型标准、主数据等千差万别，跨省、跨域、跨系统的模型标准统一非常困难，即便通过数据副本的模式进行整合汇聚，也存在转换不专业和数据失真等问题。同时，域与域之间虽是松耦合的，但因为使用者和建设者的不同，相互之间会冗余存储对方数据，而建模和主数据又不同，跨域之间数据的关联整合非常复杂，跨域、跨省的端到端应用困难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;运营商的数据还有一个显著的特点，就是与网络密切相关，网络运行数据和网络拓扑数据需要与网络保持实时一致，且数据量比较大，网络智能化后的实时数据应用需求也越来越多。通信网络是一张大网，即便引入云计算、虚拟化技术，依然有大量网络节点遍布31个省市，海量网络数据的实时采集、处理及应用也是运营商数据架构需要考虑的一个重要因素。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;国内运营商目前都不同程度地建立了自己的企业级大数据平台，有的分总部/省两级部署，支撑两级数据分析，统一全网的架构、来源、算法、规则，总部数据轻度汇总，按需采集汇聚高价值详单数据；有的采用1+N模式，建设总部和省互补协作平台，总部提供跨域数据和特定的大数据能力，作为N的省向总部提供本地化数据能力与自定义算法。电信运营商数据平台架构示例如图2所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5306704707560628&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibdI0gzt9Bq2ZMTjAVJOabiadlj2FIMctgoibkfPUGAkcMZREQCGE8pia1g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1402&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;不管采用哪种模式，都不同程度地存在其下属各专业公司、各部门根据各自需要，或在生产系统内构建含大数据技术的混搭数据架构，或建设域内自用的大数据平台，因此有很多数据未进入企业级大数据平台，或数据平台的应用未达到预期。其原因可归结为如下几点&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台数据质量不高&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;平台数据来自于M/B/O的生产系统，而运营商分两级31省市建设的生产系统，不但数据模型、主数据标准不统一，业务管理模式的差异也很大。数据经过多次模型转换，存在严重失真的问题，且很难对数据质量问题追踪溯源。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;平台数据不够实时&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据经过多级采集汇聚，处理环节多，采集周期长。网络相关海量数据跨省传输，占用大量带宽，数据时延较大。数据平台目前只能以支撑离线的决策分析为主，难以满足SDN/NFV/云网络及物联网等实时/准实时数据应用需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台的灵活性不足&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据平台的建设以存储计算一体化架构为主，平台与应用紧耦合，多基于公共数据平台和整合后的数据支撑应用创新。对于新的数据整合、数据计算分析技术引入、平台扩容支撑等需求响应不灵活，导致数据平台应用不足。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;平台和应用互锁，形成恶性循环&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;企业级数据平台难以满足生产系统数据应用需求，生产系统就没有动力将自身数据和应用迁入数据平台，进而数据平台的数据质量和可用性越来越差。同时，还导致生产系统和各个大数据平台的数据重复采集、重复存储，且相互之间数据访问技术和管理壁垒严重，建设和维护成本大幅提高。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据湖方案的价值及可行性分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖推崇存储原生数据，对不同结构的数据统一存储，使不同数据有一致的存储方式，在使用时方便连接，真正解决数据集成问题。数据湖的本质是一种数据管理的思路，利用低成本技术来捕捉、提炼和探索大规模、长期的原始数据存储的方法与技术。数据湖可存储任何种类的数据，高质量、高效率地存储数据，更快速、更廉价地处理数据，将建模应用问题丢给最终开发者[9]。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖的方案应用可以带来如下几个显著的好处&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;规模大、成本低&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;全企业海量数据统一存储，采用开源技术，基于低成本硬件资源，建立和维护成本相比数据仓库低一个数量级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据“原汁原味”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖以原始形式保存数据，并在整个数据生命周期捕获对数据和上下文语义的更改，尤其便于进行合规性和内部审计。如果数据经历了转换、聚合和更新，将很难在需求出现时将数据拼凑在一起，而且几乎没有希望确定清晰出处。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据方便易用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结构化、非结构化、半结构化的数据都是原样加载和存储，以后再进行转换，开发和保存成本低，产生和使用之间时延小。客户、供应商和数据运营者不需要数据拥有者提供太多帮助即可整合数据，消除了数据共享的内部政治或技术障碍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;应用按需建模&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖提供数据给灵活的、面向任务的结构化应用，详细的业务需求和艰苦的数据建模都不是数据湖的先决条件。数据湖给予最终用户最大的灵活度来处理数据，对于同一份原始数据，不同的用户可能有不同的理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前，大部分运营商采用传统的以数据为中心的处理架构（存储计算一体化，如主流MPP、Hive和分布式计算厂商产品），好处是计算效率高、技术成熟，缺点也很明显，如灵活性不足，使得数据应用适用于少数人，这也制约了原生数据提供者向平台提供的积极性，进而导致数据的质量、数据的全面性都得不到很好的保障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引入数据湖概念的一个显著特点就是存储和计算松耦合，可采用以计算为中心的处理模式（存储与计算分离，如Spark技术及AWS、阿里云等云服务提供商产品），使得运营商可以更加专注于数据的存储和管理，存储和计算不用相互制约，从而优先确保数据的高质量、低时延、高可用，并为数据应用的快速构建提供了极大的灵活性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖按照成熟度可划分为4个阶段：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一个阶段，应用程序独立建设，部分应用将数据提供给数据仓库，基于数据仓库构建分析应用；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二个阶段，数据湖和数据仓库并存，应用程序向数据湖提供副本数据，基于数据湖开发分析型应用，数据仓库和应用也可从数据湖提取数据；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三个阶段，新系统以数据湖为中心构建，应用通过数据湖交互彼此数据，数据湖成为数据架构的核心，数据仓库基于数据湖提供特定的应用需求，数据治理变得重要；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第四个阶段，所有新的应用均基于数据湖构建，数据湖成为弹性的分布式平台，数据的治理和安全需持续加强，支撑企业的数据运营和分析能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;电信运营商目前普遍处于第二个阶段向第三个阶段演进的过程中，在构建数据技术方案方面具备较好的基础条件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电信运营商数据湖建设思路及实施要点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调整现有分析型数据平台建设思路，将其数据与应用解耦，引入数据湖概念，强调原生数据入湖，并与全网生产系统模型和主数据标准化协同推进，兼顾层次化的传统数据架构和扁平化的数据湖架构的优点，SchemaonRead和SchemaonWrite并存，统一支撑企业实时、准实时和离线数据应用快速创新，是电信运营商实现以数据为中心IT架构转型的有效途径。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖作为运营商数据存储和访问的唯一出口，成为所有IT系统共享的基础设施，统一存储全企业IT和网络数据，通过开放架构支撑智慧运营，并可作为IT系统集约化演进的纽带。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据统一存储&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;统一存储MSS、BSS、OSS及网元平台的实时、历史、在线、离线数据，全网的原生数据只存储一份在逻辑统一的分布式数据湖内，原生数据与生产系统数据模型标准和主数据一致，新IT系统/网元平台的生产数据直接使用数据湖存储。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据统一管理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所有入湖数据的目录、元数据、数据应用及数据质量、数据标准、数据安全必须统一管理。数据模型标准和主数据动态维护，数据质量集中治理，原生系统的数据问题溯源处理，生产系统建设者全程参与数据管理，责任权利保持一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据统一标准&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;生产系统管理部门负责31省市系统模型和主数据的标准化；数据湖统一管理生产系统的数据模型及主数据；暂未进行标准化的生产系统数据模型，由对应系统的管理部门负责数据模型的转换和运营，协调推进生产系统数据标准进程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据近源采集&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提供数据统一采集、实时订阅分发框架，支撑实时/准实时数据、离线数据的采集。各网元/平台数据采集能力以组件方式纳入数据湖，分专业采集、预处理加工，海量实时数可靠近网络近源部署前置采集模块。非网络类数据（如BSS、MSS、OSS流程等），初期以副本采集方式汇聚入湖，远期直接以服务交互方式入湖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据与应用分离&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据应用环境与数据存储环境分离，按应用计算的网络带宽需要就近部署。提供统一的服务化访问、小批量数据订阅、数据分析计算云平台环境。基于云平台环境，应用开发者可自行整合数据、构建应用，数据存储、数据整合、平台组件、数据应用间相互解耦，建设的进程不会相互制约。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，建立全生命周期数据目录，统一标识各项数据，完善数据治理机制，管理数据湖数据的生产加工流程，对各项数据生成和使用过程进行跟踪记录，支撑数据的应用和溯源，是数据湖方案顺利实施的关键要素。并且还需要加强数据标准的全生命周期流程以及数据标准的元数据及数据质量问题收集、自动稽核、问题溯源、影响分析及跟踪处理等数据管理能力。可以采用爬虫的方式生成数据目录，在不影响数据所有者或用户的情况下自动生成，&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6115214180206795&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibWWHtDzZMulgFjPcgqgveGkiaic6ouxKFXZxqTdVMvazicpjePicqom7VqA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;决定数据湖能否顺利实施的因素有很多，包括数据湖涵盖哪些数据及如何分区存储、数据湖如何分布式部署、纷繁复杂的现有IT系统数据如何入湖、数据和应用能否分离、数据湖与现有各类数据平台的演进关系等。当然，更重要的是数据管理思维的转变，这是一切的基础。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对运营商数据湖的实施，提出如下4个方面的关键要点及建议。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要点1：数据湖分区&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖逻辑上可划分为&lt;strong&gt;生产数据区、原生数据区、整合数据区、汇总数据区&lt;/strong&gt;4个大的存储区域。数据湖的应用可基于PaaS平台按需使用各个区的数据，4个区的数据目录、元数据、数据加工处理流程及数据应用需要统一管理、维护和治理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;生产数据区&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;M/B/O系统生产数据的存储区域，涵盖实时交易型数据、实时/准实时网络采集数据等，可以是关系型和非关系型混搭的存储结构，各生产系统需要进行架构优化，数据与应用分层解耦，将数据存入生产数据区。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原生数据区&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;将各系统的生产数据直接写入数据湖原生数据区，以非关系型数据格式存储生产系统数据，方便各数据应用使用，生产数据和原生数据模型标准、主数据一致。原生数据区涵盖企业的任何内容，无限接近企业各系统、部门的敏感信息。供数据湖科学家和技术人员访问使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整合数据区&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储按照数据分析需求建模加工后的公用数据。模型从生产/原生数据模型派生而来，被业务和IT部门熟知，可供企业各种应用程序使用。原生数据区中依然有很多数据或属性没有被真正理解，并未完全包含在这个数据区的模型中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;汇总数据区&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储按需求分析汇总的结果数据，一般可存储在关系型数据存储内，便于数据服务的快速加载呈现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖生产数据区和原生数据区作为最重要的数据分区，是数据湖内数据整合和汇总的源头数据，数据质量必须得到保障。另外，数据湖虽不鼓励应用特定模型，但也可划分特定数据区给私有应用使用，提供快速构建数据应用的途径，这些应用获取数据湖数据且具有数据处理能力，数据湖构建初期，可将已有业务应用数据导入数据湖特定数据区中。电信运营商数据湖数据分区示例如图4所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5089820359281437&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibfaQAnRAiaLZRp4vkB8XLt2vK5qCXicedRmLbG9PE7NlpHicLDJkbJ1epg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1336&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要点2：数据湖部署&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖部署方案的设计需要考虑如下要素：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;现有BSS/OSS系统分省/总部两级建设和维护，源系统模型属地管理；网络/平台数据量大，且贴近网络建设归属地，属地应用占比大；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;M/B/O及网络/平台之间数据松耦合，主要通过企业主数据进行衔接。数据湖原生数据区和生产数据区与数据源系统就近分布式部署（总部1+省市31模式）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生产数据云节点由生产系统按需分区、分片部署，即支撑生产应用交易处理，也支撑实时网络数据采集和应用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;原生数据云节点与生产数据云节点就近、集中部署，靠近数据归属地，数据实时从生产数据云节点写入原生数据云节点。原生数据云节点可再细分为核心数据区（如客户、销售品、产品、服务、资源、组织、人员等）、BSS数据区、OSS数据区、MSS数据区、网络/平台数据区。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;数据湖整合、汇总数据云节点采用1+N模式部署，统一管理、控制和调度节点环境，兼顾全网统一和个性化应用需求，数据科学家逐步探索和建模数据，开放数据应用。1+N模式中的“1”支撑全网应用，“N”支撑省内应用，并作为创新基地，有条件、数据量大、应用丰富的省可选择建设N分区。分区节点内可按照应用范围（全局需求、特定需求）、地域归属（集团、省）、数据层次（整合、汇总）、数据分级（普通、密级）等进一步分区存储。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;电信运营商数据湖部署方案示例如图5所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44459738472126636&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibfaAz64aP1AsRg8wWwj3jDib3EJ79nhneIEoAJqjgQCzoOKCjkeiarcFg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1453&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;要点3：IT系统数据入湖&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖的建设不可能一蹴而就，需要根据运营商IT系统建设情况分别采用不同策略进行数据入湖演进。电信运营商IT系统入湖方案示例如图6所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41064388961892245&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z41OKKvYQO6RknHBeVQUfqMpVVkpfibJibP5SxuEUkjnkqPanS1icxDgP6Mtlnp0Zb6o9ichiaxqnT88olw3RsfEJYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;方式一：数据同步方式。适合交易型系统已存在、数据模型和主数据已全网统一的场景，生产数据直接同步写入原生数据区，如BSS、MSS、传统OSS。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方式二：数据同步/转换方式。适合交易型系统已存在、数据模型和主数据并未全网统一的场景，如BSS、MSS、传统OSS。将非标准生产数据写入原生数据区，支撑省内整合汇总应用及集团标准的宽表需求；将非标准生产数据按全网统一标准转换，提供给全网数据整合汇总及数据治理使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方式三：数据正本方式。适合交易型系统新建模式，如新一代OSS资源、编排、告警等。正本数据写入生产数据区，统一模型和主数据标准，基于交易型PaaS平台完成应用；生产数据区数据直接写入原生数据区。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;方式四：采集入库方式。适合网络监控分析型系统新建模式，如新一代OSS的网络采集数据、资源拓扑、深度分组检测（DPI）数据等。数据采集文件、流数据等暂存在生产数据区；写入原生数据区后，生产数据区不再保留；统一原生数据模型和主数据标准，基于实时和非实时PaaS平台完成分析型应用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;要&lt;/span&gt;点4：数据湖数据与应用分离&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖通过数据服务平台、数据共享平台及统一数据应用环境按需支持交易类、实时监控类、分析类应用。数据增、删、改、查服务统一部署在数据服务平台上，供交易类应用访问调用；通过订阅需要监控的数据，由数据共享平台将数据实时分发给监控类应用使用；数据的加工整合、分析应用、海量搜索、人工智能等应用均可部署在应用环境内，按需动态加载并临时存储数据，结果写回到数据湖存储环境，以服务方式启动任务和查询结果数据。其中，应用环境公共组件随着技术的更新不断叠加，逐渐平台化共享，暂时无法满足应用需求的可由应用在统一环境内部署组件及加载数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖应用加载数据的方式可分为实时增量加载、准实时增量/全量加载、离线批量加载等，数据可按需全量或增量短期加载。对于应用和数据无法解耦的组件（如Hive、MPP等），按需复制数据，以空间换数据管理和应用的灵活性；对于应用和数据可以有效解耦的组件（如Spark等），可以按需动态、实时加载数据。应用组件逐渐由与数据紧耦合的组件向与数据松耦合的组件演进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖采用读写分离、应用计算与数据存储分离、关系数据与非关系数据存储并存的模式，并提供数据存储节点分布式部署、服务化访问及统一数据加载、共享及分发能力，降低数据湖数据存储访问负载，提升数据的可用性及数据访问效率。由数据湖提供数据的统一迁移，包括主从库的复制、关系库到非关系库的数据转换等；提供统一的关系和非关系库数据访问及分布式数据路由以及数据共享开放和订阅分发管理框架，实现高效的数据访问；提供统一的数据应用环境管理，包括配额管理、数据访问权限管理、数据回写节点分配管理等，独立部署分析计算类应用，分析计算节点与数据湖数据存储节点分离；提供统一的分布式服务运行框架，基于服务调用实现交易类增、删、改、查应用的数据访问，避免直接操作数据。电信运营商数据湖应用方案示例如图7所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;225&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3888888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DMP9YVibia1dS9ziaSloOhVib5cevyIJWPDKffbPbdXccibSDq8XONvZKHwhcDlt7LCcaHawX0Mn5sGeb8mqw0otoyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要点5：数据湖数据统一管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据湖的实施，需要实现模型和主数据标准的动态维护以及数据的集中治理，避免数据湖成为数据墓地。而数据来源众多，数据管理需要依赖于多方的密切合作以及数据标准管理、目录/元数据管理、应用/服务管理、质量等管理及海量数据探索分析等高效的管理工具。电信运营商数据湖管理体系示例如图8所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;278&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DMP9YVibia1dS9ziaSloOhVib5cevyIJWPDKC9P8D7SPhBtLQhGXoksqdlcoK1jhXJ3hwqTSPl5icEltbcBVumQ4jSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;电信运营商数据涉及系统众多、关系复杂，没有任何一个独立的团队能够通晓所有的数据模型和关联关系，因此需要企业数据管理团队与专业数据管理团队分工合作，共同完成数据模型标准/主数据的管理及数据集中治理。建立横纵向一体化的数据管理体系，明确企业数据管理和原生数据部门职责分工，固化数据管理流程制度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;企业数据管理团队负责统筹标准和主数据管理及数据治理工作，负责数据建模挖掘和跨专业数据治理协作，负责为业务部门和应用开发者提供数据建模和平台技术支持；专业数据管理团队负责建立专业数据的模型标准和管理主数据，识别数据问题及跟踪处理；数据湖应用开发者负责提出数据需求，按需整合和构建应用，反馈数据问题，评估数据变更影响。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;另外，作为企业最核心的数据资产，其全生命周期的安全管理非常重要。需要针对数据采集、数据存储（生产数据、原生数据、整合数据、汇总数据）、数据应用、数据服务、数据分发共享等环节构建端到端的安全管控体系。对涉及用户行为特征及关键信息的敏感数据进行统一处理，脱敏后提供给应用使用；不管是敏感数据还是非敏感数据，所有数据的直接访问均在数据湖的管理范围内进行，具体措施包括数据应用环境、服务访问环境、共享分发环境、数据存储环境统一管控，需要经过统一的对象和属性等的鉴权才能访问数据，数据不出数据湖（即数据访问不出台），只能使用服务化方式或经过鉴权认证的数据共享分发方式进行数据访问。同时需要对大数据安全事件具备闭环管控能力，增强数据安全事件快速分析能力，提升安全事件发&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;生后的应对处置效率。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6764091858037579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TwK74MzofXd78W49nBaME6TkGc8gv8DBzMJvytIYy9Dibfsl7qq5ibATfYh9BN1xQO5qU1OejK3Gic6dfl8iafXwGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>