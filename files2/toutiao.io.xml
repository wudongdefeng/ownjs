<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ddd9ef3f1b5c49d139e4ba7fd56e06b9</guid>
<title>全网最全的权限系统设计方案（图解）</title>
<link>https://toutiao.io/k/lozkmee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 为什么需要权限管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常工作中权限的问题时时刻刻伴随着我们，程序员新入职一家公司需要找人开通各种权限，比如网络连接的权限、编码下载提交的权限、监控平台登录的权限、运营平台查数据的权限等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在很多时候我们会觉得这么多繁杂的申请给工作带来不便，并且如果突然想要查一些数据，发现没有申请过权限，需要再走审批流程，时间拉得会很长。那为什么还需要这么严格的权限管理呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，一家支付公司有运营后台，运营后台可以查到所有的商户信息，法人代表信息，交易信息以及费率配置信息，如果我们把这些信息不加筛选都给到公司的每一个小伙伴，那么跑市场的都可以操作商家的费率信息，如果一个不小心把费率改了会造成巨大的损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如商户的信息都是非常隐秘的，有些居心不良的小伙伴把这些信息拿出来卖给商家的竞争对手，会给商家造成严重的不良后果。虽然这么做都是个别人人为的过错，但是制度上如果本身这些信息不开放出来就能在很大程度上避免违法乱纪的事情发生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来讲&lt;strong&gt;权限管理是公司数据安全的重要保证，针对不同的岗位，不同的级别看到的数据是不一样的，操作数据的限制也是不一样的。&lt;/strong&gt;比如涉及到资金的信息只开放给财务的相关岗位，涉及到配置的信息只开放给运营的相关岗位，这样各司其职能避免很多不必要的安全问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何让各个岗位的人在系统上各司其职，就是权限管理要解决的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 权限模型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 权限设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从业务分类上来讲权限可以分为数据查看权限，数据修改权限等，对应到系统设计中有页面权限、菜单权限、按钮权限等。菜单也分一级菜单、二级菜单甚至三级菜单，以csdn文章编辑页面左侧菜单栏为例是分了两级菜单。菜单对应的页面里又有很多按钮，我们在设计的时候最好把权限设计成树形结构，这样在申请权限的时候就可以一目了然的看到菜单的结构，需要哪些权限就非常的明了了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.563302752293578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7nn7wjVKBrX4icyVY40flLXqTVFQFjMTNx72QPVsseZ3mdrFPpwM8C1g/640?wx_fmt=png&amp;amp;random=0.3869801465108955&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个架构，按钮的父级是二级菜单，二级菜单的父级是一级菜单，这样用户申请权限的时候非常清晰的看到自己需要哪些权限。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 为什么需要角色&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限结构梳理清晰之后，需要思考怎么把权限分配给用户，用户少的情况下，可以直接分配，一个用户可以有多个权限，统一一个权限可以被多个用户拥有，用户-权限的模型结构如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25984251968503935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq73HUxp4kSjepVXIibazxT1kcOnuZxf1jTL4mwLQwgYyX512p28fzOmNg/640?wx_fmt=png&amp;amp;random=0.12281593247417089&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;这种模型能够满足权限的基本分配能力，但是随着用户数量的增长，这种模型的弊端就凸显出来了，每一个用户都需要去分配权限，非常的浪费管理员的时间和精力，并且用户和权限杂乱的对应关系会给后期带来巨大的维护成本。用户-权限对应关系图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8726708074534162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7mNU34iciasyLzPxZ0EMspjJ9sY47UyhSAl0MoQ2ukttkMrX7rzgf6SKw/640?wx_fmt=png&amp;amp;random=0.379500115530764&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;这种对应关系在用户多的情况下基本无法维护了。其实很多用户负责同一个业务模块所需要的权限是一样的，这样的话我们是不是可以借助第三个媒介，把需要相同的权限都分配给这个媒介，然后用户和媒介关联起来，用户就拥有了媒介的权限了。这就是经典的RBAC模型，其中媒介就是我们通常所说的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 权限模型的演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.1 RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了角色之后可以把权限分配给角色，需要相同权限的用户和角色对应起来就可以了，一个权限可以分配给多个角色，一个角色可以拥有多个权限，同样一个用户可以分配多个角色，一个角色也可以对应多个用户，对应模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17224080267558528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq70Pp3ia1T0qWCpcO3hoibptmXtfMFmuLV5R0pKdZpBibHLE6c5htVDUcUA/640?wx_fmt=png&amp;amp;random=0.7805500510170766&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是经典的RBAC模型了（role-based-access-control），在这里面角色起到了桥梁左右，连接了用户和权限的关系，每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46864686468646866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7SyN9SrzXEnBS0RDBVicmt3PlGDvovzf05C1ulRyVadO9oD6hYHbtP6A/640?wx_fmt=png&amp;amp;random=0.2863653075923056&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本， 但是实际的业务千变万化，权限管理的模型也需要根据不同的业务模型适当的调整，比如一个公司内部的组织架构是分层级的，层级越高权限越大，因为层级高的人不仅要拥有自己下属拥有的权限，二期还要有一些额外的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型可以给不同层级的人分配不同的角色，层级高的对应角色的权限就多，这样的处理方式可以解决问题，但是有没有更好的解决办法呢，答案肯定是有的，这就引出&lt;strong&gt;角色继承的RBAC模型&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.2 角色继承的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;角色继承的RBAC模型又称RBAC1模型。每个公司都有自己的组织架构，比如公司里管理财务的人员有财务总监、财务主管、出纳员等，财务主管需要拥有但不限于出纳员的权限，财务总监需要拥有但不限于财务主管的权限，像这种管理关系向下兼容的模式就需要用到角色继承的RBAC模型。&lt;strong&gt;角色继承的RBAC模型的思路是上层角色继承下层角色的所有权限，并且可以额外拥有其他权限。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7605363984674329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Vz5WxDUJECmsqerotwzqLJXTVm2HDRkZGhc6OIfBmiaJiagYjiapXBFnQ/640?wx_fmt=png&amp;amp;random=0.01075333932726652&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;从模型图中可以看出下级角色拥有的权限，上级角色都拥有，并且上级角色可以拥有其他的权限。角色的层级关系可以分为两种，一种是下级角色只能拥有一个上级角色，但是上级角色可以拥有多个下级角色，这种结构用图形表示是一个树形结构，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5091911764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7vTkqibyicXmfwX5eQCzCFabxibpGUa2NG1LtAE55js6Gms3yPKxbSlHzg/640?wx_fmt=png&amp;amp;random=0.9664950058278607&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;还有一种关系是下级角色可以拥有多个上级角色，上级角色也可以拥有多个下级角色，这种结构用图形表示是一个有向无环图，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064456721915286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7BD3bNkYP7mqzTYEVhia1UJMiaokMSAlWdmobLACVu5CyItAWxrH1Cpsw/640?wx_fmt=png&amp;amp;random=0.04259729352510133&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;树形图是我们比较常用的，因为一个用户一般情况下不会同时有多个直属上级，比如财务部只能有一个财务总监，但是可以有多个财务主管和收纳员。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.3 带约束的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带约束的RBAC模型又成RBAC2模型。在实际工作中，为了安全的考虑会有很多约束条件，比如财务部里同一个人不能即是会计又是审核员，跟一个人同一时间不能即是运动员又是裁判员是一个道理的，又比如财务部的审核员不能超过2个，不能1个也没有。因为角色和权限是关联的，所以我们做好角色的约束就可以了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;常见的约束条件有：角色互斥、基数约束、先决条件约束等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;角色互斥：&lt;/strong&gt; 如果角色A和角色B是互斥关系的话，那么一个用户同一时间不能即拥有角色A，又拥有角色B，只能拥有其中的一个角色。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如我们给一个用户赋予了会计的角色就不能同时再赋予审核员的角色，如果想拥有审核员的角色就必须先去掉会计的角色。假设提交角色和审核角色是互质的，我们可以用图形表示：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3898989898989899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7ZpUKnW9qWjqtpmH9pOic9ye6hAjz1IEFaSarNTwZTGbqibFva5ly7ODg/640?wx_fmt=png&amp;amp;random=0.5303696963485485&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;strong&gt;基数约束：&lt;/strong&gt; 同一个角色被分配的用户数量可以被限制，比如规定拥有超级管理员角色的用户有且只有1个；用户被分配的角色数量也需要被限制，角色被分配的权限数量也可以被限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先决条件约束：&lt;/strong&gt;用户想被赋予上级角色，首先需要拥有下级角色，比如技术负责人的角色和普通技术员工角色是上下级关系，那么用户想要用户技术负责人的角色就要先拥有普通技术员工的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 用户划分&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.1 用户组&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建角色是为了解决用户数量大的情况下，用户分配权限繁琐以及用户-权限关系维护成本高的问题。抽象出一个角色，把需要一起操作的权限分配给这个角色，把角色赋予用户，用户就拥有了角色上的权限，这样避免了一个个的给用户分配权限，节省了大量的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的如果有一批用户需要相同的角色，我们也需要一个个的给用户分配角色，比如一个公司的客服部门有500多个人，有一天研发部研发了一套查询后台数据的产品，客服的小伙伴都需要使用，但是客服由于之前并没有统一的一个角色给到所有的客服小伙伴，这时候需要新加一个角色，把权限分配给该角色，然后再把角色一个个分配给客服人员，这时候会发现给500个用户一个个添加角色非常的麻烦。但是客服人员又有共同的属性，所以我们可以创建一个用户组，所有的客服人员都属于客服用户组，把角色分配给客服用户组，这个用户组下面的所有用户就拥有了需要的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型添加用户组之后的模型图如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44676409185803756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7AOXjfzkg6ayvFhyqFepD2iaTibyFXBlQwd0NeZn6OGQCkgCrJdMo7a0Q/640?wx_fmt=png&amp;amp;random=0.7284421954870555&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;很多朋友会问，用户组和角色有什么区别呢？简单的来说，&lt;strong&gt;用户组是一群用户的组合，而角色是用户和权限之间的桥梁。&lt;/strong&gt; 用户组把相同属性的用户组合起来，比如同一个项目的开发、产品、测试可以是一个用户组，同一个部门的相同职位的员工可以是一个用户组， 一个用户组可以是一个职级，可以是一个部门，可以是一起做事情的来自不同岗位的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以分组，权限也可以分组，权限特别多的情况下，可以把一个模块的权限组合起来成为一个权限组，权限组也是解决权限和角色对应关系复杂的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们定义权限的时候一级菜单、二级菜单、按钮都可以是权限，一个一级菜单下面有几十个二级菜单，每个二级菜单下面又有几十个按钮，这时候我们把权限一个个分配给角色也是非常麻烦的，可以采用分组的方法把权限分组，然后把分好的组赋予角色就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给权限分组也是个技术活，需要理清楚权限之间的关系，比如支付的运营后台我们需要查各种信息，账务的数据、订单的数据、商户的数据等等，这些查询的数据并不在一个页面，每个页面也有很多按钮，我们可以把这几个页面以及按钮对应的权限组合成一个权限组赋予角色。加入权限组之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44258872651356995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Nv23yWO5UqQ1pJfFZ91ibRRz9ebKWcECWctygzdANx1zvHFatVPRiaMw/640?wx_fmt=png&amp;amp;random=0.3565732072391419&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;实际工作中我们很少给权限分组，给用户分组的场景会多一些，有的时候用户组也可以直接和权限关联，这个看实际的业务场景是否需要，权限模型没有统一的，业务越复杂业务模型会约多样化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.2 组织&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个公司都有自己的组织架构，很多时候权限的分配可以根据组织架构来划分。因为同一个组织内的小伙伴使用的大部分权限是一样的。如下所示一个公司的组织架构图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5008210180623974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7dbXNuYRGZNcaZib6H7oG4AgiaheboEicZStGr81tbUC5qOaiaJObnmONYw/640?wx_fmt=png&amp;amp;random=0.4545984963546068&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;按照这个组织架构，每一个组织里的成员使用的基础权限很可能是一样的，比如人力资源都需要看到人才招聘的相关信息，市场推广都需要看到行业分析的相关信息，按照组织来分配角色会有很多优势：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现权限分配的自动化：&lt;/strong&gt; 和组织关系打通之后，按照组织来分配角色，如果有新入职的用户，被划分在某个组织下面之后，会自动获取该组织下所有的权限，无需人工分配。又比如有用户调岗，只需要把组织关系调整就可以了，权限会跟着组织关系自动调整，也无需人工干预。这么做首先需要把权限和组织关系打通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制数据权限：&lt;/strong&gt; 把角色关联到组织，组织里的成员只能看到本组织下的数据，比如市场推广和大客定制，市场推广针对的是零散的客户，大可定制针对的是有一定体量的客户，相互的数据虽然在一个平台，但是只能看自己组织下的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入组织之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4425531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7lWt5ia70uWdoanLr5bhpA1vd8Mva67aEbFdiafTTPck10snrWwncNr7A/640?wx_fmt=png&amp;amp;random=0.43082287972094635&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;用户可以在多个组织中，因为组织也有层级结构，一个组织里只可以有多个用户，所以用户和组织的关系是多对多的关系，组织和角色的关系是一对一的关系。这个在工作中可以根据实际情况来确定对应关系。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.3 职位&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个组织下面会有很多职位，比如财务管理会有财务总监、财务主管、会计、出纳员等职位，每个职位需要的权限是不一样的，可以像组织那样根据职位来分配不同的角色，由于一个人的职位是固定的，所以用户跟职位的对应关系时一对一的关系，职位跟角色的对应关系可以是多对多的关系。加入职位的RBAC模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4451476793248945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kcXicbH94aqTjw4aRwMysbxhPvEwDnBicYYIZ551WZm4ib50Kfv38D7CA/640?wx_fmt=png&amp;amp;random=0.8327855836170899&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 理想的RBAC模型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型根据不同业务场景的需要会有很多种演变，实际工作中业务是非常复杂的，权限分配也是非常复杂的，想要做出通用且高效的模型很困难。我们把RBAC模型的演变汇总起来会是一个支撑大数据量以及复杂业务的理想的模型。把RBAC、RBAC1、RBAC2、用户组、组织、职位汇总起来的模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4702517162471396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7fzPfV1Lno8roOmeJ4gd3CKsr0iclcsviaTkJlIia3xLtn7gooooEs1vfA/640?wx_fmt=png&amp;amp;random=0.7807457219448579&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;按照这个模型基本上能够解决所有的权限问题，其中的对应关系可以根据实际的业务情况来确定，一般情况下，组织和职位是一对多的关系，特殊情况下可以有多对多的情况，需要根据实际情况来定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型并不是说我们一开始建权限模型就可以这么做，而是数据体量、业务复杂度达到一定程度之后可以使用这个模型来解决权限的问题，如果数据量特别少，比如刚成立的公司只有十几个人，那完全可以用用户-权限模型，都没有必要使用RBAC模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 权限系统表设计&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 标准RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准RBAC模型的表是比较简单了，要表示&lt;code&gt;用户-角色-权限&lt;/code&gt;三者之前的关系，首先要创建用户表、角色表、权限表，用户和角色是多对多的关系，角色和权限是多对多的关系，需要再创建两章关系表，分别是用户-角色关系表和角色-权限关系表。这六张表的ER图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4920886075949367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kgfe8UC7IVzSzSzqO6fn3SAZ7vw1l7PYiaNXCcTd5JajrEsseJpIAmw/640?wx_fmt=png&amp;amp;random=0.5719574040529976&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 理想RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型是标准RBAC模型经过多次扩展得到的，表结构也会比较复杂，因为要维护很多关系，如下图所示是理想的RBAC模型的ER图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5965417867435159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7icQjj6sPTuvRdUAjKc9icrkV7tQNwuic8HWOf2cfTGz7RwZBfzbjfuUcA/640?wx_fmt=png&amp;amp;random=0.021794103728019598&quot; data-type=&quot;png&quot; data-w=&quot;2082&quot;/&gt;这里面需要强调的是角色互斥表，互斥的关系可以放在角色上，也可以放在权限上，看实际工作的需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 结语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从易到难非常详细的介绍了权限模型的设计，在工作中需要根据实际情况来定义模型，千人以内的公司使用RBAC模型是完全够用的，没有必要吧权限模型设计的过于复杂。模型的选择要根据具体情况，比如公司体量、业务类型、人员数量等。总之最适合自己公司的模型就是最好的模型，权限模式和设计模式是一样的，都是为了更好的解决问题，不要为了使用模型而使用模型。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83a5b260c1357d19c1fcf67438e4cf07</guid>
<title>麻了，代码改成多线程，竟有9大问题</title>
<link>https://toutiao.io/k/1lggdyi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;文末留言送书啦！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们为了提升接口的性能，会把之前&lt;code&gt;单线程同步&lt;/code&gt;执行的代码，改成&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查询用户信息接口，&lt;code&gt;同步调用&lt;/code&gt;三个接口获取数据，会非常耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常有必要把三个接口调用，改成&lt;code&gt;异步调用&lt;/code&gt;，最后&lt;code&gt;汇总结果&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如：注册用户接口，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该用户注册接口包含的业务逻辑比较多，如果在接口中同步执行这些代码，该接口响应时间会非常慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就需要把业务逻辑梳理一下，划分：&lt;code&gt;核心逻辑&lt;/code&gt;和&lt;code&gt;非核心逻辑&lt;/code&gt;。这个例子中的核心逻辑是：写用户表和分配权限，非核心逻辑是：配置用户导航页和发通知消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然&lt;code&gt;核心逻辑&lt;/code&gt;必须在接口中&lt;code&gt;同步执行&lt;/code&gt;，而&lt;code&gt;非核心逻辑&lt;/code&gt;可以&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要使用多线程的业务场景太多了，使用多线程异步执行的好处不言而喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要说的是，如果多线程没有使用好，它也会给我们带来很多意想不到的问题，不信往后继续看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊，代码改成多线程调用之后，带来的9大问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.获取不到返回值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通过直接继承&lt;code&gt;Thread&lt;/code&gt;类，或者实现&lt;code&gt;Runnable&lt;/code&gt;接口的方式去创建&lt;code&gt;线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，恭喜你，你将没法获取该线程方法的返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用线程的场景有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是不需要关注线程方法返回值的，但如果我们有些业务需要关注线程方法的返回值该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1QFBCIrAKapkFNx1jEiaRObHA0Im1rz2yYNvRfMdmhGppAqjfgsbvLZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;在Java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，&lt;code&gt;Fork/join&lt;/code&gt;框架也提供了执行任务并返回结果的能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.数据丢失&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以注册用户接口为例，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：写用户表和分配权限功能，需要在一个事务中同步执行。而剩余的配置用户导航页和发通知消息功能，使用多线程异步执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上看起来没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果前面的写用户表和分配权限功能成功了，用户注册接口就直接返回成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果后面异步执行的配置用户导航页，或发通知消息功能失败了，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT14NOSxPsEFpU4ARFqEhZbMHZZmJECbmkkDZSJ8hx92sA1dicX1c7GveQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;该接口前面明明已经提示用户成功了，但结果后面又有一部分功能在多线程异步执行中失败了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，你可以做&lt;code&gt;失败重试&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果重试了一定的次数，还是没有成功，这条请求数据该如何处理呢？如果不做任何处理，该数据是不是就丢掉了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止数据丢失，可以用如下方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用mq异步处理。在分配权限之后，发送一条mq消息，到mq服务器，然后在mq的消费者中使用多线程，去配置用户导航页和发通知消息。如果mq消费者中处理失败了，可以自己重试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用job异步处理。在分配权限之后，往任务表中写一条数据。然后有个job定时扫描该表，然后配置用户导航页和发通知消息。如果job处理某条数据失败了，可以在表中记录一个重试次数，然后不断重试。但该方案有个缺点，就是实时性可能不太高。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.顺序问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用了多线程，就必须接受一个非常现实的问题，即&lt;code&gt;顺序问题&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如之前代码的执行顺序是：a,b,c，改成多线程执行之后，代码的执行顺序可能变成了：a,c,b。（这个跟cpu调度算法有关）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;c&lt;br/&gt;b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，来自灵魂的一问：如何保证线程的顺序呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即线程启动的顺序是：a,b,c，执行的顺序也是：a,b,c。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1703296703296704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT12moFAiaOLH2D345zeSLOHsyNdW3BU8AYYbRpudZhU3yCqEg6fGJ2EDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 join&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;类的&lt;code&gt;join&lt;/code&gt;方法它会让主线程等待子线程运行结束后，才能继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread2.join();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 newSingleThreadExecutor&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用JDK自带的&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法，创建一个&lt;code&gt;单线程&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    executorService.submit(thread1);&lt;br/&gt;    executorService.submit(thread2);&lt;br/&gt;    executorService.submit(thread3);&lt;br/&gt;&lt;br/&gt;    executorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法创建的单线程的线程池，使用了&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为队列，而此队列按 &lt;code&gt;FIFO&lt;/code&gt;（先进先出）排序元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加到队列的顺序是a,b,c，则执行的顺序也是a,b,c。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 CountDownLatch&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch latch1 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch2 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch3 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch1, latch2, &lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch2, latch3, &lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch3, latch3, &lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;        thread3.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRunnable&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch1;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch2;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;&lt;br/&gt;    TestRunnable(CountDownLatch latch1, CountDownLatch latch2, String message) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch1 = latch1;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch2 = latch2;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            latch1.await();&lt;br/&gt;            System.out.println(message);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        latch2.countDown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，使用&lt;code&gt;CompletableFuture&lt;/code&gt;的&lt;code&gt;thenRun&lt;/code&gt;方法，也能多线程的执行顺序，在这里就不一一介绍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.线程安全问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然使用了线程，伴随而来的还&lt;span&gt;会&lt;/span&gt;有线程安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有这样一个需求：用多线程执行查询方法，然后把执行结果添加到一个list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list = Lists.newArrayList();&lt;br/&gt; dataList.stream()&lt;br/&gt;     .map(data -&amp;gt; CompletableFuture&lt;br/&gt;          .supplyAsync(() -&amp;gt; query(list, data), asyncExecutor)&lt;br/&gt;         ));&lt;br/&gt;CompletableFuture.allOf(futureArray).join();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;CompletableFuture&lt;/code&gt;异步多线程执行query方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; list, UserEntity condition)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   User user = queryByCondition(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   list.add(user);&lt;br/&gt;   UserExtend userExtend = queryByOther(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(userExtend)) {&lt;br/&gt;      user.setExtend(userExtend.getInfo());&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在query方法中，将获取的查询结果添加到list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果list会出现线程安全问题，有时候会少数据，当然也不一定是必现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为&lt;code&gt;ArrayList&lt;/code&gt;是&lt;code&gt;非线程安全&lt;/code&gt;的，没有使用&lt;code&gt;synchronized&lt;/code&gt;等关键字修饰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;集合，代替普通的&lt;code&gt;ArrayList&lt;/code&gt;集合，CopyOnWriteArrayList是一个线程安全的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需一行小小的改动即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list Lists.newCopyOnWriteArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨的提醒一下，这里创建集合的方式，用了google的collect包。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.ThreadLocal获取数据异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK&lt;/code&gt;为了解决线程安全问题，提供了一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal在普通中线程中，的确能够获取正确的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何获取&lt;code&gt;ThreadLocal&lt;/code&gt;对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接使用普通ThreadLocal，显然是获取不到正确数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先试试&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想进一步了解ThreadLocal的工作原理，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247494889&amp;amp;idx=1&amp;amp;sn=db15e438326c8e297eef739ec190971b&amp;amp;chksm=c0e83401f79fbd17143734d5dbb509f020553772e162d5895de8c8039d79a3cff8633bcf4bb8&amp;amp;token=1106409335&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;ThreadLocal夺命11连问&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.OOM问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，使用多线程可以提升代码执行效率，但也不是绝对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一些耗时的操作，使用多线程，确实可以提升代码执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但线程不是创建越多越好，如果线程创建多了，也可能会导致&lt;code&gt;OOM&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: &lt;br/&gt;java.lang.OutOfMemoryError: unable to create &lt;span&gt;new&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; thread&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;JVM&lt;/code&gt;中创建一个线程，默认需要占用&lt;code&gt;1M&lt;/code&gt;的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果创建了过多的线程，必然会导致内存空间不足，从而出现OOM异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果使用线程池的话，特别是使用固定大小线程池，即使用&lt;code&gt;Executors.newFixedThreadPool&lt;/code&gt;方法创建的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该线程池的&lt;code&gt;核心线程数&lt;/code&gt;和&lt;code&gt;最大线程数&lt;/code&gt;是一样的，是一个固定值，而存放消息的队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该队列的最大容量是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，也就是说如果使用固定大小线程池，存放了太多的任务，有可能也会导致OOM异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.OutOfMemeryError:Java heap space&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.CPU使用率飙高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有做过excel数据导入功能，需要将一批excel的数据导入到系统中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每条数据都有些业务逻辑，如果单线程导入所有的数据，导入效率会非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是改成了多线程导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果excel中有大量的数据，很可能会出现CPU使用率飙高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，如果代码出现死循环，cpu使用率会飚的很多高。因为代码一直在某个线程中循环，没法切换到其他线程，cpu一直被占用着，所以会导致cpu使用率一直高居不下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多线程导入大量的数据，虽说没有死循环代码，但由于多个线程一直在不停的处理数据，导致占用了cpu很长的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也会出现cpu使用率很高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Thread.sleep&lt;/code&gt;休眠一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线程中处理完一条数据，休眠10毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然CPU使用率飙高的原因很多，多线程处理数据和死循环只是其中两种，还有比如：频繁GC、正则匹配、频繁序列化和反序列化等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面我会写一篇介绍CPU使用率飙高的原因的专题文章，感兴趣的小伙伴，可以关注一下我后续的文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.事务问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到&lt;code&gt;事务方法&lt;/code&gt;add中，调用了事务方法doOtherThing，但是&lt;code&gt;事务方法&lt;/code&gt;doOtherThing是在另外一个&lt;code&gt;线程&lt;/code&gt;中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的&lt;code&gt;数据库连接&lt;/code&gt;不一样，从而是两个不同的&lt;code&gt;事务&lt;/code&gt;。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是&lt;code&gt;数据源&lt;/code&gt;，value是&lt;code&gt;数据库连接&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的&lt;code&gt;同一个事务&lt;/code&gt;，其实是指&lt;code&gt;同一个数据库连接&lt;/code&gt;，只有拥有同一个数据库连接才能同时&lt;code&gt;提交&lt;/code&gt;和&lt;code&gt;回滚&lt;/code&gt;。如果在不同的&lt;code&gt;线程&lt;/code&gt;，拿到的&lt;code&gt;数据库连接&lt;/code&gt;肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以不要在事务中开启另外的线程，去处理业务逻辑，这样会导致事务失效。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.导致服务挂掉&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程会导致服务挂掉，这不是危言耸听，而是确有其事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在有这样一种业务场景：在mq的消费者中需要调用订单查询接口，查到数据之后，写入业务表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来是没啥问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天，mq生产者跑了一个批量数据处理的job，导致mq服务器上堆积了大量的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，mq消费者的处理速度，远远跟不上mq消息的生产速度，导致的结果是出现了大量的消息堆积，对用户有很大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，mq消费者改成&lt;code&gt;多线程&lt;/code&gt;处理，直接使用了&lt;code&gt;线程池&lt;/code&gt;，并且&lt;code&gt;最大线程数&lt;/code&gt;配置成了20。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样调整之后，消息堆积问题确实得到了解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但带来了另外一个更严重的问题：订单查询接口并发量太大了，有点扛不住压力，导致部分节点的服务直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5266821345707656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1uhx7xe5SaRncT0IhIGSDXpWvpqNOrZqKYS533UG8DftiaUuX3v3cbcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;为了解决问题，不得不临时加服务节点。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在mq的消费者中使用多线程，调用接口时，一定要评估好接口能够承受的最大访问量，防止因为压力过大，而导致服务挂掉的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>09ae4a4e649ba9a0ab3fc0da10c8f18b</guid>
<title>优质网站同好者周刊（第 078 期） | 倾城博客</title>
<link>https://toutiao.io/k/rveastt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8&quot;&gt;&lt;code&gt;浏览器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%98%E7%BD%91&quot;&gt;&lt;code&gt;官网&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%95%88%E7%8E%87&quot;&gt;&lt;code&gt;效率&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Whist is the first cloud-hybrid browser. It uses near-zero memory and loads pages at the speed of thought.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.whist.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Whist | The no-compromise browser&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/post/62f50049edc6366d5c0852e5&quot;&gt;Whist&lt;/a&gt; 是第一个配备云标签/云混合（Coud Tabs / Cloud Hybrid）的原生浏览器，旨在&lt;strong&gt;疯狂快速&lt;/strong&gt;和&lt;strong&gt;轻量级&lt;/strong&gt;；可将任何网站的处理卸载到云端。当繁重的网站占用 RAM 或降低您的计算机速度时，您只需单击一个按钮即可激活云选项卡。当您打开更多选项卡时，传统浏览器会降低性能。Whist（惠斯特）没有，它具有以下功能特色：&lt;/p&gt;&lt;h3 id=&quot;近零内存&quot;&gt;&lt;a href=&quot;#%E8%BF%91%E9%9B%B6%E5%86%85%E5%AD%98&quot; aria-label=&quot;近零内存 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;近零内存&lt;/h3&gt;&lt;p&gt;单个选项卡可以轻松消耗超过 GB 的内存。云标签几乎没有使用。&lt;/p&gt;&lt;h3 id=&quot;快速的网络应用程序&quot;&gt;&lt;a href=&quot;#%E5%BF%AB%E9%80%9F%E7%9A%84%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F&quot; aria-label=&quot;快速的网络应用程序 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;快速的网络应用程序&lt;/h3&gt;&lt;p&gt;立即加载海量电子表格、仪表板和生产力应用程序。&lt;/p&gt;&lt;h3 id=&quot;安静的笔记本电脑风扇&quot;&gt;&lt;a href=&quot;#%E5%AE%89%E9%9D%99%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%B5%E8%84%91%E9%A3%8E%E6%89%87&quot; aria-label=&quot;安静的笔记本电脑风扇 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;安静的笔记本电脑风扇&lt;/h3&gt;&lt;p&gt;通过将处理卸载到云端，Whist 让您的笔记本电脑保持凉爽运行。&lt;/p&gt;&lt;h3 id=&quot;gpu-加速&quot;&gt;&lt;a href=&quot;#gpu-%E5%8A%A0%E9%80%9F&quot; aria-label=&quot;gpu 加速 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;GPU 加速&lt;/h3&gt;&lt;p&gt;Whist 云选项卡由 NVIDIA 云 GPU 提供支持，可运行要求最苛刻的 Web 应用程序。&lt;/p&gt;&lt;h3 id=&quot;更长的电池寿命&quot;&gt;&lt;a href=&quot;#%E6%9B%B4%E9%95%BF%E7%9A%84%E7%94%B5%E6%B1%A0%E5%AF%BF%E5%91%BD&quot; aria-label=&quot;更长的电池寿命 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;更长的电池寿命&lt;/h3&gt;&lt;p&gt;Whist 可将笔记本电脑的电池寿命延长多达 2 小时。&lt;/p&gt;&lt;h3 id=&quot;原生性能&quot;&gt;&lt;a href=&quot;#%E5%8E%9F%E7%94%9F%E6%80%A7%E8%83%BD&quot; aria-label=&quot;原生性能 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;原生性能&lt;/h3&gt;&lt;p&gt;通过 Whist 专有的低延迟流媒体技术，大幅提升性能。&lt;/p&gt;&lt;p&gt;Whist 让网络应用程序变得更快，通过从云端流式传输单个的沉重标签（heavy tabs），对于以下群体，是福音般的存在：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;工程团队&lt;/strong&gt;：在您的笔记本电脑上，轻松运行数百个选项卡或并发桌面应用程序；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;设计团队&lt;/strong&gt;：通过云图形加速在 Figma 和其他设计工具中，即时加载 2D/3D 资源；&lt;/li&gt;&lt;li&gt;&lt;strong&gt;营销团队&lt;/strong&gt;：运行数十个并发的重型仪表板，和销售工具而不会放慢速度；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Whist，于 2019 年，Whist 在哈佛大学成立，作为虚拟机的远程桌面提供商。2020 年，Whist 转向应用程序流媒体，2021 年，Whist 将其流媒体技术完全集中在浏览器上。如今（2022.08），Whist 总部位于纽约市，拥有一支由 15 多名工程师组成的团队。它是 Brave 的一个分支，该浏览器在外观上几乎与 Chrome 相同，并增强了更好的隐私和安全性；此外，Whist 自带屏蔽广告拦截器、附带 Brave 的加密钱包、支持 Tor 打开隐身窗口、支持 Chrome 扩展及导入设置。在普通用户使用这块儿，Whist 做得颇为用心。&lt;/p&gt;&lt;p&gt;官方团队有在 &lt;a href=&quot;https://www.producthunt.com/posts/whist&quot;&gt;Product Hunt&lt;/a&gt; 介绍：“创建 Whist 是为了解决技术、金融、销售和设计领域的工作人员非常熟悉的一个问题：现代 Web 应用程序变得越来越重，并拖累了人们的生产力。在过去的两年里，我们已经用数千名用户测试了 Whist，并构建了真正的&lt;strong&gt;不妥协浏览器&lt;/strong&gt;：具有云选项卡的浏览器，不会牺牲本地浏览器的任何性能或安全性”。有用户在下面评论到：“Whist 很棒，我终于可以打开 2000 个标签，而不会让我的 2014 MacBook air 崩溃”。&lt;/p&gt;&lt;p&gt;看到这些介绍，令作为经常打开数十浏览器 Tab （Chrome）的我，兴奋不已，迫不及待下载并体验；即便打开多个标签，其占用内存也远小于 &lt;a href=&quot;https://nicelinks.site/post/5fa82652ac6b5718fc48ac10&quot;&gt;火狐&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/62f106afb5abd454197aa3aa&quot;&gt;欧朋&lt;/a&gt;（只打开一个）；响应渲染速度上，感知上 Whist 要略快一些；因为内部基于 Chrome，因而兼容性很好，与 Chrome 别无二致。目前，Whist 仅适用于 macOS（支持 M1 芯片 Mac），对于只使用 macOS 用户，无较大影响。整体而言，对 Whist 很是满意；接下来对浏览器的使用分工为：Whist 用于检索和浏览网页，Chrome 则专注涉及 Web 应用开发，Wow，&lt;strong&gt;酷&lt;/strong&gt;。嘿，朋友，如果您对桌面浏览器，亦有较高之要求，Whist 强烈建议体验并应用。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f50049edc6366d5c0852e5&quot;&gt;倾城之链 - Whist | The no-compromise browser&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%99%BD%E6%9D%BF&quot;&gt;&lt;code&gt;白板&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%AF%E8%A7%86%E5%8C%96&quot;&gt;&lt;code&gt;可视化&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E8%A1%A8&quot;&gt;&lt;code&gt;图表&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：白板, 可视化, 图表, 应用, 画图, 流程图, 草图, 专利图, diagramming, whiteboarding, diagrams.net, draw.io, 在线, 工具, 桌面应用&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;draw.io, is a configurable diagramming/whiteboarding visualization application.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.diagrams.net.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Diagram Software and Flowchart Maker&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：Diagram，可配置的图表/白板可视化应用程序，支持在线使用，也提供桌面应用程序，涵盖 Mac、Windows 等系统； 此外，您也可以基于 Docker 部署在本地或自己的服务器；更棒的是也有集成于 &lt;a href=&quot;https://nicelinks.site/post/6266999577f8270876fcb3d6&quot;&gt;Obsidian&lt;/a&gt; 插件您可以自由选择使用方式。Diagram 最大限度地保护隐私，因而「安全」也是该工具一大特色。&lt;/p&gt;&lt;p&gt;Diagram 目前使用域名为 &lt;code&gt;diagrams.net&lt;/code&gt;，当然 &lt;code&gt;draw.io&lt;/code&gt; 似乎是他更为人所熟知的品牌；它是用于构建图表应用程序的开源技术堆栈，也是世界上使用最广泛的基于浏览器的最终用户图表软件。除了 Obsidian，在 Confluence 和 Jira 的 draw.io 应用程序，您也可以使用 diagrams.net 编辑器。&lt;/p&gt;&lt;p&gt;Diagram 为您提供了丰富的创建各种&lt;strong&gt;图表&lt;/strong&gt;工具，诸如：流程图、思维导图、组织结构图、维恩图、信息图表、网络和架构图、平面图、电气和机架图、UML 图等等。如果您是从事开发或专利相关工程师，涉及到各种&lt;code&gt;图表&lt;/code&gt;的制作，相信 Diagram 会提供莫大帮助。除此之外 Diagram 还提供类似 &lt;a href=&quot;https://nicelinks.site/post/5f819f32cda9de27bd93a922&quot;&gt;Excalidraw&lt;/a&gt; 白板可视化功能。Diagram 在 Github 开源： &lt;a href=&quot;https://github.com/jgraph/drawio&quot;&gt;drawio&lt;/a&gt;，已有 30K+ Star，感兴趣的朋友可以移步以了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f4f37fedc6366d5c0852e3&quot;&gt;倾城之链 - Diagram Software and Flowchart Maker&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A0%81&quot;&gt;&lt;code&gt;编码&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F%E5%BA%93&quot;&gt;&lt;code&gt;程序库&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%93%8D%E5%BA%94%E5%BC%8F&quot;&gt;&lt;code&gt;响应式&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：RxJS, Ts, toPromise, Observable, Subscription, Subscriber, RxJS Error types, Operators, Subject, Schedulers, Monad, Reactive Programming&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code. This project is a rewrite of Reactive-Extensions/RxJS with better performance, better modularity, better debuggable call stacks, while staying mostly backwards compatible, with some breaking changes that reduce the API surface&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/rxjs.dev.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - RxJS - Reactive Extensions Library for JavaScript&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/post/62f24ee6b5abd454197aa3af&quot;&gt;RxJS&lt;/a&gt; JavaScript 的反应式（响应式）编程库，它通过使用可观察（Observable）序列，来编写异步和基于事件的程序。它提供了一个核心类型 Observable，附属类型 (Observer、 Schedulers、 Subjects) 和受 Array 启发的操作符 (map、filter、reduce、every, 等等)，这些数组操作符可以把异步事件作为集合来处理。将 RxJS 视为事件的 &lt;code&gt;Lodash&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/post/62f24a6fb5abd454197aa3ad&quot;&gt;ReactiveX&lt;/a&gt; 结合了 观察者模式、迭代器模式 和 使用集合的函数式编程，以满足以一种理想方式来管理事件序列所需要的一切。RxJS（Reactive Extensions For JavaScript），是 ReactiveX 提供的在 Web 上运行的版本。在 RxJS 中用来解决异步事件管理的的基本概念是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Observable&lt;/strong&gt; (可观察对象)：表示一个概念，这个概念是一个可调用的未来值或事件的集合。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Observer&lt;/strong&gt; (观察者)：一个回调函数的集合，它知道如何去监听由 Observable 提供的值。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Subscription&lt;/strong&gt; (订阅)：表示 Observable 的执行，主要用于取消 Observable 的执行。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Operators&lt;/strong&gt; (操作符)：采用函数式编程风格的纯函数(pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Subject&lt;/strong&gt; (主体)：相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Schedulers&lt;/strong&gt; (调度器)：用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;RxJs 它在使用方式上，跟 &lt;code&gt;Promise&lt;/code&gt; 有点像，但在能力上比 &lt;code&gt;Promise&lt;/code&gt; 更加强大，不仅仅能够以流的形式，对数据进行控制，还内置诸多工具方法，让开发者十分方便的处理各种数据，，从而使得代码如丝顺滑，简洁优雅；整体而言，它能带来以下优势：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;代码量的大幅度减少；&lt;/li&gt;&lt;li&gt;代码可读性的提高；&lt;/li&gt;&lt;li&gt;很好的处理异步；&lt;/li&gt;&lt;li&gt;事件管理、调度引擎；&lt;/li&gt;&lt;li&gt;十分丰富的操作符；&lt;/li&gt;&lt;li&gt;响应式的编程风格；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;正如这世间没有完美解决问题方案一样，软件的世界&lt;code&gt;没有银弹&lt;/code&gt;：RxJs 乃至响应式编程，虽然为一些场景，提出了更为优雅的解决思路，但同样也并不完美；比如其学习成本偏高，使得很难快速流行开来（背后是深层数学理论）。但，如果您能熟练掌握，确实能大幅提升代码的简洁性、“可读性”、可扩展性。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f24ee6b5abd454197aa3af&quot;&gt;倾城之链 - RxJS - Reactive Extensions Library for JavaScript&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E7%BC%96%E7%A8%8B&quot;&gt;&lt;code&gt;编程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A8%8B%E5%BA%8F%E5%BA%93&quot;&gt;&lt;code&gt;程序库&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%93%8D%E5%BA%94%E5%BC%8F&quot;&gt;&lt;code&gt;响应式&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/reactivex.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - An API for asynchronous programming with observable streams - ReactiveX&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/post/62f24a6fb5abd454197aa3ad&quot;&gt;ReactiveX&lt;/a&gt; ，是&lt;strong&gt;响应式（反应式）编程&lt;/strong&gt;原则的一种实现，通过使用可观察序列，组成异步和基于事件的程序。使用 RX，您的代码创建并订阅名为 Observables 的数据流。虽然响应式编程是关于概念的，但 RX 为您提供了一个惊人的工具箱。通过结合&lt;em&gt;观察者&lt;/em&gt;和&lt;em&gt;迭代器模式&lt;/em&gt;以及函数式习语，RX 为您提供了超能力。您拥有一系列功能来组合、合并、过滤、转换和创建数据流。作为更棒的程序库，它具有以下优势：&lt;/p&gt;&lt;h3 id=&quot;功能性&quot;&gt;&lt;a href=&quot;#%E5%8A%9F%E8%83%BD%E6%80%A7&quot; aria-label=&quot;功能性 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;功能性&lt;/h3&gt;&lt;p&gt;避免复杂的有状态程序，在可观察的流上使用干净的输入/输出函数。&lt;/p&gt;&lt;h3 id=&quot;少即是多&quot;&gt;&lt;a href=&quot;#%E5%B0%91%E5%8D%B3%E6%98%AF%E5%A4%9A&quot; aria-label=&quot;少即是多 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;少即是多&lt;/h3&gt;&lt;p&gt;ReactiveX 的操作员经常将曾经复杂的挑战简化为几行代码。&lt;/p&gt;&lt;h3 id=&quot;异步错误处理&quot;&gt;&lt;a href=&quot;#%E5%BC%82%E6%AD%A5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86&quot; aria-label=&quot;异步错误处理 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;异步错误处理&lt;/h3&gt;&lt;p&gt;传统的 try/catch 对异步计算中的错误无能为力，但 ReactiveX 配备了适当的机制来处理错误。&lt;/p&gt;&lt;h3 id=&quot;并发变得容易&quot;&gt;&lt;a href=&quot;#%E5%B9%B6%E5%8F%91%E5%8F%98%E5%BE%97%E5%AE%B9%E6%98%93&quot; aria-label=&quot;并发变得容易 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;并发变得容易&lt;/h3&gt;&lt;p&gt;ReactiveX 中的 Observables 和 Scheduler，允许程序员抽象出低级线程、同步和并发问题。&lt;/p&gt;&lt;p&gt;值得一提的是，ReactiveX 可以说无处不在，对前端、跨平台、后端都进行了适配，并提供相对应用的工具。在 Web 上可以使用 &lt;a href=&quot;https://github.com/ReactiveX/rxjs&quot;&gt;RxJS&lt;/a&gt; （A reactive programming library for JavaScript. 已有 27.5K Star），在移动设备上使用 Rx.NET 和 RxJava 操作 UI 事件和 API 响应。在 Java 平台，支持响应式编程的流行库有 &lt;a href=&quot;https://github.com/reactor&quot;&gt;Reactor&lt;/a&gt; , &lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt; （Reactive Extensions for the JVM）, &lt;a href=&quot;https://github.com/eclipse-vertx/vert.x&quot;&gt;Vert.x&lt;/a&gt; 等，而在Java9中，实现了响应式流规范（Reactive Streams）所定义的相关接口，让Java本身支持了响应式编程，不需要通过其他三方库实现。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/post/62f24a6fb5abd454197aa3ad&quot;&gt;ReactiveX&lt;/a&gt; 是一个使用可观察（Observable）序列组成&lt;strong&gt;异步和基于事件&lt;/strong&gt;的程序的库。 它扩展了观察者模式以支持数据和/或事件序列，并添加了允许您以声明方式组合序列的运算符，同时抽象出对低级线程、同步、线程安全、并发数据结构和非阻塞 I/O。&lt;/p&gt;&lt;p&gt;它有时被称为“函数式反应式编程”（&lt;code&gt;FRP&lt;/code&gt;），但这是用词不当。ReactiveX 可能是函数式的，也可能是响应式的，但“函数式响应式编程”是另一回事。主要区别之一是函数式反应式编程对 随时间_连续_变化的值进行操作，而 ReactiveX 对随时间发出的_离散_值进行操作。&lt;/p&gt;&lt;p&gt;&lt;code&gt;ReactiveX&lt;/code&gt; 结合了&lt;strong&gt;观察者模式&lt;/strong&gt;、&lt;strong&gt;迭代器模式&lt;/strong&gt;和&lt;strong&gt;函数式编程&lt;/strong&gt;的最佳思想，您可以基于它轻松创建事件流或数据流、使用类似查询的运算符组合和转换流、订阅任何可观察的流以执行副作用；它不仅仅是一个 API，它是编程中的一个想法和突破。它启发了其他几个 API、框架，甚至编程语言。截至目前，对于函数式、响应式、声明式等编程思想，仍处于初步学习阶段，如果您从事编程开发并对这些思想感兴趣，可移步至学习中梳理的博文：&lt;a href=&quot;https://quickapp.lovejade.cn/reactive-programming-vs-responsive-web-design/&quot;&gt;响应式编程 vs 响应式系统 vs 响应式设计&lt;/a&gt;，以了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f24a6fb5abd454197aa3ad&quot;&gt;倾城之链 - An API for asynchronous programming with observable streams - ReactiveX&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B5%8F%E8%A7%88%E5%99%A8&quot;&gt;&lt;code&gt;浏览器&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%98%E7%BD%91&quot;&gt;&lt;code&gt;官网&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;跨平台&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：欧朋浏览器, 欧朋浏览器下载, 欧朋流量宝, 欧朋流量宝下载, 桌面浏览器下载, Opera桌面浏览器, PC浏览器, 苹果浏览器, 欧朋浏览器官网, 免流量, 送话费, 有奖活动&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;欧朋-全球最流行的手机浏览器。欧朋手机浏览器是一款基于云端压缩技术的全平台手机浏览器，具有速度快，体积小，超省流量等功能特点。智能手机浏览器官方下载、安卓手机浏览器下载、手机浏览器免费下载、Opera 桌面浏览器下载尽在欧朋手机浏览器官方网站。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.oupeng.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 欧朋 Opera 浏览器官方网站&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：欧朋 Opera 浏览器，是一款基于云端压缩技术的全平台浏览器（可以在 Windows、Mac 和 Linux 三个操作系统平台上运行，其姊妹浏览器 – Opera Mobile 可以运行于移动端设备）；具有速度快，体积小，超省流量等功能特点。官方在其官网给出以下特征说明：&lt;/p&gt;&lt;h3 id=&quot;轻巧体积&quot;&gt;&lt;a href=&quot;#%E8%BD%BB%E5%B7%A7%E4%BD%93%E7%A7%AF&quot; aria-label=&quot;轻巧体积 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;轻巧体积&lt;/h3&gt;&lt;p&gt;推翻传统的浏览器架构设计，提升浏览性能。1.91M 的轻巧体积，更少占用，更快下载。基于云端的扩展能力，为用户智能化提供彪悍的移动上网体验，囊括个性推荐、标签管理、断点续传下载、节省流量、视频和阅读等功能。&lt;/p&gt;&lt;h3 id=&quot;简洁设计&quot;&gt;&lt;a href=&quot;#%E7%AE%80%E6%B4%81%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;简洁设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简洁设计&lt;/h3&gt;&lt;p&gt;秉承极简的设计思路，巧妙进行 UI 布局，增加最近关闭的标签历史，贴心实现一键关闭所有页面，让你轻松从容地上网浏览。&lt;/p&gt;&lt;h3 id=&quot;节省流量&quot;&gt;&lt;a href=&quot;#%E8%8A%82%E7%9C%81%E6%B5%81%E9%87%8F&quot; aria-label=&quot;节省流量 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;节省流量&lt;/h3&gt;&lt;p&gt;关键时刻，怎能没有流量？10 年流量压缩技术积累，Opera Turbo 2.0 技术，帮你节省流量，用更少的流量浏览更多的精彩内容！&lt;/p&gt;&lt;h3 id=&quot;智能新闻-dna&quot;&gt;&lt;a href=&quot;#%E6%99%BA%E8%83%BD%E6%96%B0%E9%97%BB-dna&quot; aria-label=&quot;智能新闻 dna permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;智能新闻 DNA&lt;/h3&gt;&lt;p&gt;基于欧朋云端数据处理技术，呈现符合您阅读习惯的内容。悉数涵盖热点、时事、娱乐、体育等资讯，实时更新。&lt;/p&gt;&lt;p&gt;Opera 浏览器因为它的快速、小巧和比其他浏览器更佳的标准兼容性，获得了国际上的最终用户和业界媒体的承认，并在网上受到很多人的推崇（兼容性确实要好于 &lt;a href=&quot;https://nicelinks.site/post/5fa82652ac6b5718fc48ac10&quot;&gt;火狐&lt;/a&gt; ）。Opera 还提供很多方便的特性，包括网络同步，Wand 密码管理、会话管理、鼠标手势、键盘快捷键、内置搜索引擎、智能弹出式广告拦截、网址的过滤、浏览器识别伪装和超过 400 种，可以方便下载更换的皮肤，界面也可以在定制模式下通过拖放随意更改。桌面浏览器，就非开发者而言，除了 Chrome，Opera 给我的体验，要远好于 &lt;a href=&quot;https://nicelinks.site/post/5fa82652ac6b5718fc48ac10&quot;&gt;火狐&lt;/a&gt; 、Safari 等浏览器。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/62f106afb5abd454197aa3aa&quot;&gt;倾城之链 - 欧朋 Opera 浏览器官方网站&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;游蕲水清泉寺，寺临兰溪，溪水西流。&lt;br/&gt;山下兰芽短浸溪，松间沙路净无泥，萧萧暮雨子规啼。&lt;br/&gt;&lt;strong&gt;谁道人生无再少？门前流水尚能西！休将白发唱黄鸡&lt;/strong&gt;。&lt;br/&gt;──宋 · 苏轼 《浣溪沙·游蕲水清泉寺》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44cc1c28679b1dbdb4e00c4bef9585af</guid>
<title>抓到Netty一个Bug，顺带来透彻地聊一下Netty是如何高效接收网络连接的</title>
<link>https://toutiao.io/k/3vfg8nb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本系列Netty源码解析文章基于 &lt;strong&gt;4.1.56.Final&lt;/strong&gt;版本&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个高性能网络通讯框架来说，最最重要也是最核心的工作就是如何高效的接收客户端连接，这就好比我们开了一个饭店，那么迎接客人就是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者就来为大家介绍下netty这块最核心的内容，看看netty是如何高效的接收客户端连接的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为笔者在一个月黑风高天空显得那么深邃遥远的夜晚，闲来无事，于是捧起Netty关于如何接收连接这部分源码细细品读的时候，意外的发现了一个影响Netty接收连接吞吐的一个Bug。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是笔者就在Github提了一个&lt;span&gt;?&lt;/span&gt;Issue#11708，阐述了下这个Bug产生的原因以及导致的结果并和Netty的作者一起讨论了下修复措施。如上图所示。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先不详细解释这个Issue，也不建议大家现在就打开这个Issue查看，笔者会在本文的介绍中随着源码深入的解读慢慢的为大家一层一层地拨开迷雾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以在文章的开头把这个拎出来，笔者是想让大家带着怀疑，审视，欣赏，崇敬，敬畏的态度来一起品读世界顶级程序员编写的代码。由衷的感谢他们在这一领域做出的贡献。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，问题抛出来后，我们就带着这个疑问来开始本文的内容吧~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaYswibX4udEqDRckSCoqEWgDicedibRoE1SLdqD56zxJqxCj5LfCWPbFNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;文章概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前文回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照老规矩，再开始本文的内容之前，我们先来回顾下前边几篇文章的概要内容帮助大家梳理一个框架全貌出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者这里再次想和读者朋友们强调的是本文可以独立观看，并不依赖前边系列文章的内容，只是大家如果对相关细节部分感兴趣的话，可以在阅读完本文之后在去回看相关文章。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边的系列文章中，笔者为大家介绍了驱动Netty整个框架运转的核心引擎Reactor的创建，启动，运行的全流程。从现在开始Netty的整个核心框架就开始运转起来开始工作了，本文要介绍的主要内容就是Netty在启动之后要做的第一件事件：监听端口地址，高效接收客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中，我们是从整个网络框架的基石IO模型的角度整体阐述了下Netty的IO线程模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Netty中的Reactor正是IO线程在Netty中的模型定义。Reactor在Netty中是以Group的形式出现的，分为:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup bossGroup&lt;/code&gt;,main reactor group中的reactor主要负责监听客户端连接事件，高效的处理客户端连接。也是本文我们要介绍的重点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup workerGroup&lt;/code&gt;，sub reactor group中的reactor主要负责处理客户端连接上的IO事件，以及异步任务的执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们得出Netty的整个IO模型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们讨论的重点就是MainReactorGroup的核心工作上图中所示的步骤1，步骤2，步骤3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在从整体上介绍完Netty的IO模型之后，我们又在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中完整的介绍了Netty框架的骨架主从Reactor组的搭建过程，阐述了Reactor是如何被创建出来的，并介绍了它的核心组件如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0638516992790936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaRn9ZX4dJLJdyxSEEXojs5lEmPNiaBfstFOG95KMGibJed4vo3xMhnE6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;thread&lt;/code&gt;即为Reactor中的IO线程，主要负责监听IO事件，处理IO任务，执行异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;selector&lt;/code&gt;则是JDK NIO对操作系统底层IO多路复用技术实现的封装。用于监听IO就绪事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;taskQueue&lt;/code&gt;用于保存Reactor需要执行的异步任务，这些异步任务可以由用户在业务线程中向Reactor提交，也可以是Netty框架提交的一些自身核心的任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;scheduledTaskQueue&lt;/code&gt;则是保存Reactor中执行的定时任务。代替了原有的时间轮来执行延时任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tailQueue&lt;/code&gt;保存了在Reactor需要执行的一些尾部收尾任务，在普通任务执行完后 Reactor线程会执行尾部任务，比如对Netty 的运行状态做一些统计数据，例如任务循环的耗时、占用物理内存的大小等等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在骨架搭建完毕之后，我们随后又在在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;》一文中介绍了&lt;strong&gt;本文的主角服务端NioServerSocketChannel的创建，初始化，绑定端口地址，向main reactor注册监听&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的完整过程&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7161290322580646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaMNnpeQav9HykpMEYenDPdshUtLBMicYHd5F9HwloOsE6FfLVtGW0XRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor启动后的结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor如何处理OP_ACCEPT事件将会是本文的主要内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此Netty框架的main reactor group已经启动完毕，开始准备监听OP_accept事件，当客户端连接上来之后，OP_ACCEPT事件活跃，main reactor开始处理OP_ACCEPT事件接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而netty中的IO事件分为：OP_ACCEPT事件，OP_READ事件，OP_WRITE事件和OP_CONNECT事件，netty对于IO事件的监听和处理统一封装在Reactor模型中，这四个IO事件的处理过程也是我们后续文章中要单独拿出来介绍的，本文我们聚焦OP_ACCEPT事件的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了让大家能够对IO事件的处理有一个完整性的认识，笔者写了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;这篇文章，在文章中详细介绍了Reactor线程的整体运行框架。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor线程会在一个死循环中996不停的运转，在循环中会不断的轮询监听Selector上的IO事件，当IO事件活跃后，Reactor从Selector上被唤醒转去执行IO就绪事件的处理，在这个过程中我们引出了上述四种IO事件的处理入口函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取Channel的底层操作类Unsafe&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!k.isValid()) {&lt;br/&gt;            ......如果SelectionKey已经失效则关闭对应的Channel......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//获取IO就绪事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;            &lt;span&gt;//处理Connect事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ops = k.interestOps();&lt;br/&gt;                &lt;span&gt;//移除对Connect事件的监听，否则Selector会一直通知&lt;/span&gt;&lt;br/&gt;                ops &amp;amp;= ~SelectionKey.OP_CONNECT;&lt;br/&gt;                k.interestOps(ops);&lt;br/&gt;                &lt;span&gt;//触发channelActive事件处理Connect事件&lt;/span&gt;&lt;br/&gt;                unsafe.finishConnect();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//处理Write事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                ch.unsafe().forceFlush();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;             &lt;span&gt;//处理Read事件或者Accept事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者将会为大家重点介绍&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数&lt;code&gt;unsafe.read()&lt;/code&gt;的整个源码实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端连接完成三次握手之后，main reactor中的selector产生&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor随即被唤醒，来到了&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数开始接收客户端连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Main Reactor处理OP_ACCEPT事件&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaWfVAUiaQYd2Sebxwzf9VCWLhcbIISY1nBSug2YiaVEPewXhib8D8EUk2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;OP_ACCEPT事件活跃.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;Main Reactor&lt;/code&gt;轮询到&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;就绪时，Main Reactor线程就会从&lt;code&gt;JDK Selector&lt;/code&gt;上的阻塞轮询API&lt;code&gt;selector.select(timeoutMillis)&lt;/code&gt;调用中返回。转而去处理&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        ..............省略.................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;               ..............处理OP_CONNECT事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;              ..............处理OP_WRITE事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//本文重点处理OP_ACCEPT事件&lt;/span&gt;&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理IO就绪事件的入口函数&lt;code&gt;processSelectedKey&lt;/code&gt;中的参数&lt;code&gt;AbstractNioChannel ch&lt;/code&gt;正是Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。因为此时的执行线程为main reactor线程，而main reactor上注册的正是netty服务端NioServerSocketChannel负责监听端口地址，接收客户端连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;ch.unsafe()&lt;/code&gt;获取到的NioUnsafe操作类正是NioServerSocketChannel中对底层JDK NIO ServerSocketChannel的Unsafe底层操作类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Unsafe接口&lt;/code&gt;是Netty对Channel底层操作行为的封装，比如NioServerSocketChannel的底层Unsafe操作类干的事情就是&lt;code&gt;绑定端口地址&lt;/code&gt;，&lt;code&gt;处理OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到，Netty将&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;处理的入口函数封装在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;里的底层操作类Unsafe的&lt;code&gt;read&lt;/code&gt;方法中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaVwgSgt5AkddHoicEO9er6tOogNfpjVyMysiaZeHCCTBRolMRpG5NDs2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而NioServerSocketChannel中的Unsafe操作类实现类型为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;定义在上图继承结构中的&lt;code&gt;AbstractNioMessageChannel父类中&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法中来看下Netty对&lt;code&gt;OP_ACCPET事件&lt;/code&gt;的具体处理过程：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 接收客户端连接核心流程框架总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是按照老规矩，先从整体上把整个OP_ACCEPT事件的逻辑处理框架提取出来，让大家先总体俯视下流程全貌，然后在针对每个核心点位进行各个击破。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程是在一个&lt;code&gt;do...while{...}&lt;/code&gt;循环read loop中不断的调用JDK NIO &lt;code&gt;serverSocketChannel.accept()&lt;/code&gt;方法来接收完成三次握手的客户端连接&lt;code&gt;NioSocketChannel&lt;/code&gt;的，并将接收到的客户端连接NioSocketChannel临时保存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中，后续会服务端NioServerSocketChannel的pipeline中通过ChannelRead事件来传递，最终会在ServerBootstrapAcceptor这个ChannelHandler中被处理初始化，并将其注册到Sub Reator Group中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的read loop循环会被限定只能读取&lt;strong&gt;16次&lt;/strong&gt;，当main reactor从NioServerSocketChannel中读取客户端连接NioSocketChannel的次数达到&lt;strong&gt;16次&lt;/strong&gt;之后，无论此时是否还有客户端连接都不能在继续读取了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;一文中提到，netty对reactor线程压榨的比较狠，要干的事情很多，除了要监听轮询IO就绪事件，处理IO就绪事件，还需要执行用户和netty框架本省提交的异步任务和定时任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的main reactor线程不能在read loop中无限制的执行下去，因为还需要分配时间去执行异步任务，不能因为无限制的接收客户端连接而耽误了异步任务的执行。所以这里将read loop的循环次数限定为16次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果main reactor线程在read loop中读取客户端连接NioSocketChannel的次数已经满了16次，即使此时还有客户端连接未接收，那么main reactor线程也不会再去接收了，而是转去执行异步任务，当异步任务执行完毕后，还会在回来执行剩余接收连接的任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是Netty在接收客户端连接时的整体核心逻辑，下面笔者将这部分逻辑的核心源码实现框架提取出来，方便大家根据上述核心逻辑与源码中的处理模块对应起来，还是那句话，这里只需要总体把握核心处理流程，不需要读懂每一行代码，笔者会在文章的后边分模块来各个击破它们。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//必须在Main Reactor线程中执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;eventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;.&lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//注意下面的config和pipeline都是服务端ServerSocketChannel中的&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelConfig config = config();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = pipeline();&lt;br/&gt;            &lt;span&gt;//创建接收数据Buffer分配器（用于分配容量大小合适的byteBuffer用来容纳接收数据）&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//在接收连接的场景中，这里的allocHandle只是用于控制read loop的循环读取创建连接的次数。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;            allocHandle.reset(config);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            Throwable exception = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;//已无新的连接可接收则退出read loop&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;span&gt;//判断是否已经读满16次&lt;/span&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//在NioServerSocketChannel对应的pipeline中传播ChannelRead事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//清除本次accept 创建的客户端SocketChannel集合&lt;/span&gt;&lt;br/&gt;                readBuf.clear();&lt;br/&gt;                allocHandle.readComplete();&lt;br/&gt;                &lt;span&gt;//触发readComplete事件传播&lt;/span&gt;&lt;br/&gt;                pipeline.fireChannelReadComplete();&lt;br/&gt;                ....................省略............&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                ....................省略............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里首先要通过断言&lt;code&gt;assert eventLoop().inEventLoop()&lt;/code&gt;确保处理接收客户端连接的线程必须为Main Reactor 线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而main reactor中主要注册的是服务端NioServerSocketChannel，主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，所以当前main reactor线程是在NioServerSocketChannel中执行接收连接的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里我们通过&lt;code&gt;config()&lt;/code&gt;获取到的是NioServerSocketChannel的属性配置类&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;,它是在Reactor的启动阶段被创建出来的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理这里通过&lt;code&gt;pipeline()&lt;/code&gt;获取到的也是NioServerSocketChannel中的&lt;code&gt;pipeline&lt;/code&gt;。它会在NioServerSocketChannel向main reactor注册成功之后被初始化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLCnvGuX5Vnkyf8vov0T9bwuSrXAQAKQWoCQjzhgBbkfQ52iaDe6282Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;ServerChannelPipeline完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到main reactor线程会被限定只能在read loop中向NioServerSocketChannel读取16次客户端连接，所以在开始read loop之前，我们需要创建一个能够保存记录读取次数的对象，在每次read loop循环之后，可以根据这个对象来判断是否结束read loop。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个对象就是这里的 &lt;code&gt;RecvByteBufAllocator.Handle allocHandle&lt;/code&gt;专门用于统计read loop中接收客户端连接的次数，以及判断是否该结束read loop转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这一切准备就绪之后，main reactor线程就开始在&lt;code&gt;do{....}while(...)&lt;/code&gt;循环中接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 read loop中通过调用&lt;code&gt;doReadMessages函数&lt;/code&gt;接收完成三次握手的客户端连接，底层会调用到JDK NIO ServerSocketChannel的accept方法，从内核全连接队列中取出客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回值&lt;code&gt;localRead&lt;/code&gt;表示接收到了多少客户端连接，客户端连接通过accept方法只会一个一个的接收，所以这里的&lt;code&gt;localRead&lt;/code&gt;正常情况下都会返回&lt;code&gt;1&lt;/code&gt;，当&lt;code&gt;localRead &amp;lt;= 0&lt;/code&gt;时意味着已经没有新的客户端连接可以接收了，本次main reactor接收客户端的任务到这里就结束了，跳出read loop。开始新的一轮IO事件的监听处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将接收到的客户端连接占时存放到&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;统计本次事件循环中接收到的客户端连接个数，最后在read loop末尾通过&lt;code&gt;allocHandle.continueReading&lt;/code&gt;判断是否达到了限定的16次。从而决定main reactor线程是继续接收客户端连接还是转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop的两个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足以上两个退出条件时，main reactor线程就会退出read loop，由于在read loop中接收到的客户端连接全部暂存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中,随后开始遍历readBuf，在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//NioServerSocketChannel对应的pipeline中传播read事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor.channelRead&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终pipeline中的ChannelHandler(ServerBootstrapAcceptor)会响应ChannelRead事件，并在相应回调函数中初始化客户端NioSocketChannel，并将其注册到Sub Reactor Group中。此后客户端NioSocketChannel绑定到的sub reactor就开始监听处理客户端连接上的读写事件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty整个接收客户端的逻辑过程如下图步骤1，2，3所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是笔者提取出来的整体流程框架，下面我们来将其中涉及到的重要核心模块拆开，一个一个详细解读下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. RecvByteBufAllocator简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor在处理对应Channel上的IO数据时，都会采用一个&lt;code&gt;ByteBuffer&lt;/code&gt;来接收Channel上的IO数据。而本小节要介绍的RecvByteBufAllocator正是用来分配ByteBuffer的一个分配器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得这个&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;在哪里被创建的吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中，在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建过程中提到，对应Channel的配置类NioServerSocketChannelConfig也会随着NioServerSocketChannel的创建而创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;的过程中会创建&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到NioServerSocketChannel中的RecvByteBufAllocator实际类型为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;，顾名思义，这个类型的RecvByteBufAllocator可以根据Channel上每次到来的IO数据大小来自适应动态调整ByteBuffer的容量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于服务端NioServerSocketChannel来说，它上边的IO数据就是客户端的连接，它的长度和类型都是固定的，所以在接收客户端连接的时候并不需要这样的一个ByteBuffer来接收，我们会将接收到的客户端连接存放在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于客户端NioSocketChannel来说，它上边的IO数据时客户端发送来的网络数据，长度是不定的，所以才会需要这样一个可以根据每次IO数据的大小来自适应动态调整容量的ByteBuffer来接收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么看起来这个RecvByteBufAllocator和本文的主题不是很关联，因为在接收连接的过程中并不会怎么用到它，这个类笔者还会在后面的文章中详细介绍，之所以这里把它拎出来单独介绍是因为它和本文开头提到的Bug有关系，这个Bug就是由这个类引起的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 RecvByteBufAllocator.Handle的获取&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们是通过NioServerSocketChannel中的unsafe底层操作类来获取RecvByteBufAllocator.Handle的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractUnsafe&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Unsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; RecvByteBufAllocator.&lt;span&gt;Handle &lt;span&gt;recvBufAllocHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (recvHandle == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                recvHandle = config().getRecvByteBufAllocator().newHandle();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; recvHandle;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到最终会在NioServerSocketChannel的配置类NioServerSocketChannelConfig中获取到&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ChannelConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//用于Channel接收数据用的buffer分配器  类型为AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; RecvByteBufAllocator rcvBufAllocator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;中会创建自适应动态调整容量的ByteBuffer分配器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AdaptiveRecvByteBufAllocator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Handle &lt;span&gt;newHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HandleImpl(minIndex, maxIndex, initial);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HandleImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                  .................省略................&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;newHandle&lt;/code&gt;方法返回的具体类型为&lt;code&gt;MaxMessageHandle&lt;/code&gt;，这个&lt;code&gt;MaxMessageHandle&lt;/code&gt;里边保存了每次从&lt;code&gt;Channel&lt;/code&gt;中读取&lt;code&gt;IO数据&lt;/code&gt;的容量指标，方便下次读取时分配合适大小的&lt;code&gt;buffer&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次在使用&lt;code&gt;allocHandle&lt;/code&gt;前需要调用&lt;code&gt;allocHandle.reset(config);&lt;/code&gt;重置里边的统计指标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ExtendedHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; ChannelConfig config;&lt;br/&gt;        &lt;span&gt;//每次事件轮询时，最多读取16次&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxMessagePerRead;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的message数,这里指的是接收连接的数量&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalMessages;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalBytesRead;&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(ChannelConfig config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.config = config;&lt;br/&gt;            &lt;span&gt;//默认每次最多读取16次&lt;/span&gt;&lt;br/&gt;            maxMessagePerRead = maxMessagesPerRead();&lt;br/&gt;            totalMessages = totalBytesRead = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;maxMessagePerRead&lt;/strong&gt;：用于控制每次read loop里最大可以循环读取的次数，默认为16次，可在启动配置类&lt;code&gt;ServerBootstrap&lt;/code&gt;中通过&lt;code&gt;ChannelOption.MAX_MESSAGES_PER_READ&lt;/code&gt;选项设置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;b.group(bossGroup, workerGroup)&lt;br/&gt;  .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;MAX_MESSAGES_PER_READ&lt;/span&gt;, 自定义次数)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalMessages&lt;/strong&gt;：用于统计read loop中总共接收的连接个数，每次read loop循环后会调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;增加记录接收到的连接个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incMessagesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; amt)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            totalMessages += amt;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalBytesRead&lt;/strong&gt;：用于统计在read loop中总共接收到客户端连接上的数据大小，这个字段主要用于sub reactor在接收客户端NioSocketChannel上的网络数据用的，本文我们介绍的是main reactor接收客户端连接，所以这里并不会用到这个字段。这个字段会在sub reactor每次读取完NioSocketChannel上的网络数据时增加记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lastBytesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; bytes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            lastBytesRead = bytes;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (bytes &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                totalBytesRead += bytes;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MaxMessageHandler中还有一个非常重要的方法就是在每次read loop末尾会调用&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法来判断读取连接次数是否已满16次，来决定main reactor线程是否退出循环。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1879032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiadlS4S4GAOnWGfc4cAFuhpziasUfsEWHxBfh3nKvLNvBAFAWEAP2sJibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红框中圈出来的两个判断条件和本文主题无关，我们这里不需要关注，笔者会在后面的文章详细介绍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalMessages &amp;lt; maxMessagePerRead&lt;/code&gt;：在本文的接收客户端连接场景中，这个条件用于判断main reactor线程在read loop中的读取次数是否超过了16次。如果超过16次就会返回false，main reactor线程退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;：用于判断当客户端NioSocketChannel上的OP_READ事件活跃时，sub reactor线程在read loop中是否读取到了网络数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是RecvByteBufAllocator.Handle在接收客户端连接场景下的作用，大家这里仔细看下这个&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法退出循环的判断条件，再结合整个&lt;code&gt;do{....}while(...)&lt;/code&gt;接收连接循环体，感受下是否哪里有些不对劲？Bug即将出现~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9494949494949495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia73S7DDn065yic2ibMIJ2CB70d9VuqkWqj9ydiaAk4yDaKbHZ5Z3rlfQfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 啊哈！！Bug ! !&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18333333333333332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia1WWpXwfWKkgmhBW2wuBConIInzvqErmKhCjykxao8tPMQq4aMzRMWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netty不论是在本文中处理接收客户端连接的场景还是在处理接收客户端连接上的网络数据场景都会在一个&lt;code&gt;do{....}while(...)&lt;/code&gt;循环read loop中不断的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也都会利用在上一小节中介绍的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来记录每次read loop接收到的连接个数和从连接上读取到的网络数据大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从而在read loop的末尾都会通过&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法判断是否应该退出read loop循环结束连接的接收流程或者是结束连接上数据的读取流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是用于接收客户端连接的main reactor也好还是用于接收客户端连接上的网络数据的sub reactor也好，它们的运行框架都是一样的，只不过是具体分工不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以netty这里想用统一的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来处理以上两种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;中的&lt;code&gt;totalBytesRead&lt;/code&gt;字段主要记录sub reactor线程在处理客户端NioSocketChannel中OP_READ事件活跃时，总共在read loop中读取到的网络数据，而这里是main reactor线程在接收客户端连接所以这个字段并不会被设置。totalBytesRead字段的值在本文中永远会是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论同时有多少个客户端并发连接到服务端上，在接收连接的这个read loop中永远只会接受一个连接就会退出循环，因为&lt;code&gt;allocHandle.continueReading()方法&lt;/code&gt;中的判断条件&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;永远会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而netty的本意是在这个read loop循环中尽可能多的去接收客户端的并发连接，同时又不影响main reactor线程执行异步任务。但是由于这个Bug，main reactor在这个循环中只执行一次就结束了。这也一定程度上就影响了netty的吞吐&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们想象下这样的一个场景，当有16个客户端同时并发连接到了服务端，这时NioServerSocketChannel上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor从Selector上被唤醒，随后执行&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; { &lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:                  &lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;&lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;                            ............监听轮询IO事件.........&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    ............省略.........&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ............处理IO就绪事件.........&lt;br/&gt;                ............执行异步任务.........&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于这个Bug的存在，main reactor在接收客户端连接的这个read loop中只接收了一个客户端连接就匆匆返回了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后根据下图中这个Reactor的运行结构去执行异步任务，随后绕一大圈又会回到&lt;code&gt;NioEventLoop#run&lt;/code&gt;方法中重新发起一轮OP_ACCEPT事件轮询。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于现在还有15个客户端并发连接没有被接收，所以此时Main Reactor线程并不会在&lt;code&gt;selector.select()&lt;/code&gt;上阻塞，最终绕一圈又会回到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法的&lt;code&gt;do{.....}while()&lt;/code&gt;循环。在接收一个连接之后又退出循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我们可以在一次read loop中把这16个并发的客户端连接全部接收完毕的，因为这个Bug，main reactor需要不断的发起OP_ACCEPT事件的轮询，绕了很大一个圈子。&lt;strong&gt;同时也增加了许多不必要的selector.select()系统调用开销&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时大家在看这个&lt;span&gt;?&lt;/span&gt;Issue#11708中的讨论是不是就清晰很多了~~&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 Bug的修复&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者在写这篇文章的时候，Netty最新版本是4.1.68.final，这个Bug在4.1.69.final中被修复。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiamkpfIdsVEQRQibNvxZYJJiaTQFHvmuiasd23LH4hjLazv0W1sibvr46nkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该Bug产生的原因正是因为服务端NioServerSocketChannel（用于监听端口地址和接收客户端连接）和 客户端NioSocketChannel（用于通信）中的Config配置类混用了同一个ByteBuffer分配器&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;而导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在新版本修复中专门为服务端ServerSocketChannel中的Config配置类引入了一个新的ByteBuffer分配器&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;，专门用于服务端ServerSocketChannel接收客户端连接的场景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29596774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiav3Ks04F9n6vSaQ7UXVue9wPbIFbqyNQagBs7wgxicohYqZswtWNc8uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23548387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaC96ubib29hOP3CibOSE7tonFMkgTib9Hr0yiauIyZV5RuJic5GUQ38Fl9xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;的父类&lt;code&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/code&gt;中引入了一个新的字段&lt;code&gt;ignoreBytesRead&lt;/code&gt;，用于表示是否忽略网络字节的读取，在创建服务端Channel配置类NioServerSocketChannelConfig的时候，这个字段会被赋值为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaQJG8bYicxmmJ7mia8kjSvVTUaKeod0A0iaOczCRVgav7GibyTbDCD4AP4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当main reactor线程在read loop循环中接收客户端连接的时候。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在read loop循环的末尾就会采用从&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;中创建的&lt;code&gt;MaxMessageHandle#continueReading&lt;/code&gt;方法来判断读取连接次数是否超过了16次。由于这里的&lt;code&gt;ignoreBytesRead == true&lt;/code&gt;这回我们就会忽略&lt;code&gt;totalBytesRead == 0&lt;/code&gt;的情况，从而使得接收连接的read loop得以继续地执行下去。在一个read loop中一次性把16个连接全部接收完毕。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1588709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabJdRFibbDhoULfxwyl3njuSGPmiaw9KwAtB7hicggEYHwcUbMZe4BibEDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是对这个Bug产生的原因，以及发现的过程，最后修复的方案一个全面的介绍，因此笔者也出现在了netty 4.1.69.final版本发布公告里的thank-list中。哈哈，真是令人开心的一件事情~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaEtpEzZGwchbkWicibbjCuOujhoHFk1GrxibqAKnfVkticFu04DQX8XyWkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上对netty接收客户端连接的全流程分析和对这个Bug来龙去脉以及修复方案的介绍，大家现在一定已经理解了整个接收连接的流程框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来笔者就把这个流程中涉及到的一些核心模块在单独拎出来从细节入手，为大家各个击破~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. doReadMessages接收客户端连接&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;Failed to create a new channel from an accepted socket.&quot;&lt;/span&gt;, t);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ch.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t2) {&lt;br/&gt;                logger.warn(&lt;span&gt;&quot;Failed to close a socket.&quot;&lt;/span&gt;, t2);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;javaChannel()&lt;/code&gt;获取封装在Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;中的&lt;code&gt;JDK 原生 ServerSocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ServerSocketChannel &lt;span&gt;javaChannel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (ServerSocketChannel) &lt;span&gt;super&lt;/span&gt;.javaChannel();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;获取&lt;code&gt;JDK NIO 原生&lt;/code&gt;客户端连接&lt;code&gt;SocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步就是我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;介绍到的调用&lt;code&gt;监听Socket&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;，内核会基于&lt;code&gt;监听Socket&lt;/code&gt;创建出来一个新的&lt;code&gt;Socket&lt;/code&gt;专门用于与客户端之间的网络通信这个我们称之为&lt;code&gt;客户端连接Socket&lt;/code&gt;。这里的&lt;code&gt;ServerSocketChannel&lt;/code&gt;就类似于&lt;code&gt;监听Socket&lt;/code&gt;。&lt;code&gt;SocketChannel&lt;/code&gt;就类似于&lt;code&gt;客户端连接Socket&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们在创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候，会将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;设置为&lt;code&gt;非阻塞&lt;/code&gt;，所以这里当&lt;code&gt;ServerSocketChannel&lt;/code&gt;上有客户端连接时就会直接创建&lt;code&gt;SocketChannel&lt;/code&gt;，如果此时并没有客户端连接时&lt;code&gt;accept调用&lt;/code&gt;就会立刻返回&lt;code&gt;null&lt;/code&gt;并不会阻塞。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;          ..........省略.............&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 创建客户端NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;          .........省略.......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会根据&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept&lt;/code&gt;方法获取到&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;（用于底层真正与客户端通信的Channel），来创建Netty中的&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;SocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SocketChannel socket)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, socket);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, socket.socket());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的过程其实和之前讲的创建服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;大体流程是一样的，我们这里只对客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;和服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;在创建过程中的不同之处做一个对比。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体细节部分大家可以在回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中关于&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建的详细细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 对比NioSocketChannel与NioServerSocketChannel的不同&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1：Channel的层次不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍Reactor的创建文章中，我们提到Netty中的&lt;code&gt;Channel&lt;/code&gt;是具有层次的。由于客户端NioSocketChannel是在main reactor接收连接时在服务端NioServerSocketChannel中被创建的，所以在创建客户端NioSocketChannel的时候会通过构造函数指定了parent属性为&lt;code&gt;NioServerSocketChanel&lt;/code&gt;。并将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;封装进Netty的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Reactor启动过程中创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候&lt;code&gt;parent属性&lt;/code&gt;指定是&lt;code&gt;null&lt;/code&gt;。因为它就是顶层的&lt;code&gt;Channel&lt;/code&gt;，负责创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2：向Reactor注册的IO事件不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor注册的是&lt;code&gt;SelectionKey.OP_READ事件&lt;/code&gt;，而服务端NioServerSocketChannel向Main Reactor注册的是&lt;code&gt;SelectionKey.OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, ch, SelectionKey.OP_READ);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3: 功能属性不同造成继承结构的不同&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaibVzdgIkicOvZJL9oNdgkTWsJTKwwKr71mN9DiaY16VzdQ1dmHtguRxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaJhrEYzibyhX4xH6g502Qobny1kJrRNvgo7j0duvaw9HC2f5eXQPqoTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioServerSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioByteChannel&lt;/code&gt;，而服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioMessageChannel&lt;/code&gt;。它们继承的这两个抽象类一个前缀是&lt;code&gt;Byte&lt;/code&gt;，一个前缀是&lt;code&gt;Message&lt;/code&gt;有什么区别吗？？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;主要处理的是服务端与客户端的通信，这里涉及到接收客户端发送来的数据，而&lt;code&gt;Sub Reactor线程&lt;/code&gt;从&lt;code&gt;NioSocketChannel&lt;/code&gt;中读取的正是网络通信数据单位为&lt;code&gt;Byte&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，创建用于通信的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。这时候客户端与服务端还没开始通信，所以&lt;code&gt;Main Reactor线程&lt;/code&gt;从&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的读取对象为&lt;code&gt;Message&lt;/code&gt;。这里的&lt;code&gt;Message&lt;/code&gt;指的就是底层的&lt;code&gt;SocketChannel&lt;/code&gt;客户端连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;创建过程中的不同之处，后面的过程就一样了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在AbstractNioChannel 类中封装JDK NIO 原生的&lt;code&gt;SocketChannel&lt;/code&gt;，并将其底层的IO模型设置为&lt;code&gt;非阻塞&lt;/code&gt;，保存需要监听的IO事件&lt;code&gt;OP_READ&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为客户端NioSocketChannel创建全局唯一的&lt;code&gt;channelId&lt;/code&gt;，创建客户端NioSocketChannel的底层操作类&lt;code&gt;NioByteUnsafe&lt;/code&gt;，创建pipeline。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt;&lt;span&gt;(Channel parent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.parent = parent;&lt;br/&gt;        &lt;span&gt;//channel全局唯一ID machineId+processId+sequence+timestamp+random&lt;/span&gt;&lt;br/&gt;        id = newId();&lt;br/&gt;        &lt;span&gt;//unsafe用于底层socket的读写操作&lt;/span&gt;&lt;br/&gt;        unsafe = newUnsafe();&lt;br/&gt;        &lt;span&gt;//为channel分配独立的pipeline用于IO事件编排&lt;/span&gt;&lt;br/&gt;        pipeline = newChannelPipeline();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在NioSocketChannelConfig的创建过程中，将NioSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在Bug修复后的版本中服务端NioServerSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终我们得到的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaW2k5wARibzQC47D0ricxafnVibibz8usyYO8DIiagJObUwYIu1vS6fGW08A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. ChannelRead事件的响应&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边介绍接收连接的整体核心流程框架的时候，我们提到main reactor线程是在一个&lt;code&gt;do{.....}while(...)&lt;/code&gt;循环read loop中不断的调用&lt;code&gt;ServerSocketChannel#accept&lt;/code&gt;方法来接收客户端的连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor就会退出read loop循环，此时接收到的客户端连接NioSocketChannel暂存与&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;br/&gt;                  ........省略.........&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                  ........省略.........&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后main reactor线程会遍历&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中的NioSocketChannel，并在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLcRXsic4tugeyCbo2ZjSLhNtU09WGLEicbhFmqJBY7BDibKss8j2BTKibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRead事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终&lt;code&gt;ChannelRead事件&lt;/code&gt;会传播到&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;中，这里正是Netty处理客户端连接的核心逻辑所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;主要的作用就是初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;，并将客户端NioSocketChannel注册到&lt;code&gt;Sub Reactor Group&lt;/code&gt;中，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ServerBootstrapAcceptor 中会初始化客户端NioSocketChannel的这些属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：从Reactor组&lt;code&gt;EventLoopGroup childGroup&lt;/code&gt;，用于初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;用到的&lt;code&gt;ChannelHandler childHandler&lt;/code&gt;，以及&lt;code&gt;NioSocketChannel&lt;/code&gt;中的一些&lt;code&gt;childOptions&lt;/code&gt;和&lt;code&gt;childAttrs&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrapAcceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EventLoopGroup childGroup;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ChannelHandler childHandler;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] childOptions;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] childAttrs;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Channel child = (Channel) msg;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//向客户端NioSocketChannel的pipeline中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//添加在启动配置类ServerBootstrap中配置的ChannelHandler&lt;/span&gt;&lt;br/&gt;            child.pipeline().addLast(childHandler);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//利用配置的属性初始化客户端NioSocketChannel&lt;/span&gt;&lt;br/&gt;            setChannelOptions(child, childOptions, logger);&lt;br/&gt;            setAttributes(child, childAttrs);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;/**&lt;br/&gt;                 * 1：在Sub Reactor线程组中选择一个Reactor绑定&lt;br/&gt;                 * 2：将客户端SocketChannel注册到绑定的Reactor上&lt;br/&gt;                 * 3：SocketChannel注册到sub reactor中的selector上，并监听OP_READ事件&lt;br/&gt;                 * */&lt;/span&gt;&lt;br/&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                forceClose(child, t);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是在这里，netty会将我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;的启动示例程序中在ServerBootstrap中配置的客户端NioSocketChannel的所有属性（child前缀配置）初始化到NioSocketChannel中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&lt;span&gt;&quot;port&quot;&lt;/span&gt;, &lt;span&gt;&quot;8007&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Configure the server.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//创建主从Reactor线程组&lt;/span&gt;&lt;br/&gt;        EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        EventLoopGroup workerGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; EchoServerHandler serverHandler = &lt;span&gt;new&lt;/span&gt; EchoServerHandler();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;            b.group(bossGroup, workerGroup)&lt;span&gt;//配置主从Reactor&lt;/span&gt;&lt;br/&gt;             .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)//配置主&lt;span&gt;Reactor&lt;/span&gt;中的&lt;span&gt;channel&lt;/span&gt;类型&lt;br/&gt;             .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;SO_BACKLOG&lt;/span&gt;, 100)//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;channel&lt;/span&gt;的&lt;span&gt;option&lt;/span&gt;选项&lt;br/&gt;             .&lt;span&gt;handler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;LoggingHandler&lt;/span&gt;(&lt;span&gt;LogLevel&lt;/span&gt;.&lt;span&gt;INFO&lt;/span&gt;))//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;Channel&lt;/span&gt;-&amp;gt;&lt;span&gt;pipline&lt;/span&gt;-&amp;gt;&lt;span&gt;handler&lt;/span&gt;&lt;br/&gt;             .&lt;span&gt;childHandler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;SocketChannel&lt;/span&gt;&amp;gt;() &lt;/span&gt;{&lt;span&gt;//设置从Reactor中注册channel的pipeline&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(SocketChannel ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                     ChannelPipeline p = ch.pipeline();&lt;br/&gt;                     &lt;span&gt;//p.addLast(new LoggingHandler(LogLevel.INFO));&lt;/span&gt;&lt;br/&gt;                     p.addLast(serverHandler);&lt;br/&gt;                 }&lt;br/&gt;             });&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// Start the server. 绑定端口启动服务，开始监听accept事件&lt;/span&gt;&lt;br/&gt;            ChannelFuture f = b.bind(PORT).sync();&lt;br/&gt;            &lt;span&gt;// Wait until the server socket is closed.&lt;/span&gt;&lt;br/&gt;            f.channel().closeFuture().sync();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// Shut down all event loops to terminate all threads.&lt;/span&gt;&lt;br/&gt;            bossGroup.shutdownGracefully();&lt;br/&gt;            workerGroup.shutdownGracefully();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码中通过ServerBootstrap配置的NioSocketChannel相关属性，会在Netty启动并开始初始化&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候将&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;的创建初始化工作封装成&lt;code&gt;异步任务&lt;/code&gt;，然后在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;注册到&lt;code&gt;Main Reactor&lt;/code&gt;中成功后执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrap&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractBootstrap&lt;/span&gt;&amp;lt;&lt;span&gt;ServerBootstrap&lt;/span&gt;, &lt;span&gt;ServerChannel&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ................省略................&lt;br/&gt;&lt;br/&gt;        p.addLast(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;Channel&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Channel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = ch.pipeline();&lt;br/&gt;                ................省略................&lt;br/&gt;                ch.eventLoop().execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        pipeline.addLast(&lt;span&gt;new&lt;/span&gt; ServerBootstrapAcceptor(&lt;br/&gt;                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在经过&lt;code&gt;ServerBootstrapAccptor#chanelRead回调&lt;/code&gt;的处理之后，此时客户端NioSocketChannel中pipeline的结构为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将初始化好的客户端NioSocketChannel向Sub Reactor Group中注册，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图中的步骤3所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 向SubReactorGroup中注册NioSocketChannel&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor Group注册的流程完全和服务端NioServerSocketChannel向Main Reactor Group注册流程一样。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于服务端NioServerSocketChannel的注册流程，笔者已经在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中做出了详细的介绍，对相关细节感兴趣的同学可以在回看下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里笔者在带大家简要回顾下整个注册过程并着重区别对比客户端NioSocetChannel与服务端NioServerSocketChannel注册过程中不同的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从Sub Reactor Group中选取一个Sub Reactor进行绑定&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MultithreadEventLoopGroup&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MultithreadEventExecutorGroup&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoopGroup&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; next().register(channel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; EventExecutor &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chooser.next();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 向绑定的Sub Reactor上注册NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventExecutor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注册channel到绑定的Reactor上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; register(&lt;span&gt;new&lt;/span&gt; DefaultChannelPromise(channel, &lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ObjectUtil.checkNotNull(promise, &lt;span&gt;&quot;promise&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//unsafe负责channel底层的各种操作&lt;/span&gt;&lt;br/&gt;        promise.channel().unsafe().register(&lt;span&gt;this&lt;/span&gt;, promise);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当时我们在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的注册过程时，这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此时这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioByteUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(EventLoop eventLoop, &lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            ..............省略....................&lt;br/&gt;            &lt;span&gt;//此时这里的eventLoop为Sub Reactor&lt;/span&gt;&lt;br/&gt;            AbstractChannel.&lt;span&gt;this&lt;/span&gt;.eventLoop = eventLoop;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;/**&lt;br/&gt;             * 执行channel注册的操作必须是Reactor线程来完成&lt;br/&gt;             *&lt;br/&gt;             * 1: 如果当前执行线程是Reactor线程，则直接执行register0进行注册&lt;br/&gt;             * 2：如果当前执行线程是外部线程，则需要将register0注册操作 封装程异步Task 由Reactor线程执行&lt;br/&gt;             * */&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (eventLoop.inEventLoop()) {&lt;br/&gt;                register0(promise);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    eventLoop.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                            register0(promise);&lt;br/&gt;                        }&lt;br/&gt;                    });&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    ..............省略....................&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意此时传递进来的EventLoop eventLoop为Sub Reactor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但此时的执行线程为&lt;code&gt;Main Reactor线程&lt;/code&gt;，并不是Sub Reactor线程（此时还未启动）&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的&lt;code&gt;eventLoop.inEventLoop()&lt;/code&gt;返回的是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiazIA5weroZkxOLyqsUBrN8Q1XP3NM5vBsFVdZXIGz1Il7FPprdZ4TNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;else分支&lt;/code&gt;中向绑定的Sub Reactor提交注册&lt;code&gt;NioSocketChannel&lt;/code&gt;的任务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当注册任务提交后，此时绑定的&lt;code&gt;Sub Reactor线程&lt;/code&gt;启动。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 register0&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们又来到了Channel注册的老地方&lt;code&gt;register0方法&lt;/code&gt;。在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中我们花了大量的篇幅介绍了这个方法。这里我们只对比&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;不同的地方。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register0&lt;/span&gt;&lt;span&gt;(ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ................省略..................&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; firstRegistration = neverRegistered;&lt;br/&gt;                &lt;span&gt;//执行真正的注册操作&lt;/span&gt;&lt;br/&gt;                doRegister();&lt;br/&gt;                &lt;span&gt;//修改注册状态&lt;/span&gt;&lt;br/&gt;                neverRegistered = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                registered = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                pipeline.invokeHandlerAddedIfNeeded();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        beginRead();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                 ................省略..................&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;doRegister()方法&lt;/code&gt;将NioSocketChannel注册到Sub Reactor中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRegister&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; selected = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException e) {&lt;br/&gt;                ...............省略...............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是Netty客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;与JDK NIO 原生 SocketChannel关联的地方。此时注册的&lt;code&gt;IO事件&lt;/code&gt;依然是&lt;code&gt;0&lt;/code&gt;。目的也是只是为了获取NioSocketChannel在Selector中的&lt;code&gt;SelectionKey&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时通过&lt;code&gt;SelectableChannel#register&lt;/code&gt;方法将Netty自定义的NioSocketChannel（这里的this指针）附着在SelectionKey的attechment属性上，完成Netty自定义Channel与JDK NIO Channel的关系绑定。这样在每次对Selector进行IO就绪事件轮询时，Netty 都可以从 JDK NIO Selector返回的SelectionKey中获取到自定义的Channel对象（这里指的就是NioSocketChannel）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42258064516129035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaBHZIoOsiaAmdqQxwtXvIIgHxoYrpp2AeUMs5qEla9BoHU4wkg4Sgjqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;channel与SelectionKey对应关系.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后调用&lt;code&gt;pipeline.invokeHandlerAddedIfNeeded()&lt;/code&gt;回调客户端NioSocketChannel上pipeline中的所有ChannelHandler的&lt;code&gt;handlerAdded方法&lt;/code&gt;，此时&lt;code&gt;pipeline&lt;/code&gt;的结构中只有一个&lt;code&gt;ChannelInitializer&lt;/code&gt;。最终会在&lt;code&gt;ChannelInitializer#handlerAdded&lt;/code&gt;回调方法中初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;C&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Channel&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlerAdded&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ctx.channel().isRegistered()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (initChannel(ctx)) {&lt;br/&gt;                &lt;span&gt;//初始化工作完成后，需要将自身从pipeline中移除&lt;/span&gt;&lt;br/&gt;                removeState(ctx);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(C ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于对Channel中pipeline的详细初始化过程，对细节部分感兴趣的同学可以回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时客户端NioSocketChannel中的pipeline中的结构就变为了我们自定义的样子，在示例代码中我们自定义的&lt;code&gt;ChannelHandler&lt;/code&gt;为&lt;code&gt;EchoServerHandler&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaTdUsySmibYW5g2lI0f8hN484CkfWrAjns8jib4vPJfrta5gpuxH5lyvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Sharable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServerHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ctx.write(msg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelReadComplete&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        ctx.flush();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exceptionCaught&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Throwable cause)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Close the connection when an exception is raised.&lt;/span&gt;&lt;br/&gt;        cause.printStackTrace();&lt;br/&gt;        ctx.close();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端NioSocketChannel中的pipeline初始化完毕后，netty就开始调用&lt;code&gt;safeSetSuccess(promise)方法&lt;/code&gt;回调&lt;code&gt;regFuture&lt;/code&gt;中注册的&lt;code&gt;ChannelFutureListener&lt;/code&gt;，通知客户端NioSocketChannel已经成功注册到Sub Reactor上了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;               childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在服务端NioServerSocketChannel注册的时候我们会在listener中向Main Reactor提交&lt;code&gt;bind绑定端口地址任务&lt;/code&gt;。但是在&lt;code&gt;NioSocketChannel&lt;/code&gt;注册的时候，只会在&lt;code&gt;listener&lt;/code&gt;中处理一下注册失败的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sub Reactor线程通知ChannelFutureListener注册成功之后，随后就会调用&lt;code&gt;pipeline.fireChannelRegistered()&lt;/code&gt;在客户端NioSocketChannel的pipeline中传播&lt;code&gt;ChannelRegistered事件&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaAGdSxbwsoLP3mhiaKahLtKrMRdE9IXvMOyxgInz5UweSSrv8H9HwNKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRegister事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者重点要强调下&lt;/strong&gt;，在之前介绍NioServerSocketChannel注册的时候，我们提到因为此时NioServerSocketChannel并未绑定端口地址，所以这时的NioServerSocketChannel并未激活，这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;。&lt;code&gt;register0方法&lt;/code&gt;直接返回。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端NioServerSocketChannel判断是否激活的标准为端口是否绑定成功。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; isOpen() &amp;amp;&amp;amp; javaChannel().socket().isBound();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;判断是否激活的标准为是否处于&lt;code&gt;Connected状态&lt;/code&gt;。那么显然这里肯定是处于&lt;code&gt;connected状态&lt;/code&gt;的。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = javaChannel();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ch.isOpen() &amp;amp;&amp;amp; ch.isConnected();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NioSocketChannel&lt;/code&gt;已经处于&lt;code&gt;connected状态&lt;/code&gt;，这里并不需要绑定端口，所以这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;           &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;/**&lt;br/&gt;                     * 客户端SocketChannel注册成功后会走这里，在channelActive事件回调中注册OP_READ事件&lt;br/&gt;                     * */&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        .......省略..........&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用&lt;code&gt;pipeline.fireChannelActive()&lt;/code&gt;在NioSocketChannel中的pipeline传播&lt;code&gt;ChannelActive事件&lt;/code&gt;，最终在&lt;code&gt;pipeline&lt;/code&gt;的头结点&lt;code&gt;HeadContext&lt;/code&gt;中响应并注册&lt;code&gt;OP_READ事件&lt;/code&gt;到&lt;code&gt;Sub Reactor&lt;/code&gt;中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaDWO56Rib0H2YViadZkbq3WErIBg6duwk22WMHcnt41ZWlS9WTtaYbcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelActive事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{ {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBeginRead&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        ..............省略................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps = selectionKey.interestOps();&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 1：ServerSocketChannel 初始化时 readInterestOp设置的是OP_ACCEPT事件&lt;br/&gt;         * 2：SocketChannel 初始化时 readInterestOp设置的是OP_READ事件&lt;br/&gt;         * */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; readInterestOp) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//注册监听OP_ACCEPT或者OP_READ事件&lt;/span&gt;&lt;br/&gt;            selectionKey.interestOps(interestOps | readInterestOp);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里的&lt;code&gt;readInterestOp&lt;/code&gt;为客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;在初始化时设置的&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Netty中的&lt;code&gt;Main Reactor&lt;/code&gt;接收连接的整个流程，我们就介绍完了，此时Netty中主从Reactor组的结构就变为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5040322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabSEUJ3uzXNIS7OGAbpeQ3ib7ZoCM6RlzjglPlzJ4Pud3L0oWSzN0iaAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;主从Reactor组完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;处理客户端连接事件的整个过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接收连接的整个处理框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;影响Netty接收连接吞吐的Bug产生的原因，以及修复的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建并初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;向&lt;code&gt;Sub Reactor&lt;/code&gt;注册的过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中我们也对比了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;与&lt;code&gt;NioSocketChannel&lt;/code&gt;在创建初始化以及后面向&lt;code&gt;Reactor&lt;/code&gt;注册过程中的差异之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;接收完毕并向&lt;code&gt;Sub Reactor&lt;/code&gt;注册成功后，那么接下来&lt;code&gt;Sub Reactor&lt;/code&gt;就开始监听注册其上的所有客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;OP_READ事件&lt;/code&gt;，并等待客户端向服务端发送网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面&lt;code&gt;Reactor&lt;/code&gt;的主角就该变为&lt;code&gt;Sub Reactor&lt;/code&gt;以及注册在其上的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章，我们将会讨论Netty是如何接收网络数据的~~~~ 我们下篇文章见~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ae19c24ea1c5082ed5e4c49fb83dc7a4</guid>
<title>开源kv引擎nutsdb v0.10.0发布以及背后故事</title>
<link>https://toutiao.io/k/xrpkb3u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是太白。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章主要是来说明下NutsDB v0.10.0发布的情况以及背后的故事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击下方👇🏻 关注本公众号&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5OTcwNDc5Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4x9eqg3nPicpPPwX5QicW5GH0GDjvnLvCTOBOBqXvBDElILDVzRne2QibNY0DIV2Sg0FweAFze3K0aBog/0?wx_fmt=png&quot; data-nickname=&quot;太白技术&quot; data-alias=&quot;taibai_tech&quot; data-signature=&quot;关键词：Go语言、微服务、架构、开源项目。欢迎关注。&quot; data-from=&quot;1&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;NutsDB的项目地址&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;本次v0.10.0发布的主要改动&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1、bug的修复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2、新功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3、重构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4、单测&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;5、文档&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;整个v0.10.0的迭代的始末&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;新的proposol &lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;nutsdb v0.11.0提议&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;nutsweb v0.1.0提议&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;招募开发者&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;加群&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NutsDB的项目地址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/nutsdb/nutsdb， 欢迎star关注我们。目前项目已经累计了2300+star。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要使用场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;嵌入式应用，用于存储定时间段的数据（已有人用在生产）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储Meta信息（例子：https://github.com/cloud-barista/cb-store）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加密存储（例子：https://github.com/jrapoport/chestnut）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地队列（已有人用在生产）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;github上统计的依赖nutsdb的开源项目：https://github.com/nutsdb/nutsdb/network/dependents?package_id=UGFja2FnZS0yMjY0ODU0MDM5&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;本次v0.10.0发布的主要改动&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢参与贡献的小伙伴，我把相关PR（#PR编号）贡献的小伙伴的github名放在后面了（类似@xxx）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次改动主要分以下几类（详见：https://github.com/nutsdb/nutsdb/issues/193）：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、bug的修复&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;list数据结构count为负号的边界处理（#183）@andrewhzy&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、新功能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持 LRemByIndex API (#174) @NailCui&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加 LKeys SKeys ZKeys API。这个特性支持对key做正则匹配，可以非常方便的扫描出你需要的key，*支持全量的扫描，非常实用。（#175） @NailCui&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加 Iterator API (HintKeyAndRAMIdxMode 和 HintKeyValAndRAMIdxMode这两个模式下支持)，之前的range支持是对扫描结果返回，这次外国小哥带来了迭代器的方式。（#191）@zeina1i&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、重构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;graceful options parameters。使用选项模式（#185）@Nailcui&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、单测&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Add rwmanager fileio test（#170） @zeina1i&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Improve code coverage about list (#183) @andrewhzy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Test coverage improvement for inmemory (#187) @andrewhzy&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、文档&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt; A few corrections in ReadME file (#171) @kwakubiney&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;整个v0.10.0的迭代的始末&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、首先会发起一个proposal，即一些提议&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5003790750568613&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4xibXcARf4gL9zMFEtmia6z8LL8tlf8Bzib65gBSAlVbJg4jZfBQAQhTiaoNw4ONRfYkgRMvnXjWsC759A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2638&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、然后发起报名&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8646998982706002&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4xibXcARf4gL9zMFEtmia6z8LL1cOib2nJzWV1vt8fztmz7I0SZbia9r61rd8v4H4SbkzByMBMqx5pkibVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1966&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、报名之后领取相应的任务来做&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报名的人员，我们会在每周发起一次讨论，主要是同步下进度和遇到的问题等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个过程是透明和可追溯的，所以自己的贡献，别人都看得到的，不要吝啬你的贡献哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;新的 proposal&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次提议2个部分：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nutsdb v0.11.0提议&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;v0.11.0马上也要开始了，proposal的issue已经建立（https://github.com/nutsdb/proposal/issues/4），有兴趣的可以直接在issue中回复报名，或者加群联系我报名参与。后面会根据实际情况做调整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度：单测类 &amp;lt; 功能类 &amp;lt; 性能类（可以按照自己的情况来选择）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、单测类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提高单测覆盖率，接着v0.10.0版本的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明下关于第一点的覆盖率，可以多人同时报名参与，因为需要拆分下。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、功能类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前open的issue挑选一些，方便落地的&amp;amp;也准备了一些有难度的可选，https://github.com/nutsdb/nutsdb/issues&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内存模式相比非内存模式，有一些功能缺失比如：内存模式下没有PrefixScan nutsdb#188&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加支持IterateBuckets正则匹配（可视化项目需要） Add support for IterateBuckets regularized matching nutsdb#194&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HintBPTSparseIdxMode支持正向迭代（较难，可选）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HintKeyValAndRAMIdxMode、HintKeyAndRAMIdxMode 支持反向迭代（较难，可选）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、性能类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于有人提出提高db的启动时间（可选）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;nutsweb v0.1.0提议&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nutsweb项目争取0.1.0版本能实现基础的查询功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nutsweb这个项目（https://github.com/nutsdb/nutsweb）主要是对nutsdb提供可视化的能力和nutshttp（https://github.com/nutsdb/nutshttp，提供nutsdb http访问的能力）配合使用。目前有一个PR（#1）初始化项目（init project with Vite + React + TypeScript）） @jukanntenn贡献的。希望能招募到人，开发v0.1.0。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;招募开发者&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前NutsDB开发者群有30人了（这里面都是意向开发者或者能提供宝贵意见的人）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;贡献方向：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、数据库引擎方向&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、工具生态如cli、可视化工具等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、单测覆盖率、文档建设等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NutsDB发展还很早期，等你的加入，希望你有热情，有意愿，有学习力，有开源精神，愿意贡献项目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;加群&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个群主要交流Go语言&amp;amp;nutsdb&amp;amp;其他技术相关的。如果二维码过期，请访问这个链接（https://github.com/nutsdb/nutsdb/issues/116），里面有最新的二维码&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2933526011560694&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4xibXcARf4gL9zMFEtmia6z8LLT3nIlPOuFxDANBfb2StTvmMuUbYEbwy1icCNLP1YkyxoxuUVmwPOB8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;span&gt;     &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;让我看到你的头像，谢谢！&lt;/p&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>