<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ead64aee4295f11b07d15f5eaba76f34</guid>
<title>Redis高可用方案</title>
<link>https://toutiao.io/k/3hh68yl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;鉴于上一篇文章提出了，&lt;/span&gt;&lt;span&gt;Redis的性能瓶颈在于内存和网络IO上&lt;/span&gt;&lt;span&gt;，针对内存上的性能瓶颈，Redis总共采用了三种技术方案，分别是&lt;/span&gt;&lt;span&gt;增加内存&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;内存淘汰策略&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;集群&lt;/span&gt;&lt;span&gt;。集群不仅解决了&lt;/span&gt;&lt;span&gt;内存瓶颈&lt;/span&gt;&lt;span&gt;还是提供了&lt;/span&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;分布式&lt;/span&gt;&lt;span&gt;性能。Redis高可用方案从演变的过程大致分为三种，分别是&lt;/span&gt;&lt;span&gt;主从复制模式&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;哨兵模式&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;集群模式&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;众所周知，单机模式下，如果Redis服务器出现故障，内存中的数据将不复存在，而对应的客户端请求都将打到数据库服务器上，当访问量非常大的情况下，数据库服务器是会崩的。虽然Redis服务恢复了正常，可以通过RDB和AFO从磁盘中恢复数据，但是如果磁盘出现了故障，数据仍旧是不可用的，并且，在单机模式下，读写是不分离的，大量的请求也会出现IO性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果同一个&lt;span&gt;数据&lt;/span&gt;服务器部署到多台机器上，当一台机器宕机，只要有一个机器仍旧可用就不会影响正常使用。这也正是Redis最初想到的高可用性能方案之一主从复制模式。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、主从复制模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从复制模式就是让一个服务器去复制另一个服务器。我们称被复制的服务器叫&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;，而对主服务器进行复制的服务器叫&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;106&quot; data-backw=&quot;380&quot; data-ratio=&quot;0.2789473684210526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uNBJjalgSkSHTYT93rsvSmwoYxxicN0fliciaWqksxvYL7FHTs9EgKqFXiaZ1NxmITWmkljtUTYH7SC6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Redis的复制功能分为两个部分：&lt;/span&gt;&lt;span&gt;同步&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;命令传播&lt;/span&gt;&lt;span&gt; 两个操作&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;当客户端向从服务器发送异步SLAVEOF命令，就意味着让从服务器复制一个主服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;同步&lt;/span&gt;&lt;span&gt;，在&lt;/span&gt;&lt;span&gt;Redis2.8版本开始使用了&lt;/span&gt;&lt;span&gt;PSYNC&lt;/span&gt;&lt;span&gt;命令替代了2.8版本之前的&lt;/span&gt;&lt;span&gt;SYNC&lt;/span&gt;&lt;span&gt;命令，用来执行复制时的同步操作。PSYNC的命令具有&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;两种模式。而SYNC仅支持完整重同步。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;命令传播&lt;/span&gt;&lt;span&gt;，在执行同步完成之后，主从服务器两者的数据达到一致的状态，此时主服务器只需要将自己执行的写命令发送给从服务器，而从服务器只需要一直执行主服务器发来的写命令就可以保证主从服务器的一致性了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/span&gt;：&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;心跳检测&lt;/span&gt;&lt;/span&gt;，在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令&lt;/span&gt;&lt;span&gt;REPLCONF ACK 偏移量&lt;/span&gt;&lt;span&gt; 。主要有三个作用，分别是&lt;/span&gt;&lt;span&gt;检测网络连接状态、辅助实现min-slaves选项、检测命令丢失&lt;/span&gt;&lt;span&gt;。主要是为了保证数据能够安全同步到从服务器并且保证数据状态一致不丢失。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;：它适用于&lt;/span&gt;&lt;span&gt;初次&lt;/span&gt;&lt;span&gt;复制情况，主要是通过让主服务器&lt;/span&gt;&lt;span&gt;创建并发送RDB文件&lt;/span&gt;&lt;span&gt;，以及向从服务器发送保存&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;缓&lt;/span&gt;&lt;span&gt;冲区&lt;/span&gt;&lt;span&gt;里面的写命令来进行同步。&lt;/span&gt;&lt;span&gt;（缓&lt;/span&gt;&lt;span&gt;冲区，是因为在发送RDB的同时，有新的写命令过来，而不在RDB文件中的那一部分命令）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;部分重同步：&lt;/span&gt;&lt;span&gt;它适用于&lt;/span&gt;&lt;span&gt;断线后&lt;/span&gt;&lt;span&gt;的重复制情况，当服务器断线后重新连接了主服务器。如果条件允许，主服务器可以将主服务器&lt;/span&gt;&lt;span&gt;连接断开期间&lt;/span&gt;&lt;span&gt;所执行的写命令发送给从服务器。从服务器只需要接收并执行这些命令即可，就可以将数据库更新至主服务器当前所处的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;1、PSYNC和SY&lt;/span&gt;&lt;span&gt;NC&lt;/span&gt;&lt;span&gt;同步有什么区别呢？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PSYNC和SYNC同步的区别主要在于，PSYNC支持部分重同步，而SYNC的每次同步都是由主服务器全量的创建并传递RDB文件给从服务器，非常占用网络资源和从服务器导入时的阻塞时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、部分重同步有什么特点呢？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器和从服务器分别维护一个复制偏移量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记同步的进度，偏移量相同则完全同步，偏移量不相同则数据未处于一致状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器的复制&lt;span&gt;积&lt;/span&gt;压缓冲区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）主服务器的复制&lt;span&gt;积&lt;/span&gt;压缓冲区里面会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的&lt;/span&gt;&lt;span&gt;复制偏移量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）通过偏移量，可以得知从服务器所丢失的数据是否在积压缓冲区中，如果存在则进行&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;，如果不存在则进行&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器的运行ID&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）从服务器初次复制主服务器数据时，主服务器会将自己的运行ID传递给从服务器，而从服务器会存储起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）如果从服务器断电后，重新连接上一个主服务器，它会将之前存储的运行ID传递过去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;span&gt;3）如果发送的运行ID和当前连接的服务器运行ID相同，则主服务器可以执行&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;操作。否则进行&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、主从模式的优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、哨兵模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵是实现Redis高可用的解决方案，它是由一个或多个哨兵实例组成的系统。它可以&lt;/span&gt;&lt;span&gt;监视&lt;/span&gt;&lt;span&gt;任意多个&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;以及属下的&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;。当主服务器进入下线状态，它将从下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器替代已下线的服务器继续处理命令请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;382&quot; data-backw=&quot;499&quot; data-ratio=&quot;0.7655310621242485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uNxohrLo4cB3447SqeISI4j6PppQLCrVYBgn8tYaRzBGuxTnfAAhBmnHcaTKJaanvtPagvibmexMHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，哨兵的核心还是&lt;/span&gt;&lt;span&gt;主从复制模式&lt;/span&gt;&lt;span&gt;，只是在主服务器下线时多了一个监听的对象，并通过哨兵系统实现了竞选机制，从主服务器下属的从服务器中选择一个最优质的作为新的主服务器。&lt;/span&gt;&lt;span&gt;哨兵系统也是有多个哨兵实例组成的，所以哨兵本身也是会出现单点故障，哨兵实例之间也会相互监视。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、启动并初始化哨兵&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵其实就是一个运行在特殊模式下的redis服务器，和普通服务器不同的是，它不会加载RDB或AOF文件，因为哨兵的执行工作和普通服务器执行的工作不同，所以初始化的过程并不完全相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵状态中的masters字典结构中记录了所有被哨兵监视的主服务器的信息，字典的键是主服务器的名字，字典的值是被监视主服务器对应的实例结构，这个实例可以是&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;又或者是一个&lt;/span&gt;&lt;span&gt;哨兵&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、创建连向主服务器的网络连接&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初始化哨兵之后，会创建连向被监视的主服务器的网络连接，哨兵将成为主服务器的客户端。哨兵会创建两个连向主服务器的异步网络连接。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;命令连接&lt;/span&gt;&lt;span&gt;，用于向主服务器发送命令，并接受命令回复&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;订阅连接&lt;/span&gt;&lt;span&gt;，用于订阅主服务器_sentinel_:hello频道&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这两个连接主要是为了防止不丢失&lt;span&gt;_sentinel_:hello频道信息，另一方面是用来和主服务器发送命令来进行通信，以及哨兵还必须向主服务器创建命令连接。哨兵需要和多个实例创建网络连接，所以哨兵使用的是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;异步连接&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、获取主服务器信息&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔10s向master和 slave发送info命令。作用是获&lt;/span&gt;&lt;span&gt;取当前数据库信息&lt;/span&gt;&lt;span&gt;，比如发现新增从节点时，会建立连接，并加入到监控列表中，当主从数据库的角色发生变化进行信息更新。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔2s向主数据里和从数据库的_sentinel_:hello频道发送自己的信息。作用是将自己的&lt;/span&gt;&lt;span&gt;监控数据和哨兵分享&lt;/span&gt;&lt;span&gt;。每个哨兵会订阅数据库的_sentinel:hello频道，当其他哨兵收到消息后，会判断该哨兵是不是新的哨兵，如果是则将其加入哨兵列表，并建立连接。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔1s向所有主从节点和所有哨兵节点发送ping命令，作用是&lt;/span&gt;&lt;span&gt;监控节点是否存活&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、主观下线和客观下线&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵节点发送ping命令时，当超过一定时间(down-after-millisecond)后，如果节点未回复，则哨兵认为&lt;/span&gt;&lt;span&gt;主观下线&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主观下线表示当前哨兵认为该节点已经下线，如果该节点为主数据库，哨兵会进一步判断是否需要进行故障切换，这时候就要发送命令询问其他哨兵节点是否认为该主节点是主观下线，当其他哨兵那里接收到了足够数量（quorum）的已下线判断之后，哨兵就会认为是&lt;/span&gt;&lt;span&gt;客观下线&lt;/span&gt;&lt;span&gt;，并对主服务器执行&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、故障转移操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选举领头哨兵&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选举从服务器优先级最高的服务器，优先级可以通过slave-priority配置&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优先级相同，则通过复制偏移量越大优先级越高&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果以上条件都相同，则选出运行id最小的从数据库&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选出从数据库后，哨兵通过slave no one命令升级为主服务器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后发送slaveof 命令将其他从节点的主数据库设置为新的主数据库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、哨兵优缺点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;始终只有一台主服务器处理请求，写操作受到单机的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;仍旧复用主从模式，所有从节点的数据都是全量的费内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器故障，在选举的过程中，服务器会开启保护机制禁止写操作，影响客户端的正常使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、集群模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群是Redis提供的&lt;/span&gt;&lt;span&gt;分布式数据库&lt;/span&gt;&lt;span&gt;方案，相当于每台redis服务器上存储不同的数据，实现了&lt;/span&gt;&lt;span&gt;数据解耦&lt;/span&gt;&lt;span&gt;，同时解决了Redis容量有限的问题。集群通过分片来进行&lt;/span&gt;&lt;span&gt;数据共享&lt;/span&gt;&lt;span&gt;，采用&lt;/span&gt;&lt;span&gt;多主多从&lt;/span&gt;&lt;span&gt;模式，并提供&lt;/span&gt;&lt;span&gt;复制&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;功能。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;集群关键词&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;节点、槽指派、命令执行、重新分片、转向、故障转移、消息&lt;/span&gt;&lt;span&gt;等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、节点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span&gt;就是一个运行在集群模式下的&lt;/span&gt;&lt;span&gt;Redis服务器&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;它会继续使用所有在单机模式中使用服务器组件&lt;/span&gt;&lt;span&gt;。比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件事件处理器处理命令请求和返回数据&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;时间事件处理器执行serverCron函数，而&lt;span&gt;serve&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;Cron函数会调用集群模式下的clusterCron函数。c&lt;span&gt;lusterCron&lt;/span&gt;&lt;span&gt;函数主要负责执行集群模式下给其他节点发送Gossip消息，检查节点是否断线，以及自动故障转移等&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用数据库保存键值对数据。RDB持久化以及AOF持久化。发布与订阅模式。复制模块等进行节点的复制工作，以及Lua脚本环境执行客户端输入的Lua脚本。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;节点会继续使用redisServer结构存储服务器状态，继续使用redisClient结构保存客户端状态，以及集群模式下的clusterNode结构存储集群模式下用到的数据以及节点的当前状态（节点的创建时间、名字、当前配置纪元、节点的Ip地址、端口号等等）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;节点和单机&lt;/span&gt;&lt;span&gt;服务器的&lt;/span&gt;&lt;span&gt;一个区别是，&lt;/span&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;只能使用&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;0号数据库&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;，而单机&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;&lt;span&gt;没有这个限制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、槽指派&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;分片&lt;/span&gt;&lt;span&gt;的方式来&lt;/span&gt;&lt;span&gt;存储&lt;/span&gt;&lt;span&gt;数据库中的&lt;/span&gt;&lt;span&gt;键值对&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;集群的整个数据被分为16384个槽&lt;/span&gt;&lt;span&gt;。数据库中的每个键都属于16384个槽的其中一个。集群中的每个节点可以处理0个或最多16384个槽。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库中的16384个&lt;/span&gt;&lt;span&gt;槽&lt;/span&gt;&lt;span&gt;都有&lt;/span&gt;&lt;span&gt;被节点处理&lt;/span&gt;&lt;span&gt;时，集群才处于&lt;/span&gt;&lt;span&gt;在线状态&lt;/span&gt;&lt;span&gt;，否则处于&lt;/span&gt;&lt;span&gt;下线状态&lt;/span&gt;&lt;span&gt;。将槽指派分配给节点的命令是：CLUSTER ADDSLOTS 槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个节点处理哪些槽也都记录在&lt;span&gt;clusterNode结构体中。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;槽指派主要是使用结构体中的slots（一个二进制位数组）存储。&lt;/span&gt;&lt;span&gt;当前节点不仅将槽指派存储在结构体中，它还通过消发送给其他节点告知它们我处理了哪些槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，数据库中的16384个槽都进行了指派之后，集群就处于&lt;/span&gt;&lt;span&gt;上线状态&lt;/span&gt;&lt;span&gt;，此时，客户端就可以向集群中的节点&lt;/span&gt;&lt;span&gt;发送数据命令&lt;/span&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、命令执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、重新分片&amp;amp;转向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群的&lt;/span&gt;&lt;span&gt;重新分片&lt;/span&gt;&lt;span&gt;可以将某个节点（源节点）的槽指派给另一个节点（目标节点）。同时该槽的键值对也会移动到目标节点。重新分片可以在线操作，集群不需要下线，也不影响两个节点的正常工作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重新分片是通过Redis集群管理软件redis-trib负责执行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASK错误&lt;/span&gt;&lt;span&gt;，如果在&lt;/span&gt;&lt;span&gt;重新分片的过程中遇到了键的命令请求，可能会触发ASK错误&lt;/span&gt;&lt;span&gt;。类似于MOVED错误，ASK错误也是会被隐藏的，并返回目标分片ip和端口号。而对于集群模式下的redis-cli接收到ASK错误，也不会打印错误，而是根据返回的ip+端口号直接转向。若想看到ASK错误，可以在单机模式的redis-cli客户端下访问。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASK错误和MOVED错误都会导致客户端转向，但是它们也是有区别的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5、故障转移&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Redis集群中的节点分为主节点和从节点，主节点用于处理槽，而从节点则用于复制主节点。若主节点下线，则从从节点中选择优质节点替代已下线的主节点。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;集群中的每个节点都会定期向其他节点发送ping消息，用来检测对方是否在线。如果对方没有在规定的时间内返回pong，则发送ping的节点可以认为对方疑似下线。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在一个集群里面，半数以上的负责处理槽的主节点都发现某个主节点都疑似下线，那么这个主节点将被标记为下线。将主节点标记为下线的其他主节点并向集群广播主节点下线的消息。所有收到消息的节点都会立即将那个主节点标记为已下线。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个从节点发现自己复制的主节点下线了，则进行&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;选举新的主节点（详细请查阅资料）&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;被选中的从节点会执行 slaveof on one 命令，成为新的主节点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新的主节点会撤销所有对已下线主节点的槽指派，并将槽全部指向自己&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新的主节点向集群广播一条pong消息，告知其他主节点和从节点，自己已成为新的主节点之一，并且接管了已下线的节点所负责的槽。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6、消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;集群中的各个节点通过发送和接收消息来进行通信。节点发送的消息主要有以下5种。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MEET消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PING消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PONG消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;FAIL消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PUBLISH消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意：一条消息由&lt;/span&gt;&lt;span&gt;消息头&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;消息正文&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、拓展&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Codis代理：https://developer.aliyun.com/article/848655&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Twemproxy代理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、参考来源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《Redis设计与实现》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/Seky_fei/article/details/107239765&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;578&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uNE2jbQicbpwrWbzt4yCuXsolw0UEM7wZRXB1Rl8vvAJzbNsaQc7llGM2RQmT0TEJD94GARMRFUQvQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.271585557299843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uOnC8YBW9UGogSXeaGKoIibSDV6rg2FnuL671lPX6ibOEBOcNuvPqxyhqxlWicyf8dcraK579G8FWzrg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff354f8cb1e2a1da4d94f89c1306738d</guid>
<title>使用 ELK 收集日志</title>
<link>https://toutiao.io/k/mollir5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在当前分布式、微服务架构下，各个应用都部署在不同的服务器上，每个应用都在记录着自己重要或者不重要的日志信息。当我们要通过日志信息来排查错误时，可以根据出错应用在对应的机器上找报错相关的日志信息。但是，可能我们不具有相应服务器的访问权限，也可能相同的应用部署在多台服务器上，导致根本不知道在哪台服务器上找日志。遇到类似这样的尴尬，想要通过日志来排查错误就搞得很麻烦。在这种情况下，ELK 为我们提供了统一的日志管理解决方案，它能很好的支持 Logback 等日志框架，使得我们可以集中的管理不同应用输出的日志信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 是 ElasticSearch、Logstash 和 Kibana 的简写。ElasticSearch 主要用来存储日志信息，并提供检索功能；Logstash 用于收集应用发送的日志信息，并写入到 ElasticSearch 当中；Kibana 是一个可视化的日志查看、分析工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 架构大体如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5615942028985508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtiaoRFfPUskPicqs87jsvqaNYia2rh7eibkRCAU3SJoPZ6Dr45niarUIt3Yxn8vdjb9wiagiaO526Pf0WRKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在上图中应用日志框架直接将日志发送给 Logstash，然后 Logstash 将接收的日志写入 ElasticSearch 中，开发人员通过可视化的 Kibana 可以进行日志的查询和分析。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在上图中，Logstash、ElasticSearch 都可以是多个，而不是一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ELK 的下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 都可以通过它们的官网进行下载，最好将它们的版本进行统一。我这里下载的是 7.17.6 的版本，即 ElasticSearch、Logstash 和 Kibana 都是 7.17.6 版本的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        它们的下载地址分别如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;- elasticsearch下载地址:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-17-6&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;- logstash下载地址：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/logstash-7-17-6&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;- kibana下载地址：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/kibana-7-17-6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 下载后只需要解压缩后进行配置即可使用，还是很方便的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ELK 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我这里使用的是 Windows 系统进行演示，在将 ELK 配置好后直接使用命令行进行启动，并没有将其注册为服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ElasticSearch 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 ES 的安装目录下有个 config 目录，打开该目录下的 elasticsearch.yml 文件，然后取消掉两行配置的注释符号，并进行简单的修改，配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;network.host: 0.0.0.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;discovery.seed_hosts: [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        在 ES 的安装目录下打开命令行执行以下命令，来启动 ES：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\elasticsearch.bat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Logstash 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 Logstash 的安装目录下同样有一个 config 目录，复制 logstash-sample.conf 配置文件，并命名为 log_to_es.conf，文件名可以自己定，启动时写对即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        修改配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;input {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  beats {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    port =&amp;gt; 5044&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tcp {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    host =&amp;gt; &quot;0.0.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    port =&amp;gt; 8082&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mode =&amp;gt; &quot;server&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tags =&amp;gt; [&quot;bsjiot&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    codec =&amp;gt; json_lines&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;output {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  elasticsearch {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    hosts =&amp;gt; [&quot;http://localhost:9200&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        其中 input 是用于收集日志信息的配置，output 是用于将收集的信息推送到 ES 中。通过命令行来启动 Logstash，命令如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\logstash.bat -f .\config\log_to_es.conf&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kibana 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 Kibana 的安装目录下也同样有一个 config 目录，修改该目录下的 kibana.yml 文件，配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;elasticsearch.hosts: [&quot;http://localhost:9200&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.host: &quot;127.0.0.1&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过在命令行如下命令启动 Kibana，命令如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\kibana.bat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过 Logback 输出日志到 ELK&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;上面配置完 ELK 并启动后，通过 SpringBoot 来进行测试。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;首先引入两个依赖，引入依赖如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;net.logstash.logback&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;logstash-logback-encoder&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;7.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;接下来配置 Logback 的配置文件：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;destination&amp;gt;localhost:8082&amp;lt;/destination&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;lt;customFields&amp;gt;{&quot;appname&quot;:&quot;xxxx&quot;}&amp;lt;/customFields&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;/encoder&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;root level=&quot;info&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;appender-ref ref=&quot;CONSOLE&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;appender-ref ref=&quot;LOGSTASH&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;root&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;最后通过 Logback 来输出一些日志，然后在 Kibana 中进行查看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过 Kibana 查看日志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;我们来&lt;/span&gt;&lt;span&gt;&lt;strong&gt;访问 Kibana 提供的 Web 页面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;浏览器中打开 http://localhost:5601/ 该地址&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。然后在左侧列表中选择 &lt;strong&gt;Stack Managentment&lt;/strong&gt;，选择后会出现新的页面，然后选择 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Index Patterns&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 选项。在新出现的页面中点击 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Create Index pattern&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 按钮，然后命名其为 logstash-*（这里名字随意），并选择 @timestamp 的字段，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40168539325842695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtje49PygRE6ddtoFUxO4np2MoDAEFIQ5GibUhqH1OJiaFGRwcIVyJ17LYHnDbuYwyXuQHxIbbrZKvRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;选择好后，点击 Create index pattern 按钮即可。创建完成后，返回 Kibana 的首页，选择 Discover 选项，切换到我们新建的 logstash-* 选项下，然后选择时间段，就可以看到相应的日志信息了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;上例中 ELK 都部署在了一台机器上，Demo 演示而已。实际情况中，ELK 可能部署在多台机器上，且可以配置集群。当微服务等客户端特别多时，同时向 Logstash 发送数据，并写入 ES 可能会影响性能，此时可以在客户端和 Logstash 中间引入 Kafka 来缓解 Logstash 和 ES 的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>914885e75129aa209afd07d752333d9a</guid>
<title>2022 年了，我才开始学 TypeScript ，晚吗？（7.5k字总结）</title>
<link>https://toutiao.io/k/7ppg48s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25220458553791886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR7Ujrq3JOdFEjypcT9HbREvfiaNviclzzszmueEsq5NBmyPwLhkY0zgiaYLvonb8IjLMgNdZicolHZaw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;567&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实早在初学前端时，就有大致了解过 typescript ,但后面工作中基本 vue2 开发为主，所以真正能够接触到 typescript 的机会其实并不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管在某些间歇性踌躇满志的时刻，我也会上X站搜索 &lt;code&gt;typescript最新教程&lt;/code&gt;，但都很难坚持过10节视频，又或者刷掘金的时候看到相关文章，我也会麻溜的点赞收藏一条龙，可是到现在也只是在我的收藏夹里吃灰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可能不是我太懒，只是这个世界诱惑太多，毕竟刷剧刷短视频它不香吗，学习，学个屁！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近刷掘金看着大伙的年中总结，不是跳槽涨薪了，就是完成了多少 flag。吓得我从床上一个激灵蹦起，低头看着自己日渐肥硕的肚子，仔细想想，这过去的大半年，除了完成日常的工作，我基本回家就开始躺平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再这么下去可不行，躺平的日子舒坦归舒坦但多少感到有点乏味，还是得给自己整点事情干。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拍拍自己的大肚皮，那就从现在开始，就把我那学了又相当于没学的 typescript ，重新整起来吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是 TypeScript&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TypeScript优缺点&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增强代码的可维护性，尤其在大型项目的时候效果显著&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;友好地在编辑器里提示错误，编译阶段就能检查类型发现大部分错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持最新的JavaScript新特特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;周边生态繁荣，vue3已全面支持 typescript&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要一定的学习成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和一些插件库的兼容并不是特别完美，如以前在 vue2 项目里使用 typescript就并不是那么顺畅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加前期开发的成本，毕竟你需要写更多的代码（但是便于后期的维护）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装环境&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装typescript&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们可以新建一个空文件夹，用来学习 ts，例如我在文件夹下新建了个 &lt;code&gt;helloworld.ts&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm install -g  typescript // 全局安装 ts&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不记得自己是否已经安装过 typescript 的，可以使用以下命令来验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tsc -v &lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现版本，则说明已经安装成功&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Version 4.6.3&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 tsconfig.json 配置文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tsc --init&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令后我们就可以看到生成了一个 tsconfig.json 文件，里面有一些配置信息，我们暂时先按下不表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们&lt;code&gt;helloworld.ts&lt;/code&gt;文件中,随便写点什么&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; s:&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;彼时彼刻，恰如此时此刻&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(s);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台执行 &lt;code&gt;tsc helloworld.ts&lt;/code&gt; 命令，目录下生成了一个同名的 helloworld.js 文件，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;&quot;彼时彼刻，恰如此时此刻&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(s);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过tsc命令，发现我们的typescript代码被转换成了熟悉的js代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接着执行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;node helloworld.js&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即可看到输出结果&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装 ts-node&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么通过我们上面的一通操作，我们知道了运行tsc命令就可以编译生成一个js文件，但是如果每次改动我们都要手动去执行编译，然后再通过 node命令才能查看运行结果岂不是太麻烦了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 ts-node 正是来解决这个问题的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm i -g ts-node // 全局安装ts-node&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个插件，我们就可以直接运行.ts文件了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们试一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ts-node helloworld.ts&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们的打印结果已经输出&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续我们的示例都可以通过这个命令来进行验证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就可以正式进入到 typescript 的学习之旅了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TypeScript 基础类型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Boolean 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; flag: &lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Number 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; count: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;String 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Enum 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;枚举类型用于定义数值集合，使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。，如周一到周日，方位上下左右等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; red: Color = Color.RED;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(red); &lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pink: Color = Color.PINK;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(pink); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED = &lt;span&gt;&quot;红色&quot;&lt;/span&gt;,&lt;br/&gt;  PINK = &lt;span&gt;&quot;粉色&quot;&lt;/span&gt;,&lt;br/&gt;  BLUE = &lt;span&gt;&quot;蓝色&quot;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pink: Color = Color.PINK;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(pink); &lt;span&gt;// 粉色&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; color: Color[] = [Color.RED, Color.PINK, Color.BLUE];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(color); &lt;span&gt;//[0, 1, 2]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//编译之后的js如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; color = [&lt;span&gt;0&lt;/span&gt; &lt;span&gt;/* RED */&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;/* PINK */&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; &lt;span&gt;/* BLUE */&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数组类型的定义有两种方式:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;const&lt;/span&gt; arr: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; arr2: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;元组（tuple）类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面数组类型的方式，只能定义出内部全为同种类型的数组。对于内部不同类型的数组可以使用元组类型来定义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元组（ Tuple ）表示一个已知数量和类型的数组,可以理解为他是一种特殊的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;const&lt;/span&gt; tuple: [&lt;span&gt;number&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;undefined和null&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 null 和 undefined 是所有类型的子类型。也就是说你可以把 null 和 undefined 赋值给其他类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; a: &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; b: &lt;span&gt;null&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;zhangmazi&#x27;&lt;/span&gt;;&lt;br/&gt;  str = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  str = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在tsconfig.json指定了&quot;strictNullChecks&quot;:true ，即开启严格模式后， null 和 undefined 只能赋值给 void 和它们各自的类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 启用 --strictNullChecks&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;undefined&lt;/span&gt;;    &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;any 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;any会跳过类型检查器对值的检查，任何值都可以赋值给any类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; value: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  value = &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = []; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = {};&lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;void 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;void 意思就是无效的, 一般只用在函数上，告诉别人这个函数没有返回值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;never 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;never 类型表示的是那些永不存在的值的类型。例如never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值会永不存在的两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1 如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2 函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;(&lt;span&gt;msg: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(msg); &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 死循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loopForever&lt;/span&gt;(): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {};&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Unknown 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unknown与any一样，所有类型都可以分配给unknown:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; value: unknown = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  value = &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unknown与any的最大区别是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的对象类型，就是我们常说的&lt;code&gt;函数、{}、数组、类&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;object, Object 和 {} 类型&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;object object 类型用于表示所有的非原始类型，即我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined 类型也不能赋给 object。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; object: object;&lt;br/&gt;object = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;&quot;a&quot;&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = {}; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 Object 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 null 和 undefined 不可以)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; bigObject: &lt;span&gt;Object&lt;/span&gt;;&lt;br/&gt;object = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;&quot;a&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;ObjectCase = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;ObjectCase = {}; &lt;span&gt;// ok&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;{} 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，我们通过 Class 关键字来定义一个类&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, age: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;  }&lt;br/&gt;  sayHi(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Hi, &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; flag1: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; flag2: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数声明&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数表达式&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口定义函数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Add {&lt;br/&gt;  (x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可选参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y?: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; y ? x + y : x;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt; = 0&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;剩余参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;...numbers: &lt;span&gt;number&lt;/span&gt;[]&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; numbers.length; i++) {&lt;br/&gt;    sum += numbers[i];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数重载&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;string&lt;/span&gt;, y: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;any&lt;/span&gt;, y: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面示例中，我们给同一个函数提供多个函数类型定义，从而实现函数的重载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体示例原理可参考&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型推论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码等价于&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述示例我们可以看出，我们没有给 x 指定明确类型的时候，typescript 会推断出 x 的类型是 number。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x;&lt;br/&gt;x = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型断言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些情况下，我们可能比typescript更加清楚的知道某个变量的类型，所以我们可能希望手动指定一个值的类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型断言有两种方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;to be or not to be&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;str).length;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;to be or not to be&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (str &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;).length;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;非空断言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上下文中当类型检查器无法断定类型时，可以使用缀表达式操作符 &lt;code&gt;!&lt;/code&gt; 进行断言操作对象是非 null 和非 undefined 的类型，&lt;strong&gt;即x!的值不会为 null 或 undefined&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; user: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(user!.toUpperCase()); &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(user.toUpperCase()); &lt;span&gt;// 错误&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定赋值断言&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value:&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(value); &lt;span&gt;// Variable &#x27;value&#x27; is used before being assigned.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义了变量, 没有赋值就使用，则会报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value!:&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(value); &lt;span&gt;// undefined 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;联合类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;联合类型用&lt;code&gt;|&lt;/code&gt;分隔，表示取值可以为多种类型中的一种&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; status:&lt;span&gt;string&lt;/span&gt;|&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;status=&lt;span&gt;&#x27;to be or not to be&#x27;&lt;/span&gt;&lt;br/&gt;status=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型别名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型别名用来给一个类型起个新名字。它只是起了一个新名字，并没有创建新类型。类型别名常用于联合类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; count = &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;[];&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;(&lt;span&gt;value: count&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;交叉类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交叉类型就是跟联合类型相反，用&lt;code&gt;&amp;amp;&lt;/code&gt;操作符表示，交叉类型就是两个类型必须存在&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IpersonA{&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IpersonB {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; person: IpersonA &amp;amp; IpersonB = { &lt;br/&gt;    name: &lt;span&gt;&quot;师爷&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;    gender: &lt;span&gt;&quot;男&quot;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;person 即是 IpersonA 类型，又是 IpersonB 类型&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：交叉类型取的多个类型的并集，但是如果key相同但是类型不同，则该key为never类型&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IpersonA {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IpersonB {&lt;br/&gt;    name: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testAndFn&lt;/span&gt;(&lt;span&gt;params: IpersonA &amp;amp; IpersonB&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(params)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;testAndFn({name: &lt;span&gt;&quot;黄老爷&quot;&lt;/span&gt;}) &lt;span&gt;// error TS2322: Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型守卫&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内&lt;/strong&gt;。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说：&lt;strong&gt;类型守卫是运行时检查，确保一个值在所要类型的范围内&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要有四种的方式来实现类型保护：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; InObj1 {&lt;br/&gt;    a: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    x: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; InObj2 {&lt;br/&gt;    a: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    y: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isIn&lt;/span&gt;(&lt;span&gt;arg: InObj1 | InObj2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// x 在 arg 打印 x&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&#x27;x&#x27;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; arg) &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;x&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// y 在 arg 打印 y&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&#x27;y&#x27;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; arg) &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;y&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;isIn({a:&lt;span&gt;1&lt;/span&gt;, x:&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;});&lt;br/&gt;isIn({a:&lt;span&gt;1&lt;/span&gt;, y:&lt;span&gt;&#x27;yyy&#x27;&lt;/span&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isTypeof&lt;/span&gt;(&lt;span&gt; val: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; val === &lt;span&gt;&quot;number&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; val === &lt;span&gt;&quot;string&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;啥也不是&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;typeof 只支持：typeof &#x27;x&#x27; === &#x27;typeName&#x27; 和 typeof &#x27;x&#x27; !== &#x27;typeName&#x27;，x 必须是 &#x27;number&#x27;, &#x27;string&#x27;, &#x27;boolean&#x27;, &#x27;symbol&#x27;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;creatDate&lt;/span&gt;(&lt;span&gt;date: &lt;span&gt;Date&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(date)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(date &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;){&lt;br/&gt;        date.getDate()&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(date)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isNumber&lt;/span&gt;(&lt;span&gt;num: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;num&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; num === &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isString&lt;/span&gt;(&lt;span&gt;str: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;str&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; str=== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用接口来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单理解就是：&lt;strong&gt;为我们的代码提供一种约定&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用关键字interface来声明接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;    age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; tom: Person = {&lt;br/&gt;    name: &lt;span&gt;&#x27;Tom&#x27;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;25&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口一般首字母大写。(当然挺多人也习惯 I 大写字母开头，用来表示这是一个接口)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置接口可选|只读&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  readonly name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可选属性，我们最常见的使用情况是，不确定这个参数是否会传，或者存在。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引签名&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 &lt;strong&gt;索引签名&lt;/strong&gt; 的形式来满足上述要求。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  [prop: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;; &lt;span&gt;//  propName字段必须是 string类型 or number类型。 值是any类型，也就是任意的&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = { name: &lt;span&gt;&quot;张麻子&quot;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = { name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;, age: &lt;span&gt;28&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p3 = { name: &lt;span&gt;&quot;汤师爷&quot;&lt;/span&gt;, sex: &lt;span&gt;1&lt;/span&gt; }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们规定 以 string 类型的值来索引，索引到的是一个 any 类型的值&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口与类型别名的区别&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;TypeScript 的核心原则之一是对值所具有的结构进行类型检查。而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;type(类型别名)会给一个类型起个新名字。type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口和类型别名都可以用来描述对象或函数的类型，只是语法不同&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MyTYpe = {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;都允许扩展&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;interface 用 &lt;code&gt;extends&lt;/code&gt; 来实现扩展&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface2 &lt;span&gt;extends&lt;/span&gt; MyInterface {&lt;br/&gt;  sex: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; person:MyInterface2 = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  sex:&lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MyType = {&lt;br/&gt;  name:&lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MyType2 = MyType &amp;amp; {&lt;br/&gt;  sex:&lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value: MyType2 = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  sex:&lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;type可以声明基本数据类型别名/联合类型/元组等，而interface不行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 基本类型别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserName = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserName = &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 联合类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Animal = Pig | Dog | Cat;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; List = [&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;boolean&lt;/span&gt;, &lt;span&gt;number&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 此时Person同时具有name和age属性&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如我们现在有个这样的需求，我们要实现一个这样的函数，函数的参数可以是任何值，返回值就是将参数原样返回，并且参数的类型是 string，函数返回类型就为 string？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你很容易写下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;string&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;string&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在需求有变，需要返回一个 number 类型的值，你会说，联合类型就完事了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样又有一个问题，就是如果我们需要返回一个 boolean 类型，string 数组甚至任意类型呢，难道有多少个就写多少个联合类型？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，我们直接用 any 就行了！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;any&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;any&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 any 大法好，很多时候 any 也确实能够解决不少问题，但是这样也不符合我们的需求了，传入和返回都是 any 类型，&lt;strong&gt;传入和返回并没有统一&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个骚有最求的程序员，我们还能不能有其他解决办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就要祭出我们的泛型了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基本使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的需求，我们如果用泛型来解决的话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型的语法是尖括号 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 里面写类型参数，一般用 &lt;code&gt;T&lt;/code&gt; 来表示第一个类型变量名称，其实它可以用任何有效名称来代替,比如我们用&lt;code&gt;NIUBI&lt;/code&gt;也是编译正常的&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;泛型就像一个占位符一个变量，在使用的时候我们可以将定义好的类型像参数一样传入，原封不动的输出&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有两种方式来使用：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义要使用的类型，比如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;); &lt;span&gt;// 定义 T 为 string 类型&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用 typescript 的类型推断，比如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getValue(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;) &lt;span&gt;// 自动推导类型为 string&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多个参数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:[T,U]&lt;/span&gt;):[&lt;span&gt;T&lt;/span&gt;,&lt;span&gt;U&lt;/span&gt;] &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; str = getValue([&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;]);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.199297629499561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR7Ujrq3JOdFEjypcT9HbREJmk5dw0bORpdeYnmXqOC9X5vpEmoQ4ae9u8aXQDT7sczTTEibPbUeZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1139&quot;/&gt; typescript 给我们自动推断出输入、返回的类型&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型约束&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getLength&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length); &lt;span&gt;// 报错，不能调用 length 属性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为泛型 T 不一定包含属性 length，那么我想 getLength 这个函数只允许传入包含 length 属性的变量，该怎么做呢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以使用&lt;code&gt;extends&lt;/code&gt;关键字来对泛型进行约束&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Lengthwise {&lt;br/&gt;  length: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getLength&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Lengthwise&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; str = getLength(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = getLength([&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = getLength({ length: &lt;span&gt;5&lt;/span&gt; })&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看出，不管你是 str，arr 还是obj，只要具有 length 属性，都可以&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体参考&lt;span&gt;轻松拿下 TS 泛型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型接口&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在定义接口的时候指定泛型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; KeyValue&amp;lt;T,U&amp;gt; {&lt;br/&gt;  key: T;&lt;br/&gt;  value: U;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person1:KeyValue&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;number&lt;/span&gt;&amp;gt; = {&lt;br/&gt;  key: &lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  value: &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person2:KeyValue&amp;lt;&lt;span&gt;number&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; = {&lt;br/&gt;  key: &lt;span&gt;20&lt;/span&gt;,&lt;br/&gt;  value: &lt;span&gt;&#x27;张麻子&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型类&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Test&amp;lt;T&amp;gt; {&lt;br/&gt;  value: T;&lt;br/&gt;  add: &lt;span&gt;(&lt;span&gt;x: T, y: T&lt;/span&gt;) =&amp;gt;&lt;/span&gt; T;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myTest = &lt;span&gt;new&lt;/span&gt; Test&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt;();&lt;br/&gt;myTest.value = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;myTest.add = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x, y&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型类型别名&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Cart&amp;lt;T&amp;gt; = { list: T[] } | T[];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; c1: Cart&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; = { list: [&lt;span&gt;&quot;1&quot;&lt;/span&gt;] };&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; c2: Cart&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型参数的默认类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。有点 js 里函数默认参数的意思。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createArray&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; = &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;length: &lt;span&gt;number&lt;/span&gt;, value: T&lt;/span&gt;): &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; result: T[] = [];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; length; i++) {&lt;br/&gt;    result[i] = value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型工具类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键词除了做类型保护，还可以从实现推出类型，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//先定义变量，再定义类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; p1 = {&lt;br/&gt;  name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; People = &lt;span&gt;typeof&lt;/span&gt; p1;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;(&lt;span&gt;p: People&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p.name;&lt;br/&gt;}&lt;br/&gt;getName(p1);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用来获取一个对象接口中的所有 key 值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt; | &lt;span&gt;&quot;female&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PersonKey = keyof Person; &lt;span&gt;//type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValueByKey&lt;/span&gt;(&lt;span&gt;p: Person, key: PersonKey&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p[key];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; val = getValueByKey({ name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;, age: &lt;span&gt;18&lt;/span&gt;, gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt; }, &lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(val); &lt;span&gt;// 树哥&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来遍历枚举类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Keys = &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Obj =  {&lt;br/&gt;  [p &lt;span&gt;in&lt;/span&gt; Keys]: &lt;span&gt;any&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// -&amp;gt; { a: any, b: any, c: any }&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ReturnType&amp;lt;T&amp;gt; = T &lt;span&gt;extends&lt;/span&gt; (&lt;br/&gt;  ...args: &lt;span&gt;any&lt;/span&gt;[]&lt;br/&gt;) =&amp;gt; infer R ? R : &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Lengthwise {&lt;br/&gt;  length: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loggingIdentity&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Lengthwise&lt;/span&gt;&amp;gt;(&lt;span&gt;arg: T&lt;/span&gt;): &lt;span&gt;T&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity(&lt;span&gt;3&lt;/span&gt;);  &lt;span&gt;// Error, number doesn&#x27;t have a .length property&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们传入合法的类型的值，即包含 length 属性的值时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity({length: &lt;span&gt;10&lt;/span&gt;, name: &lt;span&gt;&#x27;张麻子&#x27;&lt;/span&gt;}); &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;[]&lt;/code&gt; 操作符可以进行索引访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; x = Person[&lt;span&gt;&quot;name&quot;&lt;/span&gt;]; &lt;span&gt;// x is string&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内置工具类型&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Required&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将类型的属性变成必选&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name?: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    age?: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    hobby?: &lt;span&gt;string&lt;/span&gt;[]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user: Required&amp;lt;Person&amp;gt; = {&lt;br/&gt;    name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;    hobby: [&lt;span&gt;&quot;code&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Partial&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Required 相反，将所有属性转换为可选属性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; shuge:Person = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// error  Property &#x27;age&#x27; is missing in type &#x27;{ name: string; }&#x27; but required in type &#x27;Person&#x27;.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面知道，如果必传而我们少穿传了的话，就会报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 Partial 将其变为可选&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User = Partial&amp;lt;Person&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; shuge: User={&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Exclude&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; 的作用是将某个类型中属于另一个的类型移除掉,剩余的属性构成新的类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; T0 = Exclude&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;b&quot; | &quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T1 = Exclude&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T2 = Exclude&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;(&lt;span&gt;() =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;), &lt;span&gt;Function&lt;/span&gt;&amp;gt;; // &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Extract&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Exclude 相反，&lt;code&gt;Extract&amp;lt;T,U&amp;gt;&lt;/code&gt; 从 T 中提取出 U。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; T0 = Extract&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;f&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;a&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T1 = Extract&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;(&lt;span&gt;() =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;), &lt;span&gt;Function&lt;/span&gt;&amp;gt;; // &lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;适用于：并集类型&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Readonly&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把数组或对象的所有属性值转换为只读的，这就意味着这些属性不能被重新赋值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender?: &lt;span&gt;&quot;male&quot;&lt;/span&gt; | &lt;span&gt;&quot;female&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; p: Readonly&amp;lt;Person&amp;gt; = {&lt;br/&gt;  name: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;p.age = &lt;span&gt;11&lt;/span&gt;; &lt;span&gt;// error  Cannot assign to &#x27;age&#x27; because it is a read-only property.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Record&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Record&amp;lt;K extends keyof any, T&amp;gt; 的作用是将 K 中所有的属性的值转化为 T 类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Property = &lt;span&gt;&#x27;key1&#x27;&lt;/span&gt;|&lt;span&gt;&#x27;key2&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Person = Record&amp;lt;Property, &lt;span&gt;string&lt;/span&gt;&amp;gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p: Person = {&lt;br/&gt;  key1: &lt;span&gt;&quot;hello 啊&quot;&lt;/span&gt;,&lt;br/&gt;  key2: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Pick&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从某个类型中挑出一些属性出来&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Person = {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age:&lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender:&lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P1 = Pick&amp;lt;Person, &lt;span&gt;&quot;name&quot;&lt;/span&gt; | &lt;span&gt;&quot;age&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// { name: string; age: number; }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user:P1={&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  age:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;8&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Omit&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与Pick相反，&lt;code&gt;Omit&amp;lt;T,K&amp;gt;&lt;/code&gt; 从T中取出除去K的其他所有属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P1 = Omit&amp;lt;Person, &lt;span&gt;&quot;age&quot;&lt;/span&gt; | &lt;span&gt;&quot;gender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user:P1  = {&lt;br/&gt;  name: &lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;9&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NonNullable&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去除类型中的 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; P1 = NonNullable&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&amp;gt;; &lt;span&gt;// string | number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P2 = NonNullable&amp;lt;&lt;span&gt;string&lt;/span&gt;[] | &lt;span&gt;null&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&amp;gt;; &lt;span&gt;// string[]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;10&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ReturnType&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来得到一个函数的返回值类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Func = &lt;span&gt;(&lt;span&gt;value: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test: ReturnType&amp;lt;Func&amp;gt; = &lt;span&gt;&quot;1&quot;&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;11&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Parameters&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于获得函数的参数类型所组成的元组类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; P1 = Parameters&amp;lt;&lt;span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&amp;gt;; &lt;span&gt;// [number, string]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;12&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;InstanceType&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回构造函数类型T的实例类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; C {&lt;br/&gt;  x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  y = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; D = InstanceType&amp;lt;&lt;span&gt;typeof&lt;/span&gt; C&amp;gt;;  &lt;span&gt;// C&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;tsconfig.json&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开头环境安装部分，记得我们有生成一个 tsconfig.json 文件，那么这个文件究竟有什么用呢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tsconfig.json 是 TypeScript 项目的配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重要字段&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;files - 设置要编译的文件的名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;include - 设置需要进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exclude - 设置无需进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compilerOptions - 设置与编译流程相关的选项。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;compilerOptions 选项&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;compilerOptions&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 基本选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;target&quot;&lt;/span&gt;: &lt;span&gt;&quot;es5&quot;&lt;/span&gt;,                       &lt;span&gt;// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;module&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonjs&quot;&lt;/span&gt;,                  &lt;span&gt;// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;lib&quot;&lt;/span&gt;: [],                             &lt;span&gt;// 指定要包含在编译中的库文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;allowJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       &lt;span&gt;// 允许编译 javascript 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;checkJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       &lt;span&gt;// 报告 javascript 文件中的错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;jsx&quot;&lt;/span&gt;: &lt;span&gt;&quot;preserve&quot;&lt;/span&gt;,                     &lt;span&gt;// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;declaration&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                   &lt;span&gt;// 生成相应的 &#x27;.d.ts&#x27; 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;sourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                     &lt;span&gt;// 生成相应的 &#x27;.map&#x27; 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;outFile&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 将输出文件合并为一个文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;outDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                        &lt;span&gt;// 指定输出目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;rootDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 用来控制输出目录结构 --outDir.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;removeComments&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 删除编译后的所有的注释&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noEmit&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        &lt;span&gt;// 不生成输出文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;importHelpers&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 从 tslib 导入辅助工具函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;isolatedModules&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               &lt;span&gt;// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 严格的类型检查选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        &lt;span&gt;// 启用所有严格类型检查选项&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitAny&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 在表达式和声明上有隐含的 any类型时报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strictNullChecks&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,              &lt;span&gt;// 启用严格的 null 检查&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitThis&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 当 this 表达式值为 any 类型的时候，生成一个错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;alwaysStrict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                  &lt;span&gt;// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 额外的检查 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noUnusedLocals&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 有未使用的变量时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noUnusedParameters&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,            &lt;span&gt;// 有未使用的参数时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitReturns&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,             &lt;span&gt;// 并不是所有函数里的代码都有返回值时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noFallthroughCasesInSwitch&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,    &lt;span&gt;// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 模块解析选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;moduleResolution&quot;&lt;/span&gt;: &lt;span&gt;&quot;node&quot;&lt;/span&gt;,            &lt;span&gt;// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;baseUrl&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 用于解析非相对模块名称的基目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;paths&quot;&lt;/span&gt;: {},                           &lt;span&gt;// 模块名到基于 baseUrl 的路径映射的列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;rootDirs&quot;&lt;/span&gt;: [],                        &lt;span&gt;// 根文件夹列表，其组合内容表示项目运行时的结构内容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;typeRoots&quot;&lt;/span&gt;: [],                       &lt;span&gt;// 包含类型声明的文件列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;types&quot;&lt;/span&gt;: [],                           &lt;span&gt;// 需要包含的类型声明文件名列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;allowSyntheticDefaultImports&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;// 允许从没有设置默认导出的模块中默认导入。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* Source Map Options */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;sourceRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                    &lt;span&gt;// 指定调试器应该找到 TypeScript 文件而不是源文件的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;mapRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 指定调试器应该找到映射文件而不是生成文件的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;inlineSourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               &lt;span&gt;// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;inlineSources&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 其他选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;experimentalDecorators&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,        &lt;span&gt;// 启用装饰器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;emitDecoratorMetadata&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;          &lt;span&gt;// 为装饰器提供元数据的支持&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vue 项目开发，我遇到了这些问题&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;关于首屏优化，我做了哪些&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一份不可多得的 TS 学习指南&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;TS中文文档&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;2021 typescript史上最强学习入门文章&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;关于本文&lt;/span&gt;&lt;/section&gt;&lt;h1 data-v-a4949a24=&quot;&quot;&gt;&lt;span&gt;作者：呛再首&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/7124117404187099172&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.006666666666666667&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu1rRLicXibOB6jq4wpe7W4Ioibu7XTJR1ABzARKoLxyWEWeIV6HJRII2GK1ntnCkVIqjY852gntBd5Q/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;敬请关注「Nodejs技术栈」微信公众号，&lt;span&gt;期望与志同道合的你一起打造优质 “Nodejs技术栈” 交流群，一起互相学习进步！&lt;/span&gt;&lt;span&gt;可长按下方二维码&lt;/span&gt;&lt;span&gt;添加【五月君】个人微信备注 “Node” 邀请入群。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatLmT5coKbicuqENgoc3Pz4QWwtrEoP2RU2thicCJHaKNmJ23Hh9jYvicpVgiauY6NxNaZ59D6svw1Qskg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5c972f8bf86a720f52525d295139d3d8</guid>
<title>C++最佳实践 | 6. 性能</title>
<link>https://toutiao.io/k/5yqa6wj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;本系列是开源书&lt;span&gt;C++ Best Practises&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;的中文版，全书从工具、代码风格、安全性、可维护性、可移植性、多线程、性能、正确性等角度全面介绍了现代C++项目的最佳实践。本文是该系列的第六篇。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;C++最佳实践:&lt;/p&gt;&lt;p&gt;1. 工具&lt;/p&gt;&lt;p&gt;2. 代码风格&lt;/p&gt;&lt;p&gt;3. 安全性&lt;/p&gt;&lt;p&gt;4. 可维护性&lt;/p&gt;&lt;p&gt;5. 可移植性及多线程&lt;/p&gt;&lt;p&gt;6. 性能（本文）&lt;/p&gt;&lt;p&gt;7. 正确性和脚本&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;性能&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽量使用前置声明&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这种声明方式:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// some header file&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyClass&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; MyClass &amp;amp;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而不是这样:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// some header file&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;MyClass.hpp&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; MyClass &amp;amp;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样也使用于模板:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; T&amp;gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyTemplatedType&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式可以主动减少编译时间并重新构建依赖关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注意: 前置声明会阻碍内联和优化，建议在发布版本中使用链接时优化或链接时代码生成。&lt;/em&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免不必要的模板实例化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模板不要随便实例化，实例化过多模板，或者模板代码多于必要的数量，会增加编译代码的大小和构建时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例请参考: &lt;span&gt;Template Code Bloat Revisited: A Smaller make_shared&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免递归模板实例化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归模板实例化可能会给编译器带来很大的负担，并且代码更加难以理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果可能的话，考虑使用可变参数展开和折叠&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分析构建&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;span&gt;Templight&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;工具分析项目的构建时间，它需要花一些时间来构建，但一旦这样做了，可以用来替换clang++。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Templight进行构建之后，需要对结果进行分析，&lt;span&gt;templight-tools&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;项目提供了各种方法(建议使用callgrind转换并使用kcachegrind对结果进行可视化)。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;隔离频繁更改的头文件&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要包含不需要的头文件&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器必须处理看到的每个include指令，即使只是在看到&lt;code&gt;#ifndef&lt;/code&gt;include保护符后立即停止，仍然必须打开文件并进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;include-what-you-use&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;是一个可以帮我们确定需要哪些头文件的工具。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;减少预处理器的工作&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是“隔离频繁更改的头文件”和“不要包含不需要的头文件”的一般形式。类似BOOST_PP这样的工具可能非常有用，但也给预处理器带来了巨大的负担。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;考虑使用预编译头文件&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用预编译头文件可以大大减少大型项目的编译时间，选定的头文件被编译成中间形式(PCH文件)，编译器可以更快处理。建议只将经常使用但很少更改的头文件定义为预编译头文件(例如系统头文件和库头文件)，以减少编译时间。但必须记住，使用预编译头文件有几个缺点:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;预编译头文件不可移植。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成的PCH文件依赖于机器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生成的PCH文件可能相当大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它会破坏头文件依赖关系。由于有预编译头文件，每个文件都有可能包含标记为预编译头文件的每个头文件。因此，如果禁用预编译头文件，可能会导致构建失败。如果需要发布库之类的项目，这可能是个问题。正因为如此，强烈建议在第一次构建时启用预编译头，而在后续构建时将其关闭。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大多数常见的编译器都支持预编译头文件，比如&lt;span&gt;GCC&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;、&lt;span&gt;Clang&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;和&lt;span&gt;Visual Studio&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。像&lt;span&gt;cotire&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;(cmake的插件)这样的工具可以帮助我们在构建系统中添加预编译的头文件。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;考虑使用工具&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工具并不意味着可以取代好的设计。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ccache&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;，用于类unix操作系统的编译结果缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;clcache&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;，cl.exe的编译结果缓存(MSVC)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;warp&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;，Facebook的预处理器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将tmp放在Ramdisk上&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详见YouTube视频: https://www.youtube.com/watch?v=t4M3yG1dWho&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用gold链接器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是在Linux上，考虑使用GCC的gold链接器(ld.gold)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考: &lt;span&gt;gold: Google Releases New and Improved GCC Linker&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运行时&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分析代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不分析代码的情况下，无法真正找到瓶颈在哪里。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;http://developer.amd.com/tools-and-sdks/opencl-zone/codexl/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;http://www.codersnotes.com/sleepy&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简化代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码越清晰、越简单、越容易阅读，编译器就越有可能更好的将其实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用初始化列表&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// This&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;ModelObject&amp;gt; mos{mo1, mo2};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// -or-&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; mos = &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;ModelObject&amp;gt;{mo1, mo2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Don&#x27;t do this&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;ModelObject&amp;gt; mos;&lt;br/&gt;mos.push_back(mo1);&lt;br/&gt;mos.push_back(mo2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过减少对象复制并调整容器大小，初始化列表能显著提升性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;减少临时对象&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Instead of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; mo1 = getSomeModelObject();&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; mo2 = getAnotherModelObject();&lt;br/&gt;&lt;br/&gt;doSomething(mo1, mo2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// consider:&lt;br/&gt;doSomething(getSomeModelObject(), getAnotherModelObject());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类代码将阻碍编译器执行move操作……&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启用移动(move)操作&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;move操作是C++11中最受欢迎的特性之一，该操作允许编译器通过移动临时对象从而避免额外的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些代码(例如声明自己的析构函数或赋值操作符或拷贝构造函数)会阻止编译器生成移动构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数代码，下面这么一个简单的定义:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ModelObject(ModelObject &amp;amp;&amp;amp;) = &lt;span&gt;default&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;...就足够了，不过MSVC2013似乎不支持这段代码。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免&lt;code&gt;shared_ptr&lt;/code&gt;拷贝&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shared_ptr&lt;/code&gt;对象的拷贝成本比想象的要高得多，因为引用计数必须是原子的和线程安全的。这条规则只是再次强调了上面的注意事项: 避免临时对象和过多的对象副本。仅仅因为我们使用了pImpl，并不意味着副本没有代价。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽可能减少拷贝和重分配&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于更简单的情况，可以使用三元操作符:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; somevalue;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (caseA) {&lt;br/&gt;  somevalue = &lt;span&gt;&quot;Value A&quot;&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  somevalue = &lt;span&gt;&quot;Value B&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Better Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; somevalue = caseA ? &lt;span&gt;&quot;Value A&quot;&lt;/span&gt; : &lt;span&gt;&quot;Value B&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;span&gt;立即调用的lambda&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;可以简化更复杂的情况。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; somevalue;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (caseA) {&lt;br/&gt;  somevalue = &lt;span&gt;&quot;Value A&quot;&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(caseB) {&lt;br/&gt;  somevalue = &lt;span&gt;&quot;Value B&quot;&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  somevalue = &lt;span&gt;&quot;Value C&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Better Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; somevalue = [&amp;amp;]( &lt;span&gt;&quot;&amp;amp;&quot;&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (caseA) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Value A&quot;&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (caseB) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Value B&quot;&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Value C&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免多余的异常&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正常处理期间，内部抛出和捕获的异常会降低应用程序的执行速度。由于调试器会监视和报告每个异常事件，因此还会破坏调试器的用户体验。最好尽可能避免内部异常处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抛弃&lt;code&gt;new&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经知道不该使用裸内存访问，因此改用&lt;code&gt;unique_ptr&lt;/code&gt;和&lt;code&gt;shared_ptr&lt;/code&gt;，对吧？堆分配比栈分配昂贵得多，但有时不得不用。更糟的是，创建&lt;code&gt;shared_ptr&lt;/code&gt;实际上需要在堆上分配2次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，&lt;code&gt;make_shared&lt;/code&gt;函数可以将其减少为一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;shared_ptr&lt;/span&gt;&amp;lt;ModelObject_Impl&amp;gt;(&lt;span&gt;new&lt;/span&gt; ModelObject_Impl());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// should become&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::make_shared&amp;lt;ModelObject_Impl&amp;gt;(); &lt;span&gt;// (it&#x27;s also more readable and concise)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优先选择&lt;code&gt;unique_ptr&lt;/code&gt;而不是&lt;code&gt;shared_ptr&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能的话，使用&lt;code&gt;unique_ptr&lt;/code&gt;而不是&lt;code&gt;shared_ptr&lt;/code&gt;。&lt;code&gt;unique_ptr&lt;/code&gt;是不可复制的，因此不需要跟踪副本，比&lt;code&gt;shared_ptr&lt;/code&gt;性能更好。另外，类似于&lt;code&gt;shared_ptr&lt;/code&gt;和&lt;code&gt;make_shared&lt;/code&gt;的关系，应该使用&lt;code&gt;make_unique&lt;/code&gt;(C++14或更高版本)来创建&lt;code&gt;unique_ptr&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;std&lt;/span&gt;::make_unique&amp;lt;ModelObject_Impl&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前的最佳实践也建议从工厂函数返回&lt;code&gt;unique_ptr&lt;/code&gt;，然后在必要时将&lt;code&gt;unique_ptr&lt;/code&gt;转换为&lt;code&gt;shared_ptr&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;unique_ptr&lt;/span&gt;&amp;lt;ModelObject_Impl&amp;gt; &lt;span&gt;factory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; shared = &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;shared_ptr&lt;/span&gt;&amp;lt;ModelObject_Impl&amp;gt;(factory());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;抛弃&lt;code&gt;std::endl&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::endl&lt;/code&gt;表示刷新操作，等价于&lt;code&gt;&quot;\n&quot; &amp;lt;&amp;lt; std::flush&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;限制变量作用域&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量应该尽可能晚声明，最好只在可以初始化对象时声明。减小变量作用域可以减少内存的使用，提高代码效率，并帮助编译器进一步优化代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Good Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;15&lt;/span&gt;; ++i)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;MyObject &lt;span&gt;obj&lt;/span&gt;&lt;span&gt;(i)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// do something with obj&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;MyObject obj; &lt;span&gt;// meaningless object initialization&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;15&lt;/span&gt;; ++i)&lt;br/&gt;{&lt;br/&gt;  obj = MyObject(i); &lt;span&gt;// unnecessary assignment operation&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// do something with obj&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// obj is still taking up memory for no reason&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于C++17及以后版本，考虑在&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;switch&lt;/code&gt;语句中初始化变量:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (MyObject obj(index); obj.good()) {&lt;br/&gt;    &lt;span&gt;// do something if obj is good&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// do something if obj is not good&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Github上对此有专门的讨论: https://github.com/lefticus/cppbestpractices/issues/52&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优先选择&lt;code&gt;double&lt;/code&gt;类型而不是&lt;code&gt;float&lt;/code&gt;类型，但需要先测试&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据情况和编译器的优化能力，一种可能比另一种更快。选择&lt;code&gt;float&lt;/code&gt;意味着精度较低，并可能由于类型转换而影响性能。在可向量化操作中，如果能够牺牲精度，&lt;code&gt;float&lt;/code&gt;可能更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;double&lt;/code&gt;是C++中浮点值的默认类型，因此推荐作为默认选项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考下面的文章获取更多信息: &lt;span&gt;double or float, which is faster?&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优先选择&lt;code&gt;++i&lt;/code&gt;而不是&lt;code&gt;i++&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;...当语义正确时，&lt;span&gt;前置自增比后置自增更快&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;，因为前置自增不需要创建对象副本。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;15&lt;/span&gt;; i++)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;15&lt;/span&gt;; ++i)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使许多现代编译器将这两个循环优化为相同的汇编代码，选择&lt;code&gt;++i&lt;/code&gt;仍然是一种良好的实践。你永远无法确定代码会不会使用不带优化的编译器，因此没有任何理由不这样做。此外，编译器有可能只对整数类型进行优化，而不一定对所有迭代器或其他用户自定义类型进行优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总而言之，如果前置自增操作符与后置自增操作符在语义上相同，那么使用前置自增操作符总是更好。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;char是char, string是string&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; someThing() &amp;lt;&amp;lt; &lt;span&gt;&quot;\n&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; someThing() &amp;lt;&amp;lt; &lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去区别不大，但是&lt;code&gt;&quot;\n&quot;&lt;/code&gt;必须被编译器解析为&lt;code&gt;const char *&lt;/code&gt;，必须在写入流(或附加到字符串)时对&lt;code&gt;\0&lt;/code&gt;进行范围检查，而&lt;code&gt;&#x27;\n&#x27;&lt;/code&gt;是已知的单个字符，可以节约许多CPU指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次调用效率低下的代码，可能会对性能产生影响，更重要的是，考虑这两种使用情况会让我们更多的考虑编译器和运行时在执行代码时必须做什么。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;永远不要用&lt;code&gt;std::bind&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;std::bind&lt;/code&gt;的开销(包括编译时和运行时)几乎总是比需要的更多，相反，我们只需使用lambda。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; f = &lt;span&gt;std&lt;/span&gt;::bind(&amp;amp;my_function, &lt;span&gt;&quot;hello&quot;&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::placeholders::_1);&lt;br/&gt;f(&lt;span&gt;&quot;world&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;auto&lt;/span&gt; f = [](&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt; &amp;amp;s) { &lt;span&gt;return&lt;/span&gt; my_function(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;, s); };&lt;br/&gt;f(&lt;span&gt;&quot;world&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;了解标准库&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确使用供应商提供的标准库中已经高度优化的组件。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;in_place_t&lt;/code&gt;及相关内容&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道如何使用&lt;code&gt;in_place_t&lt;/code&gt;和相关标签高效创建诸如&lt;code&gt;std::tuple&lt;/code&gt;、&lt;code&gt;std::any&lt;/code&gt;和&lt;code&gt;std::variant&lt;/code&gt;等对象。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;C++ Best Practises: &lt;em&gt;https://lefticus.gitbooks.io/cpp-best-practices/content/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Template Code Bloat Revisited: A Smaller make_shared: &lt;em&gt;https://articles.emptycrate.com/2015/04/27/template_code_bloat_revisited_a_smaller_makeshared.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Folds (ish) In C++11: &lt;em&gt;http://articles.emptycrate.com/2016/05/14/folds_in_cpp11_ish.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Templight: &lt;em&gt;https://github.com/mikael-s-persson/templight&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;templight-tools: &lt;em&gt;https://github.com/mikael-s-persson/templight-tools&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;include-what-you-use: &lt;em&gt;https://github.com/include-what-you-use/include-what-you-use&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;GCC: &lt;em&gt;https://gcc.gnu.org/onlinedocs/gcc/Precompiled-Headers.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;Clang: &lt;em&gt;http://clang.llvm.org/docs/PCHInternals.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Visual Studio: &lt;em&gt;https://msdn.microsoft.com/en-us/library/szfdksca.aspx&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;cotire: &lt;em&gt;https://github.com/sakra/cotire/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;ccache: &lt;em&gt;https://ccache.samba.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;clcache: &lt;em&gt;https://github.com/frerich/clcache&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;warp: &lt;em&gt;https://github.com/facebook/warp&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;gold: Google Releases New and Improved GCC Linker: &lt;em&gt;https://opensource.googleblog.com/2008/04/gold-google-releases-new-and-improved.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;Complex Object Initialization Optimization with IIFE in C++11: &lt;em&gt;http://blog2.emptycrate.com/content/complex-object-initialization-optimization-iife-c11&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;double or float, which is faster?: &lt;em&gt;https://stackoverflow.com/questions/4584637/double-or-float-which-is-faster&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;Why is ++i faster than i++ in C++?: &lt;em&gt;http://blog2.emptycrate.com/content/why-i-faster-i-c&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b1b1d1a70da9dcbebd86dc9c82d61471</guid>
<title>WebAssembly 的发展风险及Wasmtime 1.0 性能概览</title>
<link>https://toutiao.io/k/q8plntz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章关注 WebAssembly 的相关动态。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Fermyon | WebAssembly 的风险&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今早看到来自 fermyon 官方博客的&lt;span&gt;文章&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，介绍了 WebAssembly 现存的一些风险和他们的应对方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;标准化进展非常缓慢。为此 Fermyon 加入了 字节码联盟 亲自推动标准化进程，并通过构建 Spin 代码实现来充分利用标准&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语言支持不够。Fermyon 认为前 20 种语言中至少有 15 种必须完全支持 WebAssembly 以及 WASI 和组件，才能正确地认为 WebAssembly 被很好地采用。Fermyon 采取的立场是将注意力集中在最受欢迎的语言上，这就是为什么使用 Rust 而不是 C 或Zig。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;这方面也有一些好消息：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语言支持正在迅速增长，今年C#、Python和Ruby都增加了支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wasi 支持现在是进入 wasm 游戏领域的筹码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在主流实现语言未能发挥作用的地方，该语言的替代实现正在加紧发展，比如 tinygo 对于 wasm 的支持就超越了 go&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;生态系统不是可选的。WebAssembly 有望成为下一波计算浪潮，但除非 Fermyon 能围绕它建立生态系统，所以 Fermyon 正在努力联合相关其他企业合作共建社区。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;社区实现碎片化。（比如 deno 和其他非标准化实现，文章没有明说）。可悲的是，有时这仅仅是由于无知和不参与：“我们不知道有一个标准为此而出现”。所以目前发布的组件规范（正在进行中，但正在迅速成熟）旨在解决这类问题，这个标准使得在不同的主机实现之间共享 WebAssembly 二进制文件成为可能。还有一个不幸的趋势，即一些开发人员选择与组件模型相反的工作，创建与他们自己的主机运行时的强链接。走这条路一方面会导致平台锁定，另一方面会毫无意义地重新编写相同的代码（针对略有不同的主机进行工具化）。幸运的是，那些准备最好的人（Fastly、Mozilla、Microsoft）反而选择推动互操作性标准以造福所有人。这是正确的第一步。为了阻止破坏性的碎片化“手榴弹”，我们必须增加社会压力，不要我行我素，而要坚持互操作性标准。做到这一点的一个关键方法是彼此公开合作（通过字节码联盟、W3 和 CNCF 等组织），不仅要创建和实施标准，还要创建对话论坛。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;Fermyon 的愿景是，在五年内，WebAssembly 将成为常态，而不是小众市场。新一波应用程序将能够利用 WebAssembly 的速度、安全性和组件模型。为了实现这一目标，我们每个人都可以发挥作用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Wasmtime 1.0 性能概览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近日字节码联盟发布了&lt;span&gt; wasmtime 1.0 性能概览&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 的一篇文章，为将在 9.20号发布的 wasmtime 1.0 稳定版做前期铺垫，介绍了 wasmtime 团队近期在编译器和运行时中所做的工作。这里只做重点摘要，并非全文翻译，对细节感兴趣的可进一步参阅原文。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是性能&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让 Wasmtime 和 Cranelift 变得更快意味着什么？所谓的“快”是什么意思？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;Cranelift 也被用于 Rust Debug 模式编译后端&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 Wasmtime 执行 Wasm 程序时，CPU既执行从Wasm字节码编译的本地指令，也执行 &quot;Wasmtime Runtime &quot;的一部分，Wasmtime Runtime 用于维护数据结构以帮助实现Wasm语义。这两部分的执行有两个阶段：启动初始化（Wasm代码的编译，和运行时的初始化）和 稳态（steady-state）执行。这两个层面的四个组合都对性能有一定的影响，可以分别进行优化。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Compiler (Cranelift)&lt;/th&gt;&lt;th&gt;Runtime (Wasmtime)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;启动阶段&lt;/td&gt;&lt;td&gt;代码编译时间&lt;/td&gt;&lt;td&gt;Wasm 模块实例化时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;稳态阶段&lt;/td&gt;&lt;td&gt;生成代码的速度&lt;/td&gt;&lt;td&gt;运行时的基本速度&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wasmtime 对于改善这四个象限中的每一项都做了大量工作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Wasm 模块实例化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebAssembly 之所以安全是因为wasm 模块每个实例与生俱来的隔离性。为了有效地利用这种隔离性，Wasm的一些应用将每一个工作单元实例化为一个新的实例，例如服务器上每个传入的请求。因此，极快的模块实例化是像Wasmtime这样的Wasm VM的一个关键要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在 wasmtime 的模块实例化速度已经被优化到了微秒级别。这是如何做到的呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存技术&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去，wasmtime 是通过为 wasm 应用初始化一大块内存（通过malloc或mmap或一些其他分配器），然后将数据复制到正确的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，是从现代计算机使用的虚拟内存技术获得灵感，实现了一个 &lt;span&gt;实例分配器&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;使用了mmap 、madvise 和写时复制（copy-on-write）的技术将实例化的成本大大的降低了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;延迟初始化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wasmtime运行时在开始执行已编译的Wasm代码之前，要花费大量时间来初始化数据结构。所以，团队为函数引用表和它们所指向的函数闭包对象&lt;span&gt;实现了延迟初始化&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化结果&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SpiderMonkey.wasm&lt;/code&gt; 的实例化时间从大约2毫秒到5微秒，快了400倍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运行时性能&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wasm 执行过程中的大部分 CPU 时间通常花在Wasm程序本身，或它调用的 &quot;hostcalls&quot;（这是Wasmtime用户插入Wasmtime的代码，无法直接控制），除此之外，Wasmtime本身有一些部分在某些情况下必须运行，这部分代码就是 Wasmtime Runtime 的性能优化之处。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加速栈走查（Stack-Walking）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前，为了让Wasmtime列举所有的栈帧（stackframes），Cranelift编译器产生了所谓的 &quot;unwind info&quot;。这是一种元数据，描述了编译后的代码将在任意给定点上把值放在栈中。利用这些元数据，Wasmtime的 &quot;unwinder&quot;能够逆向程序状态：它理解一个活动函数每次调用的栈帧，最终找出谁调用了它，并在栈上迭代，直到它到达Wasm的初始入口。整个过程非常慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;团队对此进行了改进，确保始终保持一个帧指针的链表，从而达到栈走查像遍历链表那么简单。这种性能改进是一个巨大的质量改进：它允许启用栈跟踪，并大幅提高Wasmtime的健壮性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加速多任务协作 与 代际（Epoch） 中断&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wasmtime的一个常见用例是同时并发运行许多不同的 WebAssembly  guests，并在它们之间设置时间片。Wasmtime内置支持在一个异步事件循环上运行对Wasm的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wasmtime 用户在这种情况下可能遇到的一个问题是如何限制 Wasm 程序的执行时间。通常，当与事件循环异步运行时，计算密集型任务应拆分为多个段，以便事件循环不会停止超过最大“时间片”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过将 Wasm 字节码标准编译为本地机器代码，Wasm 中的循环成为编译代码中的循环，并运行尽可能多的迭代，没有限制。如果用户从事件循环中调用此函数，则该事件循环可能会无限期停止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，特别是在运行不受信任的代码时，Wasmtime 用户必须建立一种在一定时间限制后重新获得控制权的方法。所以 Wasmtime 必须提供一种在某个时间点中断 Wasm 执行的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前，实现这一行为的主要方式是通过“燃料（fuel）”。这是一种机制，通过该机制，已编译的 Wasm 代码增加了对“操作”进行计数的代码，根据限制检查当前计数，如果超出限制，则返回给调用者或事件循环。“燃料（fuel）”是一种有效的机制，但它成本很高：它需要用“计数”来扩充每一段代码，并经常将该计数存储到内存中并检查它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;团队使用了&lt;span&gt;基于代际的中断&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;取代了 “燃料（fuel）”机制，性能提升了两倍。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;使用 “燃料”机制还是代际中断，是一种权衡。“燃料”机制更加精准，而代际中断性能更好。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Cranelift 编译代码的质量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cranelift 用于将Wasm字节码编译成计算机可以直接执行的本地机器代码。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;寄存器分配器改造：regalloc2&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去的一年里，wasmtime引入了新的寄存器分配器 &lt;span&gt;regalloc2&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;。寄存器分配器是编译器的一个部分，它为程序中的值分配存储位置。在真正的CPU中，指令对寄存器中的数据进行操作，寄存器是一些小的存储位置，每个位置可以容纳一个值（例如，一个64位的数字）。寄存器分配器决定在什么时候将哪些值保存在哪些寄存器中。做好这一点可以大大改善程序的性能，因为它意味着更少的数值移动。WebAssembly，作为一个抽象的、与硬件无关的虚拟机，没有大多数指令的输入和输出位置的概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;regalloc2的设计是为了支持更高级的算法，以决定如何向寄存器分配数值。当引入时，它将&lt;code&gt;SpiderMonkey.wasm&lt;/code&gt;的运行时性能提高了约&lt;code&gt;5%&lt;/code&gt;，将另一个CPU密集型基准测试&lt;code&gt;bz2&lt;/code&gt;的性能提高了&lt;code&gt;4%&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更好的模式管理：新的后端、ISLE和持续的调整&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令选择问题是指选择最佳的CPU指令来实现一个给定的程序行为。因为每个CPU都有自己独特的指令集，而且这些指令可以以许多不同的方式组合，这是一个非常难解决的组合难题。Cranelift最初采用了一种新的编译器后端设计，可以实现更高级的模式匹配，目前采取的方法是用模式匹配DSL（特定领域语言）来表达底层的指令，这样我们就可以更容易地调整这些模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;未来：中端优化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未来，我们计划为Cranelift引入更先进的中端优化。中端优化器 &quot;是编译器的一部分，在程序被 &quot;降级&quot;为机器特定的形式之前（也就是在指令选择之前），以各种方式对程序进行转换，使其更快。有一套经典的优化方法，几乎所有的编译器都会执行，包括简化常数表达式（1+1变成2）等基本规则。但也有许多更复杂和微妙的转换。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Cranelift: 编译时优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了优化Cranelift生成的代码，编译过程本身如果太慢，那么Wasmtime可能需要很长的时间来启动新的代码，将会阻碍生产力（对于Wasm开发人员）和响应能力（对于访问新应用程序的最终用户）。因此，编译器的速度是一个重要的指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广义上讲，我们可以通过在后端关键部分选择更好的算法来提高编译时间，如寄存器分配器或优化通道，或通过做一般的程序优化，如减少内存使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;regalloc2&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切换到 regalloc2 显着改善了编译时间，因为寄存器分配占编译时间的很大一部分：测量单线程时间（不是并行编译），SpiderMonkey.wasm 的构建速度提高了 6%，bz2 的构建速度提高了 10%。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;中端优化器：将多个passes合并为一&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法重新设计也可以大大缩短编译时间。在我们的中端优化器原型中，我们对编译器设计的相关部分采取了一种新的方法：几个不同的 &quot;程序&quot;，或以某种方式改造程序的特定算法，被合并成一个统一的框架，只对程序进行一次处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;标准程序优化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种特别有效的提高速度的改变是减少内存的分配和使用。程序分配的内存越少，它的运行速度就越快，至少有两个原因：内存分配器本身可能很慢，而且使用更多的内存也会导致更多的缓冲区未命中和内存流量。由于其多线程编译模式，Cranelift也倾向于对分配器施加特别大的压力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高性能是任何希望成为构建高效、持久系统的基础的软件的一个关键方面。如果 WebAssembly 想要成功，它的运行速度必须能达到与本地代码竞争的水平。这也是 wasmtime 性能优化的终极目标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过该篇文章我们简单了解了 Wasmtime 和 Cranelift 性能优化的相关工作，以及当前 wasmtime 1.0 的性能状态（详细数据见原文）。后续的文章将介绍该团队如何确保 Wasmtime 安全以及编译器生成正确的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;文章: &lt;em&gt;https://www.fermyon.com/blog/risks-of-webassembly&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;wasmtime 1.0 性能概览: &lt;em&gt;https://bytecodealliance.org/articles/wasmtime-10-performance&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;实例分配器: &lt;em&gt;https://github.com/bytecodealliance/wasmtime/pull/3697&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;实现了延迟初始化: &lt;em&gt;https://github.com/bytecodealliance/wasmtime/pull/3733&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;基于代际的中断: &lt;em&gt;https://github.com/bytecodealliance/wasmtime/pull/3699&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;regalloc2: &lt;em&gt;https://github.com/bytecodealliance/regalloc2&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>