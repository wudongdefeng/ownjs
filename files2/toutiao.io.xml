<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5c55e7d84a6dcfb9bcbb867a999bf1a7</guid>
<title>架构师三大难：领域划分问题</title>
<link>https://toutiao.io/k/q25g5er</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485868&amp;amp;idx=1&amp;amp;sn=843459f44e37003814c7a9b44bf721ec&amp;amp;chksm=fafde302cd8a6a142123716eef9228df519285d9d1b94b6a135fb701adf8cf826a570298f497&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《架构师之路-redis集群解析》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《架构师之路-redis集群解析》&lt;/a&gt;提到：提出有水平的问题、做出有水平的总结和建议、做出有水平的回答 是架构师面临的三大难。&lt;/p&gt;&lt;p&gt;天天开会，最怕开会。开会十分钟，准备半天功。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002243&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2tk5ianItRl99HCEakE1XJbqGpiahvANc79ialFqN3Y5NJicf1ibFhIt1DUnE9XOsUb5RgxGYkQAq3WjV0LqI3cicXYQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面是围绕这三大难展开的故事。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;情景-领域划分问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;几年前的一天，在一个会上，完全不相关的团队人员在进行我们系统的架构评审。由于他们对我的系统不了解，提的问题多是针对架构师个人能力上的。&lt;/p&gt;&lt;p&gt;我在介绍的时候提到：“根据系统的特点，按照角色划分领域的同时结合现有人员情况划分了下面几个应用……”，然后我被打断了，有人提问说：“应用是按领域划分还是按照人员划分？”&lt;/p&gt;&lt;p&gt;针对这种埋坑的问题，选项有A和B，那更合理的答案一般是C。&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002241&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl99HCEakE1XJbqGpiahvANc7wE8IfibQA259iaH3b1FSx597gAuoxUV8wOiax0Y1b1HHu82RVBc3Y3a6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;&lt;p&gt;翻译提问者的问题其实是在问：“不是都是用领域划分领域吗？按照人员划分的方法不对吧？”&lt;/p&gt;&lt;p&gt;先来分析一下，我顺着提问者的话说会怎样：“模块需要按照领域划分，模块是分层级的。人员划分决定的是独立部署单位的粒度，在实际项目中应该综合考虑。”&lt;/p&gt;&lt;p&gt;这样虽然回答了提问者的问题，但是提问者很显然有知识上的盲区，需要我给他解惑的地方：“究竟要怎样划分应用？”而我的回答没有给出他完整的答案，他会继续找一些回答的漏洞来细化问题，比如：“资源预算不算做考虑粒度的因素吗？” 假定我每次顺着他的思路来，整个回答过程就没有清晰的结构了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100002242&quot; data-ratio=&quot;0.9815195071868583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl99HCEakE1XJbqGpiahvANc7hyrJhK8kLNiccfJx36iadeowdaTmszgutYvlKCWTguwhpt7VugrxwtLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;487&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以我需要直接针对他本质的问题展开回答，以下是回答内容：&lt;/p&gt;&lt;p&gt;在这次介绍的系统中，最主要的依据是按照领域来划分模块，同时根据资源和人员等情况来决定独立部署的应用模块的粒度。&lt;/p&gt;&lt;p&gt;但是在其他的系统中，根据不同的系统特点，模块或者应用的划分上，考虑侧重点会有所不同。我举几个例子。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;示例一(管道过滤器模式)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;比如工作流类的系统，从总体架构上采用的是管道过滤器模式&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.190625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56VOicS57DLZOX5s8iby5iarBoXiazJ1k7libMTgEib1NgAeCcWrzqhzYUxVXwMmticlBcjXic5rXz8rcXibuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图，在这种系统中主要有两种角色，一种是管理者角色，负责把其他模块组织串联起来，整体对外提供服务。记得之前做个这样的项目，管理者角色的模块系统名叫captain（当时大家都以漫威英雄人物命名，captain对应美国队长）。其他模块都是一个个过滤器。是否要将每个过滤器独立应用部署，还是主要根据人力和资源来定。只要设计清晰，将来人力和资源有调整，或者随着业务的发展，对稳定性有个更好的要求，可能会需要根据可用性做一个隔离。高SLA和低SLA的单独部署，高SLA的多地区多机房部署。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例二(三平面分离模式)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;比如三平面分离架构系统，详情可参考我之前的文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485742&amp;amp;idx=1&amp;amp;sn=b3fa976a6bc5ec30c3f4b7b93d60711f&amp;amp;chksm=fafde380cd8a6a968c2b8204ec1e5ebd48625b2ba51714f581d358007d69ba0e2e80223434ba&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《三平面分离架构》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《三平面分离架构》&lt;/a&gt;。简单来说分成最核心的流程控制平面、次核心的组件支撑平面和SLA只要求两个9的管理运维平面。如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43274244004171014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9CmJJia6SPKn3aiat9bnl33qic0t3amOJPEs8W0qUkN1Pzkib3juW3ZbkHwibtMFeibvw6X7mOQr2klIGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以领域划分时这三个平面要边界分明，三个平面可用性级别不同，资源分配也不同。比如最核心的流程控制平台日志存储要90天，其他可能需要30天；流程控制平面可能需每笔请求开始和结束打日志，而其他服务只需要异常时打日志；流程控制平面和组件支撑平面需要四地八中心高可用部署，而管理运维平台只需要两机房容灾。所以核心是要将三个平面分开以分配不同的资源。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例三(异步处理模式)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有些应用整体是实现一个大职责，但是被中间件分成了两个部分。比如有个服务是异步处理模式。所谓异步处理模式是将一个执行耗时长的流程分成两个阶段。比如退款操作。用户提交一个退款请求，先会收到一个实时通知：“您的退款请求已经收到，退款会于1~2个工作日内到账。”之后系统会将这个退款请求扔到MQ中，慢慢来消费处理。&lt;/p&gt;&lt;p&gt;这种模式的服务，根据实际资源等情况可以分成两个独立部署的系统，或者合在一个应用里既作为MQ的生产者又作为MQ的消费者。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/fEsWkVrSk56VOicS57DLZOX5s8iby5iarBoFsr3nIKUVKRZgdiaQib3Y3Y0G9BKwh0opBib5Vb25B2YN4RosD3icujTEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果观察到别人总是就细节进行追问，这时候可以先把思路跳出来弄清楚他的本质问题是什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485029&amp;amp;idx=1&amp;amp;sn=81b593816669318ee3203449177f90c9&amp;amp;chksm=fafdeccbcd8a65dd8a1116dd4eee9e9de9c4c8833e64854422d0a8bc57d28d83d8d57e1e936d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式存储系统的一致性-可见性差异&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;分布式存储系统的一致性-可见性差异&lt;/a&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>373f940ab32f6e77d17ed6a525aad010</guid>
<title>Kubernetes Deployment 的故障排查可视化指南（2021 中文版）</title>
<link>https://toutiao.io/k/cd9u887</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;将应用部署到 Kubernetes 时通常会使用 Deployment、Service、Ingress，整个应用从部署到正常运行，经历的流程很长。从 kubectl apply YAML 文件，经过 apiserver、controller manager、scheduler、kubelet、以及 CRI、CNI 等众多组件的协同工作。&lt;/p&gt;&lt;p&gt;漫长的“行程”，Pod 也经历各种正常和不正常的状态变化，即使正常运行也会出现服务无法访问的问题。对于刚开始在 Kubernetes 平台开展工作的同学来说，故障的排查确实棘手。之前工作的时候，经常要协助排查各种问题。去年在 Learnk8s 上看到了关于 Deployment 故障排查的视图，我还参考做了当时整个平台的故障排查视图，包括了从项目源码、CICD 流水线、部署整个流程的故障排查参考。&lt;/p&gt;&lt;p&gt;现在 Learnk8s 的 Deployment 排查指南更新了，也有了中文版本。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;年中翻译 Learnk8s 的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5OTg2MTM0MQ==&amp;amp;mid=2247484290&amp;amp;idx=1&amp;amp;sn=e5bc7afc42124df149c52a2ddd4c8591&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《Kubernetes 的自动伸缩你用对了吗？》&quot; data-linktype=&quot;2&quot;&gt;《Kubernetes 的自动伸缩你用对了吗？》&lt;/a&gt; 时，与 Daniele Polencic 沟通时被问及是否能翻译故障排查的可视化指南。&lt;/p&gt;&lt;p&gt;年中的时候就翻译完了，今天电报上被告知文章 A visual guide on troubleshooting Kubernetes deployments已更新，排查视图较上一版有了部分的调整。&lt;/p&gt;&lt;p&gt;原文：https://learnk8s.io/troubleshooting-deployments&lt;/p&gt;&lt;p&gt;中文版PDF：https://learnk8s.io/a/a-visual-guide-on-troubleshooting-kubernetes-deployments/troubleshooting-kubernetes.zh_cn.v2.pdf&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4151260504201681&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tMghG0NOfxfK6IYu0bwEkN5uJaurZ3NOlLnNn1geEZUV19IEqV7TGKQggqmwYibL3uHzlMiaVf8OiaEgggAYBcTxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1785&quot; title=&quot;null&quot;/&gt;&lt;figcaption&gt;troubleshooting-kubernetes.zh_cn.v2&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;文章能看到这里，我已满足。&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4edd9ba10ccb61b3cc690690f6cd15be</guid>
<title>@Import 注解：导入配置类的四种方式 &amp; 源码解析</title>
<link>https://toutiao.io/k/dd73o71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hXEWOsco2BX1GUrLia73kRWicgUaNia6RTha47Yv20nriaNsDPGAicJ9kibdB3iaTnvaOfXVFeibgGkrTM5NkmiamhzucMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信搜索：码农StayUp&lt;/p&gt;&lt;p&gt;主页地址：https://gozhuyinglong.github.io&lt;/p&gt;&lt;p&gt;源码分享：https://github.com/gozhuyinglong/blog-demos&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时喜欢看源码的小伙伴，应该知道Spring中大量使用了&lt;code&gt;@Import&lt;/code&gt;注解。该注解是Spring用来导入配置类的，等价于&lt;code&gt;Spring XML&lt;/code&gt;中的&lt;code&gt;&amp;lt;import/&amp;gt;&lt;/code&gt;元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将对该注解进行介绍，并通过实例演示它导入配置类的四种方式，最后对该注解进行源码解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，走起~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Import&lt;/code&gt;注解的全类名是&lt;code&gt;org.springframework.context.annotation.Import&lt;/code&gt;。其只有一个默认的&lt;code&gt;value&lt;/code&gt;属性，该属性类型为&lt;code&gt;Class&amp;lt;?&amp;gt;[]&lt;/code&gt;，表示可以传入一个或多个&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过注释可以看出，该注解有如下作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以导入一个或多个组件类（通常是&lt;code&gt;@Configuration&lt;/code&gt;配置类）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该注解的功能与&lt;code&gt;Spring XML&lt;/code&gt;中的&lt;code&gt;&amp;lt;import/&amp;gt;&lt;/code&gt;元素相同。可以导入&lt;code&gt;@Configuration&lt;/code&gt;配置类、&lt;code&gt;ImportSelect&lt;/code&gt;和&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类。从4.2版本开始，还可以引用常规组件类（普通类），该功能类似于&lt;code&gt;AnnotationConfigApplicationContext.register&lt;/code&gt;方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该注解可以在类中声明，也可以在元注解中声明。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果需要导入&lt;code&gt;XML&lt;/code&gt;或其他非&lt;code&gt;@Configuration&lt;/code&gt;定义的资源，可以使用&lt;code&gt;@ImportResource&lt;/code&gt;注释。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;导入配置类的四种方式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码注释写得很清楚，该注解有四种导入方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Configuration&lt;/code&gt;配置类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ImportSelector&lt;/code&gt;的实现类&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们逐个来介绍~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;准备工作&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建四个配置类：ConfigA、ConfigB、ConfigC、ConfigD。其中ConfigB中增加&lt;code&gt;@Configuration&lt;/code&gt;注解，表示为配置类，其余三个均为普通类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigA：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigA.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigB：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigB.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigC：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigC&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigC.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConfigD：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ConfigD&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;输出：ConfigD.class&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再创建一个主配置类Config，并试图通过&lt;code&gt;@Resource&lt;/code&gt;注解将上面四个配置类进行注入。当然，这样是不成功的，还需要将它们进行导入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigA configA;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigB configB;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigC configC;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    ConfigD configD;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        configA.print();&lt;br/&gt;        configB.print();&lt;br/&gt;        configC.print();&lt;br/&gt;        configD.print();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式一：导入普通类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入普通类非常简单，只需在&lt;code&gt;@Import&lt;/code&gt;传入类的&lt;code&gt;Class&lt;/code&gt;对象即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式二：导入&lt;code&gt;@Configuration&lt;/code&gt;配置类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导入配置类与导入普通类一样，在&lt;code&gt;@Import&lt;/code&gt;注解中传入目标类的&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式三：导入&lt;code&gt;ImportSelector&lt;/code&gt;的实现类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ImportSelector&lt;/code&gt;接口的全类名为&lt;code&gt;org.springframework.context.annotationImportSelector&lt;/code&gt;。其主要作用的是收集需要导入的配置类，并根据条件来确定哪些配置类需要被导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的实现类同时还可以实现以下任意一个&lt;code&gt;Aware&lt;/code&gt;接口，它们各自的方法将在&lt;code&gt;selectImport&lt;/code&gt;之前被调用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EnvironmentAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanFactoryAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanClassLoaderAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourceLoaderAware&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，该接口实现类可以提供一个或多个具有以下形参类型的构造函数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Environment&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;BeanFactory&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ClassLoader&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourceLoader&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想要推迟导入配置类，直到处理完所有的&lt;code&gt;@Configuration&lt;/code&gt;。那么你可以使用&lt;code&gt;DeferredImportSelector&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们创建一个实现该接口的类 MyImportSelector。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下面示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;selectImports&lt;/code&gt;方法中，入参&lt;code&gt;AnnotationMetadata&lt;/code&gt;为主配置类 Config 的注解元数据。返回值为目标配置类 ConfigC 的全类名，这里是一个数组，表示可以导入多个配置类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;io.github.gozhuyinglong.importanalysis.config.ConfigC&quot;&lt;/span&gt;};&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置类 Config 中导入 MyImportSelector 类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方式四：导入&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;的实现类&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口的目的是有选择性的进行注册&lt;code&gt;Bean&lt;/code&gt;，注册时可以指定&lt;code&gt;Bean&lt;/code&gt;名称，并且可以定义bean的级别。其他功能与&lt;code&gt;ImportSelector&lt;/code&gt;类似，这里就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来看示例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个实现 &lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt; 接口的类 MyImportBeanDefinitionRegistrar，并在 &lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法中注册 configD 类。入参 &lt;code&gt;AnnotationMetadata&lt;/code&gt;为主配置类 Config 的注解元数据；&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;参数可以注册&lt;code&gt;Bean&lt;/code&gt;的定义信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;configD&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(ConfigD&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置类 Config 中导入 MyImportBeanDefinitionRegistrar 类。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;({ConfigA&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;ConfigB&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试结果&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个测试类 ImportDemo，看上面四个配置类是否被注入。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        AnnotationConfigApplicationContext ctx = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(Config&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        Config config = ctx.getBean(Config&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        config.print();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;输出：ConfigA.class&lt;br/&gt;输出：ConfigB.class&lt;br/&gt;输出：ConfigC.class&lt;br/&gt;输出：ConfigD.class&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过输出结果可以看出，这四个配置类被导入到主配置类中，并成功注入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码解析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConfigurationClassParser&lt;/code&gt;类为Spring的工具类，主要用于分析配置类，并产生一组&lt;code&gt;ConfigurationClass&lt;/code&gt;对象（因为一个配置类中可能会通过&lt;code&gt;@Import&lt;/code&gt;注解来导入其它配置类）。也就是说，其会递归的处理所有配置类。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;doProcessConfigurationClass&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的&lt;code&gt;doProcessConfigurationClass&lt;/code&gt;方法是处理所有配置类的过程，其按下面步骤来处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;@Component注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PropertySource注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ComponentScan注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Import注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ImportResource注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@Bean注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置类的接口上的默认方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置类的超类&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Nullable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SourceClass &lt;span&gt;doProcessConfigurationClass&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    ConfigurationClass configClass, SourceClass sourceClass, Predicate&amp;lt;String&amp;gt; filter)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (configClass.getMetadata().isAnnotated(Component&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;())) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1.首先会递归的处理所有成员类，即@Component注解&lt;/span&gt;&lt;br/&gt;        processMemberClasses(configClass, sourceClass, filter);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 2.处理所有@PropertySource注解&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(&lt;br/&gt;        sourceClass.getMetadata(), PropertySources&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;org&lt;/span&gt;.&lt;span&gt;springframework&lt;/span&gt;.&lt;span&gt;context&lt;/span&gt;.&lt;span&gt;annotation&lt;/span&gt;.&lt;span&gt;PropertySource&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.environment &lt;span&gt;instanceof&lt;/span&gt; ConfigurableEnvironment) {&lt;br/&gt;            processPropertySource(propertySource);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            logger.info(&lt;span&gt;&quot;Ignoring @PropertySource annotation on [&quot;&lt;/span&gt; + sourceClass.getMetadata().getClassName() +&lt;br/&gt;                        &lt;span&gt;&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 3.处理所有@ComponentScan注解&lt;/span&gt;&lt;br/&gt;    Set&amp;lt;AnnotationAttributes&amp;gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(&lt;br/&gt;        sourceClass.getMetadata(), ComponentScans&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;ComponentScan&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!componentScans.isEmpty() &amp;amp;&amp;amp;&lt;br/&gt;        !&lt;span&gt;this&lt;/span&gt;.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (AnnotationAttributes componentScan : componentScans) {&lt;br/&gt;            &lt;span&gt;// 配置类的注解为@ComponentScan-&amp;gt; 立即执行扫描&lt;/span&gt;&lt;br/&gt;            Set&amp;lt;BeanDefinitionHolder&amp;gt; scannedBeanDefinitions =&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());&lt;br/&gt;            &lt;span&gt;// 检查扫描过的BeanDefinition集合，看看是否有其他配置类，如果需要，递归解析&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (BeanDefinitionHolder holder : scannedBeanDefinitions) {&lt;br/&gt;                BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bdCand == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bdCand = holder.getBeanDefinition();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, &lt;span&gt;this&lt;/span&gt;.metadataReaderFactory)) {&lt;br/&gt;                    parse(bdCand.getBeanClassName(), holder.getBeanName());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 4.处理所有@Import注解&lt;/span&gt;&lt;br/&gt;    processImports(configClass, sourceClass, getImports(sourceClass), filter, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 5.处理所有@ImportResource注解&lt;/span&gt;&lt;br/&gt;    AnnotationAttributes importResource =&lt;br/&gt;        AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (importResource != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        String[] resources = importResource.getStringArray(&lt;span&gt;&quot;locations&quot;&lt;/span&gt;);&lt;br/&gt;        Class&amp;lt;? extends BeanDefinitionReader&amp;gt; readerClass = importResource.getClass(&lt;span&gt;&quot;reader&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String resource : resources) {&lt;br/&gt;            String resolvedResource = &lt;span&gt;this&lt;/span&gt;.environment.resolveRequiredPlaceholders(resource);&lt;br/&gt;            configClass.addImportedResource(resolvedResource, readerClass);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 6.处理标注为@Bean注解的方法&lt;/span&gt;&lt;br/&gt;    Set&amp;lt;MethodMetadata&amp;gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (MethodMetadata methodMetadata : beanMethods) {&lt;br/&gt;        configClass.addBeanMethod(&lt;span&gt;new&lt;/span&gt; BeanMethod(methodMetadata, configClass));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 7.处理配置类的接口上的默认方法&lt;/span&gt;&lt;br/&gt;    processInterfaces(configClass, sourceClass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 8.处理配置类的超类（如果有的话）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (sourceClass.getMetadata().hasSuperClass()) {&lt;br/&gt;        String superclass = sourceClass.getMetadata().getSuperClassName();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (superclass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !superclass.startsWith(&lt;span&gt;&quot;java&quot;&lt;/span&gt;) &amp;amp;&amp;amp;&lt;br/&gt;            !&lt;span&gt;this&lt;/span&gt;.knownSuperclasses.containsKey(superclass)) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.knownSuperclasses.put(superclass, configClass);&lt;br/&gt;            &lt;span&gt;// Superclass found, return its annotation metadata and recurse&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sourceClass.getSuperClass();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理完成&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;processImports&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;processImports&lt;/code&gt;方法为处理&lt;code&gt;@Import&lt;/code&gt;注解导入的配置类，是我们本篇的主题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会循环处理每一个由@Import导入的类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ImportSelector类的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ImportBeanDefinitionRegistrar类的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它类统一按照@Configuration类来处理，所以加不加@Configuration注解都能被导入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 处理配置类上的&lt;span&gt;@Import&lt;/span&gt;注解引入的类&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; configClass 配置类，这里是Config类&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; currentSourceClass 当前资源类&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; importCandidates 该配置类中的&lt;span&gt;@Import&lt;/span&gt;注解导入的候选类列表&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; exclusionFilter 排除过滤器&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; checkForCircularImports 是否循环检查导入&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processImports&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass, SourceClass currentSourceClass,&lt;br/&gt;                            Collection&amp;lt;SourceClass&amp;gt; importCandidates, Predicate&amp;lt;String&amp;gt; exclusionFilter,&lt;br/&gt;                            &lt;span&gt;boolean&lt;/span&gt; checkForCircularImports)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 如果该@Import注解导入的列表为空，直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (importCandidates.isEmpty()) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt; &lt;span&gt;// 循环检查导入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (checkForCircularImports &amp;amp;&amp;amp; isChainedImportOnStack(configClass)) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.problemReporter.error(&lt;span&gt;new&lt;/span&gt; CircularImportProblem(configClass, &lt;span&gt;this&lt;/span&gt;.importStack));&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.importStack.push(configClass);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 循环处理每一个由@Import导入的类&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (SourceClass candidate : importCandidates) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;// 1. ImportSelector类的处理&lt;/span&gt;&lt;br/&gt;                    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                    ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                                                                                   &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                    Predicate&amp;lt;String&amp;gt; selectorFilter = selector.getExclusionFilter();&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selectorFilter != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        exclusionFilter = exclusionFilter.or(selectorFilter);&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selector &lt;span&gt;instanceof&lt;/span&gt; DeferredImportSelector) {&lt;br/&gt;                        &lt;span&gt;// 1.1 若是DeferredImportSelector接口的实现，则延时处理&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;// 1.2 在这里调用我们的ImportSelector实现类的selectImports方法&lt;/span&gt;&lt;br/&gt;                        String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());&lt;br/&gt;                        Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);&lt;br/&gt;                        &lt;span&gt;// 1.3 递归处理每一个selectImports方法返回的配置类&lt;/span&gt;&lt;br/&gt;                        processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                     &lt;span&gt;// 2. ImportBeanDefinitionRegistrar类的处理&lt;/span&gt;&lt;br/&gt;                    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                    ImportBeanDefinitionRegistrar registrar =&lt;br/&gt;                        ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                                                             &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 3. 其它类统一按照@Configuration类来处理，所以加不加@Configuration注解都能被导入&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.importStack.registerImport(&lt;br/&gt;                        currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());&lt;br/&gt;                    processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionStoreException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; ex;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionStoreException(&lt;br/&gt;                &lt;span&gt;&quot;Failed to process import candidates for configuration class [&quot;&lt;/span&gt; +&lt;br/&gt;                configClass.getMetadata().getClassName() + &lt;span&gt;&quot;]&quot;&lt;/span&gt;, ex);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.importStack.pop();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面源码的解析可以看出，&lt;code&gt;@Import&lt;/code&gt;注解主要作用是导入外部类的，并且普通类也会按照&lt;code&gt;@Configuration&lt;/code&gt;类来处理。这大大方便了我们将自己的组件类注入到容器中了（无需修改自己的组件类）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码分享&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码请访问我的Github，若对你有帮助，欢迎给个⭐，感谢~~🌹🌹🌹&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/gozhuyinglong/blog-demos/tree/main/spring-source-analysis/src/main/java/io/github/gozhuyinglong/importanalysis&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于作者&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;项目&lt;/th&gt;&lt;th&gt;内容&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;公众号&lt;/td&gt;&lt;td&gt;码农StayUp（ID：AcmenStayUp）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;主页&lt;/td&gt;&lt;td&gt;https://gozhuyinglong.github.io&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CSDN&lt;/td&gt;&lt;td&gt;https://blog.csdn.net/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;掘进&lt;/td&gt;&lt;td&gt;https://juejin.cn/user/1239904849494856&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Github&lt;/td&gt;&lt;td&gt;https://github.com/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Gitee&lt;/td&gt;&lt;td&gt;https://gitee.com/gozhuyinglong&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/hXEWOsco2BX1GUrLia73kRWicgUaNia6RThGmC9HQU3icLhIHLjTH5V8x2tzeSjMgMhYd6lJGbBpTyvTMnuBRI3nDg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fe80de2d3c36b3da972847431267af86</guid>
<title>别被你的框架框住了</title>
<link>https://toutiao.io/k/eippx4u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;main class=&quot;post-styles_main__2vaxQ&quot;&gt;&lt;p class=&quot;zh-cn&quot;&gt;我短暂的职业生涯被 React 充斥着。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;还没毕业前我从 Vue 2.x 入手开始学习框架，在一个我当时觉得还行现在回看完全不行的状态进了公司。然后开启了跟 React 死磕的状态，从 class 组件到函数式组件，从 Redux 到 Recoil，从 Antd 到 MUI...&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不久前一个呆了2年多的项目成功结束，接下来要去一个新项目，新项目要用 Angular，于是我开始告别从毕业就开始用的 React，开始学习这个大家少有提及的框架。&lt;/p&gt;
&lt;h2 id=&quot;得&quot;&gt;得&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;回顾这几年，要说 React 带给我最多的是什么，我觉得可能是思想，是一种编程范式。为了理解 React 新的函数式组件，我去学习 FP，但我并不是一个原教旨主义者，所以我当然也不认同你想学 FP 就得去学 Lisp 的说法。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;在这期间我发现&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS&quot;&gt;小黄书&lt;/a&gt;的作者 &lt;a href=&quot;https://www.linkedin.com/in/getify&quot;&gt;Kyle Simpson&lt;/a&gt; 也写了一本专门为 JSer 介绍 FP 的&lt;a href=&quot;https://github.com/getify/Functional-Light-JS&quot;&gt;书&lt;/a&gt;，书中前言部分我深以为然：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;The way I see it, functional programming is at its heart about using patterns in your code that are well-known, understandable, &lt;em&gt;and&lt;/em&gt; proven to keep away the mistakes that make code harder to understand.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;是的，编程范式的作用是为了让人们更好地组织和理解代码，编程范式应该去服务写代码的人，而不是人去事无巨细地遵循编程范式的每一个规则，理解每一个晦涩难懂的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;I believe that programming is fundamentally about humans, not about code. I believe that code is first and foremost a means of human communication, and only as a &lt;em&gt;side effect&lt;/em&gt; (hear my self-referential chuckle) does it instruct the computer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;敏捷需要以人为本，写代码其实也一样。我们要做的应该是理解编程范式本身以及它背后的作用，或许在未来的某天你会突然发现，原来我用了这么久的这个玩意儿有一个这么有意思的名字，亦或者你可能永远也解释不清楚那个概念到底是什么：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;A monad is just a monoid in the category of endofunctors.&lt;/em&gt;&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;&lt;em&gt;一个单子不过是自函子范畴上的幺半群&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;那是不是搞不懂我就不能玩 FP 了？然后我就得站在鄙视链底端，被 Haskell、Lisp 玩家们指着鼻子嘲笑：你们看那家伙，其实啥也不懂，他那也叫 FP？&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;这个问题我没有答案，或许可以留给大家来讨论。但是到这里我至少明白了 React Hooks 为什么要叫 &quot;hook&quot;；为什么有一个 hook 叫 &quot;useEffect&quot;；我也理解了为什么大家都说不要用 hook 去实现 class 组件的生命周期。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;除了写好 React 本身，我也尝试了纯函数、偏函数、柯里化、组合和 Point-free 风格的代码，确实得到了一些好处，也确实带来了一些不便。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;可能这些思想就是学习 React 带给我最大的 side effect 吧（笑。&lt;/p&gt;
&lt;h2 id=&quot;失&quot;&gt;失&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;与 React 准备 all in FP 相反的是，与 Angular 短暂接触的我发现它全面拥抱 OOP。与当时 React 从 class 组件切换到函数式组件一样，首先你得把编程范式思想完全转变过来才能很好地理解 Angular。这又促使我不得不去复习许多被我丢弃很久的 OOP 思想。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;到这我不禁想起一次公司内 TDD 训练营，作业完成后去找 coach 讲解，讲解过程中 coach 讲到了抽象能力、隔离层、防腐层。那时我才发现自己 OO 的抽象能力和一起的后端小伙伴一比实在是差到不行，只有大学时候的能力。反思过后像是被 React 给“惯”坏了，几乎已经丢掉了这部分能力。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;老实说我接触 React class 组件时间并不长，第一个项目只有短短几个月。后面两个项目虽然去写 Java 了，但是第一个都是一些修修补补的工作，更像是在做 DevOps，后来的项目去写 Java BFF，毫无抽象可言，全是数据 mapping。然后又进到了一个将“追求技术卓越”贯彻执行的项目，成了那批最早吃函数式组件螃蟹的人。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是我接触 class 组件的时间就只有作为毕业生的那短短几个月而已。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;然后当我看到 Angular 文档中的依赖注入时，我脑子只能零星蹦出一些概念：SOLID、解耦。别说细节，我甚至不知道我蹦出来的这些东西是不是对的。于是我又只能凭着自己的记忆去邮件里搜相关的博客大赛的文章。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;我好像已经丢掉了 OOP 了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;zh-cn&quot;&gt;种下一棵树最好的时间是十年前，其次是现在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;悟&quot;&gt;悟&lt;/h2&gt;
&lt;p class=&quot;zh-cn&quot;&gt;跳出all in FP 的 React 我发现世界不是非黑即白的。说是全面拥抱 OOP，但其实你可以很轻易的在 Angular 中发现 FP 的影子 -- 用 pipe 来处理数据，用 Rx 来处理请求。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;既然是以人为本，编程范式本就&lt;strong&gt;不应该对立&lt;/strong&gt;，它们明明可以互补，在自己擅长的领域处理自己擅长的事情，哪怕是同一个项目。看惯了两个阵营吵架的场景，好像这样的场景才是我想要的。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;于是我又回忆起某天在项目上和大家讨论的项目分包问题，最后的结论是 OOP 的以对象和 domain 分包的策略在大多数时候要优于单纯的 FP 的方式。它能让功能更集中，让大家更容易找到自己想要找的东西。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;但是回过头来静静思考，我虽然会好好学习 OOP，但是我目前大概率不会去深入学习相关的建模方法。因为在目前我的工作环境下，我没看到有前端同学需要深刻理解建模方法的场景，大多数情况浅尝辄止即可。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;以我自身的经历来看，DDD 我看过也参加过培训，也跟着项目后端小伙伴在搭建项目时从零到一实践过。但是在实践不多的情况下，整个过程逃脱不了学了忘忘了学的魔咒。大概唯一的用处就是当我被抓到后端去干活能看懂他们为什么要这么组织代码，至于建模的那个过程，被抓去干活的我是大概率不会参与的。（当然如果你有相关的经历还请喷醒我，比如你作为偏前端的小伙伴就是要熟练掌握建模方法，不然工作就做不下去了）&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;不要被技术栈限制住了自己，其实以前一直对这句话一知半解，虽然可能现在的理解也没有很强。可是当你从一个框里跳出来以后，去思考画框这个人的想法，你可能能够得到一些不一样的思考。对于 Thoughtworker 来说学习一个新框架，一门新语言可能不是什么问题，那我们是不是可以更进一步，想想那些看起来“虚无缥缈”的东西呢。&lt;/p&gt;
&lt;p class=&quot;zh-cn&quot;&gt;别被你的框架框住你了。&lt;/p&gt;
&lt;/main&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0b6b86fa0f5b2a2917377573742f79b</guid>
<title>C/C++ 为什么要专门设计个 do…while？</title>
<link>https://toutiao.io/k/n0wpt8l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初&lt;code&gt;do ... while&lt;/code&gt;的出现，更多的是作为循环控制流的一种语法糖。因为不论是while 还是 for循环，都是要先判断是否满足进入循环体的条件的。满足条件之后才能进入循环去执行循环体内的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而有些时候，第一次的执行逻辑我们不需要满足循环条件，也要执行。这时候就可以用&lt;code&gt;do ... while&lt;/code&gt;。举个例子，前几天的LeetCode每日一题 &lt;code&gt;869. 重新排序得到2的幂&lt;/code&gt;，刚好遇到这么一个场景：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;https://leetcode-cn.com/problems/reordered-power-of-2/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解题偷懒的话，可以直接用STL的排列相关的函数next_permutation来解答：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;reorderedPowerOf2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;auto&lt;/span&gt; check = [](&lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (n&amp;amp;(n&lt;span&gt;-1&lt;/span&gt;)) == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        };&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;string&lt;/span&gt; s = to_string(n);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; len = s.size();&lt;br/&gt;        sort(s.begin(), s.end());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; (next_permutation(s.begin(), s.end()));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本题，在我们将字符串&lt;code&gt;sort()&lt;/code&gt;以后，变成了字典升序，然后每次通过调用&lt;code&gt;next_permutation()&lt;/code&gt; 修改字符串s，变成其中字母的下一个排列。当不存在下一个排列的时候（字符串已经变成字典序逆序），返回false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一开始进来的时候不能&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;while&lt;/span&gt; (next_permutaion(s.begin(), s.end()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这样会导致sort完成的那个s（升序）没有参与到check的计算，造成遗漏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不能&lt;code&gt;do ... while&lt;/code&gt;就只能这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        sort(s.begin(), s.end());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;&#x27;0&#x27;&lt;/span&gt; &amp;amp;&amp;amp; check(stoi(s))) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (next_permutation(s.begin(), s.end())) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (check(stoi(s))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在while执行之前做一次check计算，然后才进入while。逻辑上当然没问题，只是造成了代码冗余。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这是do ... while最初的用法，后面程序员们集思广益，又利用do ... while的特性发明了独特了 do ... while(0)的特殊使用场景&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;do ... while(0) 搭配宏函数的定义&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;C和C++语言中有宏的概念，而Java没有，所以这个条款对Java程序员没有用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在C/C++中，有时候我们可能用宏来定义“函数”。我们都知道其本质还是宏，而非函数。所以其实还是在编译预处理阶段进行代码文本的暴力替换！而如果你定义的宏函数中的代码，被插入的位置，附近有括号或分号，有时候常常不能如你所愿的编译运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而do ... while(0)构造的代码块则不会受到大括号、分号等的影响。不管你把你的宏函数放到任何地方都不会出错。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Redis源码中就有大量的这种用法，下面这段出自zmalloc的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; update_zmalloc_stat_alloc(__n) do { \&lt;br/&gt;    size_t _n = (__n); \&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (_n&amp;amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;amp;(sizeof(long)-1)); \&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (zmalloc_thread_safe) { \&lt;br/&gt;        update_zmalloc_stat_add(_n); \&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; { \&lt;br/&gt;        used_memory += _n; \&lt;br/&gt;    } \&lt;br/&gt;} while(0)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;do ... while(0) 中断顺序执行的逻辑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个条款适用于C、C++、Java等有&lt;code&gt;do ... while&lt;/code&gt;用法的语言。由于Java中int和bool不能转换，所以在Java中是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面言归正传，关于这个用法，其实我在之前这篇文章的条款7也介绍过了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004091&amp;amp;idx=1&amp;amp;sn=47b2a52d314ef7d83d0350134d082e59&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVicmf7qVbUxrD7rT1JO3gpshG6PFfuNdhHhkx9wbibDCqGC1mNoAKDibew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;C++代码简化之道（一）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概括一下，函数（或方法）中一段顺序逻辑，依次经历1，2，3三个步骤，然后是其他逻辑（比如 4， 5）。其中1，如果失败就不执行2，2如果失败不执行3。就是逻辑中断之后直接跳到4和5。容易想到的实现思路有三：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把步骤1， 2，3抽象成函数。每次判断函数的返回值，成功才调用下一个函数。OK。这样没问题。但是如果这种类似的逻辑很多，就要抽成很多个函数，而每个函数内只有寥寥几行代码。未免啰嗦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用异常。如果是Java语言应该很习惯用异常来实现这个逻辑，把顺序逻辑封在try catch块里。每个步骤失败直接throw异常。OK，C++也可以写类似的代码。然而C++用异常隐患很多，不如Java安全，很多工程规范都竭力避免抛异常。另外就是抛异常也不是无开销的，而且这里只是逻辑中断，逻辑上也不算『异常』，通过throw异常和catch异常的方式未免影响代码可读性……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goto【Java没有，C和C++有】确实看过一些代码确实在这种场合使用过goto。当然我们要严厉禁止goto。这个方案直接略过。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有第4种方案：&lt;code&gt;do while(0)&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 步骤1&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;1&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤2&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;2&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤3&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;3&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 步骤4&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;// 步骤5&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个其实也适用于其他用do while的语言，不止C++。当然关于这个用法在C++11以后，很多人提出，用立即执行的lambda会更好，表现力会更强一些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[...](...) { &lt;span&gt;// 通过捕获或传参传入一些上下文中的变量，&lt;/span&gt;&lt;br/&gt;             &lt;span&gt;// 用...替代，表示省略 ...不是语法的一部分！&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 步骤1&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;1&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤2&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;2&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 步骤3&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (步骤&lt;span&gt;3&lt;/span&gt;失败) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}(); &lt;span&gt;// 比普通lambda表达式多了一个括号，表示立即执行&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种匿名的、定义处立即执行的lambda，也叫&lt;code&gt;IIFE&lt;/code&gt;(Immediately Invoked Function Expression) ，翻译成：&lt;strong&gt;立即调用函数表达式&lt;/strong&gt;。IIFE是Javascript中的概念，见国外有些人也把C++的这种lambda表达式用法称作IIFE，私以为可能不是C++这边的官方说法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Anyway，不过其实IIFE的风格，代码量上也并没有比&lt;code&gt;do ... while(0)&lt;/code&gt;减少多少，而且还要额外的传参或捕获。支持者们认为，这里面的return中断逻辑，要比&lt;code&gt;do ... while(0)&lt;/code&gt;的 break表达中断要好。这个……见仁见智吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649003059&amp;amp;idx=1&amp;amp;sn=9de099fe618452c90e068d6761b4dd02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4239036973344798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnV8Qk0GUHFMdnoR10ibjRQTPG9TZF3JVk21x3J7DI1iaRlYaIBEGPGAKJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1163&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;实践解读CLOSE_WAIT和TIME_WAIT&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649002886&amp;amp;idx=1&amp;amp;sn=815697147d0fd7415a4fc0d73aec5c89&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVxuBDN1QwQ44Sqajt3ZYFmVuTrqvQu9CZUTqiaEn36jNGicuroTiaib4bBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;大四那一年&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004681&amp;amp;idx=1&amp;amp;sn=02f8c4509b18de5d8c8abac527bbf660&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4247211895910781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVxicDpx1lZwANYsYEfU8HqxxUwUcOltniaQLmVmYIDWvzz4WroIomO02Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;白嫖Github的Action做定时任务&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004646&amp;amp;idx=1&amp;amp;sn=e3f3a6e5b6e7e03e8be4660b9c983f18&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnV7pThXHiaOcsNVcxq9JGjibibfH8icfvGhUFwnpzNTzVAUXYWnFQfeIkhBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;brpc小课堂：从StringPiece说开来&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5NDIyMjI3OQ==&amp;amp;mid=2649004917&amp;amp;idx=1&amp;amp;sn=4ab837ecf07f7e3b6170eef797c5c518&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4261954261954262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hQZ4NEZ2sic4EJTcpzKx6Djia6NqvibMPnVGv5jamXIR4I8NH1yCyeuicia4NTve87QPHQUfLsHYYqmY7EcFEpW6EKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;figcaption&gt;STL中有哪些副作用或容易会产生性能开销的地方？&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>