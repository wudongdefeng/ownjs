<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>32b0b982cd10d054be6e2b9d3f476e2a</guid>
<title>简单一招，百倍提速 Flutter 开发</title>
<link>https://toutiao.io/k/0iy9gm8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;&lt;p&gt;Flutter 开发中，为了实现更好的解耦与更高的复用，我们都会使用模块化的思路来处理，在Dart 和 Flutter 中，我们会使用 Dart 包或者插件包等，将它们发布到比如自己的unpub 服务器上，然后在壳工程（主工程）中聚合使用。&lt;/p&gt;
&lt;p&gt;比如一个 壳工程的 yaml 是这样的&lt;/p&gt;
&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;10&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;dependencies&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;flutter&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;l-Scalar-Plain&quot;&gt;sdk&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;flutter&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;firebase_crashlytics&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;2.4.5&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;firebase_analytics&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;9.0.5&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;basic&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;l-Scalar-Plain&quot;&gt;hosted&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;l-Scalar-Plain&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;basic&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;l-Scalar-Plain&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;https://unpub.droidyue.com&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;l-Scalar-Plain&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;1.6.2&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;于是有这样一个场景，我们想要在basic 包里面加一个方法，并应用到 主工程中。&lt;/p&gt;
&lt;p&gt;但是在执行处理的时候，我们会有这样的考虑&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果修改的内容，通过 unpub 进行验证，时间成本很大。&lt;/li&gt;
&lt;li&gt;但是发布到unpub，需要有一定的质量把控，修改的内容必须进行验证通过后，才能发布到unpub 服务器上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，我们需要尝试寻找一种不通过 unpub，更快速验证修改内容的方式。&lt;/p&gt;
&lt;p&gt;好在 dart 提供了 &lt;code&gt;dependency_overrides&lt;/code&gt; 这个配置项来处理依赖重写问题。&lt;/p&gt;

&lt;p&gt;使用起来也很简单，下面就是我们实现重写 basic 的示例，基本上只需要关心 包名称(basic)与 path (../basic)即可。&lt;/p&gt;
&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;l-Scalar-Plain&quot;&gt;dependency_overrides&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;l-Scalar-Plain&quot;&gt;basic&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;l-Scalar-Plain&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p-Indicator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;../basic&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;虽然提供了上面的方法可以实现依赖重写，但是还是不够快速，这是因为通常场景是这样的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们通常用 Android Studio 打开了 basic 工程，AS 开多了会卡。&lt;/li&gt;
&lt;li&gt;当我们想要使用&lt;code&gt;dependency_overrides&lt;/code&gt;调整 basic 时，需要用Android studio 再次打开壳工程项目。当然也可以使用文本编辑器，但是它对yaml 支持不一定有 AS 那么好，无法智能提示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么有没有更快速的方式呢，答案是有的，这是因为 yaml 是结构化的，我们可以使用脚本来生成&lt;code&gt;dependency_overrides&lt;/code&gt;对应的内容。&lt;/p&gt;
&lt;p&gt;下面就是一个ruby 脚本，实现yaml 内容的添加处理。&lt;/p&gt;
&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;4&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;6&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;7&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;8&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;9&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;10&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;11&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;12&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;13&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;14&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;15&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;16&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;17&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;18&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;19&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;20&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;21&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;22&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;23&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;24&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;25&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;26&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;27&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;28&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;#!/usr/bin/env ruby&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;c1&quot;&gt;# encoding: utf-8&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;yaml&#x27;&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;file_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;repo_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;repo_path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ARGV&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;yaml_string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file_path&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;YAML&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yaml_string&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;dependency_overrides&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;nb&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;repo_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;s2&quot;&gt;&quot;path&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repo_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;dependency_overrides&#x27;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;dependency_overrides&#x27;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;dependency_overrides&#x27;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;n&quot;&gt;repo_name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;s2&quot;&gt;&quot;path&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;repo_path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strip&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;YAML&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dump&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;保存上面的脚本，命名为 localDartDep.rb,&lt;/li&gt;
&lt;li&gt;将其路径放入环境变量 PATH, 然后更新当前的bash&lt;/li&gt;
&lt;li&gt;切换到当前项目路径，然后执行 &lt;code&gt;localDartDep.rb basic ../basic&lt;/code&gt; 即可快速完成替换操作。不用开Android Studio，轻量快捷。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于上面的操作，依然可以更加包装成一个shell 脚本，实现更加便捷的处理&lt;/p&gt;
&lt;figure class=&quot;code&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre class=&quot;line-numbers&quot;&gt;&lt;span class=&quot;line-number&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;line-number&quot;&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;localDartDep.rb &lt;span class=&quot;s2&quot;&gt;&quot;$1/pubspec.yaml&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;basic&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;../basic&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;
&lt;p&gt;然后切换到对应的工程下，执行&lt;code&gt;basicLocalDep.sh ./&lt;/code&gt; 即可。&lt;/p&gt;
&lt;img src=&quot;https://asset.droidyue.com/image/2020_05/droidyue_gzh_green_png.png&quot; class=&quot;no_boarder_class&quot;/&gt;
&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>97e07248a2675bad709c612b36c743ba</guid>
<title>近期 yyds 的 GitHub 项目</title>
<link>https://toutiao.io/k/i1qkq4o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;9 月 2 日，GitHub 官方发布了一个消息：由于仓库趋势（GitHub Trending）使用率较低，将在 9 月 30 日永久关闭趋势榜。&lt;/section&gt;&lt;p&gt;消息一经发出，开发者看到大骂一天，迫于压力 GitHub 官方撤下公告，并发了一篇长文认错，说再研究研究是否真的撤下 GitHub Trending。&lt;/p&gt;&lt;section&gt;逛逛 GitHub 做的事情和 GitHub Trending 差不多，只不过老逛推荐的项目有很多是公众号的读者推荐，目的都是将有用好玩的开源项目推送到读者眼前，希望 GitHub 官方认真评估 GitHub Trending 是否下架的问题。&lt;/section&gt;&lt;p&gt;下架仓库趋势会不会是一个官方恶作剧？GitHub 运营同学精心策划的起量方案&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokXaVa4iayxI2Sscicesve5cnicK4ZseF5nk63gJD3hSOn2QrpcAcogZib1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;。本篇文章继续盘点近期好玩的开源项目。&lt;/p&gt;&lt;p&gt;推荐的本周6个开源项目目录：&lt;/p&gt;&lt;p&gt;1. 基于 Web 的动画编辑器&lt;/p&gt;&lt;p&gt;2. 终端文本编辑器&lt;/p&gt;&lt;p&gt;3. 数据可视化分析工具&lt;/p&gt;&lt;p&gt;4. GitHub Ranking&lt;/p&gt;&lt;p&gt;5. Kubeapps 开源&lt;/p&gt;&lt;p&gt;6. 计算机视觉工具箱&lt;/p&gt;&lt;hr/&gt;&lt;h1&gt;01&lt;/h1&gt;&lt;section&gt;&lt;span&gt;基于 Web 的动画编辑器&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Motionity 由开发者 @alyssaxuu 一个人开发，开源 5 天就有 1000 人 Star，这是一款适合所有人的动画编辑器，具有关键帧、蒙版、过滤器等强大的功能。&lt;/p&gt;&lt;p&gt;不知道大家有没有用过 Canva 或者创客贴，能够通过拖动的方式生成一个海报，After Effects  简称 AE 由 Adobe 公司推出的产品，常常用来制作帅气的特效。&lt;/p&gt;&lt;p&gt;而 Motionity  是这两款产品的结合体。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/alyssaxuu/motionity&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5888888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokDMwXpB1gic46WLda3AuJgSoicykcUUDX18VHWVfAfCTOYk2X3xFicA0kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5805555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokkl814Bm8JrbBDCYeJqmMtWfM6tsWTrAxQ79yhVjh8oxjvcABAh8u6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;02&lt;/h1&gt;&lt;section&gt;&lt;span&gt;终端文本编辑器&lt;/span&gt;&lt;/section&gt;&lt;p&gt;基于终端的文本编辑器，通常会想到 Vim、Nano。这个标星 11.8k  的编辑器：Helix ，也是一款优秀的终端文本编辑器，基于 Rust 编写有很多优秀的特性，比如：通过 tree-sitter 进行语法高亮显示、支持多项选择等等。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/helix-editor/helix&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.64375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokkeGBPlPhSgLyj6fDTem4CvgKmyiaqyHYNSGia2n8uRnGN98dLd14xRiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;h1&gt;03&lt;/h1&gt;&lt;section&gt;&lt;span&gt;数据可视化分析工具&lt;/span&gt;&lt;/section&gt;&lt;p&gt;逛逛 GitHub 推荐过很多数据可视化、数据分析的工具，具体可以查看历史发布过的文章: &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247513708&amp;amp;idx=1&amp;amp;sn=95afd6dac175f0874dadcaf3e23d4f46&amp;amp;chksm=f9a265a5ced5ecb326049427ec4dfea372d4cb30234c021c25a0f12cb0ffeaf427a8a9b197ee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;文章一&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文章一&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247501143&amp;amp;idx=1&amp;amp;sn=7899a9db2fad691a259cc7571cb390f1&amp;amp;chksm=f9a2169eced59f88850ff3b3e36279a245e7d6ff15eb170101231083f19d4eb78603de5cf9b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;文章二&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文章二&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498492&amp;amp;idx=2&amp;amp;sn=823ff5005f42a2ad94349301448d578c&amp;amp;chksm=f9a22935ced5a0235e47ea7eba9fa56d89ad5e4088453c46104e29ce84a5288fa1e3e40849f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;文章三&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文章三&lt;/a&gt;。DateEase 也是一个开源的数据可视化分析工具，国产开源支持 PC端、移动端、大屏，标星 6.8K。&lt;/p&gt;&lt;p&gt;使用开源项目 DateEase 仅仅通过简单的拖拉拽快速搞定一个图表，支持多种数据源比如：Excel、MySQL、API、Oricle、mongoDB、Hive 等等。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/dataease/dataease&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623471882640587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokPXeTWa9icg65QiaJPUYSic7jvfUJaj19rZtoj0WI74Zvvbs5dUQf3n8Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623471882640587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwoknpq3hreZvUyBia46YCfVwrJiaIuKHNhsZwTqwRyVBFpE1ViaVjDGhdXQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5552855407047388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokRBbhIKbZwFFz28F5uhdBm50yibH2gdz23OhGIG1x0WMFPu8Qicx9Hc6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/p&gt;&lt;h1&gt;04&lt;/h1&gt;&lt;section&gt;&lt;span&gt;GitHub Ranking&lt;/span&gt;&lt;/section&gt;&lt;p&gt;GitHub Ranking 是最近 Star 陡增的开源项目，这是一个 GitHub Stars 和 Forks 的排行榜，包含 Github Top 100 Star 的开源项目，根据不同编程语言进行分类，会每天更新。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/EvanLi/Github-Ranking&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.8448275862068964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokVkGWOE8yO4XXTyysHSPrSRCOzxbPx1UeYFLkIEkibe6VMndwmaLNshQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;406&quot;/&gt;&lt;/p&gt;&lt;h1&gt;05&lt;/h1&gt;&lt;section&gt;&lt;span&gt;Kubeapps 开源&lt;/span&gt;&lt;/section&gt;&lt;p&gt;Kubeapps 基于 Web 用于在 Kubernetes 集群中部署和管理应用程序，你可以在 Kubeapps 部署管理你的 Kubernetes 包，包括从 Public 、Private 注册表浏览和部署包，只需使用单个 Kubeapps 实例即可创建和管理不同的目录，将它们隔离在不同的命名空间和集群中。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/vmware-tanzu/kubeapps&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49537037037037035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokZX0NewaVa3nablEGU6wgEciasibokLOkbBAPVVmB2ziczLHc5qwJjAic3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;06&lt;/h1&gt;&lt;section&gt;&lt;span&gt;计算机视觉工具箱&lt;/span&gt;&lt;/section&gt;&lt;p&gt;EasyCV 是阿里巴巴开源的基于 PyTorch 的 Computer Vision 工具箱，主要专注于自监督学习和 Transformer 。&lt;/p&gt;&lt;p&gt;通过 EasyCV 你可以快速体验最新的图像自监督学习和 Transformer 技术，并且 EasyCV  还包含一些常见的计算机视觉的任务，比如图像分类、目标检测等等。&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/alibaba/EasyCV&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6912350597609562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzqPe3oKtSjEkTZXMRCnwokGeXgffElDuF8rDFHFLOsGZ6dljtjEC60AicAJ7uTwpMjt4uwicib4mBbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1004&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;历史盘点&lt;/span&gt;&lt;/section&gt;&lt;section&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/github.com/&lt;/span&gt;Wechat-ggGitHub/Awesome-GitHub-Repo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8091503267973856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzicgHPfCeAsrkT2JZwiaOF05zRiaXr2dUukXKGk8CJwfrXALKJ5l0fLpV2abibCYKb7d8B7vNp2u3iccg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/em&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐一款高颜值网易云播放器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;172&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;1.005449591280654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxW7LMX2Iz5DfjRIbFTS7UROhxibBmicicT0HpjIh1yniaJJibSnLFuicMHRx5NEdiaOh2OOACfr6MvR38ibQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b1b6736d7aa1685e9bcfe10c6d5a611</guid>
<title>面试官：为什么 MySQL 索引要使用 B+树而不是其它树形结构？比如 B 树？</title>
<link>https://toutiao.io/k/4pu1idw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC5gnia32IvcYplYSZb4dOCfAqSkct6ZMOsrDTWX2scypc9u4ufvuickZK4hIQxPFFC2OVNFicSKkERpw/640?wx_fmt=jpeg&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个问题？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么是这么多呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为这是可以算出来的，要搞清楚这个问题，我们先从InnoDB索引数据结构、数据组织方式说起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道计算机在存储数据的时候，有最小存储单元，这就好比我们今天进行现金的流通最小单位是一毛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是512字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是4k&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而对于我们的InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面几张图可以帮你理解最小存储单元：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文件系统中一个文件大小只有1个字节，但不得不占磁盘上4KB的空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6979695431472082&quot; data-type=&quot;png&quot; data-w=&quot;788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEWcRAqvJ6QqNgqHVw4iavbuR3pG78JdS3icafulQE5mXIYyZNIotmbtiaA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是16384（16k）的整数倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6312741312741312&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEcwxRMz4doaB82tpFEjRAtGr9UZbxREMyADMXLonEQDmqpG2oM3DGMg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;磁盘扇区、文件系统、InnoDB存储引擎都有各自的最小存储单元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3797709923664122&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEKSPz6ozRz2VTFyj2Qpnnia4aE4BTr69ibqDlrc3wA0LiamOqLdscEwWcw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在MySQL中我们的InnoDB页的大小默认是16k，当然也可以通过参数设置：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEqgd6Vj5xe8T2TkqlykMgOvYJ4FW8Oa9VAK9vyU0DKsCNa0WAESibG2Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。所以人们想了一个办法，用B+树的方式组织这些数据。如图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4521640091116173&quot; data-type=&quot;png&quot; data-w=&quot;878&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEdBOH4QQibh7a33yEfKgr6DAUeJNib38m0k1l8yWDXte9ZQJ24lsojzOQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放3条记录，实际情况可以存放很多）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了存放数据的页以外，还有存放键值+指针的页，如图中page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然它也是排好序的。这样的数据组织形式，我们称为索引组织表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在来看下，要查找一条数据，怎么查？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如：select * from user where id=5;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里id是主键,我们通过这棵B+树来查找，首先找到根页，你怎么知道user表的根页在哪呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实每张表的根页位置在表空间文件中是固定的，即page number=3的页（这点我们下文还会进一步证明）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中，那么进一步去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5    zhao2    27&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在我们清楚了InnoDB中主键索引B+树是如何组织数据、查询数据的，我们总结一下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;：1、InnoDB存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值+指针，在B+树中叶子节点存放数据，非叶子节点存放键值+指针。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页中查找到需要的数据；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么回到我们开始的问题，通常一棵B+树可以存放多少行数据？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里我们先假设B+树高为2，即存在一个根节点和若干个叶子节点，那么这棵B+树的存放总记录数为：根节点指针数*单个叶子节点记录行数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文我们已经说明单个叶子节点（页）中的记录数=16K/1K=16。（这里假设一行记录的数据大小为1k，实际上现在很多互联网业务数据记录大小通常就是1K左右）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么现在我们需要计算出非叶子节点能存放多少指针？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实这也很好算，我们假设主键ID为bigint类型，长度为8字节，而指针大小在InnoDB源码中设置为6字节，这样一共14字节&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们一个页中能存放多少这样的单元，其实就代表有多少指针，即16384/14=1170。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么可以算出一棵高度为2的B+树，能存放1170*16=18720条这样的数据记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据同样的原理我们可以算出一个高度为3的B+树可以存放：1170*1170*16=21902400条这样的记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在InnoDB中B+树高度一般为1-3层，它就能满足千万级的数据存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在查找数据时一次页的查找代表一次IO，所以通过主键索引查询通常只需要1-3次IO操作即可查找到数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么得到InnoDB主键索引B+树的高度？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面我们通过推断得出B+树的高度通常是1-3，下面我们从另外一个侧面证明这个结论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在InnoDB的表空间文件中，约定page number为3的代表主键索引的根页，而在根页偏移量为64的地方存放了该B+树的page level。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果page level为1，树高为2，page level为2，则树高为3。即B+树的高度=page level+1；下面我们将从实际环境中尝试找到这个page level。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际操作之前，你可以通过InnoDB元数据表确认主键索引根页的page number为3，你也可以从《InnoDB存储引擎》这本书中得到确认。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5050100200400801&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEicIw5qibLusqNtibI5hGAWJM3ZfW50a7tTfRnyibegexDX4MP9GB6eoGbA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.15526315789473685&quot; data-type=&quot;jpeg&quot; data-w=&quot;1520&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEmibTvG86EjCiaczP2OP3vUXvau3wCDxBxLic7j6nP7DHGuseibk9sSXctQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出数据库dbt3下的customer表、lineitem表主键索引根页的page number均为3，而其他的二级索引page number为4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于二级索引与主键索引的区别请参考MySQL相关书籍，本文不在此介绍。下面我们对数据库表空间文件做想相关的解析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3019538188277087&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kEXiaCia8s9YUB4hRU2gYOzVpWfOGxGibDz8010LUOPlZaiapGkADOiaU3zZw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为主键索引B+树的根页在整个表空间文件中的第3个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384为页大小）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外根据《InnoDB存储引擎》中描述在根页的64偏移量位置前2个字节，保存了page level的值因此我们想要的page level的值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在整个文件中的偏移量为：16384*3+64=49152+64=49216，前2个字节中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们用hexdump工具，查看表空间文件指定偏移量上的数据：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3431151241534989&quot; data-type=&quot;png&quot; data-w=&quot;886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kE4HGW9mCxqibjwyFPgeWAjgp1FRAI5M5iaToSuHljCfPpWn1LhN191BicQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;linetem表的page level为2，B+树高度为page level+1=3；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;region表的page level为0，B+树高度为page level+1=1；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;customer表的page level为2，B+树高度为page level+1=3；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三张表的数据量如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9975062344139651&quot; data-type=&quot;png&quot; data-w=&quot;802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa4R1Ydibhv1JYVp4bwTY7kE47icoeDyGTd6msGmdCO93Jl0ziceHnxSnoZhTYMnaAKKjswicNTVTUrwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：lineitem表的数据行数为600多万，B+树高度为3，customer表数据行数只有15万，B+树高度也为3。&lt;/span&gt;&lt;span&gt;可以看出尽管数据量差异较大，这两个表树的高度都是3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;换句话说这两个表通过索引查询效率并没有太大差异，因为都只需要做3次IO。那么如果有一张表行数是一千万，那么他的B+树高度依旧是3，查询效率仍然不会相差太大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;region表只有5行数据，当然他的B+树高度为1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后回顾一道面试题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有一道MySQL的面试题，为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在这个问题的复杂版本可以参考本文；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他的简单版本回答是：因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文从一个问题出发，逐步介绍了InnoDB索引组织表的原理、查询方式，并结合已有知识，回答该问题，结合实践来证明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然为了表述简单易懂，文中忽略了一些细枝末节，比如一个页中不可能所有空间都用于存放数据，它还会存放一些少量的其他字段比如page level，index number等等，另外还有页的填充因子也导致一个页不可能全部用于保存数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于二级索引数据存取方式可以参考MySQL相关书籍，他的要点是结合主键索引进行回表查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;作者丨李平&lt;br/&gt;来源:&lt;br/&gt;https://www.cnblogs.com/leefreeman/p/8315844.html?from=singlemessage&amp;amp;isappinstalled=0 &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;推荐程序员必备微信号 &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▼&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;&lt;section&gt;&lt;strong&gt;程序员内参&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot;&gt;微信号：&lt;p&gt;programmer0001&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推荐理由：&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;span&gt;在这里，我们分享程序员相关技术，职场生活，行业热点资讯。不定期还会分享IT趣文和趣图。这里属于我们程序员自己的生活，工作和娱乐空间。&lt;/span&gt;&lt;section class=&quot;&quot;&gt;&lt;span&gt; ▼长按下方↓↓↓二维码识别关注&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;img class=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jNmCBexQlC5gnia32IvcYplYSZb4dOCfAYSDD4ASA6D1tVkoY69dqnb97cQ99Y6jqlyKo0FxVgvW45sQRGXiclNg/640?wx_fmt=jpeg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8825905963c324e1fc82b7da83a2657c</guid>
<title>关系型、非关系型数据库存储选型盘点大全</title>
<link>https://toutiao.io/k/ls0fy05</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;工作中总是&lt;/span&gt;&lt;span&gt;遇到数据存储相关的 Bug 工单，新需求开发设计中也多多少少会有数据模型设计和存储相关的问题。&lt;/span&gt;&lt;span&gt;经过几次存储方案设计选型和讨论后发现需要有更全面的思考框架。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故写了这篇文章，抛出我的观察和思考，希望日后可以将一些更先进 (合适) 的技术引入公司业务，助力业务发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;存储选型的考虑要素&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;存储选型的目的还是为了我们的使用场景和用户服务，因此在选型前需要回答一些业务指标 &amp;amp; 技术指标方面的问题，以便于我们清楚存储选型的应用环境。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;存储引擎分类及特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库的分类方式非常多样，因参考维度不同而存在较大差异，下面是常见的一些分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;280&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5015060240963856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmMhdiaEwbLIzze2HAfSQBLSRRovATVnDaZPFEhPHjuHviafPnosVoAyxqqibwniaZ0Zc8ztmqcF5U5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;先拿我们最熟悉的关系数据库来说，它的优点非常多，我们选用关系数据库的理由可简单概括为以下几点：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可由二维表结构来逻辑表达，相对网状、层次等其他模型更加容易被理解。严格遵循数据格式与长度规范，数据以行为单位，一行数据表示一个实体信息，每一行数据的属性都是相同的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;支持 ACID 特性，可以维护数据之间的一致性，这是使用关系数据库非常重要的一个理由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通用的 SQL 语言使得操作关系型数据库非常方便，支持 join 等复杂查询，Sql + 二维关系是关系型数据库最无可比拟的优点，这种易用性非常贴近开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据持久化到磁盘，没有丢失数据风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最常用的关系型数据库产品 MySql、Oracle 服务器性能卓越，服务稳定，通常很少出现宕机异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，在享受关系数据库带来的便利的同时，我们也不得不面临很多麻烦的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据按行存储，即使只针对某一列进行运算，也会将整行数据从存储设备中读入内存，导致 IO 较高。写入更新频繁的情况下，数据库往往会出现 CPU 飙高、Sql 执行慢、客户端报数据库连接池不够等异常情况，且性能瓶颈通过加 CPU、换固态硬盘、继续买服务器加数据库做分库等方式处理 ROI 不高，受限于其本身的特点，可能花了很多钱都未必能达到想要的效果。因此例如万人秒杀这种场景，我们绝对不可能通过数据库直接去扣减库存，需要做好流量漏斗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据一致性是关系型数据库的核心，但是同样为了维护数据一致性的代价也非常大。SQL 标准为事务定义了不同的隔离级别，从低到高依次是读未提交、读已提交、可重复度、串行化，事务隔离级别越低，可能导致的并发异常越多，但是能提供的并发能力越强。那么为了保证事务一致性，数据库就需要提供并发控制与故障恢复两种技术，前者用于减少并发异常，后者可以在系统异常的时候保证事务与数据库状态不会被破坏。对于并发控制，其核心思想就是加锁，无论是乐观锁还是悲观锁，只要提供的隔离级别越高，那么读写性能必然会受影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提供丰富的查询能力，通常热点表都会有多个二级索引，一旦有了二级索引，数据的新增必然伴随着所有二级索引的新增，数据的更新也必然伴随着所有二级索引的更新，这不可避免地降低了关系型数据库的读写能力，且索引越多读写能力越差。除了数据文件不可避免地占空间外，索引占的空间其实也并不少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着业务规模扩大，一种方式是对数据库做分库，做了分库之后，数据迁移（1 个库的数据按照一定规则打到 2 个库中）、跨库 join、分布式事务处理都是需要考虑的问题，尤其是分布式事务处理，业界当前都没有特别好的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如 like “% 新年快乐 %”，只能搜索到 “新年快乐，爱大家”，无法搜索到 “新年真是太快乐了，爱大家” 这样的文本，即不具备分词能力，且 like 查询在 “% 新年快乐” 这样的搜索条件下，无法命中索引，将会导致查询效率大大降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于数据库存储的是结构化数据，因此表结构 schema 是固定的，扩展不方便，如果需要修改表结构，需要执行 DDL（data definition language）语句修改，修改期间会导致锁表，部分服务不可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上文所分析的，关系型数据库优点明显，缺点同样不能忽视，因此通常在企业规模不断扩大的情况下，不会一味指望通过增强数据库的能力来解决数据存储问题，而是会引入其他存储，也就是我们说的 NoSql。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NoSql 的全称为 Not Only SQL，泛指非关系型数据库，是对关系型数据库的一种补充，特别注意补充这两个字，这意味着 NoSql 与关系型数据库并不是对立关系，二者各有优劣，取长补短，在合适的场景下选择合适的存储引擎才是正确的做法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面看一下常用的 NoSql 及他们的代表产品，并对每种 NoSql 的优缺点和适用场景做一下分析，便于熟悉每种 NoSql 的特点，方便技术选型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、KV 型 NoSql（代表——Redis）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;KV 型 NoSql 顾名思义就是以键值对形式存储的非关系型数据库，是最常见的一种 NoSql。Redis、MemCache 是其中的代表，Redis 又是 KV 型 NoSql 中应用最广泛的 NoSql，KV 型数据库以 Redis 为例，最大的优点总结下来主要有两点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说，KV 型 NoSql 最大的优点就是高性能，利用 Redis 自带的 BenchMark 做基准测试，TPS 可达到 10 万的级别，性能非常强劲。同样的 Redis 也有所有 KV 型 NoSql 都有的比较明显的缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，KV 型 NoSql 最合适的场景就是缓存的场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对那些读远多于写的数据，引入一层缓存，每次读从缓存中读取，缓存中读取不到，再去数据库中取，取完之后再写入到缓存，对数据做好失效机制通常就没有大问题了。通常来说，缓存是性能优化的第一选择也是见效最明显的方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、搜索型 NoSql（代表——ElasticSearch）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;传统关系型数据库主要通过索引来达到快速查询的目的，但是在全文搜索的场景下，索引是无能为力的，like 查询无法满足所有模糊匹配需求，使用限制太大且使用不当容易引起慢查询问题，搜索型 NoSql 的诞生正是为了解决关系型数据库全文搜索能力较弱的问题，ElasticSearch 是搜索型 NoSql 的代表产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全文搜索的原理是倒排索引，我们看一下什么是倒排索引，它是关键字 –&amp;gt; 文档的映射，举例来说，现在这里有四个短句：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;搜索引擎会根据一定的分词规则将一句话切成多个关键字，并以关键字的维度维护关键字在每个文本中的出现次数。这样下次搜索“Tom”关键字的时候，由于 Tom 这个词语在“Tom is Tom”、“Tom is my friend”、“Tom is Betty’s husband” 三句话中都出现过，因此这三条记录都会被检索出来，而且由于”Tom is Tom” 这句话中”Tom” 出现了 2 次，因此这条记录对”Tom” 这个单词的匹配度最高，最先展示。这就是搜索引擎倒排索引的基本原理，假设某个关键字在某个文档中出现，那么倒排索引中有两部分内容：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相对应的，我们搜索”Betty Tom” 这两个词语也是一样，搜索引擎将”Betty Tom” 切分为”Tom”、”Betty” 两个单词，根据开发者指定的满足率，比如满足率 = 50%，那么只要记录中出现了两个单词之一的记录都会被检索出来，再按照匹配度进行展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;搜索型 NoSql 以 ElasticSearch 为例，它的优点为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;1）支持分词场景、全文搜索，这是区别于关系型数据库最大特点。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;2）数据写文件无丢失风险，在集群环境下可以方便横向扩展，可承载 PB 级别的数据。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;3）支持条件查询，支持聚合操作，类似关系型数据库的 Group By，但是功能更加强大，适合做数据分析。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;4）高可用，自动发现新的或者失败的节点，重组和重新平衡数据，确保数据是安全和可访问的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样，ElasticSearch 也有比较明显的缺点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）性能全靠内存来顶，也是使用的时候最需要注意的点，非常吃内存，大数据量下 64G + SSD 基本就是标配，相同的配置多一倍内存，一个月差不多就要多花好多钱。至于 ElasticSearch 内存主要用在以下几个地方：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）数据结构灵活性不高，字段一旦建立就没法修改类型了，假如建立的数据表某个字段没有加全文索引，想加上，那么只能把整个表删了再重建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）读写之间有延迟，写入的数据差不多 1s 样子会被读取到（数据写入时需要维护很多索引）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，搜索型 NoSql 最适用的场景就是有条件搜索尤其是全文搜索的场景，作为关系型数据库的一种替代方案，通常搜索型 NoSql 也会作为一层前置缓存，来对关系型数据库进行保护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，搜索型数据库还有一种非常重要的应用场景。我们可以想，一旦对数据库做了分库分表后，原来可以在单表中做的聚合操作、统计操作是否统统失效？例如我把订单表分 16 个库，1024 张表，那么订单数据就散落在 1024 张表中，我想要统计昨天浙江省单笔成交金额最高的订单是哪笔如何做？这就是搜索型 NoSql 的另一大作用了，我们可以把分表之后的数据统一打在搜索型 NoSql 中，利用搜索型 NoSql 的搜索与聚合能力完成对全量数据的查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、列式 NoSql（代表——HBase）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;列式 NoSql 和关系型数据库一样都有主键的概念，区别在于关系型数据库是按照行组织的数据，数据字段即使没有值同样占空间，列式存储完全是另一种方式，它是按列进行数据组织的，好处在于：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大数据时代最具代表性的技术之一 HBase 就是列式 NoSQL 的产品实现，其优点主要是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点主要表现在：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此 HBase 比较适用于 KV 型存储且未来无法预估数据增长量的场景，另外 HBase 使用还是需要一定的经验，主要体现在 RowKey 的设计上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、文档型 NoSql（代表——MongoDB）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;文档型 NoSql 指的是将半结构化数据存储为文档的一种 NoSql，文档型 NoSql 通常以 JSON 或者 XML 格式存储数据，因此文档型 NoSql 是没有 Schema 的，由于没有 Schema 的特性，我们可以随意地存储与读取数据，因此文档型 NoSql 的出现是解决关系型数据库表结构扩展不方便的问题的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB 是文档型 NoSql 的代表产品，同时也是所有 NoSql 产品中的明星产品之一，它的很多概念与关系数据库类似，因此，对于 MongDB，我们只需要理解成一个 Free-Schema 的关系型数据库就好了，其优点主要是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点在于：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总而言之，MongDB 的使用场景很大程度上可以对标关系型数据库，但是比较适合处理那些没有 join、没有强一致性要求且表 Schema 会常变化的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过以上讨论分析我们心中已经有了一个基本的选型框架指导，实际上在数据库选型时回答自己两个核心问题就好了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NoSQL 数据库都是通过牺牲了 ACID 特性来获取更高性能的，假设表数据有很强的事务特性需求，那么这类数据是不适合放在非关系型数据库。此外，选用 NoSQL 数据库时也要根据公司技术栈框架、业务特性、运维成本等多方面考虑是否采纳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;489&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8759259259259259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZmMhdiaEwbLIzze2HAfSQBLWBwhbIuG4aUMSyjibIribHEjVzcICPsGhfRj4sZrFRjzDhZZeUgnuNpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;关系型数据库和 NoSQL 数据库的选型，往往需要考虑几个指标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并发量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一致性要求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读写分布和类型&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;安全性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运维成本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;常见软件系统数据库选型参考如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中后台管理型系统  - 如运营系统，数据量少，并发量小，首选关系型数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大流量系统  - 如电商单品页，后台考虑选关系型数据库，前台考虑选内存型数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志型系统  - 原始数据考虑选列式数据库，日志搜索考虑选搜索引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;搜索型系统  - 例如站内搜索，非通用搜索，如商品搜索，后台考虑选关系型数据库，前台考虑选搜索引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务型系统  - 如库存，交易，记账，考虑选关系型数据库 + K-V 数据库（作为缓存）+ 分布式事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;离线计算 - 如大量数据分析，考虑选列式数据库或关系型数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时计算  - 如实时监控，可以考虑选内存型数据库或者列式数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计实践中，要基于需求、业务驱动架构，无论选用 RDB/NoSQL, 一定是以需求为导向，最终数据存储方案必然是各种权衡的综合性设计。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨August Rush&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：代码真香（ID：CodingLab）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c27f2ecaefe8382ba2611de6b0248284</guid>
<title>得物云原生全链路追踪Trace2.0架构实践</title>
<link>https://toutiao.io/k/okz0hly</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式链路追踪作为解决分布式应用可观测问题的重要技术，得物全链路追踪(简称Trace2.0)基于OpenTelemetry提供的可观测标准方案实现新一代的一站式全链路观测诊断平台，并通过全量采集Trace帮助业务提高故障诊断、性能优化、架构治理的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量采集Trace数据(日增数百TB 、数千亿条Span数据)并以较低的成本保证数据的实时处理与高效查询，对Trace2.0后端整体的可观测性解决方案提出了极高的要求。本文将详细介绍Trace2.0背后的架构设计、尾部采样和冷热存储方案，以及我们是如何通过自建存储实现进一步的降本增效(存储成本下降66%)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;1. 整体架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.472957422324511&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKfLUphD3Ziau2icbC2PeRJzDLjYv1WibticEiaex0PwHQgI4A4SwZXRrAicYtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;869&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全链路追踪Trace2.0从数据接入侧、计算、存储到查询整体模块架构如上图所示。这里说一下各组件的核心能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;客户端&amp;amp;数据采集：&lt;/strong&gt;&lt;/span&gt;集成并定制OpenTelemetry提供的多语言SDK(Agent)，生成统一格式的可观测数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;控制平面Control Plane：&lt;/strong&gt;&lt;/span&gt;统一的配置中心向数据采集侧下发各类动态配置发并实时生效；支持向各采集器下发动态配置并实时生效，支持应用按实例数灰度接入，并提供出入参收集动态开关、性能剖析动态开关、流量染色动态配置、客户端版本管理等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;数据收集服务OTel Server：&lt;/strong&gt;&lt;/span&gt;数据收集器OTel Server兼容OpenTelemetry Protocol（OTLP)协议，提供gRPC和HTTP两种方式接收采集器发送的可观测数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;分析计算&amp;amp;存储OTel Storage：&lt;/strong&gt;&lt;/span&gt;计算侧除了基础的实时检索能力外，还提供了场景化的数据分析计算主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;存储Trace数据：&lt;/strong&gt;数据分为两段，一段是索引字段，包括TraceID、ServiceName、SpanName、StatusCode、Duration和起止时间等基本信息，用于高级检索；另一段是明细数据(源数据，包含所有的Span数据)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算SpanMetrics数据：&lt;/strong&gt;聚合计算Service、SpanName、Host、StatusCode、Env、Region等维度的执行总次数、总耗时、最大耗时、最小耗时、分位线等数据；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务单号关联Trace：&lt;/strong&gt;电商场景下部分研发多以订单号、履约单号、汇金单号作为排障的输入，因此和业务研发约定特殊埋点规则后--在Span的Tag里添加一个特殊字段&quot;bizOrderId={实际单号}&quot;--便将这个Tag作为ClickHouse的索引字段；从而实现业务链路到全链路Trace形成一个完整的排障链路；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Redis热点数据统计：&lt;/strong&gt;在客户端侧扩展调用Redis时入参和出参SpanTag埋点，以便统Redis命中率、大Key、高频写、慢调用等指标数据；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;strong&gt;热点数据统计：&lt;/strong&gt;按照SQL指纹统计调用次数、慢SQL次数以及关联的接口名。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;2. 尾部采样&amp;amp;冷热存储&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得物早期的全链路追踪方案出于对存储成本的考虑，在客户端设置了1%的采样率，导致研发排查问题时经常查询不到想看的Trace链路。那么Trace2.0为了解决这个问题，就不能仅仅只是简单地将客户端的采样率调整为100%，而是需要在客户端全量采集Trace数据的同时，合理地控制Trace存储成本。且从实践经验来看，Trace数据的价值分布是不均匀的，随着时间的推移Trace的数据价值是急速降低的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全量存储Trace数据不仅会造成巨大的成本浪费，还会显著地影响整条数据处理链路的性能以及稳定性。所以，如果我们能够只保存那些有价值、大概率会被用户实际查询的Trace，就能取得成本与收益的平衡。那什么是有价值的Trace呢？根据日常排查经验，我们发现业务研发主要关心以下四类优先级高场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在调用链上出现了异常ERROR；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在调用链上出现了大于「200ms」的数据库调用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;整个调用链耗时超过「1s」；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务场景的调用链，比如通过订单号关联的调用链。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个背景下，并结合业界的实践经验，落地Trace2.0的过程中设计了尾部采样&amp;amp;冷热分层存储方案，方案如下:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.346875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKfKLIrOf3wuYtGaEFF1Hibhr6Qo8kl2esdeHkz7tfV1HL2K0zibPZRuAdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;OTel Server数据收集&amp;amp;采样规则：&lt;/strong&gt;&lt;/span&gt;将客户端采集器上报的全量Trace数据实时写入Kafka中，并把满足采样规则(上述定义的场景)的Span数据对应的TraceID记录到Bloom Filter中;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;OTel Storage持久化热数据：&lt;/strong&gt;&lt;/span&gt;实时消费Kafka中数据，并全量持久化到ClickHouse热集群中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;OTel Storage持久化冷数据：&lt;/strong&gt;&lt;/span&gt;订阅上游OTel Server的Bloom Filter，&lt;strong&gt;延迟&lt;/strong&gt;消费Kafka中的数据，将TraceID在Bloom Filter中可能存在的Span数据持久化到ClickHouse冷集群中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;TraceID点查：&lt;/strong&gt;&lt;/span&gt; Trace2.0自定义了TraceID的生成规则；在生成TraceID时，会把当前时间戳秒数的16进制编码结果(占8个字节)作为TraceID的一部分。查询时只需要解码TraceId中的时间戳，即可知道应该查询热集群还是冷集群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接下来再介绍一下尾部采样中Bloom Filter的设计细节，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKfRKpDeoxUQPTicNJTywnPvZdPhOeglPo6toib3sEnmiamVE0gaqrAcWmvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OTel Server会将满足采样规则的Span数据对应的TraceID，根据TraceID中的时间戳写入到对应时间戳的Bloom Filter中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Bloom Filter会按十分钟粒度(可根据实际的数据量并结合BloomFilter的误算率和样本大小计算内存消耗并调整)进行分片，十分钟过后将Bloom Filter进行序列化并写入到ClickHouse存储中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OTel Storage消费侧拉取Bloom Filter数据(注意：同一个时间窗口，每一个OTel Server节点都会生成一个BloomFilter)并进行合并Merge(减少Bloom Filter的内存占用并提高Bloom Filter的查询效率)。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，Trace2.0仅使用了较少的资源就完成了尾部采样和冷热分层存储。既为公司节约了成本，又保存了几乎所有「有价值」Trace，解决了业务研发日常排查时查询不到想看的Trace的问题。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;3. 自建存储&amp;amp;降本增效&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.1 基于SLS-Trace的解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Trace2.0建设初期采用了&lt;em&gt;SLS专为OpenTelemetry定制的Trace方案 &lt;/em&gt;&lt;/span&gt;&lt;span&gt;【1】&lt;/span&gt;&lt;span&gt;，提供了Trace查询、调用分析、拓扑分析等功能，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKfrLn2kpYRkABQA0g8ibPqFMR22wG03T3Gn98uUiauZywibN6rmuqpA8S1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SLS-Trace主要处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;利用OpenTelemetry Collector &lt;em&gt;aliyunlogserverexporter&lt;/em&gt;【2】将Trace数据写入到SLS-Trace Logstore中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SLS-Trace通过默认提供的Scheduled SQL任务定时聚合Trace数据并生成相应的Span指标与应用、接口粒度的拓扑指标等数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着Trace2.0在公司内部全面铺开，SLS的存储成本压力变得越来越大，为了响应公司“利用技术手段实现降本提效”的号召，我们决定自建存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3.2 基于ClickHouse的解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前业内比较流行的全链路追踪开源项目(SkyWalking、Pinpoint、Jaeger等)采用的存储大都是基于ES或者HBase实现的。而近几年新兴的开源全链路追踪开源项目(&lt;/span&gt;&lt;em&gt;&lt;span&gt;Uptrace&lt;/span&gt;&lt;/em&gt;&lt;span&gt;【3】&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;em&gt;&lt;span&gt;Signoz&lt;/span&gt;&lt;/em&gt;&lt;span&gt;【4】&lt;/span&gt;&lt;span&gt;等)采用的存储大都是基于ClickHouse实现的，同时将Span数据清洗出来的指标数据也存储在ClickHouse中。且ClickHouse的物化视图(很好用)也很好地解决了指标数据降采样(DownSampling)的问题。最终经过一番调研，我们决定基于ClickHouse来自建新的存储解决方案。整体架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKfuOeH6I4OarTA8ia6OZr16HRdkvNnUnicCeduTuuiaAQdNANtY1LKjicgfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;Trace索引&amp;amp;明细数据：&lt;/strong&gt;&lt;/span&gt;OTel Storage会将基于Span原始数据构建的索引数据写入到SpanIndex表中，将Span原始明细数据写入到SpanData表中(相关表设计可以参考&lt;/span&gt;&lt;em&gt;&lt;span&gt;Uptrace&lt;/span&gt;&lt;/em&gt;&lt;span&gt;【5】&lt;/span&gt;&lt;span&gt;)；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;计算&amp;amp;持久化SpanMetrics数据：&lt;/strong&gt;&lt;/span&gt;OTel Storage会根据Span的Service、SpanName、Host、StatusCode等属性统计并生成「30秒」粒度的总调用次数、总耗时、最大耗时、最小耗时、分位线等指标数据，并写入到SpanMetrics表；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-- span_metrics_10m_mv&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE MATERIALIZED VIEW IF NOT EXISTS &#x27;{database}&#x27;.span_metrics_10m_mv_local&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            on cluster &#x27;{cluster}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            TO &#x27;{database}&#x27;.span_metrics_10m_local&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;AS&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;SELECT a.serviceName                     as serviceName,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       a.spanName                        as spanName,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       a.kind                            as kind,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       a.statusCode                      as statusCode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       toStartOfTenMinutes(a.timeBucket) as timeBucket,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       sum(a.count)                      as count,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       sum(a.timeSum)                    as timeSum,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       max(a.timeMax)                    as timeMax,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       min(a.timeMin)                    as timeMin&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;FROM &#x27;{database}&#x27;.span_metrics_30s_local as a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GROUP BY a.serviceName, a.spanName, a.kind, a.statusCode,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    toStartOfTenMinutes(a.timeBucket);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ClickHouse使用Distributed引擎实现了Distributed(分布式)表机制，可以在所有分片(本地表)上建立视图，实现分布式查询。并且Distributed表自身不会存储任何数据，它会通过读取或写入其他远端节点的表来进行数据处理。SpanData表创建语句如下所示：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-- span_data&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE IF NOT EXISTS &#x27;{database}&#x27;.span_data_local ON CLUSTER &#x27;{cluster}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    traceID                   FixedString(32),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    spanID                    FixedString(16),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    startTime                 DateTime64(6 ) Codec (Delta, Default),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    body                      String CODEC (ZSTD(3))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;) ENGINE = MergeTree&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ORDER BY (traceID,startTime,spanID)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PARTITION BY toStartOfTenMinutes(startTime)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;TTL toDate(startTime) + INTERVAL &#x27;{TTL}&#x27; HOUR;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-- span_data_distributed&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE IF NOT EXISTS &#x27;{database}&#x27;.span_data_all ON CLUSTER &#x27;{cluster}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;as &#x27;{database}&#x27;.span_data_local&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ENGINE = Distributed(&#x27;{cluster}&#x27;, &#x27;{database}&#x27;, span_data_local,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                         xxHash64(concat(traceID,spanID,toString(toDateTime(startTime,6)))));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体写入流程比较简单(注意：避免使用分布式表)，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32223796033994334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Bs4mwibUGtJcE5zUdvgdsKf9I9FKbIlk3xZkA4z5pOON4Xz8AmfC2ZxBoLGj1FV1so1tlOfhkrvXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2824&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全链路追踪是一个典型的写多读少的场景，因此我们采用了ClickHouse ZSTD压缩算法对数据进行了压缩，压缩后的压缩比高达12，效果非常好。目前ClickHouse冷热集群各使用数十台16C64G ESSD机器，单机写入速度25w/s(ClickHouse写入的行数)。相比于初期的阿里云SLS-Trace方案，存储成本下降66%，查询速度也从800+ms下降至490+ms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前Trace2.0将Span的原始明细数据也存储在了ClickHouse中，导致ClickHouse的磁盘使用率会有些偏高，后续考虑将Span明细数据先写入HDFS/OSS等块存储设备中，ClickHouse来记录每个Span在块存储中的offset，从而进一步降低ClickHouse的存储成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于我们：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得物监控团队提供一站式的可观测性平台，负责链路追踪、时序数据库、日志系统，包括自定义大盘、应用大盘、业务监控、智能告警、AIOPS等排障分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎对可观测性/监控/告警/AIOPS 等领域感兴趣的同学加入我们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;引用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【1】&lt;/span&gt;&lt;strong&gt;&lt;span&gt;SLS-Trace方案 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://developer.aliyun.com/article/785854&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【2】&lt;/span&gt;&lt;strong&gt;&lt;span&gt;SLS-Trace Contrib &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/alibabacloudlogserviceexporter&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【3】&lt;strong&gt;Uptrace &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://uptrace.dev/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【4】&lt;strong&gt;Signoz&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://signoz.io/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【5】&lt;strong&gt;Uptrace Schema设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; https://github.com/uptrace/uptrace/tree/v0.2.16/pkg/bunapp/migrations&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇是&lt;strong&gt;《得物云原生全链路追踪Trace2.0》&lt;/strong&gt;系列开篇，更多内容请关注“得物技术”公众号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;strong mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;17.600000381469727&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;*文&lt;/span&gt;&lt;/strong&gt;&lt;strong mp-original-font-size=&quot;11&quot; mp-original-line-height=&quot;17.600000381469727&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;/南风&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;svg viewbox=&quot;0 0 1 1&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;svg viewbox=&quot;0 0 1 1&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt; 关注得物技术，每周一三五晚18:30更新技术干货&lt;br mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;/&gt;要是觉得文章对你有帮助的话，欢迎评论转发点赞～&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74DWvZPADM5XknnTibzgrxuvzvLtcjycF3pIbYqpsXSWwxz9QLfqbWCufybUH4agABGQlhkqfdI0pNw/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-alias=&quot;&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;活动推荐&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;主题：得物技术沙龙-数据治理专场&lt;br mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;时间：9月3日 14:00-18:00&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22.399999618530273&quot;&gt;报名方式：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/Q3auHgzwzM6A15Sbkl3fcb3MH3giciciaiaypmMpAKzLbz2rnKDXs4ia2bg/0&quot; data-username=&quot;v2_060000231003b20faec8cae28b1dc7d5cf02ea3db07785f6268ca44f543d593c9d5004c1e666@finder&quot; data-nickname=&quot;得物Tech&quot; data-desc=&quot;将在09月03日 14:00 直播&quot; data-intro=&quot;数据治理｜得物技术沙龙，本期邀请阿里云、网易数帆和得物一起聚焦数仓、成本、埋点、数据等治理，希望能够帮助到大家的工作。&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8cae28b1dc7d5cf02ea3db07785f6268ca44f543d593c9d5004c1e666@finder-1661160357894361-1871780857&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>