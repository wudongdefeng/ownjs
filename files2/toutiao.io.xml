<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>daf5606db97de013af77038a6ca42af3</guid>
<title>想要做好代码质量，如何破局？</title>
<link>https://toutiao.io/k/s9s8hub</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：苗现方&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要做好代码质量，我们不得不提什么是代码质量？本文中讨论的代码质量一般是指代码的风格、重复率和复杂度等，代码是技术团队的价值产物，是宝贵的财富，同样代码质量的好坏可以直接体现出团队的重视程度和技术管理水平。&lt;/p&gt;

&lt;p&gt;代码质量的下降是内在原因，通常会恶性循环，&lt;strong&gt;主要表现出以下两个特性：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;感染性：坏代码总能在部门渲染着只要业务交付达成，代码质量不重要的负面气氛，严重减低了研发人员的技术热情，破坏工作氛围，导致更多的坏代码出现。&lt;/p&gt;

&lt;p&gt;心理暗示性：在坏代码基础上继续生产坏代码的&quot;罪过&quot;减轻。&lt;/p&gt;

&lt;p&gt;为什么会产生这样的结果，这里我与你举个生活中的栗子，我在上个周日收拾房间，发现一个房间衣柜中的衣服很乱，花了很长时间才叠放好，过两天晚上下班回家，我发现客厅沙发上也很乱，衣服、电脑、背包、零食几乎日常的小物件都会有，两件事情合在一起想，这确实是一个很有趣的思考，为什么会是这样的？在一个相对封闭的空间中，任其无意识地随着时间的发展，房间和沙发也一定很乱，注意，这里我说的是无意识，也就是我并没有刻意放，或者去刻意整理。带着这个思考的结果，我又观察了大家的工位、园区内景观，一段时间内一定会出现乱象，不过通过一顿治理之后很快恢复到有秩序，好，大家可以猜到这是什么定律，就是熵增定律，不了解的可以自行网络科普，那么在质量域中依然存在这样的定律，不然熵增定律也不会被古今中外的物理学家所推崇备至，它的定义是：在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大。&lt;/p&gt;

&lt;p&gt;代码质量在软件项目是一种有序的状态，自然总是向着无序发展的，要想保持这种有序，需要主动投入资源，就像整理房间，花草修剪一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回到我们的多数开发工作中，我们面临的现状是这样的：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、业务交付压力大，需求优先上线，业务逻辑实现优先级最高，没时间没精力关注代码质量，甚至终极目标就是需求上线，导致坏代码产生，开发效率逐步下降，随着后续版本的迭代，业务交付压力越来越大。&lt;/p&gt;

&lt;p&gt;2、出现了1的情况后，我们意识到压力越来越大，为了应付这种交付压力，常见的手段就是增加人力，但是一味的增加人数，沟通成本及风格的一致性无法得到保障，这将进一步产生更多的坏代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对以上2个现状，我们该怎么着手解决。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的建议方案是多渠道，系统性解决问题，首先控制人力的大量投入，主动发起对代码质量进行管控，其次持续提升技术升级。但是，从减轻业务交付压力的结果来看，人们往往倾向于增加人力来快速解决问题，技术升级需要靠长期的投入才能有所收获，所以，我们需要在质量方面增加强有力的管控。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果做好代码质量管控？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码质量管控首先应解决两个问题，库存坏代码和增量坏代码。&lt;/p&gt;

&lt;p&gt;想解决这两个问题，我们要对现有的系统、人员、工具、流程整合形成一套体系化的方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/1a7c49ea15824e3db2cf7737f306588d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=pSyRWdOXChxXhYsyqT8aYwmrH0g%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对代码质量管控，通过在部门内工程实践，我认为需要经历以下这四个过程，部门内建立代码规范制度（EOS）、检查代码问题的自动化工具（bamboo平台）、代码质量检查与代码流动过程绑定（质量门禁）、部门视角下，集中管理代码规范和质量状况的透明（代码质量评测系统）。&lt;/p&gt;

&lt;p&gt;过程一：代码质量的基础是规范，包括代码风格的规范、长期一线代码实践规范、与业务需求相关的特殊规范，例如风控文案、异常托底文案等。&lt;/p&gt;

&lt;p&gt;过程二：实现自动化的检查能力是在规范基础之上，通过自动化工具进行检查，包括对代码重复率、圈复杂度、单测case通过率、静态规则扫描等。&lt;/p&gt;

&lt;p&gt;过程三：实现质量检查与代码流动过程绑定，在编辑-构建-提交-发布各个时段部署检查能力保障上线代码必须经过机器和人工的多环节检查。&lt;/p&gt;

&lt;p&gt;过程四：团队规模逐步扩大，各业务线项目快速发展，实现规范管理统一、项目要求一致、各项目质量状况透明、对比，建立统一的评测体系。&lt;/p&gt;

&lt;p&gt;为了让你有一个很直观的认识，我在下面画了一个张图，希望可以帮助快速理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/c4205dbd8cc34e0bb884de4f25028196%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=AkQGG9%2FqByBy3x1rJnGUK%2FWJff4%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在日常开发工作中，大家都会想到通过增加人手来缓解项目交付的压力，这是可以理解，但是从整体角度看，人员的增加会产生越来越多的坏代码，使整体的效率下降，这又进而加剧了后续项目交付的压力，在这种压力下，又通过增加人手缓解......让代码质量变的越来越差，这也是房间为什么会越来越乱，是熵增定律在软件质量域的生动体现。&lt;/p&gt;

&lt;p&gt;为了抑制这种恶性循环，我们意识到了通过有效的手段和资源投入进行各项工程实践，逐步完善代码质量的管控体系，积累很多方法和工具。&lt;/p&gt;

&lt;p&gt;目前，我也在积极探索对统一代码质量评测体系的实践，希望逐步建立一套中心化的代码质量评测系统，在这个系统中让工匠精神、专家文化借住平台进一步传播、让系统的质量更加透明。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd31cb279ba0e36795a78066ee7ee067</guid>
<title>现代化 C 使用体验</title>
<link>https://toutiao.io/k/nz0xzfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;outline-text-headline-6&quot; class=&quot;outline-text-3&quot;&gt;&lt;p&gt;指针作为 C 中最重要的一类型，往往会给初学者造成较大困扰，不仅仅是使用上，光是解读指针定义就不是件容易的事情。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 比较好理解，是指向 int 类型的指针，那 &lt;code class=&quot;verbatim&quot;&gt;ptr2&lt;/code&gt; 呢？是指向数组的指针，还是元素为指针的数组？&lt;/p&gt;&lt;p&gt;其实这个问题在 K&amp;amp;R C 这本书有一点睛之笔，即：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也就是说，变量的声明语法，阐明了该变量在表达式中的类型。翻译过来比较绕，看几个例子就明白了：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*ptr&lt;/code&gt; 是一个类型为 int 的表达式，因此 ptr 必须是指针，指向 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 arr 必须是数组，数组元素为 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 必须是指针，因此 arr 必须是数组，元素是 int 的指针。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*ptr)[100]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 必须是指针，指向一个 int 类型数组&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*comp()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;comp()&lt;/code&gt; 必须返回一个 int 指针，因此 comp 是一个函数，返回值是 int 的指针&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*comp)()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;*comp&lt;/code&gt; 必须是一个函数，因此 comp 是一个函数指针&lt;/p&gt;&lt;p&gt;通过上面的解释，如果读者一时没有理解也不要紧，平时写代码用到时再来揣摩其中的奥妙。对于复杂的声明，一般推荐用 typedef 的方式。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;4&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;5&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;通过这种方式定义的 &lt;code class=&quot;verbatim&quot;&gt;a1&lt;/code&gt; 理解起来就没什么难度了，它首先是一数组，数组的元素是指向 int 的指针。K&amp;amp;R C 有一个程序，可以将复杂声明转为文字描述：&lt;a href=&quot;https://stackoverflow.com/questions/40388241/kr-recursive-descent-parser-strcat&quot;&gt;K&amp;amp;R - Recursive descent parser&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28f2920aab313b5bb19d1f3c6f181c87</guid>
<title>零拷贝技术第二篇：Go 语言中的应用</title>
<link>https://toutiao.io/k/6bnvoqn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书接上回:&lt;span&gt;零拷贝技术第一篇：综述&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;, 我们留了一个小尾巴，还没有介绍Go语言中零拷贝技术的应用，那么本文将带你了解Go标准库中零拷贝技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go标准库中的零拷贝&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go标准库中，也广泛使用了零拷贝技术来提高性能。因为零拷贝相关的技术很多都是通过系统调用提供的，所以在Go标准库中，也封装了这些系统调用，相关封装的代码可以在&lt;span&gt;internal/poll&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以Linux为例，毕竟我们大部分的业务都是在Linux运行的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;internal/poll/sendfile_linux.go&lt;/code&gt;文件中，封装了&lt;code&gt;sendfile&lt;/code&gt;系统调用，我删除了一部分的代码，这样更容易看到它是如何封装的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/ SendFile wraps the sendfile system call.&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SendFile&lt;/span&gt;&lt;span&gt;(dstFD *FD, src &lt;span&gt;int&lt;/span&gt;, remain &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...... &lt;span&gt;//写锁&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; dst := dstFD.Sysfd&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; written &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; remain &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  n := maxSendfileSize&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(n) &amp;gt; remain {&lt;br/&gt;   n = &lt;span&gt;int&lt;/span&gt;(remain)&lt;br/&gt;  }&lt;br/&gt;  n, err1 := syscall.Sendfile(dst, src, &lt;span&gt;nil&lt;/span&gt;, n)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   written += &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   remain -= &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; n == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; err1 == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  ...... &lt;span&gt;// error处理&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到&lt;code&gt;SendFile&lt;/code&gt;调用senfile批量写入数据。&lt;code&gt;sendfile&lt;/code&gt;系统调用一次最多会传输 0x7ffff00(2147479552) 字节的数据。这里Go语言设置maxSendfileSize为 0&amp;lt;&amp;lt;20 (4194304)字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;net/sendfile_linux.go&lt;/code&gt;文件中会使用到它:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sendFile&lt;/span&gt;&lt;span&gt;(c *netFD, r io.Reader)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, err error, handled &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; remain &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;62&lt;/span&gt; &lt;span&gt;// by default, copy until EOF&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; lr, ok := r.(*io.LimitedReader)&lt;br/&gt; ......&lt;br/&gt; f, ok := r.(*os.File)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; sc, err := f.SyscallConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; werr error&lt;br/&gt; err = sc.Read(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(fd &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  written, werr = poll.SendFile(&amp;amp;c.pfd, &lt;span&gt;int&lt;/span&gt;(fd), remain)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  err = werr&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; lr != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  lr.N = remain - written&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, wrapSyscallError(&lt;span&gt;&quot;sendfile&quot;&lt;/span&gt;, err), written &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数谁又会调用呢？是&lt;strong&gt;TCPConn&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *TCPConn)&lt;/span&gt; &lt;span&gt;readFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n, err, handled := splice(c.fd, r); handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n, err, handled := sendFile(c.fd, r); handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; genericReadFrom(c, r)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法又会被ReadFrom方法封装。记住这个&lt;strong&gt;ReadFrom&lt;/strong&gt;方法，我们待会再说。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *TCPConn)&lt;/span&gt; &lt;span&gt;ReadFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !c.ok() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, syscall.EINVAL&lt;br/&gt; }&lt;br/&gt; n, err := c.readFrom(r)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; err != io.EOF {&lt;br/&gt;  err = &amp;amp;OpError{Op: &lt;span&gt;&quot;readfrom&quot;&lt;/span&gt;, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCPConn.readFrom方法实现很有意思。它首先检查是否满足使用splice系统调用进行零拷贝优化，在目的是TCP connection, 源是TCP或者是Unix connection才能调用splice。否则才尝试使用sendfile。如果要使用sendfile优化，也有限制，要求源是*os.File文件。再否则使用不同的拷贝方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReadFrom又会在什么情况下被调用？实际上你经常会用到，&lt;code&gt;io.Copy&lt;/code&gt;就会调用&lt;code&gt;ReadFrom&lt;/code&gt;。也许在不经意之间，当你在将文件写入到socket过程中，就不经意使用到了零拷贝。当然这不是唯一的调用和被使用的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们看一个调用链，就会把脉络弄清楚：&lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; &lt;code&gt;*TCPConn.ReadFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;*TCPConn.readFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;net.sendFile&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.sendFile&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;splice&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面你也看到了，&lt;code&gt;*TCPConn.readFrom&lt;/code&gt;初始就是尝试使用splice,使用的场景和限制也提到了。&lt;code&gt;net.splice&lt;/code&gt;函数其实是调用&lt;code&gt;poll.Splice&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Splice&lt;/span&gt;&lt;span&gt;(dst, src *FD, remain &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, handled &lt;span&gt;bool&lt;/span&gt;, sc &lt;span&gt;string&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p, sc, err := getPipe()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, sc, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; putPipe(p)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; inPipe, n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; remain &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  max := maxSpliceSize&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(max) &amp;gt; remain {&lt;br/&gt;   max = &lt;span&gt;int&lt;/span&gt;(remain)&lt;br/&gt;  }&lt;br/&gt;  inPipe, err = spliceDrain(p.wfd, src, max)&lt;br/&gt;  handled = handled || (err != syscall.EINVAL)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; || inPipe == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  p.data += inPipe&lt;br/&gt;&lt;br/&gt;  n, err = splicePump(dst, p.rfd, inPipe)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   written += &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   remain -= &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   p.data -= n&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; written, handled, &lt;span&gt;&quot;splice&quot;&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇中讲到pipe如果每次都创建其实挺损耗性能的，所以这里使用了pip pool,也提到是潘少优化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你看到，不经意间你就会用到splice或者sendfile。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;CopyFileRange&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;copy_file_range_linux.go&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;封装了copy_file_range系统调用。因为这个系统调用非常的新，所以封装的时候首先要检查Linux的版本，看看是否支持此系统调用。版本检查和调用批量拷贝的代码我们略过，具体看是怎么使用这个系统调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copyFileRange&lt;/span&gt;&lt;span&gt;(dst, src *FD, max &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := dst.writeLock(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; dst.writeUnlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := src.readLock(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; src.readUnlock()&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  n, err = unix.CopyFileRange(src.Sysfd, &lt;span&gt;nil&lt;/span&gt;, dst.Sysfd, &lt;span&gt;nil&lt;/span&gt;, max, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != syscall.EINTR {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(n), err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪里会使用到它呢？of.File的读取数据的时候：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; pollCopyFileRange = poll.CopyFileRange&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(f *File)&lt;/span&gt; &lt;span&gt;readFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, handled &lt;span&gt;bool&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// copy_file_range(2) does not support destinations opened with&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// O_APPEND, so don&#x27;t even try.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; f.appendMode {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; remain := &lt;span&gt;int64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;62&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; lr, ok := r.(*io.LimitedReader)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok {&lt;br/&gt;  remain, r = lr.N, lr.R&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; remain &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; src, ok := r.(*File)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; src.checkValid(&lt;span&gt;&quot;ReadFrom&quot;&lt;/span&gt;) != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Avoid returning the error as we report handled as false,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// leave further error handling as the responsibility of the caller.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; written, handled, err = pollCopyFileRange(&amp;amp;f.pfd, &amp;amp;src.pfd, remain)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; lr != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  lr.N -= written&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, handled, NewSyscallError(&lt;span&gt;&quot;copy_file_range&quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的是*FIle.ReadFrom调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(f *File)&lt;/span&gt; &lt;span&gt;ReadFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := f.checkValid(&lt;span&gt;&quot;write&quot;&lt;/span&gt;); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; n, handled, e := f.readFrom(r)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; genericReadFrom(f, r) &lt;span&gt;// without wrapping&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n, f.wrapErr(&lt;span&gt;&quot;write&quot;&lt;/span&gt;, e)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个优化用在文件的拷贝中，一般的调用链路是 &lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; &lt;code&gt;*File.ReadFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;*File.readFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.CopyFileRange&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.copyFileRange&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标准库零拷贝的应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go标准库将零拷贝技术在底层做了封装，所以很多时候你是不知道的。比如你实现了一个简单的文件服务器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;import &quot;net/http&quot;&lt;br/&gt;&lt;br/&gt;func main() {&lt;br/&gt;// 绑定一个handler&lt;br/&gt;http.Handle(&quot;/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(&quot;../root.img&quot;))))&lt;br/&gt;// 监听服务&lt;br/&gt;http.ListenAndServe(&quot;:8972&quot;, nil)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用链如左：&lt;code&gt;http.FileServer&lt;/code&gt; -&amp;gt; &lt;code&gt;*fileHandler.ServeHTTP&lt;/code&gt; -&amp;gt; &lt;code&gt;http.serveFile&lt;/code&gt; -&amp;gt; &lt;code&gt;http.serveContent&lt;/code&gt; -&amp;gt; &lt;code&gt;io.CopyN&lt;/code&gt; -&amp;gt; &lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; 和sendFile的调用链接上了。可以看到访问文件的时候是调用了sendFile。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三方库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几个库提供了sendFile/splice的封装。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/acln0/zerocopy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/hslam/splice&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/hslam/sendfile&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为直接调用系统调用很方便，所以很多时候我们可以模仿标准库实现我们自己零拷贝的方法。所以个人感觉这些传统的方式没有太多锦上添花的东西可做了，要做的就是新的零拷贝系统接口的封装或者自定义开发。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;零拷贝技术第一篇：综述: &lt;span&gt;https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;internal/poll: &lt;span&gt;https://github.com/golang/go/tree/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;copy_file_range_linux.go: &lt;span&gt;https://github.com/golang/go/blob/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll/copy_file_range_linux.go&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1153762a7ad9ea61043f1cbbe2a9142a</guid>
<title>判断线程池是否全部完成的 5 种方法，还有谁不会？？</title>
<link>https://toutiao.io/k/w4f2muf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近写小玩具的时候用到了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 计数器，然后顺便想了想判断线程池全部结束有多少种方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在网上搜了下，可能有些没找到，但是我找到的有（所有方法都是在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 线程池方法下测试的）：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 判断方式，在执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，关闭线程池后，判断是否所有任务已经完成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getCompletedTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，判断完成任务数和全部任务数是否相等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 计数器，使用闭锁计数来判断是否全部完成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;手动维护一个公共计数 ，原理和闭锁类似，就是更加灵活。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;submit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 向线程池提交任务，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 判断任务执行状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好嘞，现在开始一个一个介绍优缺点和简要原理；&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先创建一个 static 线程池，后面好几个例子就不一一创建了，全部用这个就行了：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 创建一个最大线程数是20的线程池&lt;br/&gt; */&lt;br/&gt;public static ThreadPoolExecutor pool = new ThreadPoolExecutor(&lt;br/&gt;     10, 20, 0L,&lt;br/&gt;     TimeUnit.MILLISECONDS,&lt;br/&gt;     new LinkedBlockingQueue&amp;lt;&amp;gt;());&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后再准备一个通用的睡眠方法：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 线程执行方法，随机等待0到10秒&lt;br/&gt; */&lt;br/&gt;private static void sleepMtehod(int index){&lt;br/&gt;    try {&lt;br/&gt;        long sleepTime = new Double(Math.random() * 10000).longValue();&lt;br/&gt;        Thread.sleep(sleepTime);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;当前线程执行结束: &quot;&lt;/span&gt; + index);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方法就是为了测试的时候区分线程执行完毕的下顺序而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好嘞，准备完毕，现在开始。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;isTerminated 方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先贴上测试代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void shutdownTest() throws Exception {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;        int index = i;&lt;br/&gt;        pool.execute(() -&amp;gt; sleepMtehod(index));&lt;br/&gt;    }&lt;br/&gt;    pool.shutdown();&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!pool.isTerminated()){&lt;br/&gt;        Thread.sleep(1000);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这一种方式就是在主线程中进行循环判断，全部任务是否已经完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里有两个主要方法：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。如果已经关闭，调用没有额外的作用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果所有任务在关闭后完成，则返回true。请注意， &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 从不是 true，除非 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdownNow&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 先被执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通俗点讲，就是在执行全部任务后，对线程池进行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 有序关闭，然后循环判断 &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，线程池是否全部完成。另外，&lt;span&gt;最新最全的 Java 面试题整理好了，点击&lt;/span&gt;Java面试库&lt;span&gt;小程序在线刷题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：操作简单，代码更加简单。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：需要关闭线程池。一般我在代码中都是将线程池注入到 Spring 容器，然后各个组件中统一用同一个，当然不能关闭。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类似方法扩展：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;shutdownNow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。从此方法返回时，这些任务将从任务队列中删除。通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Thread.interrupt()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 取消任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isShutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果线程池已关闭，则返回 true 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminating()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdownNow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之后终止 ，但尚未完全终止，则返回true。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;waitTermination(long timeout, TimeUnit unit)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：当前线程阻塞，直到等所有已提交的任务（包括正在跑的和队列中等待的）执行完，或者等超时时间到，或者线程被中断抛出异常；全部执行完返回true，超时返回false。也可以用这个方法代替 &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进行判断 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;getCompletedTaskCount&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还是一样，贴上代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void taskCountTest() throws Exception {&lt;br/&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;            int index = i;&lt;br/&gt;            pool.execute(() -&amp;gt; sleepMtehod(index));&lt;br/&gt;        }&lt;br/&gt;        //当线程池完成的线程数等于线程池中的总线程数&lt;br/&gt;        &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!(pool.getTaskCount() == pool.getCompletedTaskCount())) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;任务总数:&quot;&lt;/span&gt; + pool.getTaskCount() + &lt;span&gt;&quot;； 已经完成任务数:&quot;&lt;/span&gt; + pool.getCompletedTaskCount());&lt;br/&gt;            Thread.sleep(1000);&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还是一样在主线程循环判断，主要就两个方法：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：返回计划执行的任务总数。由于任务和线程的状态可能在计算过程中动态变化，因此返回的值只是一个近似值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getCompletedTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：返回完成执行的任务的大致总数。因为任务和线程的状态可能在计算过程中动态地改变，所以返回的值只是一个近似值，但是在连续的调用中并不会减少。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个好理解，总任务数等于已完成任务数，就表示全部执行完毕。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：完全使用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 提供的方法，并且不必关闭线程池，避免了创建和销毁带来的损耗。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：上面的解释也看到了，使用这种判断存在很大的限制条件；必须确定，在循环判断过程中，没有新的任务产生。差不多意思就是，这个线程池只能在这条线程中使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其他 ：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后扯两句，因为我用 main 方法运行的，跑完后 main 没有结束，是因为非守护线程如果不终止，程序是不会结束的。而线程池 Worker 线程里写了一个死循环，而且被设置成了非守护线程。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;CountDownLatch 计数器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方法是我比较常用的方法，先看代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void countDownLatchTest() throws Exception {&lt;br/&gt;     //计数器，判断线程是否执行结束&lt;br/&gt;     CountDownLatch taskLatch = new CountDownLatch(30);&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;         int index = i;&lt;br/&gt;         pool.execute(() -&amp;gt; {&lt;br/&gt;             sleepMtehod(index);&lt;br/&gt;             taskLatch.countDown();&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;当前计数器数量：&quot;&lt;/span&gt; + taskLatch.getCount());&lt;br/&gt;         });&lt;br/&gt;     }&lt;br/&gt;     //当前线程阻塞，等待计数器置为0&lt;br/&gt;     taskLatch.await();&lt;br/&gt;     System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方法，呃，应该是看起来比较高级的，我也不知道别的大佬怎么写的，反正我就用这个。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方法需要介绍下这个工具类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。先把这种方式的优缺点写了，后面再详细介绍这个类。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：代码优雅，不需要对线程池进行操作，将线程池作为 Bean 的情况下有很好的使用场景。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：需要提前知道线程数量；性能确实，呃呃呃呃呃，差了点。哦对了，还需要在线程代码块内加上异常判断，否则在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之前发生异常而没有处理，就会导致主线程永远阻塞在 await。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;CountDownLatch 概述&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 JDK 提供的一个同步工具，它可以让一个或多个线程等待，一直等到其他线程中执行完成一组操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常用的方法有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在初始化时，需要指定用给定一个整数作为计数器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法时，计数器会被减1；当调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法时，如果计数器大于0时，线程会被阻塞，一直到计数器被 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法减到0时，线程才会继续执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计数器是无法重置的，当计数器被减到0时，调用 await 方法都会直接返回。最新最全的 Java 多线程面试题整理好了，点击Java面试库小程序在线刷题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;维护一个公共计数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式其实和 CountDownLatch 原理类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先维护一个静态变量&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static int taskNum = 0;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后在线程任务结束时，进行静态变量操作：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void staticCountTest() throws Exception {&lt;br/&gt;     Lock lock = new ReentrantLock();&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;         int index = i;&lt;br/&gt;         pool.execute(() -&amp;gt; {&lt;br/&gt;             sleepMtehod(index);&lt;br/&gt;             lock.lock();&lt;br/&gt;             taskNum++;&lt;br/&gt;             lock.unlock();&lt;br/&gt;         });&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt;(taskNum &amp;lt; 30) {&lt;br/&gt;         Thread.sleep(1000);&lt;br/&gt;         System.out.println(&lt;span&gt;&quot;还没停止。。。当前完成任务数:&quot;&lt;/span&gt; + taskNum);&lt;br/&gt;     }&lt;br/&gt;     System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实就是加锁计数，循环判断。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：手动维护方式更加灵活，对于一些特殊场景可以手动处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 相比，一样需要知道线程数目，但是代码实现比较麻烦，相对于灵活这一个优势，貌似投入产出并不对等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Future 判断任务执行状态&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是用来装载线程结果的，不过，用这个来进行判断写代码总感觉怪怪的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只能装载一条线程的返回结果，多条线程总不能用 List 在接收 Future 。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里就开一个线程做个演示：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void futureTest() throws Exception {&lt;br/&gt;    Future&amp;lt;?&amp;gt; future = pool.submit(() -&amp;gt; sleepMtehod(1));&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!future.isDone()){&lt;br/&gt;        Thread.sleep(500);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式就不写优缺点了，因为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的主要使用场景并不是用于判断任务执行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>acb88ce4204a51433f6bd8134a539de1</guid>
<title>异常检测算法分类总结（含常用开源数据集）</title>
<link>https://toutiao.io/k/klv044a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;em&gt;作者：云智慧算法工程师 Chris Hu&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;异常检测是识别与正常数据不同的数据，与预期行为差异大的数据。本文详细介绍了异常检测的应用领域以及总结梳理了异常检测的算法模型分类。文章最后更是介绍了常用的异常算法数据集。&lt;/p&gt;

&lt;h2&gt;异常的概念与类型&lt;/h2&gt;

&lt;p&gt;目前异常检测主要是基于Hawkins对异常的定义：(Hawkins defines an outlier as an observation that deviates so significantly from other observations as to arouse suspicion that it was generated by a different mechanism.)。异常（anomaly/outlier）指的是远离其他观测数据而疑为不同机制产生的观测数据。根据概率理论对异常的形式化定义如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ac5edd2b65541d9b165b8e753be021d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;异常主要分为以下三种类型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;point anomalies（点异常）&lt;/p&gt;

&lt;p&gt;点异常是单个异常数据点 ，将数据集中每个数据映射到高维空间中，其中孤立的点被称为点异常。这种异常点与其他数据点具有明显差异，这种异常分类是异常数据中最为简单的一种，也是异常检测研究中最常研究的异常类型。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec9a2b0c06b249dfa9c88bebd4b6fccb%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;conditional anomalies/contextual anomalies（条件异常/上下文异常）&lt;/p&gt;

&lt;p&gt;一个数据本身来看属于正常点，但在特定的条件下又与一般情况有差异，这类数据称为条件异常或上下文异常。其中上下文指数据集间的结构和关系，每个数据均由上下文特征( contextual attributes) 及行为特征( behavioral attributes) 来定义，即条件异常需要考虑的不仅仅是数据的取值，还需考虑数据出现的环境，也就是说某一数据在特定数据环境下被判断为异常，而在其他数据集中则可能是正常的。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b624246e027d41c89ad0cb7bdcc985f1%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;collective anomalies/group anomalies（群体异常/序列异常）&lt;/p&gt;

&lt;p&gt;数据属性在正常范围内，且从上下文环境角度判断也属于正常的数据仍有可能是异常数据。如图3所示，在脑电图中虚线圆圈部分与脑电图整体图形不一致模式称之为聚集异常( 或称集合异常)。异常数据集中单个点可能并不异常，但这些相互关联的数据点聚集在一起时变为异常的情况。聚集异常不仅需要考虑数据的取值、上下文环境，还考虑数据集是否符合整体模式。聚集异常检测常用于时间序列、空 间数据以及图形式的数据中。
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d63175fd873a409d804e27e84054320c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际的运维场景中，以上三种异常都会出现，比如资源使用率突然上升造成Point Anomalies，又如CPU使用过程中的突然卡顿形成Contextual anomaly，再如某指标使用率连续一段时间处于“满格”状态而呈现出Collective or group anomalies。后两者异常通常需要和业务紧密结合，单纯从数据本身出发具有一定的辨识难度，再加上运维领域中大比例情况下出现的是Point Anomalies，客户多关注于此，因而通常情况下我们更关注Point Anomalies。&lt;/p&gt;

&lt;h2&gt;异常检测的应用领域&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;入侵检测（Intrusion detection）：通过从计算机网络或计算机系统中的若干关键点收集信息并对其进行分析，从中发觉网络或系统中有没有违反安全策略的行为和遭到袭击的迹象，并对此做出适当反应的流程。最普遍的两种入侵检测系统包括基于主机的入侵检测系统（HIDS）、网络入侵检测系统（NIDS）。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;欺诈检测（Fraud detection）：主要是不同领域的非法活动检测，主要应用领域包括银行欺诈、移动蜂窝网络故障、保险欺诈、医疗欺诈。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;恶意软件检测（Malware Detection）：主要分为静态分析检测技术与动态分析与检测技术。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;医疗异常检测（Medical Anomaly Detection）：通过X光片、核磁共振、CT等医学图像检测疾病或量化异常，也可以通过EEG、ECG等时序信号进行疾病检测或异常预警。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;深度学习用于社交网络中的异常检测（Deep learning for Anomaly detection in Social Networks）： 社交网络中的异常通常是指个人的不正常甚至违法的行为，如垃圾邮件发送者、性侵者、在线欺诈者、虚假用户或谣言散布者等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志异常检测（Log Anomaly Detection）：日志异常检测是指找到异常日志，从而判断系统故障原因与性质，通常将日志数据建模为自然语言序列进行异常检测。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;物联网大数据异常检测（Internet of things (IoT) Big Data Anomaly Detection）：通过监控数据流信息检测异常设备和系统行为。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工业异常检测（Industrial Anomalies Detection）: 检测风力涡轮机、发电厂、高温能源系统、存储设备和旋转机械部件组成的工业系统中设备的损坏情况， 该领域中异常检测的挑战是数据量与数据的动态特性，因为故障通常是由多种因素引起的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;时间序列中的异常检测（Anomaly Detection in TimeSeries）：包括单变量时间序列异常检测与多变量时间序列异常检测。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;视频监控（Video Surveillance）：检测视频中的异常场景。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;异常检测思路与方法总结&lt;/h2&gt;

&lt;p&gt;现如今，异常检测主要面临以下困难与挑战：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;未知性：异常与许多未知因素有关，例如，具有未知的突发行为、数据结构和分布的实例。它们直到真正发生时才为人所知，比如恐怖袭击、诈骗和网络入侵等应用；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异常类的异构性： 异常是不规则的，一类异常可能表现出与另一类异常完全不同的异常特征。例如，在视频监控中，抢劫、交通事故和盗窃等异常事件在视觉上有很大差异；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类别不均衡：异常通常是罕见的数据实例，而正常实例通常占数据的绝大部分。因此，收集大量标了标签的异常实例是困难的，甚至是不可能的。这导致在大多数应用程序中无法获得大规模的标记数据。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;基于标签的异常检测算法分类&lt;/h3&gt;



&lt;p&gt;有监督异常检测算法是指在训练集中的正常实例和异常实例都有标签，训练二类或多类分类器。有监督异常检测方法主要面临两个问题，一方面是在训练数据中，相对于正常时间序列来讲，异常的数据量太小，会对检测效果产生影响；另一方面是在实际操作中很难精确地标注数据是正常或异常，而且异常的情况也难以全部覆盖。基于以上原因，在实际异常检测中，有监督异常检测算法在实际应用中较少。&lt;/p&gt;



&lt;p&gt;半监督异常检测算法是指在训练集中只有单一类别（正常实例）的实例，没有异常实例参与训练。半监督异常检测技术的一种典型方法是基于训练数据集为正常时间序列数据建立模型，然后利用该模型识别待检测数据中的异常。半监督异常检测学习正常数据的判别边界，不属于正常类的数据被判断为异常。由于训练中不需标注异常序列，因此半监督式异常检测方法的应用相对更加广泛。&lt;/p&gt;



&lt;p&gt;无监督异常检测算法在训练集中既有正常实例也可能存在异常实例，但假设数据的比例是正常实例远大于异常实例，模型训练过程中没有标签进行校正。此类技术的核心思想在于异常的情况相对于正常的情况而言是很少的，且其与正常情况存在较大的差异，这种差异可以体现在数据之间的距离远近、分布密度、偏离程度等方面。无监督异常检测算法仅根据数据的内在属性（如距离、密度等）检测数据的异常值，自编码器是所有无监督深度异常检测模型的核心。&lt;/p&gt;

&lt;h3&gt;基于模型的异常检测算法分类&lt;/h3&gt;

&lt;p&gt;基于模型的异常算法分类基于传统方法的异常检测模型和基于深度学习的异常检测模型两大类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/09e8b8c0d2b149f2b1c1af8b1cc1720a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;基于传统方法的异常检测模型&lt;/h4&gt;



&lt;p&gt;使用这类方法基于的基本假设是正常的数据是遵循特定分布形式的，并且占了很大比例，而异常点的位置和正常点相比存在比较大的偏移。比如高斯分布，在平均值加减3倍标准差以外的部分仅占了0.2%左右的比例，一般我们把这部分数据就标记为异常数据。&lt;/p&gt;

&lt;p&gt;基于统计的异常检测一般需要充分的数据基础和相应的先验知识，此时检测效果可能是非常有效的。然而，此类检测方法一般是针对单个属性或低维数据的，而对于高纬度的时间序列数据就难以估计其真实的分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df7a46b7d6554913880734623b3f3d9c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;假设异常点是不可被压缩的或不能从低维映射空间有效地被重构的。常见的方法有PCA、Robust PCA、random projection等降维方法。 PCA提取了数据的主要特征，如果一个数据样本不容易被重构出来，表示这个数据样本的特征跟整体数据样本的特征不一致，那么它显然就是一个异常的样本。&lt;/p&gt;

&lt;p&gt;对于数据样本X_i, 假设其基于 k 维特征向量重构的样本为X_ik^&#x27; , 则该数据样本的异常得分可以用如下的公式计算：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1705a3c16c4243698539bff6998cb9d5%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;此类方法利用聚类算法（如K-means、_x0008_DBSCAN等）对待检测数据进行聚类，通过聚类的结果来分辨正常与异常的数据，是一种典型的非监督式异常检测技术。通常来讲，基于聚类的异常检测可基于三种假设来分辨异常数据：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不属于任何簇（Cluster）的数据即为异常；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;距离簇中心很远的数据即为异常；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;归属于数据点少或稀疏簇的数据即为异常。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用聚类算法进行异常检测，可利用大量已有的聚类研究成果。但是，聚类与异常检测还是有较大差异的，异常检测的目标在于寻找不正常的数据，而聚类的目的在于确定数据归属的类别。而且，很多聚类算法并未针对时间序列数据做优化，算法执行效率往往不高。&lt;/p&gt;



&lt;p&gt;对正常数据建立区分性边界，异常点被划分到边界外。常见的方法有OC-SVM、SVDD等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6db3a34f6f034bb5a703d28281fbcc23%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;基于深度学习的异常检测模型&lt;/h4&gt;



&lt;p&gt;该类的典型方法为：Deep SVDD [11] 、OC-NN [20]。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb1edf5f21814f98a32fa027e42fd4f4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee3ba33d46041bdb46cddc03437a8df%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;采用深度学习的聚类方法一般是用神经网络对输入数据进行编码，然后认为最后的编码序列可以代表神经网络的很多特征，然后我们对编码序列进行聚类就可以达成聚类的目的。该类方法被用于异常检测的包括：CAE-l2 cluster 、DAE-DBC。&lt;/p&gt;

&lt;p&gt;CAE-l2 cluster：在autoencoder中间加入了L2标准化以及k-means。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2b8f5400ef449978c49af58f39c9f94%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DAE-DBC：先利用autoencoder降维，然后通过聚类方法判别异常值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5627b8a432954010878513cb372337d4%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;一个通用的自动编码器由编码器和解码器组成，编码器将原始数据映射到低维特征空间，而解码器试图从投影的低维空间恢复数据。这两种网络的参数通过重构损失函数来学习。为了使整体重构误差最小化，保留的信息必须尽可能与输入实例(如正常实例)相关。&lt;/p&gt;

&lt;p&gt;典型案例有稀疏自动编码器（sparse AE）、去噪自动编码器（denoising AE）、收缩自动编码器（contractive AE）、鲁邦自动编码器（Robust Deep AE）等，基本原理都较为简单。&lt;/p&gt;

&lt;p&gt;该类方法的优点是能够通过非线性方法捕捉复杂特征，试图找到正常实例的一种通用模式，缺点是如何选择正确的压缩程度，以及如何解决“过拟合”的问题（网络拟合的太好以至于异常实例也“潜伏”在低维特征空间中）。为了解决这个缺点，有研究者使用正则化或者记忆矩阵等等方法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52f0e6e10de84ec1b0bb8e22db14c5d7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4764d35607504c90986b297002b2a582%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这种方法通常旨在学习生成网络G的潜在特征空间，使潜在空间能够很好地捕捉到给定数据背后的常态。将生成模型用于异常检测是基于在生成网络的潜在特征空间中正常实例比异常实例能够更准确地被产生这一假设。 实际实例和生成实例之间的残差被定义为异常分数。&lt;/p&gt;

&lt;p&gt;典型案例有AnoGAN、GANomaly、Wasserstein GAN、 Cycle GAN、VAE等。该类方法的关键问题是如何设计合适的生成器和目标函数。&lt;/p&gt;

&lt;h3&gt;异常检测数据集&lt;/h3&gt;

&lt;h4&gt;异常检测数据类型&lt;/h4&gt;

&lt;p&gt;用于异常检测的数据通常可分为两类：&lt;/p&gt;

&lt;p&gt;序列数据：如voice, text, music, time series, protein sequences；&lt;/p&gt;

&lt;p&gt;非序列数据：如images, other data。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d12cfd6f8424d63a318e606374d3a3c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;异常检测开源数据集&lt;/h4&gt;

&lt;p&gt;下方链接为常用的异常检测数据集，该git仓库中维护了多种通用的异常检测数据集。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/GuansongPang/ADRepository-Anomaly-detection-datasets&quot;&gt;https://github.com/GuansongPang/ADRepository-Anomaly-detection-datasets&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8014047e3b4b62a62489e8b9b76b18%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下方链接为时间序列异常检测数据集，该git仓库中维护了时间序列异常检测算法相关的软件、包、数据集等。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/rob-med/awesome-TS-anomaly-detection&quot;&gt;https://github.com/rob-med/awesome-TS-anomaly-detection&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2dd53f340aa4b1a9c30da6841e2bc25%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;开源项目推荐&lt;/h2&gt;

&lt;p&gt;云智慧已开源数据可视化编排平台 FlyFish 。通过配置数据模型为用户提供上百种可视化图形组件，零编码即可实现符合自己业务需求的炫酷可视化大屏。 同时，飞鱼也提供了灵活的拓展能力，支持组件开发、自定义函数与全局事件等配置， 面向复杂需求场景能够保证高效开发与交付。&lt;/p&gt;

&lt;p&gt;如果喜欢我们的项目，请不要忘记点击下方代码仓库地址，在 &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;Gitee&lt;/a&gt;&lt;/strong&gt; 仓库上点个 Star，我们需要您的鼓励与支持。此外，即刻参与 FlyFish 项目贡献成为 FlyFish Contributor 的同时更有万元现金等你来拿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;https://github.com/CloudWise-OpenSource/FlyFish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;https://gitee.com/CloudWise/fly-fish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【飞鱼】加入 AIOps 社区飞鱼开发者交流群，与 FlyFish 项目 PMC 面对面交流～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/018b9a988f5d4945896d91995eb620f8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>