<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4f32e2fd05191161bc3963bffcd8f194</guid>
<title>万字长文将 MySQL InnoDB 剥的一丝不挂：B+ 树与 Buffer Pool</title>
<link>https://toutiao.io/k/5073apm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;本文共 11000 字，阅读大约需要 40 分钟。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;前面几篇文章，我们大多数时候都在挥舞着架构大棒，对性能问题进行降维打击，但是本文不一样，本文要啃硬骨头：吃透 MySQL 的 InnoDB 存储引擎，以便于我们能顺利地看懂下一篇文章。&lt;/p&gt;&lt;p&gt;同时，本文也是一篇比较完善的讲解 InnoDB 底层设计原理的文章，单独作为 InnoDB 的一篇详解文章我认为也是极好的，如果大家觉得对身边的人有帮助，可以单独分享此篇文章，相信能够让每一个读过的人都对 InnoDB 有新的理解、体会和感悟。&lt;/p&gt;&lt;p&gt;本文将是《高并发的哲学原理》系列中唯一一篇有点像面试八股文的文章，但是，我们还是要尽量走出个虎虎生风，走出个一日千里，再走出个恍如隔世...... 下面我们正式开始。&lt;/p&gt;&lt;h2&gt;磁盘存储引擎的巅峰——InnoDB&lt;/h2&gt;&lt;h3&gt;发展历程和设计目标&lt;/h3&gt;&lt;p&gt;2004 年，扎克伯格选择了 MySQL 来创建 Facebook，不承想，Facebook 迅速火遍了全世界。之后的十年，Google、亚马逊、阿里巴巴等互联网巨头纷纷选择了 MySQL 作为自己的核心数据库，随之而来的就是 MySQL 的高速发展：互联网巨头投入海量技术资源把 MySQL 打造成了一个十分优秀的开源数据库软件，而 InnoDB 就是承接资源最多的那个部分。&lt;/p&gt;&lt;p&gt;这些公司的数据库需求基本都是一个类型的：表字段很少，但是行数很多；对于单个查询的时间要求很高；很少存储长字符串和二进制文件。这个类型的需求恰恰不是传统数据库(如 Oracle)的强项。而且，互联网公司的发展一日千里，无论是授权费还是实施速度，买 Oracle 都不如自己魔改 MySQL。之后的十几年，MySQL 特别是 InnoDB 的发展真的可以说是虎虎生风、一日千里，如果你站在 2014 往回看 2004，也确实称得上恍如隔世。&lt;/p&gt;&lt;p&gt;但 InnoDB 也不是银弹，它的性能也是靠&lt;code&gt;取舍&lt;/code&gt;得来的。&lt;/p&gt;&lt;h3&gt;InnoDB 拿什么找信息之神换了什么？&lt;/h3&gt;&lt;p&gt;InnoDB 和之前的 MyISAM 比，最大的变化就是将磁盘上面数据的基本存储结构从索引+数据这样的分体式，变成了所有数据都挂在索引上的整体式：从“B+ 树索引”加“磁盘连续存储数据”(中间用指针链接)变成了“B+ 树存储全部索引和数据”。&lt;/p&gt;&lt;p&gt;这个操作给 MySQL 带来了翻天覆地的变化。那么，InnoDB 到底做了哪些取舍呢？&lt;/p&gt;&lt;h4&gt;代价&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;插入性能显著下降，更新性能显著下降（100~1000倍，但是绝对耗时依然在毫秒级别）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一次性读取连续多行的复杂度大幅提升（大约提升了&lt;code&gt;行数/10&lt;/code&gt;那么多倍）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;因为事务隔离导致大表 count(*) 的返回时间令人崩溃（多少倍已经无法衡量，一千倍到一千亿倍吧）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;放弃了数据完全压缩能力（磁盘占用 2-5 倍）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写入放大显著增加，对磁盘特别是固态磁盘(SSD)形成了额外的压力&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;收益&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;支持了事务：事务是极其核心的功能进步，使 MySQL 摆脱了玩具定位，真正实现了&lt;code&gt;ACID&lt;/code&gt;，成为了一个合格的 OLTP 数据库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大表的单行读取性能暴增：数据挂在 B+ 树索引上带来的优势，还可以依靠内存缓存进行加速和局部性优化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DML(表结构变更)操作的安全性大幅提升，数据损坏的概率大幅降低&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;联表查询性能大幅提升，让 MySQL 在 OLAP 方向也有很大进步&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持全文检索：类似于 ES 的倒排索引&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;其它小收益：支持了行锁、内存缓存、外键约束等&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这些代价和收益，基本都是两个东西带来的：B+ 树和 Buffer Pool，下面我们分别认识一下这两个技术。&lt;/p&gt;&lt;h2&gt;B+ 树&lt;/h2&gt;&lt;p&gt;B+ 树是 1970 年 Rudolf Bayer 教授在《Organization and Maintenance of Large Ordered Indices》一文中提出的，此后，该技术迅速成为了海量数据存储与检索的大宝贝：以查询为主要场景的关系型数据库，无一例外地选择了它。&lt;/p&gt;&lt;h3&gt;B+ 树基本思想&lt;/h3&gt;&lt;p&gt;B+ 树是一种平衡多路查找树，它的思想其实是承袭自平衡二叉树和 B 树的，但是它是为速度非常慢的所谓“外存”设计的一种数据结构，所以它拥有独特的设计方向：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;尽量减少数据不停增长时的磁盘 IO 数量：包含插入新数据场景和查询场景&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它将经典平衡二叉树的“再平衡”过程&lt;code&gt;颠倒&lt;/code&gt;过来了：最底层的叶子结点致密排列，新增数据时不断新增新的叶子节点，需要进行“再平衡”操作的不是叶子节点，而是上面的索引页，索引页具有以下特点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;索引页的数量很少&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;再平衡时 B+ 树算法调整的索引节点数量也很少&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;索引容量足够大：3 层索引可以承载 2000 万行数据，4 层索引可以承载 200 多亿行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;索引页少，就可以将所有索引全部载入内存，读取索引的磁盘 IO 无限趋近于 0&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;InnoDB 是如何组织数据的&lt;/h3&gt;&lt;p&gt;下面我们来具体认识一下 InnoDB 中索引和数据在磁盘上是怎么利用 B+ 树思想进行组织的：&lt;/p&gt;&lt;h4&gt;1. 页&lt;/h4&gt;&lt;p&gt;页是 MySQL 中数据存储的基本单元，整颗 B+ 树就是一个又一个相互使用指针连接在一起的页组成的。由于 InnoDB 出现的时候，SSD 还没有出现，所以它是为了机械磁盘及其 512 字节的扇区而设计的，所以页块的默认大小被设置为了 16KB（32 个连续扇区）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4422145328719723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOphFH0Q1XN0HiaELJ01Ry4sTGYU3hprTZhjgylgUMkPTFr5FibVInRX6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2890&quot;/&gt;&lt;/p&gt;&lt;center&gt;三层索引下的页结构图（35 行数据）&lt;/center&gt;&lt;p&gt;这张图基本展示出了页之间的指针关系：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;上层页对下层页拥有&lt;code&gt;单向&lt;/code&gt;指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同一层内相邻的页之间拥有&lt;code&gt;双向&lt;/code&gt;指针，无论是上面的索引页层还是底层的数据也层&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最底层数据页层中，每一页可以存储多行数据，每一行数据拥有指向下一行的&lt;code&gt;单向&lt;/code&gt;指针&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;而在物理层面，每一页的内部结构都如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5765575501583949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPO2DhyywdOv02wr7eerJd6ibvdDDIj3J7DMeCcpYkic9bklw2aMOPL9P7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;947&quot;/&gt;&lt;/p&gt;&lt;h4&gt;2. 索引页里面有什么&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4305555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOMicTQBmNj0m9FrGEJH3P7mbqqBngHROh44ib5lr5unicVQkjf2FguSQvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2016&quot;/&gt;&lt;/p&gt;&lt;center&gt;二层索引下的页结构图（15 行数据）&lt;/center&gt;&lt;p&gt;我们用更清晰的二层索引簇结构来展示索引页包含的关键信息，顶部那个彩色的就是索引页。&lt;/p&gt;&lt;p&gt;除了头部和尾部的基础信息字段之外，索引页的“用户存储数据”紧密排列着&lt;code&gt;指向下一层页的指针&lt;/code&gt;，结构为：&lt;code&gt;id|页号&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这里的 id 就是这张表默认主键的那个 id，一般为&lt;code&gt;int&lt;/code&gt;(4 字节)或者&lt;code&gt;bigint&lt;/code&gt;(8 字节)。该数字的含义是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;该页号对应的页，以及下挂的所有页，所拥有的全部数据行中，id 最小的那行数据的 id&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;InnoDB 使用这个数字可以快速定位某一行数据所处的页的位置。&lt;/p&gt;&lt;p&gt;页号就是页的编号，在不同版本的 MySQL 上这个页编号的长度是不一样的，下面我们会通过测试来确定 MySQL 8.0 中页编号的长度。&lt;/p&gt;&lt;h4&gt;3. 数据页里面有什么&lt;/h4&gt;&lt;p&gt;B+ 树上层的所有页只存储索引，只用最底层的页存储数据。这是 B+ 比 B 树优秀的地方：以一丢丢写入速度为代价，让较少的索引层数内存下了更多的索引指针，可以支撑海量的数据行数。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.137037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOhZ8sObvngSKGPLaWtafiapUeWwMH53hHtu2nJOriaAdex1zXk6BjZq4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;数据页内部是分槽的，相当于自己又加了一层索引。数据页内部拥有最小记录指针和最大纪录指针，有没有觉得一花一世界，数据页内部结构和 B+ 树颇有几分神似呢？&lt;/p&gt;&lt;h3&gt;执行 &lt;code&gt;select * from users where id=6&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;有了前面的铺垫，真正的 SQL 查询过程就呼之欲出了：我们要找出&lt;code&gt;id=6&lt;/code&gt;的一行数据时，只需要一层一层地比大小：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将顶部页(16KB)的数据读入内存，将 6 和每一个&lt;code&gt;id|页号&lt;/code&gt;进行大小对比，找到 6 落在哪一页：大于等于当前 id 并小于右侧邻居的 id&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将上面找出的那一页数据读入内存，重复上面的比对操作，直到找到最底层的那个数据页&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将数据页读入内存，找出&lt;code&gt;id=6&lt;/code&gt;索引下下挂的全部数据，就是这一行数据&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;InnoDB 数据插入测试&lt;/h2&gt;&lt;p&gt;下面我们针对 InnoDB 搞一次数据插入测试，希望能够窥探到 InnoDB 索引页“再平衡”的具体操作，追踪索引扩层的具体动作，确定&lt;code&gt;id|页号&lt;/code&gt;中页号的数据长度，并顺便解决一下“2000w 行分表”问题的历史悬案。&lt;/p&gt;&lt;h3&gt;神奇的“2000W 行分表”历史悬案&lt;/h3&gt;&lt;p&gt;相信大家都听说过“单表到了 2000 万行就需要分表了”，甚至有人还看过“京东云开发者”的那篇著名的文章¹，但是那篇文章为了硬凑 2000 万搞出了很多不合理的猜想。&lt;/p&gt;&lt;p&gt;下面我们实际测试一下 MySQL 8.0.28 运行在 CentOS Stream release 9 上（文件系统为 ext4），索引层数和数据行数之间的关系，相信测试完以后，你会对这个问题有深刻的理解。&lt;/p&gt;&lt;h3&gt;测试准备&lt;/h3&gt;&lt;p&gt;测试表结构如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;CREATE TABLE `index_tree` (&lt;br/&gt;  `id` int unsigned NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `s1` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s1&#x27;,&lt;br/&gt;  `s2` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s2&#x27;,&lt;br/&gt;  `s3` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s3&#x27;,&lt;br/&gt;  `s4` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s4&#x27;,&lt;br/&gt;  PRIMARY KEY (`id`)&lt;br/&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们采用不可变长度的 char 来进行测试，根据 MySQL 8.0 关于 CHAR 和 VARCHAR 类型的官方文档²，当我们只保存&lt;code&gt;s1&lt;/code&gt;这种 ASCII 字符时，一行数据的长度很容易就可以计算出来：4 + 255 + 255 + 255 + 255 = 1024 字节&lt;/p&gt;&lt;h3&gt;ibd 结构探测工具&lt;/h3&gt;&lt;p&gt;我们采用阿里巴巴开源的&lt;code&gt;MySQL InnoDB Java Reader&lt;/code&gt;³来窥探 ibd 内部所有页的情况，主要是看他们的层级。&lt;/p&gt;&lt;h3&gt;开始插入数据&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24774774774774774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOrh3T23B0p9UcjoPMv4W0GSAJJ4n73s1I6jaswoKj5hQTAFZIYl4hvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;444&quot;/&gt;&lt;/p&gt;&lt;p&gt;在只插入了一行数据时，窥探结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;=====page number, page type, other info=====&lt;br/&gt;0,FILE_SPACE_HEADER,space=1289,numPagesUsed=5,size=7,xdes.size=1&lt;br/&gt;1,IBUF_BITMAP&lt;br/&gt;2,INODE,inode.size=4&lt;br/&gt;3,SDI&lt;br/&gt;4,INDEX,root.page=true,index.id=4605,level=0,numOfRecs=1,num.dir.slot=2,garbage.space=0&lt;br/&gt;5,ALLOCATED&lt;br/&gt;6,ALLOCATED&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5875420875420876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOt7wFQ9FuGPBeiaob9kOdLmx35xVq5W1ZOqHCeeCFSBL0D9PbIGNrp5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1188&quot;/&gt;&lt;/p&gt;&lt;center&gt;一层索引下的页结构图（1 行数据）&lt;/center&gt;&lt;p&gt;此时&lt;code&gt;index_tree.ibd&lt;/code&gt;文件的尺寸为 112KB。&lt;/p&gt;&lt;h4&gt;1. 首次索引分级&lt;/h4&gt;&lt;p&gt;我们继续插入数据，在插入了第 15 行后，这个 idb 文件从 1 页分裂成了 3 页：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;=====page number, page type, other info=====&lt;br/&gt;0,FILE_SPACE_HEADER,space=1289,numPagesUsed=7,size=8,xdes.size=1&lt;br/&gt;1,IBUF_BITMAP&lt;br/&gt;2,INODE,inode.size=4&lt;br/&gt;3,SDI&lt;br/&gt;4,INDEX,root.page=true,index.id=4605,level=1,numOfRecs=2,num.dir.slot=2,garbage.space=0&lt;br/&gt;5,INDEX,index.id=4605,level=0,numOfRecs=7,num.dir.slot=3,garbage.space=7350&lt;br/&gt;6,INDEX,index.id=4605,level=0,numOfRecs=8,num.dir.slot=3,garbage.space=0&lt;br/&gt;7,ALLOCATED&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4305555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOMicTQBmNj0m9FrGEJH3P7mbqqBngHROh44ib5lr5unicVQkjf2FguSQvw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2016&quot;/&gt;&lt;/p&gt;&lt;center&gt;二层索引下的页结构图（15 行数据）&lt;/center&gt;&lt;p&gt;我们能够看出，本来这 14 条数据都是在初始的那个 4 号页内部储存的，即数据部分至少有&lt;code&gt;1024*14=14KB&lt;/code&gt;的容量，在插入第 15 条数据迈向 15KB 的时候，innodb 发了页的分级：B+ 树分出了两级，顶部为一个索引页 4，底部为两个数据页 5 和 6，5 号页拥有 7 行数据，6 号页拥有 8 行数据。这说明每一页可用的数据容量为&lt;code&gt;14kB - 15KB&lt;/code&gt;之间。&lt;/p&gt;&lt;p&gt;而且，从&lt;code&gt;garbage.space&lt;/code&gt;可以看出，5 号页是之前那个唯一的 4 号页，而新的 4 号页和 6 号页则是本次分级的时候新建的。&lt;/p&gt;&lt;p&gt;下面让我们继续插入数据，看它什么时候能从二层增长为三层。&lt;/p&gt;&lt;h4&gt;2. 二层转换为三层&lt;/h4&gt;&lt;p&gt;我以 500 为步长批量插入数据，在 16500 行的时候，还是二层：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;=====page number, page type, other info=====&lt;br/&gt;0,FILE_SPACE_HEADER,space=1292,numPagesUsed=37,size=1664,xdes.size=22&lt;br/&gt;1,IBUF_BITMAP&lt;br/&gt;2,INODE,inode.size=4&lt;br/&gt;3,SDI&lt;br/&gt;4,INDEX,root.page=true,index.id=4608,level=1,numOfRecs=1180,num.dir.slot=296,garbage.space=0&lt;br/&gt;5,INDEX,index.id=4608,level=0,numOfRecs=7,num.dir.slot=3,garbage.space=7350&lt;br/&gt;6,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;7,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;8,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;9,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是当表长度来到 17000 的时候，已经是三层了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;=====page number, page type, other info=====&lt;br/&gt;0,FILE_SPACE_HEADER,space=1292,numPagesUsed=39,size=1728,xdes.size=22&lt;br/&gt;1,IBUF_BITMAP&lt;br/&gt;2,INODE,inode.size=4&lt;br/&gt;3,SDI&lt;br/&gt;4,INDEX,root.page=true,index.id=4608,level=2,numOfRecs=2,num.dir.slot=2,garbage.space=0&lt;br/&gt;5,INDEX,index.id=4608,level=0,numOfRecs=7,num.dir.slot=3,garbage.space=7350&lt;br/&gt;6,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;7,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;&lt;br/&gt;... ...&lt;br/&gt;&lt;br/&gt;36,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;37,INDEX,index.id=4608,level=1,numOfRecs=601,num.dir.slot=152,garbage.space=7826&lt;br/&gt;38,INDEX,index.id=4608,level=1,numOfRecs=614,num.dir.slot=154,garbage.space=0&lt;br/&gt;39,ALLOCATED&lt;br/&gt;40,ALLOCATED&lt;br/&gt;... ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3683469445226697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOiaqOv3dHkXnGB7qBS90D5WYM1sZ8BISrBezVdmGTT7BN5fwMg0pOEHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3551&quot;/&gt;&lt;/p&gt;&lt;center&gt;三层索引下的页结构图（17000 行数据）&lt;/center&gt;&lt;p&gt;此时，&lt;code&gt;index_tree.ibd&lt;/code&gt;文件的尺寸为 27MB。&lt;/p&gt;&lt;p&gt;在整颗 B+ 树从二层转换为三层的过程中，只修改了三个页：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;将目前唯一的索引页 4 号的数据复制到 37 号页中，level 保持不变（此时 37-63 号已经被提前&lt;code&gt;ALLOCATED&lt;/code&gt;出来用作备用页了）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将 38 号页初始化成一个新的 level=1 的索引页，并将左侧 37 号页右边一半的页指针转移给 38 号页，再删除 37 号页中的原指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重新初始化 4 号页，设置为顶层(level=2)索引页，创建两个页指针：第一个指向 37，第二个指向 38&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;为什么是 17000 行呢？我们来计算一下二层索引的极限容量：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;已知一个最底层(level=0)的数据节点可以存储 14 条数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;假设索引页内部的一个页指针的长度是&lt;code&gt;4+8=12&lt;/code&gt;字节，那 2 层索引的极限就是：&lt;/p&gt;&lt;p&gt;(14 &lt;em&gt;1024 / 12)&lt;/em&gt; 14 = 16725.33&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;和实测值完美契合！&lt;/p&gt;&lt;p&gt;此时计算可知，一个索引页至少可以存储&lt;code&gt;14 * 1024 / 12=1194.66666666&lt;/code&gt;个页指针。&lt;/p&gt;&lt;h4&gt;3. 三层转换为四层&lt;/h4&gt;&lt;p&gt;继续向 index_tree 表中批量插入数据，在数据继续分层之前，整棵树的结构保持不变，只是会不断增加 level=0 和 level=1 的页的数量。&lt;/p&gt;&lt;p&gt;但当行数来到了 21427000 行时，索引就从 3 层转换为了 4 层了，此时磁盘 ibd 文件为 24GB，探测结果如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;=====page number, page type, other info=====&lt;br/&gt;0,FILE_SPACE_HEADER,space=1292,numPagesUsed=4,size=1548032,xdes.size=256&lt;br/&gt;1,IBUF_BITMAP&lt;br/&gt;2,INODE,inode.size=4&lt;br/&gt;3,SDI&lt;br/&gt;4,INDEX,root.page=true,index.id=4608,level=3,numOfRecs=2,num.dir.slot=2,garbage.space=0&lt;br/&gt;5,INDEX,index.id=4608,level=0,numOfRecs=7,num.dir.slot=3,garbage.space=7350&lt;br/&gt;6,INDEX,index.id=4608,level=0,numOfRecs=14,num.dir.slot=4,garbage.space=0&lt;br/&gt;&lt;br/&gt;... ...&lt;br/&gt;&lt;br/&gt;1424021,INDEX,index.id=4608,level=2,numOfRecs=601,num.dir.slot=152,garbage.space=7826&lt;br/&gt;1424022,INDEX,index.id=4608,level=2,numOfRecs=672,num.dir.slot=169,garbage.space=0&lt;br/&gt;... ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由此可知，索引结构是这样的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1 个 4 层(level=3)索引页，含有 2 个 3 层索引页的指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2 个 3 层(level=2)索引页，其中左侧的 1424021 号页有 601 个底层数据页的指针，右侧的 1424022 号页有 672 个底层数据页的指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;601+672=1273&lt;/code&gt;个 2 层索引页，每页含有 1194+ 个底层数据页的指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;21427000/14=1530500&lt;/code&gt;个底层数据页，每页含有 14 条数据&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;转换的过程中，哪些页需要更新数据呢？还是只需要修改三个页：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;需要将 4 号页(旧顶层页)的数据拷贝到 1424021 号页(新 level=2 左)中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;新生成 1424022 号页(新 level=2 右)，将 1424021 号页(新 level=2 左)内部右侧的 672 个页指针(&lt;code&gt;id|页号&lt;/code&gt;)复制到 1424022 号页中，并删除 1424021 号页中的原指针&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重新初始化 4 号页，创建两个页指针：第一个指向 1424021，第二个指向 1424022&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;再增加一层需要再插入 1200 倍的数据，我们就不测试了，28TB 的磁盘阵列我也没有╮(╯▽╰)╭&lt;/p&gt;&lt;h3&gt;计算页指针&lt;code&gt;id|页号&lt;/code&gt;的大小&lt;/h3&gt;&lt;p&gt;无论是中文技术文章还是英文技术文章，我甚至还查了 MySQL 8.0 InnoDB 的官方文档，并没有说“页号”的大小，甚至对于&lt;code&gt;id&lt;/code&gt;的大小都没有一个统一的说法。下面我们尝试自己算出来：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在 14-15 之间一层索引转换成了二层索引，所以页可用容量最大值&lt;code&gt;1024 * 15 = 15360&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最小值&lt;code&gt;1024 * 14 = 14336&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在 16500-17000 之间二层索引转换成了三层索引，对应的索引数最大值为&lt;code&gt;17000 / 14 = 1214.28&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;索引数最小值为&lt;code&gt;16500 / 14 = 1178.57&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们拿最大值除以最小值，得到 &lt;code&gt;15360 / 1178.57 = 13.03&lt;/code&gt;字节，拿最小值除以最大值，得到 &lt;code&gt;14336 / 1214.28 = 11.81&lt;/code&gt;字节，所以我们可以得出结论:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;单个&lt;code&gt;id|页号&lt;/code&gt;的大小应该为 12 字节或者 13 字节&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;接下来怎么确定呢？再拿 bigint 做一遍测试就行了。&lt;/p&gt;&lt;h3&gt;使用 bigint 确定页号的大小&lt;/h3&gt;&lt;p&gt;我们建立一个名叫&lt;code&gt;index_tree_bigint&lt;/code&gt;的表：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;CREATE TABLE `index_tree_bigint` (&lt;br/&gt;  `id` bigint unsigned NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `s1` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s1&#x27;,&lt;br/&gt;  `s2` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s2&#x27;,&lt;br/&gt;  `s3` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s3&#x27;,&lt;br/&gt;  `s4` char(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT &#x27;s4&#x27;,&lt;br/&gt;  PRIMARY KEY (`id`)&lt;br/&gt;) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;单行数据的容量从 1024 上升到了 1028。&lt;/p&gt;&lt;p&gt;按照同样的流程进行测试，可以发现还是 14 到 15 条的时候发生的一层转换到两层，从 12500 到 13000 条时从二层转换到了三层，我们使用同样的方法进行计算：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;1028 * 15 / ( 12500 / 14 ) = 17.27&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;1028 * 14 / ( 13000 / 14 ) = 15.50&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;主键采用 bigint 类型时，单个&lt;code&gt;id|页号&lt;/code&gt;的大小应该为 16 字节或者 17 字节。&lt;/p&gt;&lt;h4&gt;得出结论：“页号”为 8 字节&lt;/h4&gt;&lt;p&gt;由于页号采用奇数长度的概率非常低，我们可以得出一个十分可信的结论：在 MySQL 8 中，id 的长度和类型有关：&lt;code&gt;int&lt;/code&gt;为 4 字节，&lt;code&gt;bigint&lt;/code&gt;为 8 字节，“页号”的长度为 8 字节。则单个&lt;code&gt;id|页号&lt;/code&gt;的大小应该为 12 字节或者 16 字节。&lt;/p&gt;&lt;h2&gt;解答“2000W 行分表”问题&lt;/h2&gt;&lt;h3&gt;真实世界数据长度以及它的 4 层极限&lt;/h3&gt;&lt;p&gt;看了一眼我司生产数据库，电商业务的常用大表“订单商品表”，实际单行数据长度为&lt;code&gt;0.9KB&lt;/code&gt;，和我们做测试的 1KB 差别不大，所以上面的测试结果还是很符合现实世界的真实情况的。&lt;/p&gt;&lt;p&gt;我们取如下几个值来计算 3 层到 4 层的理论极限：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;单页可用数据容量 14KB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单行数据 0.9KB，所以每页最多可以存储&lt;code&gt;14/0.9=15.5555&lt;/code&gt;，取整为 15 行数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;主键类型采用&lt;code&gt;int&lt;/code&gt;，页指针长度为 12 字节，所以每页最多可以存储&lt;code&gt;14*1024/12=1194.6666&lt;/code&gt;，取整为 1194 个页指针&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;则三层 B+ 树的理论极限为：&lt;code&gt;1194^2 * 15 = 21384540&lt;/code&gt;，大约 2100 万行，还是蛮符合 2000W 行分表的传说的。&lt;/p&gt;&lt;h4&gt;四层到五层呢？&lt;/h4&gt;&lt;p&gt;而如果需要五层，则行数需要达到 &lt;code&gt;1194^3 * 15 = 25533140760&lt;/code&gt;，即 255 亿行，这个数字已经超过了 unsigned int 的上限 42 亿多，需要用 bigint 来做主键了，感兴趣的可以自行计算 bigint 下五层索引甚至是六层七层八层的行数极限，我在此不再赘述。&lt;/p&gt;&lt;h3&gt;2100w 行以后，真的会发生性能极速劣化吗？并不会!&lt;/h3&gt;&lt;blockquote&gt;&lt;h4&gt;三层索引和四层索引的性能并没有什么不同，2000W 行分表已经过时了！&lt;/h4&gt;&lt;/blockquote&gt;&lt;p&gt;其实，每一次 B+ 树增高，都只会增加两个索引页，修改一个索引页，加起来只修改了三个 16KB 的数据页，无论是磁盘 IO 还是 Buffer Pool 缓存失效，对性能的影响都微乎其微：&lt;/p&gt;&lt;p&gt;索引从三层转换到四层，只增加了一次 IO，绝对性能降低幅度的理论极限只有&lt;code&gt;1/3&lt;/code&gt;，而且在有 Buffer Pool 存在的情况下，性能差异微乎其微，只增加了&lt;code&gt;1~2&lt;/code&gt;次比大小的计算成本。&lt;/p&gt;&lt;h3&gt;那是否意味着不需要再分表了呢？&lt;/h3&gt;&lt;p&gt;虽然三层索引和四层索引看起来性能差异不大，但是如果你的单行数据比较大，例如达到了 5KB，还是建议做一下&lt;code&gt;横向分表&lt;/code&gt;的，这才是效果最立竿见影的减少磁盘 IO 次数的优化方法：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;单行数据为 0.9KB 时，三层树的极限行数是 2100 万，但是如果单行数据来到 5KB，那这个极限会变成 285 万行，这可能就不太够了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据页拥有局部性：每次从磁盘读取都是一整页的数据，所以读取某一行数据以后，它 id 附近的数据行也已经在内存缓存里了，读取性能十分优异&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在连续读取多行时（例如全表条件查询），巨大的单行数据将在让“局部性”优势迅速丧失的同时，会引发磁盘 IO 次数出现数量级规模的上升，这就是单行数据比较大的表读取起来感觉格外慢的原因&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;到底该何时分表？&lt;/h3&gt;&lt;p&gt;2017 年发布的阿里巴巴 Java 开发手册中写道“单表行数超过 500 万行或者单表容量超过 2 GB ，才推荐进行分库分表”，被很多技术博文写成了：阿里巴巴推荐超过 500 万行的表进行分表，这种理解是错误的。&lt;/p&gt;&lt;p&gt;虽然经过我的实测，在每行数据定长 1024 字节，Buffer Pool 配置为 22GB，在单表体积 24GB 的情况下，四层索引和三层索引并没有任何性能差异，但是现实世界中的数据表可不是这么严丝合缝：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;为了节约空间和保持扩展性，绝大多数短字符串类型采用的是 varchar 而非定长的 char，这就让 level=0 的每一页包含的数据行数不一致，这会让这颗“平衡多路查找树”不怎么平衡&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;生产表经常面临数据删除和更新：同层的页之间的双向链表和不同层页之间的单向指针都需要经常变化，同样会让这棵树变的不平衡&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一张表使用的越久，ibd 文件中的碎片就越多，极端情况下（例如新增 10 行删除 9 行）会让数据页的缓存几乎失效&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;磁盘上单文件体积过大，不仅在读取 IOPS 上不如多文件，还会引发文件系统的高负载：单个文件描述符也是一种&lt;code&gt;单点&lt;/code&gt;，大文件的读写性能都不太行，还容易浪费大量内存&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;那么，该如何回答“到底该何时分表”这个问题呢？很遗憾并没有一个放之四海皆准的答案，这和每个表的读取、新增、更新的具体情况是分不开的。&lt;/p&gt;&lt;p&gt;虽然在数据库技术层面我们无法给出何时分表的答案，但是从软件工程层面我们可以得出一个结论：&lt;/p&gt;&lt;h4&gt;能不分就不分，不到万不得已不搞分表，如果能靠加索引或者加内存来解决就不要考虑分表，分表会对业务代码造成根本性的影响，会产生长久的技术债务。&lt;/h4&gt;&lt;p&gt;B+ 树和分表的问题我们就讨论到这里，下面我们简单分析一下 Buffer Pool 的设计思想和运行规律。&lt;/p&gt;&lt;h2&gt;内存缓存 Buffer Pool&lt;/h2&gt;&lt;p&gt;Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认为 128MB，强烈建议任何一台 MySQL 服务器都根据自己的机器资源情况，增大配置的内存值，这玩意儿能把 MySQL 的性能提升多个数量级。&lt;/p&gt;&lt;h3&gt;缓存池的大小&lt;/h3&gt;&lt;p&gt;缓存池的大小由&lt;code&gt;innodb_buffer_pool_size&lt;/code&gt;参数来管理，一般建议大家设置成系统可用内存的 75%，但是根据我的经验，对于普通的“冷热均衡”的数据库这样是合理的，因为热数据较少，但是如果你需要在短时间内（如几天）普遍地读写几乎所有表的所有数据，那这个比例最好设置在 50% 附近，否则在运行一段时间后将会爆内存（OOM 错误），MySQL 进程会被杀掉。&lt;/p&gt;&lt;h3&gt;缓存池的基本结构&lt;/h3&gt;&lt;p&gt;缓存池和磁盘数据一样，分为一个又一个 16KB 的页来进行管理。除了缓存“索引页”和“数据页”，缓存池里面还有 undo 页，插入缓存、自适应哈希索引、锁信息等。&lt;/p&gt;&lt;p&gt;虽然缓存池已经在内存中了，但是既然缓存池是一组 16KB 的页，那它就需要一个额外的内存索引来保存每一页的表空间、页号、缓存页地址、链表节点信息，这个结构叫控制块。N 个控制块和 N 个 16KB 数据页连在一起就是 Buffer Pool 占据那一段连续内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24324324324324326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOQeuNhDa2Qwxs85aYibXXnAficJy82kiavbx8EuFV9Ruh5NyOyde1Aic71A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;962&quot;/&gt;&lt;/p&gt;&lt;h3&gt;引入缓存池后，数据如何读写&lt;/h3&gt;&lt;p&gt;缓存池中的 16KB 页是和磁盘上的页一一对应的，这就带来了读写两个方向的改变：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读数据时，如果该页已经在内存中了，则无需再浪费一次磁盘 IO。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写数据时，会直接将数据写入缓存中的页（不影响之后的读取），并在成功写入 redo log 之后返回成功。同时会将该页设置为脏页，等待后台进程将数据真正写入磁盘。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;缓存池 LRU 算法&lt;/h3&gt;&lt;p&gt;除了控制块和数据页，Buffer Pool 中还存在着管理空闲页的&lt;code&gt;free 链表&lt;/code&gt;和管理脏页的&lt;code&gt;flush 链表&lt;/code&gt;，我们不再深入了解。&lt;/p&gt;&lt;p&gt;但是，管理缓存生命周期的 LRU 算法我们不能放过，必须狠狠地了解它一下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6037234042553192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA04Kb3xyeL15u0Yrjnu3cPOFdrxPkGC3DNON7ogwibc77qw0YNHHpdWtDJnUO5lCNbicXzQibPaZMY6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;376&quot;/&gt;&lt;/p&gt;&lt;center&gt;LRU 链表&lt;/center&gt;&lt;p&gt;传统的 LRU 算法只用一个链表就实现了“移动至头部”和“淘汰尾部”两个操作，什么 InnoDB 非要搞一个变体呢？还是因为 B+ 树：由于底层数据的非连续性，导致 Buffer Pool 会遇到两个比较严重的问题：预读失效和缓冲池污染。&lt;/p&gt;&lt;h4&gt;预读失效&lt;/h4&gt;&lt;p&gt;预读失效很容易理解，因为预读本质上是基于局部性对需求的一种预估，正常的 SQL 并不能保证每一条取出的数据都是大概集中的，例如取性别为女的用户，就需要跳着走完全表，预读失效非常正常。&lt;/p&gt;&lt;p&gt;LRU 链表将数据分为&lt;code&gt;新生代&lt;/code&gt;和&lt;code&gt;老生代&lt;/code&gt;两个区域，分别占据&lt;code&gt;5/8&lt;/code&gt;和&lt;code&gt;3/8&lt;/code&gt;的内存空间，预读时只插入老生代的头部，同时老生代尾部元素会被淘汰。当数据真的被读取时，这一页会被立刻转移到新生代的头部，并且会挤出去一个新生代尾部的元素进入老生代的头部，数据还在缓存中。&lt;/p&gt;&lt;p&gt;不知道大家发现了没有，这的操作的本质是给 LRU 算法加了一层 LRU 算法，减小了缓存粒度。&lt;/p&gt;&lt;h4&gt;缓冲池污染&lt;/h4&gt;&lt;p&gt;这个问题是非常符合本文主旨的一个问题：由于磁盘数据库拥有极大的体量，相比之下内存容量却十分捉襟见肘，所以在用内存来做磁盘缓存时，一旦需求不满足局部性，缓存会被迅速劣化：当一条 SQL 需要扫描海量的数据页时，其它表用得好好的热数据嘎的一下就被清出内存了，结果就是磁盘 IO 数量突然增加，系统崩溃。&lt;/p&gt;&lt;p&gt;于是 InnoDB 给“数据被读取时，这一页会从老生代转移到新生代的头部”这个操作加了个条件：在老生代里面待的时间要足够久。&lt;/p&gt;&lt;p&gt;这里面有两个点非常巧妙：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;改变的是“转移页操作”所需要的条件，而且这个条件(即留存时间)的判断非常简单，只需要在加入老生代的时候增加一个时间戳就行，4 个字节，除此之外无需任何维护&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用时间而不是次数来做限制，更加符合数据库的最终用户——人的真实需求。读取次数可能因为技术原因而增加，时间不会。没有无缘无故的爱，更没有无缘无故的读取。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;Buffer Pool 应该怎么优化&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内存配置的越大越好：多一倍的内存，比多一倍的 CPU 更能提高数据库性能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;减少对冷数据的随机调用：优化定时任务和队列的业务代码，避免这种情况&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在大批量执行小修改的时候、尽量自己控制事务：由于 InnoDB 底层的数据隔离机制，让它的每一个写动作都是一个事务，所以如果你要在一次会话中写多行数据，最好自己控制事务，可以显著减少对缓冲池的影响以及磁盘 IO 数量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;避免修改主键：修改主键的值会带来大量的数据移动，磁盘会不堪重负，缓存会疯狂失效&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;一万字多的 InnoDB 详解文章终于完成了，下一篇文章我们将在本文的基础上，讨论数据库的拆单点方案：Shared-Nothing、计算存储分离、Paxos、KV、列存储与微服务架构，由浅入深，由软件架构到存储引擎再到系统架构，把整个系统的性能搞上去，让数据库能够真正支撑得住一百万 QPS 的 web 系统。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;mysql 最大建议行数 2000w, 靠谱吗？https://my.oschina.net/u/4090830/blog/5559454&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The CHAR and VARCHAR Types https://dev.mysql.com/doc/refman/8.0/en/char.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MySQL InnoDB Java Reader https://github.com/alibaba/innodb-java-reader&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;肯定有人想问，前面七篇文章呢？别急，除了前面七篇，后面还有两篇呢。关注我，美好的文章即将推送~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf511da0e4a845f24998a2b1f5417266</guid>
<title>Google 如何写设计文档</title>
<link>https://toutiao.io/k/mwpqnxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;作者：&lt;/span&gt;&lt;span&gt;Malte是Vercel的&lt;/span&gt;&lt;span&gt;CTO&lt;/span&gt;&lt;span&gt;&lt;span&gt;。在此之前，&lt;/span&gt;Malte是负责谷歌搜索渲染的首席工程师，以及Search on Laptops, Tablets, &lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Desktop的工程总监。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;译者，许晓斌，现任阿里巴巴资深技术专家，《&lt;/span&gt;Maven实战》作者&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文获得作者和译者授权，在技术琐话公开发布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google 软件工程文化中关键元素之一，是使用设计文档来定义软件设计。这些文档通常不是非常正式，主要是软件系统或应用程序的作者在着手写代码之前编写的。这些设计文档记录了 high-level 的实现策略和关键的设计决策，而后者重点描述了决策过程中思考的权衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为软件工程师，我们的工作并不是生产代码本身，而是解决问题。非结构化的文本，例如以设计文档的形式，在项目早期或许是解决问题更适宜的工具。因为设计文档可能更简明、更容易被理解，相比代码能在更高的层面沟通问题及解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了用作软件设计的原始文档记录，设计文档还在软件研发生命周期中实现了下述功能：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;在修改成本还比较低的时候，尽早地识别设计缺陷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;在组织中围绕设计达成共识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;确保横切关注点（&lt;/span&gt;&lt;span&gt;&lt;span&gt;Cross-cutting concern&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）得到充分考虑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;在组织中传播资深工程师的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;就设计决策形成组织记忆基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;成为软件设计者技术资产中的一个摘要性制品。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1. 设计文档的构成&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;设计文档是非正式的文档，因此其内容不需要遵循严格的准则。因此首要原则就是：在特定的项目中，用任何最合理的形式编写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在此原则之外，&lt;/span&gt;Google 也建立了一种颇有效果的设计文档结构。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.1 上下文和范围（Context and scope）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这一小节给读者展现一个有关这个系统在哪里被构建，以及什么会被构建的非常粗的概览。这不是需求文档。保持言简意赅！这里的目标是让读者快速进入状态，可以假设读者知道一些前置的知识，相关详情可以给到链接。这一节内容应该完全关注在客观的背景事实。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.2 目标和非目标（Goals and non-goals）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;给出一个简单的列表，讲述系统的目标是什么。有时候更重要的是讲述非目标是什么。注意，非目标不是对目标的否定，例如&lt;/span&gt;&lt;span&gt;“系统不应该 crash”，而是显示地挑选出来的不是目标的内容。一个好的例子是 “遵循 ACID”，当设计一个数据库的时候，你必然想要知道这是目标还是非目标。进一步的，你仍然可以选择一个方案来实现非目标，只要它不会给实现目标带来不必要的权衡。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.3 实际设计（The actual design）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这一部分应该以一个概述开头，然后逐渐展开细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.815&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWGz1l3vGx0LlLlP3O0icuaZmAekqJYRytPeuBUuJFBy1Ticcia2sQUHCCddL0mZpqR0ffc437VYyHp6Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;设计是文档是在你设计软件的过程中，&lt;/span&gt;&lt;em&gt;&lt;span&gt;记录设计取舍的地方&lt;/span&gt;&lt;/em&gt;&lt;span&gt;。应该关注这些取舍，以产出一个具备长期价值的文档。具体就是，在既定的上下文（事实），目标和非目标（需求）下，设计文档应该提出解决方案，并阐明为什么某个特定的解决方案是满足这些目标的最佳方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相较于更为正式媒体形式，编写文档的意义在于可以用合适的方式灵活地表述手头的问题集合。因此，如何描述设计并没有显式的指引。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;话虽如此，对于大多数设计文档来说，一些最佳实践和重复出现的主题还是有意义的：&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.3.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;系统上下文图（&lt;/span&gt;System-context-diagram）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于很多文档来说，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;系统上下文图&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;是很有用的。这类图展示了当前系统是更大技术图景的一部分，能让读者在一个他们已经熟悉的上下文环境中去理解新的设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5092707045735476&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;809&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWGz1l3vGx0LlLlP3O0icuaZmELpnvW79vXIPibvTQmQyGfuWKXib3AKVlQ4Soa2OmZeqM3akiaBocKpMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;系统上下文图的例子&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.3.2 APIs&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果设计的系统会暴露&lt;/span&gt; API，那么草拟出 API 通常是好想法。不过，在大多数情况，我们应该克制住把正式接口和数据定义复制粘贴到文档中的冲动，因为这么做会导致文档过于冗长，包含不必要的细节，并很快过期。相对应的，我们应当关注和设计及取舍相关的那部分 API。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.3.3 数据存储（Data storage）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;需要存储系统的系统应该讨论数据是如何以何种形式，如何被存储的。和前面描述&lt;/span&gt; API 的建议一样，基于相同的理由，应该避免复制粘贴完整的 schema 定义，正确的做法是关注在那些和设计取舍相关的部分。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.3.4 代码和伪代码（Code and pseudo-code）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;设计文档应当很少包含代码或伪装代码，除非有一些情况需要描述新的算法。合理的做法是给到设计原型实现的链接。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1.3.5 约束条件（Degree of constraint）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;软件设计形态（因此设计文档）的主要影响因素是解决方案空间（&lt;/span&gt;solution space）中的约束条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;一个方向的极端情况是&lt;/span&gt; &lt;span&gt;“绿地软件项目（greenfield）”，在这种情况下我们知道所有的目标，解决方案只要是合理的，没什么限制。这样的文档可能就会显得很宽泛，但是也应该快速定义一组规则，以便让大家尽快把目光收敛到一组可控的解决方案中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个方向的极端情况是，所有可能的解决方案都被定义得很清楚了，但是如何把它们结合起来以达成目标，却毫不清晰。这往往是因为遗留系统难以改动，或者遗留系统不是被设计用来解决当前所面临的问题的，又或者是一个类库的设计要求我们在它的宿主编程语言限制下工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这种情况下，你或许可以遍历所有可行的简单方法，但更需要创新地把所有这些方法整合起来以完成目标。也许存在多种方案，每一种方案都不是特别出色的，因此文档应该关注在如何从已经识别的各项取舍中，选择最合适的方案。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.4 候选设计（Alternatives considered）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这一小节列出那些同样可以实现类似产出的可选设计。这里关注的应该是各种方案各自的取舍，以及这些取舍的对比如何引向最终的设计&lt;/span&gt; &lt;span&gt;—— 文档的核心主题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然描述候选设计可以简洁一些，但是这一小节实际上非常核心的，因为这里非常清晰地展示了，在给定的项目目标和所有可选方案下，为什么&lt;/span&gt;&lt;strong&gt;&lt;span&gt;选择&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;了最终方案，在给定目标下权衡的判断是如何做出的，而这正是文档的读者所关注的核心。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.5 横切关注点（Cross-cutting Concerns）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在这里组织可以确保一些横切关注点如安全，隐私，可观测性，总是被考虑到。这部分内容通常相对较短，只是用来解释设计会如何影响到横切关注点，以及相关影响如何得到解决。团队应该标准化在他们场景下的关注点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如，由于隐私非常重要，&lt;/span&gt;Google 的项目就必须写一个专门的隐私设计文档，这个文档会别专门用来 Review 隐私和安全。虽然 Review 只要在项目启动前完成，但通常最好是尽早让隐私和安全团队介入，确保设计从一开始就重视他们的意见。关于这部分内容更专门的细节，核心文档不一定要全部包含，有时候给到这些专门文档的引用即可。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1.6 设计文档的长度（The length of a design doc）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;设计文档应该具备充分的细节，但同时足够简短以能够被忙碌的人阅读。对于一个大型项目来说，最佳的长度似乎是&lt;/span&gt; 10 到 20 页。如果你的内容超过这个大小，更合理的做法可能是把这个问题划分成更易管理的子问题。当然，需要注意的是，编写 1-3 页的“迷你设计文档”完全是可能的。这类文档对于敏捷项目中的增量改进或者子任务尤其有用 —— 但你仍然需要和编写长文档一样执行一样的步骤，区别只是让内容更精炼，并且只关注有限的问题集合。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. 什么时候不要编写设计文档（When not to write a design doc）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;编写设计文档是需要成本的。关于是否编写设计文档的决定，实际上是在做权衡。权衡的一边是围绕设计、文档、高层评审等工作形成组织共识的益处，权衡的另一边是这块工作投入的精力成本。决策的核心在于设计问题的解决方案是否模糊&lt;/span&gt; &lt;span&gt;—— 这往往是因为问题复杂度，或者解决方案的复杂度引起的（或者两者皆有）。如果不存在这个问题，那么走一个设计文档编写的流程价值就有限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计文档可能没有必要的一个明显征兆是：设计文档实际上是&lt;/span&gt;&lt;em&gt;&lt;span&gt;实现手册&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;。如果文档基本上说的是&lt;/span&gt;&lt;span&gt;“这是我们将如何实现之”，而没有深入讨论取舍、可选方案、没有解释决策（或者说解决方案太明显了以致于没什么取舍可讨论），那么很有可能直接编写真实代码是更好的选择。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，创建和评审设计文档的投入可能与快速制作原型并迭代理念并不相容。但是大多数软件项目都是有一组&lt;/span&gt;&lt;em&gt;&lt;span&gt;实际上已知的问题&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt;。拥抱敏捷方法不应该成为不花时间去寻找已知问题正确解决方案的借口。此外，原型本身可能就是创建设计文档过程的一部分。&lt;/span&gt;&lt;span&gt;“我试过了，这么做可行” 就是选择一种设计最好的论据之一。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;3. 设计文档的生命周期（The design doc lifecycle）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一份设计文档的生命周期包括如下阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;创建和快速迭代&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;审查（可能有多轮）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;实现和迭代&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.&lt;/span&gt;&lt;span&gt;维护和学习&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.1 创建和快速迭代（Creation and rapic iteration）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;你编写文档，有时候是和几个合作者一起编写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这一阶段快速演进成为快速迭代的时期，文档被分享给一些同事，他们拥有关于问题空间（&lt;/span&gt;problem space）的最多的知识（通常属于同一个团队），通过他们不断澄清问题并提出建议，文档逐渐形成第一个相对稳定的版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你会发现很多工程师和团队更偏向于使用版本控制和代码审查工具来管理文档，但是&lt;/span&gt; Google 的大多数文档是使用 Google Docs 创建的，并重度使用了协作特性。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;评审&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;（&lt;/span&gt;Review）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在评审阶段，设计文档被分享给原始作者和紧密协作者之外更广范的一批受众。评审可以给文档增加很多价值，但是也有可能是危险的投入成本陷阱，因此要明智对待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;评审可以有很多形式：最轻量的版本就是简单把文档发给更大范围的团队，让大伙有机会可以看一眼。随着而来的讨论主要就发生在文档的评论区。而形式较重的评审，就是发起正式的设计文档评审会议，在会议中作者面向通常是较为资深的工程师听众演示文档（通常是专门的演示）。&lt;/span&gt;Google 有很多团队为此目的排了周期性的会议，工程师可以注册用来发起设计评审。自然的，等待此类会议来评审设计文档会大幅降低研发速度。工程师可以通过直接向同事获取最关键的反馈，同时也不阻塞更广泛的评审，进而降低这一风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt; Google 是一个小一些的公司的时候，大家习惯上会把设计发到一个中心的邮件列表中，在这里资深的工程师会抽空进行评审。这种方式对公司来说可能就不错。这种方式一大好处是，它在整个公司层面建立了一种相对一致的软件设计文化。但是随着公司逐渐增长细形成一个较大的工程师团队，维护这种中心化的方法就不可行了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计评审增加的主要价值是，它形成了一个让组织的综合经验可以融合到设计中的机会。如何让设计能够充分考虑横切关注点如可观测性、安全性、以及隐私，这一点就能够非常一致地在评审阶段得到保障。评审的主要价值不是问题被发现本身，而是让问题在软件研发阶段相对早期的时候，也就是修复成本相对较低的时候被发现。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.3 实现和迭代（Implementation and iteration）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当事情获得了充分的进展，看起来进一步的评审不太会要求设计做重大的改变，那就是时候开始实现了。当计划和现实冲突，不可避免的会发现设计的缺陷，未被充分考虑的需求，或者基于经验的推测实际上错误的，进而发现需要对设计做修改。在这种情况下强烈推荐更新设计文档，一般说来：如果系统还没有上线，那么很确定应该更新文档。在实践中，我们普通人在更新文档方面都做得不好，以及因为一些其他的实际因素，更新还通常会落到新的独立的文档中去。这就导致了一种近似美国宪法的最终态：有一堆修正案，而非一份一致的文档。对于将来维护系统的可怜程序员来说，当他们像考古学家一样翻阅历史设计文档，去试图理解目标系统的时候，原始文档中给出这些&lt;/span&gt;&lt;span&gt;“修正案”的链接会非常有帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3.4 维护和学习（Maintenance and learning）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当&lt;/span&gt; Google 工程师首次接触一个系统的时候，他们的第一个问题通常是“设计文档在哪里？”。虽然说设计文档和所有其他文档一样，都会随着时间的流逝变得和现实不一致，但它们依旧是学习系统在创建之初其背后思考的最佳起步材料。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为作者，从为自己着想的角度考虑，可以在一两年后重新阅读自己的设计文档。你哪里做对了？哪里做错了？在今天来看你会做哪些不同的决策？对于工程师来说，回答这些问题是一种绝佳的提升软件设计能力和自我进步的方式。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;4. 结论（Conclusions）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在软件项目中，围绕解决最难的问题，设计文档是一种获得清晰度以并达成共识的绝佳方法。设计文档可以节省金钱，因为在前期足够的调研可以帮助避免过早就进入编码细节却未能完成项目目标；设计文档又花费金钱，因为编写和审查文档消耗时间。因此，在你项目中明智地做出选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在考虑是否编写设计文档的时候，思考如下问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;你是否对正确软件设计不确信？在前期消耗时间来获取确定性是否合理？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;在设计阶段引入相关的资深工程师是否有帮助？他们可能没有时间审查所有代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;软件设计是否是模糊的，甚至是有争议的？因此围绕这一问题在组织层面达成共识会很有价值？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;我团队是否有时候会在设计中忘记考虑隐私、安全、日志或者其他横切关注点？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●&lt;/span&gt;&lt;span&gt;&lt;span&gt;在组织中是否非常需要遗留系统设计的文档？这样可以让大家在&lt;/span&gt; high-level 快速了解系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果对于上述的问题你有三个或更多&lt;/span&gt;&lt;span&gt;“是”的回答，那么在你开始下一个软件项目的时候，设计文档大概率是个不错的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;js_underline_content&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术琐话 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-id=&quot;MzIxMzEzMjM5NQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nhlGsolibOWF3auwD2unWLZHOt6TeCJ1iboL4Po7ickwKsibk7WgicbkOxG7wibMw8ZsSMQtDpR9D3OsF2RKibxKN00Xg/0?wx_fmt=png&quot; data-nickname=&quot;技术琐话&quot; data-alias=&quot;TheoryPractice&quot; data-signature=&quot;最干货的分布式技术公众号，范围包括大数据/运维/Java/人工智能，兼及研发管理。本号专家阵容：蚂蚁金服右军、NETSTARS CTO陈斌、江苏百瑞赢CTO李伟山、某互联网公司技术总监老G先生、前蚂蚁金服高级技术专家张翔等。&quot; data-from=&quot;2&quot; data-index=&quot;0&quot; data-origin_num=&quot;301&quot; data-isban=&quot;0&quot; data-weuitheme=&quot;light&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2b8c7b3775082b6c16392350c3e5387</guid>
<title>阿里面试 HashMap 的 21 连击！一招下来你还有多少血？</title>
<link>https://toutiao.io/k/hsasxkx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section data-v-b51c2330=&quot;&quot; data-tools=&quot;新媒体排版&quot;&gt;&lt;p&gt;&lt;span&gt;公众号关注 “&lt;/span&gt;&lt;span&gt;程序员解析&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;设为“&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，重磅干货，第一时间送达&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-backh=&quot;34&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.0625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ow6przZuPIENb0m5iawutIf90N2Ub3dcPuP2KXHJvaR1Fv2FnicTuOy3KcHuIEJbd9lUyOibeXqW8tEhoJGL98qOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1：HashMap 的数据结构？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;A：哈希表结构（链表散列：数组+链表）实现，结合数组和链表的优点。当链表长度超过 8 时，链表转换为红黑树。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;transient Node&amp;lt;K,V&amp;gt;\[\] table;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2：HashMap 的工作原理？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put &amp;amp; get 方法存储和获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储对象时，将 K/V 键值传给 put() 方法：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①、调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②、调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③、i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取对象时，将 K 传给 get() 方法：①、调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；②、顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.当两个对象的 hashCode 相同会发生什么？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 hashCode 相同，不一定就是相等的（equals方法比较），所以两个对象所在数组的下标相同，&quot;碰撞&quot;就此发生。又因为 HashMap 使用链表存储对象，这个 Node 会存储到链表中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.你知道 hash 的实现吗？为什么要这样实现？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 1.8 中，是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16)，主要是从速度，功效和质量来考虑的，减少系统的开销，也不会造成因为高位没有参与下标的计算，从而引起的碰撞。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;5.为什么要用异或运算符？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的减少碰撞。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;6.HashMap 的 table 的容量如何确定？loadFactor 是什么？该容量如何变化？这种变化会带来什么问题？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①、table 数组大小是由 capacity 这个参数确定的，默认是16，也可以构造时传入，最大限制是1&amp;lt;&amp;lt;30；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②、loadFactor 是装载因子，主要目的是用来确认table 数组是否需要动态扩展，默认值是0.75，比如table 数组大小为 16，装载因子为 0.75 时，threshold 就是12，当 table 的实际大小超过 12 时，table就需要动态扩容；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③、扩容时，调用 resize() 方法，将 table 长度变为原来的两倍（注意是 table 长度，而不是 threshold）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;④、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;7.HashMap中put方法的过程？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：“调用哈希函数获取Key对应的hash值，再计算其数组下标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1ODg0OTkxNQ==&amp;amp;mid=2247489424&amp;amp;idx=1&amp;amp;sn=e4c490e60b38c54854787deeb6ef9411&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表&lt;/a&gt;;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果结点的key已经存在，则替换其value即可；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果集合中的键值对大于12，调用resize方法进行数组扩容。”&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;8.数组扩容的过程？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新的数组，其容量为旧数组的两倍，并重新计算旧数组中结点的存储位置。结点在新数组中的位置只有两种，原下标位置或原下标+旧数组的大小。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;9.拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。推荐：面试问红黑树，我脸都绿了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;10.说说你对红黑树的见解？&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个节点非红即黑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根节点总是黑色的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果节点是红色的，则它的子节点必须是黑色的（反之不一定）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个叶子节点都是黑色的空节点（NIL节点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;11.jdk8中对HashMap做了哪些改变？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java 1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发生hash碰撞时，java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java 1.8中，Entry被Node替代(换了一个马甲。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;12.HashMap，LinkedHashMap，TreeMap 有什么区别？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;13.HashMap &amp;amp; TreeMap &amp;amp; LinkedHashMap 使用场景？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，使用最多的是 HashMap。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap：在 Map 中插入、删除和定位元素时；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TreeMap：在需要按自然顺序或自定义顺序遍历键的情况下；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LinkedHashMap：在需要输出的顺序和输入的顺序相同的情况下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;14.HashMap 和 HashTable 有什么区别？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①、HashMap 是线程不安全的，HashTable 是线程安全的；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②、由于线程安全，所以 HashTable 的效率比不上 HashMap；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③、HashMap最多只允许一条记录的键为null，允许多条记录的值为null，而 HashTable不允许；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;④、HashMap 默认初始化数组的大小为16，HashTable 为 11，前者扩容时，扩大两倍，后者扩大两倍+1；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⑤、HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;15.Java 中的另一个线程安全的与 HashMap 极其类似的类是什么？同样是线程安全，它与 HashTable 在线程同步上有什么不同？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConcurrentHashMap 类（是 Java并发包 java.util.concurrent 中提供的一个线程安全且高效的 HashMap 实现）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashTable 是使用 synchronize 关键字加锁的原理（就是对对象加锁）；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而针对 ConcurrentHashMap，在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了CAS（无锁算法）+ synchronized。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;16.HashMap &amp;amp; ConcurrentHashMap 的区别？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了加锁，原理上无太大区别。另外，HashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;17.为什么 ConcurrentHashMap 比 HashTable 效率要高？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConcurrentHashMap&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;18.针对 ConcurrentHashMap 锁机制具体分析（JDK 1.7 VS JDK 1.8）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②、HashEntry 用来封装映射表的键-值对；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③、每个桶是由若干个 HashEntry 对象链接起来的链表&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47820672478206727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iatuNc7NQHickAhMV0TjhX04HK2iadAoFhBFPSF4qKuzzXJWqV04d7yibwgP1hRaGU4zibnvA1pwgLwY3YNSaBa7waQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 1.8 中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40063593004769477&quot; data-type=&quot;jpeg&quot; data-w=&quot;629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/iatuNc7NQHickAhMV0TjhX04HK2iadAoFhBF42GMl1HT1F6xbEwGG8bTdfarYU1ABonvFvG5xEMUPHiaYWrzicgTv2w/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;19.ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①、粒度降低了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;20.ConcurrentHashMap 简单介绍？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;①、重要的常量：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;private transient volatile int sizeCtl;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当为负数时，-1 表示正在初始化，-N 表示 N - 1 个线程正在进行扩容；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当为 0 时，表示 table 还没有初始化；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当为其他正数时，表示初始化或者下一次进行扩容的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;②、数据结构：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node 是存储结构的基本单元，继承 HashMap 中的 Entry，用于存储数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TreeNode 继承 Node，但是数据结构换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TreeBin 是封装 TreeNode 的容器，提供转换红黑树的一些条件和锁的控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;③、存储对象时（put() 方法）：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有初始化，就调用 initTable() 方法来进行初始化；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有 hash 冲突就直接 CAS 无锁插入；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要扩容，就先进行扩容；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;④、扩容方法 transfer()：默认容量为 16，扩容时，容量变为原来的两倍。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;helpTransfer()：调用多个工作线程一起帮助进行扩容，这样的效率就会更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;⑤、获取对象时（get()方法）：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算 hash 值，定位到该 table 索引位置，如果是首结点符合就返回；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果遇到扩容时，会调用标记正在扩容结点 ForwardingNode.find()方法，查找该结点，匹配就返回；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上都不符合的话，就往下遍历结点，匹配就返回，否则最后就返回 null。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;21.ConcurrentHashMap 的并发度是什么？&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32）&lt;span/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89434&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89434&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;更多精彩内容，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;关注我们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;▼▼&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile data-weui-theme=&quot;light&quot; class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzI0MjQxNjAyOQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uVtw9FmykSia8BtTbSFgJuxP4Lm9JOIOre5WbjWvRu00qKfjRH9FYOhaojvBx1nLsjxFTaRN4Ht9Pv4RVIibFAEg/0?wx_fmt=png&quot; data-nickname=&quot;程序员解析&quot; data-alias=&quot;programmer0001&quot; data-signature=&quot;这里都是程序员的那点事。程序员成长必读读物。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;如果觉得这篇文章还不错&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;点击下面卡片关注我&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;点个“&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;”吧&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FIO8OeuiaIUlNoicAVcG6avjKlSUUCpXpzRaG6Vg4VBIPsJqEJoSHA1euLfMkEBuBp2axd8m0tiaQH8qFzLAStic9g/640?wx_fmt=png&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca7ff18e852389e8c19cd2756c3b9fcd</guid>
<title>读懂Redis源码，我总结了这7点心得 - 知乎</title>
<link>https://toutiao.io/k/ely8yyv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;hqf_wpOC&quot;&gt;用了这么久的 Redis，也翻了很多次源码，经常有人问我到底怎么读 Redis 源码。&lt;/p&gt;&lt;p data-pid=&quot;2Khps9Hs&quot;&gt;一提到读源码，很多人都会比较畏惧，认为读源码是高手才会做的事情。他们可能遇到问题时，会更倾向于去找别人分享的答案。但往往很多时候，自己查到的资料并不能解决所有问题，尤其是比较细节的问题。&lt;/p&gt;&lt;p data-pid=&quot;P2tRikx5&quot;&gt;从我的实战经验来看，遇到这种情况，通常就需要去源码中寻找答案了，因为在源码面前，这些细节会变得「一览无余」。&lt;/p&gt;&lt;p data-pid=&quot;Jm3m2CUG&quot;&gt;而且我认为，掌握读源码的能力，是从&lt;b&gt;只懂得如何使用 Redis，到精通 Redis 实现原理&lt;/b&gt;的成长之路上，必须跨越的门槛。&lt;/p&gt;&lt;p data-pid=&quot;WniekhTC&quot;&gt;可是，面对庞大复杂的项目，我们怎样读源码才能更高效呢？&lt;/p&gt;&lt;p data-pid=&quot;deqMfn9n&quot;&gt;这篇文章我就来和你聊一聊，我读 Redis 源码的经验，以及读源码的「通用思路」，希望这些心得可以帮助到你。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-25cb1efd52f82daa5ce0954c4b3cdcaf_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;376&quot; data-rawheight=&quot;305&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;376&quot; data-rawheight=&quot;305&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-25cb1efd52f82daa5ce0954c4b3cdcaf_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;h_427346783_0&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;01 找到地图&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;eWQ0WizP&quot;&gt;很多开源项目的源码，代码量一般都比较庞大，如果在读代码之前，我们没有制定合理的方法，就一头扎进去读代码，势必会把自己搞晕。&lt;/p&gt;&lt;p data-pid=&quot;0WIaQwTP&quot;&gt;所以，我在拿到一个项目的代码之后，并不会马上着手去读，而是会先对整个项目结构进行梳理，划分出项目具体包含的模块。这样，我就对整个项目有了一个「宏观」的了解。&lt;/p&gt;&lt;p data-pid=&quot;EJ_Gbh3A&quot;&gt;读代码就好比去一个陌生城市旅行，这个旅途过程充满着未知。如果在出发之前，我们手里能有一张地图，那我们对自己的行程就可以有一个非常清晰的规划。&lt;/p&gt;&lt;p data-pid=&quot;14kxLXP2&quot;&gt;我们就知道，如果想要到达目的地，需要从哪里出发、经过哪些地方、通过什么方式才能到达，&lt;b&gt;有了地图就有了行进方向&lt;/b&gt;，否则很容易迷失。&lt;/p&gt;&lt;p data-pid=&quot;TJNwFVDG&quot;&gt;因此，提前花一些时间梳理整个项目的「结构和目录」，对于后面更好地阅读代码是非常有必要的。&lt;/p&gt;&lt;p data-pid=&quot;lmloxUDD&quot;&gt;就拿 Redis 来举例，在读 Redis 源码之前，我们可以先梳理出整个项目的功能模块，以及每个模块对应的代码文件（src 下的代码结构）：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4d7ce78b07466c63cb7421b9749d44cd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;802&quot; data-rawheight=&quot;1769&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-4d7ce78b07466c63cb7421b9749d44cd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;802&quot; data-rawheight=&quot;1769&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-4d7ce78b07466c63cb7421b9749d44cd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4d7ce78b07466c63cb7421b9749d44cd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;BGPYAS1e&quot;&gt;这样，有了这张地图之后，我们再去看代码的时候，就可以有重点地阅读了。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_1&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;02 前置知识准备&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;Q731XQ63&quot;&gt;在梳理完整个项目结构之后，我们就可以正式进入阅读环节当中了。不过，在阅读代码之前，我们其实还需要预先掌握一些「前置知识」。&lt;/p&gt;&lt;p data-pid=&quot;GO7Rj8N2&quot;&gt;因为一个完整的项目，必然综合了各个领域的技术知识点，比如&lt;b&gt;数据结构、操作系统、网络协议、编程语言&lt;/b&gt;等，如果我们提前做好一些功课，在读源码的过程中就会轻松很多。&lt;/p&gt;&lt;p data-pid=&quot;PUb3eybu&quot;&gt;以下是根据我在阅读 Redis 书籍和实战过程中，提取的读源码必备前置知识点，你可以参考下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;u2It_56b&quot;&gt;&lt;b&gt;常用数据结构&lt;/b&gt;：数组、链表、哈希表、跳表&lt;/li&gt;&lt;li data-pid=&quot;SyP-rswi&quot;&gt;&lt;b&gt;网络协议&lt;/b&gt;：TCP 协议&lt;/li&gt;&lt;li data-pid=&quot;0Ul4-btK&quot;&gt;&lt;b&gt;网络 IO 模型&lt;/b&gt;：IO 多路复用、非阻塞 IO、Reactor 网络模型&lt;/li&gt;&lt;li data-pid=&quot;Lb6BLvkN&quot;&gt;&lt;b&gt;操作系统&lt;/b&gt;：写时复制（Copy On Write）、常见系统调用、磁盘 IO 机制&lt;/li&gt;&lt;li data-pid=&quot;hSRfuB5W&quot;&gt;&lt;b&gt;C 语言基础&lt;/b&gt;：循环、分支、结构体、指针&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;wRv-4dLr&quot;&gt;当然，在阅读源码的过程中，我们也可以根据实际问题再去查阅相关资料，但不管怎样，提前熟悉这些方面的知识，在真正读代码时就会省下不少时间。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_2&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;03 从基础模块开始读&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;uvXsnIj6&quot;&gt;好，有了地图并掌握了前置知识之后，接下来我们就要进入主题了：&lt;b&gt;读代码&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;wZd4vT1s&quot;&gt;但具体要从哪个地方开始读起呢？我认为要先从「&lt;b&gt;最基础&lt;/b&gt;」的模块开始读起。&lt;/p&gt;&lt;p data-pid=&quot;Qq1fd8cb&quot;&gt;我在前面也分析了，一个完整的项目会划分很多的功能模块，但这些模块并不是孤立的，而很可能是有「依赖」关系的。&lt;/p&gt;&lt;p data-pid=&quot;viBhGdmL&quot;&gt;比如说，Redis 中的 networking.c 文件，表示处理网络 IO 的具体实现。而如果我们能在理解事件驱动模块 ae.c 的基础上，再去阅读网络 IO 模块，效率就会更高。&lt;/p&gt;&lt;p data-pid=&quot;rCDzDcH3&quot;&gt;那在 Redis 源码中，哪些是最基础的模块呢？&lt;/p&gt;&lt;p data-pid=&quot;T6GFcvSI&quot;&gt;想一下，我们在使用 Redis 时，接触最频繁的是哪些功能？&lt;/p&gt;&lt;p data-pid=&quot;Ntj9P-hY&quot;&gt;答案是&lt;b&gt;各种数据类型&lt;/b&gt;。&lt;/p&gt;&lt;p data-pid=&quot;ExHCIZnv&quot;&gt;一切操作的基础，其实都是基于这些最常用的数据类型来做的，比如 String、List、Hash、Set、Sorted Set等。所以，我们就可以从这些基础模块开始读起，也就是从 t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c 代码入手。&lt;/p&gt;&lt;p data-pid=&quot;g9GVc7Fx&quot;&gt;如果你对 Redis 的数据类型有所了解，就会看到这些数据类型在实现时，底层都对应了不同的数据结构。比如，String 的底层是 SDS，List 的底层是 ziplist + quicklist，Hash 底层可能是ziplist，也可能是哈希表，等等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2e20653dfa825c79f1ac8281b2de5d5b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;345&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2e20653dfa825c79f1ac8281b2de5d5b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;581&quot; data-rawheight=&quot;345&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2e20653dfa825c79f1ac8281b2de5d5b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2e20653dfa825c79f1ac8281b2de5d5b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;L0vbHW-y&quot;&gt;由此一来，我们会发现，这些数据结构又是更为「底层」的模块，所以我们在阅读数据类型模块时，就需要重点聚焦在这些模块上，也就是 sds.c、ziplist.c、quicklist.c、dict.c、intset.c 文件，而且这些文件都是比较独立的，阅读起来就可以更加集中。&lt;/p&gt;&lt;p data-pid=&quot;XhGzrAU1&quot;&gt;这样，当我们真正掌握了这些「底层数据结构」的实现后，就能更好地理解基于它们实现的各种「数据类型」了。&lt;/p&gt;&lt;p data-pid=&quot;ReKHeAWQ&quot;&gt;&lt;b&gt;这些基础模块就相当于一座大厦的地基，地基打好了，才能做到高楼耸立。&lt;/b&gt;&lt;/p&gt;&lt;h2 id=&quot;h_427346783_3&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;04 找到核心主线&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;XqHuAcBj&quot;&gt;接着，掌握了数据结构模块之后，这时我们的重点就需要放在「&lt;b&gt;核心主线&lt;/b&gt;」上来了。&lt;/p&gt;&lt;p data-pid=&quot;-Y--PjDT&quot;&gt;在这个阶段，我们需要找到一个明确的目标，以这个目标为主线去读代码。因为读源码一个很常见的需求，就是为了了解这个项目最「核心功能」的实现细节，我们只有以此为目标，找到这条主线去读代码，才能达到最终目的。&lt;/p&gt;&lt;p data-pid=&quot;3D6my1SC&quot;&gt;那么在读 Redis 源码时，什么才是它的核心主线呢？这里我分享一个非常好用的技巧，就是根据「&lt;b&gt;Redis 究竟是怎么处理客户端发来的命令的？&lt;/b&gt;」 为主线来梳理。&lt;/p&gt;&lt;p data-pid=&quot;ixnmXLhZ&quot;&gt;举个例子，当我们在执行 SET testkey testval EX 60 这样一条命令时，就需要搞清楚 Redis 是怎么执行这条命令的。&lt;/p&gt;&lt;p data-pid=&quot;XwURuU6C&quot;&gt;也就是要明确，&lt;b&gt;Redis 从收到客户端请求，到把数据存到 Redis 中、设置过期时间，最后把响应结果返回给客户端&lt;/b&gt;，整个过程的每一个环节，到底是如何处理的。&lt;/p&gt;&lt;p data-pid=&quot;x65Je2Hn&quot;&gt;有了这条主线，我们就有了非常明确的目标，而且沿着这条主线去读代码，我们还可以很清晰地把多个模块「串联」起来。比如从前面的例子中，我们会看到一条命令的执行，主要包含了这样几个阶段。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;rcfPZXCr&quot;&gt;&lt;b&gt;Redis Server 初始化&lt;/b&gt;：加载配置、监听端口、注册连接建立事件、启动事件循环（server.c、anet.c）。&lt;/li&gt;&lt;li data-pid=&quot;dM8MzzCe&quot;&gt;&lt;b&gt;接收、解析客户端请求&lt;/b&gt;：初始化 client、注册读事件、读客户端 socket（networking.c）。&lt;/li&gt;&lt;li data-pid=&quot;w-UHaLdm&quot;&gt;&lt;b&gt;处理具体的命令&lt;/b&gt;：找到对应的命令函数、执行命令（server.c、t_string.c、t_list.c、t_hash.c、t_set.c、t_zset.c）。&lt;/li&gt;&lt;li data-pid=&quot;PvxkofWw&quot;&gt;&lt;b&gt;返回响应给客户端&lt;/b&gt;：写客户端缓冲区、注册写事件、写客户端 socket（networking.c）。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ab566a908e0ab29c1940e7404cd5252d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ab566a908e0ab29c1940e7404cd5252d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ab566a908e0ab29c1940e7404cd5252d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ab566a908e0ab29c1940e7404cd5252d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;2Y5KTiRT&quot;&gt;沿着这条主线去读代码，我们就可以掌握一条命令的执行全过程。&lt;/p&gt;&lt;p data-pid=&quot;koxpjNbZ&quot;&gt;而且，由于这条主线的代码逻辑，已经覆盖了「所有命令」的执行流程，我们下次再去读其它命令时，比如 SADD，就只需要关注「处理命令」部分的逻辑即可，其它逻辑有 80% 都是相同的。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_4&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;05 先整体后细节&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;HA6bpiPv&quot;&gt;当然，在阅读主线代码的过程中，肯定也会遇到过于「&lt;b&gt;复杂&lt;/b&gt;」的函数，第一次在读这种函数时，很容易就会「陷进去」，导致整个主线代码的阅读，无法继续推进下去。&lt;/p&gt;&lt;p data-pid=&quot;1SoxL4jY&quot;&gt;遇到这种情况其实是很正常的，可这时我们应该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;vQeaDEdp&quot;&gt;这里我的做法是，前期读到这种逻辑时，不要马上陷入到细节中去，而是要先「抓整体」。&lt;/p&gt;&lt;p data-pid=&quot;5hbeQkHG&quot;&gt;具体来说，对于复杂的函数逻辑，我们刚开始并不需要知道它的每一个细节是如何实现的，而是只需知道这个函数「大致」做了几件事情即可。&lt;/p&gt;&lt;p data-pid=&quot;6dutC9JH&quot;&gt;举个例子，在执行 HSET 命令时，有一段代码很复杂，其中包括了很多分支判断，一次很难读懂：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0c16d55efe5587f39ede5d27ebf1766e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2304&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0c16d55efe5587f39ede5d27ebf1766e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;2304&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0c16d55efe5587f39ede5d27ebf1766e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0c16d55efe5587f39ede5d27ebf1766e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;A_O01sKT&quot;&gt;那么，我在读这段代码时，就可以先简化逻辑，把握整体思路：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e1a16bd1a4a0b4406dc1d83bc4257313_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;708&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1a16bd1a4a0b4406dc1d83bc4257313_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;708&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e1a16bd1a4a0b4406dc1d83bc4257313_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e1a16bd1a4a0b4406dc1d83bc4257313_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;AKchu80D&quot;&gt;之后，再了解每个分支大致做了哪些事情：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4f3df0f2875d02320aed5d26ee8f0f74_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;851&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4f3df0f2875d02320aed5d26ee8f0f74_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;851&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4f3df0f2875d02320aed5d26ee8f0f74_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4f3df0f2875d02320aed5d26ee8f0f74_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;BaJydFwx&quot;&gt;这样做的好处，一是不会被复杂的细节逻辑搞晕，打击自己的自信心，二是可以有效避免阅读的连贯性被打断，从而能持续推进我们把整个主线逻辑读完。&lt;/p&gt;&lt;p data-pid=&quot;Xj5PbEGk&quot;&gt;所以，这里的重点就是：&lt;b&gt;先把复杂代码的主逻辑搞清楚，知道涉及的每个方法完成了什么事，心里要先搭建一个简单的「框架」，等有了框架之后，我们再去给框架填充「细节」。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;PT8kdmdY&quot;&gt;这样通过「先整体后细节」的方式，我们就可以不再畏惧代码中的复杂逻辑。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_5&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;06 先主线后支线&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;RpZoeZON&quot;&gt;不过，在阅读主线代码的过程中，我们肯定还会遇到各种「支线」逻辑，比如&lt;b&gt;数据过期、替换淘汰、持久化、主从复制&lt;/b&gt;等。&lt;/p&gt;&lt;p data-pid=&quot;-_jjKJ2U&quot;&gt;其实，在阅读主线逻辑的时候，我们并不需要去重点关注这些支线，而当整个主线逻辑「清晰」起来之后，我们再去读这些支线模块，就会容易很多了。&lt;/p&gt;&lt;p data-pid=&quot;cdPVssxB&quot;&gt;这时，我们就可以从这些支线中，选取下一个「目标」，带着这个目标去阅读，比如说：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;jlH9rU5N&quot;&gt;过期策略是怎么实现的？（expire.c、lazyfree.c）&lt;/li&gt;&lt;li data-pid=&quot;Yhu5Ipkc&quot;&gt;淘汰策略是如何实现的？（evict.c）&lt;/li&gt;&lt;li data-pid=&quot;PllMiAZx&quot;&gt;持久化 RDB、AOF 是怎么做的？（rdb.c、aof.c）&lt;/li&gt;&lt;li data-pid=&quot;r5z904MR&quot;&gt;主从复制是怎么做的？（replication.c）&lt;/li&gt;&lt;li data-pid=&quot;pUSf3tmx&quot;&gt;哨兵如何完成故障自动切换？（sentinel.c）&lt;/li&gt;&lt;li data-pid=&quot;HHLvbd4R&quot;&gt;分片逻辑如何实现？（cluster.c）&lt;/li&gt;&lt;li data-pid=&quot;7_rwp6pN&quot;&gt;...&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;h0Amo3ww&quot;&gt;有了新的支线目标后，我们依旧可以采用前面提到的「先整体后细节」的思路阅读相关模块，这样下来，整个项目的每个模块，就可以被「逐一击破」了。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_6&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;07 查漏补缺&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;OOOOhulN&quot;&gt;最后，我们还需要「查漏补缺」。&lt;/p&gt;&lt;p data-pid=&quot;qcJBL3kJ&quot;&gt;按照前面提到的方法，基本就可以把整个项目的主要模块读得七七八八了，这时我们基本已经对整个项目有了整体的「把控」。&lt;/p&gt;&lt;p data-pid=&quot;NjHrhHYb&quot;&gt;不过，当我们在工作中遇到问题时，很有可能会发现，在当时读代码的过程中，有很多并不在意的「细节」被忽略了。&lt;/p&gt;&lt;p data-pid=&quot;VDzDYMtW&quot;&gt;所以这时，我们就可以再带着「具体问题」出发，聚焦这个问题相关的模块，再一次去读源码。这样一来，我们就可以填补当时阅读源码的「空白区」。&lt;/p&gt;&lt;p data-pid=&quot;tXRquKZ8&quot;&gt;举个例子，当我们在阅读 String 底层数据结构 SDS（简单动态字符串）的实现时，我们会看到当 SDS 需要追加新内容时会进行扩容，而我们之前阅读这块代码时，&lt;b&gt;很有可能只是了解到有这样的逻辑存在，但并没有在意扩容的相关细节（一次扩容多大）。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;sO8NCOUQ&quot;&gt;所以，当我们在工作中遇到这个细节问题后，就可以把目光聚焦在 SDS 的扩容逻辑上（sds.c 的sdsMakeRoomFor函数），而此时我们会发现，当需要申请的新内存小于 1MB 时，Redis 就会翻倍申请内存，否则按 1MB 申请新内存。&lt;/p&gt;&lt;p data-pid=&quot;Zq73fCQa&quot;&gt;采用这个方法进行查漏补缺，我们就可以对整个项目了解得更深入、更全面，真正把项目「吃透」。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_7&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;T6fcqi0N&quot;&gt;好了，以上就是我在阅读 Redis 源码时的经验心得，总结一下这 7 个步骤。&lt;/p&gt;&lt;p data-pid=&quot;8ZiU96pg&quot;&gt;1、&lt;b&gt;找到地图&lt;/b&gt;：拿到项目代码后，提前梳理整个项目结构，知晓整个项目的模块划分，以及对应的代码文件。&lt;/p&gt;&lt;p data-pid=&quot;ZJmsIzw_&quot;&gt;2、&lt;b&gt;前置知识准备&lt;/b&gt;：提前掌握项目中用到的前置知识，比如数据结构、操作系统原理、网络协议、网络 IO 模型、编程语言语法等等。&lt;/p&gt;&lt;p data-pid=&quot;TlILHul6&quot;&gt;3、&lt;b&gt;从基础模块开始读&lt;/b&gt;：从最底层的基础模块开始入手，先掌握了这些模块，之后基于它们构建的模块读起来会更加高效。&lt;/p&gt;&lt;p data-pid=&quot;8bUcieQz&quot;&gt;4、&lt;b&gt;找到核心主线&lt;/b&gt;：找到整个项目中最核心的主线逻辑，以此为目标，了解各模块为了完成这个功能，是如何协作和组织的。&lt;/p&gt;&lt;p data-pid=&quot;p3xh_5wR&quot;&gt;5、&lt;b&gt;先整体后细节&lt;/b&gt;：对于复杂函数，不要上来就陷入细节，前期阅读只需了解这个函数大致做了什么事情，建立框架，等搭建起框架之后，再去填充细节。&lt;/p&gt;&lt;p data-pid=&quot;jyajmM3l&quot;&gt;6、&lt;b&gt;先主线后支线&lt;/b&gt;：整个主线逻辑清晰之后，再去延伸阅读支线逻辑，因为支线逻辑肯定是服务主线逻辑的，读完主线后再去读这些支线，也会变得更简单。&lt;/p&gt;&lt;p data-pid=&quot;QqqqbE-s&quot;&gt;7、&lt;b&gt;查漏补缺&lt;/b&gt;：在工作中遇到具体问题，带着这些实际的问题出发再次去读源码，进行查漏补缺，填补之前读源码时没有注意到的地方。&lt;/p&gt;&lt;h2 id=&quot;h_427346783_8&quot; data-into-catalog-status=&quot;&quot;&gt;&lt;b&gt;后记&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;ubrjzAbX&quot;&gt;你可以看到，这篇文章介绍的阅读源码的方法，其实并不局限于读 Redis 代码。&lt;/p&gt;&lt;p data-pid=&quot;c21oo3p1&quot;&gt;这 7 个步骤，可以算是一个的「通用思路」，我也经常用这个思路来读其它项目的源码，非常有用，你也可以试试。&lt;/p&gt;&lt;p data-pid=&quot;17HySscr&quot;&gt;另外，我认为很多人读源码觉得难，&lt;b&gt;一是因为心理上自认为自己读不懂，不敢迈步这一步，二是因为找不到合理的方法，在读源码时屡次受挫，最终知难而退。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;oTyscqTp&quot;&gt;我在读源码时也经历过这些，这里再分享一下我的经验。&lt;/p&gt;&lt;p data-pid=&quot;JbizEq3U&quot;&gt;1、&lt;b&gt;永远不要给自己设限&lt;/b&gt;：想想看，曾经以为很多自己做不到的事，在有压力的情况下，是不是慢慢都做到了，而且发现做得还挺好？学习技术也是一样，技术是死的，东西就那么多，一遍不行来两遍，总有一次能搞懂，所以心态上一定不要先「否定」自己，凡事先迈一小步进去试试看，好的开始就是成功的一半。&lt;/p&gt;&lt;p data-pid=&quot;5sdKkMTQ&quot;&gt;2、&lt;b&gt;找到对的学习方法&lt;/b&gt;：正所谓「学会学习，再学习」，科学高效的方法，能帮你事半功倍，这篇文章分享的方法论，就是属于学习方法的范畴，你可以结合自己的实际情况试试看。&lt;/p&gt;&lt;p data-pid=&quot;42aoriS0&quot;&gt;希望我的这些经验和心得，对你有所启发。&lt;/p&gt;&lt;p data-pid=&quot;-hiwoHGn&quot;&gt;如果你也有自己的阅读源码的实践经验和方法，欢迎在留言区分享出来，我们一起交流，共同进步~&lt;/p&gt;&lt;a data-draft-node=&quot;block&quot; data-draft-type=&quot;mcn-link-card&quot; data-mcn-id=&quot;1437544891367174144&quot;/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6748cffc621788f1911c6f0f8e06f6b5</guid>
<title>程序员不得不知道的 API 接口常识</title>
<link>https://toutiao.io/k/ts9tpt3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oGp3ImQqDoaJAZbHjdmUoFn9xKhFC4fiajGq8GEzYK9AicZM4bAz0jicFYl1LvVILTsdcyKpm8xyT88OhFgRAc5BQ/640?wx_fmt=jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，我非常希望自己能早点看到本篇文章，大学那个时候懵懵懂懂，跟着网上的免费教程做了一个购物商城就屁颠屁颠往简历上写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至今我仍清晰地记得，那个电商教程是怎么定义接口的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;管它是增加、修改、删除、带参查询，全是 POST 请求一把梭，比如下面这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;修改用户的收货地址&lt;br/&gt;&lt;br/&gt;POST /xxx-mall/cart/update_address&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在看来，全部用 POST 请求估计是为了传参方便吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那个时候自己也没有一个 &lt;code&gt;API 接口需要设计&lt;/code&gt; 的意识，跟学过类似教程的朋友应该懂的，老师敲一行代码学生跟着敲一行。如果没人提这个事情，正式工作进入团队后，是很容易出丑的......（作者亲身经历，捂脸）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文就不用 PPT 教案上的那种官方腔介绍 API 接口是个什么概念了，比较希望用一种聊天的方式和大家分享下现有的一丁丁和 API 相关的小心得，文章会分为五小块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;初识 API 接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于 API 限流&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于 API 版本管理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于 API 权限与安全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关于团队间的 API 互通&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注：这是一篇会隐式罗列很多知识点的文章，您可以按需深度搜索进行更进一步的学习。当年渴望看到这样的文章的原因是：学习一个知识点其实只需要时间，对学生而言，时间不是问题，问题在于不知道该往哪些方向学 T_T 。本文希望通过串讲，梳理一下个人当前了解到的 API 知识体系，整理的同时也希望能对大家有一点点帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得在我初学 web 开发的时候，后端框架相关的教程基本都会教学生写渲染模版（不分语言），也就是说后端返回的是整个网页的数据，浏览器只负责渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般这类模版在后端都会对应一个路由，比如前端想登入一个看用户信息的页面，在 url 中输入的访问地址大概长这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https:&lt;span&gt;//ajun24.com/user&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那个时候，我以为这样的路由地址就是 API 概念的全部了......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是：绝大部分后端教程都会简单教一下前端，在前端的补充教程中有一个必学的知识点，叫：AJAX。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老师大概率会演示一下 AJAX 这个技术怎么使用，写个小 Demo，告诉大家可以这样在页面上发送异步请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个技术请求的后端接口一般不会跳转或返回一个 html 页面，大概率会返回一份 json 数据。我一直对这样的接口和返回页面数据的接口有着迷之困惑。直到我实习后明白了什么叫前后端分离开发......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是为了教学方便，完整项目大概率还是会用渲染模版的方式讲解，毕竟只在一套系统里写代码演示会方便很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当年就是这样学完了第一个项目，虽然对如何做一个软件系统有了整体的认识，但是对 API 设计的认识是非常弱的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我在学 AJAX 这个知识点的时候就在想：有没有可能全部数据都通过类似 AJAX 这种方式获取？这样感觉会更方便一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来实习的时候，前端同学告诉我：开发前需要先定义 API 哦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，他还告诉我：删除一个东西不能用 POST 请求哦&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;（捂脸）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来导师提醒我：你需要去了解一下如何设计 REST 风格的 API。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;自从那次出丑后，我明白了一个事情，一定要敢于把自己的不足&quot;暴露&quot;给愿意指点你的人看。就好比我们读大学的时候最好要努力去找一份实习，每一次被拒以及每一份 offer 都会告诉我们，这个社会需要什么样的人才，什么样的技能可以帮助我们谋得一份工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在正式的面试场合下，或许我们更应该条理清晰地和面试官介绍什么是表现层状态转换，但是在这篇文章中，我想把 REST 风格的 API 称为更容易让人看懂的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家会发现符合 REST 风格的 API 能非常容易地让别人知道调用这个 API 能干什么，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET     /users                # 查询用户信息&lt;br/&gt;PATCH   /users/{user_id}      # 根据 id 更新某个用户的信息，只部分更新客户端提交的数据&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按约定写 API 就好比在 IT 领域说行话&lt;/strong&gt; ，大家只要看见你的 API，就知道你能提供什么样的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有同学可能会好奇为什么要遵守规范？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如，我们负责的系统仅联系到我们身边同事的系统，那约定 API 的时候只需要打个招呼，或在聊天工具上简单说明一下就可以了，甚至可以没有文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在很多情况下，我们的系统是要被很多其他系统调用的，大家想象一下我们去调用云厂商 API 的场景：别人的工程师大概率不是我们的微信好友，大多数时候是没有人站在我们身边手把手告诉我们 API 怎么调用的。这个时候想调用对方提供的 API，就得看对方提供的 API 文档。如果对方的 API 不按照规范定义，那 API 文档绝对像天书一样难读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看天书的痛苦，保证大家体会一次足以终生难忘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;良好的 API 文档一般会像工具手册，没有太多学习成本，否则别人下一次很有可能就不使用我们的服务了&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/newemoji/Hurt.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以先系统地学习 API 定义约规，再编写 API 文档，然后根据设计进行开发是一个比较好的研发流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的问题是，在了解了 API 的规范后，如何写出良好的 API 文档呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，写文档对程序员来说是一件非常痛苦的事情，一想到学习写专业的 API 文档还需要学习成本，实在是劝退。这个时候我们可以通过一些自动化工具辅助我们完成一篇优秀的 API 文档，比如我们可以使用 swagger，它可以通过我们的代码自动生成 API 文档。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近还看到不少基于 API 的研发测试一体化产品和平台，感觉一站式的、流水线式的研发管理是未来的趋势呀！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 写出来后会被调用，但由于计算机 &amp;amp; 网络系统的局限性，我们的 API 接口是不可以被无限制调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以随便到网上挑一个比较专业的 API 文档看，比如大家可以去看云厂商对外提供的 API，基本都会看到一个接口频率调用限制，比如：单用户调用频率为 30 次 / 秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当我们在设计 API 的时候，限流是一个不得不考虑的事情（内部自己弄着玩的不算哈，泛指面向用户的系统）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在设计限流之前，我们首先要知道自己系统的瓶颈。假设我们的 API 纯粹调用自家的技术组件，比如数据库，消息队列等中间件，这个时候我们可以通过压测得知一个接口的最大承受能力；假设我们的系统是一个中间系统，需要依赖其他系统的接口完成业务，那么这个时候基于木桶原理，我们接口的可访问频率就会受限于其他业务系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完自身项目的访问瓶颈后，需要考虑自身系统的架构，假设我们的系统是单体部署：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.378698224852071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdPlFS3dmnRl67ZOiaoR5p2Jet6CwY3H0NfBupOy30ia9KhalFx8FK80OcorWvfhgODD33dfaLRMkTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;507&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个时候我们只需要简单的令牌桶算法即可以完成限流，下面是一个极简的令牌桶算法实现 Demo：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;&quot;&lt;br/&gt;简单解释：&lt;br/&gt;实现一个固定容量的桶，按一定的频率往桶内放令牌直至桶满，每当执行一个限频操作需要从桶中获取一个令牌才能继续操作，若桶中没有令牌，则进行等待&lt;br/&gt;往令牌桶中放令牌的操作不便按照原概念实现，所以放令牌这步放到取令牌的时候进行。我们根据当前取令牌的时间减去上一次取令牌的时间差，就能得知这段时间内增加了多少个令牌。&lt;br/&gt;&quot;&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TokenBucket&lt;/span&gt;(&lt;span&gt;object&lt;/span&gt;):&lt;br/&gt;&lt;br/&gt;    # &lt;span&gt;rate&lt;/span&gt; 是令牌桶生产令牌的速率，&lt;span&gt;capacity&lt;/span&gt; 是令牌桶生产令牌的速率&lt;br/&gt;    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(&lt;span&gt;self&lt;/span&gt;, &lt;span&gt;rate&lt;/span&gt;, &lt;span&gt;capacity&lt;/span&gt;):&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.&lt;span&gt;_rate&lt;/span&gt; &lt;/span&gt;= rate&lt;br/&gt;        self._capacity = capacity&lt;br/&gt;        self._current_amount = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        self._last_consume_time = &lt;span&gt;int&lt;/span&gt;(time.time())&lt;br/&gt;&lt;br/&gt;    # token_amount 是执行一次操作需要的令牌数量&lt;br/&gt;    &lt;span&gt;def &lt;span&gt;consume&lt;/span&gt;&lt;span&gt;(self, token_amount)&lt;/span&gt;:&lt;br/&gt;        # 通过时间差乘速率，得到令牌的增量&lt;br/&gt;        increment &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;(time.time()) - self._last_consume_time) * self._rate&lt;br/&gt;        时间差乘速率，得到令牌的增量  &lt;br/&gt;        self._current_amount = min(&lt;br/&gt;            increment + self._current_amount, self._capacity)&lt;br/&gt;        # 令牌数量不够则不允许操作&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; token_amount &amp;gt; self._current_amount:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; False&lt;br/&gt;        # 更新最后一次操作时间&lt;br/&gt;        self._last_consume_time = &lt;span&gt;int&lt;/span&gt;(time.time())&lt;br/&gt;        # 结算当前的令牌数量&lt;br/&gt;        self._current_amount -= token_amount&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; True&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际工作中，我们部署单体架构的机会不多，现在的大公司都构建有自己的云生态，业务部门上云后可快速进行扩缩容，所以我们的系统很有可能会进行集群部署，用户的请求通过代理层负载均衡至各个后端节点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.554364471669219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfdPlFS3dmnRl67ZOiaoR5p2JX9N7m0hJSe36pZqzUlLBEElMhesGj9sa9YtRdapUUSUmzuyXBqJ7MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候上面的 15 行代码显然就不符合我们的分布式系统架构，我们得考虑更复杂的限流算法实现了（这里不是指令牌桶算法不合适，是指令牌桶算法的实现方式需要改进），当然这个实现大概率会放在代理层了，而不是实现在我们的业务层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以上网看一下主流云厂商提供的云服务，很多都会提供 API 网关，对应着我们上面提到的代理层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如一个公司有统一的 API 网关服务，或有类似的代理服务，业务部门是可以在 API 限流这件事情上省下很大功夫的。我有时候想，当越来越多的中小企业基于巨无霸云厂商搭建业务，大家要考虑的技术性问题就会越来越少，越来越专注于业务，这到底是一件好事还是坏事呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://github.com/YunaiV/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍完 API 及限流的基本知识后，谈一下和业务比较相关的 API 的版本管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没真正接触业务前，我以为只有软件需要做版本管理，为啥 API 也要做版本管理咧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实原理是一样的，软件会根据需求不断迭代版本，API 同样也会迭代版本，但秉承开闭原则，为了不影响之前的业务，我们最好不要改动原有的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们设计 API 的时候可以指定版本号，比如上述的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET     /users  # 查询用户信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以统一定义成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET     /api/v1/users  # 查询用户信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设这个接口有了第二个版本，我们就可以通过版本号进行区分了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET     /api/v2/users  # 查询用户详细信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换作两年前的我可能会对 API 版本管理无感，但大家尝试把自己代入以下场景就能明白了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们的产品让我们出一套新的查询用户 API，假设我们没有定义版本号，由于 &lt;code&gt;/users&lt;/code&gt; 这条路由已经在用了，逼不得已，我们就会定义一个新的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET     /get_user_info  # 查询用户信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新接口和老接口的意思差不多，如果我们一直负责这个系统，那还好说（心里有不同版本的区分）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但假如这个系统换了另一个接班人，当他面对大量意义接近的接口时，肯定会怀疑人生的......（屎山就是这样来的）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们思考一下 API 的权限与安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是回到初学的时候，那个时候我对 API 接口权限完全没有任何概念。老师为了快速教会我们开发系统，很多接口的设计是完全裸奔的。如果不了解一点点相关的知识，工作中会容易给别人一种考虑事情不周到的感觉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际生产中，接口是不可以不做权限校验的，如果我们的系统暴露在公网，还没有权限校验的话，系统估计很快就挂了；内部涉及机密的系统，权限校验则更为严格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于权限校验，个人暂时分为三个维度，三个维度或许可以对应三种业务类型：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一种是直接针对 IP 设置白名单，这种方式比较适用于客户端有限且固定的内部系统；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二种则是设置权限校验流程，比如采用 Token 鉴权，较多用于 ToB 业务。大家在云厂商注册账号后基本都会得到一对密钥，后续的 API 调用一般都需要先根据密钥进行权限认证；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三种是通过用户登陆判断权限，较多用于 ToC 业务，比如我们登陆京东，登陆淘宝需要账号，没有登陆就访问不了购物车等页面。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是，权限设计是另一个维度的知识，除了第一个维度，后两者其实都可以单独成立一个系统的。比如公司的用户管理系统，中心化权限认证系统等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限校验关乎着公司财产安全，所以不可忽视，很多时候我们甚至需要在 API 设计层面考虑安全问题。再次引用商城的例子，比如登陆后获取用户购物车的订单，API 大概率会设计成这样子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /users/&lt;span&gt;287435&lt;/span&gt;/orders&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但直接暴露用户 id 或许不是一个明智的选择，有可能被不法分子利用，我们可以换种方式，比如用以下的方式替代：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /users/me/orders&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总而言之，API 的设计除了参考规范外，还需要根据自身业务情况进行更进一步的安全考虑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后是一个延展性话题，相信大家都感受到了我们正身处于一个数据时代，我们的个人信息，包括各类行为喜好，都存放在各家互联网公司的数据仓库里，企业们可能比我们更了解我们自身，网上也有很多与数据资产有关的话题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然已经把数据比作资产了，而资产流动性又是一个经久不衰的话题，所以各类数据的开放性问题也倍受关注。而数据对外开放，必然就会涉及到 API 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然作为一只小码农，我的视野极其有限，很难从一个较高的层次去谈论企业的数据问题。但在工作中，当其他业务团队提出要调用自己负责的项目的 API 接口时，也是需要进行多方位考虑的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文列出的就是个人会从技术上考虑的点，总结成三句话就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你能看懂我的 API 嘛？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;别把我的 API 打爆哦！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;API 要经允许才能使用哦！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于API 的这个概念实在是太大了，我能接触的也是一些些皮毛，但时不时总结整理一下还是大有裨益的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>