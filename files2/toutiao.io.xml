<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bd56318523ecab3224c9f342ed266c19</guid>
<title>Spring Boot 生产中 16 条最佳实践，建议收藏</title>
<link>https://toutiao.io/k/30pmyuh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;👆&lt;/span&gt;点击左上角&lt;/span&gt;&lt;span&gt;蓝字&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;，&lt;/span&gt;&lt;strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;关注&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;此公众号👆&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;技术干货，及时送达！&lt;/span&gt;&lt;/p&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Spring Boot是最流行的用于开发微服务的Java框架。在本文中，我将与你分享自2016年以来我在专业开发中使用Spring Boot所采用的最佳实践。这些内容是基于我的个人经验和一些熟知的Spring Boot专家的文章。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本文中，我将重点介绍Spring Boot特有的实践（大多数时候，也适用于Spring项目）。以下依次列出了最佳实践，排名不分先后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;1&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用自定义BOM来维护第三方依赖&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这条实践是我根据实际项目中的经历总结出的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Boot项目本身使用和集成了大量的开源项目，它帮助我们维护了这些第三方依赖。但是也有一部分在实际项目使用中并没有包括进来，这就需要我们在项目中自己维护版本。如果在一个大型的项目中，包括了很多未开发模块，那么维护起来就非常的繁琐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么办呢？事实上，Spring IO Platform就是做的这个事情，它本身就是Spring Boot的子项目，同时维护了其他第三方开源库。我们可以借鉴Spring IO Platform来编写自己的基础项目platform-bom，所有的业务模块项目应该以BOM的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.spring.platform&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;platform-bom&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;Cairo-SR3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;           &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用自动配置&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Boot的一个主要特性是使用自动配置。这是Spring Boot的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的jar文件时，自动配置就会被激活。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用它的最简单方法是依赖Spring Boot Starters。因此，如果你想与Redis进行集成，你可以首先包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你想与MongoDB进行集成，需要这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-mongodb&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;借助于这些starters，这些繁琐的配置就可以很好地集成起来并协同工作，而且它们都是经过测试和验证的。这非常有助于避免可怕的Jar地狱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//dzone.&lt;span&gt;com&lt;/span&gt;/articles/what-&lt;span&gt;is&lt;/span&gt;-jar-hell&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过使用以下注解属性，可以从自动配置中排除某些配置类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;EnableAutoConfiguration&lt;/span&gt;（&lt;span&gt;exclude&lt;/span&gt; = {&lt;span&gt;ClassNotToAutoconfigure&lt;/span&gt;&lt;span&gt;.class&lt;/span&gt;}）&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但只有在绝对必要时才应该这样做。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有关自动配置的官方文档可在此处找到：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;https&lt;/span&gt;:&lt;span&gt;//docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;3&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用Spring Initializr来开始一个新的Spring Boot项目&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;49&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;这一条最佳实践来自Josh Long （Spring Advocate，@starbuxman）。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring Initializr 提供了一个超级简单的方法来创建一个新的Spring Boot项目，并根据你的需要来加载可能使用到的依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;https://start.spring.io/&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用Initializr创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于Spring自动配置。你甚至可能会发现一些新的集成，但你可能并没有意识到这些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;4&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑为常见的组织问题创建自己的自动配置&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条也来自Josh Long（Spring Advocate，@starbuxman）——这个实践是针对高级用户的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你在一个严重依赖Spring Boot的公司或团队中工作，并且有共同的问题需要解决，那么你可以创建自己的自动配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这项任务涉及较多工作，因此你需要考虑何时获益是值得投入的。与多个略有不同的定制配置相比，维护单个自动配置更容易。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果将这个提供Spring Boot配置以开源库的形式发布出去，那么将极大地简化数千个用户的配置工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;5&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;正确设计代码目录结构&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;尽管允许你有很大的自由，但是有一些基本规则值得遵守来设计你的源代码结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;避免使用默认包。确保所有内容（包括你的入口点）都位于一个名称很好的包中，这样就可以避免与装配和组件扫描相关的意外情况；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将Application.java（应用的入口类）保留在顶级源代码目录中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我建议将控制器和服务放在以功能为导向的模块中，但这是可选的。一些非常好的开发人员建议将所有控制器放在一起。不论怎样，坚持一种风格！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;6&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;保持@Controller的简洁和专注&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Controller应该非常简单。你可以在此处阅读有关GRASP中有关控制器模式部分的说明。你希望控制器作为协调和委派的角色，而不是执行实际的业务逻辑。以下是主要做法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//&lt;span&gt;en&lt;/span&gt;.wikipedia.org/wiki/GRASP_(object-oriented_design)#Controller&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要深入这个内容，需要进一步地了解设计REST API的最佳实践。无论你是否想要使用Spring Boot，都是值得学习的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;7&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;围绕业务功能构建@Service&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Service是Spring Boot的另一个核心概念。我发现最好围绕业务功能/领域/用例（无论你怎么称呼都行）来构建服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在应用中设计名称类似AccountService, UserService, PaymentService这样的服务，比起像DatabaseService、ValidationService、CalculationService这样的会更合适一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以决定使用Controler和Service之间的一对一映射，那将是理想的情况。但这并不意味着，Service之间不能互相调用！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;8&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使数据库独立于核心业务逻辑之外&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我之前还不确定如何在Spring Boot中最好地处理数据库交互。在阅读了罗伯特·C·马丁的“Clear Architecture”之后，对我来说就清晰多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你希望你的数据库逻辑于服务分离出来。理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;罗伯特C.马丁强烈地说明，你的数据库是一个“细节”，这意味着不将你的应用程序与特定数据库耦合。过去很少有人会切换数据库，我注意到，使用Spring Boot和现代微服务开发会让事情变得更快。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;9&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;保持业务逻辑不受Spring Boot代码的影响&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;考虑到“Clear Architecture”的教训，你还应该保护你的业务逻辑。将各种Spring Boot代码混合在一起是非常诱人的……不要这样做。如果你能抵制诱惑，你将保持你的业务逻辑可重用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;部分服务通常成为库。如果不从代码中删除大量Spring注解，则更容易创建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;10&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;推荐使用构造函数注入&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条实践来自Phil Webb（Spring Boot的项目负责人, @phillip_webb）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保持业务逻辑免受Spring Boot代码侵入的一种方法是使用构造函数注入。不仅是因为@Autowired注解在构造函数上是可选的，而且还可以在没有Spring的情况下轻松实例化bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;11&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熟悉并发模型&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;我写过的最受欢迎的文章之一是“介绍Spring Boot中的并发”。我认为这样做的原因是这个领域经常被误解和忽视。如果使用不当，就会出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;82&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://www.e4developer.com/2018/03/30/introduction-to-concurrency-in-spring-boot/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Spring Boot中，Controller和Service是默认是单例。如果你不小心，这会引入可能的并发问题。你通常也在处理有限的线程池。请熟悉这些概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你正在使用新的WebFlux风格的Spring Boot应用程序，我已经解释了它在“Spring’s WebFlux/Reactor Parallelism and Backpressure”中是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;12&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;加强配置管理的外部化&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一点超出了Spring Boot，虽然这是人们开始创建多个类似服务时常见的问题……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以手动处理Spring应用程序的配置。如果你正在处理多个Spring Boot应用程序，则需要使配置管理能力更加强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我推荐两种主要方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些选项中的任何一个（第二个选项多一些）都要求你在DevOps更少工作量，但这在微服务领域是很常见的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;13&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;提供全局异常处理&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;你真的需要一种处理异常的一致方法。Spring Boot提供了两种主要方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这与Spring中的几乎相同，并且Baeldung有一篇关于REST与Spring的错误处理的详细文章，非常值得一读。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;http&lt;span&gt;s:&lt;/span&gt;//www.baeldung.&lt;span&gt;com&lt;/span&gt;/exception-handling-&lt;span&gt;for&lt;/span&gt;-rest-with-spring&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;14&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用日志框架&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可能已经意识到这一点，但你应该使用Logger进行日志记录，而不是使用System.out.println()手动执行。这很容易在Spring Boot中完成，几乎没有配置。只需获取该类的记录器实例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;Logger logger = LoggerFactory.getLogger(MyClass.&lt;span&gt;class&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这很重要，因为它可以让你根据需要设置不同的日志记录级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;15&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;测试你的代码&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这不是Spring Boot特有的，但它需要提醒——测试你的代码！如果你没有编写测试，那么你将从一开始就编写遗留代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有其他人使用你的代码库，那边改变任何东西将会变得危险。当你有多个服务相互依赖时，这甚至可能更具风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于存在Spring Boot最佳实践，因此你应该考虑将Spring Cloud Contract用于你的消费者驱动契约，它将使你与其他服务的集成更容易使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;16&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用测试切片让测试更容易，并且更专注&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一条实践来自Madhura Bhave（Spring 开发者, @madhurabhave23）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用Spring Boot测试代码可能很棘手——你需要初始化数据层，连接大量服务，模拟事物……实际上并不是那么难！答案是使用测试切片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用测试切片，你可以根据需要仅连接部分应用程序。这可以为你节省大量时间，并确保你的测试不会与未使用的内容相关联。来自spring.io的一篇名为Custom test slice with Spring test 1.4的博客文章解释了这种技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;72&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://spring.io/blog/2016/08/30/custom-test-slice-with-spring-boot-1-4&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-class=&quot;_mbEditor&quot; data-id=&quot;132251&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;17&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢Spring Boot，编写基于Spring的微服务正变得前所未有的简单。我希望通过这些最佳实践，你的实施过程不仅会变得很快，而且从长远来看也会更加强大和成功。祝你好运！&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;来源：&lt;/span&gt;&lt;span&gt;&amp;lt;网络&amp;gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;版权声明：此内容来源网络，版权归原作者所有。我们转载的内容，都会注明来源，除非无法确认。若有侵权，烦请告知，我们会立即删除并表示歉意。谢谢！&lt;/span&gt;&lt;/blockquote&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;PS：文章若对您有用，请帮助 &lt;strong&gt;点赞、在看、转发&lt;/strong&gt; 吧！&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;公众号：Java精选&quot; data-id=&quot;91842&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;点击卡片关注我们，更多技术干货，及时为您送达！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzU0ODk2MzE3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib178LnVu9br0VUuI4OKYwvXKpZnaGseFG3vyFJShp2VFcwVodS88CkUsNYcLDrglYLHPFoic6MJD4A/0?wx_fmt=png&quot; data-nickname=&quot;逻魔代码&quot; data-alias=&quot;lomagicode&quot; data-signature=&quot;逻魔代码，分享架构技术干货，打造有价值的经验分享社群，帮助后继者以前人的肩膀为基，建造更精妙的技术殿堂！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;&lt;p mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485286&amp;amp;idx=1&amp;amp;sn=4e9419cbc1fcbf82b37c40318667d282&amp;amp;chksm=fbb6516bccc1d87d8588e9b7d19ddf35ffcfdc027529514f5a5d8231870d0ec4ed96361bcd38&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【实战】SpringBoot零侵入全局记录RabbitMQ消息发送和消费状态&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【实战】SpringBoot零侵入全局记录RabbitMQ消息发送和消费状态&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485286&amp;amp;idx=2&amp;amp;sn=cfd655eaa33e278eb83c6dc565fe5be3&amp;amp;chksm=fbb6516bccc1d87df92ddb198b7a21899b96db177b88f148e8156e571347a7ab0dba56102ad2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;几个数据持久化框架（Hibernate、JPA、Mybatis、JOOQ、JDBC Template）的比较&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;几个数据持久化框架（Hibernate、JPA、Mybatis、JOOQ、JDBC Template）的比较&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485246&amp;amp;idx=1&amp;amp;sn=4deca9c75a6aa9de9883e388916496f4&amp;amp;chksm=fbb65133ccc1d8257ae41dd8fe710d7cea93a312e6aa0f2079f4a140416dbf17f9a03866c895&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计一个短链接系统？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计一个短链接系统？&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485184&amp;amp;idx=1&amp;amp;sn=3ba295e248bd8e6fae451d241e8f30b1&amp;amp;chksm=fbb6510dccc1d81b32f7e05ba07ae9c010f9a9b9bd1c79b36d3cebbb918e48d2a2ada828d310&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;JWT 实现登录认证 + Token 自动续期方案，正确的使用姿势！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;JWT 实现登录认证 + Token 自动续期方案，正确的使用姿势！&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ddd711eac5760656ff4b76d304618c68</guid>
<title>分布式 ID 生成服务的技术原理和项目实战</title>
<link>https://toutiao.io/k/9v68f9o</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;&lt;p name=&quot;global_header&quot; data-traceid=&quot;global_header&quot; data-tracepid=&quot;global_header&quot;&gt;
                &amp;#13;
&amp;#13;

            &lt;/p&gt;
            

        &lt;val data-name=&quot;site_url&quot; data-value=&quot;https://www.oschina.net&quot;/&gt;      &lt;val data-name=&quot;space_user_url&quot; data-value=&quot;https://my.oschina.net/u/4939618&quot;/&gt;      &lt;val data-name=&quot;space_user_id&quot; data-value=&quot;4939618&quot;/&gt;      &lt;val data-name=&quot;g_user_url&quot; data-value=&quot;&quot;/&gt;      &lt;val data-name=&quot;api_prefix&quot; data-value=&quot;/action&quot;/&gt;      &lt;val data-name=&quot;g_user_code&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_id&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_bind_phone&quot; data-value=&quot;false&quot;/&gt;     &lt;val data-name=&quot;g_user_name&quot; data-value=&quot;&quot;/&gt;     &lt;val data-name=&quot;g_user_small_portrait&quot; data-value=&quot;https://www.oschina.net/new-osc/img/portrait.gif&quot;/&gt;     &lt;val data-name=&quot;g_user_large_portrait&quot; data-value=&quot;https://www.oschina.net/new-osc/img/portrait.gif&quot;/&gt;     &lt;val data-name=&quot;g_user_osc_staff&quot; data-value=&quot;false&quot;/&gt;     &lt;val data-name=&quot;login_page&quot; data-value=&quot;https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;/&gt; 
                &lt;val data-name=&quot;weixinAppId&quot; data-value=&quot;wx880def15e694b905&quot;/&gt;
        &lt;val data-name=&quot;weixinTimestamp&quot; data-value=&quot;1667209486009&quot;/&gt;
        &lt;val data-name=&quot;weixinNonceStr&quot; data-value=&quot;86087361-c985-4534-9952-c20f7d6babc5&quot;/&gt;
        &lt;val data-name=&quot;weixinSignature&quot; data-value=&quot;801f5a130f044ea96cb4204cfd26d47c756f26bf&quot;/&gt;
        &lt;val data-name=&quot;weixinShareUrl&quot; data-value=&quot;https://my.oschina.net/u/4939618/blog/5585451?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot;/&gt;                             
                &lt;val data-name=&quot;is_detail_page&quot; data-value=&quot;true&quot;/&gt;

        &lt;val data-name=&quot;fixedHeaderHeight&quot; data-value=&quot;45&quot;/&gt;
        &lt;val data-name=&quot;secondaryHeaderEnable&quot; data-value=&quot;true&quot;/&gt;

        &lt;val data-name=&quot;rocommendGrayStatus&quot; data-value=&quot;true&quot;/&gt; 
        
    &lt;div class=&quot;pusher&quot;&gt;
                        
                                                                &lt;div class=&quot;small-header-box small-header-box--fixed small-header-box--default-simple&quot;&gt;
                &lt;div class=&quot;small-header-box__wrapper&quot;&gt;
                    &lt;div class=&quot;small-header-box__inner&quot;&gt;
                        
                        &lt;div class=&quot;user-bar&quot;&gt;
                            &lt;ul class=&quot;user-bar__links&quot;&gt;
                                                                &lt;a class=&quot;item icon app-download btnDownloadTop&quot; title=&quot;OSC小程序&quot;&gt;&lt;i class=&quot;oicon oicon-phone&quot;/&gt;&lt;/a&gt;
                                &lt;div class=&quot;ui popup top left transition btnDownloadTopContent hidden&quot;&gt;
                                    &lt;h3 class=&quot;header&quot;&gt;OSCHINA 小程序 —— &lt;br/&gt;关注技术领域的头条文章&lt;/h3&gt;
                                    &lt;p&gt;聚合全网技术文章，根据你的阅读喜好进行个性推荐&lt;/p&gt;
                                    &lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-91f008637a179c217fdec464b7bad202844.jpg&quot; alt=&quot;OSC小程序&quot;/&gt;
                                &lt;/div&gt;

                                                                    &lt;a class=&quot;item&quot; href=&quot;https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;&gt;登录&lt;/a&gt;
                                                                &lt;a class=&quot;item&quot; href=&quot;https://www.oschina.net/home/reg?goto_page=https%3A%2F%2Fmy.oschina.net%2Fu%2F4939618%2Fblog%2F5585451%3Fhmsr%3Dtoutiao.io%26utm_campaign%3Dtoutiao.io%26utm_medium%3Dtoutiao.io%26utm_source%3Dtoutiao.io&quot;&gt;注册&lt;/a&gt;
                                                                        &lt;/ul&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        
                
                
        
                &lt;/div&gt;&lt;/body&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7b5c63668bd5b4698caf7f9102d6e6b9</guid>
<title>精进 JavaScript ｜ 这些手写你都会吗 ？</title>
<link>https://toutiao.io/k/d7k5x0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道今年大家有没有感受到来自互联网的“寒气”，至少我是感受到了，面试的时候手写代码时很常见很常见的事情了。有时候没遇到过还真一时半会写不出来，企业招聘的要求也是越来越高，尤其是一些大厂会对 JS 的功底有着更加苛刻的要求，所以学会手写常见的 JS 模块好像已经快变为一个基本技能了，也慢慢变为我们手写 webpack 手写 mini-vue 的一个 &lt;code&gt;coding&lt;/code&gt; 基础 了。当然我们也不完全是为了去准备面试而去学习这些常见模块。死磕这些难啃的骨头之后，你会从中学到很多优秀的思想，对你的职业生涯也是很有帮助的。而且阅读代码本身就是一个很好的习惯，读懂并且理解写代码人的思维逻辑更加重要。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文中涉及到的手写模块，大多数都是从网上的博客、面筋、牛客网以及自己的面试经验借鉴而来的。希望能对你有个帮助。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础手写&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;全排列（力扣原题）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要求以数组的形式返回字符串参数的所有排列组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;字符串参数中的字符无重复且仅包含小写字母&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;返回的排列组合数组不区分顺序&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const _permute = &lt;span&gt;string&lt;/span&gt; =&amp;gt; {&lt;br/&gt;  const result = []&lt;br/&gt;  const map = new Map()&lt;br/&gt;  const dfs = (&lt;span&gt;path&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;path&lt;/span&gt;.length === &lt;span&gt;string&lt;/span&gt;.length) {&lt;br/&gt;      result.push(&lt;span&gt;path&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (let i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;string&lt;/span&gt;.length; i++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (map.get(&lt;span&gt;string&lt;/span&gt;[i])) continue&lt;br/&gt;      map.set(&lt;span&gt;string&lt;/span&gt;[i], &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;path&lt;/span&gt; += &lt;span&gt;string&lt;/span&gt;[i]&lt;br/&gt;      dfs(&lt;span&gt;path&lt;/span&gt;)&lt;br/&gt;      &lt;span&gt;path&lt;/span&gt; = &lt;span&gt;path&lt;/span&gt;.substring(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;path&lt;/span&gt;.length - &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;      map.set(&lt;span&gt;string&lt;/span&gt;[i], &lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  dfs(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;console.&lt;span&gt;log&lt;/span&gt;(_permute(&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;)) // [ &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;acb&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;bac&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;bca&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;cab&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;cba&#x27;&lt;/span&gt; ]&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 target 为基本数据类型直接返回 false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断 Fn.prototype 是否在 target 的隐式原型链上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _instanceof = &lt;span&gt;(&lt;span&gt;target, Fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) || target === &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; proto = target.__proto__&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (proto === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (proto === Fn.prototype) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    proto = proto.__proto__&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;() &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; A()&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(_instanceof(a, A)) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(_instanceof(&lt;span&gt;1&lt;/span&gt;, A)) &lt;span&gt;// false&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.map&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;map 中的 exc 接受三个参数，分别是: 元素值、元素下标和原数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;map 返回的是一个新的数组，地址不一样&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 这里不能直接使用箭头函数，否则无法访问到 this&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._map = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = []&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    result[index] = exc(item, index, arr)&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;).fill(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a.map(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; item * index + &lt;span&gt;1&lt;/span&gt;)) &lt;span&gt;// [1,3]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(a._map(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; item * index + &lt;span&gt;1&lt;/span&gt;))&lt;span&gt;// [1,3]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.filter&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;filter 中的 exc 接受三个参数，与map一致，主要实现的是数组的过滤功能，会根据 exc 函数的返回值来判断是否“留下”该值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;filter 返回的是一个新的数组，地址不一致。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._filter = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = []&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item, index, arr&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (exc(item, index, arr)) {&lt;br/&gt;      result.push(item)&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; b = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b._filter(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt; item % &lt;span&gt;2&lt;/span&gt; === &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// [ 4, 6, 2, 8, 20 ]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array.prototype.reduce&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;reduce 接受两个参数，第一个为 exc 函数，第二个为初始值，如果不传默认为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;reduce 最终会返回一个值，当然不一定是 Number 类型的，取决于你是怎么计算的，每次的计算结果都会作为下次 exc 中的第一个参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Array&lt;/span&gt;.prototype._reduce = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;exc, initial = &lt;span&gt;0&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; result = initial&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.forEach(&lt;span&gt;(&lt;span&gt;item&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    result = exc(result, item)&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b.reduce(&lt;span&gt;(&lt;span&gt;pre, cur&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// 55&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(b._reduce(&lt;span&gt;(&lt;span&gt;pre, cur&lt;/span&gt;) =&amp;gt;&lt;/span&gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;// 55&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Object.create&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MDN&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; Object.create() 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Object&lt;/span&gt;.prototype._create = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;proto&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Fn = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{ }&lt;br/&gt;  Fn.prototype = proto&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Fn()&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;() &lt;/span&gt;{ }&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = &lt;span&gt;Object&lt;/span&gt;.create(A)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = &lt;span&gt;Object&lt;/span&gt;._create(A)&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(obj.__proto__ === A) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(obj.__proto__ === A) &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Function.prototype.call&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Function&lt;/span&gt;.prototype._call = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;ctx, ...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 如果不为空，则需要进行对象包装&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; o = ctx == &lt;span&gt;undefined&lt;/span&gt; ? &lt;span&gt;window&lt;/span&gt; : &lt;span&gt;Object&lt;/span&gt;(ctx)&lt;br/&gt;  &lt;span&gt;// 给 ctx 添加独一无二的属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; key = &lt;span&gt;Symbol&lt;/span&gt;()&lt;br/&gt;  o[key] = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 执行函数，得到返回结果&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = o[key](...args)&lt;br/&gt;  &lt;span&gt;// 删除该属性&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;delete&lt;/span&gt; o[key]&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;11&#x27;&lt;/span&gt;,&lt;br/&gt;  fun() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.name)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;22&#x27;&lt;/span&gt; }&lt;br/&gt;obj.fun() &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;obj.fun.call(obj2) &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;obj.fun._call(obj2) &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Function.prototype.bind&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; obj = {&lt;br/&gt;  name: &lt;span&gt;&#x27;11&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    console.log(&lt;span&gt;this&lt;/span&gt;.name)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;Function.prototype._bind = function (ctx, ...args) {&lt;br/&gt;  &lt;span&gt;// 获取函数体&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; _self = &lt;span&gt;this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 用一个新函数包裹，避免立即执行&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; bindFn = (...reset) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; _self.call(ctx, ...args, ...reset)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; bindFn&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj2 = { name: &lt;span&gt;&#x27;22&#x27;&lt;/span&gt; }&lt;br/&gt;obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; &lt;span&gt;// 11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn = obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;.&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;(obj2)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; fn2 = obj&lt;span&gt;.&lt;span&gt;fun&lt;/span&gt;.&lt;span&gt;_bind&lt;/span&gt;&lt;span&gt;(obj2)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;fn() &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;fn2() &lt;span&gt;// 22&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;New 关键字&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _new = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;constructor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 创建一个空对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; obj = {}&lt;br/&gt;  &lt;span&gt;// 原型链挂载&lt;/span&gt;&lt;br/&gt;  obj.__proto__ = &lt;span&gt;constructor&lt;/span&gt;.prototype;&lt;br/&gt;  // 将obj 复制给构造体中的 this，并且返回结果&lt;br/&gt;  const result = &lt;span&gt;constructor&lt;/span&gt;.call(obj)&lt;br/&gt;  // 如果返回对象不为一个对象则直接返回刚才创建的对象&lt;br/&gt;  return typeof result === &#x27;object&#x27; &amp;amp;&amp;amp; result !== null ? : result : obj&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浅拷贝&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _shallowClone = target =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 基本数据类型直接返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (typeof target === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; &amp;amp;&amp;amp; target !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// 获取target 的构造体&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt; = target.&lt;span&gt;constructor&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果构造体为以下几种类型直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (/^(Function|RegExp|Date|Map|Set)$/i.test(&lt;span&gt;constructor&lt;/span&gt;.name)) &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;    &lt;span&gt;// 判断是否是一个数组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; cloneTarget = Array.isArray(target) ? [] : {}&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (prop &lt;span&gt;in&lt;/span&gt; target) {&lt;br/&gt;      &lt;span&gt;// 只拷贝其自身的属性&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (target.hasOwnProperty(prop)) {&lt;br/&gt;        cloneTarget[prop] = target[prop]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cloneTarget&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;深拷贝&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路和浅拷贝一致，只不过需要注意几点&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;函数 正则 日期 ES6新对象 等不是直接返回其地址，而是重新创建&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;需要避免出现循环引用的情况&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; _completeDeepClone = &lt;span&gt;(&lt;span&gt;target, map = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeakMap&lt;/span&gt;(&lt;/span&gt;)) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 基本数据类型，直接返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; target !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; || target === &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; target&lt;br/&gt;  &lt;span&gt;// 函数 正则 日期 ES6新对象,执行构造题，返回新的对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;constructor&lt;/span&gt; = target.&lt;span&gt;constructor&lt;/span&gt;&lt;br/&gt;  if (/^(Function|RegExp|Date|Map|Set)$/i.test(&lt;span&gt;constructor&lt;/span&gt;.name)) return new &lt;span&gt;constructor&lt;/span&gt;(target)&lt;br/&gt;  // map标记每一个出现过的属性，避免循环引用&lt;br/&gt;  if (map.&lt;span&gt;get&lt;/span&gt;(target)) return map.&lt;span&gt;get&lt;/span&gt;(target)&lt;br/&gt;  map.&lt;span&gt;set&lt;/span&gt;(target, true)&lt;br/&gt;  const cloneTarget = Array.isArray(target) ? [] : {}&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (prop &lt;span&gt;in&lt;/span&gt; target) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (target.hasOwnProperty(prop)) {&lt;br/&gt;      cloneTarget[prop] = _completeDeepClone(target[prop], map)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; cloneTarget&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;寄生组合式继承&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一图胜千言&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189655172413794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5ia5Fp3CiaRSV2rf79bMkoISz8sL76jAEopxbdfdicjKaWXrwTIGuFdhk5A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;580&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.name = name&lt;br/&gt;}&lt;br/&gt;Parent.prototype.getName = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.name&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt;(&lt;span&gt;name, age&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这里其实就等于 this.name = name&lt;/span&gt;&lt;br/&gt;  Parent.call(&lt;span&gt;this&lt;/span&gt;, name)&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.age = age&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;Son.prototype.getAge = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; () &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.age&lt;br/&gt;}&lt;br/&gt;Son.prototype.__proto__ = &lt;span&gt;Object&lt;/span&gt;.create(Parent.prototype)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; son1 = &lt;span&gt;new&lt;/span&gt; Son(&lt;span&gt;&#x27;shao&#x27;&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(son1.getName()) &lt;span&gt;// shao&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(son1.getAge()) &lt;span&gt;// 20&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发布订阅者模式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EventEmitter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// key: 事件名&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// value: callback [] 回调数组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events = {}&lt;br/&gt;  }&lt;br/&gt;  on(name, callback) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.events[name]) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.events[name].push(callback)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.events[name] = [callback]&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  off(name, callback) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.message[name]) &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!callback) {&lt;br/&gt;      &lt;span&gt;// 如果没有callback,就删掉整个事件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.message[name] = undefined;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.message[name] = &lt;span&gt;this&lt;/span&gt;.message[name].filter((item) =&amp;gt; item !== callback);&lt;br/&gt;&lt;br/&gt;  }&lt;br/&gt;  emit(name, ...args) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.events[name]) &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.events[name].forEach(cb =&amp;gt; cb(...args))&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;观察者模式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observerd&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;// 我要看看到底有多少人在观察俺&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList = []&lt;br/&gt;  }&lt;br/&gt;  addObserver(observer) {&lt;br/&gt;    &lt;span&gt;// 添加一个观察俺的人&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList.push(observer)&lt;br/&gt;  }&lt;br/&gt;  notify() {&lt;br/&gt;    &lt;span&gt;// 我要闹点动静，所有观察者都会知道这个信息，具体怎么做就是他们自己的事情了&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.observerList.forEach(&lt;span&gt;&lt;span&gt;observer&lt;/span&gt; =&amp;gt;&lt;/span&gt; observer.update())&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(doSome) {&lt;br/&gt;    &lt;span&gt;// 观察到小白鼠有动静之后，观察者做的事情&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.doSome = doSome&lt;br/&gt;  }&lt;br/&gt;  update() {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;.doSome)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ob1 = &lt;span&gt;new&lt;/span&gt; Observer(&lt;span&gt;&#x27;我是ob1，我观察到小白鼠有反应了，太饿了，我得去吃个饭了&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ob2 = &lt;span&gt;new&lt;/span&gt; Observer(&lt;span&gt;&#x27;我是ob2，我观察到小白鼠有反应了，我要继续工作！&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; xiaoBaiShu = &lt;span&gt;new&lt;/span&gt; Observerd()&lt;br/&gt;xiaoBaiShu.addObserver(ob1)&lt;br/&gt;xiaoBaiShu.addObserver(ob2)&lt;br/&gt;xiaoBaiShu.notify() &lt;span&gt;// .... .... &lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多说一句：怎么理解发布订阅者和观察者的区别呢 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实发布订阅者模式只有一个中间者，好像啥事情都需要它亲自来做。而且仔细观察的话，发布订阅者模式会存在一个事件名和事件的对应关系，今天可以发布天气预报，只有订阅了天气预报的才会被通知，订阅了 KFC疯狂星期四闹钟事件 的不会被提醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而观察者模式，等被观察者发出了一点动静（执行notify），所有观察者都会被通知。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节流&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节流函数（throttle）就是让事件处理函数（handler）在大于等于执行周期时才能执行，周期之内不执行，即事件一直被触发，那么事件将会按每小段固定时间一次的频率执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;throttle&lt;/span&gt;(&lt;span&gt;fn, delay = &lt;span&gt;300&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 这里始终记得字节二面的时候，建议我不写 flag 好家伙&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; isThrottling = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 核心思路，函数多次执行只有当 isThrottling 为 false 时才会进入函数体&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isThrottling) {&lt;br/&gt;      isThrottling = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        isThrottling = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;        fn.apply(&lt;span&gt;this&lt;/span&gt;, args)&lt;br/&gt;      }, delay)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;防抖&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事件响应函数在一段时间后才执行，如果这段时间内再次调用，则重新计算执行时间&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;debounce&lt;/span&gt;(&lt;span&gt;fn, delay = &lt;span&gt;300&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; timer = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每次进来都会清空定时器，所以在 delay 事件中重复执行之后执行最后一次&lt;/span&gt;&lt;br/&gt;    clearInterval(timer)&lt;br/&gt;    timer = setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      fn.apply(&lt;span&gt;this&lt;/span&gt;, args)&lt;br/&gt;    }, delay)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;once 函数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数返回结果会被缓存下来，只会计算一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const f = (x) =&amp;gt; x;&lt;br/&gt;const onceF = once(f);&lt;br/&gt;//=&amp;gt; 3&lt;br/&gt;onceF(3);&lt;br/&gt;//=&amp;gt; 3&lt;br/&gt;onceF(4);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; once = &lt;span&gt;(&lt;span&gt;fn&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; res, isFirst = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!isFirst) &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;    res = fn.call(&lt;span&gt;this&lt;/span&gt;, ...args)&lt;br/&gt;    isFirst = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; res&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;累加函数应用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现一个累加函数，下面的几种情况都能正确的调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;console.log(sum(1, 2)(3)()) // 6&lt;br/&gt;console.log(sum(1)(2)(3)()) // 6&lt;br/&gt;console.log(sum(1, 2, 4)(4)()) // 11&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;function &lt;span&gt;sum&lt;/span&gt;(&lt;span&gt;...args&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; &lt;span&gt;params&lt;/span&gt; = args&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; _sum = (...newArgs) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (newArgs.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;params&lt;/span&gt;.reduce((pre, cur) =&amp;gt; pre + cur, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;params&lt;/span&gt; = [...&lt;span&gt;params&lt;/span&gt;, ...newArgs]&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; _sum&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; _sum&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进阶&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现 repeat 方法&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;repeat&lt;/span&gt;(&lt;span&gt;fn, times, delay&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; times; i++) {&lt;br/&gt;      &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          fn.call(&lt;span&gt;this&lt;/span&gt;, ...args)&lt;br/&gt;          resolve()&lt;br/&gt;        }, delay)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; repeatFn = repeat(&lt;span&gt;console&lt;/span&gt;.log, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;// 函数调用四次，每次间隔 1s 打印 hello&lt;/span&gt;&lt;br/&gt;repeatFn(&lt;span&gt;&#x27;hello&#x27;&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现 Promise.all/race/allSettled/any&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Promise 身上的这些方法返回的都是一个 Promise&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Promise.resolve 接受一个 Promise，若非 promise 则将其变成功状态的 Promise&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 有一个失败则返回失败的结果，全部成功返回全成功的数组&lt;br/&gt;Promise.all = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    const result = []&lt;br/&gt;    let count = 0&lt;br/&gt;    if (promiseList.length === 0) {&lt;br/&gt;      resolve(result)&lt;br/&gt;      return&lt;br/&gt;    }&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        result[i] = res&lt;br/&gt;        count++&lt;br/&gt;        // 不能直接通过 result.length 进行比较，因为 会存在下标大的先赋值&lt;br/&gt;        // 例如 i = 3 第一个返回结果，此时数组变为[empty,empty,empty,res]&lt;br/&gt;        if (count === promiseList.length) {&lt;br/&gt;          resolve(result)&lt;br/&gt;        }&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        reject(e)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// 返回第一个成功或失败的结果&lt;br/&gt;Promise.race = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    if (promiseList.length === 0) {&lt;br/&gt;      return resolve([])&lt;br/&gt;    }&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        resolve(res)&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        reject(e)&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// 无论成功约否都返回，但是会添加一个 status 字段用于标记成功/失败&lt;br/&gt;Promise.allSettled = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    const result = []&lt;br/&gt;    let count = 0&lt;br/&gt;&lt;br/&gt;    const addRes = (i, data) =&amp;gt; {&lt;br/&gt;      result[i] = data&lt;br/&gt;      count++&lt;br/&gt;      if (count === promiseList.length) {&lt;br/&gt;        resolve(result)&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    if (promiseList.length === 0) return resolve(result)&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        addRes(i, { status: &#x27;fulfilled&#x27;, data: res })&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        addRes(i, { status: &#x27;rejected&#x27;, data: e })&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;// AggregateError，当多个错误需要包装在一个错误中时，该对象表示一个错误。&lt;br/&gt;// 和 Promise.all 相反，全部失败返回失败的结果数组，有一个成功则返回成功结果&lt;br/&gt;Promise.any = function (promiseList = []) {&lt;br/&gt;  return new Promise((resolve, reject) =&amp;gt; {&lt;br/&gt;    if (promiseList.length === 0) return resolve([])&lt;br/&gt;    let count = 0&lt;br/&gt;    const result = []&lt;br/&gt;    for (let i = 0; i &amp;lt; promiseList.length; i++) {&lt;br/&gt;      Promise.resolve(promiseList[i]).then(res =&amp;gt; {&lt;br/&gt;        resolve(res)&lt;br/&gt;      }).catch(e =&amp;gt; {&lt;br/&gt;        count++&lt;br/&gt;        result[i] = e&lt;br/&gt;        if (count === promiseList.length) {&lt;br/&gt;          reject(new AggregateError(result))&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整数千分位加逗号&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;1234567&lt;/span&gt; -&amp;gt; &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;234&lt;/span&gt;,&lt;span&gt;567&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;function toThousands(num) {&lt;br/&gt;  num = num.toString()&lt;br/&gt;  let result = &#x27;&#x27;&lt;br/&gt;  while (num.length &amp;gt; 3) {&lt;br/&gt;    result = &#x27;,&#x27; + num.substring(num.length - 3) + result&lt;br/&gt;    num = num.substring(0, num.length - 3)&lt;br/&gt;  }&lt;br/&gt;  result = num + result&lt;br/&gt;  return result&lt;br/&gt;}&lt;br/&gt;console.log(toThousands(1234567)) // 1,234,567&lt;br/&gt;console.log(toThousands(123456)) // 123,456&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;洗牌函数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几张牌张牌，用 js 来进行乱序排列，要保持公平性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const shuffle = (arr) =&amp;gt; {&lt;br/&gt;  // 不影响原来的数组&lt;br/&gt;  const result = [...arr]&lt;br/&gt;  for (let i = result.length; i &amp;gt; 0; i--) {&lt;br/&gt;    // 随机从 [0,i - 1] 产生一个 index, 将 i - 1 于 index 对应数组的值进行交换&lt;br/&gt;    const index = Math.floor(Math.random() * i);&lt;br/&gt;    [result[index], result[i - 1]] = [result[i - 1], result[index]]&lt;br/&gt;  }&lt;br/&gt;  return result&lt;br/&gt;}&lt;br/&gt;const arr = [1, 2, 3, 4, 5]&lt;br/&gt;console.log(shuffle(arr)) // [ 3, 1, 2, 5, 4 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 2, 3, 5, 1, 4 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 4, 2, 3, 1, 5 ]&lt;br/&gt;console.log(shuffle(arr)) // [ 5, 4, 2, 3, 1 ]&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;手写LRU&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的&lt;span&gt;页面置换算法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，选择最近最久未使用的页面予以淘汰。该算法赋予每个&lt;span&gt;页面&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;力扣地址&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} capacity&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; LRUCache = function(capacity) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.map = new Map()&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.capacity = capacity&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} key&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; {number}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;LRUCache.prototype.&lt;span&gt;get&lt;/span&gt; = function(key) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.has(key)){&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; value = &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;get&lt;/span&gt;(key)&lt;br/&gt;        &lt;span&gt;// 更新存储位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(key)&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;set&lt;/span&gt;(key,value)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} key &lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; {number} value&lt;br/&gt; * &lt;span&gt;@return&lt;/span&gt; {void}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;LRUCache.prototype.put = function(key, value) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.has(key)){&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(key)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.map.&lt;span&gt;set&lt;/span&gt;(key,value)&lt;br/&gt;    &lt;span&gt;// 如果此时超过了最长可存储范围&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.map.size &amp;gt; &lt;span&gt;this&lt;/span&gt;.capacity){&lt;br/&gt;        &lt;span&gt;// 删除 map 中最久未使用的元素&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.map.delete(&lt;span&gt;this&lt;/span&gt;.map.keys().next().value)&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更上一层楼&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Generator&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看下面输出的内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getResult&lt;/span&gt;() &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;getResult()&lt;br/&gt;&lt;span&gt;// 1 2 3 &lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何使用 Es6 中的 generator 实现类似的效果呢 ？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;* &lt;span&gt;getResult&lt;/span&gt;(&lt;span&gt;params&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;500&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            resolve(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;        }, &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; gen = getResult()&lt;br/&gt;&lt;span&gt;// gen.next().value 就是每一次 yield 之后返回的 Promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// gen.next() = {value: yeild 返回的数据,done: 迭代器是否走完}&lt;/span&gt;&lt;br/&gt;gen.next().value.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    gen.next().value.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        gen.next();&lt;br/&gt;    });&lt;br/&gt;});&lt;span&gt;// 依次打印 1 2 3&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将 gen.next() 封装一层，让其自己能够实现递归调用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const gen = getResult()&lt;br/&gt;function co(g) {&lt;br/&gt;  const nextObj = g.next();&lt;br/&gt;  // 递归停止条件：当迭代器迭代到最后一个 yeild &lt;br/&gt;  if (nextObj.done) {&lt;br/&gt;    return;&lt;br/&gt;  }&lt;br/&gt;  nextObj.value.then(()=&amp;gt;{&lt;br/&gt;    co(g)&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;co(gen)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;async-pool&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JS 控制并发请求， 参考文章 &lt;span&gt;mp.weixin.qq.com/s/yWOPoef9i…&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0262068965517241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5ia8fEuO4KawprmdxJ40dVib2OibM1aOez5b0pgykrYdHIpThwaPyNRXztw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;aysnc-pool 的基本使用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeout = &lt;span&gt;&lt;span&gt;i&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resolve(i), i));&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; asyncPool(&lt;span&gt;2&lt;/span&gt;, [&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;, &lt;span&gt;3000&lt;/span&gt;, &lt;span&gt;2000&lt;/span&gt;], timeout);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;asyncPool 这个函数接受三个参数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;poolLimit（数字类型）：表示限制的并发数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;array（数组类型）：表示任务数组；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提醒一下，promise.then 中的函数执行是一异步的，而赋值是同步的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;Promise&lt;/span&gt;.resolve().then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;console&lt;/span&gt;.log(a))&lt;br/&gt;&lt;span&gt;// 等价于 此时 a 等于一个 pending 状态的 promise&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; a = &lt;span&gt;Promise&lt;/span&gt;.resolve().then()&lt;br/&gt;a.then(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(a)&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手写实现，这部分可能会多花点时间。可以拷贝代码多调试几次就知道了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;async function asyncPool(poolLimit, array, iteratorFn) {&lt;br/&gt;  const ret = []; // 存储所有的异步任务&lt;br/&gt;  const executing = []; // 存储正在执行的异步任务&lt;br/&gt;  for (const item of array) {&lt;br/&gt;    // 调用iteratorFn函数创建异步任务&lt;br/&gt;    const p = Promise.resolve().then(() =&amp;gt; iteratorFn(item, array));&lt;br/&gt;    ret.push(p); // 保存新的异步任务&lt;br/&gt;&lt;br/&gt;    // 当poolLimit值小于或等于总任务个数时，进行并发控制&lt;br/&gt;    if (poolLimit &amp;lt;= array.length) {&lt;br/&gt;      // 当任务完成后，从正在执行的任务数组中移除已完成的任务&lt;br/&gt;      const e = p.then(() =&amp;gt; executing.splice(executing.indexOf(e), 1));&lt;br/&gt;      executing.push(e); // 保存正在执行的异步任务&lt;br/&gt;      if (executing.length &amp;gt;= poolLimit) {&lt;br/&gt;        await Promise.race(executing); // 等待较快的任务执行完成&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  return Promise.all(ret);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const timeout = i =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(() =&amp;gt; { console.log(i); resolve(i) }, i));&lt;br/&gt;// 当然,limit &amp;lt;= 0 的时候 我们可以理解为只允许一个请求存在 &lt;br/&gt;asyncPool(2, [1000, 5000, 3000, 2000], timeout).then(res =&amp;gt; {&lt;br/&gt;  console.log(res)&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共花费 6 s 时间，符合预期&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3256880733944954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5iaA9Su0TAlFl34CLT5Yxn7GSMibNYk6pcPQk1ia9GahlNOBjBFmsbjeZgw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收集这些手写的时候,自己也学到了很多东西，其实也是一个查漏补缺的过程。感谢你看到这里，点赞收藏 &lt;code&gt;offer ++&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>420ad5751925a7bd91211c86dd59783d</guid>
<title>秒杀系统设计套路，一套带走</title>
<link>https://toutiao.io/k/xtptia2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;你好，我是yes。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天来看看秒杀设计的套路，然后文末再送一波书~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;曾经有一家巨头公司和我们公司进行战略合作，经过双方的不懈努力及精诚合作，双方公司决定共同举办一场秒杀活动，我们公司提供优质商品和强有力的吸引价格以及使用场景，对方公司提供巨大的用户流量，再加上我们公司自己的用户流量，粗略估算下来有5000万的用户流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，当时我们的架构是完全支撑不了千万级流量的瞬时冲击的，但是双方老板已经达成协议就要快速干起来，而且给了一个基本无法完成的时间期限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于时间紧急，我们公司技术部召开了紧急会议，最终得出结论就是在原有架构基础上增加秒杀的相关接口，增加两个H5页面作为前端秒杀活动的承接页面，然后等待洪水般流量的到来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当秒杀活动真正开始时，流量远超过我们的估算，很快就卡住不动了，后台服务器内存、CPU、数据库负载等全满负荷了。期间，正常下单的用户也不能正常访问公司App以及下单。不难猜出，这个结果老板肯定是不满意的，要求必须解决，不能终止本次活动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最后的解决办法是：使用金钱来砸——立刻增加120多台云服务器来承载当时的秒杀活动。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;那次活动对于技术部门来讲无疑是一个痛苦的经历，也是一个“不光彩”的经历。于是，后面增加了针对秒杀架构的设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;225:661&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;“秒杀”这个词在电商行业中出现的频率较高，如京东或者淘宝平台的各种“秒杀”活动，最典型的就是“双11抢购”。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;“秒杀”是指在有限的时间内对有限的商品数量进行抢购的一种行为，这是商家以“低价量少”的商品来获取用户的一种营销手段。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 功能性需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;其实，整个秒杀的业务场景并不复杂，可即查看参与秒杀的商品信息，加上购买和支付的动作，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8692307692307693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLcxDhv8SGcCGiaYrpVcxy0XtVdCtl9OwFKUaxak8IeTiczgYNFmszedsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;秒杀业务最大的挑战在于3点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;瞬时：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;持续时间极短，对于热门且具备极强竞争力的商品通常只有一秒。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流量巨大：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为价格低廉，商品性价比高，而且正常买是需要很高的价格，所以才会吸引大量的用户来争抢。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数量有限：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为商品的低价且性价比高，所以只有很有限的商品数量参与秒杀。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;同时，在保证高并发流量承接的前提下，为了增强用户的体验和活动规则的公平性，以及防止遭到恶意破坏等，特此增加如下需求：&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;（1）用户在秒杀页面无需一直刷新“抢购”按钮，待秒杀活动开始时，按钮自动点亮。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）在公平以及防止恶意破坏的原则下，在下单之前增加验证码的录入，或者答题的相关环节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）库存不能出现问题，即不多扣也不少扣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）整个秒杀活动过程持续10分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 性能指标预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通过秒杀的需求描述可得出，当前秒杀活动主要需要预估三块的性能指标：存储容量、并发量、网络带宽。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）存储容量&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于是秒杀活动，且参与的商品基本都是低价高性价比的，数量是非常有限的。所以，在订单存储上基本不用去过多考虑。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）并发量&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;针对5000万用户平均每人访问2次，则并发量为每秒16.7万左右（5000w*2/10*60）,在预留一部分，可以预估到每秒25万左右（也可以进行double下）。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3）网络带宽&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在带宽方面，需要进行相关优化，采取数据传输越少越好，假设单条传输在0.5KB，则根据并发量预估网络带宽为：977Mb左右（25w*0.5KB=122MB*8bit=977Mb）。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 非功能性需求&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;做任何系统都要考虑非功能性需求，特别是公司的核心系统，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当前秒杀业务系统非功能性需求主要体现在如下几点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，在秒杀活动的整个持续期间内，都能对用户提供服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高性能&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，让每个用户都能感受到极快的秒杀响应，不能出现大批量用户延迟较高的现象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;可扩展&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，当流量比预期更高时，有平滑扩展的策略（也有部分产品设计成友好的拒绝策略）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;213:645&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;概要设计&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;通过对秒杀业务的本身认知以及上面提到的秒杀业务需求，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本次秒杀系统需要着重设计如下几点：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;（1）动静分离：如何保证用户在不刷新页面的情况下，依然能进行秒杀相关数据的获取且不会耽误秒杀活动的开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）流量分层，针对巨大流量，如何进行有效的防控，以免造成后台服务的不堪重负，以及如何避免前端页面的卡死。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）高可用：如何确保后台持续提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（4）扣减库存：如何有效扣减库存。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 动静分离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;动静分离是指，将静态页面与动态页面（或者静态数据与动态数据）解耦分离，用不同系统承载对应流量。这样可以提升整个服务访问性能和可维护性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商品秒杀页面的静态数据以及动态数据，均是不同的地方提供，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2601851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLWZQel9jBAc51WoLGMsibGgiclCNn33mEvXcFXaShuhI9uhELcicWmIziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态数据是指，页面中几乎不怎么变化的数据（即不依据用户的Cookie、基本信息、地域，及时间等各种属性来生成的数据），例如：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CSS和JavaScript中的静态文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;活动页中的HTML静态文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图片等相关资源文件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其他与用户信息无关的静态数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对于这种分离出来的静态数据可以进行缓存。在缓存之后，这些静态数据的访问效率就提高了，系统也更快了。可以使用代理服务器进行静态数据的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动态数据是指，依据当前用户属性动态生成的数据，在浏览淘宝首页时，每个用户所看到的商品都是不一样的，这就是淘宝的“千人千面”——针对不同用户做不同的推荐；在百度搜索中是依据不同用户的输入条件，以及用户的习惯给出不同的结果页。这其中的数据就是动态数据。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 流量分层&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在“秒杀”业务中，商品价格具有强大的吸引力，所以会受到很多用户的关注，但是商品数量是有限的。所以，在千万的用户中可能只有100人能得到商品，对于系统来说，有90%以上的流量属于无效流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“秒杀”业务希望有大量的用户来关注“秒杀”活动，但是在用户真正下单时又不能将这些流量全部放过，所以，需要设计一套高效的流量管控方案，来有效地控制请求流量，过滤掉没必要的流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于瞬时流量洪峰可以采用倒三角的分层级逐层控制方式，共分为CDN、反向代理（Nginx）、后端服务及DB这四个层级。接下来，就来看看每一层级是怎么控制流量的，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7956521739130434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL3TSO3icBGtribdu06owmFicQax3yKbBCzT8aStQe7RXnRtZ6dMHsdZ7Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 高可用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;要想在整个“秒杀”活动持续期间内，依然能对用户提供良好的体验，则秒杀系统架构在设计时不能设计成单节点的架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单节点是所有系统设计中的大忌，因为单节点系统意味着系统的不稳定性较高，可能会出现不可用的情况，会给企业带来直接的损失。在系统设计（特别是“秒杀”这类对高并发要求极高的系统）时，必须保证系统的高可用，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.526431718061674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLYLjNnTBrmtHeSzk2YkW5qibKtHPBZRibaEJicAMRH1qdfGwmC3M2mMibtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04. 扣减库存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于“秒杀”活动，通常，公司是不允许商品超卖（即下单成功的数量不能大于商品存存数量）的。一旦超卖，则会给公司造成损失。如果被恶意流量利用，则损失是巨大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库存对于电商平台来说是一个重要的业务指标，所以在技术上需要合理设计扣减库存，不能出现“超卖”现象。通常，扣减库存常有以下3种方式：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05. 系统架构设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;根据上面讨论，针对当前秒杀架构如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0804162724692525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLVX8uPpwthndkOjNCiaIzPyPds84BELbKYBWaHBs13XVHnJn1VSdpTgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如上架构比较简洁，主要分为以下5层。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;其部署架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4965437788018433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL6LDhP9qBd0XAReRWTiaYJEJtXJRIYGqMiaiceQ67DricHEY07iaibQT6VtZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;240:536&quot;&gt;&lt;span&gt;&lt;strong&gt;详细设计&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01. 动静分离设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实施动静分离架构可以采用“分而治之”的办法，即将动态数据和静态数据解耦，分别使用各自的架构系统来承载对应的流量：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;静态数据访问速度很快，而动态数据访问速度较慢。那么试想下，可以将需要动态获取的数据给提前生成好，然后使用静态页面加速技术来访问吗？如果这样可以，那动态数据访问的速度就变快了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样是可以的，需要用到比较流行的“页面静态化”技术。页面静态化技术是指，直接缓存HTTP连接，而不仅是缓存数据。如下图所示，代理服务器根据请求的URL直接将HTTP对应的响应头及响应消息体返回，流程简洁且高效。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49428208386277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLB5xyODNed3r6T3KGsBreof9dsvs5VXWvEzMhHpWj0YRJtqC8eodUEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. 流量分层设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;流量分层主要体现在对于CDN层、反向代理层、后端服务层以及数据层流量进行控制。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）CDN层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由动静分离技术可以想到：&lt;/span&gt;&lt;span&gt;应尽量将尽可能多的数据提前生成，然后将其放入CDN节点缓存中（因为CDN层在物理架构上离用户比较近）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，如果绝大部分的流量都在这一层获取数据，则到达后端的流量会减少很多，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6380165289256199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLgicNGP1MsKA4BA9t5IVKrW74X71oMictTONgxS3icdQbtOb9icj37XoRvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）反向代理层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在动静分离方案中，讲到通过“页面静态化技术”加速动态数据的获取，即提前将动态数据生成好，然后对其进行静态化处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，这里就可以依据页面静态化加速技术，通过后端服务Job的方式定时提前生成前端需要静态的数据；然后，将其发送到内容分发服务上；最后，分发服务会将这些静态化页面数据分发到所有的反向代理服务器上，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25031446540880503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLLUMPLMThXl7GASxtPOqRSVZZL4WJ5TMV13CA85h4hVOxFudU2iaw69g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”业务中，活动详情页上有一个倒计时的模块，用户可以看到当前“秒杀”活动还剩余多少时间开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种逻辑简单的功能可以直接使用Nginx来实现：&lt;/span&gt;&lt;span&gt;利用nginx-lua插件，使用lua脚本获取当前Nginx服务器的时间进行计算倒计时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，商品库存数据也可以通过Nginx直接访问分布式缓存来获取，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23796033994334279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLLwvtCia28ibUnucz7AMJNAumxyWwL54ibJTomKjejxYS1WMIkYTGkcgZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“秒杀”业务中的商品价格很低，对于用户有很大的吸引力，所以可能会有人利用“秒杀器”进行不公平竞争，且有可能存在竞争对手恶意刷请求的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果存在这样的情况，那本次活动就是有风险的，万一被恶意流量独占了库存，则会导致正常用户不能抢购商品，也有可能这种恶意的请求会对后端系统造成严重冲击，甚至造成后端系统瘫痪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种恶意请求，最好有一套机制能提前感知，并将恶意请求提前封存。&lt;/span&gt;&lt;span&gt;可以在Nginx层中控制；也可以在Nginx中配置用户的访问频率（例如每分钟只能访问10次）；还可以使用Lua脚本编写一些简单业务逻辑的接口，例如，通过调用接口直接封掉指定IP地址或UserAgent的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3）后端服务层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于服务层的流量控制，有以下几点建议：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;当“到达系统中的请求数”明显大于“系统能够处理的最大请求数”时，可以直接拒绝这些多余的请求，直接返回“秒杀”活动结束的信息。例如，活动开始时的商品库存是100，目前库存只剩50了，如果“每台服务器待处理的请求数”已经超过“商品总库存数（100）”了，则可以直接终止掉多余的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;4）数据库层流量控制&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;对于请求到数据中的流量，写入的流量就是真正下单成功的流量，即需要扣减库存的动作。有如下建议：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;对于数据库行锁的优化，可以通过将商品进行拆分来实现——增加ID，如下图所示。对于单一的“秒杀”活动这会得到显著效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7359307359307359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLOXuDChq3P3tFv9TEArpJsiclrqOXo43Mp3pa3QU6xgVvvf1d359VYRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从流量分层控制方案可看出，瞬时流量就像被漏斗过滤了似的，应尽量将数据和请求量一层一层地过滤掉。这种流量分层控制核心思想：在不同的层级中尽可能地过滤掉无效的请求，到达“倒三角”最末端的请求才是有效的请求。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;5）高可用&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在系统设计时想要做到高可用，避免单节点的一个小妙招：将服务无状态化。如果无法完全无状态化（如存储系统），则可以通过冗余多个备份节点的方案来避免单节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于篇幅原因，高可用此处就不再赘述，大家可以查看&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书里面针对高并发系统的真实设计案例，毫无保留的分享出了企业级高并发系统实战。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. 扣减库存设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;由于在“秒杀”场景中商品一般优惠力度很大，对用户很具有吸引力，所以，在这种场景中使用“下单扣库存”方式更为合适。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，大部分用户抱着“抢到就是赚到”的想法，基本都会去付款的，但如果真有竞争对手恶意下单不付款，那我们该怎么办？前面在流量管控中已经说到，可以对请求日志进行实时分析，让风控系统选择出恶意用户，然后将其封停。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，通过流量分层控制可以分层管控大量的“读”请求。但是，依然会有很大的流量进入真正的下单逻辑。对于这么大的流量，除前面说的数据库隔离外，还需要进一步优化库存，否则数据库读/写依然是系统的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来看看如何优化大流量“秒杀”场景中的库存数量扣减操作。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;1）利用缓存技术&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在“秒杀”场景中，如果只是一个扣减库存数量这样的简单流程，则可以先将库存数量直接放在缓存中，然后用分布式缓存（如Redis）的超高性能去应对这种瞬时流量洪峰下的系统挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用缓存是存在一定风险的，比如，缓存节点出现了异常，那库存数量该怎么算？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用缓存，不仅要考虑分布式缓存高可用（如何设计可以查看我的新书“高并发系统实战派”），还要考虑各种限流容错机制，以确保分布式缓存对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;2）异步处理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;如果是复杂的扣减库存（如涉及商品信息本身或牵连其他系统），则建议使用数据库进行库存数量的扣减，可以使用异步的方式来应对这种高并发的库存的更新。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;①在用户下单时，不立刻生成订单，而是将所有订单依次放入队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;②下单模块依据自身的处理速度，从队列中依次获取订单进行“下单扣库存”操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③在订单生成成功后，用户即可进行支付操作了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这种方式是针对“秒杀”场景的，依据“先到先得”原则来保证公平公正，所有用户都可以抢购，然后等待订单处理，最后生成订单（如果库存不足，则生成订单失败）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑，对用户来说体验不是很差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体排队逻辑如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15458015267175573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFLa41cdph5dv6871PMwNrzg8YnCUZFdGWBqAe4VECnYiaBdeHQOhFia8icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;239:554&quot;&gt;&lt;strong&gt;&lt;span&gt;搭建千万级流量“秒杀”系统需要哪些技术&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;前面介绍了千万级流量“秒杀”系统的基本架构、“秒杀”系统的设计原则、如何做动静分离方案和流量控制，以及扣减库存方面内容。这些都是设计高并发“秒杀”系统必须要考虑的。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;“秒杀”系统的流程并不复杂——只是一个“下单扣库存”的动作，但由于其独特的业务特点，所以在进行系统设计时不能大意。对于瞬时流量洪峰的高并发“秒杀”系统，我们需要什么技术呢？下面来总结一下。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（1）数据的静态化的技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;用来应对高并发读的请求，主要涉及以下内容，这些在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书中详细分享了真实使用场景已经技术方案：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各层级缓存的处理（即多级缓存的技术）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分布式缓存技术&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（2）负载均衡反向代理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（3）异步处理技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（4）系统架构设计技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;（5）系统监控技术&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;section data-id=&quot;89894&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section hm_fix=&quot;276:458&quot; data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTkJIfWr9IueKsXFibaLaicJkRxJibPxKsxQFia5bylsyH1fdOBgDd11ibnth10uSKyNh4zdIMSmu09N7Q/640?wx_fmt=gif&quot; data-w=&quot;100&quot;/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;好嘞，今天的内容就到这。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多相关内容可以看下&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《高并发系统实战派：集群、Redis缓存、海量存储、Elasticsearch、RocketMQ、微服务、持续集成等》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;aaa6c183-f442-4dc1-92db-54580b1bdb07&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_13430165&quot; data-appuin=&quot;3915176470&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_13430165&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3915176470&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;aaa6c183-f442-4dc1-92db-54580b1bdb07&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_13430165&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-0ad8d80e--1018824-623404592840175064/95602431520102022/53c7cf63a4faeafbc0c67b35134f7de0.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;高并发系统实战派：集群、Redis缓存、海量存储、Elasticsearch、RocketMQ、微服务、持续集成等&amp;quot;,&amp;quot;current_price&amp;quot;:10900,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[&amp;quot;京东配送&amp;quot;],&amp;quot;appuin&amp;quot;:&amp;quot;3915176470&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1,&amp;quot;templateId&amp;quot;:&amp;quot;list&amp;quot;}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span draggable=&quot;true&quot;&gt; 限时下单立减50！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3noBek33ibiaJc7xphKUrPIFL5M3d8ACOXe4GkRba44HU9hqWJAdmuFOnKScozdvic5T1s457aZOwiaPg/640?wx_fmt=jpeg&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span&gt;送书规则&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;截止10.30日晚上20点，留言点赞排名前四名，各得一本，包邮~&lt;/p&gt;&lt;p&gt;中奖者加我微信 yes_oba，私发我收件信息即可。&lt;/p&gt;&lt;p&gt;&lt;span&gt;刷赞或非此行业从事者，不予资格&lt;/span&gt;，最终解释权归我所有&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nFg1q2t7lb585CJWMxKLPPicBRCtrNt5keaQZQ96K1nBngXkhUPq6x70tCNbgicepqtpRuwsic4nUGUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;br/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a83bde9fec5f3bb66e84b93f7f987df5</guid>
<title>用 Numba 加速 Python 代码，变得像 C++ 一样快</title>
<link>https://toutiao.io/k/qinsbai</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numba 是 python 的即时（Just-in-time）编译器，即当你调用 python 函数时，你的全部或部分代码就会被转换为“即时”执行的机器码，它将以你的本地机器码速度运行！它由 Anaconda 公司赞助，并得到了许多其他组织的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Numba 的帮助下，你可以加速所有计算负载比较大的 python 函数（例如循环）。它还支持 numpy 库！所以，你也可以在你的计算中使用 numpy，并加快整体计算，因为 python 中的循环非常慢。你还可以使用 python 标准库中的 math 库的许多函数，如 &lt;code&gt;sqrt&lt;/code&gt; 等。有关所有兼容函数的完整列表，请查看 此处。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 为什么选择 Numba？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，当有像 cython 和 Pypy 之类的许多其他编译器时，为什么要选择 numba？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因很简单，这样你就不必离开写 python 代码的舒适区。是的，就是这样，你根本不需要为了获得一些的加速来改变你的代码，这与你从类似的具有类型定义的 cython 代码获得的加速相当。那不是很好吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你只需要添加一个熟悉的 python 功能，即添加一个包装器（一个装饰器）到你的函数上。类的装饰器也在开发中了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你只需要添加一个装饰器就可以了。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;cd ~/pythia/data&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; jit&lt;br/&gt;&lt;span&gt;@jit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# your loop or numerically intensive computations&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; x&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这仍然看起来像一个原生 python 代码，不是吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 如何使用 Numba？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numba 使用 LLVM 编译器基础结构 将原生 python 代码转换成优化的机器码。使用 numba 运行代码的速度可与 C/C++ 或 Fortran 中的类似代码相媲美。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是代码的编译方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5784090909090909&quot; data-w=&quot;880&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7To1xxsdFPzR9WxKZd2icgSicO8YIrkLaQQicWlQ6qzTzdPC6BEyPGaywFJwRVTEHb23UFYB3YibVTv1ng/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Python 函数被传入，优化并转换为 numba 的中间表达，然后在类型推断（type inference）之后，就像 numpy 的类型推断（所以 python float 是一个 float64），它被转换为 LLVM 可解释代码。然后将此代码提供给 LLVM 的即时编译器以生成机器码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以根据需要在运行时或导入时 生成 机器码，导入需要在 CPU（默认）或 GPU 上进行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 使用 numba 的基本功能&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;（只需要加上 @jit ！）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了获得最佳性能，numba 实际上建议在你的 jit 装饰器中加上 &lt;code&gt;nopython=True&lt;/code&gt; 参数，加上后就不会使用 Python 解释器了。或者你也可以使用 &lt;code&gt;@njit&lt;/code&gt;。如果你加上 &lt;code&gt;nopython=True&lt;/code&gt;的装饰器失败并报错，你可以用简单的 &lt;code&gt;@jit&lt;/code&gt; 装饰器来编译你的部分代码，对于它能够编译的代码，将它们转换为函数，并编译成机器码。然后将其余部分代码提供给 python 解释器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你只需要这样做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; njit, jit&lt;br/&gt;&lt;span&gt;@njit      # or @jit(nopython=True)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# your loop or numerically intensive computations&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 &lt;code&gt;@jit&lt;/code&gt; 时，请确保你的代码有 numba 可以编译的内容，比如包含库（numpy）和它支持的函数的计算密集型循环。否则它将不会编译任何东西，并且你的代码将比没有使用 numba 时更慢，因为存在 numba 内部代码检查的额外开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有更好的一点是，numba 会对首次作为机器码使用后的函数进行缓存。因此，在第一次使用之后它将更快，因为它不需要再次编译这些代码，如果你使用的是和之前相同的参数类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的代码是 可并行化 的，你也可以传递 &lt;code&gt;parallel=True&lt;/code&gt; 作为参数，但它必须与 &lt;code&gt;nopython=True&lt;/code&gt; 一起使用，目前这只适用于CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以指定希望函数具有的函数签名，但是这样就不会对你提供的任何其他类型的参数进行编译。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; jit, int32&lt;br/&gt;&lt;span&gt; @jit(int32(int32, int32))&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;# your loop or numerically intensive computations&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt; &lt;span&gt;# or if you haven t imported type names&lt;/span&gt;&lt;br/&gt; &lt;span&gt;# you can pass them as string&lt;/span&gt;&lt;br/&gt;&lt;span&gt; @jit( int32(int32, int32) )&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# your loop or numerically intensive computations&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你的函数只能接收两个 int32 类型的参数并返回一个 int32 类型的值。通过这种方式，你可以更好地控制你的函数。如果需要，你甚至可以传递多个函数签名。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7690763052208835&quot; data-w=&quot;498&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7To1xxsdFPzR9WxKZd2icgSicOqKWunZ4EPtpZ1gWVfCloibUuNy1AHMqnCDF0POHMeI4lNONX3VyT27Q/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以使用 numba 提供的其他装饰器：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@vectorize：允许将标量参数作为 numpy 的 ufuncs 使用，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@guvectorize：生成 NumPy 广义上的 &lt;code&gt;ufunc&lt;/code&gt;s，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@stencil：定义一个函数使其成为 stencil 类型操作的核函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@jitclass：用于 jit 类，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@cfunc：声明一个函数用于本地回调（被C/C++等调用），&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@overload：注册你自己的函数实现，以便在 &lt;code&gt;nopython&lt;/code&gt; 模式下使用，例如：&lt;code&gt;@overload（scipy.special.j0）&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numba 还有 &lt;strong&gt;Ahead of time&lt;/strong&gt;（AOT）编译，它生成不依赖于 Numba 的已编译扩展模块。但：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;它只允许常规函数（ufuncs 就不行），&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你必须指定函数签名。并且你只能指定一种签名，如果需要指定多个签名，需要使用不同的名字。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它还根据你的CPU架构系列生成通用代码。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. @vectorize 装饰器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用 @vectorize 装饰器，你可以对仅能对标量操作的函数进行转换，例如，如果你使用的是仅适用于标量的 python 的 &lt;code&gt;math&lt;/code&gt; 库，则转换后就可以用于数组。这提供了类似于 numpy 数组运算（ufuncs）的速度。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; jit, int32&lt;br/&gt;&lt;span&gt;@vectorize&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# Some operation on scalars&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以将 &lt;code&gt;target&lt;/code&gt; 参数传递给此装饰器，该装饰器使 target 参数为 &lt;code&gt;parallel&lt;/code&gt; 时用于并行化代码，为 &lt;code&gt;cuda&lt;/code&gt; 时用于在 cudaGPU 上运行代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@vectorize(target=&quot;parallel&quot;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# Some operation on scalars&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使 &lt;code&gt;target=“parallel”&lt;/code&gt; 或 &lt;code&gt;“cuda”&lt;/code&gt; 进行矢量化通常比 numpy 实现的代码运行得更快，只要你的代码具有足够的计算密度或者数组足够大。如果不是，那么由于创建线程以及将元素分配到不同线程需要额外的开销，因此可能耗时更长。所以运算量应该足够大，才能获得明显的加速。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7569169960474308&quot; data-w=&quot;506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fhujzoQe7To1xxsdFPzR9WxKZd2icgSicOCo5LIicolCGAXUc0UqRETZpOsGaXo6HdtF5LNncB2UExWLnzI116VRg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个视频讲述了一个用 Numba 加速用于计算流体动力学的Navier Stokes方程的例子：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 在GPU上运行函数&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以像装饰器一样传递 @jit 来运行 cuda/GPU 上的函数。为此你必须从 &lt;code&gt;numba&lt;/code&gt; 库中导入 &lt;code&gt;cuda&lt;/code&gt;。但是要在 GPU 上运行代码并不像之前那么容易。为了在 GPU 上的数百甚至数千个线程上运行函数，需要先做一些初始计算。实际上，你必须声明并管理网格，块和线程的层次结构。这并不那么难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在GPU上执行函数，你必须定义一个叫做 &lt;strong&gt;核函数&lt;/strong&gt; 或 &lt;strong&gt;设备函数&lt;/strong&gt; 的函数。首先让我们来看 &lt;strong&gt;核函数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于核函数要记住一些要点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;核函数在被调用时要显式声明其线程层次结构，即块的数量和每块的线程数量。你可以编译一次核函数，然后用不同的块和网格大小多次调用它。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;核函数没有返回值。因此，要么必须对原始数组进行更改，要么传递另一个数组来存储结果。为了计算标量，你必须传递单元素数组。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# Defining a kernel function&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; cuda&lt;br/&gt;&lt;span&gt;@cuda.jit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(a, result)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# Some cuda related computation, then&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# your computationally intensive code.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# (Your answer is stored in  result )&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，要启动核函数，你必须传入两个参数：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每块的线程数，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;块的数量。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;threadsperblock = &lt;span&gt;32&lt;/span&gt;&lt;br/&gt;blockspergrid = (array.size + (threadsperblock - &lt;span&gt;1&lt;/span&gt;)) // threadsperblock&lt;br/&gt;func[blockspergrid, threadsperblock](array)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个线程中的核函数必须知道它在哪个线程中，以便了解它负责数组的哪些元素。Numba 只需调用一次即可轻松获得这些元素的位置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@cuda.jit&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(a, result)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    pos = cuda.grid(&lt;span&gt;1&lt;/span&gt;)  &lt;span&gt;# For 1D array&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# x, y = cuda.grid(2) # For 2D array&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; pos &amp;amp;lt; a.shape[&lt;span&gt;0&lt;/span&gt;]:&lt;br/&gt;        result[pos] = a[pos] * (some computation)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了节省将 numpy 数组复制到指定设备，然后又将结果存储到 numpy 数组中所浪费的时间，Numba 提供了一些 函数 来声明并将数组送到指定设备，如：&lt;code&gt;numba.cuda.device_array&lt;/code&gt;，&lt;code&gt;numba.cuda。device_array_like&lt;/code&gt;，&lt;code&gt;numba.cuda.to_device&lt;/code&gt; 等函数来节省不必要的复制到 cpu 的时间（除非必要）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，&lt;strong&gt;设备函数&lt;/strong&gt; 只能从设备内部（通过核函数或其他设备函数）调用。比较好的一点是，你可以从 &lt;strong&gt;设备函数&lt;/strong&gt; 中返&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; numba &lt;span&gt;import&lt;/span&gt; cuda&lt;br/&gt;&lt;span&gt;@cuda.jit(device=True)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;device_function&lt;/span&gt;&lt;span&gt;(a, b)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还应该在这里查看 Numba 的 cuda 库支持的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Numba 在其 cuda 库中也有自己的原子操作，随机数生成器，共享内存实现（以加快数据的访问）等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ctypes/cffi/cython 的互用性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;cffi&lt;/code&gt; – 在 nopython 模式下支持调用 CFFI 函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ctypes&lt;/code&gt; – 在 nopython 模式下支持调用 ctypes 包装函数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cython 导出的函数是 可调用 的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>