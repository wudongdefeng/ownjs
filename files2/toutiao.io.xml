<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7ea4225a65b6c2ce167feb0143eea9c5</guid>
<title>全局视角看技术-Java多线程演进史</title>
<link>https://toutiao.io/k/zpdpuex</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东科技 文涛&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全文较长共6468字，语言通俗易懂，是一篇具有大纲性质的关于多线程的梳理，作者从历史演进的角度讲了多线程相关知识体系，让你知其然知其所以然。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;前言&lt;/h1&gt;

&lt;p&gt;2022年09月22日，JDK19发布了，此版本最大的亮点就是支持虚拟线程，从此轻量级线程家族再添一员大将。虚拟线程使JVM摆脱了通过操作系统调度线程的束缚，由JVM自身调度线程。其实早期sun在Solaris操作系统的虚拟机中实现过JVM调度线程，基于其复杂性，和可维护性考虑，最终都回归到了由操作系统调度线程的模式。&lt;/p&gt;

&lt;p&gt;长安归来锦衣客，昨日城南起新宅。回想这一路走来，关于多线程的概念令人烟花缭乱，网上相关讲解也不胜枚举，但总感觉缺少一个全局性的视角。为此笔者系统性的梳理了Java关于多线程的演进史，希望对你掌握多线程知识有帮助。&lt;/p&gt;

&lt;p&gt;本文不讲什么：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1 不讲某些技术点的详细实现原理，不拆解源码，不画图，如果从本文找到了你感兴趣的概念和技术可以自行搜索 2 不讲支持并发性的库和框架，如Quasar、Akka、Guava等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;本文讲什么&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1 讲JDK多线程的演进历史 2 讲演进中某些技术点的功能原理及背景，以及解决了什么问题 3 讲针对某些技术点笔者的看法，欢迎有不同看法的人在评论区讨论&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;里程碑&lt;/h1&gt;

&lt;p&gt;老规矩，先上个统计表格。其中梳理了历代JDK中关于线程相关的核心概念。在这里，做一个可能不太恰当的比喻，可以将多线程的演进映射到汽车上，多线程的演进分别经历了手动档时代(JDK1.4及以下)，自动档时代（JDK5-JDK18），自动驾驶时代(JDK19及以后)。这个比喻只为了告诉读者JDK5以后可以有更舒服姿势的驾驭多线程，JDK19以后更是突破了单纯的舒服，它给IO密集型服务的性能带来了质的飞跃。&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时代&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;发布时间&lt;/th&gt;
&lt;th&gt;核心概念&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;手动档&lt;/td&gt;
&lt;td&gt;JDK1.0&lt;/td&gt;
&lt;td&gt;1996-01-23&lt;/td&gt;
&lt;td&gt;Thread和Runnable&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;手动档&lt;/td&gt;
&lt;td&gt;JDK1.2&lt;/td&gt;
&lt;td&gt;1998-12-04&lt;/td&gt;
&lt;td&gt;ThreadLocal、Collections&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.5/5.0&lt;/td&gt;
&lt;td&gt;2004-09-30&lt;/td&gt;
&lt;td&gt;明确Java内存模型、引入并发包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.6/6.0&lt;/td&gt;
&lt;td&gt;2006-12-11&lt;/td&gt;
&lt;td&gt;synchronized优化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.7/7.0&lt;/td&gt;
&lt;td&gt;2011-07-28&lt;/td&gt;
&lt;td&gt;Fork/Join框架&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.8/8.0&lt;/td&gt;
&lt;td&gt;2014-03-18&lt;/td&gt;
&lt;td&gt;CompletableFuture、Stream&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK1.9/9.0&lt;/td&gt;
&lt;td&gt;2014-09-08&lt;/td&gt;
&lt;td&gt;改善锁争用机制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK10&lt;/td&gt;
&lt;td&gt;2018-03-21&lt;/td&gt;
&lt;td&gt;线程-局部管控&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动档&lt;/td&gt;
&lt;td&gt;JDK15&lt;/td&gt;
&lt;td&gt;2020-09-15&lt;/td&gt;
&lt;td&gt;禁用和废弃偏向锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动驾驶&lt;/td&gt;
&lt;td&gt;JDK19&lt;/td&gt;
&lt;td&gt;2022-09-22&lt;/td&gt;
&lt;td&gt;虚拟线程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-12-23-15aqQxE11X6ebN9CSQ.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;手动档时代&lt;/h1&gt;

&lt;p&gt;JDK1.4及以下笔者称之为多线程“手动档”的时代，也叫原生多线程时代。线程的操作还相对原生，没有线程池可用。研发人员必须手写工具避免频繁创建线程造成资源浪费，手动对共享资源加锁。也正是这个时代酝酿了许多优秀的多线程框架，最有名的被JDK5.0采纳了。&lt;/p&gt;

&lt;h2&gt;JDK 1.0 Thread和Runnable&lt;/h2&gt;

&lt;p&gt;1996年1月的JDK1.0版本，从一开始就确立了Java最基础的线程模型，并且，这样的线程模型再后续的修修补补中，并未发生实质性的变更，可以说是一个具有传承性的良好设计。抢占式和协作式是两种常见的进程/线程调度方式，操作系统非常适合使用抢占式方式来调度它的进程，它给不同的进程分配时间片，对于长期无响应的进程，它有能力剥夺它的资源，甚至将其强行停止。采用协作式的方式，需要进程自觉、主动地释放资源，在这种调度方式下,可能一个执行时间很长的线程使得其他所有需要CPU的线程”饿死”。Java hotspot虚拟机的调度方式为抢占式调用，因此Java语言一开始就采用抢占式线程调度的方式。JDK 1.0中创建线程的方式主要是继承Thread类或实现Runnable接口，通过对象实例的start方法启动线程，需要并行处理的代码放在run方法中，线程间的协作通信采用简单粗暴的stop/resume/suspend这样的方法。&lt;/p&gt;

&lt;p&gt;如何解释stop/resume/suspend的概念呢？就是主线程可以直接调用子线程的终止，暂停，继续方法。如果你小时候用过随身听，上面有三个按键，终止，暂停，继续。想象一下你正在同时听3个随身听，三个随身听就是三个子线程，你就是主线程，你可以随意控制这三个设备的启停。&lt;/p&gt;

&lt;p&gt;这一套机制有个致命的问题，就是容易发生死锁，原因在于当线程A锁定了某个资源，还未释放时，被主线程暂停了(suspend方法并不会释放锁)，此时线程B如果想占有这个资源，只能等待线程A执行继续操作（resume）后释放资源，否则将永远得不到，发生死锁。&lt;/p&gt;

&lt;h2&gt;JDK 1.2&lt;/h2&gt;

&lt;p&gt;粗暴的stop/resume/suspend机制在这个版本被禁止使用了，转而采用wait/notify/sleep这样的多条线程配合行动的方式。值得一提的是，在这个版本中，原子对象AtomicityXXX已经设计好了，主要是解决i++非原子性的问题。ThreadLocal和Collections的加入增加了多线程使用的姿势，因为这两项技术，笔者称它为Java的涡轮增压时代。&lt;/p&gt;

&lt;h3&gt;ThreadLocal&lt;/h3&gt;

&lt;p&gt;ThreadLocal是一种采用无锁的方式实现多线程共享线程不安全对象的方案。它并不能解决“银行账户或库存增加、扣减”这类问题，它擅长将具有“工具”属性的类，通过复本的方式安全的执行“工具”方法。典型的如SimpleDateFormat、库连接等。值得一提的是它的设计非常巧妙，想像一下如果让你设计，一般的简单思路是：在ThreadLocal里维护一个全局线程安全的Map，key为线程，value为共享对象。这样设计有个弊端就是内存泄露问题，因为该Map会随着越来越多的线程加入而无限膨胀，如果要解决内容泄露，必须在线程结束时清理该Map，这又得强化GC能力了，显然投入产出比不合适。于是，ThreadLocal就被设计成Map不由ThreadLocal持有，而是由Thread本身持有。key为ThreadLocal变量，value为值。每个Thread将所用到的ThreadLoacl都放于其中（当然此设计还有其它衍生问题在此不表，感兴趣的同学可以自行搜索）。&lt;/p&gt;

&lt;h3&gt;Collections&lt;/h3&gt;

&lt;p&gt;Collections工具类在这个版本被设计出来了，它包装了一些线程安全集合如SynchronizedList。在那个只有Hashtable、Vector、Stack等线程安全集合的年代，它的出现也是具有时代意义的。Collections工具的基本思想是我帮你将线程不安全的集合包装成线程安全的，这样你原有代码升级改造不必花很多时间，只需要在集合创建的时候用我提供方法初始化集合即可。比较像汽车的涡轮增压技术，在发动机排量不变的情况下，增加发动机的功率和扭矩。Java的涡轮增压时代到来了^_^&lt;/p&gt;

&lt;h1&gt;自动档时代&lt;/h1&gt;

&lt;h2&gt;JDK 5.0&lt;/h2&gt;

&lt;h3&gt;引入并发包&lt;/h3&gt;

&lt;p&gt;Doug Lea，中文名为道格·利。是美国的一个大学教师，大神级的人物，J.U.C就是出自他之手。JDK1.5之前，我们控制程序并发访问同步代码只能使用synchronized，那个时候synchronized的性能还没优化好，性能并不好，控制线程也只能使用Object的wait和notify方法。这个时候Doug Lea给JCP提交了JSR-166的提案，在提交JSR-166之前，Doug Lea已经使用了类似J.U.C包功能的代码已经三年多了，这些代码就是J.U.C的原型。&lt;/p&gt;

&lt;p&gt;J.U.C提供了原子化对象、锁及工具套装、线程池、线程安全容器等几大类工具。研发人员可灵活的使用任意能力搭建自己的产品，进可使用ReentrantLock搭建底层框架，退可直接使用现成的工具或容器进行业务代码编写。站在历史的角度去看，J.U.C在2004年毫无争议可以称为“尖端科技产品”。为Java的推广立下了悍马功劳。Java的自动档时代到来了，就好比自动档的汽车降低司机的门槛一样，J.U.C大大降低了程序员使用多线程的门槛。这是个开创了一个时代的产品。&lt;/p&gt;

&lt;p&gt;当然J.U.C同样存在一结瑕疵：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CPU开销大&lt;/strong&gt;：如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。&lt;/p&gt;

&lt;p&gt;解决方案：在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ABA问题&lt;/strong&gt;：如果一个值原来是A，变成了B，然后又变成了A，在CAS检查时会发现没有改变，但实际它已经改变，这就是ABA问题。大部分情况下ABA问题不会影响程序并发的正确性。&lt;/p&gt;

&lt;p&gt;解决方案：每个变量都加上一个版本号，每次改变时加1，即A —&amp;gt; B —&amp;gt; A，变成1A —&amp;gt; 2B —&amp;gt; 3A。Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳（stamp），从而避免ABA问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;只能保证一个共享变量原子操作&lt;/strong&gt;：CAS机制所保证的只是一个变量的原子性操作，而不能保证整个代码块的原子性。&lt;/p&gt;

&lt;p&gt;解决方案：比如需要保证3个变量共同进行原子性的更新，就不得不使用Synchronized了。还可以考虑使用AtomicReference来包装多个变量，通过这种方式来处理多个共享变量的情况。&lt;/p&gt;

&lt;h3&gt;明确Java内存模型&lt;/h3&gt;

&lt;p&gt;此版本的JDK重新明确了Java内存模型，在这之前，常见的内存模型包括连续一致性内存模型和先行发生模型。 对于连续一致性模型来说，程序执行的顺序和代码上显示的顺序是完全一致的。这对于现代多核，并且指令执行优化的CPU来说，是很难保证的。而且，顺序一致性的保证将JVM对代码的运行期优化严重限制住了。&lt;/p&gt;

&lt;p&gt;但是此版本JSR 133规范指定的先行发生（Happens-before）使得执行指令的顺序变得灵活：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在同一个线程里面，按照代码执行的顺序（也就是代码语义的顺序），前一个操作先于后面一个操作发生 对一个monitor对象的解锁操作先于后续对同一个monitor对象的锁操作 对volatile字段的写操作先于后面的对此字段的读操作 对线程的start操作（调用线程对象的start()方法）先于这个线程的其他任何操作 一个线程中所有的操作先于其他任何线程在此线程上调用 join()方法 如果A操作优先于B，B操作优先于C，那么A操作优先于C&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而在内存分配上，将每个线程各自的工作内存从主存中独立出来，更是给JVM大量的空间来优化线程内指令的执行。主存中的变量可以被拷贝到线程的工作内存中去单独执行，在执行结束后，结果可以在某个时间刷回主存： 但是，怎样来保证各个线程之间数据的一致性？JLS（Java Language Specification）给的办法就是，默认情况下，不能保证任意时刻的数据一致性，但是通过对synchronized、volatile和final这几个语义被增强的关键字的使用，可以做到数据一致性。&lt;/p&gt;

&lt;h2&gt;JDK 6.0 synchronized优化&lt;/h2&gt;

&lt;p&gt;作为“共和国长子”synchronized关键字，在5.0版本被ReentrantLock压过了风头。这个版本必须要扳回一局，因此JDK 6.0对锁做了一些优化，比如锁自旋、锁消除、锁合并、轻量级锁、所偏向等。本次优化是对“精细化管理”这个理念的一次诠释。没优化之前被synchronized加锁的对象只有两个状态：无锁，有锁（重量级锁）。优化后锁一共存在4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁、重量级锁。这几个状态随着竞争的情况逐渐升级，但是不能降级，目的是为了提高获取锁和释放锁的效率（笔者认为其实是太复杂了，JVM研发人员望而却步了）。&lt;/p&gt;

&lt;p&gt;这一次优化让synchronized扬眉吐气，自此再也不允许别人说它的性能比ReentrantLock差了。但好戏还在后头，偏向锁在JDK 15被废弃了（─.─||）。笔者认为synchronized吃亏在了它只是个关键字，JVM负责它底层的动作，到底应用程序加锁的时候什么样的姿势舒服，得靠JVM“猜”。ReentrantLock就不同了，它将这件事直接交给程序员去处理了，你希望公平那就用公平锁，你希望你的不公平，那你就用非公平锁。设计层面算是一种偷懒，但同时也是一种灵活。&lt;/p&gt;

&lt;h2&gt;JDK 7.0 Fork/Join框架&lt;/h2&gt;

&lt;p&gt;Fork/Join的诞生也是一个比较先进的产品，它的核心竞争力在于，支持递归式的任务拆解，同时将各任务结果进行合并。但它是一个既熟悉又陌生的技术，熟悉在于它被应用到各种地方，比如接下来JDK8.0要讲的CompletableFuture和Stream；陌生在于我们似乎很少在业务研发过程中使用到它。&lt;/p&gt;

&lt;p&gt;甚至有人甚至觉得它鸡肋。笔者的观点是，你如果是业务需求相关的研发，它是鸡肋的，因为基本用不到，大批数据量的场景有数仓那套工具，其它场景可以用线程池代替；如果你是中间件框架编写相关的研发，它不鸡肋，兴许会用到。中文互联网上很少有人质疑这项技术，但国外已经有人在讨论，感兴趣的可以直接跳转查阅 &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/343402/is-the-fork-join-framework-in-java-broken&quot;&gt;Is the Fork-Join framework in Java broken?&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;JDK 8.0&lt;/h2&gt;

&lt;p&gt;此版本的发布对于Java来说是划时代的，以至于现在全世界在运行的Java程序里此版本占据了一半以上。但多线程相关的更新不如JDK5.0那么具有颠覆性。此版本除了增加了一些原子对象之外 ，最亮眼的便是以下两项更新。&lt;/p&gt;

&lt;h3&gt;CompletableFuture&lt;/h3&gt;

&lt;p&gt;网上关于CompletableFuture相关介绍很多，大多是讲它原理及怎么用。但是笔者始终不明白一个问题：为什么在有那么多线程池工具的情况下，还会有CompletableFuture的出现，它解决了什么痛点？它的核心竞争力到底是什么？相信你如果进行过思考也会提出这个问题，没关系，笔者已经帮你找到了答案。&lt;/p&gt;

&lt;p&gt;结论：CompletableFuture的核心竞争力是&lt;strong&gt;任务编排&lt;/strong&gt;。CompletableFuture继承Future接口特性，可以进行并发执行任务等特性这些能力都是有可替代性的。但它的任务编排能力无可替代，它的核心API中包括了构造任务链，合并任务结果等都是为了任务编排而设计的。所以JDK之所以在此版本引入此框架，主要是解决业务开发中越来越痛的任务编排需求。&lt;/p&gt;

&lt;p&gt;最后多说一句，CompletableFuture底层使用了Fork/Join框架实现。&lt;/p&gt;

&lt;h3&gt;Stream&lt;/h3&gt;

&lt;p&gt;《架构整洁之道》里曾提到有三种编程范式，结构化编程（面向过程编程）、面向对象编程、函数式编程。Stream是函数式编程在Java语言中的一种体现，笔者认为，初级程序员向中级进阶的必经之路就是攻克Stream，初次接触Stream肯定特别不适应，但如果熟悉以后你将打开一个编程方式的新思路。作为研发人员经常混淆三个概念，函数式编程、Stream、Lambda表达式，总以为他们三个说的是一回事。以下是笔者的理解：&lt;/p&gt;

&lt;p&gt;•函数式编程是一种编程思想，各种编程语言中都有该思想的实践&lt;/p&gt;

&lt;p&gt;•Stream是JDK8.0的一个新特性，也可以理解新造了个概念，目的就是迎合函数式编程这种思想，通过Stream的形式可以在集合类上实现函数式编程&lt;/p&gt;

&lt;p&gt;•Lambda 表达式（lambda expression）是一个匿名函数，通过它可以更简洁高效的表达函数式编程&lt;/p&gt;

&lt;p&gt;那么说了这么多，Stream和多线程什么关系？Stream中的相关并行方法底层是使用了Fork/Join框架实现的。《Effective Java》中有一条相关建议“谨慎使用Stream并行”，理由就是因为所有的并行都是在一个通用的Fork/Join池中运行的，一个pipeline运行异常，可能损害其他不相关部分性能。&lt;/p&gt;

&lt;h2&gt;JDK 9.0&lt;/h2&gt;

&lt;h3&gt;改善锁争用机制&lt;/h3&gt;

&lt;p&gt;锁争用限制了许多Java多线程应用性能，新的锁争用机制改善了Java对象监视器的性能，并得到了多种基准测试的验证（如Volano）,这类测试可以估算JVM的极限吞吐量。实际中, 新的锁争用机制在22种不同的基准测试中都得到了出色的成绩。如果新的机制能在Java 9中得到应用的话, 应用程序的性能将会大大提升。简单的解释就是当多个线程发生锁争用时，优化之前：晚到的线程统一采用相同的标准流程进行锁等待。优化后：JVM识别出一些可优化的场景时直接让晚到的线程进行“VIP通道”式的锁抢占。&lt;/p&gt;

&lt;p&gt;详细解释请参考： &lt;a href=&quot;https://ionutbalosin.com/2018/06/contended-locks-explained-a-performance-approach/&quot;&gt;Contended locks explained – a performance approach&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;响应式流&lt;/h3&gt;

&lt;p&gt;响应式流(Reactive Streams)是一种以非阻塞背压方式处理异步数据流的标准，提供一组最小化的接口，方法和协议来描述必要的操作和实体。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;什么叫非阻塞背压？ 背压是back pressure的缩写，简单讲，生产者给消费者推送数据，当消费者处理不动了，告知生产者，此时生产者降低生产速率，此机制使用阻塞的方式实现最简单，即推送时直接返回压力数据。非阻塞方式实现增加了设计的复杂度，同时提高了性能。 PS:感觉背压这个词翻译的不好，不能望文生义。反压是不是更好^_^&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;为了解决消费者承受巨大的资源压力(pressure)而有可能崩溃的问题，数据流的速度需要被控制，即流量控制(flow control)，以防止快速的数据流不会压垮目标。因此需要反压即背压(back pressure)，生产者和消费者之间需要通过实现一种背压机制来互操作。实现这种背压机制要求是异步非阻塞的，如果是同步阻塞的，消费者在处理数据时生产者必须等待，会产生性能问题。&lt;/p&gt;

&lt;p&gt;响应式流(Reactive Streams)通过定义一组实体，接口和互操作方法，给出了实现非阻塞背压的标准。第三方遵循这个标准来实现具体的解决方案，常见的有Reactor，RxJava，Akka Streams，Ratpack等。&lt;/p&gt;

&lt;h2&gt;JDK 10 线程-局部管控&lt;/h2&gt;

&lt;p&gt;Safepoint及其不足：&lt;/p&gt;

&lt;p&gt;Safepoint是Hotspot JVM中一种让所有应用程序停止的一种机制。JVM为了做一些底层的工作，必须要Stop The World，让应用线程都停下来。但不能粗暴的直接停止，而是会给应用线程发送个指令信号告诉他，你该停下了。此时应用线程执行到一个Safepoint点时就会听从指令并响应。这也是为什么叫Safepoint。之所以加safe，是强调JVM要做一些全局的安全的事情了，所以给这个点加了个safe。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全局的安全的事情包括以下： 1、垃圾清理暂停 2、代码去优化（Code deoptimization）。 3、flush code cache。 4、类文件重新定义时（Class redefinition，比如热更新 or instrumentation)。 5、偏向锁的取消（Biased lock revocation）。 6、各种debug操作(比如： 死锁检查或者stacktrace dump等)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而，让所有线程都到就近的safepoint停下来本身就需要较长的时间。而且让所有线程都停下来是不是显得太过鲁莽和专断了呢。为此Java10就引入了一种可以不用stop all threads的方式，就是线程-局部管控（Thread Local Handshake）。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;比如以下是不需要stop所有线程就可以搞定的场景： 1、偏向锁撤销。这个事情只需要停止单个线程就可以撤销偏向锁，而不需要停止所有的线程。 2、减少不同类型的可服务性查询的总体VM延迟影响，例如获取具有大量Java线程的VM上的所有线程的stack trace可能是一个缓慢的操作。 3、通过减少对信号（signals）的依赖来执行更安全的stack trace采样。 4、使用所谓的非对称Dekker同步技术，通过与Java线程握手来消除一些内存障碍。 例如，G1和CMS里使用的“条件卡标记码”（conditional card mark code），将不再需要“内存屏障”这个东东。这样的话，G1发送的“写屏障（write barrier）”就可以被优化， 并且那些尝试要规避“内存屏障”的分支也可以被删除了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;JDK 15 禁用和废弃偏向锁&lt;/h2&gt;

&lt;p&gt;为什么要废弃偏向锁？偏向锁在过去带来的的性能提升，在现在看来已经不那么明显了。受益于偏向锁的应用程序，往往是使用了早期 Java 集合 API的程序（JDK 1.1），这些 API（Hashtable 和 Vector） 每次访问时都进行同步。JDK 1.2 引入了针对单线程场景的非同步集合（HashMap 和 ArrayList），JDK 1.5 针对多线程场景推出了性能更高的并发数据结构。这意味着如果代码更新为使用较新的类，由于不必要同步而受益于偏向锁的应用程序，可能会看到很大的性能提高。此外，围绕线程池队列和工作线程构建的应用程序，性能通常在禁用偏向锁的情况下变得更好。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;以下以使用了Hashtable 和 Vector的API实现： &lt;em&gt;java.lang.Classloader&lt;/em&gt; &lt;em&gt;uses Vector&lt;/em&gt; &lt;em&gt;java.util.Properties&lt;/em&gt; &lt;em&gt;extends Hashtable&lt;/em&gt; &lt;em&gt;java.security.Provider&lt;/em&gt; &lt;em&gt;extends Properties&lt;/em&gt; &lt;em&gt;java.net.URL&lt;/em&gt; &lt;em&gt;uses Hashtable&lt;/em&gt; &lt;em&gt;java.net.URConnection&lt;/em&gt; &lt;em&gt;uses Hashtable&lt;/em&gt; &lt;em&gt;java.util.ZipOutputStream&lt;/em&gt; &lt;em&gt;uses Vector&lt;/em&gt; &lt;em&gt;javax.management.timer.TimerMBean&lt;/em&gt; &lt;em&gt;has Vector on the interface&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1&gt;自动驾驶时代&lt;/h1&gt;

&lt;p&gt;虚拟线程使Java进入了自动驾驶时代。很多语言都有类似于“虚拟线程”的技术，比如Go、C#、Erlang、Lua等，他们称之为“协程”。这次java没有新增任何关键字，甚至没有新增新的概念，虚拟线程比起goroutine，协程，要好理解得多，看这名字就大概知道它在做啥了。&lt;/p&gt;

&lt;h2&gt;JDK 19 虚拟线程&lt;/h2&gt;

&lt;p&gt;传统Java中的线程模型与操作系统是 1:1 对应的，创建和切换线程代价很大，受限于操作系统，只能创建有限的数量。当并发量很大时，无法为每个请求都创建一个线程。使用线程池可以缓解问题，线程池减少了线程创建的消耗，但是也无法提升线程的数量。假如并发量是2000，线程池只有1000个线程，那么同一时刻只能处理1000个请求，还有1000个请求是无法处理的，可以拒绝掉，也可以使其等待，直到有线程让出。&lt;/p&gt;

&lt;p&gt;虚拟线程的之前的方案是采用异步风格。已经有很多框架实现了异步风格的并发编程（如Spring5的Reactor），通过线程共享来实现更高的可用性。原理是通过线程共享减少了线程的切换，降低了消耗，同时也避免阻塞，只在程序执行时使用线程，当程序需要等待时则不占用线程。异步风格确实有不少提升，但是也有缺点。大部分异步框架都使用链式写法，将程序分为很多个步骤，每个步骤可能会在不同的线程中执行。你不能再使用熟悉的 ThreadLocal 等并发编程相关的API，否则可能会有错误。编程风格上也有很大的变化，比传统模式的编程风格要复杂很多，学习成本高，可能还要改造项目中的很多已有模块使其适配异步模式。&lt;/p&gt;

&lt;p&gt;虚拟线程的实现原理和一些异步框架差不多，也是线程共享，当然也就不需要池化。在使用时你可以认为虚拟线程是无限充裕的，你想创建多少就创建多少，不必担心会有问题。不仅如此，虚拟线程支持 debug，并且能被 Java 相关的监控工具所支持，这很重要。虚拟线程会使你程序的内存占用大幅降低，所有IO密集型应用，比如Web Servers，都可以在同等硬件条件下，大幅提升IO的吞吐量。原来1G内存，同时可以host 1000个访问，使用虚拟线程后，按照官方的说法，能轻松处理100万的并发，具体到业务场景上能否支撑还要看压力测试，但是我们打个折扣，10万应该能够轻松实现，而你不需要为此付出任何的代价，可能连代码都不用改。因为虚拟线程可以使得你保持传统的编程风格，也就是一个请求一个线程的模式，像使用线程一样使用虚拟线程，程序只需要做很少的改动。虚拟线程也没有引入新的语法，可以说学习和迁移成本极低。&lt;/p&gt;

&lt;p&gt;值得一提的是虚拟线程底层依然使用了Fork/Join框架。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04a7de60ee051bff3d963f5a8ddc35a5</guid>
<title>程序员 “火柴棍式” 的烧脑面试题</title>
<link>https://toutiao.io/k/4a28i1d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;早期文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x01 - 从耗子叔博客看到的题目&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“火柴棍式” 的面试是在看耗子叔的博客时看到的，引入耗子叔的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;213&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;有时候，有些面试题是很是无厘头，这不，又有一个，还记得小时候玩的的“火柴棍游戏”吗，就是移动一根火柴棍改变一个图或字的游戏。程序面试居然也可以这么玩，看看下面这个火柴棍式的程序面试题吧。 &lt;/p&gt;&lt;p&gt;下面是一个C程序，其想要输出20个减号，不过，粗心的程序员把代码写错了，你需要把下面的代码修改正确，不过，你只能增加或是修改其中的一个字符，请你给出三种答案。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;int n = 20; &lt;/p&gt;&lt;p&gt;for(int i = 0; i &amp;lt; n; i--) {&lt;/p&gt;&lt;p&gt;    printf(&quot;-&quot;);&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E6%9C%89%E6%97%B6%E5%80%99%EF%BC%8C%E6%9C%89%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%A2%98%E6%98%AF%E5%BE%88%E6%98%AF%E6%97%A0%E5%8E%98%E5%A4%B4%EF%BC%8C%E8%BF%99%E4%B8%8D%EF%BC%8C%E5%8F%88%E6%9C%89%E4%B8%80%E4%B8%AA%EF%BC%8C%E8%BF%98%E8%AE%B0%E5%BE%97%E5%B0%8F%E6%97%B6%E5%80%99%E7%8E%A9%E7%9A%84%E7%9A%84%E2%80%9C%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%B8%B8%E6%88%8F%E2%80%9D%E5%90%97%EF%BC%8C%E5%B0%B1%E6%98%AF%E7%A7%BB%E5%8A%A8%E4%B8%80%E6%A0%B9%E7%81%AB%E6%9F%B4%E6%A3%8D%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%88%96%E5%AD%97%E7%9A%84%E6%B8%B8%E6%88%8F%E3%80%82%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E5%B1%85%E7%84%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%BF%99%E4%B9%88%E7%8E%A9%EF%BC%8C%E7%9C%8B%E7%9C%8B%E4%B8%8B%E9%9D%A2%E8%BF%99%E4%B8%AA%E7%81%AB%E6%9F%B4%E6%A3%8D%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%A7%E3%80%82%5Cn%5Cn%E4%B8%8B%E9%9D%A2%E6%98%AF%E4%B8%80%E4%B8%AAC%E7%A8%8B%E5%BA%8F%EF%BC%8C%E5%85%B6%E6%83%B3%E8%A6%81%E8%BE%93%E5%87%BA20%E4%B8%AA%E5%87%8F%E5%8F%B7%EF%BC%8C%E4%B8%8D%E8%BF%87%EF%BC%8C%E7%B2%97%E5%BF%83%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E6%8A%8A%E4%BB%A3%E7%A0%81%E5%86%99%E9%94%99%E4%BA%86%EF%BC%8C%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8A%8A%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BF%AE%E6%94%B9%E6%AD%A3%E7%A1%AE%EF%BC%8C%E4%B8%8D%E8%BF%87%EF%BC%8C%E4%BD%A0%E5%8F%AA%E8%83%BD%E5%A2%9E%E5%8A%A0%E6%88%96%E6%98%AF%E4%BF%AE%E6%94%B9%E5%85%B6%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AF%B7%E4%BD%A0%E7%BB%99%E5%87%BA%E4%B8%89%E7%A7%8D%E7%AD%94%E6%A1%88%E3%80%82%5Cn%5Cnint%26nbsp%3Bn%26nbsp%3B%3D%26nbsp%3B20%3B%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B0%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3Bn%3B%26nbsp%3Bi--)%7B%5Cn%26nbsp%3B%26nbsp%3B%26nbsp%3B%26nbsp%3Bprintf(%26quot%3B-%26quot%3B)%3B%5Cn%7D%3C%2Fp%3E%22%2C%22digestLen%22%3A234%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;开始以为是一些比较以前见过的一些变态题目，比如考察编译选项、数组越界之类的题目，结果没想到竟然是“脑筋急转弯”。在看答案之前，真的是花了点时间，才想出一种方法。看完答案以后恍然大悟，竟然可以这样，哈哈！晒一下耗子叔给出的答案。&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;112&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;//第一种解法：在for循环中给n加一个负号 &lt;/p&gt;&lt;p&gt;for(int i = 0; i &amp;lt; -n; i--) &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;//第二种解法：把 n 初始化成 -20 &lt;/p&gt;&lt;p&gt;int n = -20; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;//第三种解法：把for循环中的 i 初始化成40 &lt;/p&gt;&lt;p&gt;for(int i = 40; i &amp;lt; n; i--)&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%2F%2F%E7%AC%AC%E4%B8%80%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%BB%99n%E5%8A%A0%E4%B8%80%E4%B8%AA%E8%B4%9F%E5%8F%B7%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B0%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3B-n%3B%26nbsp%3Bi--)%5Cn%2F%2F%E7%AC%AC%E4%BA%8C%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E6%8A%8A%26nbsp%3Bn%26nbsp%3B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%90%26nbsp%3B-20%5Cnint%26nbsp%3Bn%26nbsp%3B%3D%26nbsp%3B-20%3B%5Cn%2F%2F%E7%AC%AC%E4%B8%89%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%9A%E6%8A%8Afor%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84%26nbsp%3Bi%26nbsp%3B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%9040%5Cnfor(int%26nbsp%3Bi%26nbsp%3B%3D%26nbsp%3B40%3B%26nbsp%3Bi%26nbsp%3B%26lt%3B%26nbsp%3Bn%3B%26nbsp%3Bi--)%3C%2Fp%3E%22%2C%22digestLen%22%3A138%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;0x02 - 对这种题目的看法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我把这个题目发到一个微信群里，给群友们看看，但是直接得到下面的答复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1199510403916768&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Bfv9smoHwtjkfIlWvF3iauBI4jdX3mndaBSXxYLbkgpXNy3Ym8ED2GgmOYnUa4DbD8POfZJv3p4zUNQPNxvvOHQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发出去之后，唯一一个接话的竟然这样说。其他的群友对这个问题直接无视。不知道他们为什么对这种搞怪的“脑筋急转弯”没兴趣！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉看到这样的答复也不奇怪吧，毕竟没啥用，第一没人这么写，第二也没有实际的意义。但是这竟然是面试题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想起以前学习 C 语言的时候，一个老师说过这么四句话，这几句话我印象深刻（尤其是第四句话，希望大家先收藏再观看，……&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_45@2x.png&quot; data-w=&quot;20&quot;/&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;熟练掌握 C 语言各种语法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;深入了解编译器对 C 语言编译的处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写出不受编译器限制的 C 代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;其他牛角尖问题一概无视&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上面的四句话，都不是原话，即使印象深刻也不知道到底是不是这四句话，但是大概就是这么个意思。从第四句话来看，这算不算牛角尖问题呢？不知道啊！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以前见过有的公司面试，就面试类似 ++/-- ，这种自增的题，有的学校考试也考这种题吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如 i ++ + ++ i 这样的。反正这样的题我是不会，而且更重要的是不同的编译器竟然结果不同。对这种运行结果依赖编译器的情况，我们称之为“编译器相关”。就是你别让我猜，你自己在编译器上跑吧！其实，C 语言标准里对于有些语法给出的说明就是，实现方自行处理，就是没有给出具体标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x03 - 剩下问题的答案&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实上面虽然这么说，但是我很无聊的看了看，类似“脑筋急转弯”题目的变形题，这些变形方式也是在耗子叔的博客上看的，题目如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;73&quot; data-source-title=&quot;https://coolshell.cn/articles/3961.html&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;其它相关的变种题如下： &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其输出21个减号 &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其只输出1个减号 &lt;/p&gt;&lt;p&gt;通过修改、增加一个字符，让其不输出减号&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%3Cp%3E%E5%85%B6%E5%AE%83%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8F%98%E7%A7%8D%E9%A2%98%E5%A6%82%E4%B8%8B%EF%BC%9A%5Cn%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E8%BE%93%E5%87%BA21%E4%B8%AA%E5%87%8F%E5%8F%B7%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E5%8F%AA%E8%BE%93%E5%87%BA1%E4%B8%AA%E5%87%8F%E5%8F%B7%5Cn%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9%E3%80%81%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%EF%BC%8C%E8%AE%A9%E5%85%B6%E4%B8%8D%E8%BE%93%E5%87%BA%E5%87%8F%E5%8F%B7%3C%2Fp%3E%22%2C%22digestLen%22%3A76%2C%22text%22%3A%22%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22https%3A%2F%2Fcoolshell.cn%2Farticles%2F3961.html%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;https://coolshell.cn/articles/3961.html&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;花了点时间试了试，还是搞出来了。不过时间也花得不短，超过十五分钟了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里给一下我的答案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.添加一个字符输出 21 个减号，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; ~i &amp;lt; n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，对变量 i 进行了取反操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.添加一个字符输出 1 个减号，代码如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &amp;amp;n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，对 n 进行了取地址运算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.修改一个字符，让其不输出减号，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; n = &lt;span class=&quot;code-snippet__number&quot;&gt;-20&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;-&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这里，将变量 n 初始化为了 -20。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;上面的问题中，不输出减号的方式还是&lt;/span&gt;&lt;span&gt;很容易找到多种方法的，&lt;/span&gt;&lt;span&gt;但是输出 1 &lt;/span&gt;&lt;span&gt;个减号和输出&lt;/span&gt;&lt;span&gt; 21 个减号，要找到多种方法&lt;/span&gt;&lt;span&gt;感觉比较复杂。而且，&lt;/span&gt;不同的语言解决起来方法不太一样，就比如输出 1 个减号，在 C 语言中我使用的是取地址运算，而其他语言就不行了，比如 Java、PHP 和 Python 就没有这个运算符了吧。我用 PHP 实现了下只输出一个 1 个减号，代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__variable&quot;&gt;$n&lt;/span&gt; = 2&amp;gt;0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; = 0; &lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; &amp;lt; &lt;span class=&quot;code-snippet__variable&quot;&gt;$n&lt;/span&gt;; &lt;span class=&quot;code-snippet__variable&quot;&gt;$i&lt;/span&gt; --) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;-&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面的代码中，我将 20 改成了 2&amp;gt;0 ，添加了一个符号。我真是觉得自己小时候的脑筋急转弯没白玩啊。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;0x04 - 最后……&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中规中矩的写代码挺好的，本来就很难写出优雅的代码，要是每天就想着写这种代码，也真的就是没谁了。好好写代码，面试、工作不是参加代码混乱大赛！！&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;img data-src=&quot;https://res.wx.qq.com/t/wx_fed/we-emoji/res/v1.3.10/assets/Expression/Expression_14@2x.png&quot; data-ratio=&quot;1&quot; data-w=&quot;20&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;2af7abf0-032e-41b0-a0b2-f1bbb5c92a20&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_10060770213143&quot; data-appuin=&quot;3243069781&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;2af7abf0-032e-41b0-a0b2-f1bbb5c92a20&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_10060770213143&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-6fa174af--1018824-7975090560325406147/23105240921122022/b7eff0a3125954d219c32e31f2511988.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;逆向分析实战冀云人民邮电出版社9787115590701 计算机与互联网书籍&amp;quot;,&amp;quot;current_price&amp;quot;:7390,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;templateId&amp;quot;:&amp;quot;card&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3243069781&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;努力成为一个初级程序员！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JHWsQdz8yVn3MVh22hia7NFoPyNJz4ZI7XUnMa9xM50TJRqPkWf7BRibQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1e729eef6657e0cfe96f20562ff873b</guid>
<title>从 CTO 视角来看：如何搭建运维/SRE 能力</title>
<link>https://toutiao.io/k/u6toh45</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;近期有很多文章在探讨运维岗位去留的问题，我主持的SRETalk公众号里也发了多个运维总监的观点，个人也和行业内挺多人做了交流，有些许小小的想法，记录下来，供各位CTO/CIO参考，作为运维/SRE的你如果觉得迷茫，也推荐你仔细读一下本文。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我自认为这是一个深度的思考了，可能枯燥，但对择业和团队搭建都会有些帮助。本文欢迎有理有据的讨论，不欢迎杠精，另外，很多事情其实也没有非黑即白，文章内容对你有些启发，对CXO们的决策带来新的思考，那就是极好的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，SRETalk的运维总监采访还会继续，还会有更多不同的观点持续输出，供大家参考，而我的观点，不一定对，也是仅供参考哈。&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;关于标题&lt;/h2&gt;&lt;p&gt;首先说一下标题，《如何搭建运维/SRE能力》，这里我没有写搭建团队，而是搭建能力，因为有些目标的达成未必一定需要自建团队，从成本、结果可预见性、长期投入维护的角度来看，需要慎重决策，决策错了，未来将是一地鸡毛，这个后文再展开。&lt;/p&gt;&lt;h2&gt;关于运维/SRE团队&lt;/h2&gt;&lt;p&gt;另外一点也要提前澄清，文中提到的运维/SRE团队都是为业务服务的，业务的成功是第一要务。有些运维团队做了一些产品在对外商业化输出，本身成了一条业务，这个另当别论，而且，以我在老东家的经验来看，运维/SRE团队这样的做法（对外商业化输出）不可取，尤其是在一个没有ToB基因、没有相应的ToB组织建设的公司。&lt;/p&gt;&lt;h2&gt;从哪里获取运维/SRE能力&lt;/h2&gt;&lt;p&gt;既然一切都是为了业务成功（不考虑业务，只考虑自己能否晋升能否忽悠老板的另当别论），我们就重点来看业务需要哪些运维能力（后文详细讲解），需要从哪里获取这些运维能力，典型的获取方式有三种。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3316831683168317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QMdm8cJjtkDibdfufcPMPj8mcgqBR3Vs2gNiaOFlGrBuk5ONZrkXEonuYVdicvQuPpJ7iaEDfmqxKvJ9EthXZUMvjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;h3&gt;自建团队&lt;/h3&gt;&lt;p&gt;首先是通过自建团队提供相关能力，这个方式大家最为熟悉，自建的团队对业务的交付物通常包括两部分：产品+服务。先说产品：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果产品需求是通用需求，产品大概率是直接使用的开源项目。需要考虑开源项目的持久性（开源项目研发人员是否有商业公司做收入上的支持，个人开源项目大都会死在没有收入上）、活跃性（项目是否已经多年未更新？提的issue、pr是否及时处理？通常一周内处理就可以看做是活跃的）、生态繁荣性（是否有很多人参与做贡献？很多公司投入使用？）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开源项目是否要二次开发？如果二次开发的代码可以merge回主干，通常意味着二次开发的代码具有通用性，得到了开源项目团队的认可。如果无法merge回主干，后面的维护就是麻烦事了，尤其是人才变动之后，一地鸡毛。基于开源项目的API做一些胶水代码，和内部系统做整合，通常是可以的，毕竟没有改造开源代码，后面开源项目升级还是可以跟得上的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当然也有不用开源完全自研的（只是使用一些开源的lib库，核心产品逻辑自研），这种要慎重，如果开源社区没有相关的产品，那只能自研，但是自研之后就要考虑长期维护的问题，研发人员通常喜欢做从0到1的事情，后面收益小了，无法晋升涨薪，就容易变动。而运维这个赛道，开源社区的产品琳琅满目，需要自研的产品可能屈指可数，三思。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其次就是服务，这里所谓的服务，说的是向业务侧输出的专家经验。比如自建团队做了一款监控产品，这个团队需要给公司内部的“客户”输出监控的最佳实践、监控产品出问题的时候需要这个团队快速解决。其实，公司内部的中后台团队需要有很强的服务意识，同时还得了解行业最佳实践，否则，就容易被业务牵着鼻子走，走出了和行业最佳实践背道而驰的路子，后面，就都是问题了。&lt;/p&gt;&lt;p&gt;服务的核心，是靠人（当然，能把最佳实践固化到产品里，那自然是极好的），作为管理者，要想让这个团队输出好的服务，就需要考虑很多人的问题，比如：能否招到相关的人才、能否留住相关的人才（发展空间、薪资等）、自建团队每个方向至少两个人互备，成本是否可以接得住。&lt;/p&gt;&lt;h3&gt;第三方供应商&lt;/h3&gt;&lt;p&gt;通过第三方供应商来获取运维能力，是另一个路子，供应商的交付物显然也包括两部分：产品+服务。产品分为开源、闭源两种类型，有哪些考量点呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;开源的产品通常会有更多的用户、更多的场景来打磨，但是一些长尾需求，通常不开源，至于原因么，要么是开源团队把这些长尾需求作为收费项，要么就是开源团队觉得这些长尾需求不够通用，不值得放到产品里。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;闭源的产品，通常受众小，没有太多的开源用户帮助打磨产品，就需要经过较长时间的商业化客户打磨，或者，闭源产品的供应商有很强大的质量管理体系，对产品有完备的测试，这就需要找那些家大业大的供应商了，而且，测试人员和终端用户毕竟是两类人群，商业客户的打磨是不可或缺的，只是，如果供应商有强大的质量保障团队，会让这个打磨过程变得短一些。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不管是开源还是闭源，供应商都是带着产品来的，作为甲方可以直接测试，来看产品匹配度，很快就可以得到反馈，而自建团队来做的话，可能需要几个月甚至一两年的时间来开发，业务可能等不起，开发完了之后产品是否真的符合预期，又有很多因素决定，结果具有不可预见性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其次是服务，供应商相比自建的团队，通常会有优势。原因如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;因为供应商见识了更多的客户场景，而ToB公司，长期的行业Know-How的积累，是这个公司的核心竞争力，供应商会不断的从优秀客户那里汲取经验，反哺给那些不那么先进的客户，良性循环，多方共赢。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;也是因为供应商见识了更多的场景，可以对产品做更好的抽象，可以让产品更通用，更像一个产品，而自建团队做的产品，通常更偏工具，无意冒犯，我说的是通常。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;供应商之所以在运维这个赛道创业，大概率是在这个赛道有些建树的，相比自建团队，供应商的顶层认知通常会好一些，你真的去招人的时候就会发现了，最牛逼的那群人，要么创业了，要么太贵了，要么不愿意来。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;另外说一下成本问题，供应商的收费大概率是比自己招人（前提是招到合适的人）来的划算，否则的话，商业逻辑不成立。这个道理显而易见不再赘述。&lt;/p&gt;&lt;p&gt;从第三方供应商这里获取运维能力，看起来是碾压自建团队的，所以，后面的文章还用读么？其实也不尽然，对于某个运维能力，到底更看重的是产品能力，还是服务能力，你最需要的是产品能力还是服务能力，需要 case by case 的看，后文，我会从业务侧需要的各个方面的运维能力分别拆解。&lt;/p&gt;&lt;h2&gt;业务需要哪些技术支撑能力&lt;/h2&gt;&lt;p&gt;运维本质是一类技术支撑能力，跟基础架构团队很像，有些活放到运维团队是可以的，放到基础架构团队问题也不大，甚至有些公司直接把这类人放到业务研发团队，我们暂且不管分工的问题，先来梳理一下业务需要什么样的技术支撑能力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30649038461538464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QMdm8cJjtkDibdfufcPMPj8mcgqBR3Vs229Bcj2E5T5uy5svsnJ7J1GzCk2ic9fyjaAqYDRpZZaEFCJSssh9icQGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1664&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个图其实已经很能说明问题了，我再稍微啰嗦一下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;可靠的基础环境和组件：业务程序要运行，需要基础网络、硬件、操作系统、数据库、中间件等，需要这些环境和组件稳定可靠&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;快速安全变更的能力：快速变更的能力，大家很容易理解，作为研发人员，写了一个feature或者做了个bugfix，肯定很想快速交付，但是变更很容易导致故障，变更需要受控，需要尽量确保安全&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可靠性保障能力：软件部署到生产环境之后，可能会遇到各类问题，如何能够提前做好风险量化，如何能快速发现问题、定位问题、快速止损，这可能是业务侧对运维侧最重要的诉求了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最佳实践：业务依赖很多基础支撑能力，这些能力用的如何？是不是业界最佳实践？是不是公司内其他大部分业务的最佳实践？需要基础支撑团队反哺给业务&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;各个能力如何获取&lt;/h2&gt;&lt;p&gt;上面谈及的四个能力，应该如何获取？下面我们就掰开了揉碎了讲一讲。&lt;/p&gt;&lt;h3&gt;可靠的基础环境和组件&lt;/h3&gt;&lt;p&gt;首先说基础硬件环境，显然有两种选择，上云 or 自建，如果是政策有要求必须自己折腾，那没有办法，以政策为准。如果可以自行选择，现在这个时代，大概率是上云更合适，除非公司体量很大，机器量很大，自建才可能有优势。注意，我这里说的是&lt;strong&gt;才可能&lt;/strong&gt;，算成本的时候切记要把人力成本算上，别只算了硬件的成本。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于择业：对于系统运维工程师、网络运维工程师，看起来并不是个好消息，云的出现确实抢占了一部分这类岗位的空间，没办法，时代的车轮滚滚向前，大家都是历史的尘埃。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;再说组件，比如MySQL、Redis、MongoDB、Kafka、ElasticSearch、Nginx、Kubernetes等等，显然有3种选择，使用云上PaaS产品 or 自己折腾 or 自己出硬件+供应商出方案和服务。针对每种选择，我们分别做一下点评：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;云上PaaS产品：如果规模不大，没有相关人才储备，使用云上PaaS产品，是比较合适的，可以快速把能力建设起来，选择使用云上PaaS产品的甲方，通常已经使用了云上的虚拟机、Kubernetes类的Runtime环境，顺带采买PaaS类的产品，也比较丝滑，不需要再跟新的供应商做对接。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自己折腾：如果某个组件规模很大，或许是有自建的必要性的，比如Kafka，自己折腾，招2个人一主一备，水平还可以，出了问题能兜底，在北京的话每年大概100万的成本，得多大的规模才能从硬件和组件上省出这些钱呢？当然，也可以招聘一些低成本的运维工程师（&lt;span&gt;&lt;strong&gt;划重点，这里可能需要运维工程师，但是职级不高&lt;/strong&gt;&lt;/span&gt;），能解决日常问题，高阶问题解不了，高阶问题可以求助外部供应商的专家服务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自己出硬件+供应商出方案和服务：第三方供应商相比云厂商的PaaS产品，通常性价比更高，响应更快，但是组件如此之多，每个供应商大概率只能搞定有限的几款，作为甲方，可能要同时跟多个供应商打交道，略微麻烦。对于需要跨云协同的产品，比如统一监控、故障定位、FinOps相关的产品，如果公司用了多家云或是混合云架构，大概率是第三方供应商更为合适。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于择业：各组件的资深老炮，第一选择是去云厂商工作或创业输出经验，第二选择去自建组件的大厂，普通中小厂，很难有高薪资，毕竟第三方的专家服务性价比不低。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;快速安全变更的能力&lt;/h3&gt;&lt;p&gt;业务研发最常做的变更是二进制、配置的变更，当然，还有对基础环境以及组件的变更需求。&lt;/p&gt;&lt;p&gt;我们先说二进制、配置的变更，怎么做才能又快又安全的迭代呢？可以分阶段，公司还比较小的时候，不用太关注工具的建设，只需要定好规范和流程即可。规范方面比如：部署在哪个账号下，哪个目录下，日志怎么放，进程怎么托管，任何变更必须能够可回滚等等，流程方面比如：变更通报机制、多模块协同上线机制、无法回滚的需要有审批机制等等。&lt;/p&gt;&lt;p&gt;然后，需要有历史变更的量化数据，比如某个团队最近一个季度有多少次变更，回滚率如何，故障率如何，各个团队有个对比，做的不好的团队就会在下个季度好好改善的。&lt;/p&gt;&lt;p&gt;当公司继续变大，就可以投入人力做变更类的平台，把规范制度落实到平台上，产出量化数据，因为不同的公司情况各异，在传统的物理机虚拟机时代，很少看到有商业化的变更系统。当然，Kubernetes起来之后，屏蔽掉了底层的很多差异，基于Kubernetes做变更平台通用性强了很多，开始有相关的产品出来。&lt;/p&gt;&lt;p&gt;生产环境的变更，和测试环境、联调环境的变更还不太一样，生产环境对稳定性要求比较苛刻，测试环境、联调环境则相对没有太高的要求。所谓的CI/CD的系统，大都是针对测试环境、联调环境的，能够对生产环境做到CD的公司，屈指可数。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;划重点：测试、联调环境的CI/CD系统，更多的是为研发效率提速；生产环境的变更系统，更多的是确保稳定性、落地规范制度的。公司前期体量小，靠规章制度就够了，后面就需要规章制度+变更平台协同发力了。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;这个规范制度谁来定？变更平台谁来开发？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;规范的制定其实偏前期，可能运维团队都还没有的时候规范就已经有了，所以，大概率是CTO以及下辖的Core团队来制定就好了。如果之前没有制定过，运维总监（&lt;span&gt;&lt;strong&gt;运维总监上场了&lt;/strong&gt;&lt;/span&gt;）可以牵头制定，CTO下辖的Core团队来评审（大家有参与度），最终CTO拍板（自顶向下）发布，大家执行。&lt;/p&gt;&lt;p&gt;变更平台的开发，由运维团队来开发相对比较合适，后文还会介绍一些其他的平台，成立一个专门的运维团队（这里我说的运维和SRE没有区别，你也可以管这个团队叫SRE团队）是合适的。变更平台因为要落地公司的规范，外采的情况比较少，公司大到一定规模之后，基于开源的东西自研、攒，是个大概率的选择。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;关于择业：变更管理是企业中的重要一环，同时服务于稳定性体系。这是一个典型的DevOps岗位，天花板大概在P7+的水平（纯属个人看法，仅供参考）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;另外就是基础组件和环境的变更，典型的比如MySQL表结构、Nginx配置、DNS、VIP等等，这类变更可以内化到组件管控平台里，让组件能力提供方提供变更入口和管控能力。&lt;/p&gt;&lt;h3&gt;可靠性保障能力&lt;/h3&gt;&lt;p&gt;这个能力非常重要，SRE就是Site Reliability Engineering的缩写，即站点可靠性工程。从CTO的角度，软件部署到生产环境，后续可能会有各种问题发生，希望能有一套工程体系来保障可靠性。这是一个巨大的话题，本文不会事无巨细，只是理清楚哪些事哪些人来负责即可。&lt;/p&gt;&lt;p&gt;所谓的可靠性，就是与故障做斗争的过程，所以，我们还是来看故障的生命周期，从生命周期的各个环节着手，把故障打趴下，甚至直接把它扼杀在摇篮之中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2868020304568528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QMdm8cJjtkDibdfufcPMPj8mcgqBR3Vs2oGnhgGUFj4mW6ZewmBEtJklCdGUIV3sk1TsVhOpSu3rzUSUVRbyiajw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;故障开始之前降发生&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;事前的预防和风控，有很多的工作。比如：制定告警完备性标准并对各个业务线做量化评估；制定定位原则和流程以及故障定级定责的标准；提前梳理各个业务的核心功能和服务模块的对应关系，建立全局稳定性视图或者作战室，便于快速揪出故障模块或接口；对架构做优化；梳理故障预案并定期演练保鲜，也就是混沌工程那摊事；等等等等。&lt;/p&gt;&lt;p&gt;这里有些事情是需要业务研发来搞定的，比如架构优化，剩下的事情，我的建议是：&lt;span&gt;&lt;strong&gt;让运维团队来牵头，研发配合。比如CTO下辖的Core团队大概率既有运维一号位也有各个业务的技术一号位，名义上要CTO拍板，授权运维一号位来牵头，各个业务的研发一号位来配合，当然了，实际操刀的时候，运维一号位可能是找了一个得力干将来实操，各个业务线可能也是有技术一号位依仗的人来做接口人配合。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;除了架构优化之外，其他这些事情都是横向的事情，是可以有一些方法论和最佳实践的，把大家拉通，有利于共享这些方法论和最佳实践。当然，有些人会有疑问：我们能否直接在研发团队找个人来组成这么一个稳定性的虚拟组织，共同推进这个事情呢？其实也可以尝试。不过会有这么几点问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;每个业务线通常只有这么一两个接口人，人少活多，这个人大概率很难兼顾业务代码开发和稳定性工作，如果这个人全职做稳定性了，其实就相当于SRE了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果是SRE，和业务研发人员的考核体系其实是不同的，KPI怎么定？而且这个人可能也没有很好的归属感&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果这个人同时兼顾两个事情：稳定性、业务研发，可能会引发人的惰性，稳定性工作遇到问题的时候，天然的就会想去干点业务研发的活，业务研发遇到问题的时候，又想偷懒去干稳定性的活&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;划重点：事前的预防和风控，请各位CXO找运维总监要结果，但是必须给予极大的配合，从上往下推。对于搞定这摊事的SRE工程师角色，看起来是需要非常专业的高级别人士，工作5年以内大概率认知跟不上，或许，从资深研发团队招SRE是一个不错的选择，各位CXO可以尝试下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;故障开始之后降影响&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;一旦故障发生，我们的首要目标就变成降影响了。相关团队立马协作起来，快速定位直接原因、快速止损，事后再慢慢排查根因即可。这里会涉及如下一些工作内容：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;定义故障：通常，业务的指标出现问题就代表故障开始了，比如订单量下跌、叫车呼叫量下跌、支付量下跌，老板会尤为关注这类指标；而某个机器的CPU飙高或者磁盘用满，可能只是团队内部消化的问题，甚至K8s类的系统自动漂移解决，通常对客户主流程没有影响，老板是不关注的。为了不至于草木皆兵，我们就需要区分故障和问题的定义，不同的业务线指标不同，但是总体方法论是一样的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;响应故障：故障告警接收人是给业务研发？还是SRE？还是OnCall中心？不同的公司做法差异巨大，我个人的想法是：直接发给有能力处理的人！没有非黑即白，不同的告警不同的处理机制，比如基础网络有问题，显然是要发给网工，某个业务有问题，发给对应的运维和研发，尽量不要在中间再转一次，发给张三，张三处理不了去联系李四，就浪费时间了，故障处理应该争分夺秒。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;快速定位：一套行之有效的故障定位系统，是大杀器。故障定位系统通常是基于可观测性数据构建的，可以看做是驾驶舱级别的产品。可观测性数据是海量的，如果不经过梳理利用，这些海量的数据无法变成有价值的信息。从定位的角度来看，通常需要的是：可观测性体系+故障定位+持续运营，这里要展开的话内容就太多了，如想详细探讨可以联系我，什么？不知道怎么联系？SRETalk公众号，了解一下。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;快速止损：止损要快，就要有完备的预案，每次故障复盘的时候，建议CTO、运维总监关注预案有效率，就是说，这个故障是否是利用一个既有的预案来止损的，还是现攒的解决方案。如果是现攒的，说明你们的预案不够完备啊。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;OK，上面洋洋洒洒一片，回归问题，针对这块工作内容，CTO找谁要结果？我的建议是：SRE团队（文中多次出现运维、SRE字眼，在本文中基本都代表一个意思，这里的运维不止是Operations）。显然SRE无法搞定所有的故障，应该说大部分故障都得借助其他团队的人，但是CTO总不能一会找A团队一会找B团队吧。所以，&lt;span&gt;&lt;strong&gt;SRE要携CTO的尚方宝剑，牵头整体的稳定性建设，各个业务需要出接口人极力配合，所谓的稳定性建设，包括事前的预防风控、事中的统筹协同、事后的复盘推进，这也是SRE对公司的最大价值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;最佳实践&lt;/h3&gt;&lt;p&gt;这个内容很多，比如用什么机型套餐比较合适，用什么组网方式比较合适，用哪些组件公司具有更好的掌控力、可以得到更好的支持（不管是内部团队还是借助第三方供应商），公司推荐甚至要求的编程语言、框架是什么，业界推荐的接入层方案是什么？变更方案是什么？可观测性怎么做？等等等等。&lt;/p&gt;&lt;p&gt;不可否认，牛逼的业务研发团队，这些实践方式是门清的，但是同样不可否认，业务线多了之后，水平是良莠不齐的，水平差的团队势必需要教练角色的人，总不能啥事都去找CTO吧，SRE团队作为一个横向的技术团队，特别适合负责这摊事。但是显然，这是一个高端职位，新瓜蛋子干不来，&lt;span&gt;&lt;strong&gt;招聘高阶人士做业务BP是推进技术栈趋于统一的有效手段，如果CTO用不好这个抓手，技术体系会百花齐放，后面则是各种治理困局&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上面的四个支撑能力，业务侧应该如何获取，CTO应该如何统筹，各团队应该如何配合，大致就说这么多。下面我们再做两个小结。&lt;/p&gt;&lt;h2&gt;小结1：CTO如何帮助业务线获取这些支撑能力？&lt;/h2&gt;&lt;p&gt;显然，CTO不需要亲力亲为，但CTO要做好把关，CTO要颁发政策，是全军统帅。横向的工作落给SRE团队，各团队出接口人极力配合，大概率是个最佳实践。如果把横向的工作目标完全打散到业务团队自闭环，就无法享受到横向团队带来的经验传播能力。而且，屁股决定脑袋，不在其位不谋其政，各个业务自己容易有小九九，中心的横向组织也是一个削藩机制，抱歉这个词用的重了，本意是好的，你要自己体会啦。&lt;/p&gt;&lt;p&gt;另外补充一点FinOps的话题，FinOps也是一个横向能力，是否也要交由SRE来做呢？这个倒是未必。就让业务自闭环我觉得也挺好的，业务自己要负责盈亏，IT支出是支出大头，业务的GM理应是很上心的，CEO把营收净利相关的KPI压给业务GM，业务GM可以自闭环做好折中的。&lt;/p&gt;&lt;h2&gt;小结2：运维/SRE择业建议&lt;/h2&gt;&lt;p&gt;如果没有太高的职级和薪资期望，做一些相对基础的Operations工作也是可以的，10年内这个岗位大概率不会消亡。如果对职级和薪资有更高期望，先深扎某个细分领域，做到行业专家，是一条行之有效的路径。再之后，则讲究多个技术方向的融会贯通了，又要往广度发展。再之后，创业或者高管。&lt;/p&gt;&lt;h2&gt;本文作者&lt;/h2&gt;&lt;p&gt;秦晓辉，Open-Falcon、Nightingale 创业研发，极客时间《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODAxNTIzMQ==&amp;amp;mid=2247485044&amp;amp;idx=1&amp;amp;sn=5abc0303ca62bc8544c0e83666cf03cc&amp;amp;chksm=fd7a9ce4ca0d15f258c314d0ed0254a80c8f173c83b30b4064706e7402e7822c1179fc4a2104&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运维监控系统实战笔记&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;运维监控系统实战笔记&lt;/a&gt;》作者，公众号 SRETalk 主理人，快猫星云创业合伙人，创业方向是稳定性保障方向，如有需求欢迎&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3ODAxNTIzMQ==&amp;amp;mid=2247485160&amp;amp;idx=1&amp;amp;sn=e7d008c7908fc08bb190dcdf520cefda&amp;amp;chksm=fd7a9c78ca0d156eb131ef0541fc8431a74b5b4ae86501a19cb52059234e57523374f2188be4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;联系我做交流&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;联系我做交流&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3313782991202346&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QMdm8cJjtkDibdfufcPMPj8mcgqBR3Vs2cTeocSp2yKmlDJjs8kXOLKuggBOib26XSlyUNRB1GGQU6LUjRt8ibJYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4092&quot;/&gt;&lt;/p&gt;&lt;h2&gt;扩展阅读&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df157de938993c651cf64cd3a9f17ce4</guid>
<title>golang 面试题：能说说 uintptr 和 unsafe.Pointer 的区别吗？</title>
<link>https://toutiao.io/k/5ywnrru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;Ampg_362&quot;&gt;uintptr和unsafe.Pointer都是Go语言中处理底层指针的类型。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;9FHtXjOR&quot;&gt;uintptr是一个整数类型，用于存储指针类型的数值，它的大小和指针大小相同，通常是32位或64位。uintptr可以存储指向任何类型的指针，但它不能直接解引用，也不能用于进行指针运算。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;8iEASxsQ&quot;&gt;unsafe.Pointer是一个指针类型，用于存储任意类型的指针。unsafe.Pointer可以转换为任何指针类型，包括uintptr，这意味着它可以用于进行指针运算。但是，unsafe.Pointer不能直接解引用，因为它不知道指向的类型，需要使用类型转换将其转换为指向正确类型的指针。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;dx0fr_1d&quot;&gt;总之，uintptr是一个无类型的整数类型，不能直接解引用或进行指针运算，只能用于存储指针类型的数值。而unsafe.Pointer是一个指针类型，可以转换为任何指针类型，包括uintptr，可以进行指针运算，但需要小心使用，因为它可以绕过Go语言的类型安全检查。&lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d66e012f51e0c2f18222df4ec1133b1c</guid>
<title>2023 年：我成了半个外包</title>
<link>https://toutiao.io/k/yo4xxxd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;边线业务与主线角色被困外包；&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2022年，最后一个工作日，裁员的小刀再次挥下；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商务区楼下又多了几个落寞的身影，办公室内又多了几头暴躁的灵魂；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着裁员的结束，部门的人员结构简化到了极致，至少剩下的人是这么认为的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说实话，对于当下的互联网行业来说，个人感觉两极分化的有点严重；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;卷的，卷到鼻青脸肿，不知道BUG和需求哪个会先来；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不卷，感觉随时失业，不知道明天和裁员哪个会先来；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近这几年，裁员的故事已经不新奇了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比较热的话题反而是留下的那些人，如何应对各种此起彼伏的事情；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;裁员，对于走的人和留的人来说，都是正面暴击；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;走的人，虽然拿着赔偿礼包，但是要面对未来工作的不确定性，尤其是在当下的环境中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;留的人，要兜底很多闪现过来的事项，未来一段时间会陷入混乱的节奏中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于公司来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;裁员之后如何应对业务，没有一丝丝迟疑，会做出了完全出于本能的决定；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内部团队能应对的就自己解决，解决不了就交给外包方处理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体的策略就是：核心业务领域之外的需求，选择更低成本的解决手段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公司裁员之后，本意还是想专注自己的核心业务；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至于为何要接其他公司的需求，这里就涉及很多&lt;strong&gt;社会上的人情世故&lt;/strong&gt;了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如一些重要关系或者流水大的客户；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺乏互联网方面的专业团队，合作时会偶尔抛出研发或其他方面的需求；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于公司来说，接手吃力不讨好，不接手又怕影响客户关系维护；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最好的选择就是寻求外包解决；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于公司的研发团队，替客户进行相关需求的落地把控；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然接收外包需求流水抽成不高，但是可以更加紧密的维持客户合作关系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;允许质疑外包的质量和效率，但是不能否认长期的整体成本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在裁员之后，团队介入的外包项目越来越多，形成主线和外包业务五五开的魔幻局面；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;外包项目的合作形式大致分为两种；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAibcQDpPqWv0e4vTaFZ5icP4bxvV2dict6f4zW6dJrW0iaWgQicqdia9MnXYlibbdE8ediaKM5LiaQE1sb5wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这种合作中，如果只涉及甲乙两方，流程还是顺畅的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是对于甲乙丙三方的合作模式，如果再关联其他对接方，简直就是离谱踹门而入，离谱想拆家；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在经历几次甲乙丙三方的合作过程中，对于夹板气的体会已经是铭刻在心了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;甲乙双方对于丙方来说，是提供需求单的甲方；乙丙双方对于甲方来说，是落地需求单的外包方；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;合作过程中拉扯出个精分现象，都习以为常了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面基于甲乙丙三方合作的模式，来聊一聊外包所踩到的坑坑洼洼；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【如何选择外包公司】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在甲乙丙三方合作中，甲方交给乙方的业务，可能是基于信任关系，或者成本原因；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是乙方想再找一个靠谱的外包团队，难度就会大很多；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乙方既然承接需求，最终都是想交付高质量的结果，从而加强双方的合作关系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果没有一个靠谱的外包团队介入，所谓高质量的结果根本无从谈起；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常会先从过往的合作过且靠谱的外包团队中寻找，但是能找到的概率其实并不大，这里的影响因素有很多；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需求本身的复杂度，外包团队能不能承接，是一方面；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;甲方对于需求落地的预期时间，与外包团队的介入时间是否符合，也是一方面；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乙方对于外包团队的报价能否接受，又是一方面；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果合作过的团队中没有，则会优先从公司内部寻求推荐，比盲寻一个不知底的团队要靠谱很多；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里存在一个关键的卡点因素；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然研发团队接触的外包人员多，但是碍于怕麻烦的心理，乐意介入的人很少；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以需求最终交给一个新的外包团队的概率很大，也为后续的诸多问题埋下隐患；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【三方合作的流程机制】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先还是先说一个基本原则，在复杂的协作中，明确流程是最基础的事项；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三方合作，实现需求，获取利益回报；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程上看可能并不复杂，然而在实际协作过程中，又十分的曲折；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在明确协作的流程时，需要把握需求的三个关键阶段：排期、研发、交付；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里阶段划分是站在研发的角度拆解，从项目经理或者决策层看又是另一个说法了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.07109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAibcQDpPqWv0e4vTaFZ5icP4np3YiaP7K0Gic1jpZGXyhIxch8jGYOUUlLj9qAib4hXviaO1wLHiciaL2tdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在研发视角下，虽然依旧是围绕&lt;strong&gt;排期、研发、交付&lt;/strong&gt;三个阶段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但由于涉及三方协同，各个阶段的事项都会变的繁杂；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程的推进和问题解决，都要进行三方的统筹协调，麻烦事也从不缺席；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;排期阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 乙方接受甲方的需求单和报价，并寻求丙方做需求实现；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 丙方围绕需求单进行拆解，输出项目计划书以及报价，乙方认同后达成初步合作意向；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 乙丙双方就排期与甲方达成共识后，三方就各自的合作签订外包合同；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;研发阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;交付阶段&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 理论上丙方在自测完成后，再交付给乙方进行验收；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 乙方在验收阶段承担的压力比较大，本着对客户关系负责的态度，需要实现高质量的交付；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;• 甲方验收通过后，进行线上部署并交付项目材料，最终完成合同的结算流程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;流程终究只是对协作的预期设定；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际的执行中，会有各种问题层出不穷；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很容易把各方都推到情绪的边缘，进而导致系列关联的效应问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【三方合作的沟通问题】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果从三方合作的问题中，选一个最大的出来，不用证明都确定是沟通问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;沟通不到位，问题容易说不清楚，解决问题的很多动作可能都是抓瞎；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于三方的合作是远程在线模式，不是当面表达；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;沟通频率本来就低，等到发现问题解决思路不对时，耽误的时间已经久了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果返工；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那排期又需要重新协商，又会引起一系列必要的麻烦问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况，对于乙方的项目经理来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;身处甲丙两方的极限拉扯之中，会经常在离职和跳槽的情绪中不断徘徊；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而也不乏一些花哨的操作，将甲乙丙三方拉扯到一个协作群中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果甲方不介意乙方寻找外包实现需求，那么三方在群里及时沟通和解决问题的效率也会高很多；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是大部分的甲方还是介意的，很多沟通都是由丙方到乙方，乙方再转述给甲方；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传话游戏玩到最后，驴头不对驴嘴的现象十有八九；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，很多的外包合作群中；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能都是存在着甲乙丙三方人员，只是乙丙对甲方语调统一，以此避免信息传递的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;【需求落地的质量问题】&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于三方合作实现的需求，质量高不高？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比较肯定的回答；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能有一定的质量，但是高质量的期望建议打消，说不定还有一丝惊喜；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;质量依赖靠谱的外包合作方，这本身就是一件有难度的事，看脸和运气都没用；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;专业负责的外包团队少有，所以其团队的业务有持续性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际协作过程中出现的问题少，才可能更加专注于需求本身的落地实现上；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而真实的现状是；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;外包团队会在需求排期内尽快完成，投入越少，收益越大；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如：实现一个需求，估时30天，费用10W；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果在15天内完成需求，相当于成本投入缩减一半，这样在30天内可能实现多个需求；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;鉴于这种策略之下，很多需求的实现可能都是仓促的，质量上自然很难保证；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以对于质量问题的把关，压力会给到乙方，在交付验收时做好时间差管理；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAibcQDpPqWv0e4vTaFZ5icP4NtSQicViaCS6kgPiavLW6P8cdtuIZmvic3oicc91nxlF652ZO6L8SMHyZ1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乙方预留一部分时间段，对丙方交付进行验收，如果出现问题及时修改，避免传递到甲方；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然了，混乱验收和测试也是常见的骚操作；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不乏一些丙方拿乙方的验收当测试，乙方拿甲方的验收当测试，以此来降低自己的时间成本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此导致三方合作裂开，尾款结算的问题，甚至对簿公堂也不少见；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然不是三方负责人乐意见到的，但又是三方都很难把控的事；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终结果就是，不但成本没少，事情还更多了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;07&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务需求外包，是比较常见的一种手段，只是过程与结果的把控难度较大；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于甲乙两方来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可能是利益驱动，可能是社会的人情世故，从而建立了合作关系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于乙丙两方来说；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;则是单纯的利益考量，从而形成了短期的合作；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而对于那些身处甲乙丙三方合作的网友们，只能在内心轻轻的嘀咕一句：&lt;strong&gt;人在社会，身不由己&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-support=&quot;96编辑器&quot; data-style-id=&quot;30792&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97816&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>