<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>92f47082e1e161b20337c0751c5b006d</guid>
<title>京东面试：MQ 消息丢失、重复、积压问题，如何解决？</title>
<link>https://toutiao.io/k/1unx53z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官在面试候选人时，如果发现候选人的简历中写了在项目中使用了&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MQ 技术（如 Kafka、RabbitMQ、RocketMQ），基本都会抛出一个问题：在使用 MQ 的时候，怎么确保消息 100% 不丢失？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在实际工作中很常见，既能考察候选者对于 MQ 中间件技术的掌握程度，又能很好地区分候选人的能力水平。接下来，我们就从这个问题出发，探讨你应该掌握的基础知识和答题思路，以及延伸的面试考点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以京东系统为例，用户在购买商品时，通常会选择用京豆抵扣一部分的金额，在这个过程中，交易服务和京豆服务通过 MQ 消息队列进行通信。在下单时，交易服务发送“扣减账户 X 100 个京豆”的消息给 MQ 消息队列，而京豆服务则在消费端消费这条命令，实现真正的扣减操作。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18796296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaOLG75wzrQhoHvvjich4uzuzbsJkTkreibEWhu1XxTMy2QJPryDzxSnQA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;那在这个过程中你会遇到什么问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例分析&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要知道，在互联网面试中，引入 MQ 消息中间件最直接的目的是：做系统解耦合流量控制，追其根源还是为了解决互联网系统的高可用和高性能问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;系统解耦：&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;用MQ消息队列，可以隔离系统上下游环境变化带来的不稳定因素，比如京豆服务的系统需求无论如何变化，交易服务不用做任何改变，即使当京豆服务出现故障，主交易流程也可以将京豆服务降级，实现交易服务和京豆服务的解耦，做到了系统的高可用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;流量控制：&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;遇到秒杀等流量突增的场景，通过 MQ 还可以实现流量的“削峰填谷”的作用，可以根据下游的处理能力自动调节流量。不过引入 MQ虽然实现了系统解耦合流量控制，也会带来其他问题。&lt;/p&gt;&lt;p&gt;引入 MQ 消息中间件实现系统解耦，会影响系统之间数据传输的一致性。&lt;br/&gt;在分布式系统中，如果两个节点之间存在数据同步，就会带来数据一致性的问题。同理，在这一讲你要解决的就是：消息生产端和消息消费端的消息数据一致性问题（也就是如何确保消息不丢失）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而引入MQ 消息中间件解决流量控制， 会使消费端处理能力不足从而导致消息积压，这也是你要解决的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你能发现，问题与问题之间往往是环环相扣的，面试官会借机考察你解决问题思路的连贯性和知识体系的掌握程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那面对“在使用 MQ 消息队列时，如何确保消息不丢失”这个问题时，你要怎么回答呢？首先，你要分析其中有几个考点，比如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何知道有消息丢失？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;哪些环节可能丢消息？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何确保消息不丢失？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;候选人在回答时，要先让面试官知道你的分析思路，然后再提供解决方案：网络中的数据传输不可靠，想要解决如何不丢消息的问题，首先要知道哪些环节可能丢消息，以及我们如何知道消息是否丢失了，最后才是解决方案（而不是上来就直接说自己的解决方案）。就好比“架构设计”“架构”体现了架构师的思考过程，而“设计”才是最后的解决方案，两者缺一不可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;案例解答&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看消息丢失的环节，一条消息从生产到消费完成这个过程，可以划分三个阶段，分别为消息生产阶段，消息存储阶段和消息消费阶段。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18796296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaOLG75wzrQhoHvvjich4uzuzbsJkTkreibEWhu1XxTMy2QJPryDzxSnQA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;strong&gt;消息生产阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到 MQ Broker 的 ack&lt;br/&gt;确认响应，就表示发送成功，所以只要处理好返回值和异常，这个阶段是不会出现消息丢失的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息存储阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个阶段一般会直接交给 MQ 消息中间件来保证，但是你要了解它的原理，比如 Broker 会做副本，保证一条消息至少同步两个节点再返回ack。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息消费阶段：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;消费端从 Broker 上拉取消息，只要消费端在收到消息后，不立即发送消费确认给&lt;br/&gt;Broker，而是等到执行完业务逻辑后，再发送消费确认，也能保证消息的不丢失。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方案看似万无一失，每个阶段都能保证消息的不丢失，但在分布式系统中，故障不可避免，作为消息生产端，你并不能保证 MQ 是不是弄丢了你的消息，消费者是否消费了你的消息，所以，本着 Design for Failure 的设计原则，你还是需要一种机制，来 Check 消息是否丢失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;紧接着，你还可以向面试官阐述怎么进行消息检测？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;总体方案解决思路为：在消息生产端，给每个发出的消息都指定一个全局唯一 ID，或者附加一个连续递增的版本号，然后在消费端做对应的版本校验。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具体怎么落地实现呢？&lt;/strong&gt;&lt;br/&gt;你可以利用拦截器机制。在生产端发送消息之前，通过拦截器将消息版本号注入消息中（版本号可以采用连续递增的 ID 生成，也可以通过分布式全局唯一 ID生成）。然后在消费端收到消息后，再通过拦截器检测版本号的连续性或消费状态，这样实现的好处是消息检测的代码不会侵入到业务代码中，可以通过单独的任务来定位丢失的消息，做进一步的排查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里需要你注意：&lt;/strong&gt;&lt;br/&gt;如果同时存在多个消息生产端和消息消费端，通过版本号递增的方式就很难实现了，因为不能保证版本号的唯一性，此时只能通过全局唯一 ID 的方案来进行消息检测，具体的实现原理和版本号递增的方式一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，你已经知道了哪些环节（消息存储阶段、消息消费阶段）可能会出问题，并有了如何检测消息丢失的方案，然后就要给出解决防止消息丢失的设计方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;回答完“如何确保消息不会丢失？” 之后，面试官通常会追问“怎么解决消息被重复消费的问题？”&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如：在消息消费的过程中，如果出现失败的情况，通过补偿的机制发送方会执行重试，重试的过程就有可能产生重复的消息，那么如何解决这个问题？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题其实可以换一种说法，就是如何解决消费端幂等性问题（幂等性，就是一条命令，任意多次执行所产生的影响均与一次执行的影响相同），只要消费端具备了幂等性，那么重复消费消息的问题也就解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是来看扣减京豆的例子，将账户 X 的金豆个数扣减 100 个，在这个例子中，我们可以通过改造业务逻辑，让它具备幂等性。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41944444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaZNUNRyiciciclojurMAM20Leq7gFJYciby5IiaVRv4oWzKNI02yXiclmfsow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;&lt;strong&gt;最简单的实现方案，就是在数据库中建一张消息日志表，&lt;/strong&gt;&lt;br/&gt;这个表有两个字段：消息 ID 和消息执行状态。这样，我们消费消息的逻辑可以变为：在消息日志表中增加一条消息记录，然后再根据消息记录，异步操作更新用户京豆余额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们每次都会在插入之前检查是否消息已存在，所以就不会出现一条消息被执行多次的情况，这样就实现了一个幂等的操作。当然，基于这个思路，不仅可以使用关系型数据库，也可以通过 Redis 来代替数据库实现唯一约束的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我多说一句，想要解决“消息丢失”和“消息重复消费”的问题，有一个前提条件就是要实现一个全局唯一 ID 生成的技术方案。这也是面试官喜欢考察的问题，你也要掌握。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，全局唯一 ID 生成的实现方法有数据库自增主键、UUID、Redis，Twitter-Snowflake 算法，我总结了几种方案的特点，你可以参考下。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4564814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GpcH5Yqqj0k1EM31Gh0ZYjUMxowE5BzaZol162ib2Gv7XGLIyYUkwaH8oAlcGU7PXb9pznnzJ53vWq8zCnapkWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;br/&gt;我提醒你注意，无论哪种方法，如果你想同时满足简单、高可用和高性能，就要有取舍，所以你要站在实际的业务中，说明你的选型所考虑的平衡点是什么。我个人在业务中比较倾向于选择 Snowflake 算法，在项目中也进行了一定的改造，主要是让算法中的 ID 生成规则更加符合业务特点，以及优化诸如时钟回拨等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当然，除了“怎么解决消息被重复消费的问题？”之外，面试官还会问到你“消息积压”。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原因在于消息积压反映的是性能问题，解决消息积压问题，可以说明候选者有能力处理高并发场景下的消费能力问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你在解答这个问题时，依旧要传递给面试官一个这样的思考过程：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果出现积压，那一定是性能问题，想要解决消息从生产到消费上的性能问题，就首先要知道哪些环节可能出现消息积压，然后在考虑如何解决。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为消息发送之后才会出现积压的问题，所以和消息生产端没有关系，又因为绝大部分的消息队列单节点都能达到每秒钟几万的处理能力，相对于业务逻辑来说，性能不会出现在中间件的消息存储上面。毫无疑问，出问题的肯定是消息消费阶段，&lt;br/&gt;&lt;strong&gt;那么从消费端入手，如何回答呢？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果是线上突发问题，要临时扩容，增加消费端的数量，与此同时，降级一些非核心的业务。通过扩容和降级承担流量，这是为了表明你对应急问题的处理能力。&lt;/p&gt;&lt;p&gt;其次，才是排查解决异常问题，如通过监控，日志等手段分析是否消费端的业务逻辑代码出现了问题，优化消费端的业务处理逻辑。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，如果是消费端的处理能力不足，可以通过水平扩容来提供消费端的并发处理能力&lt;br/&gt;&lt;strong&gt;但这里有一个考点需要特别注意，&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那就是在扩容消费者的实例数的同时，必须同步扩容主题 Topic&lt;br/&gt;的分区数量，确保消费者的实例数和分区数相等。如果消费者的实例数超过了分区数，由于分区是单线程消费，所以这样的扩容就没有效果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在Kafka 中，一个 Topic 可以配置多个 Partition（分区），数据会被写入到多个分区中，但在消费的时候，Kafka 约定一个分区只能被一个消费者消费，Topic 的分区数量决定了消费的能力，所以，可以通过增加分区来提高消费者的处理能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结 至此，我们讲解了 MQ 消息队列的热门问题的解决方案，无论是初中级还是高级研发工程师，本篇文章的内容都是你需要掌握的，你都可以从这几点出发，与面试官进行友好的交流。我来总结一下今天的重点内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何确保消息不会丢失？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你要知道一条消息从发送到消费的每个阶段，是否存在丢消息，以及如何监控消息是否丢失，最后才是如何解决问题，方案可以基于“ MQ 的可靠消息投递&lt;br/&gt;”的方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何保证消息不被重复消费？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在进行消息补偿的时候，一定会存在重复消息的情况，那么如何实现消费端的幂等性就这道题的考点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何处理消息积压问题？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这道题的考点就是如何通过 MQ&lt;br/&gt;实现真正的高性能，回答的思路是，本着解决线上异常为最高优先级，然后通过监控和日志进行排查并优化业务逻辑，最后是扩容消费端和分片的数量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答问题的时候，你需要特别注意的是，让面试官了解到你的思维过程，这种解决问题的能力是面试官更为看中的，比你直接回答一道面试题更有价值。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;转自：一个天蝎座的程序猿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://blog.csdn.net/qq_45566762/article/details/123787373&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651517204&amp;amp;idx=2&amp;amp;sn=eb911348d66090f5af9af3eb74ebc0e9&amp;amp;chksm=bd259d6b8a52147d30997d8699b879fb3fb92d6866de454d67ce06ef05d910502e08431df942&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;新来个技术总监，把 RabbitMQ 讲的那叫一个透彻，佩服！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651514792&amp;amp;idx=1&amp;amp;sn=765ef6d4c521d6a74d9e47e07999bf8f&amp;amp;chksm=bd258bd78a5202c1caf1ffa5e9de1db1b94b87b170e978b0c9c7da462f00d21782c47fe8ad2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;选 Redis 做 MQ 的人，是水平欠缺么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;选 Redis 做 MQ 的人，是水平欠缺么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>765e9c92bd42e03169403e5904b1731c</guid>
<title>面试官：Redis 大 key 要如何处理？</title>
<link>https://toutiao.io/k/adi7th7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：小林coding&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来聊聊，关于 Redis 大 key 的四个问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是 Redis 大 key？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大 key 会造成什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何找到大 key ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何删除大 key？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是 Redis 大 key？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 key 并不是指 key 的值很大，而是 key 对应的 value 很大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，下面这两种情况被称为大 key：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;String 类型的值大于 10 KB；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hash、List、Set、ZSet 类型的元素的个数超过 5000个；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大 key 会造成什么问题？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 key 会带来以下四种影响：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;客户端超时阻塞&lt;/strong&gt;。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;引发网络阻塞&lt;/strong&gt;。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;阻塞工作线程&lt;/strong&gt;。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存分布不均&lt;/strong&gt;。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何找到大 key ？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、redis-cli --bigkeys 查找大key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 redis-cli --bigkeys 命令查找大 key：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p6379 -a &quot;password&quot; -- bigkeys&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用的时候注意事项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最好选择在从节点上执行该命令。因为主节点上执行时，会阻塞主节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有从节点，那么可以选择在 Redis 实例业务压力的低峰阶段进行扫描查询，以免影响到实例的正常运行；或者可以使用 -i 参数控制扫描间隔，避免长时间扫描降低 Redis 实例的性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方式的不足之处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这个方法只能返回每种类型中最大的那个 bigkey，无法得到大小排在前 N 位的 bigkey；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于集合类型来说，这个方法只统计集合元素个数的多少，而不是实际占用的内存量。但是，一个集合中的元素个数多，并不一定占用的内存就多。因为，有可能每个元素占用的内存很小，这样的话，即使元素个数有很多，总内存开销也不大；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、使用 SCAN 命令查找大 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 SCAN 命令对数据库扫描，然后用 TYPE 命令获取返回的每一个 key 的类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 String 类型，可以直接使用 STRLEN 命令获取字符串的长度，也就是占用的内存空间字节数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于集合类型来说，有两种方法可以获得它占用的内存大小：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果能够预先从业务层知道集合元素的平均大小，那么，可以使用下面的命令获取集合元素的个数，然后乘以集合元素的平均大小，这样就能获得集合占用的内存大小了。List 类型：&lt;code&gt;LLEN&lt;/code&gt; 命令；Hash 类型：&lt;code&gt;HLEN&lt;/code&gt; 命令；Set 类型：&lt;code&gt;SCARD&lt;/code&gt; 命令；Sorted Set 类型：&lt;code&gt;ZCARD&lt;/code&gt; 命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不能提前知道写入集合的元素大小，可以使用 &lt;code&gt;MEMORY USAGE&lt;/code&gt; 命令（需要 Redis 4.0 及以上版本），查询一个键值对占用的内存空间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、使用 RdbTools 工具查找大 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 RdbTools 第三方开源工具，可以用来解析 Redis 快照（RDB）文件，找到其中的大 key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，下面这条命令，将大于 10 kb 的  key  输出到一个表格文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rdb dump.rdb -c memory --bytes 10240 -f redis.csv&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何删除大 key？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除操作的本质是要释放键值对占用的内存空间，不要小瞧内存的释放过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，删除大 key 这一个动作，我们要小心。具体要怎么做呢？这里给出两种方法：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、分批次删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 Hash&lt;/strong&gt;，使用 &lt;code&gt;hscan&lt;/code&gt; 命令，每次获取 100 个字段，再用 &lt;code&gt;hdel&lt;/code&gt; 命令，每次删除 1 个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_hash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;    large_hash_key =&lt;span&gt;&quot;xxx&quot;&lt;/span&gt; &lt;span&gt;#要删除的大hash键名&lt;/span&gt;&lt;br/&gt;    cursor = &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; cursor != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;# 使用 hscan 命令，每次获取 100 个字段&lt;/span&gt;&lt;br/&gt;        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; data.items():&lt;br/&gt;                &lt;span&gt;# 再用 hdel 命令，每次删除1个字段&lt;/span&gt;&lt;br/&gt;                r.hdel(large_hash_key, item[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 List&lt;/strong&gt;，通过 &lt;code&gt;ltrim&lt;/code&gt; 命令，每次删除少量元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_list&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_list_key = &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;  &lt;span&gt;#要删除的大list的键名&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; r.llen(large_list_key)&amp;gt;&lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;      &lt;span&gt;#每次只删除最右100个元素&lt;/span&gt;&lt;br/&gt;      r.ltrim(large_list_key, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;-101&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 Set&lt;/strong&gt;，使用 &lt;code&gt;sscan&lt;/code&gt; 命令，每次扫描集合中 100 个元素，再用 &lt;code&gt;srem&lt;/code&gt; 命令每次删除一个键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_set&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;redis-host1&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_set_key = &lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;   &lt;span&gt;# 要删除的大set的键名&lt;/span&gt;&lt;br/&gt;  cursor = &lt;span&gt;&#x27;0&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; cursor != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;# 使用 sscan 命令，每次扫描集合中 100 个元素&lt;/span&gt;&lt;br/&gt;    cursor, data = r.sscan(large_set_key, cursor=cursor, count=&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; data:&lt;br/&gt;      &lt;span&gt;# 再用 srem 命令每次删除一个键&lt;/span&gt;&lt;br/&gt;      r.srem(large_size_key, item)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;strong&gt;删除大 ZSet&lt;/strong&gt;，使用 &lt;code&gt;zremrangebyrank&lt;/code&gt; 命令，每次删除 top 100个元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;del_large_sortedset&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;  r = redis.StrictRedis(host=&lt;span&gt;&#x27;large_sortedset_key&#x27;&lt;/span&gt;, port=&lt;span&gt;6379&lt;/span&gt;)&lt;br/&gt;  large_sortedset_key=&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; r.zcard(large_sortedset_key)&amp;gt;&lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;# 使用 zremrangebyrank 命令，每次删除 top 100个元素&lt;/span&gt;&lt;br/&gt;    r.zremrangebyrank(large_sortedset_key,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;99&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、异步删除&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Redis 4.0 版本开始，可以采用&lt;strong&gt;异步删除&lt;/strong&gt;法，&lt;strong&gt;用 unlink 命令代替 del 来删除&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐阅读：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247518397&amp;amp;idx=1&amp;amp;sn=c75e71eca9127474d60d9ea9bdcb546a&amp;amp;chksm=f98dcc17cefa450181debb590e79958d247ef9ffbbb94a36f5726b19829eec598acce24b31dd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;字节二面，差点没答好&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;字节二面，差点没答好&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247517757&amp;amp;idx=2&amp;amp;sn=67d56ebc0accd449c75ec6c36fca8645&amp;amp;chksm=f98dc297cefa4b811a2cf04d60b5f28f8e2d59e1281cf3e433579bb164767342b0499f6f689a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：如何用 Redis 实现分布式锁？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：如何用 Redis 实现分布式锁？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247516338&amp;amp;idx=2&amp;amp;sn=481c0c5ba605eddbc4824056d941a261&amp;amp;chksm=f98dc418cefa4d0ec4e8e3e2a1c1badc6cb66b5c20775ff785b8ef0da708cf8eb0a1c42c236f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：你确定 Redis 是单线程的进程吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：你确定 Redis 是单线程的进程吗？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53b3a67b41e8c792af544cc9245d4499</guid>
<title>说一下：运行 npm run xxx 的时候发生了什么？</title>
<link>https://toutiao.io/k/vpij4ii</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;在搜索 npm run 资料时，相关搜索推荐了一个词条 “运行 npm run xxx 的时候发生了什么？”，下意识地点击了下词条，找到相关结果还真不少。实话说npm run xxx 是最常用的命令之一，但说实话，对此运行时发生了什么还真是一知半解，这就来一探究竟&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;为了显示较为完整的执行日志，在项目根目录新建配置文件 .npmrc，增加配置项&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;loglevel&lt;/span&gt;=silly&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;然后执行命令行，得到如下截图（红色部分为手动添加日志）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6347826086956522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ariagf5PYIYIuxUlgxKKfwK00XuEedoW3n8C866kJZonDydYibOgHmWzT07bTSe21v6kiaTmRawFerTfB8gic0rl1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据执行的日志可以看出，运行 npm run xxx 后首先到 package.json 文件获取所有的 scripts 命令，这里以 vite 为例大致流程如下&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1301&quot; data-backw=&quot;541&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.4048059149722736&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ariagf5PYIYIuxUlgxKKfwK00XuEedoW3SNnXEibcDcJCd5fSxicn3HCaliakG6Iyh59U0Z1C7Yespibvzial5lYRufQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;或许到这里会有几点疑问？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;执行文件 vite.cmd 怎么来的？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实在执行 npm install 时，npm 会根据扩展包的 package.json 文件中 bin 配置生成跨平台的三个执行文件：&lt;span&gt;vite, &lt;span&gt;vite.cmd, vite.ps1 ，然后指向真实&lt;span&gt;的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;vite/bin/vite.js 文件  &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;502&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8690344062153164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ariagf5PYIYIuxUlgxKKfwK00XuEedoW3nvX6bP0Lg87oR6RCXnaUW8Ty2ibv7KBSBYbZyM0hQLnTH1F12vsicWEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;如何会执行到 node_moudles/.bin 目录？&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前面说到 npm install 时会生成执行文件，同时这也是一种软连接，这种软连接相当于一种映射，执行 npm run xxx 的时候，就会到 node_modules/bin 中找对应的映射文件，然后再找到相应的 js 文件来执行。 类似 npm install -g xxx 全局安装后，可以执行 xxx 命令了&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;项目可以执行 npm start , 这是为什么？ &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从图中可以看出 start 是 npm 自带的命令，可以直接简写 npm start &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7130434782608696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ariagf5PYIYIuxUlgxKKfwK00XuEedoW3WAvxibXIxAlwlgiaKwCGibZfLkbregJ4G5rOb4ZDib3zIDxL5r1xjNDdjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 package.json 增加配置，也就可以执行 npm start 了&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;scripts&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;start&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;vite&quot;&lt;/span&gt;,    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; },&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么关于 npm run xxx 的流程就简单梳理到这了&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71bc7d741315f5a321683e21b0a70aab</guid>
<title>32 道 Spring 常见面试总结（附详细参考答案），我经常拿来面试别人</title>
<link>https://toutiao.io/k/vmbw17y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-9scqi7&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;zvkfAIab&quot;&gt;首发于 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide 在线网站&lt;/a&gt;：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Spring 常见面试题总结&lt;/a&gt;&lt;/blockquote&gt;&lt;p data-pid=&quot;t48c5Bod&quot;&gt;最近在对 JavaGuide 的内容进行重构完善，同步一下最新更新，希望能够帮助你。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring 基础&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring 框架?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;i1NBKkV_&quot;&gt;Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。&lt;/p&gt;&lt;p data-pid=&quot;38CpyAg8&quot;&gt;我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inverse of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;361&quot; data-rawheight=&quot;741&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;7XlxHliz&quot;&gt;Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。&lt;/p&gt;&lt;p data-pid=&quot;WMe-HBZ1&quot;&gt;Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！&lt;/p&gt;&lt;p data-pid=&quot;T_frrzZh&quot;&gt;  多提一嘴 ： &lt;b&gt;语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;8GrdyTh4&quot;&gt;Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring 包含的模块有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;d5hVj1P-&quot;&gt;&lt;b&gt;Spring4.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring4.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Esivw2dB&quot;&gt;&lt;b&gt;Spring5.x 版本&lt;/b&gt; ：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;650&quot; data-rawheight=&quot;450&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-472d5e63b920c822525e11d05133be44_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring5.x主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TJD_HRfd&quot;&gt;Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;p data-pid=&quot;TzDpak8y&quot;&gt;Spring 各个模块的依赖关系如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;937&quot; data-rawheight=&quot;738&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d93ac9f3dcd23f8a1fcb657d81acbbe2_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring 各个模块的依赖关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Core Container&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;m0Vrd8VL&quot;&gt;Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;i-Udk49h&quot;&gt;&lt;b&gt;spring-core&lt;/b&gt; ：Spring 框架基本的核心工具类。&lt;/li&gt;&lt;li data-pid=&quot;-_QpCS62&quot;&gt;&lt;b&gt;spring-beans&lt;/b&gt; ：提供对 bean 的创建、配置和管理等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;3BJestPe&quot;&gt;&lt;b&gt;spring-context&lt;/b&gt; ：提供对国际化、事件传播、资源加载等功能的支持。&lt;/li&gt;&lt;li data-pid=&quot;qnyeY0ST&quot;&gt;&lt;b&gt;spring-expression&lt;/b&gt; ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;AOP&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;0DdS6DJu&quot;&gt;&lt;b&gt;spring-aspects&lt;/b&gt; ：该模块为与 AspectJ 的集成提供支持。&lt;/li&gt;&lt;li data-pid=&quot;95r0WE5Q&quot;&gt;&lt;b&gt;spring-aop&lt;/b&gt; ：提供了面向切面的编程实现。&lt;/li&gt;&lt;li data-pid=&quot;T_hBsnGK&quot;&gt;&lt;b&gt;spring-instrument&lt;/b&gt; ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Data Access/Integration&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;DA3kSEG4&quot;&gt;&lt;b&gt;spring-jdbc&lt;/b&gt; ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。&lt;/li&gt;&lt;li data-pid=&quot;KRkn9OQk&quot;&gt;&lt;b&gt;spring-tx&lt;/b&gt; ：提供对事务的支持。&lt;/li&gt;&lt;li data-pid=&quot;PwAkXOzU&quot;&gt;&lt;b&gt;spring-orm&lt;/b&gt; ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。&lt;/li&gt;&lt;li data-pid=&quot;7lS_CDkO&quot;&gt;&lt;b&gt;spring-oxm&lt;/b&gt; ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。&lt;/li&gt;&lt;li data-pid=&quot;pvOK5TZ2&quot;&gt;&lt;b&gt;spring-jms&lt;/b&gt; : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Spring Web&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;kPdLK_Ag&quot;&gt;&lt;b&gt;spring-web&lt;/b&gt; ：对 Web 功能的实现提供一些最基础的支持。&lt;/li&gt;&lt;li data-pid=&quot;p-ixTyVO&quot;&gt;&lt;b&gt;spring-webmvc&lt;/b&gt; ： 提供对 Spring MVC 的实现。&lt;/li&gt;&lt;li data-pid=&quot;uf0cEFAl&quot;&gt;&lt;b&gt;spring-websocket&lt;/b&gt; ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。&lt;/li&gt;&lt;li data-pid=&quot;swzXm0ql&quot;&gt;&lt;b&gt;spring-webflux&lt;/b&gt; ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Messaging&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;0FU9DXOS&quot;&gt;&lt;b&gt;spring-messaging&lt;/b&gt; 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring Test&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;sD3V41th&quot;&gt;Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。&lt;/p&gt;&lt;p data-pid=&quot;hrNQ_sZM&quot;&gt;Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring,Spring MVC,Spring Boot 之间什么关系?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;WTaWWIah&quot;&gt;很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。&lt;/p&gt;&lt;p data-pid=&quot;qzayFgrX&quot;&gt;Spring 包含了多个功能模块（上面刚刚提高过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。&lt;/p&gt;&lt;p data-pid=&quot;KCudy2cQ&quot;&gt;下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;540&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-97c54723d8dfaa3c77b3960f8788b89e_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring主要模块&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;eoDUqwpe&quot;&gt;Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q3RbJ1ZG&quot;&gt;使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！&lt;/p&gt;&lt;p data-pid=&quot;cYPoAbUu&quot;&gt;Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。&lt;/p&gt;&lt;p data-pid=&quot;br5ypV5F&quot;&gt;Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Spring IoC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 Spring IoC 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;_kdBjvmW&quot;&gt;&lt;b&gt;IoC（Inverse of Control:控制反转）&lt;/b&gt; 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。&lt;/p&gt;&lt;p data-pid=&quot;48OxSyn-&quot;&gt;&lt;b&gt;为什么叫控制反转？&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;JI_TUrNY&quot;&gt;&lt;b&gt;控制&lt;/b&gt; ：指的是对象创建（实例化、管理）的权力&lt;/li&gt;&lt;li data-pid=&quot;t5PSuvqI&quot;&gt;&lt;b&gt;反转&lt;/b&gt; ：控制权交给外部环境（Spring 框架、IoC 容器）&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;392&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2a1fa4b04fe10f0f377561b4056bdaf4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;GWqolc05&quot;&gt;将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。&lt;/p&gt;&lt;p data-pid=&quot;G2IBfAcj&quot;&gt;在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。&lt;/p&gt;&lt;p data-pid=&quot;j6uuhGwr&quot;&gt;在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。&lt;/p&gt;&lt;p data-pid=&quot;iDS1lAjf&quot;&gt;Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。&lt;/p&gt;&lt;p data-pid=&quot;QuvfWkhE&quot;&gt;相关阅读：&lt;/p&gt;&lt;h3&gt;&lt;b&gt;什么是 Spring Bean？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;tREpF7hs&quot;&gt;简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。&lt;/p&gt;&lt;p data-pid=&quot;CEcokO1u&quot;&gt;我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- Constructor-arg with &#x27;value&#x27; attribute --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;bean&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;...&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;pRqfzGbk&quot;&gt;下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;498&quot; data-rawheight=&quot;296&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e5efc5d328f2c67049b43250d4950b49_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;0Mub_iuf&quot;&gt;org.springframework.beans和 org.springframework.context 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看&lt;/p&gt;&lt;h3&gt;&lt;b&gt;将一个类声明为 Bean 的注解有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;YlRADxNm&quot;&gt;@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个 Bean 不知道属于哪个层，可以使用@Component 注解标注。&lt;/li&gt;&lt;li data-pid=&quot;k6wQYVO-&quot;&gt;@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。&lt;/li&gt;&lt;li data-pid=&quot;O1dgwjYU&quot;&gt;@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。&lt;/li&gt;&lt;li data-pid=&quot;f5OapWoq&quot;&gt;@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;@Component 和 @Bean 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;xy-ds-X3&quot;&gt;@Component 注解作用于类，而@Bean注解作用于方法。&lt;/li&gt;&lt;li data-pid=&quot;fkcZUfK0&quot;&gt;@Component通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。&lt;/li&gt;&lt;li data-pid=&quot;M-d9l9kU&quot;&gt;@Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ZdVry_Go&quot;&gt;@Bean注解使用示例：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transferService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TransferServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;KFct29sE&quot;&gt;上面的代码相当于下面的 xml 配置&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;transferService&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.acme.TransferServiceImpl&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beans&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;mWTl__L1&quot;&gt;下面这个例子是通过 @Component 无法实现的。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OneService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceImpl3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;注入 Bean 的注解有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;2cPfZnOc&quot;&gt;Spring 内置的 @Autowired 以及 JDK 内置的 @Resource 和 @Inject 都可以用于注入 Bean。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;Annotaion&lt;/th&gt;&lt;th&gt;Package&lt;/th&gt;&lt;th&gt;Source&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Autowired&lt;/td&gt;&lt;td&gt;org.springframework.bean.factory&lt;/td&gt;&lt;td&gt;Spring 2.5+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Resource&lt;/td&gt;&lt;td&gt;javax.annotation&lt;/td&gt;&lt;td&gt;Java JSR-250&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@Inject&lt;/td&gt;&lt;td&gt;javax.inject&lt;/td&gt;&lt;td&gt;Java JSR-330&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;Ge225ACS&quot;&gt;@Autowired 和@Resource使用的比较多一些。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;@Autowired 和 @Resource 的区别是什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Z7KU5GkS&quot;&gt;Autowired 属于 Spring 内置的注解，默认的注入方式为byType（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。&lt;/p&gt;&lt;p data-pid=&quot;bHoiWhDe&quot;&gt;&lt;b&gt;这会有什么问题呢？&lt;/b&gt; 当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。&lt;/p&gt;&lt;p data-pid=&quot;QIqWZ-67&quot;&gt;这种情况下，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 smsService 就是我这里所说的名称，这样应该比较好理解了吧。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// smsService 就是我们上面所说的名称
@Autowired
private SmsService smsService;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;LaXvI4z5&quot;&gt;举个例子，SmsService 接口有两个实现类: SmsServiceImpl1和 SmsServiceImpl2，且它们都已经被 Spring 容器所管理。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsServiceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入  SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// smsServiceImpl1 就是我们上面所说的名称
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Qualifier&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;smsServiceImpl1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;zU9bsxj2&quot;&gt;我们还是建议通过 @Qualifier 注解来显示指定名称而不是依赖变量的名称。&lt;/p&gt;&lt;p data-pid=&quot;n657xaF_&quot;&gt;@Resource属于 JDK 提供的注解，默认注入方式为 byName。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为byType。&lt;/p&gt;&lt;p data-pid=&quot;Ptbedm2e&quot;&gt;@Resource 有两个比较重要且日常开发常用的属性：name（名称）、type（类型）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Resource&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;jqQZyRiw&quot;&gt;如果仅指定 name 属性则注入方式为byName，如果仅指定type属性则注入方式为byType，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 报错，byName 和 byType 都无法匹配到 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsServiceImpl1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;smsServiceImpl1&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SmsService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smsService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;-UaQIws7&quot;&gt;简单总结一下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;-2keCio9&quot;&gt;@Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。&lt;/li&gt;&lt;li data-pid=&quot;g1ded-v1&quot;&gt;Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。&lt;/li&gt;&lt;li data-pid=&quot;P7Uwn-4s&quot;&gt;当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显示指定名称，@Resource可以通过 name 属性来显示指定名称。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Bean 的作用域有哪些?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;gGKqZoMB&quot;&gt;Spring 中 Bean 的作用域通常有下面几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;zRxa5A5O&quot;&gt;&lt;b&gt;singleton&lt;/b&gt; : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。&lt;/li&gt;&lt;li data-pid=&quot;HfPvdoFB&quot;&gt;&lt;b&gt;prototype&lt;/b&gt; : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。&lt;/li&gt;&lt;li data-pid=&quot;yW8gM9wM&quot;&gt;&lt;b&gt;request&lt;/b&gt; （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。&lt;/li&gt;&lt;li data-pid=&quot;aeNFSz1B&quot;&gt;&lt;b&gt;session&lt;/b&gt; （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。&lt;/li&gt;&lt;li data-pid=&quot;zfpzLyaE&quot;&gt;&lt;b&gt;application/global-session&lt;/b&gt; （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），，该 bean 仅在当前应用启动时间内有效。&lt;/li&gt;&lt;li data-pid=&quot;t7BLtbO4&quot;&gt;&lt;b&gt;websocket&lt;/b&gt; （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Wdap7ETM&quot;&gt;&lt;b&gt;如何配置 bean 的作用域呢？&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;29giT_HY&quot;&gt;xml 方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;bean id=&quot;...&quot; class=&quot;...&quot; scope=&quot;singleton&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;UMCqoKq7&quot;&gt;注解方式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Scope&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ConfigurableBeanFactory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SCOPE_PROTOTYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;personPrototype&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;单例 Bean 的线程安全问题了解吗？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;E_4_mWHp&quot;&gt;大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。&lt;/p&gt;&lt;p data-pid=&quot;ExRxpR-Z&quot;&gt;常见的有两种解决办法：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;eTV1EOca&quot;&gt;在 Bean 中尽量避免定义可变的成员变量。&lt;/li&gt;&lt;li data-pid=&quot;KUCz4zQ7&quot;&gt;在类中定义一个 ThreadLocal 成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;MB7k8ziy&quot;&gt;不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Bean 的生命周期了解么?&lt;/b&gt;&lt;/h3&gt;&lt;blockquote data-pid=&quot;oampAYZw&quot;&gt; 下面的内容整理自：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//yemengying.com/2016/07/14/spring-bean-life-cycle/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;yemengying.com/2016/07/&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;14/spring-bean-life-cycle/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; ，除了这篇文章，再推荐一篇很不错的文章 ：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zrtqsk/p/3735273.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/zrtqsk/p/37&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;35273.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 。  &lt;/blockquote&gt;&lt;ul&gt;&lt;li data-pid=&quot;qd-_Toh4&quot;&gt;Bean 容器找到配置文件中 Spring Bean 的定义。&lt;/li&gt;&lt;li data-pid=&quot;9JVRpXBt&quot;&gt;Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。&lt;/li&gt;&lt;li data-pid=&quot;MFG_N1Dq&quot;&gt;如果涉及到一些属性值 利用 set()方法设置一些属性值。&lt;/li&gt;&lt;li data-pid=&quot;3h09eSOd&quot;&gt;如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字。&lt;/li&gt;&lt;li data-pid=&quot;z-LEAXdZ&quot;&gt;如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;KV0BiiqN&quot;&gt;如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例。&lt;/li&gt;&lt;li data-pid=&quot;1779JQyl&quot;&gt;与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。&lt;/li&gt;&lt;li data-pid=&quot;Rq_SSfz4&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法&lt;/li&gt;&lt;li data-pid=&quot;Ds902rmV&quot;&gt;如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法。&lt;/li&gt;&lt;li data-pid=&quot;9_H6FYLc&quot;&gt;如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。&lt;/li&gt;&lt;li data-pid=&quot;C9L9qkjM&quot;&gt;如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法&lt;/li&gt;&lt;li data-pid=&quot;AmUizyp5&quot;&gt;当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。&lt;/li&gt;&lt;li data-pid=&quot;szyswK-N&quot;&gt;当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;2WeqIgNz&quot;&gt;图示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1272&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-7498c5c4fd5f5ab53ff6e84b49fde9d6_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;jIkD0nHY&quot;&gt;与之比较类似的中文版本:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;303&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-539a40a6c77eba95a23146dcd39fd28a_b.jpg&quot;/&gt;&lt;figcaption&gt;Spring Bean 生命周期&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;Spring AoP&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;谈谈自己对于 AOP 的了解&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;OXXJZruw&quot;&gt;AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。&lt;/p&gt;&lt;p data-pid=&quot;C_-lAJri&quot;&gt;Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 &lt;b&gt;JDK Proxy&lt;/b&gt;，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 &lt;b&gt;Cglib&lt;/b&gt; 生成一个被代理对象的子类来作为代理，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;354&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3438696c64b8eac308dab82c2b355ed3_b.jpg&quot;/&gt;&lt;figcaption&gt;SpringAOPProcess&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;NDONXps6&quot;&gt;当然你也可以使用 &lt;b&gt;AspectJ&lt;/b&gt; ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。&lt;/p&gt;&lt;p data-pid=&quot;IjfseH-n&quot;&gt;AOP 切面编程设计到的一些专业术语：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;术语&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;目标(Target)&lt;/td&gt;&lt;td&gt;被通知的对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理(Proxy)&lt;/td&gt;&lt;td&gt;向目标对象应用通知之后创建的代理对象&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;连接点(JoinPoint)&lt;/td&gt;&lt;td&gt;目标对象的所属类中，定义的所有方法均为连接点&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切入点(Pointcut)&lt;/td&gt;&lt;td&gt;被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;通知(Advice)&lt;/td&gt;&lt;td&gt;增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;切面(Aspect)&lt;/td&gt;&lt;td&gt;切入点(Pointcut)+通知(Advice)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Weaving(织入)&lt;/td&gt;&lt;td&gt;将通知应用到目标对象，进而生成代理对象的过程动作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring AOP 和 AspectJ AOP 有什么区别？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;QZYNjqVz&quot;&gt;&lt;b&gt;Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。&lt;/b&gt; Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。&lt;/p&gt;&lt;p data-pid=&quot;cito6I0x&quot;&gt;Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，&lt;/p&gt;&lt;p data-pid=&quot;GpGyl7Qa&quot;&gt;如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;AspectJ 定义的通知类型有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;hRntEfQu&quot;&gt;&lt;b&gt;Before&lt;/b&gt;（前置通知）：目标对象的方法调用之前触发&lt;/li&gt;&lt;li data-pid=&quot;qsGNYMXI&quot;&gt;&lt;b&gt;After&lt;/b&gt; （后置通知）：目标对象的方法调用之后触发&lt;/li&gt;&lt;li data-pid=&quot;ygUb0DaU&quot;&gt;&lt;b&gt;AfterReturning&lt;/b&gt;（返回通知）：目标对象的方法调用完成，在返回结果值之后触发&lt;/li&gt;&lt;li data-pid=&quot;_DY3DiFW&quot;&gt;&lt;b&gt;AfterThrowing&lt;/b&gt;（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。&lt;/li&gt;&lt;li data-pid=&quot;zmhtoksK&quot;&gt;&lt;b&gt;Around&lt;/b&gt;： （环绕通知）编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;多个切面的执行顺序如何控制？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Fu46aNTv&quot;&gt;1、通常使用@Order 注解直接定义切面顺序&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 值越小优先级越高
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nd&quot;&gt;@Order&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ordered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;zH_0pO7a&quot;&gt;&lt;b&gt;2、实现Ordered 接口重写 getOrder 方法。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@Aspect&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;LoggingAspect&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ordered&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// ....
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getOrder&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 返回值越小优先级越高
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;Spring MVC&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;说说自己对于 Spring MVC 了解?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;r7QDh2Pn&quot;&gt;MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;481&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0a691dea1f84b22d2167c7a35d15a426_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;17wSFqs-&quot;&gt;网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/iluwatar/java-design-patterns&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;java-design-patterns&lt;/a&gt;** 项目中就有关于 MVC 的相关介绍。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1156&quot; data-rawheight=&quot;1198&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fbb79a0fb04ed748a65f4c22edeb9ec4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4D9V8YJP&quot;&gt;想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。&lt;/p&gt;&lt;p data-pid=&quot;J8z4Bygh&quot;&gt;&lt;b&gt;Model 1 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;a9agJY0E&quot;&gt;很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。&lt;/p&gt;&lt;p data-pid=&quot;MbYU0ZvK&quot;&gt;这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;809&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b49347ea36e7c44dcab6a6097632bfa8_b.jpg&quot;/&gt;&lt;figcaption&gt;mvc-mode1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;tREuwrw1&quot;&gt;&lt;b&gt;Model 2 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;uvGBmEL1&quot;&gt;学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MyzUfVoa&quot;&gt;Model:系统涉及的数据，也就是 dao 和 bean。&lt;/li&gt;&lt;li data-pid=&quot;JHavbVzg&quot;&gt;View：展示模型中的数据，只是用来展示。&lt;/li&gt;&lt;li data-pid=&quot;9Fe7J2f0&quot;&gt;Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;843&quot; data-rawheight=&quot;424&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-bf377aa840ff80122a3ca306e76e2602_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Vdg7Q4n5&quot;&gt;Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。&lt;/p&gt;&lt;p data-pid=&quot;7vweY6uf&quot;&gt;于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。&lt;/p&gt;&lt;p data-pid=&quot;uTxGBasn&quot;&gt;&lt;b&gt;Spring MVC 时代&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;OeCnWUxx&quot;&gt;随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。&lt;/p&gt;&lt;p data-pid=&quot;lf4AkWXf&quot;&gt;MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Spring MVC 的核心组件有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;DfpzHp_4&quot;&gt;记住了下面这些组件，也就记住了 SpringMVC 的工作原理。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;mZxPPCMD&quot;&gt;&lt;b&gt;DispatcherServlet&lt;/b&gt; ：&lt;b&gt;核心的中央处理器&lt;/b&gt;，负责接收请求、分发，并给予客户端响应。&lt;/li&gt;&lt;li data-pid=&quot;yLi7x_oB&quot;&gt;&lt;b&gt;HandlerMapping&lt;/b&gt; ：&lt;b&gt;处理器映射器&lt;/b&gt;，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;HzJ4Y3xl&quot;&gt;&lt;b&gt;HandlerAdapter&lt;/b&gt; ：&lt;b&gt;处理器适配器&lt;/b&gt;，根据 HandlerMapping 找到的 Handler ，适配执行对应的 Handler；&lt;/li&gt;&lt;li data-pid=&quot;6C4YD2DR&quot;&gt;&lt;b&gt;Handler&lt;/b&gt; ：&lt;b&gt;请求处理器&lt;/b&gt;，处理实际请求的处理器。&lt;/li&gt;&lt;li data-pid=&quot;-tZkpf5f&quot;&gt;&lt;b&gt;ViewResolver&lt;/b&gt; ：&lt;b&gt;视图解析器&lt;/b&gt;，根据 Handler 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 DispatcherServlet 响应客户端&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;SpringMVC 工作原理了解吗?&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;WTtjFr8P&quot;&gt;&lt;b&gt;Spring MVC 原理如下图所示：&lt;/b&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;m1HSkGtd&quot;&gt; SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。  &lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;737&quot; data-rawheight=&quot;419&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-715f8d02b593f2716064f6dd432c2db5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TWiYsFIn&quot;&gt;&lt;b&gt;流程说明（重要）：&lt;/b&gt;&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;Kt6pgw1S&quot;&gt;客户端（浏览器）发送请求， DispatcherServlet拦截请求。&lt;/li&gt;&lt;li data-pid=&quot;G7q1kTx7&quot;&gt;DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。&lt;/li&gt;&lt;li data-pid=&quot;xLBSI4VD&quot;&gt;DispatcherServlet 调用 HandlerAdapter适配执行 Handler 。&lt;/li&gt;&lt;li data-pid=&quot;--qaNoGQ&quot;&gt;Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。&lt;/li&gt;&lt;li data-pid=&quot;XX3SBhgT&quot;&gt;ViewResolver 会根据逻辑 View 查找实际的 View。&lt;/li&gt;&lt;li data-pid=&quot;nwviXbuz&quot;&gt;DispaterServlet 把返回的 Model 传给 View（视图渲染）。&lt;/li&gt;&lt;li data-pid=&quot;kjnpTAOB&quot;&gt;把 View 返回给请求者（浏览器）&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;统一异常处理怎么做？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;J_xbRa4X&quot;&gt;推荐使用注解的方式统一异常处理，具体会使用到 @ControllerAdvice + @ExceptionHandler 这两个注解 。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@ControllerAdvice&lt;/span&gt;
&lt;span class=&quot;nd&quot;&gt;@ResponseBody&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GlobalExceptionHandler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handleAppException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BaseException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//......
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@ExceptionHandler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResourceNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseEntity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ErrorReponse&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;handleResourceNotFoundException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResourceNotFoundException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpServletRequest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//......
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;GE_1EL41&quot;&gt;这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被@ExceptionHandler 注解修饰的方法进行处理。&lt;/p&gt;&lt;p data-pid=&quot;zV1kWuD_&quot;&gt;ExceptionHandlerMethodResolver 中 getMappedMethod 方法决定了异常具体被哪个被 @ExceptionHandler 注解修饰的方法处理异常。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;nd&quot;&gt;@Nullable&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Method&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getMappedMethod&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Throwable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mappedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;keySet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isAssignableFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mappedException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 不为空说明有方法处理异常
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 按照匹配程度从小到大排序
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionDepthComparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exceptionType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 返回处理异常的方法
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;mappedMethods&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;gxNGu5g2&quot;&gt;从源代码看出：getMappedMethod()会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。&lt;/p&gt;&lt;p data-pid=&quot;Zsg3bAYV&quot;&gt;由于篇幅过多，部分内容没有放出来，你可以点击下面的链接进行在线阅读，体验更好一些。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-f8338a1bb365c97b5514762e1156a7ac_120x160.jpg&quot; data-image-width=&quot;361&quot; data-image-height=&quot;741&quot; data-text=&quot;Spring 常见面试题总结&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;h2&gt;&lt;b&gt;参考&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;DCZRDsnx&quot;&gt;自荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 。这是我在大三开始准备秋招面试的时候创建的，已经维护了 4 年多了，目前这个项目在 Github 上收到了 125k+ 的 star。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-d31f72b06d90a3b2d206f13addc05536_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;x3TMP6mg&quot;&gt;并且，这个项目还推出了一个PDF版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;。&lt;/p&gt;&lt;p data-pid=&quot;p77rmSsZ&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Java 面试指北 》&lt;/a&gt; 是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-eb29b2d8245630aa4c87313f77bd4b1f_b.jpg&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QUWht3wd&quot;&gt;为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;。虽然收费只有培训班/训练营的百分之一，但是&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;里的内容质量更高，提供的服务也更全面。&lt;/p&gt;&lt;p data-pid=&quot;3Y-AzN2P&quot;&gt;欢迎准备 Java 面试以及学习 Java 的同学加入我的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;知识星球&lt;/a&gt;，干货非常多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。&lt;/p&gt;&lt;p data-pid=&quot;DKBMAlDc&quot;&gt;我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>969d1e95b11703989aa658ee21b81715</guid>
<title>python命令行传递参数的两种方式！</title>
<link>https://toutiao.io/k/9r1cvll</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;p&gt;&lt;span&gt;python在命令行运行.py文件时，如何在命令行传递参数给运行程序，python默认提供了sys模块的系统参数属性实现接收命令行中的外部参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx4f706964b979122a&quot; data-miniprogram-path=&quot;pages/topics/topics?group_id=48841258855188&quot; data-miniprogram-nickname=&quot;知识星球&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;span&gt;立即前往微信小程序【知识星球】提问&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一种则是通过argparse模块实现的，argparse模块可以实现事先对命令行参数的初始化，更加的便于命令行参数的管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、sys.argv参数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sys.argv的命令行参数获取方式比较的简单，直接通过提取sys.argv的值就可以获取到其对应的参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，下面写一个hello_world.py模块，并且在其中引用了命令行参数。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;&lt;br/&gt;print(&lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + str(sys.argv[&lt;span&gt;1&lt;/span&gt;]) + &lt;span&gt;&#x27;, welcome to Hello World!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;直接在命令行执行当前的.py文件，执行命令应该是这样的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python hello_world.py Siri&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这时我们预期的结果应该是下面这样的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# Hi Siri, welcome to Hello World!&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;执行后的结果和预期的运行结果是一模一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.13270142180094788&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hGLENdnjAZvaNQjzCNYSSoGFbyeNLamj5Ol1q6jp86tWiaq2ib6yUg5yAJfH6W7P7sQryEQicZqQ4zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在运行时，有一个不好的地方时，若是在命令行没有传递足够的参数，则会直接抛出下面的异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.22925457102672292&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hGLENdnjAZvaNQjzCNYSSoXiaUK45af72pjB0ic9tWKCtTkZ7bJT4XD4mia1fKFsCUcA7HiaFicUF9UmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、argparse参数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用argparse模块，有一个好处就是事先对需要在命令行传递的参数做一个初始化的赋值，若是命令行没有值的时候则可以使用默认值来赋值。&lt;/span&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1659966677034&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1659966677034&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并且argparse模块可以通过参数构造器ArgumentParser实现对参数的管理，看起来一目了然。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; argparse&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 初始化参数构造器&lt;/span&gt;&lt;br/&gt;parser = argparse.ArgumentParser()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在参数构造器中添加两个命令行参数&lt;/span&gt;&lt;br/&gt;parser.add_argument(&lt;span&gt;&#x27;--name&#x27;&lt;/span&gt;, type=str, default=&lt;span&gt;&#x27;Siri&#x27;&lt;/span&gt;)&lt;br/&gt;parser.add_argument(&lt;span&gt;&#x27;--message&#x27;&lt;/span&gt;, type=str, default=&lt;span&gt;&#x27;,Welcom to Python World!&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取所有的命令行参数&lt;/span&gt;&lt;br/&gt;args = parser.parse_args()&lt;br/&gt;&lt;br/&gt;print(&lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + str(args.name) + str(args.message))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;同样的，创建一个hello_python.py文件，来运行上述代码块，看一下执行效果。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python hello_python.py&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.13937753721244925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hGLENdnjAZvaNQjzCNYSSoae7fia6iaDQF06jNmoEo92XQQxiadjv53Nk7LlDUFHFGUmKPicLyEjuyrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;739&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以发现在未添加命令行的参数传递后，默认使用的是我们构造器中添加的参数默认值来进行赋值的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，若是我们在命令行中再次对参数进行重新赋值是怎样的效果。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;python hello_python.py --name Laow  --message Hello_World&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12729357798165136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hGLENdnjAZvaNQjzCNYSSoNQ1icLicDPX3eewEOdmvsYfwMbYJkH3le4sROaon7L1VrK0SpHiaB4w5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「Python 集中营」&lt;/span&gt;&lt;/strong&gt;，只做知识分享 ！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA3ODk1Mzg0Mg==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hibKwqc6pgs9eu9tgh5AeibzhIhhMcAiaKaoczZdvmic9lLBP6oAyjibayia3ctN1WXEFyVia1OXoD9y3ibQ/0?wx_fmt=png&quot; data-nickname=&quot;Python 集中营&quot; data-alias=&quot;python_code1024&quot; data-signature=&quot;编程技巧、实战总结，在 Python 的路上越走越宽，+关注自动领取Python 学习视频资料！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;100369&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7010309278350515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wzyc1ToJM6jZ9Tw2LhvvECOI5ek5Z6QRGV5eQZSNTBBygEr9pUBvbrGWNmJfYYWQDohfUsIwt0ibtKBd2xxJiciaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;291&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;创作不易，点赞、分享支持一下 ~&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;加个鸡腿🍗&lt;/p&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>