<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>49f81a094050d173cc12d18613bec208</guid>
<title>利用 Jackson 序列化实现数据脱敏</title>
<link>https://toutiao.io/k/5x6kx1h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h4&gt;作者：京东物流 张晓旭&lt;/h4&gt;

&lt;h1&gt;1.背景&lt;/h1&gt;

&lt;p&gt;在项目中有些敏感信息不能直接展示，比如客户手机号、身份证、车牌号等信息，展示时均需要进行数据脱敏，防止泄露客户隐私。脱敏即是对数据的部分信息用脱敏符号（*）处理。&lt;/p&gt;

&lt;h1&gt;2.目标&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;  在服务端返回数据时，利用Jackson序列化完成数据脱敏，达到对敏感信息脱敏展示。&lt;/li&gt;
&lt;li&gt;  降低重复开发量，提升开发效率&lt;/li&gt;
&lt;li&gt;  形成统一有效的脱敏规则&lt;/li&gt;
&lt;li&gt;  可基于重写默认脱敏实现的desensitize方法，实现可扩展、可自定义的个性化业务场景的脱敏需求&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;3.主要实现&lt;/h1&gt;

&lt;h2&gt;3.1基于Jackson的自定义脱敏序列化实现&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;StdSerializer&lt;/strong&gt;：所有标准序列化程序所使用的基类，这个是编写自定义序列化程序所推荐使用的基类。&lt;br/&gt;
&lt;strong&gt;ContextualSerializer：&lt;/strong&gt;是Jackson 提供的另一个序列化相关的接口，它的作用是通过字段已知的上下文信息定制JsonSerializer。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.serializer;




import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.BeanProperty;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.ser.ContextualSerializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import com.jd.ccmp.ctm.constraints.Symbol;
import com.jd.ccmp.ctm.constraints.annotation.Desensitize;
import com.jd.ccmp.ctm.constraints.desensitization.Desensitization;
import com.jd.ccmp.ctm.constraints.desensitization.DesensitizationFactory;
import com.jd.ccmp.ctm.constraints.desensitization.DefaultDesensitization;




import java.io.IOException;




/**
 * 脱敏序列化器
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:10
 */
public class ObjectDesensitizeSerializer extends StdSerializer&amp;lt;Object&amp;gt; implements ContextualSerializer {
    private static final long serialVersionUID = -7868746622368564541L;
    private transient Desensitization&amp;lt;Object&amp;gt; desensitization;
    protected ObjectDesensitizeSerializer() {
        super(Object.class);
    }
    public Desensitization&amp;lt;Object&amp;gt; getDesensitization() {
        return desensitization;
    }
    public void setDesensitization(Desensitization&amp;lt;Object&amp;gt; desensitization) {
        this.desensitization = desensitization;
    }
    @Override
    public JsonSerializer&amp;lt;Object&amp;gt; createContextual(SerializerProvider prov, BeanProperty property) {
//获取属性注解
        Desensitize annotation = property.getAnnotation(Desensitize.class);
        return createContextual(annotation.desensitization());
    }
    @SuppressWarnings(&quot;unchecked&quot;)
    public JsonSerializer&amp;lt;Object&amp;gt; createContextual(Class&amp;lt;? extends Desensitization&amp;lt;?&amp;gt;&amp;gt; clazz) {
        ObjectDesensitizeSerializer serializer = new ObjectDesensitizeSerializer();
        if (clazz != DefaultDesensitization.class) {
            serializer.setDesensitization((Desensitization&amp;lt;Object&amp;gt;) DesensitizationFactory.getDesensitization(clazz));
        }
        return serializer;
    }
    @Override
    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException {
        Desensitization&amp;lt;Object&amp;gt; objectDesensitization = getDesensitization();
        if (objectDesensitization != null) {
            try {
                gen.writeObject(objectDesensitization.desensitize(value));
            } catch (Exception e) {
                gen.writeObject(value);
            }
        } else if (value instanceof String) {
            gen.writeString(Symbol.getSymbol(((String) value).length(), Symbol.STAR));
        } else {
            gen.writeObject(value);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：createContextual可以获得字段的类型以及注解。当字段拥有自定义注解时，取出注解中的值创建定制的序列化方式，这样在serialize方法中便可以得到这个值了。&lt;strong&gt;createContextual&lt;/strong&gt;方法只会在第一次序列化字段时调用（因为字段的上下文信息在运行期不会改变），所以无需关心性能问题。&lt;/p&gt;

&lt;h2&gt;3.2定义脱敏接口、以及工厂实现&lt;/h2&gt;

&lt;h3&gt;3.2.1脱敏器接口定义&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.desensitization;


/**
 * 脱敏器
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 10:56
 */
public interface Desensitization&amp;lt;T&amp;gt; {
    /**
     * 脱敏实现
     *
     * @param target 脱敏对象
     * @return 脱敏返回结果
     */
    T desensitize(T target);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.2.2脱敏器工厂实现&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.desensitization;


import java.util.HashMap;
import java.util.Map;


/**
 * 工厂方法
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 10:58
 */
public class DesensitizationFactory {
    private DesensitizationFactory() {
    }
    private static final Map&amp;lt;Class&amp;lt;?&amp;gt;, Desensitization&amp;lt;?&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();




    @SuppressWarnings(&quot;all&quot;)
    public static Desensitization&amp;lt;?&amp;gt; getDesensitization(Class&amp;lt;?&amp;gt; clazz) {
        if (clazz.isInterface()) {
            throw new UnsupportedOperationException(&quot;desensitization is interface, what is expected is an implementation class !&quot;);
        }
        return map.computeIfAbsent(clazz, key -&amp;gt; {
            try {
                return (Desensitization&amp;lt;?&amp;gt;) clazz.newInstance();
            } catch (InstantiationException | IllegalAccessException e) {
                throw new UnsupportedOperationException(e.getMessage(), e);
            }
        });
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.3常用的脱敏器实现&lt;/h2&gt;

&lt;h3&gt;3.3.1默认脱敏实现&lt;/h3&gt;

&lt;p&gt;可基于默认实现，扩展实现个性化场景&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.desensitization;


/**
 * 默认脱敏实现
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:01
 */
public interface DefaultDesensitization extends Desensitization&amp;lt;String&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.3.2手机号脱敏器&lt;/h3&gt;

&lt;p&gt;实现对手机号中间4位号码脱敏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.desensitization;
import com.jd.ccmp.ctm.constraints.Symbol;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * 手机号脱敏器，保留前3位和后4位
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:02
 */
public class MobileNoDesensitization implements DefaultDesensitization {
    /**
     * 手机号正则
     */
    private static final Pattern DEFAULT_PATTERN = Pattern.compile(&quot;(13[0-9]|14[579]|15[0-3,5-9]|16[6]|17[0135678]|18[0-9]|19[89])\\d{8}&quot;);




    @Override
    public String desensitize(String target) {
        Matcher matcher = DEFAULT_PATTERN.matcher(target);
        while (matcher.find()) {
            String group = matcher.group();
            target = target.replace(group, group.substring(0, 3) + Symbol.getSymbol(4, Symbol.STAR) + group.substring(7, 11));
        }
        return target;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.4注解定义&lt;/h2&gt;

&lt;p&gt;通过@JacksonAnnotationsInside实现自定义注解，提高易用性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.annotation;
import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.jd.ccmp.ctm.constraints.desensitization.Desensitization;
import com.jd.ccmp.ctm.constraints.serializer.ObjectDesensitizeSerializer;
import java.lang.annotation.*;


/**
 * 脱敏注解
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:09
 */
@Target({ElementType.FIELD, ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@JsonSerialize(using = ObjectDesensitizeSerializer.class)
@Documented
public @interface Desensitize {
    /**
     * 对象脱敏器实现
     */
    @SuppressWarnings(&quot;all&quot;)
    Class&amp;lt;? extends Desensitization&amp;lt;?&amp;gt;&amp;gt; desensitization();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3.4.1默认脱敏注解&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.annotation;
import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;
import com.jd.ccmp.ctm.constraints.desensitization.DefaultDesensitization;
import java.lang.annotation.*;




/**
 * 默认脱敏注解
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:14
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@Desensitize(desensitization = DefaultDesensitization.class)
@Documented
public @interface DefaultDesensitize {
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.4.2手机号脱敏注解&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints.annotation;
import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;
import com.jd.ccmp.ctm.constraints.desensitization.MobileNoDesensitization;
import java.lang.annotation.*;


/**
 * 手机号脱敏
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 11:18
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotationsInside
@Desensitize(desensitization = MobileNoDesensitization.class)
@Documented
public @interface MobileNoDesensitize {
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.5定义脱敏符号&lt;/h2&gt;

&lt;p&gt;支持指定脱敏符号，例如* 或是 ^_^&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.jd.ccmp.ctm.constraints;
import java.util.stream.Collectors;
import java.util.stream.IntStream;


/**
 * 脱敏符号
 *
 * @author zhangxiaoxu15
 * @date 2022/2/8 10:53
 */
public class Symbol {
    /**
     * &#x27;*&#x27;脱敏符
     */
    public static final String STAR = &quot;*&quot;;
    private Symbol() {}
    /**
     * 获取符号
     *
     * @param number 符号个数
     * @param symbol 符号
     */
    public static String getSymbol(int number, String symbol) {
        return IntStream.range(0, number).mapToObj(i -&amp;gt; symbol).collect(Collectors.joining());
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;4.使用样例&amp;amp;执行流程剖析&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=YjlmMjI4NmM3Nzg4ZGUzMjRhOTI2ZjgwMzM2MGY2MzQsMTY4MDIyNjI0ODU2Mw==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;程序类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://mp.toutiao.com/mp/agw/article_material/open_image/get?code=MTlmMTk3Y2RhM2MwOTkxZjZhZDYyNjA0YjEyNDlkYmUsMTY4MDIyNjI0ODU2Mw==&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;**执行流程剖析**
 1.调用JsonUtil.toJsonString()开始执行序列化
 2.识别属性mobile上的注解@MobileNoDesensitize(上文3.4.2)
 3.调用ObjectDesensitizeSerializer#createContextual(上文3.1 &amp;amp; 3.2)，返回JsonSerializer
 4.调用手机号脱敏实现MobileNoDesensitization#desensitize(上文3.3.2)
 5.输出脱敏后的序列化结果，{&quot;mobile&quot;:&quot;133****5678&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不难发现核心执行流程是第3步，但是@MobileNoDesensitize与ObjectDesensitizeSerializer又是如何联系起来的呢？&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  尝试梳理下引用链路：@MobileNoDesensitize -&amp;gt; @Desensitize -&amp;gt; @JsonSerialize -&amp;gt; ObjectDesensitizeSerializer&lt;/li&gt;
&lt;li&gt;  但是，在ObjectDesensitizeSerializer的实现中，我们似乎却没有发现上述链路的直接调用关系&lt;/li&gt;
&lt;li&gt;  这就不得不说下Jackson元注解的概念&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;**Jackson元注解**
1.提到元注解这个词，大家会想到@Target、@Retention、@Documented、@Inherited
2.Jackson也以同样的思路设计了@JacksonAnnotationsInside


/**
 * Meta-annotation (annotations used on other annotations)
 * used for indicating that instead of using target annotation
 * (annotation annotated with this annotation),
 * Jackson should use meta-annotations it has.
 * This can be useful in creating &quot;combo-annotations&quot; by having
 * a container annotation, which needs to be annotated with this
 * annotation as well as all annotations it &#x27;contains&#x27;.
 * 
 * @since 2.0
 */
@Target({ElementType.ANNOTATION_TYPE})
@Retention(RetentionPolicy.RUNTIME)
@JacksonAnnotation
public @interface JacksonAnnotationsInside
{
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正是通过”combo-annotations”(组合注解、捆绑注解)的机制，实现了指示Jackson应该使用其拥有的元注释，而不是使用目标注释，从而实现了自定义脱敏实现设计目标。&lt;/p&gt;

&lt;h1&gt;5.总结&lt;/h1&gt;

&lt;p&gt;以上就是利用Jackson序列化实现数据脱敏的全过程，如有此类需求的同学可以借鉴上面的实现方法。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da45b343ceaab155765b11e1ebf66929</guid>
<title>Flink 的重试机制</title>
<link>https://toutiao.io/k/h61szaq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote data-first-child=&quot;&quot; data-pid=&quot;qCcxlrR6&quot;&gt;当 Task 发生故障时，Flink 需要重启出错的 Task 以及其他受到影响的 Task ，以使得作业恢复到正常执行状态。Flink 通过重启策略和故障恢复策略来控制 Task 重启：重启策略决定是否可以重启以及重启的间隔；故障恢复策略决定哪些 Task 需要重启。&lt;/blockquote&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-f98a3ccee5e0842fe475a6d4fec3a7c3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;315&quot; data-rawheight=&quot;164&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;315&quot; data-rawheight=&quot;164&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f98a3ccee5e0842fe475a6d4fec3a7c3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;Flink重启策略&lt;/h2&gt;&lt;p data-pid=&quot;YBbKwhR-&quot;&gt;Flink的重试机制主要体现在，Flink Task出现错误的时候，需要恢复异常的Task和受影响的Task，故此需要一定的策略来进行发现和解决。&lt;/p&gt;&lt;h2&gt;Flink重启策略配置方式&lt;/h2&gt;&lt;p data-pid=&quot;xDnW28BL&quot;&gt;通过 Flink 的配置文件&lt;code&gt;flink-conf.yaml&lt;/code&gt;来设置默认的重启策略。配置参数&lt;i&gt;restart-strategy&lt;/i&gt;定义了采取何种策略。 如果没有启用 checkpoint，就采用“不重启”策略。如果启用了 checkpoint 且没有配置重启策略，那么就采用固定延时重启策略， 此时最大尝试重启次数由&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;参数设置。下表列出了可用的重启策略和与其对应的配置值。&lt;/p&gt;&lt;p data-pid=&quot;1VyFm6XT&quot;&gt;除了定义默认的重启策略以外，还可以为每个 Flink 作业单独定义重启策略。 这个重启策略通过在程序中的 &lt;code&gt;ExecutionEnvironment&lt;/code&gt; 对象上调用 &lt;code&gt;setRestartStrategy&lt;/code&gt; 方法来设置。 当然，对于 &lt;code&gt;StreamExecutionEnvironment&lt;/code&gt; 也同样适用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;n&quot;&gt;ExecutionEnvironment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutionEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getExecutionEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setRestartStrategy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RestartStrategies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fixedDelayRestart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;j__8JcSz&quot;&gt;下例展示了如何给我们的作业设置固定延时重启策略。 如果发生故障，系统会重启作业 3 次，每两次连续的重启尝试之间等待 10 秒钟。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;bdZuTqFP&quot;&gt;在Flink中提供了3种重启策略：&lt;/p&gt;&lt;p data-pid=&quot;enEwDeKY&quot;&gt;1、none：在不配置chechpoint的情况下默认采用的是 不启用策略 即出现错误即停止任务。&lt;/p&gt;&lt;p data-pid=&quot;n81QLA49&quot;&gt;2、固定延迟策略&lt;/p&gt;&lt;p data-pid=&quot;ClpGcI3D&quot;&gt;3、故障率策略&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;Flink重启策略详情&lt;/h2&gt;&lt;p data-pid=&quot;88yvb4l-&quot;&gt;1、固定延迟&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restart-strategy.fixed-delay.attempts&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;重试次数如果超过则任务退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restart-strategy.fixed-delay.delay&lt;/td&gt;&lt;td&gt;Duration&lt;/td&gt;&lt;td&gt;1s&lt;/td&gt;&lt;td&gt;两个任务之间的延迟&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;xS3-ugTw&quot;&gt;2、故障率重启&lt;/p&gt;&lt;p data-pid=&quot;TwmS5mto&quot;&gt;故障率重启策略在故障发生之后重启作业，但是当&lt;b&gt;故障率&lt;/b&gt;（每个时间间隔发生故障的次数）超过设定的限制时，作业会最终失败。 在连续的两次重启尝试之间，重启策略等待一段固定长度的时间。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;key&lt;/th&gt;&lt;th&gt;type&lt;/th&gt;&lt;th&gt;default&lt;/th&gt;&lt;th&gt;含义&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restart-strategy.failure-rate.delay&lt;/td&gt;&lt;td&gt;Duration&lt;/td&gt;&lt;td&gt;1 s&lt;/td&gt;&lt;td&gt;重试的时间间隔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restart-strategy.failure-rate.failure-rate-interval&lt;/td&gt;&lt;td&gt;Duration&lt;/td&gt;&lt;td&gt;1 min&lt;/td&gt;&lt;td&gt;时间间隔&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;restart-strategy.failure-rate.max-failures-per-interval&lt;/td&gt;&lt;td&gt;Integer&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;时间间隔内最大的错误&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;WVQYKCjf&quot;&gt;默认配置&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;restart-strategy.failure-rate.max-failures-per-interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;/&gt;&lt;span class=&quot;nt&quot;&gt;restart-strategy.failure-rate.failure-rate-interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;l&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;w&quot;/&gt;&lt;span class=&quot;nt&quot;&gt;restart-strategy.failure-rate.delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;l&quot;&gt;s&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;n&quot;&gt;ExecutionEnvironment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExecutionEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getExecutionEnvironment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setRestartStrategy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RestartStrategies&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;failureRateRestart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 每个时间间隔的最大故障次数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MINUTES&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 测量故障率的时间间隔
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;n&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;of&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeUnit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SECONDS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 延时
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;hI3FMLZZ&quot;&gt;3、无重启策略&lt;/p&gt;&lt;p data-pid=&quot;k8Wdwz5-&quot;&gt;作业直接失败，不尝试重启。&lt;/p&gt;&lt;p data-pid=&quot;JcPO-ZT0&quot;&gt;不重启策略也可以在程序中设置：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Environmentalist env = ExecutionEnvironment.getExecutionEnvironment(); 
env.setRestartStrategy(RestartStrategies.noRestart());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;LFJGVEbs&quot;&gt;4、Fallback 重启策略&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2c440e3db4bf7620cb7747f8d079630</guid>
<title>ChatGPT4.0，基础生产力的变革！</title>
<link>https://toutiao.io/k/w00uzup</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;老张的求知思考世界&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;For-Think&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;专注互联网领域相关技术实践和思考，也分享职场成长、读书杂谈等内容。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49b8a47c2e043a833b5cdbe63c1fd278</guid>
<title>.NET 中比肩 System.Text.Json 序列化反序列化组件 MessagePack</title>
<link>https://toutiao.io/k/utc9zwq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官方定义：MessagePack是一种高效的二进制序列化格式。它允许像JSON一样在多个语言之间交换数据。但是它更快并且更小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MessagePack是一种开源的序列化反序列化组件，可支持JAVA，C#等主流语言。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 C# 中使用 MessagePack，需要添加 MessagePack-CSharp组件，在.NET6之后直接添加 MessagePack。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它支持 .NET Framework、.NET Core 和 Unity 应用程序。提供了一个简单的 API，可以帮助开发人员在应用程序中快速实现对象的序列化和反序列化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 MessagePack组件，可以将对象序列化为二进制数据，这样可以将数据存储在文件或网络中，以便以后使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也可以将二进制数据反序列化为对象，这样可以在应用程序中轻松地对数据进行操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、使用方法&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;新建一个.NET项目，使用Nuget工具添加 MessagePack组件；并在使用的代码页面添加命名空间MessagePack；添加完成之后就可以在这个代码页面使用了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;//本文使用是包MessagePack-CSharp&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; MessagePack;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;TestMessage&lt;/span&gt;()&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;     MyClass message = &lt;span&gt;new&lt;/span&gt; MyClass()&lt;br/&gt;     {&lt;br/&gt;         Name = &lt;span&gt;&quot;DOTNET开发跳槽&quot;&lt;/span&gt;,&lt;br/&gt;         Quantity = &lt;span&gt;100&lt;/span&gt;,&lt;br/&gt;         Anything = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;&quot;欢迎关注公众号DOTNET开发跳槽&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;4.2&lt;/span&gt;d, &lt;span&gt;&quot;祝大家学业有成&quot;&lt;/span&gt; })&lt;br/&gt;     };&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;// 序列化&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;byte&lt;/span&gt;[] buffer = MessagePackSerializer.Serialize(message, MessagePack.Resolvers.ContractlessStandardResolver.Instance);&lt;br/&gt;     &lt;span&gt;var&lt;/span&gt; json= MessagePackSerializer.ToJson(buffer);&lt;br/&gt;     &lt;span&gt;// 反序列化&lt;/span&gt;&lt;br/&gt;     MyClass returnMsg = MessagePackSerializer.Deserialize&amp;lt;MyClass&amp;gt;(buffer,MessagePack.Resolvers.ContractlessStandardResolver.Instance);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//类如下     &lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyClass&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Quantity { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt; Anything { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效果如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;230&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3978658536585366&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/oDaAmt9QDicRTG2so2ofmP5V77ydfEQYpfvekrmD6I6AAzmoT9XosFXBsn2Jlv5WqaR1cLjwoZXuDPVsggglNCg/640?wx_fmt=png&quot; data-w=&quot;656&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、MessagePack 与 System.Text.Json比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MessagePack-CSharp 与 System.Text.Json 都是用于序列化和反序列化数据的工具，但它们有一些不同点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、数据大小&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MessagePack-CSharp 生成的数据通常比 System.Text.Json 生成的数据更小，因为 MessagePack-CSharp 使用了一些压缩技术。这意味着在网络传输和存储上，使用 MessagePack-CSharp 可能会更加有效。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、性能&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MessagePack-CSharp 在序列化和反序列化上的性能通常比 System.Text.Json 更快。这是因为 MessagePack-CSharp 使用了基于二进制的数据格式，而不是基于文本的格式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，MessagePack-CSharp 还提供了一些高级选项，例如多线程序列化和反序列化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;性能方面有博主测试了这两者的性能，大家可以参考一下，结果图片如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37987012987012986&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/oDaAmt9QDicRTG2so2ofmP5V77ydfEQYpZb8Q03TVjxRuhSTD3pYoROMlhVGiahXRB8bibKRhXmD2wqaaKsibvj2XA/640?wx_fmt=png&quot; data-w=&quot;924&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图方法2和方法4是System.Text.Json的方法，由此可见MessagePack是优于System.Text.Json的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、运行环境支持&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MessagePack-CSharp 对各种运行环境的支持比 System.Text.Json 更广泛。例如，MessagePack-CSharp 不仅可以在 .NET 和 .NET Core 上运行，还可以在 Unity 和 Xamarin 等其他平台上运行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、数据可读性&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;System.Text.Json 生成的数据通常比 MessagePack-CSharp 生成的数据更易于人类阅读和解码。这是因为 System.Text.Json 使用了 JSON 格式，该格式是一种易于阅读和编写的文本格式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;综上所述，选择哪种工具取决于你的具体需求。如果需要快速的序列化和反序列化速度和小的数据大小，则 MessagePack-CSharp 是一个不错的选择。如果需要可读性更好的数据并且不太在意性能，则 System.Text.Json 是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍了MessagePack和它在C#的使用，以及它与System.Text.Json的比较，总的来说MessagePack优于System.Text.Json，当然使用的话得根据你的项目情况来定。希望本文能对你有所收获，同时欢迎大家吐槽。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官网：https://msgpack.org/&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8ba7b1e47bc8a2015d3752216446969f</guid>
<title>如何当个优秀的文档工程师？从 TC China 看技术文档工程师的自我修养</title>
<link>https://toutiao.io/k/uvtqqeq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post&quot; itemprop=&quot;articleBody&quot;&gt;
          &lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/document-engineering.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文系 NebulaGraph Community Academic 技术文档工程师 Abby 的参会观感，讲述了她在中国技术传播大会分享的收获以及感悟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;据说，技术内容领域、传播领域的专家和决策者们会在中国技术传播大会「tcworld China 2022」大会上分享心得。作为一名技术文档工程师，本着了解相关行业的发展趋势和提升自我为 NebulaGraph 社区创造更大价值的心态，参加了此次大会。&lt;br/&gt;
第一次参加 tcworld China 技术传播大会，干货挺多，记录一下参会的收获和感受。&lt;/p&gt;
&lt;p&gt;tc，技术内容，全称 technical content。既然是技术内容，那么技术内容是如何进行传播呢？&lt;/p&gt;
&lt;p&gt;初看，会觉得技术传播和作为内容生产者的技术文档工程师或资料开发没有半毛钱关系。然而，是本人坐井观天了：全场听下来，许多课程主题涉及“从内容到营销”，当中不乏营销常出现的词汇——“故事传播”、“内容运营”、“视频传播”等等。即便是针对产品编写的&quot;说明书&quot;，也是需要考虑用户和其使用场景，这正是传播的逻辑。除了涉及“从内容到营销”主题，大会还分享了文档呈现及编辑器的演进和发展、文档工程师的价值等主题内容。&lt;/p&gt;
&lt;p&gt;下面由我带大家回顾一下这次的技术传播学习之旅。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;h-1&quot; class=&quot;anchor&quot; href=&quot;#h-1&quot;/&gt;课程主题&lt;/h2&gt;
&lt;p&gt;听了技术传播大会的大部分课程，从「技术文档工程师的价值」到「如何传播运营技术内容中的各个环节」，本次大会都有对应的课程主题。大会课程主题可以形成一条链路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/01.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注：TW，全称 Technical Writer，即技术文档工程师。&lt;/p&gt;
&lt;h2&gt;
&lt;a name=&quot;h-2&quot; class=&quot;anchor&quot; href=&quot;#h-2&quot;/&gt;干货及思考&lt;/h2&gt;
&lt;p&gt;大会中对&lt;strong&gt;技术文档工程师的价值&lt;/strong&gt;、&lt;strong&gt;文档内容编辑方式&lt;/strong&gt;、&lt;strong&gt;呈现方式&lt;/strong&gt;、&lt;strong&gt;运营方式的现状&lt;/strong&gt;及&lt;strong&gt;发展趋势&lt;/strong&gt;做了相应的分享。在这过程中，我也收获了一些新知识和有了自己的一些思考。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;h-3&quot; class=&quot;anchor&quot; href=&quot;#h-3&quot;/&gt;技术文档工程师的价值&lt;/h3&gt;
&lt;p&gt;首先，技术文档工程师是什么？引用百科中的一句话———“文档工程师，是指协同开发人员，收集资料，安排开发计划，编写企业项目开发所需的各类文档，同时保证文档的质量、安全等的技术人员，他们肩负着软件开发过程中信息处理与整合的重要职责。面对“文档”，他们需要完成包括安排开发计划、制定各类模板、跟踪编写进度以及编辑管理等在内的一系列工作，实现文档处理的“一条龙”服务。”&lt;/p&gt;
&lt;p&gt;有人可能会说技术文档工程师就是给产品 / 项目编写文档的人员。这也就延伸出来一个现象：文档工程师的价值经常被挑战。有些老板甚至文档工程师自身会想，为什么企业不训练一个开发工程师来直接写技术文档呢？这样他对技术的理解还会更强。为什么还要设立这样的专职的岗位？&lt;/p&gt;
&lt;p&gt;首先，这样的技术人员不太好找，具有技术文档编写能力的技术人大多都希望深耕自身的技术领域，而不愿意去写这些对“硬”技能能力提升不多的内容。毕竟，相较于文档更轻量的注释已经够让技术人头疼了。另外，就是&lt;strong&gt;专业的技术文档所呈现的内容无论是可读性，还是对产品的理解会比其他人写出来的更好、更贴近用户&lt;/strong&gt;。目前，全球许多大企业都在大量聘用技术文档工程师，像海康、阿里都有几十人的技术文档团队，人力不足的时候还需要外包。企业愿意付出这样的成本去招聘相关人才，就证明了技术文档工程师有其独特的价值存在。&lt;/p&gt;
&lt;p&gt;这也是为什么会专门存在这样的部门。因为，之前未设立技术文档部门时，其他人来写这块内容呈现的效果非常差、用户体验不佳。因此，很多企业才会存在技术文档这个部门，来帮助企业解决人员分工问题。假如一个企业里的技术人员既要写东西，还要去做技术或是去设计产品，就会出现超级节点。那么，分工的出现就解决这一痛点：专门的人才从事文档编写，专门的人才来搞技术，这样才能把分工内的东西做精做好。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;h-4&quot; class=&quot;anchor&quot; href=&quot;#h-4&quot;/&gt;如何提升文档团队的影响力&lt;/h3&gt;
&lt;p&gt;作为文档工程师，首先需要肯定和提升自己的认知维度，提升文档团队的影响力，具体怎么做？参考下列方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打破角色固化的认知，拒绝做边缘人。文档角色只能输出内容吗？不止是这样，文档可以发现 bug、了解和分析用户需求、给产品设计提需求及意见。&lt;/li&gt;
&lt;li&gt;有意识地训练产品思维，保持对产品的好奇心和敏感度。&lt;/li&gt;
&lt;li&gt;多接触真实的用户，去现场给用户培训，更好地了解用户实际使用产品中遇到的问题，减轻用户的学习成本。像是 NebulaGraph 这类开源产品，会经常查看社区用户常提到的问题，并将该问题和解决方案写在文档中。&lt;/li&gt;
&lt;li&gt;学习用户体验法则、尼尔森的十大可用性原则，利用「用户旅程地图」发掘机会点 。&lt;/li&gt;
&lt;li&gt;从用户痛点出发提出问题，并给出初步解决方案，和产品交互进行沟通并推动提升用户体验，从而提升文档团队的影响力。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;
&lt;a name=&quot;h-5&quot; class=&quot;anchor&quot; href=&quot;#h-5&quot;/&gt;招聘和培养英文技术文档&lt;/h3&gt;
&lt;p&gt;如果技术内容传播还泛指国际上的传播，那么英文技术文档对于产品的国际化具有关键作用。tcworld China 2022 分享中提到，在进行英文技术写作人员招聘过程中，常常遇到三个问题&lt;strong&gt;英文能力不足&lt;/strong&gt;、&lt;strong&gt;技术能力不足&lt;/strong&gt;、&lt;strong&gt;写作能力不足&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当急需人才、短期内又招不到人的情况下，企业可以转变思维，对英文技术翻译人员进行培训。在语言和写作方面，英文技术翻译人员上手会相对较快。剩下的就是对其技术方面的专门培训。像是英文技术文档这种人群的招聘前提也是需要 ta 们具有很强的学习意愿和能力。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;h-6&quot; class=&quot;anchor&quot; href=&quot;#h-6&quot;/&gt;文档未来&lt;/h3&gt;
&lt;p&gt;听完全场，我更喜欢 RWS 呼延韶文老师分享的《文档未来》课程，他从内容的创作方式和内容的应用端两个方面分享了文档的发展趋势。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;h-7&quot; class=&quot;anchor&quot; href=&quot;#h-7&quot;/&gt;内容创作方式&lt;/h4&gt;
&lt;p&gt;文档的创造方式，已经从最初的纸质版转为电子版（Word / PDF）的方式交付。文档正从纸质转变为电子再转变成数字化。文档数字化，指文档内容模块化、结构化、文档生产流程的云化、文档和用户的可交互性。《文档未来》提到 Forrester 预测文档下一个十年，新型基于云端、数据驱动、结构化的文档创作方式将成为主流。基于结构化、模块化主题内容，还可做到文档内容的自动组合、更新自动推送等等。文档内容呈现的发展的最后阶段是交互性内容，用户可以和内容进行交互（多以 HTML + CSS 实现）。与技术的互动，从文本到交互界面，是由产品设计引发的潜意识过程所引导的。技术传播者越是了解这种心理过程，越能创造出互动强的文档。&lt;/p&gt;
&lt;p&gt;不仅仅《文档未来》提到了文档内容的模块化、结构化，其他的课程《让技术文档智能化交付+多场景呈现》、《如何构建知识百科并营销，共建产业生态》也都提到了文档内容的模块化和结构化。结构化的主题内容可以一源多用，并多格式发布。相对传统的编辑方式，结构化能起到降本增效的作用。这种结构化、模块化的内容呈现是基于 XML 的体系结构，比较火热且流行的标准是 DITA 标准。目前，NebulaGraph 技术文档团队正在使用开源的文档编辑软件 MkDocs Material（参考延伸阅读），满足目前的内容复用需求。随着文档内容量不断增多，后续可以考虑使用结构化、模块化的编辑软件创作文档内容。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;h-8&quot; class=&quot;anchor&quot; href=&quot;#h-8&quot;/&gt;内容应用端&lt;/h4&gt;
&lt;p&gt;文档内容发布后，用户需要在门户网站浏览文档内容。那么，如何呈现内容或者说如何组合内容以提升用户体验呢？这个部分的内容和后面《开源网站信息架构的攻守之道》提到的信息架构有相似之处。在应用端（文档网站）可以做的用来提升用户体验的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语义化的搜索能力，搜索引擎可以根据用户的使用场景，搜索词语的意思检索到目标内容。&lt;/li&gt;
&lt;li&gt;知识模块化，基于 XML 体系的内容发布。&lt;/li&gt;
&lt;li&gt;智能内容，智能机器人可以推送用户搜索的问题。&lt;/li&gt;
&lt;li&gt;考虑用户常搜索的关键字，考虑 SEO 创作内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;
&lt;a name=&quot;ia-9&quot; class=&quot;anchor&quot; href=&quot;#ia-9&quot;/&gt;信息架构 IA&lt;/h3&gt;
&lt;p&gt;在参加这次技术传播大会之前，我只是知道 IA（Information Architecture）这个词比较火，但不懂什么是真正的信息架构。信息架构是什么？用途是啥？参加了大会后，大概知道了 IA 的概念，但是还是有点模糊具体是 IA 是做什么？于是在网上找到了一篇浅显易懂的&lt;a href=&quot;https://www.woshipm.com/pd/5444940.html&quot;&gt;《如何进行信息架构设计？》&lt;/a&gt;。下文仅列举相关概念。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;h-10&quot; class=&quot;anchor&quot; href=&quot;#h-10&quot;/&gt;什么是信息架构？&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;信息架构=信息+架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;信息包括各种文本、图片、影音等元素；架构则对应这些元素的选择、分类、导航和检索。&lt;/p&gt;
&lt;p&gt;通俗点说，&lt;strong&gt;信息架构就是通过合理的组织和表达各种信息元素，让用户获取并理解信息更容易。为信息与用户认知之间搭建⼀座畅通的桥梁&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;
&lt;a name=&quot;h-11&quot; class=&quot;anchor&quot; href=&quot;#h-11&quot;/&gt;为什么需要信息架构？&lt;/h4&gt;
&lt;p&gt;简言之，引用《通过智能内容提供出色的客户体验》课程中的提到的一张图片（如下图），我们可以直观的看出，&lt;strong&gt;知识点的不同排列组合与连接是提升体验的关键&lt;/strong&gt;。那么，如何来排列和连接这些知识，就需要用到信息架构中的构建方式、类型及设计逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/02.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;
&lt;a name=&quot;h-12&quot; class=&quot;anchor&quot; href=&quot;#h-12&quot;/&gt;信息架构的构建方式&lt;/h5&gt;
&lt;p&gt;自上而下、自下而上和综合运用&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;自上而下的构建方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自上而下的构建方式是由战略层驱动的&lt;/strong&gt;，根据产品目标与用户需求直接进行结构设计，进行新产品规划或者产品重新定义的时候会用到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/03.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自上而下的构建方式，会先从最广泛的，最有可能满足目标的内容及功能开始分类，再依据逻辑细分次级分类。（MVP 的设计思路）所有分类都是空槽，最后将内容和功能按顺序填入。它有一个明显的缺点是：&lt;strong&gt;可能导致现有重要内容被忽略&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;自下而上的构建方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自下而上的构建方式是由范围层驱动的&lt;/strong&gt;，根据对现有的内容和功能需求的分析进行设计，这是项目实践中大家最常用的一种方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/04.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在具体项目实践中，产品或设计师根据对现有内容和功能需求的分析，将它们分别归属到较高一级的类别，从而逐渐构建出能反映我们的产品目标和用户需求的结构。（常用卡片分类法辅助）它也有一个缺点：&lt;strong&gt;可能导致不能灵活兼容未来内容变动或增加&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;综合运用的构建方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正因为自上而下和自下而上都有其明显的缺点，所以，理想的信息架构的构建方式都是综合运用的，同时从战略层和范围层进行驱动，以构建一个适应性强的系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/05.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个适应性强的信息架构系统，能把新内容作为现有结构的一部分容纳进来&lt;/strong&gt;（如图左侧），&lt;strong&gt;也可以把新内容当成一个完整的部分加入&lt;/strong&gt;（如图右侧）。&lt;/p&gt;
&lt;p&gt;信息架构的基本单位是节点，节点可对应任意信息要素或信息要素的组合，小到一个字段 / 控件，大到一个界面 / 功能都是可以的。不同场景下，节点的颗粒度不相同。&lt;/p&gt;
&lt;p&gt;这些节点的排列方式有 4 种常见的类型，也就是我们所说的信息架构类型。&lt;/p&gt;
&lt;h5&gt;
&lt;a name=&quot;h-13&quot; class=&quot;anchor&quot; href=&quot;#h-13&quot;/&gt;常见的信息架构类型&lt;/h5&gt;
&lt;p&gt;常见信息架构有 4 种，&lt;strong&gt;层级结构、矩阵结构、自然结构和线性结构&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;层级结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;又叫树状结构或中心辐射结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/06.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;矩阵结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;矩阵结构允许用户沿着两 / 多个维度在节点之间移动，最终都可以帮助用户找到想要的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/07.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;自然结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自然结构不遵循任何一致的模式。节点被逐一连接起来，节点与节点之间有联系，但没有分类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/08.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;线性结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在线性结构中，用户不能进行跳转，只能一步一步按顺序浏览对应的信息 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/09.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;
&lt;a name=&quot;h-5-14&quot; class=&quot;anchor&quot; href=&quot;#h-5-14&quot;/&gt;信息架构的逻辑呈现的 5 个过程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/10.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;h-15&quot; class=&quot;anchor&quot; href=&quot;#h-15&quot;/&gt;内容运营&lt;/h3&gt;
&lt;p&gt;数字时代，媒介演变正在降低信息传播的成本和难度。很多技术内容正在通过短视频、问答、直播等形式传播，让受众有机会了解到更多有价值信息，学习到更多的新知识。&lt;/p&gt;
&lt;p&gt;除了常规的数据分析、SEO 以外，我对内容运营这块印象最深的是有 3 个课程专门分享通过视频进行技术传播。有个课程分析目前国内有两个视频传播火热的视频平台，抖音和 B 站。&lt;/p&gt;
&lt;p&gt;B 站中知识类内容的视频较多，抖音视频主要以生活休闲类为主。除了题材之外，B 站的视频基本上为中长视频，抖音视频以短视频为主。所以，技术类内容因为时长、偏知识题材的原因，视频传播更适合放在 B 站上。&lt;/p&gt;
&lt;p&gt;B 站中播放量较多的视频特征：内容硬核、专业的授课老师、趣味性高、与热点结合。&lt;/p&gt;
&lt;p&gt;对于制作视频本身，了解到一些视频制作的工具：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/11.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有印象较深的是制作 VTuber 视频，&lt;strong&gt;以虚拟人物形象在网路影片平台上传影片或进行直播的创作者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/12.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/13.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://discuss-cdn.nebula-graph.com.cn/images/emoji/apple/grin.png?v=12&quot; title=&quot;:grin:&quot; class=&quot;emoji&quot; alt=&quot;:grin:&quot; loading=&quot;lazy&quot;/&gt; 如果不想露真人，但又想有人物动作的时候，可以考虑制作 VTuber 视频进行。&lt;/p&gt;
&lt;h3&gt;
&lt;a name=&quot;h-16&quot; class=&quot;anchor&quot; href=&quot;#h-16&quot;/&gt;课程笔记&lt;/h3&gt;
&lt;p&gt;除了一些因时间冲突没参加外，参加的大部分课程名称及分析概参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/1.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/2.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nebula-website-cn.oss-cn-hangzhou.aliyuncs.com/nebula-blog/docs-insight/3.png&quot; alt=&quot;&quot; role=&quot;presentation&quot;/&gt;&lt;/p&gt;
&lt;p&gt;延伸阅读：&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;谢谢你读完本文&lt;/strong&gt; (///▽///)&lt;/p&gt;
&lt;p&gt;NebulaGraph Desktop，Windows 和 macOS 用户安装图数据库的绿色通道，10s 拉起搞定海量数据的图服务。通道传送门：&lt;a href=&quot;http://c.nxw.so/9Rs1u&quot;&gt;http://c.nxw.so/9Rs1u&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;想看源码的小伙伴可以前往 GitHub 阅读、使用、(^з^)-☆ star 它 → &lt;a href=&quot;http://c.nxw.so/8yTlk&quot;&gt;GitHub&lt;/a&gt;；和其他的 NebulaGraph 用户一起交流图数据库技术和应用技能，留下&lt;a href=&quot;http://c.nxw.so/9jvQN&quot;&gt;「你的名片」&lt;/a&gt;一起玩耍呢~&lt;/p&gt;
        &lt;/div&gt;

        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>