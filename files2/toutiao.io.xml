<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>88307074ee4f675cef9f6af4a0de7a37</guid>
<title>聊聊 13 种锁的实现方式</title>
<link>https://toutiao.io/k/wcwg3fn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;大家好，我是Tom哥。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有很多小伙伴给我留言，分布式系统时代，线程并发，资源抢占，&quot;锁&quot; 慢慢变得很重要。那么常见的锁都有哪些？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天Tom哥就和大家简单聊聊这个话题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、悲观锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如其名，它是指对数据修改时持保守态度，认为其他人也会修改数据。因此在操作数据时，会把数据锁住，直到操作完成。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是单机系统，我们可以采用 JAVA 自带的 &lt;code&gt;synchronized&lt;/code&gt; 关键字，通过添加到方法或同步块上，锁住资源
如果是分布式系统，我们可以借助数据库自身的锁机制来实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select * from 表名 &lt;span&gt;where&lt;/span&gt; id= &lt;span&gt;#{id} for update&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用悲观锁的时候，我们要注意锁的级别，MySQL innodb 在加锁时，只有明确的指定主键或（索引字段）才会使用 &lt;code&gt;行锁&lt;/code&gt;；否则，会执行 &lt;code&gt;表锁&lt;/code&gt;，将整个表锁住，此时性能会很差。在使用悲观锁时，我们必须关闭 MySQL 数据库的自动提交属性，因为mysql默认使用自动提交模式。悲观锁适用于写多的场景，而且并发性能要求不高&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、乐观锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁，从字面意思也能猜到个大概，在操作数据时非常乐观，认为别人不会同时修改数据，因此乐观锁不会上锁
只是在 &lt;code&gt;提交更新&lt;/code&gt; 时，才会正式对数据的冲突与否进行检测。如果发现冲突了，则返回错误信息，让用户决定如何去做，&lt;code&gt;fail-fast 机制&lt;/code&gt; 。否则，执行本次操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分为三个阶段：数据读取、写入校验、数据写入。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果是单机系统&lt;/strong&gt;，我们可以基于JAVA 的 CAS来实现，CAS 是一种原子操作，借助硬件的比较并交换来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果是分布式系统&lt;/strong&gt;，我们可以在数据库表中增加一个 &lt;code&gt;版本号&lt;/code&gt; 字段，如：version&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;update 表 &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; ... , version = version +1 &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; id= &lt;span&gt;#{id} and version = #{version} &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作前，先读取记录的版本号，更新时，通过SQL语句比较版本号是否一致。如果一致，则更新数据。否则会再次读取版本，重试上面的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3、分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAVA 中的 &lt;code&gt;synchronized&lt;/code&gt; 、&lt;code&gt;ReentrantLock&lt;/code&gt; 等，都是解决单体应用单机部署的资源互斥问题。随着业务快速发展，当单体应用演化为分布式集群后，多线程、多进程分布在不同的机器上，原来的单机并发控制锁策略失效&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们需要引入 &lt;code&gt;分布式锁&lt;/code&gt;，解决跨机器的互斥机制来控制共享资源的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁需要具备哪些条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与单机系统一样的资源互斥功能，这是锁的基础&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能获取、释放锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具备可重入性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有锁失效机制，防止死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非阻塞，不管是否获得锁，要能快速返回&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式多种多样，基于 &lt;code&gt;数据库&lt;/code&gt;、&lt;code&gt;Redis&lt;/code&gt;、以及 &lt;code&gt;Zookeeper&lt;/code&gt;等，这里讲下主流的基于Redis的实现方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SET key unique_value  [EX seconds] [PX milliseconds] [NX|XX]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原子命令，如果执行成功返回 1，则表示加锁成功。注意：unique_value 是客户端生成的唯一标识，区分来自不同客户端的锁操作
解锁要特别注意，先判断 &lt;code&gt;unique_value&lt;/code&gt; 是不是加锁的客户端，是的话才允许解锁删除。毕竟我们不能删除其他客户端加的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解锁：解锁有两个命令操作，需要借助 Lua 脚本来保证原子性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 先比较 unique_value 是否相等，避免锁的误释放&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&quot;get&quot;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&quot;del&quot;&lt;/span&gt;,KEYS[1])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助 Redis 的高性能，Redis 实现分布式锁也是目前主流实现方式。但任何事情有利有弊，如果加锁的服务器宕机了，当slave 节点还没来得及数据备份，那不是别的客户端也可以获得锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Redis 官方设计了一个分布式锁 Redlock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基本思路&lt;/strong&gt;：让客户端与多个独立的 Redis 节点并行请求申请加锁，如果能在半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、可重入锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可重入锁，也叫做递归锁，是指在同一个线程在调外层方法获取锁的时候，再进入内层方法会自动获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象锁或类锁内部有计数器，一个线程每获得一次锁，计数器 +1；解锁时，计数器 -1。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有多少次加锁，就要对应多少次解锁，加锁与解锁成对出现。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAVA 中的 &lt;code&gt;ReentrantLock&lt;/code&gt; 和 &lt;code&gt;synchronized&lt;/code&gt; 都是 可重入锁。可重入锁的一个好处是可一定程度避免死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5、自旋锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁是采用让当前线程不停地在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不断增加时，性能下降明显，因为每个线程都需要执行，会占用CPU时间片。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以设置一个 &lt;code&gt;循环时间&lt;/code&gt; 或 &lt;code&gt;循环次数&lt;/code&gt;，超出阈值时，让线程进入阻塞状态，防止线程长时间占用 CPU 资源。JUC 并发包中的 CAS 就是采用自旋锁，compareAndSet 是CAS操作的核心，底层利用&lt;code&gt;Unsafe&lt;/code&gt;对象实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public final int getAndAddInt(Object var1, long var2, int var4) {&lt;br/&gt;    int var5;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        var5 = this.getIntVolatile(var1, var2);&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt;(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果内存中 var1 对象的var2字段值等于预期的 var5，则将该位置更新为新值（var5 + var4），否则不进行任何操作，一直重试，直到操作成功为止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CAS 包含了Compare和Swap 两个操作，如何保证原子性呢？CAS 是由 CPU 支持的原子操作，其原子性是在硬件层面进行控制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别注意，CAS 可能导致 ABA 问题，我们可以引入递增版本号来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、独享锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独享锁，也有人叫它排他锁。无论读操作还是写操作，只能有一个线程获得锁，其他线程处于阻塞状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：读操作并不会修改数据，而且大部分的系统都是 &lt;code&gt;读多写少&lt;/code&gt;，如果读读之间互斥，大大降低系统的性能。下面的 &lt;code&gt;共享锁&lt;/code&gt; 会解决这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像JAVA 中的 &lt;code&gt;ReentrantLock&lt;/code&gt; 和 &lt;code&gt;synchronized&lt;/code&gt; 都是独享锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;7、共享锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享锁是指允许多个线程同时持有锁，一般用在读锁上。读锁的共享锁可保证并发读是非常高效的。读写，写读 ，写写的则是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;8、读锁/写锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对某个资源是读操作，那多个线程之间并不会相互影响，可以通过添加读锁实现共享。如果有修改动作，为了保证数据的并发安全，此时只能有一个线程获得锁，我们称之为 写锁。读读是共享的；而 读写、写读 、写写 则是互斥的&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;像 JAVA 中的 ReentrantReadWriteLock 就是一种 读写锁&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9、公平锁/非公平锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁&lt;/strong&gt;：多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队，先来先获取的公平性原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：所有的线程都能得到资源，不会饿死在队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，CPU 唤醒下一个阻塞线程有系统开销&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40285714285714286&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcunshF0K1SZgUyWZlDru0hZxYlhMFbhH2ibQ6zAL3709Ix1fItIme5bg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁&lt;/strong&gt;：多个线程不按照申请锁的顺序去获得锁，而是同时以插队方式直接尝试获取锁，获取不到（插队失败），会进入队列等待（失败则乖乖排队），如果能获取到（插队成功），就直接获取到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：可能导致队列中排队的线程一直获取不到锁或者长时间获取不到锁，活活饿死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 多线程并发操作，我们操作锁大多时候都是基于 &lt;code&gt;Sync&lt;/code&gt; 本身去实现的，而 Sync 本身却是 &lt;code&gt;ReentrantLock&lt;/code&gt; 的一个内部类，Sync 继承 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 ReentrantLock 默认是非公平锁，我们可以在构造函数中传入 true，来创建公平锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public ReentrantLock(boolean fair) {&lt;br/&gt;    sync = fair ? new FairSync() : new NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;10、可中断锁/不可中断锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可中断锁：指一个线程因为没有获得锁在阻塞等待过程中，可以中断自己阻塞的状态。不可中断锁：恰恰相反，如果锁被其他线程获取后，当前线程只能阻塞等待。如果持有锁的线程一直不释放锁，那其他想获取锁的线程就会一直阻塞。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;内置锁 synchronized 是不可中断锁，而 ReentrantLock 是可中断锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock获取锁定有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;lock()， 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于阻塞状态，直到该线程获取锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock()， 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lockInterruptibly()，如果获取了锁定立即返回；如果没有获取锁，线程处于阻塞状态，直到获取锁或者线程被别的线程中断&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多：https://github.com/aalansehaiyang/p-java-proof/blob/master/resource/17.md&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;11、分段锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分段锁其实是一种锁的设计，目的是细化锁的粒度，并不是具体的一种锁，&lt;code&gt;对于ConcurrentHashMap&lt;/code&gt; 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;中的分段锁称为Segment，它即类似于HashMap（JDK7 中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要put元素的时候，并不是对整个HashMap加锁，而是先通过hashcode知道要放在哪一个分段中，然后对这个分段加锁，所以当多线程put时，只要不是放在同一个分段中，可支持并行插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;12、锁升级（无锁|偏向锁|轻量级锁|重量级锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 1.6之前，synchronized 还是一个重量级锁，效率比较低。但是在JDK 1.6后，JVM为了提高锁的获取与释放效率对 &lt;code&gt;synchronized&lt;/code&gt; 进行了优化，引入了偏向锁和轻量级锁 ，从此以后锁的状态就有了四种：无锁、偏向锁、轻量级锁、重量级锁。这四种状态会随着竞争的情况逐渐升级，而且是不可降级。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5917721518987342&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcOfFOmF8md1ElBuK301awbmlTWgJlevkiaIswy7c2CKIr7cEbPJY3xwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁并不会对资源锁定，所有的线程都可以访问并修改同一个资源，但同时只有一个线程能修改成功。也就是我们常说的乐观锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向于第一个访问锁的线程，初次执行&lt;code&gt;synchronized&lt;/code&gt;代码块时，通过 CAS 修改对象头里的锁标志位，锁对象变成偏向锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程访问同步代码块并获取锁时，会在 &lt;code&gt;Mark Word&lt;/code&gt; 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 &lt;code&gt;Mark Word&lt;/code&gt; 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完同步代码块后，线程并不会主动释放偏向锁。当线程第二次再执行同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里不需要重新加锁，偏向锁几乎没有额外开销，性能极高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前锁是偏向锁，此时有多个线程同时来竞争锁，偏向锁就会升级为轻量级锁。轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式来获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的获取有两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当关闭偏向锁功能时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个线程竞争偏向锁导致偏向锁升级为轻量级锁。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，此过程是原子性。如果抢到锁，然后线程将当前锁的持有者信息修改为自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程的竞争很激励，线程的自旋超过了一定次数（默认循环10次，可以通过虚拟机参数更改），将轻量级锁升级为重量级锁（依然是 CAS  修改锁标志位，但不修改持有锁的线程ID），当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13、锁优化技术（锁粗化、锁消除）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁粗化&lt;/strong&gt;就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：有个循环体，内部&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(int i=0;i&amp;lt;size;i++){&lt;br/&gt;    synchronized(lock){&lt;br/&gt;        ...业务处理，省略&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过锁粗化的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;synchronized(lock){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(int i=0;i&amp;lt;size;i++){&lt;br/&gt;        ...业务处理，省略&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁消除&lt;/strong&gt;指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁消除的依据是逃逸分析的数据支持，如 &lt;code&gt;StringBuffer&lt;/code&gt; 的 &lt;code&gt;append()&lt;/code&gt; 方法，或 &lt;code&gt;Vector&lt;/code&gt; 的 &lt;code&gt;add()&lt;/code&gt; 方法，在很多情况下是可以进行锁消除的，比如以下这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public String &lt;span&gt;method&lt;/span&gt;() {&lt;br/&gt;    StringBuffer sb = new StringBuffer();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; 10; i++) {&lt;br/&gt;        sb.append(&lt;span&gt;&quot;i:&quot;&lt;/span&gt; + i);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sb.toString();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码经过编译之后的字节码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49471830985915494&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcBDESiaCyC6ySCHeYzkibm32Za8ZjphCyEObNluIccictJlYrxovJDW7IA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述结果可以看出，之前我们写的线程安全的加锁的 &lt;code&gt;StringBuffer&lt;/code&gt; 对象，在生成字节码之后就被替换成了不加锁不安全的 &lt;code&gt;StringBuilder&lt;/code&gt; 对象了，原因是 &lt;code&gt;StringBuffer&lt;/code&gt; 的变量属于一个局部变量，并且不会从该方法中逃逸出去，所以我们可以使用锁消除（不加锁）来加速程序的运行。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了。&lt;/strong&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.092130518234165&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdaSEqIP60fNXXqd7e15vycGo75wsfR2yTDKxOpJaKG0BKzFod8CQxLtibu2vMp1GKBMDJRbk3rpLw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/h2&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68a43fd66abd705e530a2bf3d5d45e74</guid>
<title>MySQL 单表不要超过 2000W 行，靠谱吗？</title>
<link>https://toutiao.io/k/vke55xi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为在后端圈开车的多年老司机，是不是经常听到过：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些名言民语就和 “群里只讨论技术，不开车，开车速度不要超过 120 码，否则自动踢群”，只听过，没试过，哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就把车速踩到底，干到 180 码试试…….&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://my.oschina.net/u/4090830/blog/5559454&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验一把看看… 建一张表&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; person(&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;br/&gt;    person_id &lt;span&gt;tinyint&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户id&#x27;&lt;/span&gt;,&lt;br/&gt;    person_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_create datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_modified datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;修改时间&#x27;&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;人员信息表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入一条数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; person &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&#x27;user_1&#x27;&lt;/span&gt;, &lt;span&gt;NOW&lt;/span&gt;(), &lt;span&gt;now&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 MySQL 伪列 rownum 设置伪列起始点为 1&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; (@i:=@i+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;rownum&lt;/span&gt;, person_name &lt;span&gt;from&lt;/span&gt; person, (&lt;span&gt;select&lt;/span&gt; @i:=&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; init; &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; @i=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行下面的 sql，连续执行 20 次，就是 2 的 20 次方约等于 100w 的数据；执行 23 次就是 2 的 23 次方约等于 800w , 如此下去即可实现千万测试数据的插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想翻倍翻倍的增加数据，而是想少量，少量的增加，有个技巧，就是在 SQL 的后面增加 where 条件，如 id &amp;gt; 某一个值去控制增加的数据量即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; person(&lt;span&gt;id&lt;/span&gt;, person_id, person_name, gmt_create, gmt_modified)&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; @i:=@i+&lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;left&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; person_id,&lt;br/&gt;&lt;span&gt;concat&lt;/span&gt;(&lt;span&gt;&#x27;user_&#x27;&lt;/span&gt;,@i%&lt;span&gt;2048&lt;/span&gt;),&lt;br/&gt;&lt;span&gt;date_add&lt;/span&gt;(gmt_create,&lt;span&gt;interval&lt;/span&gt; + @i*&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;100&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;),&lt;br/&gt;&lt;span&gt;date_add&lt;/span&gt;(&lt;span&gt;date_add&lt;/span&gt;(gmt_modified,&lt;span&gt;interval&lt;/span&gt; +@i*&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;100&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;), &lt;span&gt;interval&lt;/span&gt; + &lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; person;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处需要注意的是，也许你在执行到近 800w 或者 1000w 数据的时候，会报错：The total number of locks exceeds the lock table size，这是由于你的临时表内存设置的不够大，只需要扩大一下设置参数即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;GLOBAL&lt;/span&gt; tmp_table_size =&lt;span&gt;512&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;; （512M）&lt;br/&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; innodb_buffer_pool_size= &lt;span&gt;1&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;G);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一组测试数据，这组数据是在 mysql8.0 的版本，并且是在我本机上，由于本机还跑着 idea , 浏览器等各种工具，所以并不是机器配置就是用于数据库配置，所以测试数据只限于参考。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0051724137931035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ45PQnsbR4AEU5bWeV63MMeibKeC71ySplF7VKwyrhShqJMPYDgxKFSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5920084121976866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJwibXjO8NvKicvibic5bEibibS6AyeQ9Zps19eibWoy2nx9Bt5ia00LB3Ql0Rww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这组数据似乎好像真的和标题对应，当数据达到 2000w 以后，查询时长急剧上升，难道这就是铁律吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那下面我们就来看看这个建议值 2000w 是怎么来的？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单表数量限制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先想想数据库单表行数最大多大？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; person(&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;br/&gt;    person_id &lt;span&gt;tinyint&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户id&#x27;&lt;/span&gt;,&lt;br/&gt;    person_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_create datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_modified datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;修改时间&#x27;&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;人员信息表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看上面的建表 sql，id 是主键，本身就是唯一的，也就是说主键的大小可以限制表的上限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果主键声明 int 大小，也就是 32 位，那么支持  2^32-1 ~~21 亿；如果是 bigint，那就是 2^62-1 （36893488147419103232），难以想象这个的多大了，一般还没有到这个限制之前，可能数据库已经爆满了！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人统计过，如果建表的时候，自增字段选择无符号的 bigint , 那么自增长最大值是 18446744073709551615，按照一秒新增一条记录的速度，大约什么时候能用完？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47919876733436056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ5cSuI591aK3E19WbHrrWfwNnibsYRxXDiaWKUPjJEoCcCxSDvT3lbZLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;表空间&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们再来看看索引的结构，对了，我们下面讲内容都是基于 Innodb 引擎的，大家都知道 Innodb 的索引内部用的是 B+ 树&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36614645858343337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJYIzmywUhcpUtMVWHtFygVPA5bViamj0lnUDOkVlE2hQhEv52Dvux9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张表数据，在硬盘上存储也是类似如此的，它实际是放在一个叫 person.ibd （innodb data）的文件中，也叫做表空间；虽然数据表中，他们看起来是一条连着一条，但是实际上在文件中它被分成很多小份的数据页，而且每一份都是 16K。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概就像下面这样，当然这只是我们抽象出来的，在表空间中还有段、区、组等很多概念，但是我们需要跳出来看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.471976401179941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ4mPc7cEFaqRo5UfVhQygf7HFzqpPokyUcibLzUFjLafB4ttBQgru6mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;页的数据结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际页的内部结构像是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5765575501583949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJibVenqMqgd8dworIOPxC6nibol2sNP1Msiaqa18tEUl7s1cfbDGsRwysw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 User Records 部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程的图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375366568914956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJsqsPhia9VsVzE0dmzxKJTw1OzlHTQbANcgFKYT5xpEvicNAMAXECB7gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚刚上面说到了数据的新增的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那下面就来说说，数据的查找过程，假如我们需要查找一条记录，我们可以把表空间中的每一页都加载到内存中，然后对记录挨个判断是不是我们想要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据量小的时候，没啥问题，内存也可以撑。但是现实就是这么残酷，不会给你这个局面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这问题，mysql 中就有了索引的概念，大家都知道索引能够加快数据的查询，那到底是怎么个回事呢？下面我就来看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引的数据结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 mysql 中索引的数据结构和刚刚描述的页几乎是一模一样的，而且大小也是 16K,。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息，从 0 开始往上算，所以页与页之间就有了上下层级的概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48558558558558557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJtufeRkPy7ldHgkBtRC2KUtfSRZqcdrd3gkQUbmw1YubI1DNPE6bibuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这个图之后，是不是有点似曾相似的感觉，是不是像一棵二叉树啊，对，没错！它就是一棵树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过我们在这里只是简单画了三个节点，2 层结构的而已，如果数据多了，可能就会扩展到 3 层的树，这个就是我们常说的 B+ 树，最下面那一层的 page level =0, 也就是叶子节点，其余都是非叶子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0617283950617284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJbOUrteLtJbMUemysXicIqkriaUCbCPUepDNVk3lNvTVL8bcccsia2O1Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上图中，我们是单拿一个节点来看，首先它是一个非叶子节点（索引页），在它的内容区中有 id 和 页号地址两部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;id ：对应页中记录的最小记录 id 值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页号：地址是指向对应页的指针；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数据页与此几乎大同小异，区别在于数据页记录的是真实的行数据而不是页地址，而且 id 的也是顺序的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单表建议值&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就以 3 层，2 分叉（实际中是 M 分叉）的图例来说明一下查找一个行数据的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4824242424242424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJk58cx4v6TOno59eWiaMzSM5asBjSqsK3vxAWMggajMDJHMpQs5DBxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说我们需要查找一个 id=6 的行数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;因为在非叶子节点中存放的是页号和该页最小的 id，所以我们从顶层开始对比，首先看页号 10 中的目录，有 [id=1, 页号 = 20],[id=5, 页号 = 30], 说明左侧节点最小 id 为 1，右侧节点最小 id 是 5。6&amp;gt;5, 那按照二分法查找的规则，肯定就往右侧节点继续查找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到页号 30 的节点后，发现这个节点还有子节点（非叶子节点），那就继续比对，同理，6&amp;gt;5 &amp;amp;&amp;amp; 6&amp;lt;7, 所以找到了页号 60；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到页号 60 之后，发现此节点为叶子节点（数据节点），于是将此页数据加载至内存进行一一对比，结果找到了 id=6 的数据行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述的过程中发现，我们为了查找 id=6 的数据，总共查询了三个页，如果三个页都在磁盘中（未提前加载至内存），那么最多需要经历三次的磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，图中的页号只是个示例，实际情况下并不是连续的，在磁盘中存储也不一定是顺序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们大概已经了解了表的数据是怎么个结构了，也大概知道查询数据是个怎么的过程了，这样我们也就能大概估算这样的结构能存放多少数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图解我们知道 B+ 数的叶子节点才是存在数据的，而非叶子节点是用来存放索引数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，同样一个 16K 的页，非叶子节点里的每条数据都指向新的页，而新的页有两种可能&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果是叶子节点，那么里面就是一行行的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是非叶子节点的话，那么就会继续指向新的页&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;非叶子节点内指向其他页的数量为 x&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点内能容纳的数据行数为 y&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 数的层数为 z&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图中所示，&lt;strong&gt;Total =x^(z-1) *y 也就是说总数会等于 x 的 z-1 次方 与 Y 的乘积&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4885844748858447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJHdbdnBVRkiaA5TnQIckgz6n6Nlz749UJxOGGBLzK5cHjgnpNUtufK1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;X =？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的开头已经介绍了页的结构，索引也也不例外，都会有 File Header (38 byte)、Page Header (56 Byte)、Infimum + Supermum（26 byte）、File Trailer（8byte）, 再加上页目录，大概 1k 左右。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就当做它就是 1K, 那整个页的大小是 16K, 剩下 15k 用于存数据，在索引页中主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 x=15*1024/12≈1280 行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Y=？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;叶子节点和非叶子节点的结构是一样的，同理，能放数据的空间也是 15k。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是叶子节点中存放的是真正的行数据，这个影响的因素就会多很多，比如，字段的类型，字段的数量。每行数据占用空间越大，页中所放的行数量就会越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000  ≈15。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算到这边了，是不是心里已经有谱了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上述的公式，Total =x^(z-1) *y，已知 x=1280，y=15：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎呀，妈呀！这不是正好就是文章开头说的最大行数建议值 2000w 嘛！对的，一般 B+ 数的层级最多也就是 3 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你试想一下，如果是 4 层，除了查询的时候磁盘 IO 次数会增加，而且这个 Total 值会是多少，大概应该是 3 百多亿吧，也不太合理，所以，3 层应该是比较合理的一个值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;到这里难道就完了？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 那么单个数据页最多只能放下 3 条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，还是按照 z = 3 的值来计算，那 Total = （1280 ^2） *3 = 4915200 （近 500w）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Mysql 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引结构不会影响单表最大行数，2000w 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;图解系列文章：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247507000&amp;amp;idx=1&amp;amp;sn=c045101b45dd70ec37f9b81361b09f14&amp;amp;chksm=f98d9892cefa1184ac8e278e468a8a225cd5a6f4c3dfba83ed223c5da69421041961bfb945cc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小林的网站上线啦！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;24&quot; hasload=&quot;1&quot;&gt;小林的网站上线啦！&lt;/a&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247492900&amp;amp;idx=1&amp;amp;sn=2c1d06a667b1e17e6d8caabff2bbb85b&amp;amp;chksm=f98da18ecefa28986109f13d28c1a06f304cb4d897eb2e931e79dc82d0b054ef6a9f7e1e4e91&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小林的图解系统，大曝光！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;小林的图解系统，大曝光！&lt;/a&gt;&lt;br mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247491944&amp;amp;idx=1&amp;amp;sn=b90deba780ae3840668e21127e467b83&amp;amp;chksm=f98da5c2cefa2cd456045e9b2ed92837ed10e4a2c650f463b29ef5d7f8f4d01014d92225acad&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不鸽了，小林的「图解网络 3.0 」发布！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;span&gt;不鸽了，小林的「图解网络 3.0 」发布！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4768267df0e99a8ea49ae0d590b70af8</guid>
<title>Java性能优化的七个方向</title>
<link>https://toutiao.io/k/yjkn4py</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;fieldset data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;专业架构师，专注高质量架构干货分享。三高架构（高可用、高性能、高稳定）、大数据、机器学习、Java架构、系统架构、分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;了解了优化目标后，那接下来应该从哪些方面入手呢？本文主要侧重于理论分析，我们从整体上看一下 Java 性能优化都有哪些可以遵循的规律。本文主讲理论。关于实践，后续的文章会用较多的案例来细化本文的知识点，适合反复思考和归纳。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;概述&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;性能优化根据优化的类别，分为业务优化和技术优化。&lt;/span&gt;&lt;span&gt;业务优化产生的效果也是非常大的，但它属于产品和管理的范畴。&lt;/span&gt;&lt;span&gt;同作为程序员，在平常工作中，我们面对的优化方式，主要是通过一系列的技术手段，来完成对既定的优化目标。&lt;/span&gt;&lt;span&gt;这一系列的技术手段，我大体归纳为如图以下 7 类：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4377387318563789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RAGlnlpXeMIOpsicUXhJnziaQLEBgRiayjARPdJ9YLIxjJnJold5qNHQndBmc79Ca4Hxd6F6Z7jA7lJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1309&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以看到，优化方式集中在对计算资源和存储资源的规划上。优化方法中有多种用空间换时间的方式，但只照顾计算速度，而不考虑复杂性和空间问题，也是不可取的。我们要做的，就是在照顾性能的前提下，达到资源利用的最优状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我简要介绍一下这7个优化方向。&lt;/span&gt;&lt;span&gt;如果你感觉比较枯燥，那也没关系，我们本文的目的，就是让你的脑海里有一个总分的概念，以及对理论基础有一个整体的认识。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;1、复用优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在写代码的时候，你会发现有很多重复的代码可以提取出来，做成公共的方法。这样，在下次用的时候，就不用再费劲写一遍了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种思想就是复用。上面的描述是编码逻辑上的优化，对于数据存取来说，有同样的复用情况。无论是在生活中还是编码中，重复的事情一直在发生，如果没有复用，工作和生活就会比较累。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在软件系统中，谈到数据复用，我们首先想到的就是缓冲和缓存。注意这两个词的区别，它们的意义是完全不同的，很多同学很容易搞混，在这里简单地介绍一下。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;与之类似的，是对于对象的池化操作，比如数据库连接池、线程池等，在 Java 中使用得非常频繁。由于这些对象的创建和销毁成本都比较大，我们在使用之后，也会将这部分对象暂时存储，下次用的时候，就不用再走一遍耗时的初始化操作了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;2、 计算优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;并行执行&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在的 CPU 发展速度很快，绝大多数硬件，都是多核。要想加快某个任务的执行，最快最优的解决方式，就是让它并行执行。并行执行有以下三种模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一种模式是多机，采用负载均衡的方式，将流量或者大的计算拆分成多个部分，同时进行处理。&lt;/span&gt;&lt;span&gt;比如，Hadoop 通过 MapReduce 的方式，把任务打散，多机同时进行计算。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二种模式是采用多进程。&lt;/span&gt;&lt;span&gt;比如 Nginx，采用 NIO 编程模型，Master 统一管理 Worker 进程，然后由 Worker 进程进行真正的请求代理，这也能很好地利用硬件的多个 CPU。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三种模式是使用多线程，这也是 Java 程序员接触最多的。&lt;/span&gt;&lt;span&gt;比如 Netty，采用 Reactor 编程模型，同样使用 NIO，但它是基于线程的。&lt;/span&gt;&lt;span&gt;Boss 线程用来接收请求，然后调度给相应的 Worker 线程进行真正的业务计算。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像 Golang 这样的语言，有更加轻量级的协程（Coroutine），协程是一种比线程更加轻量级的存在，但目前在 Java 中还不太成熟，就不做过多介绍了，但本质上，它也是对于多核的应用，使得任务并行执行。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;变同步为异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再一种对于计算的优化，就是变同步为异步，这通常涉及编程模型的改变。同步方式，请求会一直阻塞，直到有成功，或者失败结果的返回。虽然它的编程模型简单，但应对突发的、时间段倾斜的流量，问题就特别大，请求很容易失败。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异步操作可以方便地支持横向扩容，也可以缓解瞬时压力，使请求变得平滑。同步请求，就像拳头打在钢板上；异步请求，就像拳头打在海绵上。你可以想象一下这个过程，后者肯定是富有弹性的，体验更加友好。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;惰性加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一种，就是使用一些常见的设计模式来优化业务，提高体验，比如单例模式、代理模式等。举个例子，在绘制 Swing 窗口的时候，如果要显示比较多的图片，就可以先加载一个占位符，然后通过后台线程慢慢加载所需要的资源，这就可以避免窗口的僵死。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;3、结果集优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来介绍一下对结果集的优化。举个比较直观的例子，我们都知道 XML 的表现形式是非常好的，那为什么还有 JSON 呢？除了书写要简单一些，一个重要的原因就是它的体积变小了，传输效率和解析效率变高了，像 Google 的 Protobuf，体积就更小了一些。虽然可读性降低，但在一些高并发场景下（如 RPC），能够显著提高效率，这是典型的对结果集的优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是由于我们目前的 Web 服务，都是 C/S 模式。&lt;/span&gt;&lt;span&gt;数据从服务器传输到客户端，需要分发多份，这个数据量是急剧膨胀的，每减少一小部分存储，都会有比较大的传输性能和成本提升。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像 Nginx，一般都会开启 GZIP 压缩，使得传输的内容保持紧凑。&lt;/span&gt;&lt;span&gt;客户端只需要一小部分计算能力，就可以方便解压。&lt;/span&gt;&lt;span&gt;由于这个操作是分散的，所以性能损失是固定的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;了解了这个道理，我们就能看到对于结果集优化的一般思路，你要尽量保持返回数据的精简。&lt;/span&gt;&lt;span&gt;一些客户端不需要的字段，那就在代码中，或者直接在 SQL 查询中，就把它去掉。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一些对时效性要求不高，但对处理能力有高要求的业务。&lt;/span&gt;&lt;span&gt;我们要吸取缓冲区的经验，尽量减少网络连接的交互，采用批量处理的方式，增加处理速度。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结果集合很可能会有二次使用，你可能会把它加入缓存中，但依然在速度上有所欠缺。&lt;/span&gt;&lt;span&gt;这个时候，就需要对数据集合进行处理优化，采用索引或者 Bitmap 位图等方式，加快数据访问速度。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;4、资源冲突优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在平常的开发中，会涉及很多共享资源。这些共享资源，有的是单机的，比如一个 HashMap；有的是外部存储，比如一个数据库行；有的是单个资源，比如 Redis 某个 key 的Setnx；有的是多个资源的协调，比如事务、分布式事务等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现实中的性能问题，和锁相关的问题是非常多的。大多数我们会想到数据库的行锁、表锁、Java 中的各种锁等。在更底层，比如 CPU 命令级别的锁、JVM 指令级别的锁、操作系统内部锁等，可以说无处不在。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只有并发，才能产生资源冲突。也就是在同一时刻，只能有一个处理请求能够获取到共享资源。解决资源冲突的方式，就是加锁。再比如事务，在本质上也是一种锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照锁级别，锁可分为乐观锁和悲观锁，乐观锁在效率上肯定是更高一些；按照锁类型，锁又分为公平锁和非公平锁，在对任务的调度上，有一些细微的差别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对资源的争用，会造成严重的性能问题，所以会有一些针对无锁队列之类的研究，对性能的提升也是巨大的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;5、算法优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算法能够显著提高复杂业务的性能，但在实际的业务中，往往都是变种。由于存储越来越便宜，在一些 CPU 非常紧张的业务中，往往采用空间换取时间的方式，来加快处理速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算法属于代码调优，代码调优涉及很多编码技巧，需要使用者对所使用语言的 API 也非常熟悉。有时候，对算法、数据结构的灵活使用，也是代码优化的一个重要内容。比如，常用的降低时间复杂度的方式，就有递归、二分、排序、动态规划等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个优秀的实现，比一个拙劣的实现，对系统的影响是非常大的。比如，作为 List 的实现，LinkedList 和 ArrayList 在随机访问的性能上，差了好几个数量级；又比如，CopyOnWriteList 采用写时复制的方式，可以显著降低读多写少场景下的锁冲突。而什么时候使用同步，什么时候是线程安全的，也对我们的编码能力有较高的要求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这部分的知识，就需要我们在平常的工作中注意积累，后面的课时中，也会挑比较重要的知识点穿插讲解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;6、高效实现&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在平时的编程中，尽量使用一些设计理念良好、性能优越的组件。比如，有了 Netty，就不用再选择比较老的 Mina 组件。而在设计系统时，从性能因素考虑，就不要选 SOAP 这样比较耗时的协议。再比如，一个好的语法分析器（比如使用 JavaCC），其效率会比正则表达式高很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总之，如果通过测试分析，找到了系统的瓶颈点，就要把关键的组件，使用更加高效的组件进行替换。在这种情况下，适配器模式是非常重要的。这也是为什么很多公司喜欢在现有的组件之上，再抽象一层自己的；而当在底层组件进行切换的时候，上层的应用并无感知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;7、JVM 优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为 Java 是运行在 JVM 虚拟机之上，它的诸多特性，就要受到 JVM 的制约。对 JVM 虚拟机进行优化，也能在一定程度上能够提升 JAVA 程序的性能。如果参数配置不当，甚至会造成 OOM 等比较严重的后果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前被广泛使用的垃圾回收器是 G1，通过很少的参数配置，内存即可高效回收。CMS 垃圾回收器已经在 Java 14 中被移除，由于它的 GC 时间不可控，有条件应该尽量避免使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JVM 性能调优涉及方方面面的取舍，往往是牵一发而动全身，需要全盘考虑各方面的影响。所以了解 JVM 内部的一些运行原理，还是特别重要的，它有益于我们加深对代码更深层次的理解，帮助我们书写出更高效的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;小结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上就是代码优化的 7 个大方向，我们通过简要的介绍，让大家对性能优化的内容有了大体的了解。这7大方向是代码优化的最主要方向，当然，性能优化还包含数据库优化、操作系统优化、架构优化等其他一些内容，这些不是我们的重点，在后面的文章中，我们也只做简要的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：农民工老王&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：tomcat.blog.csdn.net/article/details/123361799&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，仅供分享学习，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>86b4d6eb7409222205ab3046cd5d38c3</guid>
<title>Python3.9都带来了什么？</title>
<link>https://toutiao.io/k/tuahjt5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;post&quot; id=&quot;post&quot;&gt;
    &lt;header class=&quot;post-header text-center&quot;&gt;
      &lt;h1 class=&quot;title&quot;&gt;
        Python3.9都带来了什么？
      &lt;/h1&gt;
      
      &lt;span class=&quot;slash&quot;&gt;/&lt;/span&gt;
      &lt;span&gt;
        &lt;time class=&quot;time&quot; datetime=&quot;2022-07-31T08:03:20.512019Z&quot;&gt;
          2022-07-31
        &lt;/time&gt;
      &lt;/span&gt;
      &lt;span class=&quot;slash&quot;&gt;/&lt;/span&gt;
      &lt;span class=&quot;post-meta&quot;&gt;
        &lt;span class=&quot;post-tags&quot;&gt;
          
        &lt;/span&gt;
      &lt;/span&gt;
      &lt;span class=&quot;slash&quot;&gt;/&lt;/span&gt;
      &lt;span class=&quot;read&quot;&gt;阅读数:2335&lt;/span&gt;
    &lt;/header&gt;

    &lt;div class=&quot;post-content&quot;&gt;
      &lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;最近补一下各个 Python 新版本带来的那些对开发者有帮助的新特性。今天先说 Python3.9，这个版本很中庸，有价值的修改不多，就只放在一篇文章里列出啦。&lt;/p&gt;
&lt;h3 id=&quot;字典增加合并运算符&quot;&gt;字典增加合并运算符&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://peps.python.org/pep-0584/&quot;&gt;PEP 584 – Add Union Operators To dict&lt;/a&gt; 里面提出给 dict 增加合并 (|) 与更新 (|=) 这 2 个运算符&lt;/p&gt;
&lt;p&gt;过去合并 (Merge) 2 个字典有两种常见方法:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;b&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 方案一，使用**，Python3.5及以上版本&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;b&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 方案2，使用update&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 如果直接使用a.update，会直接修改a的结果&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然除此之外还有一些比较 trick 的，尤其是 Python 2 阶段的&lt;code&gt;dict(list(x.items()) + list(y.items()))&lt;/code&gt;这种就不提了。&lt;/p&gt;
&lt;p&gt;Python 3.9 开始可以使用按位或运算符实现:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;b&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;b&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果希望合并后直接替换，可以使用更新 (|=) 运算符:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 相当于a.update(b)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;a&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;b&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;# 在a上直接替换了(in place)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;新增用于移除前缀和后缀的字符串方法&quot;&gt;新增用于移除前缀和后缀的字符串方法&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://peps.python.org/pep-0616/&quot;&gt;PEP 616 – String methods to remove prefixes and suffixes&lt;/a&gt; 里新增了&lt;code&gt;removeprefix&lt;/code&gt;和&lt;code&gt;removesuffix&lt;/code&gt;2 个字符串方法。而在过去需要自己实现:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removeprefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;removesuffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endswith&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;suffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[:]&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，同时也增加了&lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bytearray&lt;/code&gt;以及&lt;code&gt;collections.UserString&lt;/code&gt;的对应方法。&lt;/p&gt;
&lt;p&gt;我对这个功能的理解是可以基于它对 CPython 里面的代码做一些改进。&lt;/p&gt;
&lt;h3 id=&quot;装饰器语法改进&quot;&gt;装饰器语法改进&lt;/h3&gt;
&lt;p&gt;在之前的版本中，装饰器是一个需要确定的对象，它不支持一些表达式的计算的场景，也不支持匿名函数作为装饰器，举 2 个例子:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dataclasses&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;ipython-input-1-cf77b251b3d6&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;
&lt;span class=&quot;ne&quot;&gt;SyntaxError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syntax&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;File&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;ipython-input-3-236754e0ed07&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;
&lt;span class=&quot;ne&quot;&gt;SyntaxError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;invalid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syntax&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;直接抛语法错误，现在它们都可以正常使用了:&lt;/p&gt;
&lt;figure class=&quot;highlight python3&quot; data-lang=&quot;python3&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre class=&quot;hljs python3&quot;&gt;&lt;span/&gt;&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;dataclasses&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataclass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&#x27;&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;__main__&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nd&quot;&gt;@lambda&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;lambda&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;In&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这个版本实在没有让我激动的新特性。&lt;/p&gt;

    &lt;/div&gt;

  &lt;/article&gt;


  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c3f0f1c73edbbba789cf30431ec24f1</guid>
<title>译文推荐｜详解 Pulsar Broker 负载均衡</title>
<link>https://toutiao.io/k/x72gec0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;#本文翻译自 StreamNative 博客《Achieving Broker Load Balancing with Apache Pulsar》。&lt;/p&gt;&lt;p&gt;作者 Heesung Sohn、王锴，StreamNative 开发工程师。&lt;/p&gt;&lt;p&gt;校对与整理：StreamNative。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;h1&gt;译者简介&lt;/h1&gt;&lt;p&gt;王中兴，eBay 消息中间件团队成员。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;简介&lt;/h1&gt;&lt;p&gt;本文将探讨负载均衡在分布式计算系统中的重要性，并深入分析 Pulsar 处理 Broker 负载均衡的方式。首先我们介绍 Pulsar 中的 Topic-Bundle 分组、Bundle-Broker 归属关系以及负载数据模型。然后讲解 Pulsar 的负载均衡逻辑，通过时序图来展示 Bundle 的分配、拆分和缩减过程。通过本文，你将了解 Pulsar Broker 是如何做到动态均衡的。&lt;/p&gt;&lt;p&gt;在深入探讨 Pulsar Broker 负载均衡的细节之前，我们先简要讨论分布式计算的挑战，特别是单体架构系统的挑战。&lt;/p&gt;&lt;h2&gt;分布式流系统中负载均衡的挑战&lt;/h2&gt;&lt;p&gt;负载均衡是分布式计算中的一大关键挑战。分布式系统需要在服务器之间平均分配消息负载，以避免出现服务器过载，从而导致故障并损害集群性能。一个自然而然的合理选择是根据主题来对消息进行拆分，因为同一主题（或主题分区）下的消息可以组织到一起并分配给单个逻辑服务器处理。包括 Pulsar 在内的多数分布式流系统将主题或一组主题视为负载均衡的实体，系统需要在服务器之间平均分配主题或一组主题的消息负载。&lt;/p&gt;&lt;p&gt;当主题负载不可预测时，如何做好主题负载均衡可能会形成挑战。当某些主题的负载增加时，这些主题必须直接卸载或者重新分区，以便将负载重新分配到其他机器。另一种情况是，某些机器流量非常低，甚至空闲，集群需要重平衡来避免服务器资源浪费。&lt;/p&gt;&lt;p&gt;动态重平衡在单体架构中可能会很困难，因为消息在同一个有状态的服务器中处理以及持久化。在单体流式系统中，重平衡通常涉及将消息从一台服务器复制到另一台服务器。管理员必须仔细计算初始主题分布，尽可能避免将来发生重平衡。在许多情况下，管理员需要仔细编排才能执行主题重平衡操作。&lt;/p&gt;&lt;h2&gt;Pulsar 负载均衡概览&lt;/h2&gt;&lt;p&gt;相比之下，Apache Pulsar 则实现了 Broker 的动态负载均衡，无需管理员手工干预。Pulsar 从架构上分离了存储层和计算层，可以更加灵活地分配 Broker 与主题的映射关系。Pulsar Broker 将消息持久化保存到存储服务器，当在 Broker 之间重平衡主题时，无需将消息从一个 Broker 复制到另一个 Broker。在这种情况下，新加入的 Broker 只需要查找 Metadata Store 并指向主题消息所在的正确存储服务器即可。&lt;/p&gt;&lt;p&gt;这里简要讨论一下 Pulsar 的存储架构，以便全面地了解 Pulsar 的扩展能力。在存储层，主题消息被分割成多个 Ledger，这些 Ledger 分布到多个 BookKeeper 服务器，即 Bookie。Pulsar 通过水平扩展 Bookie，即可存储尽可能多的 Ledger（Segment）条目。&lt;/p&gt;&lt;p&gt;对于高写入负载，如果所有 Bookie 都已满，只需增加更多的 Bookie，新的消息条目（即新的 Ledger）即可存储到这些新的 Bookie 上。通过这种分段设计，在存储扩展期间 Pulsar 无需从 Bookie 中重新复制旧消息。对于高读取负载，Pulsar 将消息缓存在 Broker 内存中，所以 Bookie 的读负载会显著卸载到 Broker 上，而 Broker 是负载均衡的。你可以在这篇关于&lt;span&gt;对比 Pulsar 与 Kafka &lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 的博文中了解更多关于 Pulsar 存储架构以及扩展能力的信息。&lt;/p&gt;&lt;h1&gt;在 Bundle 级别分配主题到 Broker&lt;/h1&gt;&lt;p&gt;从客户端的角度来看，Pulsar 主题是客户端发布和消费消息的基本单元。在 Broker 端，单个 Broker 处理所有客户端对某个主题的所有消息请求。主题可以被分区，而分区可以分布在多个 Broker 上。你可以将主题分区视为一个主题，而将被分区的主题视为一组主题。&lt;/p&gt;&lt;p&gt;由于每个 Broker 只处理一个主题效率较低，所以一般 Broker 需要同时处理多个主题。对于这种多主题归属关系，Pulsar 引入了 Bundle 的概念来作为一种中间层组。&lt;/p&gt;&lt;p&gt;在 Pulsar 中，相关的主题可以在逻辑上归到一个命名空间中。命名空间是一个管理单元，例如可以设置一套配置策略，应用到命名空间中的所有主题上。命名空间内部被分成多个分片，即 Bundle，每个 Bundle 是负载均衡的分配单元。&lt;/p&gt;&lt;p&gt;Pulsar 使用 Bundle 来对主题进行分片，这有助于减少要跟踪的信息量。例如，Pulsar LoadManager 聚合了主题负载统计信息，比如 Bundle 层的消息速率，这有助于减少要监控的负载样本数量。此外，Pulsar 需要跟踪当前是哪个 Broker 服务于特定主题。得益于 Bundle，Pulsar 可以减少维护这种归属关系所需的存储空间。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 使用哈希算法将主题映射到 Bundle。&lt;/span&gt;&lt;span&gt;如下是一个命名空间包含两个 Bundle 的示例。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;Bundle_Key_Partitions: [0x00000000, 0x80000000, 0xFFFFFFFF]&lt;br/&gt;Bundle1_Key_Range: [0x00000000, 0x80000000)&lt;br/&gt;Bundle2_Key_Range: [0x80000000, 0xFFFFFFFF]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pulsar 通过 &lt;code&gt;Long hashcode = hash(topicName)&lt;/code&gt; 来计算给定主题名的哈希码。假设 &lt;code&gt;hash(“my-topic”) = 0x0000000F&lt;/code&gt;，在已知 Bundle Key 范围的情况下，Pulsar 可通过 &lt;code&gt;NamespaceBundle getBundle(hashCode)&lt;/code&gt; 进行二分搜索，找到主题所属的 Bundle。在此示例中，“my-topic” 属于 “Bundle1”。&lt;/p&gt;&lt;h1&gt;Bundle 按需动态归属到 Broker&lt;/h1&gt;&lt;p&gt;Pulsar 计算层（Broker）和存储层（Bookie）分离的一大优势是 Pulsar Broker 是无状态的，基于动态 Bundle 归属可以实现良好的水平扩展性。当 Broker 过载后，可以轻松地将更多 Broker 加入集群并重新分配 Bundle 归属关系。&lt;/p&gt;&lt;p&gt;Pulsar 使用服务端发现机制来发现给定主题当前的 Bundle-Broker 归属关系，将客户端重定向到 Owner Broker 的 URL。这种发现逻辑需要知道：&lt;/p&gt;&lt;p&gt;Pulsar 将 Bundle 范围和归属关系存储在 Metadata Store 中，例如 ZooKeeper 或 etcd，这些信息也会缓存在每个 Broker 中。&lt;/p&gt;&lt;h1&gt;负载数据模型&lt;/h1&gt;&lt;p&gt;负载均衡决策中至关重要的一点是从 Broker 端收集最新的负载信息。Pulsar 不断将以下负载数据更新到内存缓存和 Metadata Store 中，并将其复制到 Leader Broker。基于这些负载数据，Leader Broker 执行 Topic-Broker 分配、Bundle 拆分以及卸载逻辑：&lt;/p&gt;&lt;h1&gt;负载均衡时序图&lt;/h1&gt;&lt;p&gt;本节将通过时序图来展示负载均衡逻辑：&lt;br/&gt;1.将主题动态分配到 Broker（&lt;span&gt;阅读完整文档&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;）。&lt;br/&gt;2.拆分过载的 Bundle（&lt;span&gt;阅读完整文档&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;）。&lt;br/&gt;3.从过载的 Broker 中卸载 Bundle（&lt;span&gt;阅读完整文档&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;）。&lt;/p&gt;&lt;h2&gt;将主题动态分配到 Broker&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;313&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5412244897959184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZC8AKWRnnRuWq7Sjl9ondBicfY25BxgbmpxljibSbntduiaHmrsDU1rJkk6nkVfjicbhTOGuRsicyskvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1225&quot;/&gt;&lt;/p&gt;&lt;p&gt;假设某客户端想要读写主题，现在试图连接到一个 Broker。该客户端先会连接到一个随机的 Broker，该 Broker 首先根据主题的哈希码以及命名空间的 Bundle 范围搜索匹配的 Bundle。然后，该 Broker 会查询 Metadata Store，检查所匹配的 Bundle 是否属于某 Broker。如果已经归属，该 Broker 会将客户端重定向到 Owner URL。否则，会将客户端重定向到 Leader 以进行 Broker 分配。Broker 分配逻辑如下：Leader 首先基于配置好的规则过滤出可用的 Broker 列表，然后随机选择一个负载最少的 Broker 分配给 Bundle（如下文第一步所示），并返回该 Broker 的 URL；Leader 将客户端重定向到该 URL，客户端即可连接到分配的 Broker。新的 Broker-Bundle 归属关系会在 Metadata Store 中创建一个临时锁，一旦 Owner 不可用之后该锁会自动释放。&lt;/p&gt;&lt;h3&gt;第一步：选定 Broker&lt;/h3&gt;&lt;p&gt;这一步从已过滤的可用 Broker 列表中选定一个 Broker，使用 &lt;code&gt;ModularLoadManagerStrategy&lt;/code&gt;（默认为 &lt;code&gt;LeastLongTermMessageRate&lt;/code&gt;）。&lt;code&gt;LeastLongTermMessageRate&lt;/code&gt; 策略计算 Broker 的负载分数，并从分数最小的 Broker 中随机选择一个，计分规则如下：&lt;/p&gt;&lt;h2&gt;拆分过载的 Bundle&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;277&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.47985781990521326&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZC8AKWRnnRuWq7Sjl9ondBfYx78amv7d5xXib8iclGCrZKwtoPlKxClxtuqSO0yRgfPaS5PDia3rBJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;p&gt;Leader Broker 根据 Bundle 负载数据判断哪些 Bundle 的负载超过阈值（见第二步），并要求 Owner Broker 进行 Bundle 拆分。具体的拆分逻辑如下：Owner Broker 首先计算拆分位置（见第三步），然后据此重新拆分目标 Bundle（见第四步）；完成拆分之后，Owner Broker 将最新的 Bundle 归属关系和范围更新到 Metadata Store 中。如果启用了 &lt;code&gt;LoadBalancerAutoUnloadSplitBundlesEnabled&lt;/code&gt;，新拆分的 Bundle 可以从 Owner Broker 中自动卸载。&lt;/p&gt;&lt;h3&gt;第二步：查找目标 Bundle&lt;/h3&gt;&lt;pre&gt;&lt;code/&gt;&lt;/pre&gt;&lt;p&gt;如果启用了 &lt;code&gt;loadBalancerAutoBundleSplitEnabled&lt;/code&gt;（默认为 true），则启用自动拆分 Bundle 功能，Leader Broker 会判断是否有 Bundle 的负载超过 &lt;code&gt;LoadBalancerNamespaceBundle&lt;/code&gt;* 配置的阈值。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;Defaults&lt;br/&gt;LoadBalancerNamespaceBundleMaxTopics = 1000&lt;br/&gt;LoadBalancerNamespaceBundleMaxSessions = 1000&lt;br/&gt;LoadBalancerNamespaceBundleMaxMsgRate = 30000&lt;br/&gt;LoadBalancerNamespaceBundleMaxBandwidthMbytes = 100&lt;br/&gt;LoadBalancerNamespaceMaximumBundles = 128&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果命名空间中的 Bundle 个数已经达到或超过 &lt;code&gt;MaximumBundles&lt;/code&gt;，则会跳过拆分逻辑。&lt;/p&gt;&lt;h3&gt;第三步：计算 Bundle 拆分边界&lt;/h3&gt;&lt;p&gt;接下来计算目标 Bundle 的拆分边界。Bundle 拆分边界算法可通过 &lt;code&gt;supportedNamespaceBundleSplitAlgorithms&lt;/code&gt; 配置。假设某个命名空间有两个 Bundle 范围，范围分布是 (0x0000, 0X8000, 0xFFFF)，现在要拆分第一个 Bundle 范围 (0x0000, 0x8000)，可使用如下拆分算法：&lt;/p&gt;&lt;p&gt;RANGE_EQUALLY_DIVIDE_NAME（默认算法）：该算法将目标 Bundle 拆分为具有相同哈希范围大小的两个部分，例如要拆分的目标 Bundle 为 (0x0000, 0x8000)，则拆分边界为 [0x4000]。&lt;/p&gt;&lt;p&gt;&lt;span&gt;TOPIC_COUNT_EQUALLY_DIVIDE：&lt;/span&gt;&lt;span&gt;该算法将目标 Bundle 拆分为具有相同主题数的两个部分。&lt;/span&gt;&lt;span&gt;假设在目标 Bundle [0x0000, 0x8000) 中有 6 个主题：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;hash(topic1) = 0x0000&lt;br/&gt;hash(topic2) = 0x0005&lt;br/&gt;hash(topic3) = 0x0010&lt;br/&gt;hash(topic4) = 0x0015&lt;br/&gt;hash(topic5) = 0x0020&lt;br/&gt;hash(topic6) = 0x0025&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种情况会在 0x0012 处进行拆分，使左右两边的主题数相同。如果要拆分的目标 Bundle 为 [0x0000, 0x8000)，则拆分边界为 [0x0012]。&lt;/p&gt;&lt;h3&gt;第四步：根据边界拆分 Bundle&lt;/h3&gt;&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.给定 Bundle 分区为 [0x0000, 0x8000, 0xFFFF]，拆分边界为 [0x4000]。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.拆分后的 Bundle 分布为 [0x0000, 0x4000, 0x8000, 0xFFFF]。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.拆分后的 Bundle 范围为 [[0x0000, 0x4000), [0x4000, 0x8000), [0x8000, 0xFFFF]]。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;从过载的 Broker 中缩减（卸载）Bundle&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;177&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3070539419087137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2ZC8AKWRnnRuWq7Sjl9ondBKUn4T6t953S2tW3l5ppAG1xW1rbbS31XYRGMZ99qIKmuyIOib4s4Oxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/p&gt;&lt;p&gt;Leader Broker 根据从所有 Broker 中收集的负载信息，识别出哪些 Broker 已经过载，并触发 Bundle 卸载操作，目的是为了重平衡整个集群的流量。&lt;/p&gt;&lt;p&gt;Leader Broker 默认使用 &lt;code&gt;ThresholdShedder&lt;/code&gt; 策略，计算 CPU、内存以及网络 IO 之间最大资源使用率的平均值。之后，Leader 找到那些负载高于此基于平均值阈值的 Broker（见第五步）。找到过载的 Broker 之后，Leader 要求它们从高吞吐量的主题开始卸载一些主题 Bundle，直至将 Broker 负载降低到临界阈值以下。收到卸载请求后，Owner Broker 从 Metadata Store 中移除目标 Bundle 的归属信息，并关闭客户端的主题连接。&lt;span&gt;然后客户端重新启动 Broker 发现机制。&lt;/span&gt;&lt;span&gt;最终，Leader 将负载较少的 Broker 分配给被卸载的 Bundle，客户端则连接到新的 Broker。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;第五步：ThresholdShedder：查找过载的 Broker&lt;/h3&gt;&lt;p&gt;ThresholdShedder 首先使用如下公式计算出所有 Broker 的平均资源使用率。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;对每个 Broker： &lt;br/&gt;    usage =  &lt;br/&gt;    max (&lt;br/&gt;    %cpu * cpuWeight&lt;br/&gt;    %memory * memoryWeight,&lt;br/&gt;    %bandwidthIn * bandwidthInWeight,&lt;br/&gt;    %bandwidthOut * bandwidthOutWeight) / 100;&lt;br/&gt;&lt;br/&gt;    usage = x * prevUsage + (1 - x) * usage&lt;br/&gt;&lt;br/&gt;    avgUsage = sum(usage) / numBrokers &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果 Broker 的资源使用率大于 avgUsage + y，则被认为过载。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 资源使用率的权重（Weight）默认为 1.0，可通过 &lt;code&gt;loadBalancerResourceWeight&lt;/code&gt; 进行配置。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 历史使用率乘子 x 可通过 &lt;code&gt;loadBalancerHistoryResourcePercentage&lt;/code&gt; 进行配置。其默认值是 0.9，历史使用率比最近使用率的权重更大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;avgUsage&lt;/code&gt; 缓冲值 y 可通过 &lt;code&gt;loadBalancerBrokerThresholdShedderPercentage&lt;/code&gt; 进行配置，默认值是 10%。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;在本博文中，我们回顾了 Pulsar Broker 的负载均衡逻辑，重点关注其时序图。我认为 Broker 负载均衡行为有如下几个要点。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• Pulsar 通过 Bundle 将主题分组以便于跟踪，并在 Broker 之间动态地分配和平衡 Bundle。如果特定的 Bundle 发生过载，则自动进行拆分，将分配单元维护在合理的流量水平。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Pulsar 将 Broker 全局负载数据（CPU、内存以及网络使用率）以及 Bundle 负载数据（消息输入/输出速率）收集到 Leader Broker，以运行负载均衡算法逻辑：执行 Bundle-Broker 分配、Bundle 拆分和卸载（缩减）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Bundle-Broker 分配逻辑随机选择负载最少的 Broker，并将客户端重定向到分配的 Broker URL。Broker-Bundle 归属关系会在 Metadata Store 中创建临时锁，如果 Owner 不可用（失去归属权）则会自动释放锁。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Bundle 拆分逻辑根据 LoadBalancerNamespaceBundle* 配置的阈值查找目标 Bundle，默认情况下 Bundle 范围被平均拆分。拆分后，Owner 默认自动卸载新拆分的 Bundle。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Bundle 自动卸载逻辑默认使用 LoadSheddingStrategy，根据 CPU、内存以及网络 IO 的最大资源使用率平均值来查找过载的 Broker。然后 Leader 要求过载的 Broker 卸载一些高负载的主题 Bundle。被卸载的 Bundle 对应的客户端主题连接会被关闭，并重新发起 Bundle-Broker 分配。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 对比 Pulsar 与 Kafka : &lt;em&gt;https://www.splunk.com/en_us/blog/it/comparing-pulsar-and-kafka-how-a-segment-based-architecture-delivers-better-performance-scalability-and-resilience.html&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 阅读完整文档: &lt;em&gt;https://pulsar.apache.org/docs/administration-load-balance/#assign-topics-to-brokers-dynamically&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 阅读完整文档: &lt;em&gt;https://pulsar.apache.org/docs/administration-load-balance/#split-namespace-bundles&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 阅读完整文档: &lt;em&gt;https://pulsar.apache.org/docs/administration-load-balance/#shed-load-automatically&lt;/em&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxOTc4NDc2MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/0EIbbCE3P2YzZuFwkBdnEC0iaRgh95QiboG80mDK21pdRuBXogpWjlkIstOgYLOxtEpPGEEZ3cCLDh8jEkp9ic3jA/0?wx_fmt=png&quot; data-nickname=&quot;StreamNative&quot; data-alias=&quot;StreamNative&quot; data-signature=&quot;Apache Pulsar &amp;amp; Apache BookKeeper @ StreamNative&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>