<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d92f47aaf67be316dca49b3f419d767e</guid>
<title>图解Go内存管理器</title>
<link>https://toutiao.io/k/k4upoi5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于Go的内存分配&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Go&lt;/code&gt;语言里，从内存的分配到不再使用后内存的回收等等这些内存管理工作都是由&lt;code&gt;Go&lt;/code&gt;在底层完成的。虽然开发者在写代码时不必过度关心内存从分配到回收这个过程，但是&lt;code&gt;Go&lt;/code&gt;的内存分配策略里有不少有意思的设计，通过了解他们有助于我们自身的提高，也让我们能写出更高效的&lt;code&gt;Go&lt;/code&gt;程序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go内存管理的设计旨在在并发环境中快速运行，并与垃圾回收器集成在一起。让我们看一个简单的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; smallStruct &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;   a, b &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;   c, d &lt;span&gt;float64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   smallAllocation()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//go:noinline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;smallAllocation&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;smallStruct&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;smallStruct{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数上面的注释&lt;code&gt;//go:noinline&lt;/code&gt;将禁止&lt;code&gt;Go&lt;/code&gt;对该函数进行内联，这样&lt;code&gt;main&lt;/code&gt;函数就会使用&lt;code&gt;smallAllocation&lt;/code&gt;函数返回的指针变量，因为被多个函数使用，返回的这个变量将被分配到堆上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于内联的概念之前的文章有说过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;内联是一种手动或编译器优化，用于将简短函数的调用替换为函数体本身。这么做的原因是它可以消除函数调用本身的开销，也使得编译器能更高效地执行其他的优化策略。&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果上面的例子不干预编译器的话，编译器通过内联将&lt;code&gt;smallAllocation&lt;/code&gt;函数体里的内容直接放到&lt;code&gt;main&lt;/code&gt;函数里，这样就不会产生&lt;code&gt;smallAllocation&lt;/code&gt;这个函数的调用了，所有的变量都是&lt;code&gt;main&lt;/code&gt;函数内这个范围使用的，也就不在需要将变量往堆上分配了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续说上面那个例子，通过逃逸分析命令 &lt;strong&gt;go tool compile  -m main.go&lt;/strong&gt; 可以确认我们上面的分析，&lt;code&gt;&amp;amp;smallStruct{}&lt;/code&gt;会被分配到堆上去。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;➜ go tool compile -m main.go&lt;br/&gt;main.go:12:6: can inline main&lt;br/&gt;main.go:10:9: &amp;amp;smallStruct literal escapes to heap&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助命令&lt;strong&gt;go tool compile -S main.go&lt;/strong&gt;，可以显示该程序的汇编代码，也可以明确地向我们展示内存的分配：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;0x001d 00029 (main.go:10)       LEAQ    type.&quot;&quot;.smallStruct(SB), AX&lt;br/&gt;0x0024 00036 (main.go:10)       PCDATA  $2, $0&lt;br/&gt;0x0024 00036 (main.go:10)       MOVQ    AX, (SP)&lt;br/&gt;0x0028 00040 (main.go:10)       CALL    runtime.newobject(SB)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内置函数&lt;code&gt;newobject&lt;/code&gt;会通过调用另外一个内置函数&lt;code&gt;mallocgc&lt;/code&gt;在堆上分配新内存。在Go里面有两种内存分配策略，一种适用于程序里小内存块的申请，另一种适用于大内存块的申请，大内存块指的是大于32KB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来细聊一下这两种策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小于32KB内存块的分配策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当程序里发生了&lt;code&gt;32kb&lt;/code&gt;以下的小块内存申请时，Go会从一个叫做的&lt;code&gt;mcache&lt;/code&gt;的本地缓存给程序分配内存。这个本地缓存&lt;code&gt;mcache&lt;/code&gt;持有一系列的大小为&lt;code&gt;32kb&lt;/code&gt;的内存块，这样的一个内存块里叫做&lt;code&gt;mspan&lt;/code&gt;，它是要给程序分配内存时的分配单元。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.687382297551789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowB6XvZYknRxo5dhC3uvlOr0etLAibsgPm56FalO52ZQVdfat8aSUkQDQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;从mcache中给程序分配内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go的调度器模型里，每个线程&lt;code&gt;M&lt;/code&gt;会绑定给一个处理器&lt;code&gt;P&lt;/code&gt;，在单一粒度的时间里只能做多处理运行一个&lt;code&gt;goroutine&lt;/code&gt;，每个&lt;code&gt;P&lt;/code&gt;都会绑定一个上面说的本地缓存&lt;code&gt;mcache&lt;/code&gt;。当需要进行内存分配时，当前运行的&lt;code&gt;goroutine&lt;/code&gt;会从&lt;code&gt;mcache&lt;/code&gt;中查找可用的&lt;code&gt;mspan&lt;/code&gt;。从本地&lt;code&gt;mcache&lt;/code&gt;里分配内存时不需要加锁，这种分配策略效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有人就会问了，有的变量很小就是数字，有的却是一个复杂的结构体，申请内存时都分给他们一个&lt;code&gt;mspan&lt;/code&gt;这样的单元会不会产生浪费。其实&lt;code&gt;mcache&lt;/code&gt;持有的这一系列的&lt;code&gt;mspan&lt;/code&gt;并不都是统一大小的，而是按照大小，从8字节到32KB分了大概70类的&lt;code&gt;msapn&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9553349875930521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBgFDzQ6BtMd6o63YmyMYy2CwAOba6xqdpsfnUToEmziaBOvoXJ58KQ6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;figcaption&gt;按照大小分类的mspan&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就文章开始的那个例子来说，那个结构体的大小是32字节，正好32字节的这种&lt;code&gt;mspan&lt;/code&gt;能满足需求，那么分配内存的时候就会给它分配一个32字节大小的&lt;code&gt;mspan&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.687382297551789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBbImaUer9P3Fy91cNicyno4uIDBcw4scyt0z8lYePgJngA61diaLVF0bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;figcaption&gt;alloc 分配内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们可能会好奇，如果分配内存时&lt;code&gt;mcachce&lt;/code&gt;里没有空闲的32字节的&lt;code&gt;mspan&lt;/code&gt;了该怎么办？&lt;code&gt;Go&lt;/code&gt;里还为每种类别的&lt;code&gt;mspan&lt;/code&gt;维护着一个&lt;code&gt;mcentral&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mcentral&lt;/code&gt;的作用是为所有&lt;code&gt;mcache&lt;/code&gt;提供切分好的&lt;code&gt;mspan&lt;/code&gt;资源。每个&lt;code&gt;central&lt;/code&gt;会持有一种特定大小的全局&lt;code&gt;mspan&lt;/code&gt;列表，包括已分配出去的和未分配出去的。每个&lt;code&gt;mcentral&lt;/code&gt;对应一种&lt;code&gt;mspan&lt;/code&gt;，当工作线程的&lt;code&gt;mcache&lt;/code&gt;中没有合适（也就是特定大小的）的&lt;code&gt;mspan&lt;/code&gt;时就会从&lt;code&gt;mcentral&lt;/code&gt; 去获取。&lt;code&gt;mcentral&lt;/code&gt;被所有的工作线程共同享有，存在多个&lt;code&gt;goroutine&lt;/code&gt;竞争的情况，因此从&lt;code&gt;mcentral&lt;/code&gt;获取资源时需要加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mcentral&lt;/code&gt;的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//runtime/mcentral.go&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; mcentral struct {&lt;br/&gt;    // 互斥锁&lt;br/&gt;    lock mutex &lt;br/&gt;    &lt;br/&gt;    // 规格&lt;br/&gt;    sizeclass int32 &lt;br/&gt;    &lt;br/&gt;    // 尚有空闲object的mspan链表&lt;br/&gt;    nonempty mSpanList &lt;br/&gt;    &lt;br/&gt;    // 没有空闲object的mspan链表，或者是已被mcache取走的msapn链表&lt;br/&gt;    empty mSpanList &lt;br/&gt;    &lt;br/&gt;    // 已累计分配的对象个数&lt;br/&gt;    nmalloc uint64 &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mcentral&lt;/code&gt;里维护着两个双向链表，&lt;strong&gt;nonempty&lt;/strong&gt;表示链表里还有空闲的&lt;code&gt;mspan&lt;/code&gt;待分配。&lt;strong&gt;empty&lt;/strong&gt;表示这条链表里的&lt;code&gt;mspan&lt;/code&gt;都被分配了&lt;code&gt;object&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7651122625215889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowB4LP16QeDbtD6qEFycRENb5iaV8kVLUu9kCby1lyo5kPTJ6ekYGSwkeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;579&quot;/&gt;&lt;figcaption&gt;mcentral&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面我们那个程序申请内存的时候，&lt;code&gt;mcache&lt;/code&gt;里已经没有合适的空闲&lt;code&gt;mspan&lt;/code&gt;了，那么工作线程就会像下图这样去&lt;code&gt;mcentral&lt;/code&gt;里去申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说下&lt;code&gt;mcache&lt;/code&gt;从&lt;code&gt;mcentral&lt;/code&gt;获取和归还&lt;code&gt;mspan&lt;/code&gt;的流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取 加锁；从&lt;code&gt;nonempty&lt;/code&gt;链表找到一个可用的&lt;code&gt;mspan&lt;/code&gt;；并将其从&lt;code&gt;nonempty&lt;/code&gt;链表删除；将取出的&lt;code&gt;mspan&lt;/code&gt;加入到&lt;code&gt;empty&lt;/code&gt;链表；将&lt;code&gt;mspan&lt;/code&gt;返回给工作线程；解锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;归还 加锁；将&lt;code&gt;mspan&lt;/code&gt;从&lt;code&gt;empty&lt;/code&gt;链表删除；将&lt;code&gt;mspan&lt;/code&gt;加入到&lt;code&gt;nonempty&lt;/code&gt;链表；解锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.581081081081081&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBvfL1SILd6E5mx20krFSFkXaXicDCXOKtMcngSEewiarukXELS57qYLog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;666&quot;/&gt;&lt;figcaption&gt;从mcentral里申请mspan&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;mcentral&lt;/code&gt;没有空闲的&lt;code&gt;mspan&lt;/code&gt;时，会向&lt;code&gt;mheap&lt;/code&gt;申请。而&lt;code&gt;mheap&lt;/code&gt;没有资源时，会向操作系统申请新内存。&lt;code&gt;mheap&lt;/code&gt;主要用于大对象的内存分配，以及管理未切割的&lt;code&gt;mspan&lt;/code&gt;，用于给&lt;code&gt;mcentral&lt;/code&gt;切割成小对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38380281690140844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBkwtqibfPPNMRNZoKxDTZ5fPibrmxOPpCussX9xHtlT4cicdct3XSibxCvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;figcaption&gt;从heap上申请内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我们也看到，&lt;code&gt;mheap&lt;/code&gt;中含有所有规格的&lt;code&gt;mcentral&lt;/code&gt;，所以，当一个&lt;code&gt;mcache&lt;/code&gt;从&lt;code&gt;mcentral&lt;/code&gt;申请&lt;code&gt;mspan&lt;/code&gt;时，只需要在独立的&lt;code&gt;mcentral&lt;/code&gt;中使用锁，并不会影响申请其他规格的&lt;code&gt;mspan&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了每种尺寸的&lt;code&gt;mspan&lt;/code&gt;都有一个全局的列表存放在&lt;code&gt;mcentral&lt;/code&gt;里供所有线程使用，所有&lt;code&gt;mcentral&lt;/code&gt;的集合则是存放于&lt;code&gt;mheap&lt;/code&gt;中的。&lt;code&gt;mheap&lt;/code&gt;里的&lt;code&gt;arena&lt;/code&gt; 区域是真正的堆区，运行时会将 &lt;code&gt;8KB&lt;/code&gt; 看做一页，这些内存页中存储了所有在堆上初始化的对象。运行时使用二维的 runtime.heapArena 数组管理所有的内存，每个 runtime.heapArena 都会管理 64MB 的内存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.706766917293233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBylDhdmic0LGrKsfdAE1ESHV3GCt1F9auPJJ9R8qJu2tuCaryPoyZ4Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;399&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 &lt;code&gt;arena&lt;/code&gt; 区域没有足够的空间，会调用 runtime.mheap.sysAlloc 从操作系统中申请更多的内存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大于32KB内存块的分配策略&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go没法使用工作线程的本地缓存&lt;code&gt;mcache&lt;/code&gt;和全局中心缓存&lt;code&gt;mcentral&lt;/code&gt;上管理超过32KB的内存分配，所以对于那些超过32KB的内存申请，会直接从堆上(&lt;code&gt;mheap&lt;/code&gt;)上分配对应的数量的内存页（每页大小是8KB）给程序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3383742911153119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBv8NT2G2tibX9v3icjIGVRZsNxtnCgHibToeK6Iiaql8iadLakqAAarrX3FQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;529&quot;/&gt;&lt;figcaption&gt;直接从堆上分配内存&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把内存分配管理涉及的所有概念串起来，可以勾画出Go内存管理的一个全局视图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5203883495145631&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4ibYqZUwMxwOh3sQpHvQowBZz5gbKtQbg119JrXsGT7WVsjBh3l7c3DE1Dk7P5tKsmer2cibibUYJibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;figcaption&gt;Go内存分配的全局示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go语言的内存分配非常复杂，这个文章从一个比较粗的角度来看Go的内存分配，并没有深入细节。一般而言，了解它的原理，到这个程度也就可以了（应付面试）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结起来关于Go内存分配管理的策略有如下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Go在程序启动时，会向操作系统申请一大块内存，由&lt;code&gt;mheap&lt;/code&gt;结构全局管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go内存管理的基本单元是&lt;code&gt;mspan&lt;/code&gt;，每种&lt;code&gt;mspan&lt;/code&gt;可以分配特定大小的&lt;code&gt;object&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mcache&lt;/code&gt;, &lt;code&gt;mcentral&lt;/code&gt;, &lt;code&gt;mheap&lt;/code&gt;是&lt;code&gt;Go&lt;/code&gt;内存管理的三大组件，&lt;code&gt;mcache&lt;/code&gt;管理线程在本地缓存的&lt;code&gt;mspan&lt;/code&gt;；&lt;code&gt;mcentral&lt;/code&gt;管理全局的&lt;code&gt;mspan&lt;/code&gt;供所有线程使用；&lt;code&gt;mheap&lt;/code&gt;管理&lt;code&gt;Go&lt;/code&gt;的所有动态分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一般小对象通过&lt;code&gt;mspan&lt;/code&gt;分配内存；大对象则直接由&lt;code&gt;mheap&lt;/code&gt;分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485579&amp;amp;idx=1&amp;amp;sn=f481cff4ffccacc186a020e45e884924&amp;amp;chksm=fa80d91ccdf7500ab984ecde7056aa29a2986c423557736c32bd251f2cb5d1ce1e54909753cc&amp;amp;token=1603590138&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Go内存管理之代码的逃逸分析&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247484559&amp;amp;idx=1&amp;amp;sn=d639ce831d514c0f73f195f207c0583d&amp;amp;chksm=fa80d518cdf75c0e224697bd9f6f97ad94082f09591d2b9141974baf8a1054e9de0d895fb603&amp;amp;token=1603590138&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上周并发题的解题思路以及介绍Go语言调度器&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; Memory Management and Allocation&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图解Go语言内存分配&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存分配器&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5374318ab5f8c7f7184a8468a026f1f7</guid>
<title>garr ：高性能、线程安全、无锁的 go 数据结构集合</title>
<link>https://toutiao.io/k/8y2p13x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h1 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-garr---go-libs-in-a-jar&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#garr---go-libs-in-a-jar&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Garr - Go libs in a Jar&lt;/h1&gt;
&lt;p dir=&quot;auto&quot;&gt;&lt;a href=&quot;https://pkg.go.dev/go.linecorp.com/garr&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ef0553731b200a819d39d8cc7e7977fd6ba3fd2a6db5c6d654181db1ab735727/68747470733a2f2f706b672e676f2e6465762f62616467652f676f2e6c696e65636f72702e636f6d2f676172722e737667&quot; alt=&quot;Go Reference&quot; data-canonical-src=&quot;https://pkg.go.dev/badge/go.linecorp.com/garr.svg&quot;/&gt;&lt;/a&gt;
&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://github.com/line/garr/actions/workflows/ci.yml/badge.svg&quot;&gt;&lt;img src=&quot;https://github.com/line/garr/actions/workflows/ci.yml/badge.svg&quot; alt=&quot;CI&quot;/&gt;&lt;/a&gt;
&lt;a href=&quot;https://goreportcard.com/report/go.linecorp.com/garr&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/edf4b843efd365f4f0bc23578ba03523946158a91ee7357d9b03811778dfcd79/68747470733a2f2f676f7265706f7274636172642e636f6d2f62616467652f676f2e6c696e65636f72702e636f6d2f67617272&quot; alt=&quot;Go Report Card&quot; data-canonical-src=&quot;https://goreportcard.com/badge/go.linecorp.com/garr&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p dir=&quot;auto&quot;&gt;Collection of high performance, thread-safe, lock-free go data structures.&lt;/p&gt;
&lt;ul dir=&quot;auto&quot;&gt;
&lt;li&gt;&lt;a href=&quot;/line/garr/blob/main/adder/README.md&quot;&gt;adder&lt;/a&gt; - Data structure to perform highly-performant sum under high contention. Inspired by &lt;a href=&quot;https://openjdk.java.net/&quot; rel=&quot;nofollow&quot;&gt;OpenJDK LongAdder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/line/garr/blob/main/circuit-breaker/README.md&quot;&gt;circuit-breaker&lt;/a&gt; - Data structure to implement circuit breaker pattern to detect remote service failure/alive status.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/line/garr/blob/main/queue/README.md&quot;&gt;queue&lt;/a&gt; - Queue data structure, go implementation of &lt;code&gt;JDKLinkedQueue&lt;/code&gt; and &lt;code&gt;MutexLinkedQueue&lt;/code&gt; from &lt;code&gt;OpenJDK&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/line/garr/blob/main/retry/README.md&quot;&gt;retry&lt;/a&gt; - Controls backoff between attempts in a retry operation.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/line/garr/blob/main/worker-pool/README.md&quot;&gt;worker-pool&lt;/a&gt; - Worker pool implementation in go to help perform multiple tasks concurrently with a fixed-but-expandable amount of workers.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-usage&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#usage&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Usage&lt;/h1&gt;
&lt;h2 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-getting-started&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#getting-started&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Getting started&lt;/h2&gt;
&lt;div class=&quot;highlight highlight-source-shell notranslate position-relative overflow-auto&quot; data-snippet-clipboard-copy-content=&quot;go get -u go.linecorp.com/garr&quot;&gt;&lt;pre&gt;go get -u go.linecorp.com/garr&lt;/pre&gt;&lt;/div&gt;
&lt;h2 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-examples&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#examples&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Examples&lt;/h2&gt;
&lt;p dir=&quot;auto&quot;&gt;Please find detailed examples in each sub-package.&lt;/p&gt;
&lt;h3 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-adder&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#adder&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Adder&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go notranslate position-relative overflow-auto&quot; data-snippet-clipboard-copy-content=&quot;package main&amp;#10;&amp;#10;import (&amp;#10;&amp;quot;fmt&amp;quot;&amp;#10;&amp;quot;time&amp;quot;&amp;#10;&amp;#10;ga &amp;quot;go.linecorp.com/garr/adder&amp;quot;&amp;#10;)&amp;#10;&amp;#10;func main() {&amp;#10;// or ga.DefaultAdder() which uses jdk long-adder as default&amp;#10;adder := ga.NewLongAdder(ga.JDKAdderType) &amp;#10;&amp;#10;for i := 0; i &amp;lt; 100; i++ {&amp;#10;go func() {&amp;#10;adder.Add(123)&amp;#10;}()&amp;#10;}&amp;#10;&amp;#10;time.Sleep(3 * time.Second)&amp;#10;&amp;#10;// get total added value&amp;#10;fmt.Println(adder.Sum()) &amp;#10;}&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
&lt;span class=&quot;pl-s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
&lt;span class=&quot;pl-s&quot;&gt;&quot;time&quot;&lt;/span&gt;

ga &lt;span class=&quot;pl-s&quot;&gt;&quot;go.linecorp.com/garr/adder&quot;&lt;/span&gt;
)

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
&lt;span class=&quot;pl-c&quot;&gt;// or ga.DefaultAdder() which uses jdk long-adder as default&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;ga&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;NewLongAdder&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;ga&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;JDKAdderType&lt;/span&gt;) 

&lt;span class=&quot;pl-k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt;; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;100&lt;/span&gt;; &lt;span class=&quot;pl-s1&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;++&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt;() {
&lt;span class=&quot;pl-s1&quot;&gt;adder&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;123&lt;/span&gt;)
}()
}

&lt;span class=&quot;pl-s1&quot;&gt;time&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sleep&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;time&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Second&lt;/span&gt;)

&lt;span class=&quot;pl-c&quot;&gt;// get total added value&lt;/span&gt;
&lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Println&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;adder&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sum&lt;/span&gt;()) 
}&lt;/pre&gt;&lt;/div&gt;
&lt;h4 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-build-your-own-prometheus-counter-with-adder&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#build-your-own-prometheus-counter-with-adder&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Build your own Prometheus counter with Adder&lt;/h4&gt;
&lt;div class=&quot;highlight highlight-source-go notranslate position-relative overflow-auto&quot; data-snippet-clipboard-copy-content=&quot;package prom&amp;#10;&amp;#10;import (&amp;#10;ga &amp;quot;go.linecorp.com/garr/adder&amp;quot;&amp;#10;&amp;#10;&amp;quot;github.com/prometheus/client_golang/prometheus&amp;quot;&amp;#10;dto &amp;quot;github.com/prometheus/client_model/go&amp;quot;&amp;#10;)&amp;#10;&amp;#10;// NewCounterI64 creates a new CounterI64 based on the provided prometheus.CounterOpts.&amp;#10;func NewCounterI64(opts prometheus.CounterOpts) CounterI64 {&amp;#10;return CounterI64{counter: prometheus.NewCounter(opts)}&amp;#10;}&amp;#10;&amp;#10;// CounterI64 is optimized Prometheus Counter for int64 value type.&amp;#10;type CounterI64 struct {&amp;#10;val     ga.JDKAdder&amp;#10;counter prometheus.Counter&amp;#10;}&amp;#10;&amp;#10;// Value returns current value.&amp;#10;func (c *CounterI64) Value() int64 {&amp;#10;return c.val.Sum()&amp;#10;}&amp;#10;&amp;#10;// Reset value.&amp;#10;func (c *CounterI64) Reset() {&amp;#10;c.val.Reset()&amp;#10;}&amp;#10;&amp;#10;// Desc returns metric desc.&amp;#10;func (c *CounterI64) Desc() *prometheus.Desc {&amp;#10;return c.counter.Desc()&amp;#10;}&amp;#10;&amp;#10;// Inc by 1.&amp;#10;func (c *CounterI64) Inc() {&amp;#10;c.val.Add(1)&amp;#10;}&amp;#10;&amp;#10;// Add by variant.&amp;#10;func (c *CounterI64) Add(val int64) {&amp;#10;if val &amp;gt; 0 {&amp;#10;c.val.Add(val)&amp;#10;}&amp;#10;}&amp;#10;&amp;#10;// Write implements prometheus.Metric interface.&amp;#10;func (c *CounterI64) Write(out *dto.Metric) (err error) {&amp;#10;if err = c.counter.Write(out); err == nil {&amp;#10;value := float64(c.val.Sum())&amp;#10;out.Counter.Value = &amp;amp;value&amp;#10;}&amp;#10;return&amp;#10;}&amp;#10;&amp;#10;// Collect implements prometheus.Collector interface.&amp;#10;func (c *CounterI64) Collect(ch chan&amp;lt;- prometheus.Metric) {&amp;#10;ch &amp;lt;- c&amp;#10;}&amp;#10;&amp;#10;// Describe implements prometheus.Collector interface.&amp;#10;func (c *CounterI64) Describe(ch chan&amp;lt;- *prometheus.Desc) {&amp;#10;ch &amp;lt;- c.counter.Desc()&amp;#10;}&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;package&lt;/span&gt; prom

&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
ga &lt;span class=&quot;pl-s&quot;&gt;&quot;go.linecorp.com/garr/adder&quot;&lt;/span&gt;

&lt;span class=&quot;pl-s&quot;&gt;&quot;github.com/prometheus/client_golang/prometheus&quot;&lt;/span&gt;
dto &lt;span class=&quot;pl-s&quot;&gt;&quot;github.com/prometheus/client_model/go&quot;&lt;/span&gt;
)

&lt;span class=&quot;pl-c&quot;&gt;// NewCounterI64 creates a new CounterI64 based on the provided prometheus.CounterOpts.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;NewCounterI64&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;opts&lt;/span&gt; prometheus.&lt;span class=&quot;pl-smi&quot;&gt;CounterOpts&lt;/span&gt;) &lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;{&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;: &lt;span class=&quot;pl-s1&quot;&gt;prometheus&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;NewCounter&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;opts&lt;/span&gt;)}
}

&lt;span class=&quot;pl-c&quot;&gt;// CounterI64 is optimized Prometheus Counter for int64 value type.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;struct&lt;/span&gt; {
&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;     ga.&lt;span class=&quot;pl-smi&quot;&gt;JDKAdder&lt;/span&gt;
&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt; prometheus.&lt;span class=&quot;pl-smi&quot;&gt;Counter&lt;/span&gt;
}

&lt;span class=&quot;pl-c&quot;&gt;// Value returns current value.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Value&lt;/span&gt;() &lt;span class=&quot;pl-smi&quot;&gt;int64&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sum&lt;/span&gt;()
}

&lt;span class=&quot;pl-c&quot;&gt;// Reset value.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Reset&lt;/span&gt;() {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Reset&lt;/span&gt;()
}

&lt;span class=&quot;pl-c&quot;&gt;// Desc returns metric desc.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Desc&lt;/span&gt;() &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;prometheus.&lt;span class=&quot;pl-smi&quot;&gt;Desc&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Desc&lt;/span&gt;()
}

&lt;span class=&quot;pl-c&quot;&gt;// Inc by 1.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Inc&lt;/span&gt;() {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;1&lt;/span&gt;)
}

&lt;span class=&quot;pl-c&quot;&gt;// Add by variant.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;int64&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;0&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;val&lt;/span&gt;)
}
}

&lt;span class=&quot;pl-c&quot;&gt;// Write implements prometheus.Metric interface.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Write&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;dto.&lt;span class=&quot;pl-smi&quot;&gt;Metric&lt;/span&gt;) (&lt;span class=&quot;pl-s1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt;) {
&lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Write&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;out&lt;/span&gt;); &lt;span class=&quot;pl-s1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;float64&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;val&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Sum&lt;/span&gt;())
&lt;span class=&quot;pl-s1&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Counter&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;pl-s1&quot;&gt;value&lt;/span&gt;
}
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt;
}

&lt;span class=&quot;pl-c&quot;&gt;// Collect implements prometheus.Collector interface.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Collect&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt; prometheus.&lt;span class=&quot;pl-smi&quot;&gt;Metric&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;
}

&lt;span class=&quot;pl-c&quot;&gt;// Describe implements prometheus.Collector interface.&lt;/span&gt;
&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;pl-smi&quot;&gt;CounterI64&lt;/span&gt;) &lt;span class=&quot;pl-en&quot;&gt;Describe&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;chan&lt;/span&gt;&lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;*&lt;/span&gt;prometheus.&lt;span class=&quot;pl-smi&quot;&gt;Desc&lt;/span&gt;) {
&lt;span class=&quot;pl-s1&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;c&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;counter&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Desc&lt;/span&gt;()
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-queue&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#queue&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Queue&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go notranslate position-relative overflow-auto&quot; data-snippet-clipboard-copy-content=&quot;package main&amp;#10;&amp;#10;import (&amp;#10;    &amp;quot;fmt&amp;quot;&amp;#10;&amp;#10;    &amp;quot;go.linecorp.com/garr/queue&amp;quot;&amp;#10;)&amp;#10;&amp;#10;func main() {&amp;#10;    q := queue.DefaultQueue() // default using jdk linked queue&amp;#10;&amp;#10;    // push&amp;#10;    q.Offer(123)&amp;#10;&amp;#10;    // return head queue but not remove&amp;#10;    head := q.Peak()&amp;#10;    fmt.Println(head)&amp;#10;&amp;#10;    // remove and return head queue&amp;#10;    polled := q.Poll()&amp;#10;    fmt.Println(polled)&amp;#10;}&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;pl-s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

    &lt;span class=&quot;pl-s&quot;&gt;&quot;go.linecorp.com/garr/queue&quot;&lt;/span&gt;
)

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-s1&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;queue&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;DefaultQueue&lt;/span&gt;() &lt;span class=&quot;pl-c&quot;&gt;// default using jdk linked queue&lt;/span&gt;

    &lt;span class=&quot;pl-c&quot;&gt;// push&lt;/span&gt;
    &lt;span class=&quot;pl-s1&quot;&gt;q&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Offer&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;123&lt;/span&gt;)

    &lt;span class=&quot;pl-c&quot;&gt;// return head queue but not remove&lt;/span&gt;
    &lt;span class=&quot;pl-s1&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;q&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Peak&lt;/span&gt;()
    &lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Println&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;head&lt;/span&gt;)

    &lt;span class=&quot;pl-c&quot;&gt;// remove and return head queue&lt;/span&gt;
    &lt;span class=&quot;pl-s1&quot;&gt;polled&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;q&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Poll&lt;/span&gt;()
    &lt;span class=&quot;pl-s1&quot;&gt;fmt&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;Println&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;polled&lt;/span&gt;)
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3 dir=&quot;auto&quot;&gt;&lt;a id=&quot;user-content-circuit-breaker&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#circuit-breaker&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;Circuit Breaker&lt;/h3&gt;
&lt;div class=&quot;highlight highlight-source-go notranslate position-relative overflow-auto&quot; data-snippet-clipboard-copy-content=&quot;package main&amp;#10;&amp;#10;import (&amp;#10;    cbreaker &amp;quot;go.linecorp.com/garr/circuit-breaker&amp;quot;&amp;#10;)&amp;#10;&amp;#10;func makeRequest() error {&amp;#10;return nil&amp;#10;}&amp;#10;&amp;#10;func main() {&amp;#10;    cb := cbreaker.NewCircuitBreakerBuilder().&amp;#10;                        SetTicker(cbreaker.SystemTicker).&amp;#10;                        SetFailureRateThreshold(validFailureRateThreshold).&amp;#10;                        Build()&amp;#10;&amp;#10;    if cb.CanRequest() {&amp;#10;        err := makeRequest()&amp;#10;        if err != nil {&amp;#10;            cb.OnFailure()&amp;#10;        } else {&amp;#10;            cb.OnSuccess()&amp;#10;        }&amp;#10;    }&amp;#10;}&quot;&gt;&lt;pre&gt;&lt;span class=&quot;pl-k&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;pl-k&quot;&gt;import&lt;/span&gt; (
    cbreaker &lt;span class=&quot;pl-s&quot;&gt;&quot;go.linecorp.com/garr/circuit-breaker&quot;&lt;/span&gt;
)

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;makeRequest&lt;/span&gt;() &lt;span class=&quot;pl-smi&quot;&gt;error&lt;/span&gt; {
&lt;span class=&quot;pl-k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt;
}

&lt;span class=&quot;pl-k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;main&lt;/span&gt;() {
    &lt;span class=&quot;pl-s1&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;cbreaker&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;NewCircuitBreakerBuilder&lt;/span&gt;().
                        &lt;span class=&quot;pl-en&quot;&gt;SetTicker&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;cbreaker&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;SystemTicker&lt;/span&gt;).
                        &lt;span class=&quot;pl-en&quot;&gt;SetFailureRateThreshold&lt;/span&gt;(&lt;span class=&quot;pl-s1&quot;&gt;validFailureRateThreshold&lt;/span&gt;).
                        &lt;span class=&quot;pl-en&quot;&gt;Build&lt;/span&gt;()

    &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;cb&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;CanRequest&lt;/span&gt;() {
        &lt;span class=&quot;pl-s1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;makeRequest&lt;/span&gt;()
        &lt;span class=&quot;pl-k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;pl-s1&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;nil&lt;/span&gt; {
            &lt;span class=&quot;pl-s1&quot;&gt;cb&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;OnFailure&lt;/span&gt;()
        } &lt;span class=&quot;pl-k&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;pl-s1&quot;&gt;cb&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;OnSuccess&lt;/span&gt;()
        }
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;/article&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95315bb19ed690924320d2ad2bac8254</guid>
<title>缓存穿透、缓存击穿、缓存雪崩</title>
<link>https://toutiao.io/k/laxldpe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45233463035019456&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVpamYJia5K0IdYsEzs4ib73MlYSGmeT5wL1iaMXDBNEAqrPWPjhuibaQ0QrQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是楼仔！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天写的这个主题内容，其实非常基础，但是&lt;strong&gt;作为高并发非常重要的几个场景，绝对绕不开&lt;/strong&gt;，估计大家面试时，也经常会遇到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个主题的文章，网上非常多，本来想直接转载一篇，但是感觉没有合适的，要么文章不够精炼，要么就是精简过头，所以还是自己写一篇吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容虽然基础，但我还是秉承以往的写作风格，参考众多优秀的博客后，打算写一篇能通俗易懂，又不失全面的文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看一下正常情况的查询过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先查询 Redis，如果查询成功，直接返回，查询不存在，去查询 DB；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 DB 查询成功，数据回写 Redis，查询不存在，直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7459379615952733&quot; data-type=&quot;png&quot; data-w=&quot;677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVp0m8zibaiaPA5VRIfzU1HT95rqCI5TQuPlnwozoXXkAl63DiaDjfhZfquA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存穿透&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;定义：当查询数据库和缓存都无数据时，因为数据库查询无数据，出于容错考虑，不会将结果保存到缓存中，因此&lt;strong&gt;每次请求都会去查询数据库&lt;/strong&gt;，这种情况就叫做缓存穿透。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6910112359550562&quot; data-type=&quot;png&quot; data-w=&quot;712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVpKJ1r7KEiaRzXRyKyoXhz5f71NrPK1m4MiaOZiaxcnQplu9JZWOQCvBalg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色的线条，就是缓存穿透的场景，&lt;strong&gt;当查询的 Key 在缓存和 DB 中都不存在时，就会出现这种情况。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以想象一下，比如有个接口需要查询商品信息，如果有恶意用户模拟不存在的商品 ID 发起请求，瞬间并发量很高，估计你的 DB 会直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能大家第一反应就是对入参进行正则校验，过滤掉无效请求，对！这个没错，那有没有其它更好的方案呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓存空值&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们从数据库中查询到空值时，&lt;strong&gt;我们可以向缓存中回种一个空值&lt;/strong&gt;，为了避免缓存被长时间占用，需要给这个空值加一个比较短的过期时间，例如 3~5 分钟。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7246192893401016&quot; data-type=&quot;png&quot; data-w=&quot;788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVpauvQ3SVngNmWIBZicTEmqGD4eSNKHdwlSw2sEfLycxjViaXCLyib9WI6w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这个方案有个问题，当大量无效请求穿透过来时，缓存内就会有有大量的空值缓存，如果缓存空间被占满了，还会因剔除掉一些已经被缓存的用户信息，反而会造成缓存命中率的下降，&lt;strong&gt;所以这个方案，需要评估缓存容量。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果缓存空值不可取，这时你可以考虑使用布隆过滤器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;布隆过滤器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;布隆过滤器是由一个可变长度为 N 的二进制数组与一组数量可变 M 的哈希函数构成，说的简单粗暴一点，就是一个 Hash Map。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理相当简单：比如元素 key=#3，假如通过 Hash 算法得到一个为 9 的值，就存在这个 Hash Map 的第 9 位元素中，通过标记 1 标识该位已经有数据，如下图所示，0 是无数据，1 是有数据。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5160680529300568&quot; data-type=&quot;png&quot; data-w=&quot;529&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVpB2jNHfB4ZgvQatxx9DU5MYaPNR6kajmrkVCzrWIlwiaKt2KN8bg9geA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以通过该方法，会得到一个结论：&lt;strong&gt;在 Hash Map 中，标记的数据，不一定存在，但是没有标记的数据，肯定不存在。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么“标记的数据，不一定存在”呢？&lt;strong&gt;因为 Hash 冲突！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Hash Map 的长度为 100，但是你有 101 个请求，假如你运气好到爆，这 100 个请求刚好均匀打在长度为 100 的 Hash Map 中，此时你的 Hash Map 已经全部标记为 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当第 101 个请求过来时，就 100% 出现 Hash 冲突&lt;/strong&gt;，虽然我没有请求过，但是得到的标记却为 1，导致布隆过滤器没有拦截。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要减少误判，可以增加 Hash Map 的长度，并选择却分度更高的 Hash 函数，比如多次对 key 进行 hash。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 Hash 冲突，&lt;strong&gt;布隆过滤器其实会带来一个致命的问题：布隆过滤器更新失败。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有一个商品 ID 第一次请求，当 DB 中存在时，需要在 Hash Map 中标记一下，但是由于网络原因，导致标记失败，那么下次这个商品 ID 重新发起请求时，请求会被布隆过滤器拦截，比如这个是双11的爆款商品库存，明明有 10W 件商品，你却提示库存不存在，领导可能会说“明天你可以不用来了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以如果使用布隆过滤器，在对 Hash Map 进行数据更新时，需要保证这个数据能 100% 更新成功&lt;/strong&gt;，可以通过异步、重试的方式，所以这个方案有一定的实现成本和风险。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存击穿&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;定义：&lt;strong&gt;某个热点缓存在某一时刻恰好失效&lt;/strong&gt;，然后此时刚好有大量的并发请求，此时这些请求将会给数据库造成巨大的压力，这种情况就叫做缓存击穿。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个其实和“缓存穿透”流程图一样，只是这个的出发点是“某个热点缓存在某一时刻恰好失效”，比如某个非常热门的爆款商品，缓存突然失效，流量直接全部打到 DB，&lt;strong&gt;造成某一时刻数据库请求量过大，更强调瞬时性。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决问题的方法主要有 2 种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;：只有拿到锁的第一个线程去请求数据库，然后插入缓存，当然每次拿到锁的时候都要去查询一下缓存有没有，这种在高并发场景下，个人不太建议用分布式锁，会影响查询效率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;设置永不过期&lt;/strong&gt;：对于某些热点缓存，我们可以设置永不过期，这样就能保证缓存的稳定性，但需要注意在数据更改之后，要及时更新此热点缓存，不然就会造成查询结果的误差，比如热门商品，都先预热到数据库，后续再下线掉。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上还有“缓存续期”的方式，比如缓存 30 分钟失效，可以搞个定时任务，每 20 分钟跑一次，感觉这种方式不伦不类，仅供大家参考。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存雪崩&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;定义：&lt;strong&gt;在短时间内有大量缓存同时过期，导致大量的请求直接查询数据库&lt;/strong&gt;，从而对数据库造成了巨大的压力，严重情况下可能会导致数据库宕机的情况叫做缓存雪崩。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说“缓存击穿”是单兵反抗，那“缓存雪崩”就是集体起义了，那什么情况会出现缓存雪崩呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;短时间内有大量缓存同时过期；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存服务宕机，导致某一时刻发生大规模的缓存失效。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有哪些解决方案呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;缓存添加随机时间&lt;/strong&gt;：可在设置缓存时添加随机时间，比如 0~60s，这样就可以极大的避免大量的缓存同时失效；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分布式锁&lt;/strong&gt;：加一个分布式锁，第一个请求将数据持久化到缓存后，其它的请求才能进入；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流和降级&lt;/strong&gt;：通过限流和降级策略，减少请求的流量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群部署&lt;/strong&gt;：Redis 通过集群部署、主从策略，主节点宕机后，会切换到从节点，保证服务的可用性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存添加随机时间示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 缓存原本的失效时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; exTime = &lt;span&gt;10&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 随机数生成类&lt;/span&gt;&lt;br/&gt;Random random = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;&lt;span&gt;// 缓存设置&lt;/span&gt;&lt;br/&gt;jedis.setex(cacheKey, exTime + random.nextInt(&lt;span&gt;1000&lt;/span&gt;) , value);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;「文章汇总」&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;汇总目录&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3OTU5NzQ1Mw==&amp;amp;mid=2247487713&amp;amp;idx=1&amp;amp;sn=9661f1520e6237d18536ccf496f8793a&amp;amp;chksm=cf035203f874db157eb05a3909725daeadd4625b8702f358abe9d77dd52fefd08c50279ce771&amp;amp;token=1760780777&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;楼仔原创精选荟萃&lt;/a&gt; 🔥🔥🔥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;推荐理由&lt;/strong&gt;：&lt;span&gt;一百多篇原创好文，近 2 年的坚持，&lt;/span&gt;&lt;strong&gt;无论你是小白，还是资深大佬，总能找到属于你自己的段位。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3OTU5NzQ1Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFTdSvrrpJnCZ0Fp5Z1wKkhKFQBxTaFfxOpib3E2zgUu39BFbsBqqJbEpxicUvz3H6csoL2JQ9EP1yQ/0?wx_fmt=png&quot; data-nickname=&quot;楼仔&quot; data-alias=&quot;&quot; data-signature=&quot;7 年一线大厂经验（百度/小米/滴滴），带你进大厂，不限于Java、Go、高并发、架构选型、消息队列、设计模式、MySQL、Redis、DDD、项目管理、软技能等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;「学习交流」&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前我们已经成立多个技术交流群！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长按二维码，回复 &lt;strong&gt;「加群」&lt;/strong&gt;，欢迎一起学习交流哈~~ 👏🏻👏🏻👏🏻&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5726210350584308&quot; data-type=&quot;png&quot; data-w=&quot;1198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFvjy33QIm6KV68BdT73EVp0ibd3XdurERqIhL1DWS0fhiaZqibDNekibaUlicLiaz60ibGPzZzWxv4PpZgQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;尽信书则不如无书，因个人能力有限，难免有疏漏和错误之处，如发现 bug 或者有更好的建议，欢迎批评指正，不吝感激。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9766f770883884f36781a5320c92e131</guid>
<title>数据库全量SQL分析与审计系统性能优化之旅</title>
<link>https://toutiao.io/k/np9qvi3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUrXicw2VXTQTVVN5yxXWEacdY1ZdxTH195Pgibtib8EENJRMia3tzEnyVfgyfAgRibMssKqwlE186TLSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总第514&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2022年 第031篇&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;127&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;93&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;93&quot; data-ratio=&quot;0.9966329966329966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVLR21NicmyQxcmiaqQ2KOJJj2JLwgJL4KSbo7CcuMF1hLf4xFjGQiaDRhSPyERxWGChWYP47Oc4sKGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot; data-width=&quot;100%&quot; opacity=&quot;&quot; title=&quot;undefined&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; data-style=&quot;text-align: left; font-size: 14px; color: inherit;&quot;&gt;&lt;p&gt;&lt;span&gt;全量SQL（所有访问数据库的SQL）可以有效地帮助安全进行数据库审计，帮助业务快速排查性能问题。一般可通过开启genlog日志或者启动MySQL审计插件方式来进行获取，而美团选用了一种非侵入式的旁路抓包方案，使用Go语言实现。无论采用哪种方案，都需要重点关注它对数据库的性能损耗。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团基础研发平台抓包方案在数据库审计实践中遇到的性能问题以及优化实践，希望能对大家有所帮助或启发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2 现状及挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3 分析及优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 数据采集端介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 基础性能测试&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 CPU画像分析&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 脱敏分析及改进&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.5 调度分析及改进&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.6 垃圾回收压力分析及改进&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.7 解包分析及改进&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4 最终成果&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5 未来规划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;数据库安全一直是美团信息安全团队和数据库团队非常注重的领域，但由于历史原因，对数据库的访问只具备采样审计能力，导致对于一些攻击事件无法快速地发现、定损和优化。安全团队根据历史经验，发现攻击访问数据库基本上都存在着某些特征，经常会使用一些特定SQL，我们希望通过对MySQL访问流量进行全量分析，识别出惯用SQL，在数据库安全性上做到有的放矢。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 现状及挑战&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;下图是采样MySQL审计系统的架构图，数据采集端基于pcap抓包方式实现，数据处理端选用美团大数据中心的日志接入方案。所有MySQL实例都部署了用于采集MySQL相关数据的rds-agent、日志收集的log-agent。rds-agent抓取到MySQL访问数据，通过log-agent上报到日志接收端，为了减少延时，上报端与接收端间做了同机房调度优化。日志接收端把数据写入到约定的Kafka中，安全团队通过Storm实时消费Kafka分析出攻击事件，并定期拉数据持久化到Hive中。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;305&quot; data-ratio=&quot;0.5283582089552239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7pkibdoQ5lYmOxDaAfsuBlyazLnGOCMkibgiadgicLtMaD8fbupRCC1XtMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1005&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;我们发现，通常被攻击的都是一些核心MySQL集群。&lt;/span&gt;&lt;span&gt;经统计发现，这些集群单机最大QPS的9995线约5万次左右。&lt;/span&gt;&lt;span&gt;rds-agent作为MySQL机器上的一个寄生进程，为了宿主稳定性，资源控制也极为重要。&lt;/span&gt;&lt;span&gt;为了评估rds-agent在高QPS下的表现，我们用Sysbench对MySQL进行压测，观察在不同QPS下rds-agent抓取的数据丢失率和CPU消耗情况，从下面的压测数据来看结果比较糟糕：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8113207547169812&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7AarnDzDiaJ6EchJXypiaJyjdh6iaGB6zJWibmy3H8ibl4xkbkJWicz3Qlbdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何在高QPS下保证较低的丢失率与CPU消耗？已经成为当前系统的一个亟待解决的难题与挑战。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 分析及优化&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;下面主要介绍围绕丢失率与CPU消耗这一问题，我们对数据采集端在流程、调度、垃圾回收和协议方面做的分析与改进。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 数据采集端介绍&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;首先，简要介绍一下数据采集端rds-agent，它是一个MySQL实例上的进程，采用Go语言编写，基于开源的MysqlProbe的Agent改造。通过监听网卡上MySQL端口的流量，分析出客户端的访问时间、来源IP、用户名、SQL、目标数据库和目标IP等审计信息。下面是其架构图，主要分为5大功能模块：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;452&quot; data-ratio=&quot;0.7818791946308725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7Yk93lBanEzDI5cpkdTOKhCv7HzPpUJoFL2ibCibJaafIMrS8d4zrtcaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;596&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. probe&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;probe意为探针，采用了gopacket作为抓包方案，它是谷歌开源的一个Go抓包库，封装了pcap。probe把抓取到原始的数据链路层帧封装成TCP层的数据包。通过变种的Fowler-Noll-Vo算法哈希源和目的IP port字段，快速实现把数据库连接打散到不同的worker中，该算法保证了同一连接的来包与回包的哈希值一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. watcher&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;登录用户名对于审计来说极其重要，客户端往往都是通过长连接访问MySQL，而登录信息仅出现在MySQL通信协议的认证握手阶段，仅通过抓包容易错过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;watcher通过定时执行show processlist获取当前数据库的所有连接数据，通过对比Host字段与当前包的客户端ip port，补偿错过的用户名信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. worker&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的worker负责管理不同数据库连接的生命周期，一个worker管理多个连接。通过定期比对worker的当前连接列表与watcher中的连接列表，及时发现过期的连接，关闭并释放相关资源，防止内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. connStream&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整个数据采集端的核心逻辑，负责根据MySQL协议解析TCP数据包并识别出特定SQL，一个连接对应一个connStream Goroutine。因为SQL中可能包含敏感数据，connStream还负责对SQL进行脱敏，具体的特定SQL识别策略，由于安全方面原因，这里不再进行展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. sender&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;负责数据上报逻辑，通过thrift协议将connStream解析出的审计数据上报给log-agent。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 基础性能测试&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;抓包库gopacket的性能直接决定了系统性能上限，为了探究问题是否出在gopacket上，我们编写了简易的tcp-client和tcp-server，单独对gopacket在数据流向图中涉及到的前三个步骤（&lt;/span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;span&gt;）进行了性能测试，从下面的测试结果数据上看，性能瓶颈点不在gopacket。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;194&quot; data-ratio=&quot;0.33477011494252873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7Sm0LMYvSss7WPh2ace9Cz3rZbK4YO6GT4ZCutibuWxciawWf7rZjIOAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.21453287197231835&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7AuQzULNu7WNcibwibQXoolOQZmCibhOL31Nq6YpLLFkpTE8cUDBpMH73w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 CPU画像分析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;丢失率与CPU消耗二者密不可分，为了探究如此高CPU消耗的原因，我们用Go自带的pprof工具对进程的CPU消耗进行了画像分析，从下面火焰图的调用函数可以归纳出几个大头：SQL脱敏、解包、GC和Goroutine调度。下面主要介绍一下围绕它们做的优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7rQ2o868ACQLJXrpbzKiaEkdahlVwsZA0EN9S0VMGnxVtOsNs3ze48fA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 脱敏分析及改进&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;因为SQL中可能包含敏感信息，出于安全考虑，rds-agent会对每一条SQL进行脱敏处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;脱敏操作使用了pingcap的SQL解析器对SQL进行模板化：即把SQL中的值全部替换成“?”来达到目的，该操作需要解析出SQL的抽象语法树，代价较高。当前只有采样和抓取特定SQL的需求，没有必要在解析阶段对每条SQL进行脱敏。这里在流程上进行了优化，把脱敏下沉到上报模块，只对最终发送出去的样本脱敏。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;194&quot; data-ratio=&quot;0.33627019089574156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7hEUgJoiaJUf5EhHDnUy0VRc75fGQXNlW8IPz6MtKibGPgvVjt3eBcTjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;681&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;这个优化取得的效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3261261261261261&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7aMq0VYiaoMCaiaQGtmv56G0qNO0ibeSTW0sUAvqwyMYCXQEJXwIHmQZUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 调度分析及改进&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;从下面的数据流向图可以看出整个链路比较长，容易出现性能瓶颈点。同时存在众多高频运行的Goroutine（&lt;/span&gt;&lt;span&gt;红色部分&lt;/span&gt;&lt;span&gt;），由于数量多，Go需要经常在这些Goroutine间进行调度切换，切换对于我们这种CPU密集型的程序来说无疑是一种负担。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;389&quot; data-ratio=&quot;0.6729106628242075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7XgtCNiaLAIxeFqGJF4DfOSWBbcqEGrKEYicco1F53jpMSjdVaM5ic7Rkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;694&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;针对该问题，我们做了如下优化：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;缩短链路&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：分流、worker、解析SQL等模块合并成一个Goroutine解析器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;降低切换频率&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：解析器每5ms从网络协议包的队列中取一次，相当于手动触发切换。(&lt;/span&gt;&lt;span&gt;5ms也是一个多次测试后的折中数据，太小会消耗更多的CPU，太大会引起数据丢失&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这个优化取得的效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3224043715846995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7qicLPQhge9aWBJNZuMHt8lgc45HJ8QP6wiauIvkF6OXuq6JJtfhh4kBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.6 垃圾回收压力分析及改进&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图为rds-agent抓包30秒，已分配指针对象的火焰图。可以看出已经分配了4千多万个对象，GC压力可想而知。关于GC，我们了解到如下两种优化方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;池化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Go的标准库中提供了一个sync.Pool对象池，可通过复用对象来减少对象分配，从而降低GC压力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;手动管理内存&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：通过系统调用mmap直接向OS申请内存，绕过GC，实现内存的手动管理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;132&quot; data-ratio=&quot;0.22791519434628976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7rlmib1s4OkOEUo1GdyBruOgIqgORACbZ3DQnk1oqpadO4A6ia4UnSzlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;但是，方案2容易出现内存泄漏。&lt;/span&gt;&lt;span&gt;从稳定性的角度考虑，我们最终选择了方案1来管理高频调用函数里创建的指针对象，这个优化取得的效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3211009174311927&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7swkn6CLTfMxHicGzI10SMOXjONMj7V49CK4HYibaaicpkuUu22V3fXFHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.7 解包分析及改进&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MySQL是基于TCP协议之上的，在功能调试过程中，我们发现了很多空包。从下面的MySQL客户端-服务端数据的交互图可以看出：当客户端发送一条SQL命令，服务端响应结果，由于TCP的消息确认机制，客户端会发送一个空的ack包来确认消息，而且空包在整个流程中的比例较大，它们会穿透到解析环节，在高QPS下对于Goroutine调度和GC来说无疑是一个负担。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7oOZJlU11EcoG8ib4SvH7l9joO70ZicQeu8Xs3L1aNgNjro5SoN1nQQzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;284&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;215&quot; data-ratio=&quot;1.0833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7vNRFep7UvzDfPRfTDBVic0bfFvF3KYh17jog2iaqkWYiaIYqdDKhQnyfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下图是MySQL数据包的唯一格式，通过分析，我们观察到以下特点：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;206&quot; data-ratio=&quot;0.35625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7nYqoeRBexXicD8o0YZtibd288YQVTZyvibvibgOgUWeMRVuCQ2aFdmnaIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个完整的MySQL数据包长度&amp;gt;=4Byte&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;客户端新发送命令的sequence id都是为0或者1&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;而pcap支持设置过滤规则，让我们可以在内核层将空包排除掉，下面是上述特点对应的两条过滤规则：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;特点1：ip[2:2] - ((ip[0] &amp;amp; 0x0f) &amp;lt;&amp;lt; 2) - ((tcp[12:1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 2) &amp;gt;= 4&lt;br/&gt;特点2： (dst host {localIP} and dst port 3306 and (tcp[(((tcp[12:1] &amp;amp; 0xf0) &amp;gt;&amp;gt; 2) + 3)] &amp;lt;= 0x01))&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这个优化取得的效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3156934306569343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7bHZqRu8uRGfD2VBcuInKFvx6KKSo0JNEQnwicmFJkcmkctA5jc2wVvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于上述经验，我们对数据采集端进行功能代码重构，同时还进行一些其它优化。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 最终成果&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;下面是优化前后的数据对比，丢失率从最高60%下降到了0%, CPU消耗从最高占用6个核下降到了1个核。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33500837520938026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG758db34MSm18INV1asyuZ8ibtU6dWAqiab7bibvjymxF20rc5vF23E5fMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了探究抓包功能对MySQL性能损耗，我们用Sysbench做了一个性能对比测试。&lt;/span&gt;&lt;span&gt;从下面的结果数据可以看出功能对MySQL的TPS、QPS和响应时间99线指标最高大约有6%的损耗。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;284&quot; data-ratio=&quot;0.49140625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVX8W0QIibjv4iccTFOEiaZyG7fZv04PKXKj2J01EUibKWn4MYcNou6MSNmepvemYNZhYu7h6bia00SBzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5 未来规划&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;虽然我们对抓包方案进行了各种优化，但对于一些延迟敏感的业务来说性能损耗还是偏大，而且该方案对一些特殊场景支持较差：如TCP协议层发生丢包、重传、乱序时，MySQL协议层使用压缩、传输大SQL时。而业界普遍采用了直接改造MySQL内核的方式来输出全量SQL，同时也支持输出更多的指标数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，数据库内核团队也完成了该方案开发，正在线上灰度替换抓包方案中。另外，对于线上全量SQL端到端丢失率指标的缺失，我们也将陆续进行补齐。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文作者&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;粟含，来自于美团基础研发平台/基础技术部/数据库技术中心。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;----------  END  ----------&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-source=&quot;bj.96weixin.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;美团基础技术部-数据库技术中心诚招高级、资深技术专家，Base上海、北京。美团关系数据库规模大，每年快速的增长，每天承载数千亿的访问流量。在这里可以体验高并发、高可用、高可扩展性的业务挑战，可以紧跟并开拓业界前沿技术，体会到技术进步带来的生产力提升，欢迎投递简历至：&lt;/span&gt;&lt;span&gt;edp.itu.zhaopin@meituan.com&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;也许你还想看&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  | &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651768225&amp;amp;idx=1&amp;amp;sn=9d31b08486cef404013972ebc809de3c&amp;amp;chksm=bd121cec8a6595fa2062a4e129cdf216711ef39e12535d67cd8dfe990ed09f9fe95a3e312245&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库异常智能分析与诊断&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651768225&amp;amp;idx=1&amp;amp;sn=9d31b08486cef404013972ebc809de3c&amp;amp;chksm=bd121cec8a6595fa2062a4e129cdf216711ef39e12535d67cd8dfe990ed09f9fe95a3e312245&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数据库异常智能分析与诊断&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数据库异常智能分析与诊断&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt;&lt;/span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651767904&amp;amp;idx=1&amp;amp;sn=5cb1c15d7811c7e7225ac32b56026f99&amp;amp;chksm=bd121d2d8a65943b25af8e18072d5e92b831dd78cafd642c257d06815a87a95327abb9ac764e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于代价的慢查询优化建议&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于代价的慢查询优化建议&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;  |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651751923&amp;amp;idx=1&amp;amp;sn=3908b323818b299c13cb19da24d2eb91&amp;amp;chksm=bd125cbe8a65d5a89a72e9b39e04da8ad78a609ed886c7f70dfcaebfb78aebd63f5701cc7787&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团MySQL数据库巡检系统的设计与应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团MySQL数据库巡检系统的设计与应用&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765958&amp;amp;idx=1&amp;amp;sn=8201546812e5a95a2bee9dffc6d12f00&amp;amp;chksm=bd12658b8a65ec9de2f5be1e96796dfb3c8f1a374d4b7bd91266072f557caf8118d4ddb72b07&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765981&amp;amp;idx=1&amp;amp;sn=c2dd86f15dee2cbbc89e27677d985060&amp;amp;chksm=bd1265908a65ec86d4d08f7600d1518b61c90f6453074f9b308c96861c045712280a73751c73&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;算‍法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765982&amp;amp;idx=1&amp;amp;sn=231b41f653ac7959f3e3b8213dcec2b0&amp;amp;chksm=bd1265938a65ec85630c546169444d56377bc2f11401d251da7ca50e5d07e353aa01580c7216&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后‍端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;后端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765964&amp;amp;idx=1&amp;amp;sn=ab6d8db147234fe57f27dd46eec40fef&amp;amp;chksm=bd1265818a65ec9749246dd1a2eb3bf7798772cc4d5b4283b15eae2f80bc6db63a1471a9e61e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;数‍据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765965&amp;amp;idx=1&amp;amp;sn=37e0c56c8b080146ce5249243bfd84d8&amp;amp;chksm=bd1265808a65ec96d3a2b2c87c6e27c910d49cb6b149970fb2db8bf88045a0a85fed2e6a0b84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;安‍全&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;安全&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765972&amp;amp;idx=1&amp;amp;sn=afe02ec92762c1ce18740d03324c4ac3&amp;amp;chksm=bd1265998a65ec8f10d5f58d0f3681ddfc5325137218e568e1cda3a50e427749edb5c6a7dcf5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;And‍roid&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Android&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765973&amp;amp;idx=1&amp;amp;sn=32a23bf1d278dda0398f993ab60a697e&amp;amp;chksm=bd1265988a65ec8e630ef4d24b4946ab6bd7e66702c1d712481cf3c471468a059c470a14c30d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;iO‍S&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;iOS&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765963&amp;amp;idx=1&amp;amp;sn=a3de9ef267d07d94118c1611776a4b28&amp;amp;chksm=bd1265868a65ec906592d25ad65f2a8516338d07ec3217059e6975fc131fc0107d66a8cd2612&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运‍维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651765974&amp;amp;idx=1&amp;amp;sn=763c1e37d04acffd0142a2852ecfb000&amp;amp;chksm=bd12659b8a65ec8dfcfeb2028ef287fae7c38f134a665375ba420556ce5d2e4cf398147bd12e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;测‍试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NjQ5MTI5OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVGibnsaEib3aNlqF0tOrA2RGEmNSbia2nnohE4Tpf95UyTiaSjDVbHRfY8WNBeTuLLTaVdSckkNyEx1Q/0?wx_fmt=png&quot; data-nickname=&quot;美团技术团队&quot; data-alias=&quot;meituantech&quot; data-signature=&quot;10000+工程师，如何支撑中国领先的生活服务电子商务平台？数亿消费者、数百万商户、2000多个行业、几千亿交易额背后是哪些技术在支撑？这里是美团、大众点评、美团外卖、美团配送、美团优选等技术团队的对外窗口。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2577b43a53aaef5003111fe1cc17d3b5</guid>
<title>Go netpoll大解析</title>
<link>https://toutiao.io/k/6ercbix</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wxicPoYsPLia7RuF7m5HYXeByuJbX9ugsIwQ5FbF51DERicDuwutIrUYXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片拍摄于2022年4月3日 杭州&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;开篇&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n68&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;之前简单看过一点go原生netpoll，没注意太多细节。&lt;/span&gt;&lt;span&gt;最近从头到尾看了一遍，特写篇文章记录下。&lt;/span&gt;&lt;span&gt;文章很长，请耐心看完，一定有所收获。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n972&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 md-src-pos=&quot;261..277&quot; data-darkmode-bgcolor-16499522379759=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16499522379759=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16499522379759=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16499522379759=&quot;#fff|rgb(0, 0, 0)&quot; data-style=&quot;margin-top: 1em; margin-bottom: 16px; font-weight: bold; line-height: 1.4; font-size: 17px; color: rgb(0, 0, 0); font-family: Helvetica, Arial, freesans, sans-serif; text-align: start; white-space: normal; background-color: rgb(255, 255, 255);&quot; class=&quot;js_darkmode__29&quot;&gt;&lt;span&gt;内核空间和用户空间&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在linux中，经常能看到两个词语:User space(用户空间)和Kernel space (内核空间)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;简单&lt;/span&gt;&lt;span&gt;地&lt;span&gt;说， Kernel space是linux内核运行的空间，User space是用户程序运行的空间。&lt;/span&gt;&lt;span&gt;它们之间是相互隔离的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;现代操作系统都是采用虚拟存储器。那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了保证用户进程不能直接操作内核，保证内核的安全，系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。空间分配如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n129&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5468227424749164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9waNV3NicYA0Duia7CkaEeAn6VyPzebksdc7FmneW6Luzyyia8lrwIJRgiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Kernel space可以调用系统的一切资源。User space 不能直接调用系统资源，在 Linux系统中，所有的系统资源管理都是在内核空间中完成的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;比如读写磁盘文件、分配回收内存、从网络接口读写数据等等。应用程序无法直接进行这样的操作，但是用户程序可以通过内核提供的接口来完成这样的任务。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37386363636363634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wWBYZwOAkwzMMjTT7M7SdSDYX6bmrDuRWUibdut64XzybicVkSpNVzkkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;像下面这样，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n973&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1733203505355404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wgIfhu97Rn9L0qJ5eIGia6eD5yo4ELic2nTt0yeicWgZU2VAKZkWI2QGqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2054&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;应用程序要读取磁盘上的一个文件，它可以向内核发起一个 “系统调用” 告诉内核：”我要读取磁盘上的某某文件”。其实就是通过一个特殊的指令让进程从用户态进入到内核态。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在内核空间中，CPU 可以执行任何的指令，当然也包括从磁盘上读取数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体过程是先把数据读取到内核空间中，然后再把数据拷贝到用户空间并从内核态切换到用户态。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;此时应用程序已经从系统调用中返回并且拿到了想要的数据，继续往下执行用户空间执行逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n975&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这样的话，一旦涉及到对I/O的处理，就必然会涉及到在用户态和内核态之间来回切换。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n148&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;io模型&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;网上有太多关于I/O模型的文章，看着看着有可能就跑偏了，所以我还是从 &amp;lt;&amp;lt;UNIX 网络编程&amp;gt;&amp;gt; 中总结的5中I/O模型说起吧。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Unix可用的5种I/O模型。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n161&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n164&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;阻塞I/O&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;非阻塞I/O&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n168&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;I/O复用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;信号驱动式I/O(SIGIO)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;异步I/O(POSIX的aio_系列函数)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n195&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;阻塞I/O&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://cdn.syst.top/截屏2022-04-09 上午10.29.31.png&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4365904365904366&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wHmh12ibZK222LGMKW2vX02EcVbhgayaDMj0p8yv4SZH08KVHqQK1UHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n190&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;阻塞式I/O下，进程调用recvfrom，直到数据到达且被复制到应用程序的缓冲区中或者发生错误才返回，在整个过程进程都是被阻塞的&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n200&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;非阻塞I/O&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p cid=&quot;n213&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5110619469026548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wAmJnn1mZwUV0tlH7XkWSjptQF3hbFkCYnlhXib1ibroiaoQ9d6ZPYT41Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从图中可以看出，前三次调用recvfrom中没有数据可返回，因此内核转而立即返回一个EWOULDBLOCK错误。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第四次调用recvfrom时已有一个数据报准备好，它被复制到应用程序缓冲区，于是recvfrom成功返回。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n207&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当一个应用程序像这样对一个非阻塞描述符循环调用recvfrom时，我们通常称为轮询(polling)，持续轮询内核，以这种方式查看某个操作是否就绪。&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n216&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n216&quot; mdtype=&quot;heading&quot;&gt;&lt;strong&gt;&lt;span&gt;I/O多路复用&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p cid=&quot;n217&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4437984496124031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wbPHkFh3bCp7OxLmDFSDluvYR863tHnBacvmzBLGvHXhfXKSkhaEiaXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;有了I/O多路复用(I/O multiplexing)，我们就可以调用 select 或者 poll，阻塞在这两个系统调用中的某一个之上，而不是阻塞在真正的I/O系统调用上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上面这句话难理解是吧。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;说白了这里指的是，在第一步中，我们只是阻塞在select调用上，直到数据报套接字变为可读，返回可读条件，这里并没有发生I/O事件，所以说这一步，并没有阻塞在真正的I/O系统调用上。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n223&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n227&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其他两种就不过多介绍了。&lt;/span&gt;还有一点，我们会经常提到同步I/O和异步I/O。&lt;/p&gt;&lt;p cid=&quot;n227&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n237&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;POSIX 把这两种术语定义如下:&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n250&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;基于上面的定义，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n252&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4603174603174603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wRkCbzDTWL2UIRNKEcaUfYd8yqAUQBoAowlzQoabFwN8U96hh6aDqUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;异步I/O的关键在于第二步的recrfrom是否会阻塞住用户进程，如果不阻塞，那它就是异步I/O。从上面汇总图中可以看出，只有异步I/O满足POSIX中对异步I/O的定义。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n229&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n260&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n260&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go netpoller&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go netpoller 底层就是对I/O多路复用的封装。不同平台对I/O多路复用有不同的实现方式。比如Linux的select、poll和epoll。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n277&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在MacOS则是kqueue,而Windows是基于异步I/O实现的icop......，基于这些背景，Go针对不同的平台调用实现了多版本的netpoller。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n278&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5406162464985994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wAibh5K9hhEhiaGZcDlkAZIQo8Ba6hMA43eo597QuF2TBPq4zRYo0IHqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n819&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n819&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;下面我们通过一个demo开始讲解。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n292&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9174757281553398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wicAN3Qj0vBuwXSrpV4PQdjYib8c34seqMhtvEuPJGwKNL16uGBeJibxHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;824&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;很简单一个demo，开启一个tcp服务。然后每来一个连接，就启动一个g去处理连接。处理完毕，关闭连接。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n288&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n832&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且我们使用的是同步的模式去编写异步的逻辑，一个连接对应一个g处理，极其简单和易于理解。go标准库中的http.server也是这么干的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n834&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1057007125890737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w3nMynhgTw39adF3SGsrMy433Iiae5oNXCUhrw2ibjoalTcrT5C0bFafw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1684&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;针对上面的tcp服务demo，我们需要关注这段代码底层都发生了什么。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n836&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n282&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上面代码中主要涉及底层的一些结构。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n264&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6517073170731708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wKzW3h9uM7Xnuqd2lRHaqAP3Q5gg3YDM1T1SCicicasoRXh3KibLVwibuDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2050&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n275&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n275&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;先简单解释一波。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n294&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n297&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;TCPListener:我们开启的是一个TCP服务，那当然就是TCP服务的网络监听器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n298&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netFD:网络描述符。Go中所有的网络操作都是以netFD实现的，它和底层FD做绑定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n301&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;FD:文件描述符。net和os包把这个类型作为一个网络连接或者操作系统文件。其中里面一个字段Sysfd就是具体文件描述符值。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n304&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollDesc:I/O轮询器。说白了它就是底层事件驱动的封装。其中的runtimeCtx是一个指针类型，具体指向runtime/netpoll 中的pollDesc.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当然图上面结构字段都是阉割版的，但是不影响我们这篇文章。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n99&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n320&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;还有一个问题，为什么结构上需要一层一层嵌入呢？&lt;/span&gt;我的理解是每下一层都是更加抽象的一层。它是可以作为上一层具体的一种应用体现。&lt;/p&gt;&lt;p cid=&quot;n320&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;是不是跟没说一样？哈哈。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n326&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n328&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;举例，比如这里的netFD表示网络描述符。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n328&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n844&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;它的上一层可以是用于TCP的网络监听器TCPListener，那么对应的接口我们能想到的有两个Accept以及close。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n844&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n840&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于Accept 动作，一定是返回一个连接类型 Conn ，针对这个连接，它本身也存在一个自己的netFD，那么可想而知一定会有 Write和Read两个操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n840&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n848&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而所有的网络操作都是以netFD实现的。这样，netFD在这里就有两种不&lt;/span&gt;&lt;span&gt;同&lt;/span&gt;&lt;span&gt;&lt;span&gt;的上层应用体现了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n850&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n330&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;好了,我们需要搞清楚几件事：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n332&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n337&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一般我们用其他语言写一个tcp服务，必然会写这几步：socket-&amp;gt;bind-&amp;gt;listen，但是Go就一个Listen，那就意味着底层包装了这些操作。它是在哪一步完成的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n341&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go是在什么时候初始化netpoll的，比如linux下初始化epoll实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n344&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当对应fd没有可读或者可写的IO事件而对应被挂起的g，是如何知道fd上的I/O事件已ready，又是如何唤醒对应的g的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n852&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n977&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n977&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Listen解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n856&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n856&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;带着这些问题，我们接着看流程。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n363&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.116279069767442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wGmjypxAy5LSibWZgw48GtPbdB5NNP8ke9qChsxpwPQnfvt4KlKicY72w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1978&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图已经把当你调用Listen操作的完整流程全部罗列出来了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;就像我上面列出的结构关系一样，从结构层次来说，每调用下一层，都是为了创建并获取下一层的依赖，因为内部的高度抽象与封装，才使得使用者往往只需调用极少数简单的API接口。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n353&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;现在我们已经知道事例代码涉及到的结构以及对应流程了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n359&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在传统印象中，创建一个网络服务。需要经过:创建一个socket、bind 、listen这基本的三大步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n377&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;前面我们说过，Go中所有的网络操作都是以netFD实现的。&lt;/span&gt;go也是在这一层封装这三大步的。所以我们直接从netFD逻辑开始说。&lt;/p&gt;&lt;p cid=&quot;n369&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n381&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图是在调用socket函数这一步返回的netFD，可想而&lt;/span&gt;&lt;span&gt;知&lt;/span&gt;&lt;span&gt;&lt;span&gt;核心逻辑都在这里面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n387&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7553879310344828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9whysJzw3D4Xpf5hNIT6iaicJaIzX91JHyZKK3AWjhwpd9ibDz8vQ1fic3Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n383&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n383&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们可以把这个函数核心点看成三步。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n392&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n395&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;调用sysSocket函数创建一个socket，返回一个文件描述符(file descriptor)，简称fd下文。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n399&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过sysSocket返回的fd，调用newFD函数创建一个新的netFD。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n396&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;调用netFD自身的方法listenStream函数，做初始化动作，具体详情下面再说。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n385&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在sysSocket函数中，首先会通过socketFunc来创建一个socket，通过层层查看，最终是通过system call来完成这一步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n858&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当获取到对应fd时，会通过syscall.SetNonblock函数把当前这个fd设置成非阻塞模式，这样当这个Listener调用accept函数就不会被阻塞了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n371&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8641655886157826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wxWEklHiafp3gvmnMdtaDMRscY2dL4kUqkQDiba0QNRkziaXvUsokW7Mfw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1546&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第二步，通过第一步创建socket拿到的fd，创建一个新的netFD。这段代码没啥好解释的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n365&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n406&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;第三步，也就是最核心的一步，调用netFD自身的listenStream方法。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n408&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4811218985976268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w4OOl2BOSSgzYt2GoR4HFZEib0hKzscVevdLiaRFpmRYSBjBTxdtTpwEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n434&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n434&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;listenStream里面也有核心的三步:&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n355&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们主要看fd.init逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n445&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.308970099667774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wBWPDic6Ju4e4zgj4jicYFtffR4dBgmaJ3qfmSayRao7q9JzjO45MpVfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1204&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n347&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n347&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终是调用的pollDesc的init函数。这个函数有重要的两步。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;更具体的流程，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n860&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n453&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先serviceInit.Do 保证当中的runtime_pollServerInit只会初始化一次。这很好理解，类似epoll实例全局初始化一次即可。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n453&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n531&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们看下runtime_pollServerInit函数，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n457&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20170940170940171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wITHlr01PfAiacyYuFicBOJLSaIt3fmiazSiasico8Zael0r5a9k3sspkFoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这是咋回事，和我们平常看过的函数长的不太一样，执行体呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n322&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n864&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实这个函数是通过 go:linkname连接到具体实现的函数poll_runtime_pollServerInit。找起来也很简单，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5122699386503068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wNCQiasqFFicwEn8rZicIFXXyEY1DwcafxnvRVAUj3HmfEAleSolSvb0QA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1956&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;看到poll_runtime_pollServerInit()上面的 //go:linkname xxx 了吗？不了解的可以看看Go官方文档`go:linkname。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n533&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n866&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以最终runtime_pollServerInit调用的是，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n468&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431034482758621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9w9qPJtWicugYLTmePUjFAiaKrGDdt56iaeb8UzDSWyegHKpibxsfWegAiapQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;通过调用poll_runtime_pollServerInit-&amp;gt;netpollGenericInit，netpollGenericInit里调用netpollinit函数完成初始化。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n470&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;注意。这里的netpollinit，是基于当前系统来调用对应系统的netpollinit函数的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n868&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n539&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;什么意思？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n539&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n537&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;文章开始有提到Go底层网络模型是基于I/O多路复用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n537&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不同平台对I/O多路复用有不同的实现方式。比如Linux的epoll，MacOS的kqueue,而Windows的icop。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n870&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n473&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以对应，如果你当前是Linux，那么最终调用的是src/runtime/netpoll_epoll.go下的 netpollinit函数，然后会创建一个epoll实例，并把值赋给epfd，作为整个runtime中唯一的event-loop使用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n477&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0012674271229405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wsNMMaTMUW8NbUs4YibxuawicMyiafvOjmIETKlQT2hll0OJrNY3xyxJCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n475&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其他的，比如MacOS下的kqueue,也存在netpollinit函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n485&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8964285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wefNcY5ib64cGmmebicZlWdyH6NETQwuFSicCHwjnORXXStELEOVaP9iaiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n491&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n491&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;以及Windows下的icop。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n493&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21170610211706103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wetnrTHpdlQ0AsMbPonHQH2Q9C84BqkLDcbTsoQo95XCF5AlzHLreCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n495&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n495&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们回到pollDesc.init 操作，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n497&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4432576769025367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wVM52ySpR2E6LxCt5pAdLyRUnu4ib6aDcRD4rFNL4maBMQUDHEe7CHEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;完成第一步初始化操作后，第二步就是调用runtime_pollOpen。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n545&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;老套路通过//go:linkname找到对应的实现，实际上是调用的poll_runtime_pollOpen函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n873&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个函数里面再调用netpollopen函数，netpollopen函数和上面的netpollinit函数一样，不同平台都有它的实现。linux平台下，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n547&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7986754966887417&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wuKIiasnt9WJicDQWSmOiaVIX0gJGOWZWYNBDu8k8stHLcWahTfTWAFtzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;755&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollopen函数，首先会通过指针把pollDesc保存到epollevent的一个字节数组data里。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n549&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;然后会把传递进来的fd(刚才初始化完成的那个Listener监听器)注册到epoll当中，且通过指定 _EPOLLET将epoll设置为边缘触发(Edge Triggered)模式。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果让我用一句话来说明epoll水平触发和边缘触发的区别，那就是,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n553&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;水平触发下epoll_wait在文件描述符没有读写完会一直触发，而边缘触发只在是在变成可读写时触发一次。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n875&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n881&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;到这里整个Listen 动作也就结束了，然后层层返回。最终到业务返回的是一个 Listener，按照本篇的例子，本质上还是一个TCPListener。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n982&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n988&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Accept解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n562&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着当我们调用listen.Accept的时候，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n566&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2873711340206186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wuzZ7ibHmTXQ85RBWPWHb05PRgLOffHibzzQZF7gASQ4zCgRwERHwziaMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1552&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终netFD的accept函数。netFD中通过调用fd.pfd(实际上是FD)的Accept函数获取到socket fd，通过这个fd创建新的netFD表示这是一个新连接的fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;并且会和Listen时一样调用netFD.init做初始化，因为当前epoll已经初始化一次了，所以这次只是把这个新连接的fd也加入到epoll事件队列当中，用于监听conn fd的读写I/O事件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n564&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n580&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体我们看FD.Accept是咋么执行的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n578&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8002560819462228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wC7zZxKcKibxVaPHqLH0kaZPAicVGibiaa5ib84wOjqoIibcZLic3pj4zCIYWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先是一个死循环for，死循环里调用了accept函数，本质上通过systcall调用系统accept接收新连接。当有新连接时，最终返回一个文件描述符fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当accept获取到一个fd，会调用systcall.SetNonblock把这个fd设置成非阻塞的I/O。然后返回这个连接fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n608&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因为我们在Listen的时候已经把对应的Listener fd设置成非阻塞I/O了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以调用accept这一步是不会阻塞的。只是下面会进行判断，根据判断 err ==syscall.EAGAIN 来调用fd.pd.waitRead阻塞住用户程序。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n612&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n885&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;直到I/O事件ready，被阻塞在fd.pd.waitRead的代码会继续执行continue，重新一轮的accept, 此时对应fd上的 I/O已然ready，最终就返回一个conn类型的fd。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n885&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n620&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我刚才说的调用fd.pd.waitRead会被阻塞，直到对应I/O事件ready。我们来看它具体逻辑，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n887&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7473997028231798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wSibHqsRH3GS2AjFIBBxejiaU7usU1eKMRiaWaHibK5RKCMsgJ1YbqlfcJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n889&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n894&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最终到runtime_pollWait函数，老套路了，我们找到具体的实现函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n624&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.487907465825447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wv5OhyWFImIYHflbAeIl2wHFDMsPOvIga1xSruBYFQZdHXfO5mF3Emw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;poll_runtime_pollWait 里的for循环就是为了等待对应的I/O ready才会返回，否则的话一直调用netpollblock函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollDesc结构我们之前提到，它就是底层事件驱动的封装。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中有两个重要字段: rg和wg，都是指针类型，实际这两个字段存储的就是Go底层的g，更具体点是等待i/O ready的g。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n630&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;比如当创建完一个Listener，调用Accept开始接收客户端连接。如果没有对应的请求，那么最终会把g放入到pollDesc的rg。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n648&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 如果是一个conn类型的fd等待可写I/O，那么会把g放入到pollDesc的wg中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体就是根据mode来判断当前是什么类型的等待事件。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n898&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n654&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollblock里也有一个for循环，如果已经ready了，那么直接返回给上一层就行了。否则的话，设置gpp为等待状态pdWait。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n654&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n900&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里还有一点atomic.Loaduintptr(gpp)，这是为了防止异常情况下出现死循环问题。比如如果gpp的值不是pdReady也不是0，那么意味着值是pdWait，那就成了double wait，必然导致死循环。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n900&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n668&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果gpp未ready且成功设置成pdWait，正常情况下，最终会调用gopark，会挂起g且把对应的g放入到pollDesc 的wg|rg 当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n668&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n671&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;进入gopark。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n675&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7451171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wx1ibqPQBzA0pdB9jhzCtmS4qkl6S2uEw0qWWf1EBerB1XjdzI467SlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n657&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n657&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这一块代码不是很难，基本的字段打了备注，核心还是要看park_m这个函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n683&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.149802890932983&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wJsecNIFAK4XwttEfjBiaVtp2aImKicoGrhz3ba8DzDtGPiceSe4kKdAmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在park_m函数中，首先会通过CAS并发安全&lt;/span&gt;&lt;span&gt;地&lt;span&gt;修改g的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;然后调用dropg解绑g和m的关系，也就是m把当前运行的g置空，g把当前绑定的m置空。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n685&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n902&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;后面的代码是根据当前场景来解释的。我们知道此时m的waitunlockf 其实就是netpollblockcommit。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n681&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5690045248868778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wto7WI0CJIzwf45iaaqHjXQq4utRNYfcymdWsP3iaCVZOrAAhNSTCGmQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1768&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netpollblockcommit会把当前已经是_Gwaiting状态下的g赋值给gpp。如果赋值成功，netpollWaiters会加1。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个全局变量表示当前等待I/O事件ready的g数量，调度器再进行调度的时候可以根据此变量判断是否存在等待I/O事件的g。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n677&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;如果此时当前gpp下的fd的I/O已经ready。那么gpp的状态必然已不是pdWait，赋值失败。返回false。&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;回到park_m，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;如果netpollblockcommit返回true，那么直接触发新一轮的调度。&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n703&quot; mdtype=&quot;paragraph&quot;&gt;如果netpollblockcommit返回false，意味着当前g已经不需要被挂起了，所以需要把状态调整为_Grunnable，然后安排g还是在当前m上执行。&lt;/p&gt;&lt;p cid=&quot;n706&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n716&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当I/O事件ready，会一层层返回，获取到新的socket fd，创建conn类型的netFD，初始化netFD(其实就是把这个conn类型的fd也加入epoll事件队列，用于监听)，最终最上游会获取到一个Conn类型的网络连接，就可以基于这个连接做Read、Write等操作了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n710&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5866666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wElzssv5OTarKu28NceB3HsIQ0xOOnYV8F04O67P2XQrwg2Khpg8qPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n652&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5 cid=&quot;n997&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;Read/Write 解析&lt;/span&gt;&lt;/h5&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;后续的Conn.Read 和 Conn.Write 原理和Accept 类似。&lt;/p&gt;&lt;p cid=&quot;n723&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5450819672131149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wibtZhbS8d7NGBWPJr5Xsv0hoO3l9WsO9yJOn9tu6MBvSnia7htvibScMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1952&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;上图给出了Write操作，可以看出核心部分和accept操作时一样的。对于Read操作，就不再重复了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n644&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从上面的分析中我们已经知道，Go的netpoller底层通过对epoll|kqueue|iocp的封装，使用同步的编程手法达到异步执行的效果，无论是一个Listener还是一个Conn，它的核心都是netFD。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;netFD又和底层的PollDesc结构绑定，当读写出现EAGAIN错误时，会通过调用gopark把当前g给park住，同时会将当前的g存储到对应netFD的PollDesc的wg|rg当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;直到这个netFD再次发生对应的读写事件，才会重新把当前g放入到调度系统进行调度。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n741&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n745&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;还有最后一个问题，我们咋么知道哪些FD发生读写事件了？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1000&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n1002&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n1002&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;I/O已就绪&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n751&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;答案就是netpoll()函数。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n754&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7812828601472135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9waqkqX9JFCY0NjFqeicBQeJCyx4SU1I3dCGwJGgRqsvdgdBsfLvln2VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;此函数会调用epollwait函数，本质上就是Linux中epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n758&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在之前调用epoll_ctl，注册fd对应的I/O事件到epoll实例当中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这里的epoll_wait实际上会阻塞监听epoll实例上所有fd的I/O事件，通过传入的第二个参数(用户内存地址events)。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n766&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当有对应的I/O事件到来时，内核就会把发生事件对应的fd复制到这块用户内存地址(events)，&lt;/span&gt;解除阻塞。&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;然后我们遍历这个events，去获取到对应的事件类型、pollDesc，再通过调用netpollready函数获取到pollDesc对应被gopark的g，最终把这些g加入到一个链表当中，返回。&lt;/p&gt;&lt;p cid=&quot;n904&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n771&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;也就是说只要调用这个函数，我们就能获取到之前因为I/O未ready而被gopark挂起，现在I/O已ready的g链表了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n771&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n775&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;我们可以找到四个调用处，如下，&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n777&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n780&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;startTheWorldWithSema&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n781&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;findrunnable&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n786&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;pollWork&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n791&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;sysmon&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这和go的调度有关，当然这不是本章的内容。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当这四种方法调用netpoll函数得到一个可运行的g链表时，都会调用同一个函数injectglist。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n727&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;这个函数本质上就是把链表中所有g的状态从Gwaiting-&amp;gt;Grunnable。然后按照策略，把这些g推送到本地处理器p或者全家运行队列中等待被调度器执行。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n809&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7212681638044913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lkVfNnnUQnkzIGzdEuIH9pic2m82LdR9wqRjiagiaiaYPCL6DZ69thsibhjicqpGk3r8BlSX3LNJvpd6iclIbImYTibsow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n803&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n803&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;到这里，整个流程就已经剖析完毕。不能再写了。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 cid=&quot;n607&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Go netpoller通过在底层对epoll/kqueue/iocp这些不同平台下对I/O多路复用实现的封装，加上自带的goroutine(上文我一直用g表达)，从而实现了使用同步编程模式达到异步执行的效果。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;代码很长，涉及到的模块也很多，整体看完代码还是非常爽的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n908&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;另外早有人提出，由于一个连接对应一个goroutine，瞬时并发场景下，大量的goroutine会被不断创建。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n917&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;原生netpoller无法提供足够的性能和控制力，如无法感知连接状态、连接数量多导致利用率低、无法控制协程数量等。针对这些问题，可以参考下gnet以及 KiteX 这两个项目的网络模型。&lt;/p&gt;&lt;p cid=&quot;n919&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h4 cid=&quot;n101&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot; cid=&quot;n937&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n939&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;http://man7.org/linux/man-pages/man7/epoll.7.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n965&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&amp;lt;UNIX网络编程:卷1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n944&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/panjf2000/gnet&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n953&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://strikefreedom.top/go-netpoll-io-multiplexing-reactor&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n956&quot; mdtype=&quot;paragraph&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;amp;mid=2247485756&amp;amp;idx=1&amp;amp;sn=4d2712e4bfb9be27a790fa15159a7be1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://mp.weixin.qq.com/s/wSaJYg-HqnYY4SdLA2Zzaw&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n959&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://ninokop.github.io/2018/02/18/go-net/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/cloudwego/kitex&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section data-darkmode-color-16485725445993=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16485725445993=&quot;#fff|rgb(0,0,0)&quot;&gt;&lt;span&gt;往期推荐&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>