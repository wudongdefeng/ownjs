<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9f1bc383f94dbc5f5b6e5cac9fa06e0d</guid>
<title>新来个技术总监，仅花 2 小时，撸出一个多线程永动任务，看完直接跪了，真牛逼</title>
<link>https://toutiao.io/k/6u3q7ke</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;今天教大家撸一个 Java 的多线程永动任务，&lt;/span&gt;&lt;strong&gt;这个示例的原型是公司自研的多线程异步任务项目&lt;/strong&gt;&lt;span&gt;，我把里面涉及到多线程的代码抽离出来，然后进行一定的改造。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面涉及的知识点非常多，特别适合有&lt;strong&gt;一定工作经验&lt;/strong&gt;的同学学习，或者可以直接拿到项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章结构非常简单：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5484261501210653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFO4ibj0RiaKXib9VLSJxTaWCGyibRQyudY2hg9UV61hvpUE2KrlsEX7mvAVn4KMqyyqn0evPn8gZPHNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 功能说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做这个多线程异步任务，主要是因为我们有很多永动的异步任务，什么是永动呢？就是&lt;strong&gt;任务跑起来后，需要一直跑下去。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如消息 Push 任务，因为一直有消息过来，所以需要一直去消费 DB 中的未推送消息，就需要整一个 Push 的永动异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的需求其实不难，简单总结一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;能同时执行多个永动的异步任务&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个异步任务，支持开&lt;strong&gt;多个线程&lt;/strong&gt;去消费这个任务的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持永动异步任务的&lt;strong&gt;优雅关闭&lt;/strong&gt;，即关闭后，需要把所有的数据消费完毕后，再关闭。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成上面的需求，需要注意几个点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个&lt;strong&gt;永动任务&lt;/strong&gt;，可以开一个线程去执行；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个&lt;strong&gt;子任务&lt;/strong&gt;，因为需要支持并发，需要用线程池控制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;永动任务的关闭，需要通知子任务的并发线程，并&lt;strong&gt;支持永动任务和并发子任务的优雅关闭&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多线程任务示例&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 线程池&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于子任务，需要支持并发，如果每个并发都开一个线程，用完就关闭，对资源消耗太大，所以引入线程池：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskProcessUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个任务，都有自己单独的线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, ExecutorService&amp;gt; executors = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 初始化一个线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(String poolName, &lt;span&gt;int&lt;/span&gt; poolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(poolSize, poolSize,&lt;br/&gt;                &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(&lt;span&gt;&quot;Pool-&quot;&lt;/span&gt; + poolName).setDaemon(&lt;span&gt;false&lt;/span&gt;).build(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;getOrInitExecutors&lt;/span&gt;&lt;span&gt;(String poolName,&lt;span&gt;int&lt;/span&gt; poolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = executors.get(poolName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == executorService) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (TaskProcessUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                executorService = executors.get(poolName);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == executorService) {&lt;br/&gt;                    executorService = init(poolName, poolSize);&lt;br/&gt;                    executors.put(poolName, executorService);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; executorService;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 回收线程资源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;releaseExecutors&lt;/span&gt;&lt;span&gt;(String poolName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = executors.remove(poolName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (executorService != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            executorService.shutdown();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个线程池的工具类，这里初始化线程池和回收线程资源很简单，我们主要讨论获取线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取线程池可能会存在并发情况，所以需要加一个 synchronized 锁，然后锁住后，需要对 executorService 进行二次判空校验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 单个任务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好讲解单个任务的实现方式，我们的任务主要就是把 Cat 的数据打印出来，Cat 定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String catName;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Cat &lt;span&gt;setCatName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.catName = name;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个任务主要包括以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;获取永动任务数据&lt;/strong&gt;：这里一般都是扫描 DB，我直接就简单用 queryData() 代替。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多线程执行任务&lt;/strong&gt;：需要把数据拆分成 4 份，然后分别由多线程并发执行，这里可以通过线程池支持；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;永动任务优雅停机&lt;/strong&gt;：当外面通知任务需要停机，需要执行完剩余任务数据，并回收线程资源，退出任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;永动执行&lt;/strong&gt;：如果未收到停机命令，任务需要一直执行下去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildTask&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; POOL_SIZE = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;// 线程池大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SPLIT_SIZE = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;// 数据拆分大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String taskName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 接收jvm关闭信号，实现优雅停机&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; terminal = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ChildTask&lt;/span&gt;&lt;span&gt;(String taskName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.taskName = taskName;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 程序执行入口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doExecute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            System.out.println(taskName + &lt;span&gt;&quot;:Cycle-&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;-Begin&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;// 获取数据&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Cat&amp;gt; datas = queryData();&lt;br/&gt;            &lt;span&gt;// 处理数据&lt;/span&gt;&lt;br/&gt;            taskExecute(datas);&lt;br/&gt;            System.out.println(taskName + &lt;span&gt;&quot;:Cycle-&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;-End&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (terminal) {&lt;br/&gt;                &lt;span&gt;// 只有应用关闭，才会走到这里，用于实现优雅的下线&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 回收线程池资源&lt;/span&gt;&lt;br/&gt;        TaskProcessUtil.releaseExecutors(taskName);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 优雅停机&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;terminal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 关机&lt;/span&gt;&lt;br/&gt;        terminal = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(taskName + &lt;span&gt;&quot; shut down&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doProcessData&lt;/span&gt;&lt;span&gt;(List&amp;lt;Cat&amp;gt; datas, CountDownLatch latch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Cat cat : datas) {&lt;br/&gt;                System.out.println(taskName + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + cat.toString() + &lt;span&gt;&quot;,ThreadName:&quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000L&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.out.println(e.getStackTrace());&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (latch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                latch.countDown();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理单个任务数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;taskExecute&lt;/span&gt;&lt;span&gt;(List&amp;lt;Cat&amp;gt; sourceDatas)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(sourceDatas)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 将数据拆成4份&lt;/span&gt;&lt;br/&gt;        List&amp;lt;List&amp;lt;Cat&amp;gt;&amp;gt; splitDatas = Lists.partition(sourceDatas, SPLIT_SIZE);&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; CountDownLatch latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(splitDatas.size());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 并发处理拆分的数据，共用一个线程池&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; List&amp;lt;Cat&amp;gt; datas : splitDatas) {&lt;br/&gt;            ExecutorService executorService = TaskProcessUtil.getOrInitExecutors(taskName, POOL_SIZE);&lt;br/&gt;            executorService.submit(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    doProcessData(datas, latch);&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            latch.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.out.println(e.getStackTrace());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取永动任务数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Cat&amp;gt; &lt;span&gt;queryData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Cat&amp;gt; datas = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) {&lt;br/&gt;            datas.add(&lt;span&gt;new&lt;/span&gt; Cat().setCatName(&lt;span&gt;&quot;罗小黑&quot;&lt;/span&gt; + i));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; datas;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单解释一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;queryData&lt;/strong&gt;：用于获取数据，实际应用中其实是需要把 queryData 定为抽象方法，然后由各个任务实现自己的方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;doProcessData&lt;/strong&gt;：数据处理逻辑，实际应用中其实是需要把 doProcessData 定为抽象方法，然后由各个任务实现自己的方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;taskExecute&lt;/strong&gt;：将数据拆分成 4 份，获取该任务的线程池，并交给线程池并发执行，然后通过 latch.await() 阻塞。当这 4 份数据都执行成功后，阻塞结束，该方法才返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;terminal&lt;/strong&gt;：仅用于接受停机命令，这里该变量定义为 volatile，所以多线程内存可见；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;doExecute&lt;/strong&gt;：程序执行入口，封装了每个任务执行的流程，当 terminal=true 时，先执行完任务数据，然后回收线程池，最后退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 任务入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoopTask&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;ChildTask&amp;gt; childTasks;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initLoopTask&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        childTasks = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;        childTasks.add(&lt;span&gt;new&lt;/span&gt; ChildTask(&lt;span&gt;&quot;childTask1&quot;&lt;/span&gt;));&lt;br/&gt;        childTasks.add(&lt;span&gt;new&lt;/span&gt; ChildTask(&lt;span&gt;&quot;childTask2&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; ChildTask childTask : childTasks) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    childTask.doExecute();&lt;br/&gt;                }&lt;br/&gt;            }).start();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shutdownLoopTask&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(childTasks)) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (ChildTask childTask : childTasks) {&lt;br/&gt;                childTask.terminal();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String args[])&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;        LoopTask loopTask = &lt;span&gt;new&lt;/span&gt; LoopTask();&lt;br/&gt;        loopTask.initLoopTask();&lt;br/&gt;        Thread.sleep(&lt;span&gt;5000L&lt;/span&gt;);&lt;br/&gt;        loopTask.shutdownLoopTask();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个任务都开一个单独的 Thread，这里我初始化了 2 个永动任务，分别为 childTask1 和 childTask2，然后分别执行，后面 Sleep 了 5 秒后，再关闭任务，我们可以看看是否可以按照我们的预期优雅退出。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 结果分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;childTask1:Cycle-&lt;span&gt;0&lt;/span&gt;-Begin&lt;br/&gt;childTask2:Cycle-&lt;span&gt;0&lt;/span&gt;-Begin&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cycle-&lt;span&gt;0&lt;/span&gt;-End&lt;br/&gt;childTask2:Cycle-&lt;span&gt;1&lt;/span&gt;-Begin&lt;br/&gt;childTask1:Cycle-&lt;span&gt;0&lt;/span&gt;-End&lt;br/&gt;childTask1:Cycle-&lt;span&gt;1&lt;/span&gt;-Begin&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1 shut down&lt;br/&gt;childTask2 shut down&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cycle-&lt;span&gt;1&lt;/span&gt;-End&lt;br/&gt;childTask2:Cycle-&lt;span&gt;1&lt;/span&gt;-End&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;“Pool-childTask” 是线程池名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask” 是任务名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Cat(catName=罗小黑)” 是执行的结果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask shut down” 是关闭标记；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask:Cycle-X-Begin” 和“childTask:Cycle-X-End” 是每一轮循环的开始和结束标记。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分析一下执行结果：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;childTask1 和 childTask2 分别执行，在第一轮循环中都正常输出了 5 条罗小黑数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二轮执行过程中，我启动了关闭指令，这次第二轮执行没有直接停止，而是先执行完任务中的数据，再执行退出，所以完全符合我们的优雅退出结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 源码地址&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://github.com/lml200701158/java-study/tree/master/src/main/java/com/java/parallel/pool/ofc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 写在最后&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于这个经典的线程池使用示例，原项目是我好友&lt;/span&gt;&lt;strong&gt;一灰&lt;/strong&gt;&lt;span&gt;写的，技术水平对标阿里 P7，&lt;/span&gt;&lt;strong&gt;实现得也非常优雅，涉及的知识点非常多&lt;/strong&gt;&lt;span&gt;，非常值得大家学习。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc3f1c7d499ab2e15e7ae9d48d24d889</guid>
<title>使用 StringUtils.split 的坑</title>
<link>https://toutiao.io/k/0xsnf61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/4lfok2icUkibRhulibg86OqauDH7x1pREibzO8LIVLibiaT6ibUnj1F8YsYE0Fhah3Y5ybQdiaAB1FHzzQDBmnCCBFroaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;350&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;Apche Commons&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在日常的 Java 开发中，由于 JDK 未能提供足够的常用的操作类库，通常我们会引入 Apache Commons Lang 工具库或者 Google Guava 工具库简化开发过程。两个类库都为 &lt;code&gt;java.lang&lt;/code&gt; API 提供了很多实用工具，比如经常使用的字符串操作，基本数值操作、时间操作、对象反射以及并发操作等。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;org.apache.commons&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;commons-lang3&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;3.12.0&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，最近在使用 Apache Commons Lang 工具库时&lt;strong&gt;踩了一个坑&lt;/strong&gt;，导致程序出现了意料之外的结果。&lt;/p&gt;&lt;h2&gt;StringUtils.split 的坑&lt;/h2&gt;&lt;p&gt;也是因为踩了这个坑，索性写下一篇文章好好介绍下 Apache Commons Lang 工具库中字符串操作相关 API。&lt;/p&gt;&lt;p&gt;先说坑是什么，我们都知道 String 类中到的 &lt;code&gt;split&lt;/code&gt; 方法可以分割字符串，比如字符串 &lt;code&gt;aabbccdd&lt;/code&gt; 根据 &lt;code&gt;bc&lt;/code&gt; 分割的结果应该是 &lt;code&gt;aab&lt;/code&gt; 和 &lt;code&gt;cdd&lt;/code&gt; 才对，这样的结果也很容易验证。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String s : str.split(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;)) {&lt;br/&gt;    System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 结果&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可能是因为 String 类中的 &lt;code&gt;split&lt;/code&gt; 方法的影响，我一直以为 &lt;code&gt;StringUtils.split&lt;/code&gt; 的效果应该相同，但其实完全不同，可以试着分析下面的三个方法输出结果是什么，StringUtils 是 Commons Lang 类库中的字符串工具类。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testA&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我对上面 testA 方法的预期是 &lt;code&gt;aab&lt;/code&gt; 和 &lt;code&gt;cdd&lt;/code&gt; ，但是实际上这个方法的运行结果是：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;// testA 输出&lt;br/&gt;aa&lt;br/&gt;dd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 字母都不见了，只剩下了 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，这是已经发现问题了，查看源码后发现 &lt;code&gt;StringUtils.split&lt;/code&gt; 方法其实是按字符进行操作的，不会把分割字符串作为一个整体来看，返回的结果中不也会包含用于分割的字符。&lt;/p&gt;&lt;p&gt;验证代码：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testB&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;ac&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// testB 输出&lt;/span&gt;&lt;br/&gt;b&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testC&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;abcd&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;ac&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// testC 输出&lt;/span&gt;&lt;br/&gt;b&lt;br/&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果和预期的一致了。&lt;/p&gt;&lt;h2&gt;StringUtils.split 源码分析&lt;/h2&gt;&lt;p&gt;点开源码一眼看下去，发现在方法注释中就已经进行提示了：&lt;strong&gt;返回的字符串数组中不包含分隔符&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class....&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;继续追踪源码，可以看到最终 split 分割字符串时入参有四个。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String[] splitWorker(&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; String str, &lt;span&gt;// 原字符串 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; String separatorChars,  &lt;span&gt;// 分隔符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max,  &lt;span&gt;// 分割后返回前多少个结果，-1 为所有&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preserveAllTokens &lt;span&gt;// 暂不关注&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据分隔符的不同又分了三种情况。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 分隔符为 null&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;len&lt;/span&gt; = str.length();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (len == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ArrayUtils.EMPTY_STRING_ARRAY;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sizePlus1&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;start&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;match&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;lastMatch&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (separatorChars == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// Null separator means use whitespace&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (Character.isWhitespace(str.charAt(i))) { &lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens) {&lt;br/&gt;                lastMatch = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (sizePlus1++ == max) {&lt;br/&gt;                    i = len;&lt;br/&gt;                    lastMatch = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                list.add(str.substring(start, i));&lt;br/&gt;                match = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            start = ++i;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        lastMatch = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        match = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        i++;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens &amp;amp;&amp;amp; lastMatch) {&lt;br/&gt;            list.add(str.substring(start, i));&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到如果分隔符为 &lt;code&gt;null&lt;/code&gt; ，是按照空白字符 &lt;code&gt;Character.isWhitespace()&lt;/code&gt; 分割字符串的。分割的算法逻辑为：&lt;/p&gt;&lt;p&gt;a. 用于截取的开始下标置为 0 ，逐字符读取字符串。b. 碰到分割的目标字符，把截取的开始下标到当前字符之前的字符串截取出来。c. 然后用于截取的开始下标置为下一个字符，等到下一次使用。d. 继续逐字符读取字符串、&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 分隔符为单个字符&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;逻辑同上，只是判断逻辑 &lt;code&gt;Character.isWhitespace()&lt;/code&gt; 变为了指定字符判断。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Optimise 1 character case&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; &lt;span&gt;sep&lt;/span&gt; = separatorChars.charAt(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (str.charAt(i) == sep) { &lt;span&gt;// 直接比较&lt;/span&gt;&lt;br/&gt;      ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3. 分隔符为字符串&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;总体逻辑同上，只是判断逻辑变为包含判断。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// standard case&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (separatorChars.indexOf(str.charAt(i)) &amp;gt;= &lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;// 包含判断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens) {&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;如何解决？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 使用 &lt;code&gt;splitByWholeSeparator&lt;/code&gt; 方法。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们想要的是按整个字符串分割，StringUtils 工具类中已经存在具体的实现了，使用 &lt;code&gt;splitByWholeSeparator&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;String[] resultArray = StringUtils.splitByWholeSeparator(str, &lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;    System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2. 使用 Google Guava 工具库&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;关于 Guava 工具库的使用，之前也写过一篇文章，可以参考：&lt;span&gt;Guava - 拯救垃圾代码&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;Iterable&amp;lt;String&amp;gt; iterable = Splitter.on(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;)&lt;br/&gt;    .omitEmptyStrings() &lt;span&gt;// 忽略空值&lt;/span&gt;&lt;br/&gt;    .trimResults() &lt;span&gt;// 过滤结果中的空白&lt;/span&gt;&lt;br/&gt;    .split(str);&lt;br/&gt;iterable.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3. JDK String.split 方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用 String 中的 split 方法可以实现想要效果。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;String[] res = str.split(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String re : res) {&lt;br/&gt;    System.out.println(re);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 String 的 split 方法也有一些坑，比如下面的输出结果。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;,a,,b,&quot;&lt;/span&gt;;&lt;br/&gt;String[] splitArr = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;Arrays.stream(splitArr).forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;a&lt;br/&gt;&lt;br/&gt;b&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开头的逗号&lt;code&gt;,&lt;/code&gt;前出现了空格，末尾的逗号&lt;code&gt;,&lt;/code&gt;后却没有空格。&lt;/p&gt;&lt;p&gt;一如既往，文章中代码存放在 &lt;span&gt;Github.com/niumoo/javaNotes&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;&amp;lt;完&amp;gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[4]&lt;/code&gt; Guava - 拯救垃圾代码: &lt;em&gt;https://www.wdbyte.com/2020/10/develop/google-guava/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; Github.com/niumoo/javaNotes: &lt;em&gt;https://github.com/niumoo/JavaNotes/tree/master/tool-java-apache-common&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;---- END ----&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Hello world : ) &lt;span&gt;这篇文章就到这里了，&lt;/span&gt;我是阿朗。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MDIxNjQ1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4lfok2icUkibQlzFGPibM1jmICzZmtYzRGMpP7suTs20SQKjwqgFWKKPcmAwzzeDZHE3fuhodU4oZsKQ3IibqYmibhg/0?wx_fmt=png&quot; data-nickname=&quot;程序猿阿朗&quot; data-alias=&quot;wdbyte&quot; data-signature=&quot;: ) 早睡早起，坚持不懈。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;点个在看，加油充电～&lt;/span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5a782fb3050552fdd7889393a31c8d6</guid>
<title>Kubernetes 网络流量流转路径</title>
<link>https://toutiao.io/k/ty9p91p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 网络模型定义了一组基本规则：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在不使用网络地址转换 (NAT) 的情况下，集群中的 Pod 能够与任意其他 Pod 进行通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在不使用网络地址转换 (NAT) 的情况下，在集群节点上运行的程序能与同一节点上的任何 Pod 进行通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个 Pod 都有自己的 IP 地址（IP-per-Pod），并且任意其他 Pod 都可以通过相同的这个地址访问它。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些要求，不会将具体实现限制在某种解决方案上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，它们笼统地描述了集群网络的特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了满足这些限制，你必须解决以下挑战:&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何确保同一个 Pod 中的容器行为就像它们在同一个主机上一样？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群中的 Pod 能否访问其他 Pod？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 可以访问服务吗？服务是负载均衡的吗？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 可以接收集群外部的流量吗？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本文中，将重点关注前三点，从 Pod 内的网络，容器到容器的通信说起。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Linux 网络命名空间如何在 Pod 中工作&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们来看一个运行应用的主容器和伴随一起的另一个容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在示例中，有一个带有 nginx 和 busybox 容器的 Pod:&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion: v1&lt;br/&gt;kind: Pod&lt;br/&gt;metadata:&lt;br/&gt;  name: multi-container-Pod&lt;br/&gt;spec:&lt;br/&gt;  containers:&lt;br/&gt;    - name: container-1&lt;br/&gt;      image: busybox&lt;br/&gt;      &lt;span&gt;command&lt;/span&gt;: [&lt;span&gt;&#x27;/bin/sh&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;-c&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sleep 1d&#x27;&lt;/span&gt;]&lt;br/&gt;    - name: container-2&lt;br/&gt;      image: nginx&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部署时，会发生以下事情：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 在节点上拥有独立的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配一个 IP 地址给 Pod ，两个容器之间共享端口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;两个容器共享相同的网络命名空间，并在本地彼此可见。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络配置在后台迅速完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，让我们退后一步，尝试理解为什么运行容器需要上述动作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以将网络命名空间视为，将物理网络接口分割小块之后的独立部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个部分都可以单独配置，并拥有自己的网络规则和资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些包括防火墙规则、接口（虚拟的或物理的）、路由以及与网络相关的所有内容。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;物理网络接口持有根网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeCr3SXvIziagKibKWcJnJnG85lu6tjNZL9gxMlibtLXsQj4olSVK7A1GSQAM6pic8d9EF/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;   2. 你可以使用 Linux 网络命名空间来创建独立的网络。每个网络都是独立的，除非你进行配置，默认不会与其他网络互通。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeBxFxturq3UYicHkBejOicRxjfQLqYZ3iae2OTtGvMcB7yaicZuUcM7ia0yHCu3n3dSeDw/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但最终，还是需要物理接口处理所有真实的数据包，所有虚拟接口都是基于物理接口创建的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络命名空间可以通过 ip-netns 进行管理，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip netns list&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以列出主机上的命名空间。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;需要注意的是，创建的网络命名空间会出现在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下面，但 Docker 并没有遵循这一规则。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，这是 Kubernetes 节点的一些命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns list&lt;br/&gt;&lt;br/&gt;cni-0f226515-e28b-df13-9f16-dd79456825ac (id: 3)&lt;br/&gt;cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd (id: 4)&lt;br/&gt;cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e (id: 2)&lt;br/&gt;cni-7619c818-5b66-5d45-91c1-1c516f559291 (id: 1)&lt;br/&gt;cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 (id: 0)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意 cni- 前缀；这意味着命名空间是由 CNI 插件创建的。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你创建一个 Pod，Pod 被分配给一个节点后，CNI 将：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 Pod 包含多个容器，那么这些容器都将被放在同一个命名空间中。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当创建 Pod 时，容器运行时会给容器创建一个网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BegSvV3vG5npW8KdmeCV7G7dFaPWGiaoeBMia6L2y2vnbPibFlMibT6jr7wsDkclmxWUrt/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 然后 CNI 负责给 Pod 分配一个 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bebia7oqUicByX4Ac2flVzh1UaRu4TVjLOCL9BMnnpV6nyvTc5K4Ykkiak0Iks79VHqSO/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. 最后 CNI 将容器连接到网络的其余部分。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be9a5micood7GQDpGiaS3KpUtribNhd8nFTbXia4x4csD86lGjRgs5A3UfOV9g5IALIdiaK/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，当你列出节点上的容器的命名空间会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以通过 SSH 连接到 Kubernetes 节点并查看命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ lsns -t net&lt;br/&gt;&lt;br/&gt;        NS TYPE NPROCS   PID USER     NETNSID NSFS                           COMMAND&lt;br/&gt;4026531992 net     171     1 root  unassigned /run/docker/netns/default      /sbin/init noembed norestore&lt;br/&gt;4026532286 net       2  4808 65535          0 /run/docker/netns/56c020051c3b /pause&lt;br/&gt;4026532414 net       5  5489 65535          1 /run/docker/netns/7db647b9b187 /pause&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;lsns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个用于列出主机上所有可用命名空间的命令。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;请记住，Linux 中有多种命名空间类型。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx 容器在哪里？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那些 pause 容器是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;在 Pod 中，pause 容器创建了网络命名空间&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先列出节点上的所有命名空间，看看能否找到 Nginx 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ lsns&lt;br/&gt;        NS TYPE   NPROCS   PID USER            COMMAND&lt;br/&gt;&lt;span&gt;# truncated output&lt;/span&gt;&lt;br/&gt;4026532414 net         5  5489 65535           /pause&lt;br/&gt;4026532513 mnt         1  5599 root            sleep 1d&lt;br/&gt;4026532514 uts         1  5599 root            sleep 1d&lt;br/&gt;4026532515 pid         1  5599 root            sleep 1d&lt;br/&gt;4026532516 mnt         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;4026532517 uts         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;4026532518 pid         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx 容器在挂载 (&lt;/span&gt;&lt;code&gt;&lt;span&gt;mnt&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)、Unix time-sharing (&lt;/span&gt;&lt;code&gt;&lt;span&gt;uts&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 和 PID (&lt;/span&gt;&lt;code&gt;&lt;span&gt;pid&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 命名空间中，但不在网络命名空间 (&lt;/span&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不幸的是，&lt;/span&gt;&lt;code&gt;&lt;span&gt;lsns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只显示每个进程最小的 PID，但你可以根据这个进程 ID 进一步过滤。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用以下命令，在所有命名空间中检索 Nginx 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ sudo lsns -p 5777&lt;br/&gt;&lt;br/&gt;       NS TYPE   NPROCS   PID USER  COMMAND&lt;br/&gt;4026531835 cgroup    178     1 root  /sbin/init noembed norestore&lt;br/&gt;4026531837 user      178     1 root  /sbin/init noembed norestore&lt;br/&gt;4026532411 ipc         5  5489 65535 /pause&lt;br/&gt;4026532414 net         5  5489 65535 /pause&lt;br/&gt;4026532516 mnt         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;4026532517 uts         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;4026532518 pid         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进程再次出现，它劫持了网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是怎么回事？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;集群中的每个 Pod 都有一个额外的隐藏容器在后台运行，称为 pause 容器。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列出在节点上运行的容器并获取 pause 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ docker ps | grep pause&lt;br/&gt;&lt;br/&gt;fa9666c1d9c6   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_kube-dns-599484b884-sv2js…&lt;br/&gt;44218e010aeb   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_blackbox-exporter-55c457d…&lt;br/&gt;5fb4b5942c66   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_kube-dns-599484b884-cq99x…&lt;br/&gt;8007db79dcf2   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_konnectivity-agent-84f87c…&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，节点上的每一个 Pod 都会有一个对应的 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 容器负责创建和维持网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层容器运行时会完成网络命名空间的创建，通常是由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;containerd&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CRI-O&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在部署 Pod 和创建容器之前，由运行时创建网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器运行时会自动完成这些，不需要手工执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;话题回到 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它包含非常少的代码，并且在部署后立即进入睡眠状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，它是必不可少的，并且在 Kubernetes 生态系统中起着至关重要的作用。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 Pod 时，容器运行时会创建一个带有睡眠容器的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeCVjs8AOVUdNOON0ste3qoVrqKLCtZTe2VmVC3I9qPdkGFLfuMQib086zhA4FSeqlf/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. Pod 中的其他容器都会加入由 pause 容器创建的网络名称空间。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeFuPxkjoSqg0YSBKonSYQV6h34JicvkQ1jxVzwdcYTicibCz4Gicsjwgoib6GcMEprqRjx/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. 此时，CNI 分配 IP 地址并将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BenHsjlEYNbanECNPicZuSYrylsdedDFiafO0dlCzs4IWWhHpdNOt6XU5V1ck8NicH6ux/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个进入睡眠状态的容器有什么用？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了理解它的用途，让我们想象一个 Pod 有两个容器，就像前面的例子一样，但没有 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一旦容器启动，CNI 将会：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使 busybox 容器加入之前的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 Nginx 崩溃了怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 将不得不再次执行所有步骤，并且两个容器的网络都将中断。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于睡眠容器不太可能有任何错误，因此创建网络命名空间通常是一种更安全、更健壮的选择。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;如果 Pod 中的一个容器崩溃了，剩下的仍然可以回复其他网络请求。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;分配一个 IP 地址给 Pod&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面我提到 Pod 和两个容器将具有同一个 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那是怎样配置的呢？&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;在 Pod 网络命名空间内，创建了一个接口，并分配了一个 IP 地址。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们验证一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，找到 Pod 的 IP 地址：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ kubectl get Pod multi-container-Pod -o jsonpath={.status.PodIP}&lt;br/&gt;&lt;br/&gt;10.244.4.40&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，找到相关的网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于网络命名空间是从物理接口创建的，需要先访问集群节点。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果你运行的是 minikube，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;minikube ssh&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 访问节点。如果在云厂中运行，那么应该有某种方法可以通过 SSH 访问节点。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进入后，找到最新创建的命名网络命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ls -lt /var/run/netns&lt;br/&gt;&lt;br/&gt;total 0&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 25 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在示例中，就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。然后，可以在该命名空间内运行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;exec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip a&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# output truncated&lt;/span&gt;&lt;br/&gt;3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP group default&lt;br/&gt;    link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;br/&gt;    inet 10.244.4.40/32 brd 10.244.4.40 scope global eth0&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;    inet6 fe80::14a4:f8ff:fe4f:5677/64 scope link&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 IP 就是 Pod 的 IP 地址！通过查找 @if12 中的 12 找到网络接口&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link | grep -A1 ^12&lt;br/&gt;&lt;br/&gt;12: vethweplb3f36a0@if16: mtu 1376 qdisc noqueue master weave state UP mode DEFAULT group default&lt;br/&gt;    link/ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你还可以验证 Nginx 容器是否监听了来自该命名空间内的 HTTP 流量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp&lt;br/&gt;&lt;br/&gt;Active Internet connections (only servers)&lt;br/&gt;Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name&lt;br/&gt;tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      692698/nginx: master&lt;br/&gt;tcp6       0      0 :::80                   :::*                    LISTEN      692698/nginx: master&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果你无法通过 SSH 访问集群中的工作节点，你可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl exec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 获取到 busybox 容器的 shell 并直接在内部使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;刚刚我们介绍了容器之间的通信，再来看看如何建立 Pod 到 Pod 的通信吧。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;查看集群中 Pod 到 Pod 的流量&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Pod 的通信有两种可能的情况：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 流量的目的地是同一节点上的 Pod。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 流量的目的地是在不同节点上的 Pod。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个工作流依赖于虚拟接口对和网桥，下面先来了解一下这部分的内容。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;为了让一个 Pod 与其他 Pod 通信，它必须先访问节点的根命名空间。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过虚拟以太网对来实现 Pod 和根命名空间的连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些虚拟接口设备（veth 中的 v）连接并充当两个命名空间之间的隧道。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用此 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备，你将一端连接到 Pod 的命名空间，另一端连接到根命名空间。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BenHsjlEYNbanECNPicZuSYrylsdedDFiafO0dlCzs4IWWhHpdNOt6XU5V1ck8NicH6ux/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 可以帮你执行这些操作，但你也可以手动执行：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link add veth1 netns Pod-namespace &lt;span&gt;type&lt;/span&gt; veth peer veth2 netns root&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在 Pod 的命名空间有一个可以访问根命名空间的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;隧道&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点上，新建的每一个 Pod 都会设置这样的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个是，创建接口对；另一个是为以太网设备分配地址并配置默认路由。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面看看如何在 Pod 的命名空间中设置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40/24 dev veth1&lt;br/&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip link &lt;span&gt;set&lt;/span&gt; veth1 up&lt;br/&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在节点上，让我们创建另一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip addr add 169.254.132.141/16 dev veth2&lt;br/&gt;$ ip link &lt;span&gt;set&lt;/span&gt; veth2 up&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以像前面一样检查现有的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Pod 的命名空间中，检索 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口的后缀。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show &lt;span&gt;type&lt;/span&gt; veth&lt;br/&gt;&lt;br/&gt;3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default&lt;br/&gt;    link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在这种情况下，可以使用命令 &lt;/span&gt;&lt;code&gt;&lt;span&gt;grep -A1 ^12&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查找（或滚动到目标所在处）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link show &lt;span&gt;type&lt;/span&gt; veth&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# output truncated&lt;/span&gt;&lt;br/&gt;12: cali97e50e215bd@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default&lt;br/&gt;    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;也可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.命令&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意 &lt;/span&gt;&lt;code&gt;&lt;span&gt;3: eth0@if12和12: cali97e50e215bd@if3&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口上的符号。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Pod 命名空间，该 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口连接到根命名空间的 12 号接口，因此是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@if12&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对的另一端，根命名空间连接到 Pod 命名空间的 3 号接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来是连接 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对两端的桥接器。&lt;/span&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1666439149231&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1666439149231&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;Pod 网络命名空间连接到以太网桥&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网桥会汇聚位于根命名空间中的每一个虚拟接口。这个网桥允许虚拟 pair 之间的流量，也允许穿过公共根命名空间的流量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;补充一下相关原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以太网桥位于 OSI 网络模型 的第 2 层。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以将网桥视为接受来自不同命名空间和接口的连接的虚拟交换机。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以太网桥可以连接节点上的多个可用网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，可以使用网桥连接两个接口，即 Pod 命名空间的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 连接到同一节点上另一个 Pod 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BesVkTOuAy5VJ1icLJVzo86su8sL1xyuIZkZhntHEf3dgGWwvZjMPbiboicwwg6IHVn1D/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，继续看网桥和 veth 对的用途。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;跟踪在同一节点上 Pod 到 Pod 的流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设同一个节点上有两个 Pod，Pod-A 向 Pod-B 发送消息。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于访问目标不在同一个命名空间，Pod-A 将数据包发送到其默认接口 eth0。这个接口与 veth 对的一端绑定，作为隧道。这样，数据包会被转发到节点上的根命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be6DJTlhC4RAiaoibys0EZCE3mAwvV1ULf9PuCgDq2SpVNgmpyAcHlIc176WhrPpjA4B/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 以太网网桥作为一个虚拟交换机，需要目标 Pod-B 的 MAC 地址才能工作。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeroUL1R12qsQ2gvv89EzB8ueEFkgy6B8sATfPA7cdwkoC42AuU1CPHIZibxTWWvdpK/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. ARP 协议会解决这个问题。当帧到达网桥时，会向所有连接的设备发送 ARP 广播。网桥广播询问持有 Pod-B 的 IP 地址&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be24RTlRG2RD2RrHbrQjJXD84LsnwMfhPSQ59ibdXkaRrOCZhZCFpQJib58zyLFc5agy/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  4. 此时会收到一个带有 Pod-B IP 的 MAC 地址应答，这条消息会被存储在桥接 ARP 缓存(查找表)中。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeZDcrV9CMqsaxNL2MQnrIuibqAxjsWP80OwibZicmIibH2XwI826iczkaee8PicZibQMoRoj/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  5. IP 地址和 MAC 地址的映射关系存储之后，网桥就在表中查找，并将数据包转发到正确的端点。数据包到达根命名空间内 Pod-B 的 veth 之后，很快又到达 Pod-B 命名空间内的 eth0 接口。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BehnS9AMQytNxnibGXNwdqYuNey26PZgBGB7IvEQl1fXXXuL626hWFE8icw7iakMEiaBicM/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，Pod-A 和 Pod-B 之间的通信就成功了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;跟踪不同节点上的 Pod 到 Pod 通信&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于跨节点 Pod 之间的通信，会经过额外的通信跳跃。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod-B。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeMHNq80v5zydC5zgZKtN3JC5uH9iaBjAZIqIlnQZLGl1Gg9iaRvAIOrdssTjZ0LaV3U/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 当目的 IP 不在本地网络中时，报文被转发到节点的默认网关。节点的出口网关或默认网关，通常位于节点与网络相连的物理接口 eth0 上。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BelLgSxy61hibZZLo4xvkwWEuJqqMW3ZzwibVv2DSomW7FerZ5SEIiaKczQlrrXR5dZQD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时 不会发生 ARP 解析，因为源 IP 和目标 IP 不在同一个网段中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网段的检查是使用按位运算完成的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当目的 IP 不在当前网络段时，数据包被转发到节点的默认网关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;按位运算的工作原理&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在确定数据包的转发位置时，源节点必须执行位运算&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这也称为与操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复习一下，按位与运算的规则：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;0 AND 0 = 0&lt;br/&gt;0 AND 1 = 0&lt;br/&gt;1 AND 0 = 0&lt;br/&gt;1 AND 1 = 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了 1 与 1 以外的都是 false。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与运算将得知它们位于不同的网段上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这意味着目标 IP 与数据包的源不在同一个网络上，数据包将通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数学时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们必须从二进制的 32 位地址开始进行 AND 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先找出源 IP 网络和目标 IP 网段。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.00000000.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.0.0(/16)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000000.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.0.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按位运算之后，需要将目标 IP 与数据包源节点的子网进行比较。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Network Result&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运算的结果是 172.16.1.0，不等于 192.168.1.0（源节点的网络）。说明源 IP 地址和目标 IP 地址不在同一个网络上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果目标 IP 是 192.168.1.2，即与发送 IP 在同一子网中，则 AND 操作将得到节点的本地网络。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000010&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.2&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进行逐位比较后，ARP 通过查找表查找默认网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有条目，将立即转发数据包。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;否则，先进行广播以找到网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;现在，数据包路由到另一个节点的默认接口，我们称为 Node-B。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeG4lRwtJlvFUKuDFY4Y0hD6PmNYmqqHeib9hicMhC7IMKZicuuO6HM35lQ18a5hMsLgz/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以相反的顺序。现在，数据包位于 Node-B 的根命名空间，并到达网桥，这里会进行 ARP 解析。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeyxibLXQLqIyDecl8Z9gicIhjxbWnrB5hgrrYFJYSs4w6VJgRfVbibVm82OwuvmSTibZX/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;路由系统将返回与 Pod-B 相连的接口的 MAC 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Begoj8lneQsiby4ywWW8Piaibd4m6zLo0t5UWFXKicNQkGneWOZeyHenBWSsHH38kcbgbk/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  4. 网桥通过 Pod-B 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备转发帧，并到达 Pod-B 的命名空间。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeC17ZWWrGPVGAXLlwBic1A2ncic9U0Z9L8vKDKFOwExPuibpdqsASuCo6hGNFukWnZA0/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，你应该已经熟悉了 Pod 之间的流量是如何流转的。下面，让我们花点时间来看看 CNI 如何管理上诉内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;容器网络接口 - CNI&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器网络接口（CNI）主要关注的是当前节点中的网络。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeQZm9icrtWfmQ96WauD5QQYfl0GbiaawR7p0QIoNoSzAIvg2jtj9JTBuy0a2jtXnvC5/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以将 CNI 看作为解决 Kubernetes 网络需求，而遵循的一组规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有这些 CNI 实现可供使用：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Calico&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cillium&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Flannel&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Weave Net&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其他网络插件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;他们都遵循相同的 CNI 标准。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有 CNI，你需要人工完成如下操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建接口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 veth 对。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置静态路由。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;配置以太网桥。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 NAT 规则。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;还有其他大量事情。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这还不包括，在删除或重启 Pod 时，需要进行类似的全部操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 必须支持四种不同的操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ADD - 向网络添加一个容器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DEL - 从网络中删除一个容器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CHECK - 如果容器的网络出现问题，则返回错误。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;VERSION - 显示插件的版本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们一起看下，CNI 是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Pod 被分配到特定节点时，Kubelet 自身不会初始化网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，Kubelet 将这个任务交给 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;但是，Kubelet 以 JSON 格式指定配置并发送至 CNI 插件。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以进入节点上的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc/cni/net.d&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件夹，使用以下命令查看当前的 CNI 配置文件：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ cat 10-calico.conflist&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;k8s-Pod-network&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;cniVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.3.1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;calico&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;datastore_type&quot;&lt;/span&gt;: &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;mtu&quot;&lt;/span&gt;: 0,&lt;br/&gt;      &lt;span&gt;&quot;nodename_file_optional&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;log_level&quot;&lt;/span&gt;: &lt;span&gt;&quot;Info&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;log_file_path&quot;&lt;/span&gt;: &lt;span&gt;&quot;/var/log/calico/cni/cni.log&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;ipam&quot;&lt;/span&gt;: { &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;calico-ipam&quot;&lt;/span&gt;, &lt;span&gt;&quot;assign_ipv4&quot;&lt;/span&gt; : &lt;span&gt;&quot;true&quot;&lt;/span&gt;, &lt;span&gt;&quot;assign_ipv6&quot;&lt;/span&gt; : &lt;span&gt;&quot;false&quot;&lt;/span&gt;},&lt;br/&gt;      &lt;span&gt;&quot;container_settings&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;allow_ip_forwarding&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;policy&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;k8s&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;k8s_api_root&quot;&lt;/span&gt;:&lt;span&gt;&quot;https://10.96.0.1:443&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;kubeconfig&quot;&lt;/span&gt;: &lt;span&gt;&quot;/etc/cni/net.d/calico-kubeconfig&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;bandwidth&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: {&lt;span&gt;&quot;bandwidth&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;}&lt;br/&gt;    },&lt;br/&gt;    {&lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;portmap&quot;&lt;/span&gt;, &lt;span&gt;&quot;snat&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: {&lt;span&gt;&quot;portMappings&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;}}&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个 CNI 插件都会使用不同类型的网络配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，Calico 使用基于 BGP 的三层网络连接 Pod&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cilium 从三层到七层使用的是基于 eBPF 的 overlay 网络&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与 Calico 一样，Cilium 也支持通过配置网络策略来限制流量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么你应该使用哪一个呢？主要有两类 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在第一类中，使用基本网络设置（也称为平面网络），从集群的 IP 池为 Pod 分配 IP 地址的 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式可能很快耗尽 IP 地址，而成为负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，另一类是使用 overlay 网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，overlay 网络是主（底层）网络之上的重建网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;overlay 网络通过封装来自底层网络的数据包工作，这些数据包被发送到另一个节点上的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;overlay 网络的一种流行技术是 VXLAN，它可以在 L3 网络上建立 L2 域的隧道。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么哪个更好呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没有单一的答案，这取决于你的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你是否正在构建具有数万个节点的大型集群？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许 overlay 网络更好。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你是否在意更简单的配置和审查网络流量，而不会愿意在复杂网络中丢失这种能力？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扁平网络更适合你。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们讨论完了 CNI，接着让我们来看看 Pod 到服务的通信是如何连接的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;检查 Pod 到 Service 的流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于 Pod 在 Kubernetes 中是动态的，分配给 Pod 的 IP 地址不是静态的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 的 IP 是短暂的，每次创建或删除 Pod 时都会&lt;/span&gt;&lt;span&gt;发生变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中的 Service 解决了这个问题，为连接一组 Pod 提供了可靠的机制。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BesLEAKPUeuZ4YF1tkHT7IiaWHL76olXNFKHmrUgMQw3HNxAt8U67zvURqH0UBcNrH8/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认情况下，在 Kubernetes 中创建 Service 时，被分配一个虚拟 IP。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Service 中，可以使用选择器将 Service 与目标 Pod 相关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当删除或添加一个 Pod 时会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Service 的虚拟 IP 保持静态不变。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但流量可以再无需干预的情况下，到达新创建的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;换句话说，Kubernetes 中的 Service 类似于负载均衡器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但它们是如何工作的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;使用 Netfilter 和 Iptables 拦截和重写流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中的 Service 是基于 Linux 内核中的两个组件构建的：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;网络过滤器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Netfilter 是一个可以配置数据包过滤、创建 NAT 、端口转发规则以及管理网络中流量的框架&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，它可以屏蔽和禁止未经同意的访问。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另一方面，iptables 是一个用户态程序，可以用来配置 Linux 内核防火墙的 IP 数据包过滤规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;iptables 是作为不同的 Netfilter 模块实现的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以使用 iptables CLI 即时修改过滤规则，并将它们插入 netfilters 挂载点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过滤器配置在不同的表中，其中包含用于处理网络流量数据包的链。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同的协议使用不同的内核模块和程序。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;当提到 iptables 时，通常指的是 IPv4。对于 IPv6 ，终端工具是 ip6tables。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;iptables 有五种链，每一种链都直接映射到 Netfilter 的钩子上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 iptables 的角度来看，它们是：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;INPUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;FORWARD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;OUTPUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;POST_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们对应地映射到 Netfilter 钩子：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_LOCAL_IN&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_FORWARD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_LOCAL_OUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_POST_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个数据包到达时，根据它所处的阶段，将 “触发” 一个 Netfilter 钩子。这个钩子会执行特定的 iptables 过滤规则。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeNzsOFCWdyOAxKFPL5ghCJlTYxWdtpnp3pgPQLOUE3p2hRKJJ1j43DQVNoiculxnFD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哎呀！看起来很复杂！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过没什么好担心的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就是我们使用 Kubernetes 的原因，以上所有内容都是通过使用 Service 抽象出来的，并且一个简单的 YAML 定义可以自动设置这些规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你有兴趣查看 iptables 规则，可以连接到节点并运行：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ iptables-save&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你还可以使用这个工具来可视化节点上的 iptables 链。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是来自 GKE 节点上的可视化 iptables 链的示例图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BedtQUk0u83ibwK8m6POrS2gsneOJ1DY4GlQ5pAxF4FCkRL8O2aPT31EtsnUAP0sZh6/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意，这里可能配置了几百条规则，想想一下自己动手怎么配置！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我们已经了解了，相同节点上的 Pod 和不同节点上 Pod 之间是如何通信的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Pod 与 Service 的通信中，链路的前半部分是一样的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bex5aicXl6q5Tgscxlc1StCMru68bud4EUM8sxnpggX8qALyEHwjRcicwOvNUfWq60zib/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当请求从 Pod-A 走向 Pod-B 时，由于 Pod-B 在 Service 的 “后面”，在传输的过程中，会有一些不一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原始的请求，在 Pod-A 命名空间的 eth0 接口发出。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着，请求通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;到达根名称空间的网桥。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一旦到达网桥，数据包就会立即通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与 Pod-to-Pod 部分一样，主机进行按位比较。由于服务的虚拟 IP 不是节点 CIDR 的一部分，因此数据包将立即通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果默认网关的 MAC 地址尚未出现在查找表中，则会进行 ARP 解析找出默认网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在神奇的事情发生了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据包通过节点的路由之前，Netfilter 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;NF_IP_PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 挂钩被触发，并执行 iptables 规则。这个规则会修改 Pod-A 数据包的目标 IP 地址 DNAT。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeLcmZIQemsib9micmpkp2dUZHib8EqgGVnQpjmyTLicniczyhgEjWxWeHC3TXqOYyFpmIz/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面服务的虚拟 IP 地址被重写为 Pod-B 的 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，数据包路由过程与 Pod 到 Pod 的通信一样。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be7hqickzPFlfnFuwuDO6lZu9pJSgh7EOxPDVhUZCvvjCOD3XcNn1l4FF7MLRJ00UFC/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据包重写后，通信是 Pod 到 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然而，在所有这些通信中，使用了一个第三方的功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此功能称为 conntrack 或链路跟踪。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Pod-B 发回响应时，conntrack 会将数据包与链路相关联，并跟踪其来源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NAT 严重依赖于 conntrack。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有链路跟踪，将不知道将包含响应的数据包发回何处。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 conntrack 时，数据包的返回路径很容易设置为相同的源或目标 NAT 更改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通信的另一部分与现在的链路相反。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;检查来自服务的响应&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod-B 发送响应，将其 IP 地址设置为源地址，并将 Pod-A 的 IP 地址设置为目标地址。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeFzHenJSp8WjMRpeTS1lPVkLFdKWVjCG2jfasJ8bUjylvSiaWDU26LztAHn3ibK9Cue/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当数据包到达 Pod-A 所在节点的接口时，会发生另一个 NAT。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeS1wn2WowD4AS4Errtia3GfQdCwDCOUTv3ibqnfL4vJUIc56CsYz5kI0Za2O7asicv6m/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时，conntrack 开始工作，修改源 IP 地址，iptables 规则执行 SNAT，并将 Pod-B 的源 IP 地址修改为原始服务的虚拟 IP。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bepjky9nzc3KanppnRs1PpIIde7kcicd7gpEmxljVyZcFEAaGrGMwaZGQPicWPbuPwUo/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 Pod-A 来说，响应是来自于 Service 而不是 Pod-B。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其余的都是一样的。一旦 SNAT 完成，数据包就会到达根命名空间中的网桥，并通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对转发到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pod-A&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总 结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们一起回顾下本文相关要点&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;容器如何在本地或 Pod 内通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在相同节点和不同节点上的 Pod 如何通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod-to-Service - Pod 如何将流量发送到 Kubernetes 中服务后面的 Pod 时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;什么是命名空间、veth、iptables、chains、conntrack、Netfilter、CNI、overlay 网络，以及 Kubernetes 网络工具箱中所需的一切。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ee6840568d33485a0f4fbec6c91809b</guid>
<title>如何优雅的解决线上问题？</title>
<link>https://toutiao.io/k/6u6eytw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;身为一个程序员，遇到线上问题那都是家常便饭的事儿。&lt;/p&gt;&lt;p&gt;如果你在深夜看到一群同事围在一起，他们是在共同探讨什么哲学问题么？非也，他们一定是遇到了线上BUG。&lt;/p&gt;&lt;p&gt;线上问题只要影响到了核心业务流程那便是事故，所以一旦事故发生，无论你在约会，还是周末打游戏，甚至是在睡觉，只要接到了来自公司的电话，那只能赶紧连上公司网络加班了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5036261079774376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCPVwHmVZXibnwXCNqe9ZGyQ9kzztrNiac4j98vcAJkwzvTiaSSZ8JsXI3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;BUG分类&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上问题是复杂多变的，我们一般将bug分为系统级别和业务级别bug。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;系统级别bug&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;业务部署在整套系统上运行，一旦出现系统级别bug则业务会被严重拖垮。如CPU爆满、服务不可用、甚至服务器宕机等都属于系统级别的bug。&lt;/p&gt;&lt;p&gt;如果是CPU100%，那是由哪个线程，哪个类，甚至是哪个方法导致的？&lt;/p&gt;&lt;p&gt;若是业务流程正常但是部分服务性能拉跨，那么如何快速定位到问题在哪儿？&lt;/p&gt;&lt;p&gt;因为是线上发生的事儿，所以重点在于如何&lt;span&gt;&lt;strong&gt;迅速解决&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;以下分享我最常用的一些问题排查工具。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;linux定位工具&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;1.CPU高负载，甚至100%？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;perf工具&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;perf是linux的性能分析工具，核心作用之一就是用来查看热点函数的分布情况。&lt;/p&gt;&lt;p&gt;用它可以生成&lt;strong&gt;火焰图&lt;/strong&gt;查看到函数的资源占用情况，函数的调用栈越深火焰就越高。所以对于异常的函数一眼就能看出。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1338212232096184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCpcCAzx7Wy8iaXrz0WJE1M60JuA9LFHGJyySD7zA6CcC3vbtMVZZSmDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3826&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如上图通过调用栈你可以看出Monitor管程在反复调用enter和wait，这种情况下就可以判断出该程序已经发生死锁且存在性能问题。假设有大量线程请求这段代码，那么CPU资源将被迅速打满！&lt;/p&gt;&lt;p&gt;在著名的“713B站事故”里技术团队在事故发生时就用到了当前工具生成了火焰图，快速地分析出了事故的根因也就是导致CPU100%的lua热点函数。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.某一进程存在异常嫌疑，想快速知道它的状态？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;ps命令&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们项目部署的服务器里在跑的进程老多了，java进程、nginx进程、redis、消息队列进程等等。&lt;/p&gt;&lt;p&gt;举个例子，假设在某一流量高峰期系统监控到整个服务性能下降5倍，业务被严重拖垮，在确定没有业务层面bug的情况下大概率就是因为服务性能达到瓶颈了。如何确定瓶颈在哪儿？&lt;/p&gt;&lt;p&gt;大部分情况下通过系统告警就可以知道大概问题所在。如发生消息堆积我们就该怀疑消息生产者和消费者的状态，这个时候就要具体去查看消息队列这一进程。&lt;/p&gt;&lt;p&gt;可以使用一些轻量级的linux命令，如&lt;span&gt;&lt;strong&gt;ps&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]&lt;span&gt;# ps -ef | grep queuejob&lt;/span&gt;&lt;br/&gt; root       &lt;span&gt;1303&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; Apr17 ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/queuejob&lt;br/&gt; root       &lt;span&gt;3260&lt;/span&gt;   &lt;span&gt;3087&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; Apr17 ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/bin/queuejob /bin/sh -c exec -l /bin/bash -c &lt;span&gt;&quot;env GNOME_SHELL_SESSION_MODE=classic gnome-session --session gnome-classic&quot;&lt;/span&gt;&lt;br/&gt; root      &lt;span&gt;24174&lt;/span&gt;  &lt;span&gt;19508&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto&lt;/span&gt; ssh&lt;br/&gt; [root@linux265 ~]# ps -aux | grep queueA&lt;br/&gt; root       &lt;span&gt;1303&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;82468&lt;/span&gt;  &lt;span&gt;1204&lt;/span&gt; ?        Ss   Apr17   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/queueA&lt;br/&gt; root       &lt;span&gt;3260&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;52864&lt;/span&gt;   &lt;span&gt;572&lt;/span&gt; ?        Ss   Apr17   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/bin/queueA /bin/sh -c exec -l &lt;br/&gt; root      &lt;span&gt;24188&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;112652&lt;/span&gt;   &lt;span&gt;956&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    S+   &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto&lt;/span&gt; ssh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令还可以用于对进程的资源使用情况进行排序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]# ps aux | sort -nk 3&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]&lt;span&gt;# ps aux | sort -rnk 4 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;3.我想知道内存&amp;amp;磁盘的使用情况？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;vmstat命令&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写。&lt;/p&gt;&lt;p&gt;它是一个用于监控内存和磁盘使用情况的工具，但是也可以用来查看CPU的一些指标，如中断次数等。使用它可以查看内存使用的详细信息和磁盘的读/写情况。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36810344827586206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCuW5tFtxRRicv4GVqQEf1Mbz5bUNLn7ZEvpjZcogrbvmJdXD50zhl3yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;以上表头字段的说明如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Procs（进程）：&lt;br/&gt;&lt;br/&gt;r: 运行队列中进程数量&lt;br/&gt;&lt;br/&gt;b: 等待IO的进程数量&lt;br/&gt;&lt;br/&gt;Memory（内存）：&lt;br/&gt;&lt;br/&gt;swpd: 使用虚拟内存大小&lt;br/&gt;&lt;br/&gt;free: 可用内存大小&lt;br/&gt;&lt;br/&gt;buff: 用作缓冲的内存大小&lt;br/&gt;&lt;br/&gt;cache: 用作缓存的内存大小&lt;br/&gt;&lt;br/&gt;Swap(交换)：&lt;br/&gt;&lt;br/&gt;si: 每秒从交换区写到内存的大小&lt;br/&gt;&lt;br/&gt;so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数&lt;br/&gt;&lt;br/&gt;System(系统)：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;in&lt;/span&gt;: 每秒中断数，包括时钟中断&lt;br/&gt;&lt;br/&gt;cs: 每秒上下文切换数&lt;br/&gt;&lt;br/&gt;CPU（以百分比表示）&lt;br/&gt;&lt;br/&gt;us: 用户进程执行时间(user time)&lt;br/&gt;&lt;br/&gt;sy: 系统进程执行时间(system time)&lt;br/&gt;&lt;br/&gt;id: 空闲时间(包括IO等待时间),中央处理器的空闲时间&lt;br/&gt;&lt;br/&gt;wa: IO等待时间&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从以上命令就可以很清晰地看出服务器的各方面性能情况。除此之外还有以下命令也可以在排查或者调优中使用：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7892644135188867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCMV1OVD6d00DfHBm9ibkdY3icJ2zZ6ndltWL4xGVYPGS8gILADibA45RUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;业务级别bug&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;如何定位到业务bug？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;出现了业务bug那就纯纯的是开发或测试的锅了。&lt;/p&gt;&lt;p&gt;bug确定后第一步一定是&lt;span&gt;&lt;strong&gt;先看日志&lt;/strong&gt;&lt;/span&gt;，只要你写需求的时候日志打的全，一般出现了问题日志或者告警都会第一时间推送。&lt;/p&gt;&lt;p&gt;通过日志我们可以定位到bug对应代码的位置，但这仅仅是第一步，因为你只知道哪里出了问题，并不知道代码出了什么问题(除非一眼就能看出)。&lt;/p&gt;&lt;p&gt;所以下一步，&lt;span&gt;&lt;strong&gt;看数据&lt;/strong&gt;&lt;/span&gt;，数据是业务应用的核心。若通过日志和页面表现查看到你的主流程是没有问题的，那么下一步就是要确定表的数据是否有问题，数据存在bug的表现会是各方面的，可能是用户反馈，也可能是流程错误，这要取决于你表的设计。&lt;/p&gt;&lt;p&gt;切记！！线上数据是重中之重，当你决定要修复数据，在处理之前一定要做好备份，这样起码可以保证事情不会变的更糟。一般情况下修改线上数据这种活都需要你写好SQL，然后经过leader审批再交给DBA来操作，一定不要干出删库跑路这种事哟。&lt;/p&gt;&lt;p&gt;假设验证了你数据是OK的，那么问题就极大可能出现在了&lt;span&gt;&lt;strong&gt;代码层面&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;当代程序员最难过的瞬间无非就是有一个非常紧急的线上bug需要你来解决，但是摆在你面前的却是一堆屎山代码！！&lt;/p&gt;&lt;p&gt;修改业务bug最重要的是要将bug点修改掉并且保证其它业务还能正常运行，这是牵一发而动全身的事情，否则bug只会越改越多。&lt;/p&gt;&lt;p&gt;所以平时应该预知到这些风险，做好代码设计。总结一下定位业务bug的正确步骤：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27586206896551724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCXK1IdNLPXWqHnnsMA7GcJfexfsxEZFicQ6lbknbcVGI6mATD91cesMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;方案设计&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;代码设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;一般公司都有自己的代码设计规范。比如由外到里包装代码，每一个方法都要有对应的职责，并且一个方法不要超过100行，一个类不要超过1000行代码等。清晰的结构可以让你和他人更好地review代码，避免看起来一头雾水。&lt;/p&gt;&lt;p&gt;写业务逻辑有两种方式，一种就是简洁明了的线性逻辑，另一种就是通过封装代码来减少代码耦合提高内聚性，也就是我们说的设计模式的使用。两种方式各有优缺点，但是工作多年了咱写的代码也不能直里直气的，多少得带点”艺术“对吧？推荐一下我经常使用但是也不会特别复杂的设计模式。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;设计模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这是最常使用的设计模式之一。&lt;/p&gt;&lt;p&gt;工厂模式分为简单工厂模式、工厂方法模式和抽象工厂模式。我们这里讲解简单工厂模式，因为后两个都是以其为基础做改进的。&lt;/p&gt;&lt;p&gt;其结构如下：&lt;/p&gt;&lt;p&gt;通过定义一个用以创建对象的接口, 让子类决定实例化哪个类。&lt;/p&gt;&lt;p&gt;所以其实质就是由一个&lt;span&gt;&lt;strong&gt;工厂类&lt;/strong&gt;&lt;/span&gt;根据传入的参数，动态决定应该创建哪一个&lt;span&gt;&lt;strong&gt;产品类&lt;/strong&gt;&lt;/span&gt;（这些产品类继承自一个父类或接口）的实例。&lt;/p&gt;&lt;p&gt;其包含以下角色：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工厂（Creator）角色：工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽象产品（Product）角色：它负责描述所有实例所共有的公共接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;具体产品（Concrete Product）角色：创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7542662116040956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCXIK0pgicLiaD7Z85x3iaOtf3o1kDZ52SXD1x0EJK9Rbfv4u8SwcK6VsFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当遇到&lt;span&gt;&lt;strong&gt;需要根据某个前提条件创建不同的类实现&lt;/strong&gt;&lt;/span&gt;时, 可以使用工厂模式。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;它是在不必改变原类结构和继承体系的情况下，&lt;span&gt;&lt;strong&gt;动态地扩展一个对象的功能&lt;/strong&gt;&lt;/span&gt;。通过创建一个包装对象来实现对功能的扩展，动态的给一个对象添加一些额外的职责。&lt;/p&gt;&lt;p&gt;所以装饰者模式分为主体和装饰者。&lt;/p&gt;&lt;p&gt;其包含角色如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主体(Main)：业务主体逻辑、字段等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主体具体实现类(MainComponent)：主体具体的实现类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者(Decorator)：要做的装饰扩展逻辑接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者具体实现类(DecoratorComponent)：扩展逻辑的具体实现类。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8079306071871127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCcgZEzhmfGdBJCh6Q81AMXdhic2ptOOFm3pC2oc2ZpbFT5wYoXYX8xGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;以上两种设计模式都有着”高扩展性“的特点，我们应该根据业务灵活设计接口，避免需求迭代导致的一坨坨又臭又长的代码。但是设计模式切勿用来炫技，一些较为冷门或者复杂的设计模式不推荐使用，否则当一套代码只有你能维护时，那将会是非常痛苦的。。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.048936170212766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCI02rkLsOYib9L96vwjmsEdIxgrs1PdPSK6Q5eBxlbhdQFOib33qia5pwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然了这也能够体现出你在公司的不可替代性！&lt;/p&gt;&lt;h2&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;系统高性能 &amp;amp; 高可用&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用缓存：缓存的作用是为了系统的读能力。将用户经常访问的数据扔到缓存里面可以有效地提高访问速度并且减少数据库的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44224924012158057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC8n2ZyJe4ib4gfvmmnXdfe0poibt5ibTYJHwVv7FoPJkYCpfctzgwb7r7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务降级 &amp;amp; 限流：若短时间内流量激增影响到服务器性能，可考虑降级边缘业务以保证核心业务的可用性和性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4322766570605187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC5tkzPCuatndJJX2bkxQDzgaM8UibMOv697hibibtohvRlvJzHcYEiaVceg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;分布式系统 &amp;amp; 服务拆分：&lt;/span&gt;&lt;span&gt;将整个系统拆分成不同的业务模块再部署到对应的服务器中，服务之间通过中间件通信，可以有效地避免&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;和减少单一服务故障对整体系统的影响。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8859934853420195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCqQk284qq9Hlvwjq2FicBuoKxI5CAoLvFtF7ibNqNqRLZbIOJww1n0FwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;高可用架构：重要性不言而喻。同城多活、异地多活的架构部署可以保证单机房挂掉的情况下流量可以迅速切换到其他机房让核心业务不受影响。可谓是防止系统宕机必备良药啊！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3461909353905497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC7oHh2fLKwicHLEEOhH2Gibhyuv95YZJJ6pdfYXQwzeStv9UPBwbww9Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;做好事故复盘&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;都说小事故伤身，大事故提桶。。一般发生事故后写一张事故单是不可避免的。除了详细描述好事故发生的经过，背锅人，解决方案，后续的事故跟进也是一系列流程的事，多则需要数周去跟进。事故的发生对于团队的技术发展和成型往往起着积极推进作用，所以对于每一个团队来说事故一定是不可避免的。每次事故发生我们都要思考如何完善系统，打破技术壁垒。并且遇到事儿也不要慌，如果是大问题，那么首先背锅的一定是leader！&lt;/p&gt;&lt;p&gt;其实呢一般公司最喜欢的是能快速解决问题的员工，即便这些问题可能是由你创造的。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;此外，我最近打算把新建的技术交流群，打造成一个活跃的高质量技术群。群里不定期有送书，发红包活动，工作中遇到的技术问题，都可以在里面咨询大家，还有工作内推的机会。有兴趣的小伙伴，欢迎加群。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;扫描回复：加群，即可入群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDE9vvfu1eb0KdQmjCiceE3xr7JF0cvK0z4UwCNyKO4UsMg5Urfro5qzoU2NWfgthCjwENmLxK6Nxyw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7173f8261427d1d1fc73a9c8fafa64c6</guid>
<title>科普 | NFT 如何在链上存储？又如何去中心化的在链下存储？</title>
<link>https://toutiao.io/k/43w7xzr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages __bg_gif wxw-img&quot; data-backh=&quot;103&quot; data-backw=&quot;544&quot; data-ratio=&quot;0.1889763779527559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VBPpJdUKSXze4F3I2lx9cvGkJtJ73eKgYCz32ke4bjJwaJeCu4fCecTiaZnwGjQI5MFRYU0y7PPEZAkPLrtm60A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;这是白话区块链的第&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1765&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;期原创 &lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;作者 | &lt;/span&gt;&lt;/span&gt;&lt;span&gt;moreReese&lt;br/&gt;&lt;/span&gt;&lt;span&gt;编译 | 火火&lt;br/&gt;&lt;span&gt;出品｜白话区块链（ID：hellobtc）&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;NFT  ，终极意义上说，是一种数字媒体形式，就像其他数字媒体一样，从Decrypt文章中的文字到 YouTube 视频和流媒体音乐&lt;strong&gt;，最基本的形式都是由 1 和 0 组成的数据，NFT 也不列外。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;理解这点这很重要，因为与 NFT 相关的一切，&lt;strong&gt;从它所在的智能合约到你用来查看它的 URL 再到图像本身，最终都可以被归结为存储在计算机上的 1 和 0。&lt;br/&gt;&lt;/strong&gt;&lt;br/&gt;然而，并非所有 NFT 存储技术都是一样的。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; 01 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;相关核心概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;事实上，一些 NFT 持有者可能只是拥有一个 URL 或令牌 ID。因此，在考虑购买或制作 NFT 之前，值得花些时间了解一下 NFT 存储的工作原理。&lt;br/&gt;&lt;br/&gt;首先，需要搞明白以下这些核心概念：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;服务器&lt;/strong&gt;——服务器就是一台计算机，就像您正在阅读本文的那台计算机（如果您正在用电脑阅读本文的话）一样。然而，与您正在阅读本文的计算机不同，服务器异常强大，可以同时运行许多不同的程序。&lt;strong&gt;从根本上讲，NFT 存在并存储在服务器上。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;托管&lt;/strong&gt;——绝大多数人不运行自己的服务器，因此，无论是否意识到，他们都依赖其他人来提供该服务。&lt;strong&gt;托管通常是指服务器提供的服务集合，包括存储。所有 NFT 都托管在某个地方。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;元数据&lt;/strong&gt;——元数据&lt;strong&gt;是描述其他数据的数据。元数据帮助服务器更有效地查找、处理和存储数据。&lt;/strong&gt;比如对于对于 PFP NFT，其元数据描述了名称、颜色、大小、形状、帽子类型、眼镜类型等特征。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;哈希&lt;/strong&gt;——哈希是一种加密函数，给定一些输入，每次都会产生相同的输出。哈希通常用于对大量信息进行可验证且有效的编码。&lt;strong&gt;NFT 及其所有元数据可以存储在单个哈希中。&lt;/strong&gt;要想亲身体验哈希函数，可以去查看相关哈希生成器。&lt;br/&gt; &lt;br/&gt;&lt;span&gt;注：Hash，一般翻译做散列、杂凑，或音译为哈希。是将任意长度的数据映射到有限长度的域上。直观解释起来，就是对一串数据m进行杂糅，输出另一段固定长度的数据h，作为这段数据的特征（指纹）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;智能合约&lt;/strong&gt;——智能合约是存在于区块链上的编码指令。它们是去中心化应用程序（dapps）的一部分，包括大多数 NFT。&lt;strong&gt;铸造和交换 NFT 的规则存在于智能合约中。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt; 02 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;链上存储与链下存储&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;将 NFT 存储在链上意味着整个 NFT（图像及其所有元数据）都存在于区块链上。相反，链下存储的 NFT 意味着部分或大部分 NFT 存储在区块链之外。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;链上存储的方式更可取，因为这意味着用户可以验证 NFT 的所有方面。但是，很少有 NFT 项目选择这种存储方法。因为数据太多就会导致需要大量存储空间，这意味着费用也很高昂。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;Autoglyphs就是一个例子。原因很简单——JPEG 图像包含大量数据，尤其是当这些图像存在于数千或数万个集合中时。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;因此，大多数 NFT 项目选择将实际图像存储在链下。&lt;/strong&gt;许多知名的 NFT 项目，如CryptoPunks和 Bored Ape Yacht Club 都选择了链下存储。&lt;/p&gt;&lt;br/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 03 &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;集中式与分散式托管&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在链下存储的情况下，NFT 的智能合约包含指向实际存储 NFT JPEG 图像的某个链下位置的信息&lt;/strong&gt;。通常，NFT 图像及其元数据存储在哈希函数中，即指集中式或分散式托管服务提供商。&lt;br/&gt;&lt;br/&gt;包括亚马逊和谷歌，都属于集中式托管服务提供商。集中式托管服务提供商运行的服务器存储构成 NFT 的 1 和 0数据。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;中心化托管服务提供商的风险在于（尽管不太可能）他们可能随时关闭服务器，可能会导致所有者的 NFT 丢失。&lt;/strong&gt;在某些情况下，所有者可能将只剩下智能合约中存在的一个无用的哈希数值。&lt;br/&gt;&lt;br/&gt;这就是为什么许多项目选择使用去中心化解决方案来托管他们的 NFT。最常见的解决方案是在星际文件系统 ( IPFS ) 上托管 NFT 数据。IPFS 是一个分布式的点对点网络，文件存储在多个节点上，使其能够抵抗单点故障，例如服务器故障问题。&lt;br/&gt;&lt;br/&gt;&lt;span&gt;注：星际文件系统（InterPlanetary File System，缩写为IPFS）是一个旨在实现文件的分布式存储、共享和持久化的网络传输协议。&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;虽然存储在 IPFS 上的 NFT 在技术上并未存储在链上，但它们在理论上更安全，因为 IPFS 具有抗审查性；且没有任何一个实体有权关闭它。&lt;/p&gt;&lt;p&gt;以上就是NFT存储的两种方式了。&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;你有购买NFT吗？如果有，你的NFT是如何存储的呢？欢迎评论区交流讨论。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;原文标题：How Are NFTs Stored? On-Chain, Off-Chain and Decentralized Storage&lt;br/&gt;原文链接：https://decrypt.co/resources/how-are-nfts-stored-on-chain-off-chain-and-decentralized-storage &lt;br/&gt;原文作者：moreReese &lt;br/&gt;编译：火火&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上一篇&lt;/strong&gt;：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNzE4MDM2MA==&amp;amp;mid=2247519648&amp;amp;idx=2&amp;amp;sn=45f246efdf6f4446c1f889d83cc47523&amp;amp;chksm=fa01ba87cd76339160ffbe9375496df95be21b232632dfcf6f8d2c7fc80d4a68ad760c641e71&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;科普 | Defi中的关键，智能合约是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;科普 | Defi中的关键，智能合约是什么？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;『声明：本文为作者独立观点，不代表白话区块链立场，本内容仅供广大加密爱好者科普学习和交流，不构成投资意见或建议，请理性看待，树立正确的理念，提高风险意识。文章版权和最终解释权归白话区块链所有。』&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欢迎长按二维码&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;阅读&lt;/span&gt;&lt;/span&gt;&lt;span&gt;白话区块链入门连载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;↓↓↓&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;267&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.46254071661237783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/VBPpJdUKSXzLqKlHeiaSHHIHxkUQmX411TvnRldenptHibfTBOicqTiaBQNYUAdv5XrAP1jTz19wuC8IqX9305ibdbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;喜欢请点「在看」&lt;/strong&gt;&lt;/span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;👇&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>