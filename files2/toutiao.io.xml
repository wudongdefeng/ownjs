<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f5e5a4ec66322c2914ea06dfb8cd5d04</guid>
<title>【大厂面试真题解析】虾皮 Shopee 后端一面十四问</title>
<link>https://toutiao.io/k/pol71im</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;关于我：微信公众号：面试官问，原创高质量面试题，始于面试题，但不止于面试题。【大厂面试真题解析】面试系列文章将会对大家实际面试中遇到的面试题进行汇总分析，以飨读者。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;本文是作者 &lt;span&gt;gopherhiro&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 近期面试 Shopee 被问到的问题，本文节选了其中通用的部分进行了解析，欢迎读者将面试中遇到的问题私信我，可以帮大家整理出回答的要点。&lt;/p&gt;&lt;h2&gt;MySQL&lt;/h2&gt;&lt;h3&gt;1. 为什么要分库分表&lt;/h3&gt;&lt;p&gt;单个数据库实例能够承载的并发访问量和数据量是有限的，当系统的并发访问量或者数据量超过这个限制时，就需要考虑使用分库分表来优化系统的架构设计，使其能够承载更大的并发量和数据量，并给用户提供良好的使用体验。当然，分库和分表其实是两个事情，两者并不是都会同时出现。&lt;/p&gt;&lt;h3&gt;2. 分库解决了什么问题&lt;/h3&gt;&lt;p&gt;分库主要解决的是&lt;strong&gt;并发量大&lt;/strong&gt;的问题，因为单个数据库实例能够提供的连接数是有限的，当系统并发量不断增加，我们势必需要增加更多的微服务实例来承载更多的业务请求，而每个微服务实例都会占用一定量的数据库连接，因此，当数据库连接数不够用了，就只能通过增加数据库实例的方式来提供更多的数据库连接，进而提升系统整体的并发度。&lt;/p&gt;&lt;h3&gt;3. 分表解决了什么问题&lt;/h3&gt;&lt;p&gt;分表主要解决的是&lt;strong&gt;数据量大&lt;/strong&gt;的问题，因为单表的数据量很大时，即使并发访问量不大，但单表的存储和查询的性能已经遭遇了瓶颈，通过索引优化等手段虽然能够一定程度上提升效率，但当单表数据量超过 500 万行或者单表存储容量超过 2GB（经验值，实际要看业务的具体情况） 之后，分表就应该提上日程了。一般都是将数据拆分到多张表中，来减少单表的数据量，从而提升查询的速度。&lt;/p&gt;&lt;h3&gt;4. 乐观锁与悲观锁？在实践中是否用过，可否举例说明一下。&lt;/h3&gt;&lt;p&gt;乐观锁实际上并没有加锁，只是一种锁思想，一般通过在行数据上添加&lt;strong&gt;版本号字段&lt;/strong&gt;实现，在更新数据前，先查询出当前行数据的版本号，更新数据时，将版本号加1，并判断数据库中版本号是否等于前面我们读取出来的版本号，如果不一致，说明数据被修改过，更新失败。乐观锁的核心语句是：&lt;code&gt;update table set ... version=version+1 where id=#{id} and version=#{version};&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;乐观锁使用场景&lt;/strong&gt;：比较适合读多写少的场景，因为如果出现大量的写入操作，version字段值发生冲突的可能性就会增大，更新失败后，应用层需要不断的重新获取最新version字段数据，并重试操作，这样会增加大量的查询操作，降低了系统的吞吐量。&lt;/p&gt;&lt;p&gt;悲观锁一般是使用 &lt;code&gt;select ... for update;&lt;/code&gt; 语句锁定行数据，更新完提交事务后自动释放行数据，在此期间，其他事务无法更新这一行数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;悲观锁使用场景&lt;/strong&gt;：比较适合写多读少的场景，因为如果出现大量的读取操作，每次读的时候都进行加锁，会增加大量的锁的开销，降低了系统的吞吐量。&lt;/p&gt;&lt;h3&gt;5. 主键索引和唯一索引的区别？&lt;/h3&gt;&lt;p&gt;MySQL 数据库索引按照功能进行划分，可以分为：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;普通索引：没有任何的约束作用，它存在的主要意义就是提高查询效率。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;唯一索引：在普通索引的基础上，增加了唯一性约束，要求索引列的值必须唯一，但可以为空值，一张表中可以同时存在多个唯一性索引&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;主键索引：在唯一性索引的基础上又增加了不为空的约束，而且一张表里最多只能有一个主键索引，但一个主键索引中可以包含多个字段。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;全文索引：实际上用的不多，不做介绍&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;Redis&lt;/h2&gt;&lt;h3&gt;1. Redis 崩溃时，如何保证数据不丢失？&lt;/h3&gt;&lt;p&gt;Redis 是一个内存键值对数据库，如果服务器进程挂掉，内存中的数据就会丢失，为了避免数据丢失，Redis 提供了三种持久化方案：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;RDB 持久化：Redis DataBase，将内存中的数据以快照（二进制）的形式保存到磁盘上，是 Redis 默认的持久化方式。执行完 RDB 持久操作后，会在指定的目录中生成一个 &lt;code&gt;dump.rdb&lt;/code&gt; 文件，在 Redis 重启时，会加载 &lt;code&gt;dump.rdb&lt;/code&gt; 文件来恢复数据到内存中。RDB 持久化可以通过手动和自动两种方式触发：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;手动方式：同步方式 save，会阻塞 Redis 主线程；异步方式 bgsave，会 fork 一个子进程，由子进程负责 RDB 文件的操作，避免阻塞 Redis 服务主进程&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;自动方式：save m n，当 m 秒内数据集发生 n 次修改时，自动触发 bgsave&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;AOF 持久化：Append Only File，基于日志来记录 Redis 的每个写操作，每个操作会追加到文件的末尾。Redis 默认不开启 AOF。需要注意的是，AOF 是在执行完 Redis 命令才记录日志的，而不是执行之前，因为 Redis 是不会对输入的命令进行语法检查的，因此，只有真正执行完命令后，才能避免将非法的命令写入 AOF 文件中。AOF 持久化方案有三种日志写回策略 &lt;code&gt;appendfsync&lt;/code&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;always：同步执行日志写回，也就是在每个命令执行完之后，立即将日志写入 AOF 文件末尾&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;everysec：每隔一秒将 AOF 内存缓冲区中的日志刷新到磁盘中&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;no：Redis 只负责将日志写入到 AOF 内存缓冲区中，由操作系统的刷盘机制决定什么时候写入磁盘&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;混合持久化：RDB 方式的优点是文件相比 AOF 小，数据恢复快，适合大规模数据恢复场景，例如数据备份等；AOF 的优点是数据一致性和完整性相比 RDB 高，通常使用 everysec 写回策略保证只有秒级的数据丢失。为了中和两者的优缺点，Redis 4.0 引入了混合持久化，也就是在两次 RDB 持久化中间，会增加 AOF 操作来记录这段时间的日志。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;2. Redis 基本数据类型及其使用场景有哪些？&lt;/h3&gt;&lt;p&gt;Redis 有五种常用的基本数据类型：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;字符串 String：不同微服务实例之间 session 共享，分布式锁、ID生成器、计数器、限速器等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;列表 List：实现消息队列功能，缓存文章列表信息等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;哈希 Hash：缓存用户信息 UserInfo（可能包含 userId、userName、password、email 等字段）、实现短网址生成程序&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;集合 Set：存储用户的标签信息、唯一计数器、点赞等功能&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;有序集合 ZSet：实现排行榜、时间线等功能&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;3. Redis zset 数据类型底层是如何实现的？&lt;/h3&gt;&lt;p&gt;Redis zset 底层数据结构有两种选型：压缩列表 ziplist 和跳表 skiplist，具体选择哪种数据结构要看当前存储的数据量和数据大小。当满足如下两个条件时，Redis 选择 ziplist 来实现 zset 值的存储：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;所有数据的大小都要小于 64 字节&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;元素个数小于 128 个&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当不满足以上两个条件时，则会选择使用 skiplist 来实现 zset 值的存储。&lt;/p&gt;&lt;p&gt;压缩列表是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它允许存储的数据大小不同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3336252189141856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cyZVqTO3RQaRciaEOwWx8dbWYj25C8BsoHmt2NJEsUX5OYiasQhbsJmNdT646cjfe28lyO8NK1eiaqbEAC3iaLfVsw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于压缩列表更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;跳表 skiplist 是在单链表基础上增加了多级索引实现的一个数据结构，能够实现 O(logn) 时间复杂度的查找、插入和删除操作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5805604203152365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cyZVqTO3RQaRciaEOwWx8dbWYj25C8BsoVnoP3Y2t9sQ3ic4TiaFbHDHf7sKEOqJM1EsJRo3m9AEV38l1F7HiaTDDg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;关于跳表更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;17 | 跳表：为什么Redis一定要用跳表来实现有序集合？&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;4. Redis 分布式锁是如何实现的？&lt;/h3&gt;&lt;p&gt;通过调用 Redis 命令 SETNX+EXPIRE 实现，同时为了保证原子性，可以通过 lua 脚本来实现锁的设置和过期时间设置的原子性。在 Redis 2.6.12 版本后，SETNX 命令增加了过期时间参数，也可以直接使用这个重载方法，SETNX 返回 1 表示获得 key 所代表的锁，返回 0 表示获取锁失败。&lt;/p&gt;&lt;p&gt;更多关于分布式锁的问题，可以参考&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNzkyMTE5OQ==&amp;amp;mid=2247483678&amp;amp;idx=1&amp;amp;sn=7d589fc1040c404c750a23d471e86ed6&amp;amp;scene=21#wechat_redirect&quot; title=&quot;场景化面试：关于分布式锁的十问十答&quot; data-linktype=&quot;2&quot;&gt;场景化面试：关于分布式锁的十问十答&lt;/a&gt;这篇文章。&lt;/p&gt;&lt;h3&gt;5. Redis分布式锁过期了但业务还没有执行完，怎么办？&lt;/h3&gt;&lt;p&gt;这种情况可以通过锁续约机制来解决，也就是通过另外一个线程使用心跳机制来不断延长锁的超时时间。&lt;/p&gt;&lt;h2&gt;业务监控相关&lt;/h2&gt;&lt;h3&gt;1. 所做业务接口性能耗时是多少？&lt;/h3&gt;&lt;p&gt;按你的系统实际回答即可，针对一般 OLTP 系统来说，接口耗时应该小于 500ms，对于高频接口，应该保证在 200ms 以内，具体还是要针对具体业务进行分析。&lt;/p&gt;&lt;h3&gt;2. 所做业务 QPS 大致是多少？&lt;/h3&gt;&lt;p&gt;这个主要是了解你的项目的并发情况，看你是否有高并发的相关经验，即使你的项目本身 QPS 不高，也应该准备下高并发相关的知识以便应对。&lt;/p&gt;&lt;h3&gt;3. 如何理解 p 分位？如 p99，p95。&lt;/h3&gt;&lt;p&gt;响应时间是指从前端发出请求开始到最后收到响应所需要的时间，对于互联网服务来说，响应时间我们更应该关注&lt;strong&gt;分位线&lt;/strong&gt;，也就是常说的 TP95、TP99 或 95 线、99 线。&lt;/p&gt;&lt;p&gt;对于 TP95而言，就是将对应接口所有请求的响应时间从小到大排序，位于 95% 这个位置的请求的响应时间，它表示至少有 95% 的请求响应时间小于等于这个值。&lt;/p&gt;&lt;h2&gt;系统设计&lt;/h2&gt;&lt;h3&gt;1. 如何设计一个分布式 ID 生成器？&lt;/h3&gt;&lt;p&gt;分布式 ID 必须保证全局唯一性，常见的方案有 UUID 和雪花算法（Snowflake）两种方案，但 UUID 相比雪花算法存在如下缺点，所以一般来说，我们都会选择雪花算法，并根据具体的业务场景进行改造：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;UUID 生成的 id 是无序的，而 Snowflake 生成的 id 是有序的，id 有序能够支持排序，也能够提升数据的写入性能&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;UUID 不具备业务含义，但 Snowflake 具备业务含义，Snowflake 的核心思想是将 64bit 的二进制数字分成若干部分，每一部分都存储有特定含义的数据，标准的 Snowflake 算法包含 1 位符号位、41 位时间戳、10 位机器 id、12 位序列号，最终拼接生成全局唯一的有序 id。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通常来说，对 Snowflake 的改造是保持前面 42 位生成方式不变，调整后面的 22 位比特位，在其中加入业务相关的信息。&lt;/p&gt;&lt;p&gt;分布式 ID 生成器的算法确定后，我们可以将其作为一个 jar 包提供给业务方使用，或者也可以将其独立封装成一个基础服务对外提供 API。具体可以根据自己项目的实际情况确定。&lt;/p&gt;&lt;p&gt;关于分布式 ID 生成器更详细介绍可以参考极客时间的这篇文章：&lt;span&gt;10 | 发号器：如何保证分库分表后ID的全局唯一性？&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; gopherhiro: &lt;em&gt;https://leetcode.cn/u/gopherhiro/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 52 | 算法实战（一）：剖析Redis常用数据类型对应的数据结构: &lt;em&gt;http://gk.link/a/11xJc&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 17 | 跳表：为什么Redis一定要用跳表来实现有序集合？: &lt;em&gt;http://gk.link/a/11xJd&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 10 | 发号器：如何保证分库分表后ID的全局唯一性？: &lt;em&gt;http://gk.link/a/11xJA&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>082aa303ff5ba9955cbbb2247a65b9d8</guid>
<title>go并发</title>
<link>https://toutiao.io/k/qx0xu7l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;blog-copy w-richtext&quot;&gt;&lt;p&gt;Concurrency is one of those things that&#x27;s easy to get wrong, even with Go concurrency features. Let&#x27;s review things you should consider while writing a concurrency production code.&lt;/p&gt;&lt;p&gt;The guide is split into three parts, each with a different purpose. First, we&#x27;ll talk about &quot;Rules of Thumb,&quot; which are usually the right thing to do. The second part is on what to use for writing concurrent code. And finally, we&#x27;ll cover how to write your custom concurrency primitives.&lt;/p&gt;&lt;p&gt;Before we start, I should mention that many of these recommendations will have conditions where they are not the best choice. The main situations are going to be performance and prototyping.&lt;/p&gt;&lt;h3&gt;Avoid Concurrency&lt;/h3&gt;&lt;p&gt;I&#x27;ve seen many times people using concurrency where you should not use it. It should go without saying, don&#x27;t add concurrency unless you have a good reason.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup

wg.Add(1)
go serve(&amp;amp;wg)
wg.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;p&gt;The concurrency here is entirely unnecessary, but I&#x27;ve seen this exact code in a repository. System without concurrency is much easier to debug, test and understand.&lt;/p&gt;&lt;p&gt;People also add concurrency because they think it will speed up their program. In a production environment, you are handling many concurrent requests anyways, so making one part concurrent doesn&#x27;t necessarily make the whole system faster.&lt;/p&gt;&lt;h3&gt;Prefer Synchronous API&lt;/h3&gt;&lt;p&gt;A friend of the previous rule is to prefer synchronous API. As mentioned, non-concurrent code is usually shorter and easier to test and debug.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;server.Start(ctx)
server.Stop()
server.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;p&gt;If you need concurrency when using something, it&#x27;s relatively easy to make things concurrent. It&#x27;s much more difficult to do the reverse.&lt;/p&gt;&lt;h3&gt;Use -race and t.Parallel()&lt;/h3&gt;&lt;p&gt;There are two excellent Go features that help you shake out concurrency bugs from your code.&lt;/p&gt;&lt;p&gt;First is -race, which enables the race detector to flag all the observed data races. It can be used with go test -race ./... or go build -race ./yourproject. See &lt;a href=&quot;https://go.dev/doc/articles/race_detector&quot;&gt;Data Race Detector&lt;/a&gt; for more details.&lt;/p&gt;&lt;p&gt;Second mark your tests with t.Parallel():&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func TestServer(t *testing.T) {
t.Parallel()
// ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This makes your tests run in parallel, which can speed them up, but it also means you are more likely to find a hidden shared state that doesn&#x27;t work correctly in concurrent code. In addition to finding bugs in our codebases, we&#x27;ve also found them in third-party libraries.&lt;/p&gt;&lt;h3&gt;No global variables&lt;/h3&gt;&lt;p&gt;Avoid global variables such as caches, loggers, and databases.&lt;/p&gt;&lt;p&gt;For example, it&#x27;s relatively common for people to use log.Println inside their service, and their testing output ends in the wrong location.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func TestAlpha(t *testing.T) {
t.Parallel()
log.Println(&quot;Alpha&quot;)
}

func TestBeta(t *testing.T) {
t.Parallel()
log.Println(&quot;Beta&quot;)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The output from go test -v will look like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;=== RUN   TestAlpha
=== PAUSE TestAlpha
=== RUN   TestBeta
=== PAUSE TestBeta
=== CONT  TestAlpha
=== CONT  TestBeta
2022/07/24 10:59:06 Alpha
--- PASS: TestAlpha (0.00s)
2022/07/24 10:59:06 Beta
--- PASS: TestBeta (0.00s)
PASS
ok      test.test       0.213s&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice how the &quot;Alpha&quot; and &quot;Beta&quot; are out of place. The code under test should call t.Log for any testing needs; then, the log lines will appear in the correct location. There&#x27;s no way to make it work with a global logger.&lt;/p&gt;&lt;h3&gt;Know when things stop&lt;/h3&gt;&lt;p&gt;Similarly, it&#x27;s relatively common for people to start goroutines without waiting for them to finish. &lt;em&gt;go &lt;/em&gt;keyword makes starting goroutines very easy; however, it&#x27;s not apparent that you also must wait for them to stop.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;go ListenHTTP(ctx)
go ListenGRPC(ctx)
go ListenDebugServer(ctx)
select{}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;g, ctx := errgroup.WithContext(ctx)
g.Go(func() error {
return ListenHTTP(ctx)
}
g.Go(func() error {
return ListenGRPC(ctx)
}
g.Go(func() error {
return ListenDebugServer(ctx)
}
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When you don&#x27;t know when things stop, you don&#x27;t know when to close your connections, databases, or log files. For example, some stray goroutine might use a closed database and cause panic.&lt;/p&gt;&lt;p&gt;Similarly, when you wait for all goroutines to finish, you can detect scenarios when one of the goroutines has become indefinitely blocked.&lt;/p&gt;&lt;h3&gt;Context aware code&lt;/h3&gt;&lt;p&gt;The next common issue is not handling context cancellation. It usually won&#x27;t be a problem in the production system itself. It&#x27;s more of an annoyance during testing and development. Let&#x27;s imagine you have a time.Sleep somewhere in your code:&lt;/p&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;tick := time.NewTimer(time.Minute)
defer tick.Stop()

select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;time.Sleep cannot react to any code, which means when you press Ctrl-C on your keyboard, it will stay on that line until it finishes. This can increase your test times due to some services shutting down slowly. Or, when doing upgrades on your servers, it can make them much slower to shut down.&lt;/p&gt;&lt;p&gt;&lt;em&gt;The code for the waiting on the right is much longer, but we can write helpers to simplify it.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;The other scenario where this cancellation comes up is long calculations:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, f := range files {
data, err := os.ReadFile(f)
// ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, f := range files {
if err := ctx.Err(); err != nil {
return err
}

data, err := os.ReadFile(f)
// ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we can introduce a ctx.Err() call to check whether the context has been cancelled. Note ctx.Err() call is guaranteed to be concurrency safe, and it&#x27;s not necessary to check ctx.Done() separately.&lt;/p&gt;&lt;h3&gt;No worker pools&lt;/h3&gt;&lt;p&gt;People coming from other languages often resort to creating worker pools. It&#x27;s one of those tools that&#x27;s necessary when you are working with threads instead of goroutines.&lt;/p&gt;&lt;p&gt;There are many reasons to not use worker pools:&lt;/p&gt;&lt;ul role=&quot;list&quot;&gt;&lt;li&gt;They make stack traces harder to read. You&#x27;ll end up having hundreds of goroutines that are on standby.&lt;/li&gt;&lt;li&gt;They use resources even if they are not working.&lt;/li&gt;&lt;li&gt;They can be slower than spawning a new goroutine.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;You can replace your worker pools with a goroutine limiter -- something that disallows from creating more than N goroutines.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
queue := make(chan string, 8)
for k := 0; k &amp;lt; 8; k++ {
wg.Add(1)
go func() {
defer wg.Done()
for work := range queue {
process(work)
}
}()
}

for _, work := range items {
queue &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
limiter := make(chan struct{}, 8)
for _, work := range items {
work := work
wg.Add(1)
limiter &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We&#x27;ll later show how to make a limiter primitive easier to use.&lt;/p&gt;&lt;h3&gt;No polling&lt;/h3&gt;&lt;p&gt;Polling another system is rather wasteful of resources. It&#x27;s usually better to use some channel or signal to message the other side:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lastKnown := 0
for {
time.Sleep(time.Second)
t.mu.Lock()
if lastKnown != t.current {
process(t.current)
lastKnown = t.current
}
t.mu.Unlock()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lastKnown := 0
for newState := range t.updates {
if lastKnown != newState {
process(newState)
lastKnown = newState
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Polling wastes resources when the update rates are slow. It also responds to changes slower compared to notifying directly. There are many ways to avoid polling, which could be a separate article altogether.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Of course, if you are making an external request and the external API is out of your control, you might not have any other choice than to poll.&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Defer unlocks and waits&lt;/h3&gt;&lt;p&gt;It&#x27;s easy to forget an mu.Unlock, wg.Wait or close(ch). If you always defer them, it will be much easier to see when they are missing.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, item := range items {
service.mu.Lock()
service.process(item)
service.mu.Unlock()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;for _, item := range items {
func() {
service.mu.Lock()
defer service.mu.Unlock()

service.process(item)
}()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Even if your initial code is correct, then code modification can introduce a bug. For example, adding a return inside the loop after the mu.Lock() would leave the mutex locked.&lt;/p&gt;&lt;h3&gt;Don’t expose your locks&lt;/h3&gt;&lt;p&gt;The larger the scope where the locks can be used, the easier it is to make a mistake.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Set[T any] struct {
sync.Lock
Items []T
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;❯&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Set[T any] struct {
mu    sync.Lock
items []T
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Name your goroutines&lt;/h3&gt;&lt;p&gt;You can make your debugging and stack traces much nicer by adding names to your goroutines:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;labels := pprof.Labels(&quot;server&quot;, &quot;grpc&quot;)
pprof.Do(ctx, labels,
func(ctx context.Context) {
// ...
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There&#x27;s an excellent article &quot;&lt;a href=&quot;https://rakyll.org/profiler-labels/&quot;&gt;Profiler labels in Go&lt;/a&gt;&quot;, which explains how to use them.&lt;/p&gt;&lt;h2&gt;Concurrency Primitives&lt;/h2&gt;&lt;p&gt;When it comes to writing production code, it&#x27;s a bad idea to use some concurrency primitives directly in your code. They can be error-prone and make code much harder to reason about.&lt;/p&gt;&lt;p&gt;When choosing primitives, prefer them in this order:&lt;/p&gt;&lt;ol role=&quot;list&quot;&gt;&lt;li&gt;no-concurrency&lt;/li&gt;&lt;li&gt;golang.org/x/sync/errgroup, golang.org/x/sync, sync.Once&lt;/li&gt;&lt;li&gt;custom primitive or another library&lt;/li&gt;&lt;li&gt;sync.Mutex in certain scenarios&lt;/li&gt;&lt;li&gt;select {&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;However, many others are useful when used for implementing your custom primitives:&lt;/p&gt;&lt;ol start=&quot;5&quot; role=&quot;list&quot;&gt;&lt;li&gt;sync.Map, sync.Pool (use a typesafe wrapper)&lt;/li&gt;&lt;li&gt;sync.WaitGroup&lt;/li&gt;&lt;li&gt;chan, go func() {&lt;/li&gt;&lt;li&gt;sync.Mutex, sync.Cond&lt;/li&gt;&lt;li&gt;sync/atomic&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;If you are surprised that chan and go func() { are so low on the list, we&#x27;ll show how people make tiny mistakes with them.&lt;/p&gt;&lt;h3&gt;Common Mistake #1: go func()&lt;/h3&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func (server *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
...
// start an async operation
go func() {
res, err := server.db.ExecContext(r.Context(), &quot;INSERT ...&quot;)
...
}()
...
}

func main() {
...

db, err := openDB(ctx)
defer db.Close()

err := server.Run(ctx)
...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice there&#x27;s no guarantee that the goroutine finishes before the database is closed. This can introduce weird test failure, where you try to insert into a closed database.&lt;/p&gt;&lt;p&gt;Similarly, another bug, r.Context() could be cancelled prematurely. Of course, this depends on the problem specifics, but when you start a background operation from your handler, you don&#x27;t want the user to cancel it.&lt;/p&gt;&lt;h3&gt;Primitive: sync.WaitGroup&lt;/h3&gt;&lt;p&gt;One of the solutions for starting goroutines is to use sync.WaitGroup. However, it also has quite a few problematic scenarios.&lt;/p&gt;&lt;p&gt;Let&#x27;s take a look at the first common mistake with sync.WaitGroup:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
defer wg.Wait()
for _, item := range items {
item := item
go func() {
process(&amp;amp;wg, item)
}()
}
}

func process(wg *sync.WaitGroup, item *Item) {
wg.Add(1)
defer wg.Done()

...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the problem is that the processConcurrently can return before wg.Add is called. This means that we don&#x27;t wait for all the goroutines to finish.&lt;/p&gt;&lt;p&gt;The other scenario comes up when people incrementally change code:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
wg.Add(len(items))
defer wg.Wait()
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
go func() {
defer wg.Done()
process(item)
}()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice how we moved the call to wg.Done outside of the process, making it easier to track the full concurrency. However, due to the extra if filepath.Ext statement, the code is wrong. That check was probably added by someone else at a later time. Similarly, it&#x27;s one of those cases where tests might easily miss the problem.&lt;/p&gt;&lt;p&gt;To fully fix the code, it should look like this:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) {
var wg sync.WaitGroup
defer wg.Wait()
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
wg.Add(1)
go func() {
defer wg.Done()
process(item)
}()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you don&#x27;t see the following parts when someone is using sync.WaitGroup, then it probably has a subtle error somewhere:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var wg sync.WaitGroup
defer wg.Wait()
...
for ... {
wg.Add(1)
go func() {
defer wg.Done()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Use golang.org/x/sync/errgroup&lt;/h3&gt;&lt;p&gt;Instead of sync.WaitGroup there&#x27;s a better alternative that avoids many of these issues:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func processConcurrently(item []*Item) error {
var g errgroup.Group
for _, item := range items {
item := item
if filepath.Ext(item.Path) != &quot;.go&quot; {
continue
}
g.Go(func() error {
return process(item)
})
}
return g.Wait()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;errgroup.Group can be used in two ways:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;// on failure, waits other goroutines
// to stop on their own
var g errgroup.Group
g.Go(func() error {
return publicServer.Run(ctx)
})
g.Go(func() error {
return grpcServer.Run(ctx)
})
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;// on failure, cancels other goroutines
g, ctx := errgroup.WithContext(ctx)
g.Go(func() error {
return publicServer.Run(ctx)
})
g.Go(func() error {
return grpcServer.Run(ctx)
})
err := g.Wait()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can read &lt;a href=&quot;https://pkg.go.dev/golang.org/x/sync/errgroup#Group&quot;&gt;golang.org/x/sync/errgroup documentation&lt;/a&gt; for additional information. &lt;em&gt;Note, errgroup allows to limit the number of goroutines that can be started concurrently.&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Primitive: sync.Mutex&lt;/h3&gt;&lt;p&gt;Mutex is definitely a useful primitive, however you should be careful when you use it. I&#x27;ve seen quite often code that looks like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func (cache *Cache) Add(ctx context.Context, key, value string) {
cache.mu.Lock()
defer cache.mu.Unlock()

cache.evictOldItems()
cache.items[key] = entry{
expires: time.Now().Add(time.Second),
value: value,
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You might wonder, what&#x27;s the problem here. It&#x27;s appropriately locking and unlocking. The main problem is the call to cache.evictOldItemsand that it&#x27;s not handling context cancellation. This means that requests could end up blocking behind cache.mu.Lock, and even if they are cancelled you would need to wait for it to get unlocked before you can return.&lt;/p&gt;&lt;p&gt;Instead, you can use a chan *state, which allows you to handle context cancellation properly:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Cache struct {
state chan *state
}

func NewCache() {
content := make(chan *state, 1)
content &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Even though the evictOldItems call is still there, it won&#x27;t prevent other callers to Add to cancel their request.&lt;/p&gt;&lt;p&gt;Use sync.Mutex only for cases where you need to hold the lock for a short duration. Roughly it means that the code is O(N) or better, and N is small.&lt;/p&gt;&lt;h4&gt;Primitive: sync.RWMutex&lt;/h4&gt;&lt;p&gt;sync.RWMutex has all the same problems as sync.Mutex. However, it can also be significantly slower. Similarly, it makes it easy to have data races when you write to variables during RLock.&lt;/p&gt;&lt;p&gt;In your specific scenario, you should have benchmarks demonstrating that sync.RWMutex is faster than sync.Mutex.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Details: When there are a lot of readers and no writers, there&#x27;s a cache contention between the readers because taking a read lock mutates a mutex, which is not scalable. A writer attempting to grab the lock blocks future readers from acquiring it, so long-lived readers with infrequent writers cause long delays of no work.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Either way, you should be able to demonstrate that your use of sync.RWMutex is helpful.&lt;/p&gt;&lt;h3&gt;Primitive: chan&lt;/h3&gt;&lt;p&gt;Channels are valuable things in the Go language but are also error-prone. There are many ways to write bugs with them:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;const workerCount = 100

var wg sync.WaitGroup
workQueue := make(chan *Item)
defer wg.Wait()

for i := 0; i &amp;lt; workerCount; i++ {
wg.Add(1)
go func() {
defer wg.Done()
for item := range workQueue {
process(item)
}
}()
}

err := db.IterateItems(ctx, func(item *Item) {
workQueue &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is probably one of the common ones... forgetting to close the channel. Channels also make the code harder to review compared to using higher-level primitives.&lt;/p&gt;&lt;p&gt;Using chan for communicating between different &quot;goroutine processes&quot; in your application is fine; however, ensure that you handle context cancellations and shut down properly. Otherwise, it&#x27;s easy to introduce a deadlock.&lt;/p&gt;&lt;h3&gt;Few additional rules-of-thumb&lt;/h3&gt;&lt;p&gt;I&#x27;ve come to the conclusion that you should avoid these in your domain logic:&lt;/p&gt;&lt;ul role=&quot;list&quot;&gt;&lt;li&gt;make(chan X, N)&lt;/li&gt;&lt;li&gt;go func()&lt;/li&gt;&lt;li&gt;sync.WaitGroup&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;They are error-prone, and there are better approaches. It&#x27;s clearer to write your own higher-level abstraction for your domain logic. Of course, having them isn&#x27;t an &quot;end-of-the-world&quot; issue either.&lt;/p&gt;&lt;p&gt;I should separately note that using &quot;select&quot; is usually fine.&lt;/p&gt;&lt;h2&gt;Your own artisanal concurrency primitives&lt;/h2&gt;&lt;p&gt;I told you to avoid many things in domain code, so what should you do instead?&lt;/p&gt;&lt;p&gt;If you cannot find an appropriate primitive from golang.org/x/sync or other popular libraries... you can write your own.&lt;/p&gt;&lt;blockquote&gt;Writing a separate concurrency primitive is easier to get right than writing ad hoc concurrency logic in domain code.&lt;/blockquote&gt;&lt;p&gt;There are many ways you can write such primitives. The following are merely examples of different ways how you can write them.&lt;/p&gt;&lt;h3&gt;Sleeping&lt;/h3&gt;&lt;p&gt;Let&#x27;s take a basic thing first, sleeping a bit:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func Sleep(ctx context.Context, duration time.Duration) error {
t := time.NewTimer(duration)
defer t.Stop()

select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we need to ensure that we appropriately react to context cancellation so that we don&#x27;t wait for a long time until we notice that context canceled the operation. Using this call is not much longer than time.Sleep itself:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;if err := Sleep(ctx, time.Second); err != nil {
return err
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Limiter&lt;/h3&gt;&lt;p&gt;I&#x27;ve found plenty of cases where you must limit the number of goroutines.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Limiter struct {
limit   chan struct{}
working sync.WaitGroup
}

func NewLimiter(n int) *Limiter {
return &amp;amp;Limiter{limit: make(chan struct{}, n)}
}

func (lim *Limiter) Go(ctx context.Context, fn func()) bool {
// ensure that we aren&#x27;t trying to start when the
// context has been cancelled.
if ctx.Err() != nil {
return false
}

// wait until we can start a goroutine:
select {
case lim.limit &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This primitive is used the same way as errgroup.Group:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;lim := NewLimiter(8)
defer lim.Wait()
for _, item := range items {
item := item
started := lim.Go(ctx, func() {
process(item)
})
if !started {
return ctx.Err()
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, if your limited goroutines are dependent on each other, then it can introduce a deadlock.&lt;/p&gt;&lt;p&gt;&lt;em&gt;AlsonNote that there&#x27;s a potential &quot;bug&quot; with using such a Limiter. You must not call limiter.Go after you have called limiter.Wait, otherwise the goroutine can be started after limiter.Wait has returned. This can also happen with sync.WaitGroup and errgroup.Group. One way to avoid this problem is to disallow starting goroutines after limiter.Wait has been called. It probably makes sense to rename it to &quot;limiter.Close&quot; in that case.&lt;/em&gt;&lt;/p&gt;&lt;h4&gt;Batch processing a slice&lt;/h4&gt;&lt;p&gt;Let&#x27;s say you want to process a slice concurrently. We can use this limiter to start multiple goroutines with the specified batch sizes:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Parallel struct {
Concurrency int
BatchSize   int
}

func (p Parallel) Process(ctx context.Context,
n, process func(low, high int)) error {

// alternatively, these panics could set a default value
if p.Concurrency &amp;lt;= 0 {
panic(&quot;concurrency must be larger than zero&quot;)
}
if p.BatchSize &amp;lt;= 0 {
panic(&quot;batch size must be larger than zero&quot;)
}

lim := NewLimiter(p.Concurrency)
defer lim.Wait()

for low := 0; low &amp;lt; n; low += p.BatchSize {
low, high := low, low + p.BatchSize
if high &amp;gt; n {
high = n
}

started := lim.Go(ctx, func() {
process(low, high)
})
if !started {
return ctx.Err()
}
}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This primitive allows to hide the &quot;goroutine management&quot; from our domain code:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var mu sync.Mutex
total := 0

err := Parallel{
Concurrency: 8,
BatchSize: 256,
}.Process(ctx, len(items), func(low, high int) {
price := 0
for _, item := range items[low:high] {
price += item.Price
}

mu.Lock()
defer mu.Unlock()
total += price
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Running a few things concurrently&lt;/h3&gt;&lt;p&gt;Sometimes for testing, you need to start multiple goroutines and wait for all of them to complete. You can use errgroup for it; however, we can write a utility that makes it shorter:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;func Concurrently(fns ...func() error) error {
var g errgroup.Group
for _, fn := range fns {
g.Go(fn)
}
return g.Wait()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A test can use it this way:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;err := Concurrently(
func() error {
if v := cache.Get(123); v != nil {
return errors.New(&quot;expected value for 123&quot;)
}
return nil
},
func() error {
if v := cache.Get(256); v != nil {
return errors.New(&quot;expected value for 256&quot;)
}
return nil
},
)
if err != nil {
t.Fatal(err)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;There are many variations of this. Should the function take ctx as an argument and pass it to the child goroutines? Should it cancel all the other functions via context cancellations when one error occurs?&lt;/p&gt;&lt;h3&gt;Waiting for a thing&lt;/h3&gt;&lt;p&gt;Sometimes you want different goroutines to wait for one another:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Fence struct {
create  sync.Once
release sync.Once
wait    chan struct{}
}

// init allows to use the struct without separate initialization.
func (f *Fence) init() {
f.create.Do(func() {
f.wait = make(chan struct{})
})
}

// Release releases any waiting goroutines.
func (f *Fence) Release() {
f.init()
f.release.Do(func() {
close(f.wait)
})
}

// Released allows to write different select than
// `Fence.Wait` provides.
func (f *Fence) Released() chan struct{} {
f.init()
return f.wait
}

// Wait waits for the fence to be released and takes into account
// context cancellation.
func (f *Fence) Wait(ctx context.Context) error {
f.init()
select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When we use it together with Concurrently we can write code that looks like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;var loaded Fence
var data map[string]int

err := Concurrently(
func() error {
defer loaded.Release()
data = getData(ctx, url)
return nil
},
func() error {
if err := loaded.Wait(ctx); err != nil {
return err
}
return saveToCache(data)
},
func() error {
if err := loaded.Wait(ctx); err != nil {
return err
}
return processData(data)
},
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Protecting State&lt;/h3&gt;&lt;p&gt;Similarly, we quite often need to protect the state when concurrently modifying it. We&#x27;ve seen how sync.Mutex is sometimes error-prone and doesn&#x27;t consider context cancellation. Let&#x27;s write a helper for such a scenario.&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Locked[T any] struct {
state chan *T
}

func NewLocked[T any](initial *T) *Locked[T] {
s := &amp;amp;Locked[T]{}
s.state = make(chan *T, 1)
s.state &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we can use it like:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;state := NewLocked(&amp;amp;State{Value: 123})
err := state.Modify(ctx, func(state *State) error {
state.Value = 256
return nil
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Async processes in a server&lt;/h3&gt;&lt;p&gt;Finally, let&#x27;s take a scenario where we want to start background goroutines inside a server.&lt;/p&gt;&lt;p&gt;Let&#x27;s first write out the server code, how we would like to use it:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;unc (server *Server) Run(ctx context.Context) error {
server.pending = NewJobs(ctx)
defer server.pending.Wait()

return server.listenAndServe(ctx)
}

func (server *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
...

started := server.pending.Go(r.Context(),
func(ctx context.Context) {
err := server.db.ExecContext(ctx, &quot;INSERT ...&quot;)
...
})
if !started {
if r.Context().Err() != nil {
http.Error(w, &quot;client closed request&quot;, 499)
return
}
http.Error(w, &quot;shutting down&quot;, http.StatusServiceUnavailable)
return nil
}

...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then let&#x27;s write the primitive:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Jobs struct {
root  context.WithContext
group errgroup.Group
}

func NewJobs(root context.Context) *Jobs {
return &amp;amp;Jobs{root: root}
}

func (jobs *Jobs) Wait() { _ = jobs.group.Wait() }

func (jobs *Jobs) Go(requestCtx context.Context, fn func(ctx context.Context)) bool {
// did the user cancel?
if requestCtx.Err() != nil {
return false
}
// let&#x27;s check whether server is shutting down
if jobs.root.Err() != nil {
return false
}

jobs.group.Go(func() error {
// Note, we use the root context and not the request context.
fn(jobs.root)
return nil
})

return true
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Of course, we can add a limiter, to prevent too many background workers to be started:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;type Jobs struct {
root  context.WithContext
limit chan struct{}
group errgroup.Group
}

func (jobs *Jobs) Go(requestCtx context.Context, fn func(ctx context.Context)) bool {
if requestCtx.Err() != nil || jobs.root.Err() != nil {
return false
}
select {
case &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;Exercise: Retrying with backoff&lt;/h3&gt;&lt;p&gt;As a final exercise for the reader, you can try implementing a retry with backoff. The API for such a primitive can look like this:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;const (
maxRetries = 10
minWait = time.Second/10
maxWait = time.Second
)

retry := NewRetry(maxRetries, minWait, maxWait)
for retry.Next(ctx) {
...
}
if retry.Err() != nil {
return retry.Err()
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Alternatively, it can be callback based:&lt;/p&gt;&lt;div class=&quot;w-embed&quot;&gt;&lt;pre&gt;&lt;code&gt;err := Retry(ctx, maxRetries, minWait, maxWait,
func(ctx context.Context) error {
...
})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Additionally, consider where one would be better than the other.&lt;/p&gt;&lt;h2&gt;Additional resources&lt;/h2&gt;&lt;p&gt;There are many resources that can help you delve deeper.&lt;/p&gt;&lt;p&gt;You can find quite a lot of &lt;strong&gt;our own custom primitives&lt;/strong&gt; at &lt;a href=&quot;https://pkg.go.dev/storj.io/common/sync2&quot;&gt;&lt;strong&gt;storj.io/common/sync2&lt;/strong&gt;&lt;/a&gt;. This package contains most of our synchronization primitives. It contains things like &lt;em&gt;Sleep&lt;/em&gt; and &lt;em&gt;Concurrently&lt;/em&gt;, but also more advanced things like &lt;em&gt;Cycle&lt;/em&gt;, &lt;em&gt;ReadCache&lt;/em&gt; and &lt;em&gt;Throttle&lt;/em&gt;. We also have problem specific implementations of &lt;a href=&quot;https://github.com/storj/storj/blob/main/satellite/metainfo/piecedeletion/combiner.go#L15&quot;&gt;&lt;strong&gt;Combiner&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/storj/storj/blob/6df867bb3d06240da139de145aaf88077572b4b8/satellite/metainfo/piecedeletion/queue.go#L10&quot;&gt;&lt;strong&gt;Queue&lt;/strong&gt;&lt;/a&gt; that implement a combiner queue. This primitive allows to dial storage nodes, coalesce multiple deletion requests into a single request.&lt;/p&gt;&lt;p&gt;One of the best talks about Go concurrency is &quot;&lt;a href=&quot;https://www.youtube.com/watch?v=5zXAHh5tJqQ&quot;&gt;&lt;strong&gt;Rethinking Classical Concurrency Patterns&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Bryan C. Mills&lt;/strong&gt;. He discusses problems with worker pools and sync.Cond in-depth.&lt;/p&gt;&lt;p&gt;When you struggle with understanding data-races, then &quot;&lt;a href=&quot;https://greenteapress.com/wp/semaphores/&quot;&gt;&lt;strong&gt;Little Book of Semaphores&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Allen B. Downey&lt;/strong&gt; is an excellent resource. It contains many classic problems and exercises to get your brain noticing them.&lt;/p&gt;&lt;p&gt;There has been also some research on the topic &quot;&lt;a href=&quot;https://songlh.github.io/paper/go-study.pdf&quot;&gt;&lt;strong&gt;Real-World Concurrency Bugs in Go&lt;/strong&gt;&lt;/a&gt;&quot; by &lt;strong&gt;Tengfei Tu&lt;/strong&gt; et. al. It contains many additional issues not mentioned in this post.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>52dd5da645645367ecbac11dd97f76dd</guid>
<title>浅谈Java中的池化技术</title>
<link>https://toutiao.io/k/u2sp497</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在我们平常的编码中，通常会将一些对象保存起来，这主要考虑的是对象的创建成本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如像线程资源、数据库连接资源或者 TCP 连接等，这类对象的初始化通常要花费比较长的时间，如果频繁地申请和销毁，就会耗费大量的系统资源，造成不必要的性能损失。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;并且这些对象都有一个显著的特征，就是通过轻量级的重置工作，可以循环、重复地使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个时候，我们就可以使用一个虚拟的池子，将这些资源保存起来，当使用的时候，我们就从池子里快速获取一个即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Java 中，池化技术应用非常广泛，常见的就有数据库连接池、线程池等，本文主讲连接池，线程池我们将在后续的博客中进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公用池化包 Commons Pool 2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们首先来看一下 Java 中公用的池化包 Commons Pool 2，来了解一下对象池的一般结构。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;根据我们的业务需求，使用这套 API 能够很容易实现对象的池化管理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.commons&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-pool2&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.1&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;GenericObjectPool 是对象池的核心类，通过传入一个对象池的配置和一个对象的工厂，即可快速创建对象池。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;GenericObjectPool&lt;/span&gt;&lt;span&gt;( &lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; PooledObjectFactory&amp;lt;T&amp;gt; factory, &lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; GenericObjectPoolConfig&amp;lt;T&amp;gt; config)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 的常用客户端 Jedis，就是使用 Commons Pool 管理连接池的，可以说是一个最佳实践。下图是 Jedis 使用工厂创建对象的主要代码块。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象工厂类最主要的方法就是makeObject，它的返回值是 PooledObject 类型，可以将对象使用 new DefaultPooledObject&amp;lt;&amp;gt;(obj) 进行简单包装返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;redis.clients.jedis.JedisFactory，使用工厂创建对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; PooledObject&amp;lt;Jedis&amp;gt; &lt;span&gt;makeObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;  Jedis jedis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    jedis = &lt;span&gt;new&lt;/span&gt; Jedis(jedisSocketFactory, clientConfig);&lt;br/&gt;    &lt;span&gt;//主要的耗时操作&lt;/span&gt;&lt;br/&gt;    jedis.connect();&lt;br/&gt;    &lt;span&gt;//返回包装对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultPooledObject&amp;lt;&amp;gt;(jedis);&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (JedisException je) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (jedis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        jedis.quit();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (RuntimeException e) {&lt;br/&gt;        logger.warn(&lt;span&gt;&quot;Error while QUIT&quot;&lt;/span&gt;, e);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        jedis.close();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (RuntimeException e) {&lt;br/&gt;        logger.warn(&lt;span&gt;&quot;Error while close&quot;&lt;/span&gt;, e);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; je;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们再来介绍一下对象的生成过程，如下图，对象在进行获取时，将首先尝试从对象池里拿出一个，如果对象池中没有空闲的对象，就使用工厂类提供的方法，生成一个新的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;borrowObject&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Duration borrowMaxWaitDuration)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        create = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//首先尝试从池子中获取。&lt;/span&gt;&lt;br/&gt;        p = idleObjects.pollFirst();&lt;br/&gt;        &lt;span&gt;// 池子里获取不到，才调用工厂内生成新实例&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            p = create();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                create = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那对象是存在什么地方的呢？这个存储的职责，就是由一个叫作 LinkedBlockingDeque 的结构来承担的，它是一个双向的队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来看一下 GenericObjectPoolConfig 的主要属性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// GenericObjectPoolConfig本身的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxTotal = DEFAULT_MAX_TOTAL;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxIdle = DEFAULT_MAX_IDLE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; minIdle = DEFAULT_MIN_IDLE;&lt;br/&gt;&lt;span&gt;// 其父类BaseObjectPoolConfig的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; lifo = DEFAULT_LIFO;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; fairness = DEFAULT_FAIRNESS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; maxWaitMillis = DEFAULT_MAX_WAIT_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; evictorShutdownTimeoutMillis = DEFAULT_EVICTOR_SHUTDOWN_TIMEOUT_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numTestsPerEvictionRun = DEFAULT_NUM_TESTS_PER_EVICTION_RUN;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; EvictionPolicy&amp;lt;T&amp;gt; evictionPolicy = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;// Only 2.6.0 applications set this &lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; String evictionPolicyClassName = DEFAULT_EVICTION_POLICY_CLASS_NAME;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnCreate = DEFAULT_TEST_ON_CREATE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnBorrow = DEFAULT_TEST_ON_BORROW;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testOnReturn = DEFAULT_TEST_ON_RETURN;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; testWhileIdle = DEFAULT_TEST_WHILE_IDLE;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; blockWhenExhausted = DEFAULT_BLOCK_WHEN_EXHAUSTED;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参数很多，要想了解参数的意义，我们首先来看一下一个池化对象在整个池子中的生命周期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图所示，池子的操作主要有两个：一个是业务线程，一个是检测线程。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6369529983792545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0NfXNQwL00GRMIRibHLENMqWQ2Jfp2cibPZd0iba4Qhce82TO5lc7icD6g9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象池在进行初始化时，要指定三个主要的参数：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;maxTotal 对象池中管理的对象上限&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;maxIdle 最大空闲数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;minIdle 最小空闲数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 maxTotal 和业务线程有关，当业务线程想要获取对象时，会首先检测是否有空闲的对象。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有，则返回一个；否则进入创建逻辑。此时，如果池中个数已经达到了最大值，就会创建失败，返回空对象。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象在获取的时候，有一个非常重要的参数，那就是最大等待时间（maxWaitMillis），这个参数对应用方的性能影响是比较大的。该参数默认为 -1，表示永不超时，直到有对象空闲。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图，如果对象创建非常缓慢或者使用非常繁忙，业务线程会持续阻塞 （blockWhenExhausted 默认为 true），进而导致正常服务也不能运行。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3918613413715147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0NYRTf3pHWKxyS5oAicq14M9OcrKhJuRbibbOp1R21szsmtq2cre4mXmOg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1327&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;面试题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般面试官会问：你会把超时参数设置成多大呢？&lt;/span&gt;&lt;span&gt;我一般都会把最大等待时间，设置成接口可以忍受的最大延迟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;比如，一个正常服务响应时间 10ms 左右，达到 1 秒钟就会感觉到卡顿，那么这个参数设置成 500~1000ms 都是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;超时之后，会抛出 NoSuchElementException 异常，请求会快速失败，不会影响其他业务线程，这种 Fail Fast 的思想，在互联网应用非常广泛。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;带有 evcit 字样的参数，主要是处理对象逐出的。池化对象除了初始化和销毁的时候比较昂贵，在运行时也会占用系统资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如，连接池会占用多条连接，线程池会增加调度开销等。&lt;/span&gt;&lt;span&gt;业务在突发流量下，会申请到超出正常情况的对象资源，放在池子中。&lt;/span&gt;&lt;span&gt;等这些对象不再被使用，我们就需要把它清理掉。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;超出 minEvictableIdleTimeMillis 参数指定值的对象，就会被强制回收掉，这个值默认是 30 分钟；softMinEvictableIdleTimeMillis 参数类似，但它只有在当前对象数量大于 minIdle 的时候才会执行移除，所以前者的动作要更暴力一些。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有 4 个 test 参数：&lt;/span&gt;&lt;span&gt;testOnCreate、testOnBorrow、testOnReturn、testWhileIdle，分别指定了在创建、获取、归还、空闲检测的时候，是否对池化对象进行有效性检测。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;开启这些检测，能保证资源的有效性，但它会耗费性能，所以默认为 false。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生产环境上，建议只将 testWhileIdle 设置为 true，并通过调整空闲检测时间间隔（timeBetweenEvictionRunsMillis），比如 1 分钟，来保证资源的可用性，同时也保证效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;JMH 测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用连接池和不使用连接池，它们之间的性能差距到底有多大呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面是一个简单的 JMH 测试例子（见仓库），进行一个简单的 set 操作，为 redis 的 key 设置一个随机值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Fork(2)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;@State(Scope.Benchmark)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;@Warmup(iterations = 5, time = 1)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;@Measurement(iterations = 5, time = 1)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;@BenchmarkMode(Mode.Throughput)&lt;/span&gt; &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JedisPoolVSJedisBenchmark&lt;/span&gt; &lt;/span&gt;{ &lt;br/&gt;   JedisPool pool = new JedisPool(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Benchmark&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; void testPool() { &lt;br/&gt;       Jedis jedis = pool.getResource(); &lt;br/&gt;       jedis.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, UUID.randomUUID().toString()); &lt;br/&gt;       jedis.close(); &lt;br/&gt;   } &lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Benchmark&lt;/span&gt; &lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; void testJedis() { &lt;br/&gt;       Jedis jedis = new Jedis(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, &lt;span&gt;6379&lt;/span&gt;); &lt;br/&gt;       jedis.&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, UUID.randomUUID().toString()); &lt;br/&gt;       jedis.close(); &lt;br/&gt;   } &lt;br/&gt;   &lt;span&gt;//此处省略若干行&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;将测试结果使用 meta-chart 作图，展示结果如下图所示，可以看到使用了连接池的方式，它的吞吐量是未使用连接池方式的 5 倍！&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.313586606567933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0Nkk1vHbPu6EWZehYZsCZiabJdbTj52JiaIHHicg37k8pBqLMSTD4ibUx6Kw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1553&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;数据库连接池 HikariCP&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HikariCP 源于日语“光る”，光的意思，寓意软件工作速度和光速一样快，它是 SpringBoot 中默认的数据库连接池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库是我们工作中经常使用到的组件，针对数据库设计的客户端连接池是非常多的，它的设计原理与我们在本文开头提到的基本一致，可以有效地减少数据库连接创建、销毁的资源消耗。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;同是连接池，它们的性能也是有差别的，下图是 HikariCP 官方的一张测试图，可以看到它优异的性能，官方的 JMH 测试代码见 Github。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4127536231884058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0NPQ4eD4wSozMEpFltQwq6YibU5lReGy9dqatf8hAXPxuWibFdZiaWwMajw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1725&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般面试题是这么问的：HikariCP 为什么快呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主要有三个方面：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;它使用 FastList 替代 ArrayList，通过初始化的默认值，减少了越界检查的操作&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;优化并精简了字节码，通过使用 Javassist，减少了动态代理的性能损耗，比如使用 invokestatic 指令代替 invokevirtual 指令&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;实现了无锁的 ConcurrentBag，减少了并发场景下的锁竞争&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HikariCP 对性能的一些优化操作，是非常值得我们借鉴的，在之后的博客中，我们将详细分析几个优化场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库连接池同样面临一个最大值（maximumPoolSize）和最小值（minimumIdle）的问题。这里同样有一个非常高频的面试题：你平常会把连接池设置成多大呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很多同学认为，连接池的大小设置得越大越好，有的同学甚至把这个值设置成 1000 以上，这是一种误解。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;根据经验，数据库连接，只需要 20~50 个就够用了。具体的大小，要根据业务属性进行调整，但大得离谱肯定是不合适的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HikariCP 官方是不推荐设置 minimumIdle 这个值的，它将被默认设置成和 maximumPoolSize 一样的大小。如果你的数据库Server端连接资源空闲较大，不妨也可以去掉连接池的动态调整功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，根据数据库查询和事务类型，一个应用中是可以配置多个数据库连接池的，这个优化技巧很少有人知道，在此简要描述一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务类型通常有两种：一种需要快速的响应时间，把数据尽快返回给用户；另外一种是可以在后台慢慢执行，耗时比较长，对时效性要求不高。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果这两种业务类型，共用一个数据库连接池，就容易发生资源争抢，进而影响接口响应速度。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然微服务能够解决这种情况，但大多数服务是没有这种条件的，这时就可以对连接池进行拆分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如图，在同一个业务中，根据业务的属性，我们分了两个连接池，就是来处理这种情况的。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3424068767908309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0NiabRw9cEZuH76phhEgBfnibWIRRGjhtWAKfLDSq5CqhPgQWkCf9hiaibXw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HikariCP 还提到了另外一个知识点，在 JDBC4 的协议中，通过 Connection.isValid() 就可以检测连接的有效性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，我们就不用设置一大堆的 test 参数了，HikariCP 也没有提供这样的参数。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结果缓存池&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到了这里你可能会发现池（Pool）与缓存（Cache）有许多相似之处。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们之间的一个共同点，就是将对象加工后，存储在相对高速的区域。我习惯性将缓存看作是数据对象，而把池中的对象看作是执行对象。缓存中的数据有一个命中率问题，而池中的对象一般都是对等的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑下面一个场景，jsp 提供了网页的动态功能，它可以在执行后，编译成 class 文件，加快执行速度；再或者，一些媒体平台，会将热门文章，定时转化成静态的 html 页面，仅靠 nginx 的负载均衡即可应对高并发请求（动静分离）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些时候，你很难说清楚，这是针对缓存的优化，还是针对对象进行了池化，它们在本质上只是保存了某个执行步骤的结果，使得下次访问时不需要从头再来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我通常把这种技术叫作结果缓存池（Result Cache Pool），属于多种优化手段的综合。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面我来简单总结一下本文的内容重点：&lt;/span&gt;&lt;span&gt;我们从 Java 中最通用的公用池化包 Commons Pool 2 说起，介绍了它的一些实现细节，并对一些重要参数的应用做了讲解。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Jedis 就是在 Commons Pool 2 的基础上封装的，通过 JMH 测试，我们发现对象池化之后，有了接近 5 倍的性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来介绍了数据库连接池中速度很快的 HikariCP ，它在池化技术之上，又通过编码技巧进行了进一步的性能提升，HikariCP 是我重点研究的类库之一，我也建议你加入自己的任务清单中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总体来说，当你遇到下面的场景，就可以考虑使用池化来增加系统性能：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象的创建或者销毁，需要耗费较多的系统资源&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象的创建或者销毁，耗时长，需要繁杂的操作和较长时间的等待&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象创建后，通过一些状态重置，可被反复使用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将对象池化之后，只是开启了第一步优化。要想达到最优性能，就不得不调整池的一些关键参数，合理的池大小加上合理的超时时间，就可以让池发挥更大的价值。和缓存的命中率类似，对池的监控也是非常重要的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如下图，可以看到数据库连接池连接数长时间保持在高位不释放，同时等待的线程数急剧增加，这就能帮我们快速定位到数据库的事务问题。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26276923076923075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbucssAh0TgiboSKK7FSRQeK0NgF63ulAiblwHgrY6txEIqX3qYKcmDuwzjp479TyR9fG96vZSfmTxfDA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1625&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;平常的编码中，有很多类似的场景。比如 Http 连接池，Okhttp 和 Httpclient 就都提供了连接池的概念，你可以类比着去分析一下，关注点也是在连接大小和超时时间上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在底层的中间件，比如 RPC，也通常使用连接池技术加速资源获取，比如 Dubbo 连接池、 Feign 切换成 httppclient 的实现等技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你会发现，在不同资源层面的池化设计也是类似的。比如线程池，通过队列对任务进行了二层缓冲，提供了多样的拒绝策略等，线程池我们将在后续的文章中进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线程池的这些特性，你同样可以借鉴到连接池技术中，用来缓解请求溢出，创建一些溢出策略。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现实情况中，我们也会这么做。那么具体怎么做？有哪些做法？这部分内容就留给大家思考了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>091afe3a30b6e5a039f71711bd3943dc</guid>
<title>推荐学Java——数据表高级操作</title>
<link>https://toutiao.io/k/t7u8kbm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;学java，关注不迷路&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MDY3NjYyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnAckqCAkgyY3HE1u95XvwUCHLyWyVZVgZKTlicoAOXib39OstzTlYXYyicr63nMCaKW1Lg74SnvTB8Fw/0?wx_fmt=png&quot; data-nickname=&quot;推荐学java&quot; data-alias=&quot;javaFirst&quot; data-signature=&quot;推荐学Java，学编程首选语言！关注即送精品资料(2021版)&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一节内容学习了关于数据表的基本操作，也就是针对单表的增删改查以及创建和删除，而在实际开发中，往往是多表联合操作，尤其是插入和查询用的最多，而这两步都要经过一个“筛选”的过程，这个过程要根据具体业务逻辑，综合不同的表，查询后决定是否满足插入或其他条件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节内容涉及的广泛一些，我们需要创建多个表，进行复杂一点的操作，数据库管理工具这里使用的是 &lt;code&gt;Navicat 12&lt;/code&gt; ，还有很多类似的软件，比如：&lt;code&gt;sqlyog&lt;/code&gt;、&lt;code&gt;SQL-Front&lt;/code&gt;等等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Navicat 12 安装&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官网：&lt;code&gt;https://www.navicat.com.cn/download/navicat-premium&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决 Navicat12 链接MySQL的错误：2059 - authentication plugin &#x27;caching_sha2_password&#x27;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方案：&lt;code&gt;https://jingyan.baidu.com/article/0aa22375e7966ac8cc0d64b3.html&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里特别注意最后一句命令：&lt;code&gt;ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;root&#x27;;&lt;/code&gt; BY后面的字符串就是你的 mysql 密码，如果你没有正确输入，那么测试链接数据库的时候会提示这个错误：&lt;code&gt;1045 Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)&lt;/code&gt; 其实就相当于修改了 root 账户的密码。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;本节涉及到表结构&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;部门表&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2517857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnCr7ibDibr7VRWFkd6J6uGuIdNy54s5vv3KLmdlDbVV6nKe08qgFkP4amDb4Lb56e7CngcYmjM8y6qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;figcaption&gt;部门表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段分别是：部门编号、部门名称、部门所在地址位置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;员工表&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43760399334442596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnCr7ibDibr7VRWFkd6J6uGuIdlo76SZytiaZhLHhV54sf2ldribBqia7tDR6Bb8vcmiaqU3ic2A3kQ28QaTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;figcaption&gt;员工表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段分别是：员工编号、员工名称、职位、上级、入职日期、薪资、补贴、所属部门编号、所使用的语言。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;薪资等级表&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.29313929313929316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnCr7ibDibr7VRWFkd6J6uGuIdWibr3Mowu2zXibg9Ul4xgprZm9IRRIqbIt4gFMV1uZdKVoLolQCrmlPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;figcaption&gt;薪资等级表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段分别是：等级、最低工资、最高工资。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以上表中的数据大家可以自己修改和填充&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工具和&lt;code&gt;sql&lt;/code&gt;文件在公众号 &lt;code&gt;推荐学java&lt;/code&gt; 回复&lt;code&gt;navicat&lt;/code&gt;获取。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.631911532385466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnCr7ibDibr7VRWFkd6J6uGuIdmeR9nqibtDH9XLKRaa2jgIib6yiaLq4DZHVrEphrbKwiaXbsNz0SBkYWtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1899&quot;/&gt;&lt;figcaption&gt;多表查询知识点&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;常见的 MySQL 内置函数&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之对应，还有多行处理函数，前者是说有一条输入，对应一条输出结果；后者则是多行输入，对应一条输出结果，比如：求和函数&lt;code&gt;sum()&lt;/code&gt; 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LOWER()：转小写字母&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;lower&lt;/span&gt;(列名) &lt;span&gt;from&lt;/span&gt; 表名;&lt;br/&gt;// 也可以带表名&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;lower&lt;/span&gt;(列名) &lt;span&gt;as&lt;/span&gt; l_Name &lt;span&gt;from&lt;/span&gt; 表名;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;UPPER()：转大写字母&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LENGTH(列名)：字符数量，就是字段的长度&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CONCAT(string1,string2)：字符串拼接，不能使用 &lt;code&gt;+&lt;/code&gt; .&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 将列 LANGUAGE 首字母转大写&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;concat&lt;/span&gt;(&lt;span&gt;upper&lt;/span&gt;(&lt;span&gt;substr&lt;/span&gt;(&lt;span&gt;language&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)),&lt;span&gt;substr&lt;/span&gt;(&lt;span&gt;language&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;length&lt;/span&gt;(&lt;span&gt;language&lt;/span&gt;)&lt;span&gt;-1&lt;/span&gt;)) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;语言&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;INSTR()：字符出现的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;INSERT()：插入/替换字符&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;REPLACE()：替换字符&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SUBSTR(字符串,开始截取的位置,结束的位置)：截取字符串。&lt;strong&gt;下标是从1开始的&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;substr&lt;/span&gt;(ename,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; ename &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;where&lt;/span&gt; &lt;span&gt;substr&lt;/span&gt;(ename,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;老%&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SUBSTRING(字符串,开始截取的位置,偏移量)：截取字符串&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LPAD(字符串,填充后字符串总长度,要填充的字符串)：在字符串的左侧填充给定字符串。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RPAD(字符串，填充后字符串总长度,要填充的字符串)：在字符串的右侧填充给定字符串。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TRIM()：去掉字符串的首位空格&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ROUND(列名,保留位数) ：四舍五入，根据指定位数来保留小数位。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 十位四舍五入，没有小数位&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;round&lt;/span&gt;(sal,&lt;span&gt;-1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;薪资&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;// 去尾，只保留整数部分&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;round&lt;/span&gt;(sal,&lt;span&gt;0&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;薪资&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;// 四舍五入，保留一位小数（如果本来只有一位小数，则会直接保留）&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;round&lt;/span&gt;(sal,&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;薪资&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;// 四舍五入，保留两位小数&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;round&lt;/span&gt;(sal,&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;薪资&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;ifnull(值1, 值2)&lt;/code&gt; ：空处理函数，可以将 null 转换成一个具体值。如果值1为null，那么会取值2参与运算。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; (sal + &lt;span&gt;IFNULL&lt;/span&gt;(comm,&lt;span&gt;0&lt;/span&gt;)) *&lt;span&gt;12&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;年薪&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;format(列名,&#x27;格式&#x27;)&lt;/code&gt; ：数字格式化，例如显式千分位：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename,&lt;span&gt;format&lt;/span&gt;(e.sal,&lt;span&gt;&#x27;$999,999&#x27;&lt;/span&gt;)  &lt;span&gt;as&lt;/span&gt; sal &lt;span&gt;from&lt;/span&gt; emp e;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;连接查询&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一节内容涉及的都是但张表操作和基本的sql关键词的使用，下面的内容涉及&lt;strong&gt;多张表之间的查询&lt;/strong&gt;操作，以及相关SQL专业知识。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;SQL查询分类&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;根据SQL语法年代&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SQL92：1992年出现的语法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SQL99：1999年出现的语法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;根据表连接的方式&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;内连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外连接&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;左外连接（左连接）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;右外连接（右链接）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全连接（基本不用，可不了解）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;笛卡尔积现象&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多张表关联查询时，如果不加任何约束条件，那么查询结果是多张表记录的乘机。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;内连接之等值连接案例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;查询每个员工所在的部门名称，要求显示员工姓名、部门名称。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;员工表中只有部门编号，部门名称是在部门表中，所以就需要两张表关联查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, d.dname &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;join&lt;/span&gt; dept d &lt;span&gt;on&lt;/span&gt; e.deptno = d.deptno; // on 后的条件是等值的，叫做等值连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;内连接之非等值连接案例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工的薪资等级，要求显示员工姓名、薪资、薪资等级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;薪资等级是一张单独的表，员工姓名和薪资在员工表中，同样需要两张表联合查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// on 后的条件不是等值的，叫做非等值连接&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; e.ename, e.sal, s.grade &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;join&lt;/span&gt; salgrade s &lt;span&gt;on&lt;/span&gt; e.sal &lt;span&gt;between&lt;/span&gt; s.losal &lt;span&gt;and&lt;/span&gt; s.hisal;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;内连接之自连接案例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工的领导的姓名，显示员工姓名、领导姓名。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;员工表中有员工姓名和员工的上级领导编号，领导同样也是员工，也存在员工表中，所以需要将一张表（员工表）看做两张表来查询，故称作这种情况为自连接查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;员工姓名&#x27;&lt;/span&gt;,em.ename &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;领导姓名&#x27;&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;join&lt;/span&gt; emp em &lt;span&gt;on&lt;/span&gt; e.mgr = em.empno;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;外连接案例&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工所在的部门，显示员工姓名、部门名称。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;员工在员工表中，存在部门编号，部门名称是在部门表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, d.dname &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;right&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; dept d &lt;span&gt;on&lt;/span&gt; e.deptno = d.deptno;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;带有&lt;code&gt;right&lt;/code&gt;的是右外连接，又称右链接，此时查询会以&lt;code&gt;right&lt;/code&gt;右边的表作为主表来查询，任何一个右链接查询都可以写出对应的左连接查询，反之亦然。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应左连接查询SQL：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, d.dname &lt;span&gt;from&lt;/span&gt; dept d &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; emp e &lt;span&gt;on&lt;/span&gt; e.deptno = d.deptno;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;外连接的查询结果一定是 &amp;gt;= 内连接的查询结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一条SQL中可以同时出现内连接和外连接，混合使用没有问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;多张表关联查询&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语法格式：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.xxx,b.xxx,c.xxx &lt;span&gt;from&lt;/span&gt; a表 a &lt;span&gt;join&lt;/span&gt; b表 b &lt;span&gt;on&lt;/span&gt; a和b的链接条件 &lt;span&gt;join&lt;/span&gt; c表 c &lt;span&gt;on&lt;/span&gt; a和c的链接条件&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**案例1：**三张表关联查询&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工的部门名称以及工资等级，显示员工姓名、薪资、部门名称、薪资等级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename,e.sal,d.dname,s.grade &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;join&lt;/span&gt; dept d &lt;span&gt;on&lt;/span&gt; e.deptno = d.deptno &lt;span&gt;join&lt;/span&gt; salgrade s &lt;span&gt;on&lt;/span&gt; e.sal &lt;span&gt;between&lt;/span&gt; s.losal &lt;span&gt;and&lt;/span&gt; s.hisal;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案例2：&lt;/strong&gt; 三张表链接+左连接查询&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工的部门名称以及工资等级，显示员工姓名、薪资、领导名、部门名称、薪资等级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, em.ename &lt;span&gt;as&lt;/span&gt; &lt;span&gt;&#x27;上级领导&#x27;&lt;/span&gt;, e.sal, d.dname, s.grade &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;join&lt;/span&gt; dept d &lt;span&gt;on&lt;/span&gt; e.deptno = d.deptno &lt;span&gt;join&lt;/span&gt; salgrade s &lt;span&gt;on&lt;/span&gt; e.sal &lt;span&gt;between&lt;/span&gt; s.losal &lt;span&gt;and&lt;/span&gt; hisal &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; emp em &lt;span&gt;on&lt;/span&gt; e.mgr = em.empno;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;子查询&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是子查询？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;select语句中嵌套select语句，那么被嵌套的select语句称为&lt;strong&gt;子查询&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;子查询出现位置&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;br/&gt; ...(&lt;span&gt;select&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;from&lt;/span&gt;&lt;br/&gt; ...(&lt;span&gt;select&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;where&lt;/span&gt;&lt;br/&gt; ...(&lt;span&gt;select&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;where 子句中的子查询&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出比最低工资（员工的工资，不是工资登记表中的最低工资）高的员工姓名和工资。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename,e.sal &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;where&lt;/span&gt; e.sal &amp;gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;min&lt;/span&gt;(sal) &lt;span&gt;from&lt;/span&gt; emp);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;from 子句中的子查询&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;from子句中的子查询结果可以当做一张临时表来使用，因为from后面本身就是表名&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个工作岗位的平均薪资的工资等级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; s.job,s.avg,sal.grade &lt;span&gt;from&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; job, &lt;span&gt;avg&lt;/span&gt;(sal) &lt;span&gt;avg&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; job) s &lt;span&gt;join&lt;/span&gt; salgrade sal &lt;span&gt;on&lt;/span&gt; s.avg &lt;span&gt;between&lt;/span&gt; sal.losal &lt;span&gt;and&lt;/span&gt; sal.hisal ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;select 子句中的子查询（了解即可）&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;找出每个员工的部门名称，显示员工姓名、部门名称。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, (&lt;span&gt;select&lt;/span&gt; d.dname &lt;span&gt;from&lt;/span&gt; dept d &lt;span&gt;where&lt;/span&gt; d.deptno = e.deptno) d &lt;span&gt;from&lt;/span&gt; emp e;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;union用法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将查询结果集进行合并，比如：两条select语句的结果拼接在一起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;将 &lt;code&gt;job&lt;/code&gt; 为 &lt;code&gt;四绝之一&lt;/code&gt; 和 &lt;code&gt;Java全栈工程师&lt;/code&gt; 的员工查出来，显示员工名、职位名。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL语法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; e.ename, e.job &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;where&lt;/span&gt; e.job = &lt;span&gt;&#x27;四绝之一&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;union&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; e.ename,e.job &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;where&lt;/span&gt; e.job =&lt;span&gt;&#x27;Java全栈工程师&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这个需求而言，SQL查询可以用之前学的 &lt;code&gt;or&lt;/code&gt; 或者 &lt;code&gt;in(值1,值2)&lt;/code&gt; 都可以实现结果，但在多表链接查询时 &lt;code&gt;union&lt;/code&gt; 效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;union注意事项：&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;limit用法（必须掌握）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将查询结果集的一部分取出来，通常多用于分页查询中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用法示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-- 将所有职位查询来降序排列，只显示前5条&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; emp &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; job &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;-- 将查询结果 从第四条开始，向后取5条数据出来&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; e.ename, e.sal &lt;span&gt;from&lt;/span&gt; emp e &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; sal &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;limit注意事项：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;limit startIndex,length. startIndex如果不写，默认从第一条开始&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mySQL当中，&lt;code&gt;limit&lt;/code&gt; 在 &lt;code&gt;order by&lt;/code&gt;  之后执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;通用分页公式：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;limit (pageNo-1)*pageSize, pageSize;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;存储引擎（了解即可）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个名词是MySQL特有的，Oracle中也有类似技术，但不叫这个名字。&lt;strong&gt;存储引擎&lt;/strong&gt;就是一张表存储/组织数据的方式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;MySQL默认的存储引擎是 &lt;code&gt;InnoDB&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;MySQL默认的字符编码是 &lt;code&gt;utf8&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建引擎语法格式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; t_studying (&lt;br/&gt;&lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; primary &lt;span&gt;key&lt;/span&gt; auto_increment,&lt;br/&gt;&lt;span&gt;name&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;grade &lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;engine&lt;/span&gt; = &lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;charset&lt;/span&gt;=utf8;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查看MySQL支持的存储引擎，命令：&lt;code&gt;show engines \G&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这道理，查询相关高级知识已经完结了，下面内容是偏理论性的，但也很重要，属于高级操作，请结合知识导图查看。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9763387297633873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfp26cuFSnCr7ibDibr7VRWFkd6J6uGuIdcY2EwLrnKtpDmowI7xRaW7yFcB3VutwD7yW4iaYeCQ7oo4USC9gjbrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;figcaption&gt;事务_索引_视图_范式&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;事务（重点）&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是事务？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个事务就是一个完整的业务逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;只有增、删、改才会有事务一说&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;事务的执行逻辑&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这和存储引擎有关系，MySQL使用 &lt;code&gt;InnoDB&lt;/code&gt; ，而 &lt;code&gt;InnoDB&lt;/code&gt; 对没次操作的DML语句都会有日志记录文件，事务的执行结果要么多条语句全部失败，要么全部成功，无论是什么结果都会清空日志文件，所以事务支持回滚。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;事务的四个特性&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;事务的四种隔离级别&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;读未提交（Read Uncommited）：事务A只能读取到事务B未提交的数据，这种隔离级别基本不用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读已提交（Read Commited）：事务A只能读取到事务B已提交的数据，最常用的隔离级别，Oracle数据库默认隔离级别。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可重复读（Repeatable Read）：事务A开启事务后，每次读到的数据都是相同的，就是事务B已经提交事务了，也同样读取不到事务B提交后的数据。MySQL数据库默认隔离级别。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;序列化（Serializable）：隔离级别最高，效率最低，每次读取到的都是最真实的数据，但事务不能并行，需要排队。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看事务隔离级别命令&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; @@tx_isolation&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;索引&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是索引？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引是在数据库表的字段上添加的，是为了提高查询效率提供的一种机制。一个字段可以添加一个索引，当然也可以多个字段联合起来添加索引。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;索引实现原理&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在任何数据库中，主键都会自动添加索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在MySQL中，如果一个字段有 &lt;code&gt;unique&lt;/code&gt; 约束的话，也会自动添加索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在任何数据库中，任意一条记录在硬盘上都有对应的物理存储编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不同的存储引擎索引以不同的形式存在。在 InnoDB 中，索引存储在一个逻辑名叫 &lt;code&gt;tablespace&lt;/code&gt; 中，是一种二叉树（B-Tree）结构。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;索引添加时机&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据量庞大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该字段经常出现在 &lt;code&gt;where&lt;/code&gt; 后面，一条件的形式存在，也就是经常被扫描&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该字段很少的MDL（insert delete update）操作（因为DML之后，索引需要重新排序）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;创建索引&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; 索引名 &lt;span&gt;on&lt;/span&gt; 表名(字段名);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;删除索引&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; 索引名 &lt;span&gt;on&lt;/span&gt; 表名;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 SQL 语句是否使用了索引&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;explain&lt;/span&gt; &lt;span&gt;sql&lt;/span&gt;查询语句;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;说明：&lt;/code&gt; 通过查看结果中的 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;rows&lt;/code&gt; 值来做判断，前者如果是 &lt;code&gt;ref&lt;/code&gt; 则说明是通过索引来扫描的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;索引失效的情况&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;模糊匹配当中以 &lt;code&gt;%&lt;/code&gt; 开头了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;or&lt;/code&gt; 的时候，要能使用索引，那么要求 &lt;code&gt;or&lt;/code&gt; 两边的字段都要有索引，如果只要一边有索引，那么索引会失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用复合索引（两个或多个字段联合起来添加一个索引）的时候，没有使用左侧的列查找，索引失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;where&lt;/code&gt; 当中，索引列参加了运算，索引失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;where&lt;/code&gt; 当中，索引列使用了函数，索引失效&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;视图&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;什么是视图&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同角度看待同一份数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;只有 &lt;code&gt;DQL&lt;/code&gt; 语句才能以 &lt;code&gt;view&lt;/code&gt; 的形式创建。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;创建视图对象&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; 视图名称 &lt;span&gt;as&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;语句;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;删除视图对象&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;view&lt;/span&gt; 视图名称;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;视图作用&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以面向视图对象进行增删改查，这将会导致原表数据被操作。&lt;strong&gt;方便、简化开发、利于维护&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;数据库设计三范式&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;第一范式&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要求所有表都必须有主键，每一个字段都是原子性不可再分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;第二范式&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一范式的基础上，要求每个非主键字段完全依赖主键，不要产生部分依赖。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;第三范式&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第二范式的基础上，要求所有非主键字段完全依赖主键，不要产生传递依赖。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于多表的操作，最常用的就是查询，且是最重要的内容，本章节内容会影响到我们后面的进阶内容，需要加强练习。这里建议大家在学习的过程中写 &lt;code&gt;SQL&lt;/code&gt; 语句在相应的工具中进行，本文开始介绍了工具，还没下载的可以去公众号获取。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;小编特意创建了一个公众号：&lt;code&gt;推荐学java&lt;/code&gt;，分享&lt;code&gt;java&lt;/code&gt;内容，并且以原创为主，欢迎大家搜索关注（关注即送精品视频教程），一起学Java，下次见！&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2e58b58eba8e5da5066b55c3cca28e0a</guid>
<title>有了这篇 Kubernetes 的介绍，它的原理秒懂！</title>
<link>https://toutiao.io/k/jva08b5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;架构师社区&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;devabc&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;架构师社区，专注分享架构师技术干货，架构师行业秘闻，汇集各类奇妙好玩的架构师话题和流行的架构师动向！&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>