<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>daf5606db97de013af77038a6ca42af3</guid>
<title>想要做好代码质量，如何破局？</title>
<link>https://toutiao.io/k/s9s8hub</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;作者：苗现方&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;想要做好代码质量，我们不得不提什么是代码质量？本文中讨论的代码质量一般是指代码的风格、重复率和复杂度等，代码是技术团队的价值产物，是宝贵的财富，同样代码质量的好坏可以直接体现出团队的重视程度和技术管理水平。&lt;/p&gt;

&lt;p&gt;代码质量的下降是内在原因，通常会恶性循环，&lt;strong&gt;主要表现出以下两个特性：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;感染性：坏代码总能在部门渲染着只要业务交付达成，代码质量不重要的负面气氛，严重减低了研发人员的技术热情，破坏工作氛围，导致更多的坏代码出现。&lt;/p&gt;

&lt;p&gt;心理暗示性：在坏代码基础上继续生产坏代码的&quot;罪过&quot;减轻。&lt;/p&gt;

&lt;p&gt;为什么会产生这样的结果，这里我与你举个生活中的栗子，我在上个周日收拾房间，发现一个房间衣柜中的衣服很乱，花了很长时间才叠放好，过两天晚上下班回家，我发现客厅沙发上也很乱，衣服、电脑、背包、零食几乎日常的小物件都会有，两件事情合在一起想，这确实是一个很有趣的思考，为什么会是这样的？在一个相对封闭的空间中，任其无意识地随着时间的发展，房间和沙发也一定很乱，注意，这里我说的是无意识，也就是我并没有刻意放，或者去刻意整理。带着这个思考的结果，我又观察了大家的工位、园区内景观，一段时间内一定会出现乱象，不过通过一顿治理之后很快恢复到有秩序，好，大家可以猜到这是什么定律，就是熵增定律，不了解的可以自行网络科普，那么在质量域中依然存在这样的定律，不然熵增定律也不会被古今中外的物理学家所推崇备至，它的定义是：在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大。&lt;/p&gt;

&lt;p&gt;代码质量在软件项目是一种有序的状态，自然总是向着无序发展的，要想保持这种有序，需要主动投入资源，就像整理房间，花草修剪一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;回到我们的多数开发工作中，我们面临的现状是这样的：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1、业务交付压力大，需求优先上线，业务逻辑实现优先级最高，没时间没精力关注代码质量，甚至终极目标就是需求上线，导致坏代码产生，开发效率逐步下降，随着后续版本的迭代，业务交付压力越来越大。&lt;/p&gt;

&lt;p&gt;2、出现了1的情况后，我们意识到压力越来越大，为了应付这种交付压力，常见的手段就是增加人力，但是一味的增加人数，沟通成本及风格的一致性无法得到保障，这将进一步产生更多的坏代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;针对以上2个现状，我们该怎么着手解决。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我的建议方案是多渠道，系统性解决问题，首先控制人力的大量投入，主动发起对代码质量进行管控，其次持续提升技术升级。但是，从减轻业务交付压力的结果来看，人们往往倾向于增加人力来快速解决问题，技术升级需要靠长期的投入才能有所收获，所以，我们需要在质量方面增加强有力的管控。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果做好代码质量管控？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码质量管控首先应解决两个问题，库存坏代码和增量坏代码。&lt;/p&gt;

&lt;p&gt;想解决这两个问题，我们要对现有的系统、人员、工具、流程整合形成一套体系化的方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/1a7c49ea15824e3db2cf7737f306588d%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=pSyRWdOXChxXhYsyqT8aYwmrH0g%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对代码质量管控，通过在部门内工程实践，我认为需要经历以下这四个过程，部门内建立代码规范制度（EOS）、检查代码问题的自动化工具（bamboo平台）、代码质量检查与代码流动过程绑定（质量门禁）、部门视角下，集中管理代码规范和质量状况的透明（代码质量评测系统）。&lt;/p&gt;

&lt;p&gt;过程一：代码质量的基础是规范，包括代码风格的规范、长期一线代码实践规范、与业务需求相关的特殊规范，例如风控文案、异常托底文案等。&lt;/p&gt;

&lt;p&gt;过程二：实现自动化的检查能力是在规范基础之上，通过自动化工具进行检查，包括对代码重复率、圈复杂度、单测case通过率、静态规则扫描等。&lt;/p&gt;

&lt;p&gt;过程三：实现质量检查与代码流动过程绑定，在编辑-构建-提交-发布各个时段部署检查能力保障上线代码必须经过机器和人工的多环节检查。&lt;/p&gt;

&lt;p&gt;过程四：团队规模逐步扩大，各业务线项目快速发展，实现规范管理统一、项目要求一致、各项目质量状况透明、对比，建立统一的评测体系。&lt;/p&gt;

&lt;p&gt;为了让你有一个很直观的认识，我在下面画了一个张图，希望可以帮助快速理解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-sign.toutiaoimg.com/tos-cn-i-qvj2lq49k0/c4205dbd8cc34e0bb884de4f25028196%7Enoop.image?_iz=58558&amp;amp;from=article.pc_detail&amp;amp;x-expires=1669790825&amp;amp;x-signature=AkQGG9%2FqByBy3x1rJnGUK%2FWJff4%3D&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在日常开发工作中，大家都会想到通过增加人手来缓解项目交付的压力，这是可以理解，但是从整体角度看，人员的增加会产生越来越多的坏代码，使整体的效率下降，这又进而加剧了后续项目交付的压力，在这种压力下，又通过增加人手缓解......让代码质量变的越来越差，这也是房间为什么会越来越乱，是熵增定律在软件质量域的生动体现。&lt;/p&gt;

&lt;p&gt;为了抑制这种恶性循环，我们意识到了通过有效的手段和资源投入进行各项工程实践，逐步完善代码质量的管控体系，积累很多方法和工具。&lt;/p&gt;

&lt;p&gt;目前，我也在积极探索对统一代码质量评测体系的实践，希望逐步建立一套中心化的代码质量评测系统，在这个系统中让工匠精神、专家文化借住平台进一步传播、让系统的质量更加透明。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dd31cb279ba0e36795a78066ee7ee067</guid>
<title>现代化 C 使用体验</title>
<link>https://toutiao.io/k/nz0xzfo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;outline-text-headline-6&quot; class=&quot;outline-text-3&quot;&gt;&lt;p&gt;指针作为 C 中最重要的一类型，往往会给初学者造成较大困扰，不仅仅是使用上，光是解读指针定义就不是件容易的事情。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 比较好理解，是指向 int 类型的指针，那 &lt;code class=&quot;verbatim&quot;&gt;ptr2&lt;/code&gt; 呢？是指向数组的指针，还是元素为指针的数组？&lt;/p&gt;&lt;p&gt;其实这个问题在 K&amp;amp;R C 这本书有一点睛之笔，即：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也就是说，变量的声明语法，阐明了该变量在表达式中的类型。翻译过来比较绕，看几个例子就明白了：&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*ptr&lt;/code&gt; 是一个类型为 int 的表达式，因此 ptr 必须是指针，指向 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 arr 必须是数组，数组元素为 int&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*arr[i]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;arr[i]&lt;/code&gt; 必须是指针，因此 arr 必须是数组，元素是 int 的指针。&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*ptr)[100]&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;ptr&lt;/code&gt; 必须是指针，指向一个 int 类型数组&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;*comp()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;comp()&lt;/code&gt; 必须返回一个 int 指针，因此 comp 是一个函数，返回值是 int 的指针&lt;/p&gt;&lt;p&gt;&lt;code class=&quot;verbatim&quot;&gt;(*comp)()&lt;/code&gt; 是一个类型为 int 的表达式，因此 &lt;code class=&quot;verbatim&quot;&gt;*comp&lt;/code&gt; 必须是一个函数，因此 comp 是一个函数指针&lt;/p&gt;&lt;p&gt;通过上面的解释，如果读者一时没有理解也不要紧，平时写代码用到时再来揣摩其中的奥妙。对于复杂的声明，一般推荐用 typedef 的方式。比如：&lt;/p&gt;&lt;div class=&quot;src src-c&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;div class=&quot;chroma&quot;&gt;&lt;table class=&quot;lntable&quot;&gt;&lt;tr&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code&gt;&lt;span class=&quot;lnt&quot; id=&quot;1&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;2&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot;&gt;3&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;4&quot;&gt;&lt;a href=&quot;#4&quot;&gt;4&lt;/a&gt;
&lt;/span&gt;&lt;span class=&quot;lnt&quot; id=&quot;5&quot;&gt;&lt;a href=&quot;#5&quot;&gt;5&lt;/a&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;lntd&quot;&gt;&lt;pre tabindex=&quot;0&quot; class=&quot;chroma&quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int_ptr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cl&quot;&gt;&lt;span class=&quot;n&quot;&gt;array_of_ten&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;通过这种方式定义的 &lt;code class=&quot;verbatim&quot;&gt;a1&lt;/code&gt; 理解起来就没什么难度了，它首先是一数组，数组的元素是指向 int 的指针。K&amp;amp;R C 有一个程序，可以将复杂声明转为文字描述：&lt;a href=&quot;https://stackoverflow.com/questions/40388241/kr-recursive-descent-parser-strcat&quot;&gt;K&amp;amp;R - Recursive descent parser&lt;/a&gt;。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28f2920aab313b5bb19d1f3c6f181c87</guid>
<title>零拷贝技术第二篇：Go 语言中的应用</title>
<link>https://toutiao.io/k/6bnvoqn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书接上回:&lt;span&gt;零拷贝技术第一篇：综述&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;, 我们留了一个小尾巴，还没有介绍Go语言中零拷贝技术的应用，那么本文将带你了解Go标准库中零拷贝技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go标准库中的零拷贝&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Go标准库中，也广泛使用了零拷贝技术来提高性能。因为零拷贝相关的技术很多都是通过系统调用提供的，所以在Go标准库中，也封装了这些系统调用，相关封装的代码可以在&lt;span&gt;internal/poll&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;找到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以Linux为例，毕竟我们大部分的业务都是在Linux运行的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;sendfile&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;internal/poll/sendfile_linux.go&lt;/code&gt;文件中，封装了&lt;code&gt;sendfile&lt;/code&gt;系统调用，我删除了一部分的代码，这样更容易看到它是如何封装的:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/ SendFile wraps the sendfile system call.&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SendFile&lt;/span&gt;&lt;span&gt;(dstFD *FD, src &lt;span&gt;int&lt;/span&gt;, remain &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ...... &lt;span&gt;//写锁&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; dst := dstFD.Sysfd&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; written &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; err error&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; remain &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  n := maxSendfileSize&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(n) &amp;gt; remain {&lt;br/&gt;   n = &lt;span&gt;int&lt;/span&gt;(remain)&lt;br/&gt;  }&lt;br/&gt;  n, err1 := syscall.Sendfile(dst, src, &lt;span&gt;nil&lt;/span&gt;, n)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   written += &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   remain -= &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; n == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; err1 == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  ...... &lt;span&gt;// error处理&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到&lt;code&gt;SendFile&lt;/code&gt;调用senfile批量写入数据。&lt;code&gt;sendfile&lt;/code&gt;系统调用一次最多会传输 0x7ffff00(2147479552) 字节的数据。这里Go语言设置maxSendfileSize为 0&amp;lt;&amp;lt;20 (4194304)字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;net/sendfile_linux.go&lt;/code&gt;文件中会使用到它:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sendFile&lt;/span&gt;&lt;span&gt;(c *netFD, r io.Reader)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, err error, handled &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; remain &lt;span&gt;int64&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;62&lt;/span&gt; &lt;span&gt;// by default, copy until EOF&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; lr, ok := r.(*io.LimitedReader)&lt;br/&gt; ......&lt;br/&gt; f, ok := r.(*os.File)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; sc, err := f.SyscallConn()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; werr error&lt;br/&gt; err = sc.Read(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(fd &lt;span&gt;uintptr&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  written, werr = poll.SendFile(&amp;amp;c.pfd, &lt;span&gt;int&lt;/span&gt;(fd), remain)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  err = werr&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; lr != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  lr.N = remain - written&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, wrapSyscallError(&lt;span&gt;&quot;sendfile&quot;&lt;/span&gt;, err), written &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数谁又会调用呢？是&lt;strong&gt;TCPConn&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *TCPConn)&lt;/span&gt; &lt;span&gt;readFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n, err, handled := splice(c.fd, r); handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n, err, handled := sendFile(c.fd, r); handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; genericReadFrom(c, r)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法又会被ReadFrom方法封装。记住这个&lt;strong&gt;ReadFrom&lt;/strong&gt;方法，我们待会再说。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *TCPConn)&lt;/span&gt; &lt;span&gt;ReadFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int64&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !c.ok() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, syscall.EINVAL&lt;br/&gt; }&lt;br/&gt; n, err := c.readFrom(r)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; err != io.EOF {&lt;br/&gt;  err = &amp;amp;OpError{Op: &lt;span&gt;&quot;readfrom&quot;&lt;/span&gt;, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCPConn.readFrom方法实现很有意思。它首先检查是否满足使用splice系统调用进行零拷贝优化，在目的是TCP connection, 源是TCP或者是Unix connection才能调用splice。否则才尝试使用sendfile。如果要使用sendfile优化，也有限制，要求源是*os.File文件。再否则使用不同的拷贝方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReadFrom又会在什么情况下被调用？实际上你经常会用到，&lt;code&gt;io.Copy&lt;/code&gt;就会调用&lt;code&gt;ReadFrom&lt;/code&gt;。也许在不经意之间，当你在将文件写入到socket过程中，就不经意使用到了零拷贝。当然这不是唯一的调用和被使用的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们看一个调用链，就会把脉络弄清楚：&lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; &lt;code&gt;*TCPConn.ReadFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;*TCPConn.readFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;net.sendFile&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.sendFile&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;splice&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面你也看到了，&lt;code&gt;*TCPConn.readFrom&lt;/code&gt;初始就是尝试使用splice,使用的场景和限制也提到了。&lt;code&gt;net.splice&lt;/code&gt;函数其实是调用&lt;code&gt;poll.Splice&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Splice&lt;/span&gt;&lt;span&gt;(dst, src *FD, remain &lt;span&gt;int64&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, handled &lt;span&gt;bool&lt;/span&gt;, sc &lt;span&gt;string&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p, sc, err := getPipe()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, sc, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; putPipe(p)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; inPipe, n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; &amp;amp;&amp;amp; remain &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  max := maxSpliceSize&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(max) &amp;gt; remain {&lt;br/&gt;   max = &lt;span&gt;int&lt;/span&gt;(remain)&lt;br/&gt;  }&lt;br/&gt;  inPipe, err = spliceDrain(p.wfd, src, max)&lt;br/&gt;  handled = handled || (err != syscall.EINVAL)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; || inPipe == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  p.data += inPipe&lt;br/&gt;&lt;br/&gt;  n, err = splicePump(dst, p.rfd, inPipe)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; n &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   written += &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   remain -= &lt;span&gt;int64&lt;/span&gt;(n)&lt;br/&gt;   p.data -= n&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; written, handled, &lt;span&gt;&quot;splice&quot;&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇中讲到pipe如果每次都创建其实挺损耗性能的，所以这里使用了pip pool,也提到是潘少优化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你看到，不经意间你就会用到splice或者sendfile。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;CopyFileRange&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;copy_file_range_linux.go&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;封装了copy_file_range系统调用。因为这个系统调用非常的新，所以封装的时候首先要检查Linux的版本，看看是否支持此系统调用。版本检查和调用批量拷贝的代码我们略过，具体看是怎么使用这个系统调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;copyFileRange&lt;/span&gt;&lt;span&gt;(dst, src *FD, max &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := dst.writeLock(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; dst.writeUnlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := src.readLock(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; src.readUnlock()&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  n, err = unix.CopyFileRange(src.Sysfd, &lt;span&gt;nil&lt;/span&gt;, dst.Sysfd, &lt;span&gt;nil&lt;/span&gt;, max, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != syscall.EINTR {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;(n), err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哪里会使用到它呢？of.File的读取数据的时候：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; pollCopyFileRange = poll.CopyFileRange&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(f *File)&lt;/span&gt; &lt;span&gt;readFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(written &lt;span&gt;int64&lt;/span&gt;, handled &lt;span&gt;bool&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// copy_file_range(2) does not support destinations opened with&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// O_APPEND, so don&#x27;t even try.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; f.appendMode {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; remain := &lt;span&gt;int64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;62&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; lr, ok := r.(*io.LimitedReader)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ok {&lt;br/&gt;  remain, r = lr.N, lr.R&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; remain &amp;lt;= &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; src, ok := r.(*File)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !ok {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; src.checkValid(&lt;span&gt;&quot;ReadFrom&quot;&lt;/span&gt;) != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Avoid returning the error as we report handled as false,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// leave further error handling as the responsibility of the caller.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; written, handled, err = pollCopyFileRange(&amp;amp;f.pfd, &amp;amp;src.pfd, remain)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; lr != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  lr.N -= written&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written, handled, NewSyscallError(&lt;span&gt;&quot;copy_file_range&quot;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的是*FIle.ReadFrom调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(f *File)&lt;/span&gt; &lt;span&gt;ReadFrom&lt;/span&gt;&lt;span&gt;(r io.Reader)&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int64&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := f.checkValid(&lt;span&gt;&quot;write&quot;&lt;/span&gt;); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; n, handled, e := f.readFrom(r)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !handled {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; genericReadFrom(f, r) &lt;span&gt;// without wrapping&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n, f.wrapErr(&lt;span&gt;&quot;write&quot;&lt;/span&gt;, e)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个优化用在文件的拷贝中，一般的调用链路是 &lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; &lt;code&gt;*File.ReadFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;*File.readFrom&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.CopyFileRange&lt;/code&gt; -&amp;gt; &lt;code&gt;poll.copyFileRange&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;标准库零拷贝的应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go标准库将零拷贝技术在底层做了封装，所以很多时候你是不知道的。比如你实现了一个简单的文件服务器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;import &quot;net/http&quot;&lt;br/&gt;&lt;br/&gt;func main() {&lt;br/&gt;// 绑定一个handler&lt;br/&gt;http.Handle(&quot;/&quot;, http.StripPrefix(&quot;/static/&quot;, http.FileServer(http.Dir(&quot;../root.img&quot;))))&lt;br/&gt;// 监听服务&lt;br/&gt;http.ListenAndServe(&quot;:8972&quot;, nil)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用链如左：&lt;code&gt;http.FileServer&lt;/code&gt; -&amp;gt; &lt;code&gt;*fileHandler.ServeHTTP&lt;/code&gt; -&amp;gt; &lt;code&gt;http.serveFile&lt;/code&gt; -&amp;gt; &lt;code&gt;http.serveContent&lt;/code&gt; -&amp;gt; &lt;code&gt;io.CopyN&lt;/code&gt; -&amp;gt; &lt;code&gt;io.Copy&lt;/code&gt; -&amp;gt; 和sendFile的调用链接上了。可以看到访问文件的时候是调用了sendFile。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三方库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几个库提供了sendFile/splice的封装。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://github.com/acln0/zerocopy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/hslam/splice&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://github.com/hslam/sendfile&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为直接调用系统调用很方便，所以很多时候我们可以模仿标准库实现我们自己零拷贝的方法。所以个人感觉这些传统的方式没有太多锦上添花的东西可做了，要做的就是新的零拷贝系统接口的封装或者自定义开发。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;零拷贝技术第一篇：综述: &lt;span&gt;https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;internal/poll: &lt;span&gt;https://github.com/golang/go/tree/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;copy_file_range_linux.go: &lt;span&gt;https://github.com/golang/go/blob/600db8a514600df0d3a11edc220ed7e2f51ca158/src/internal/poll/copy_file_range_linux.go&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1153762a7ad9ea61043f1cbbe2a9142a</guid>
<title>判断线程池是否全部完成的 5 种方法，还有谁不会？？</title>
<link>https://toutiao.io/k/w4f2muf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近写小玩具的时候用到了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 计数器，然后顺便想了想判断线程池全部结束有多少种方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在网上搜了下，可能有些没找到，但是我找到的有（所有方法都是在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 线程池方法下测试的）：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 判断方式，在执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，关闭线程池后，判断是否所有任务已经完成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getCompletedTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，判断完成任务数和全部任务数是否相等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 计数器，使用闭锁计数来判断是否全部完成。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;手动维护一个公共计数 ，原理和闭锁类似，就是更加灵活。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;submit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 向线程池提交任务，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 判断任务执行状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好嘞，现在开始一个一个介绍优缺点和简要原理；&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先创建一个 static 线程池，后面好几个例子就不一一创建了，全部用这个就行了：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 创建一个最大线程数是20的线程池&lt;br/&gt; */&lt;br/&gt;public static ThreadPoolExecutor pool = new ThreadPoolExecutor(&lt;br/&gt;     10, 20, 0L,&lt;br/&gt;     TimeUnit.MILLISECONDS,&lt;br/&gt;     new LinkedBlockingQueue&amp;lt;&amp;gt;());&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后再准备一个通用的睡眠方法：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 线程执行方法，随机等待0到10秒&lt;br/&gt; */&lt;br/&gt;private static void sleepMtehod(int index){&lt;br/&gt;    try {&lt;br/&gt;        long sleepTime = new Double(Math.random() * 10000).longValue();&lt;br/&gt;        Thread.sleep(sleepTime);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;当前线程执行结束: &quot;&lt;/span&gt; + index);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方法就是为了测试的时候区分线程执行完毕的下顺序而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好嘞，准备完毕，现在开始。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;isTerminated 方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先贴上测试代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void shutdownTest() throws Exception {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;        int index = i;&lt;br/&gt;        pool.execute(() -&amp;gt; sleepMtehod(index));&lt;br/&gt;    }&lt;br/&gt;    pool.shutdown();&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!pool.isTerminated()){&lt;br/&gt;        Thread.sleep(1000);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这一种方式就是在主线程中进行循环判断，全部任务是否已经完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里有两个主要方法：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：启动有序关闭，其中先前提交的任务将被执行，但不会接受任何新任务。如果已经关闭，调用没有额外的作用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果所有任务在关闭后完成，则返回true。请注意， &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 从不是 true，除非 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdownNow&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 先被执行。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通俗点讲，就是在执行全部任务后，对线程池进行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 有序关闭，然后循环判断 &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，线程池是否全部完成。另外，&lt;span&gt;最新最全的 Java 面试题整理好了，点击&lt;/span&gt;Java面试库&lt;span&gt;小程序在线刷题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：操作简单，代码更加简单。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：需要关闭线程池。一般我在代码中都是将线程池注入到 Spring 容器，然后各个组件中统一用同一个，当然不能关闭。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类似方法扩展：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;shutdownNow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：尝试停止所有主动执行的任务，停止等待任务的处理，并返回正在等待执行的任务列表。从此方法返回时，这些任务将从任务队列中删除。通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Thread.interrupt()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 取消任务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isShutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果线程池已关闭，则返回 true 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;isTerminating()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：如果在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdown()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shutdownNow()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之后终止 ，但尚未完全终止，则返回true。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;waitTermination(long timeout, TimeUnit unit)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：当前线程阻塞，直到等所有已提交的任务（包括正在跑的和队列中等待的）执行完，或者等超时时间到，或者线程被中断抛出异常；全部执行完返回true，超时返回false。也可以用这个方法代替 &lt;/span&gt;&lt;code&gt;&lt;span&gt;isTerminated()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进行判断 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;getCompletedTaskCount&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还是一样，贴上代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void taskCountTest() throws Exception {&lt;br/&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;            int index = i;&lt;br/&gt;            pool.execute(() -&amp;gt; sleepMtehod(index));&lt;br/&gt;        }&lt;br/&gt;        //当线程池完成的线程数等于线程池中的总线程数&lt;br/&gt;        &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!(pool.getTaskCount() == pool.getCompletedTaskCount())) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;任务总数:&quot;&lt;/span&gt; + pool.getTaskCount() + &lt;span&gt;&quot;； 已经完成任务数:&quot;&lt;/span&gt; + pool.getCompletedTaskCount());&lt;br/&gt;            Thread.sleep(1000);&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还是一样在主线程循环判断，主要就两个方法：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：返回计划执行的任务总数。由于任务和线程的状态可能在计算过程中动态变化，因此返回的值只是一个近似值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;getCompletedTaskCount()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：返回完成执行的任务的大致总数。因为任务和线程的状态可能在计算过程中动态地改变，所以返回的值只是一个近似值，但是在连续的调用中并不会减少。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个好理解，总任务数等于已完成任务数，就表示全部执行完毕。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：完全使用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 提供的方法，并且不必关闭线程池，避免了创建和销毁带来的损耗。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：上面的解释也看到了，使用这种判断存在很大的限制条件；必须确定，在循环判断过程中，没有新的任务产生。差不多意思就是，这个线程池只能在这条线程中使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其他 ：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后扯两句，因为我用 main 方法运行的，跑完后 main 没有结束，是因为非守护线程如果不终止，程序是不会结束的。而线程池 Worker 线程里写了一个死循环，而且被设置成了非守护线程。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;CountDownLatch 计数器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方法是我比较常用的方法，先看代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void countDownLatchTest() throws Exception {&lt;br/&gt;     //计数器，判断线程是否执行结束&lt;br/&gt;     CountDownLatch taskLatch = new CountDownLatch(30);&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;         int index = i;&lt;br/&gt;         pool.execute(() -&amp;gt; {&lt;br/&gt;             sleepMtehod(index);&lt;br/&gt;             taskLatch.countDown();&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;当前计数器数量：&quot;&lt;/span&gt; + taskLatch.getCount());&lt;br/&gt;         });&lt;br/&gt;     }&lt;br/&gt;     //当前线程阻塞，等待计数器置为0&lt;br/&gt;     taskLatch.await();&lt;br/&gt;     System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方法，呃，应该是看起来比较高级的，我也不知道别的大佬怎么写的，反正我就用这个。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方法需要介绍下这个工具类 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。先把这种方式的优缺点写了，后面再详细介绍这个类。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：代码优雅，不需要对线程池进行操作，将线程池作为 Bean 的情况下有很好的使用场景。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：需要提前知道线程数量；性能确实，呃呃呃呃呃，差了点。哦对了，还需要在线程代码块内加上异常判断，否则在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 之前发生异常而没有处理，就会导致主线程永远阻塞在 await。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;CountDownLatch 概述&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 JDK 提供的一个同步工具，它可以让一个或多个线程等待，一直等到其他线程中执行完成一组操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常用的方法有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在初始化时，需要指定用给定一个整数作为计数器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法时，计数器会被减1；当调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;await&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法时，如果计数器大于0时，线程会被阻塞，一直到计数器被 &lt;/span&gt;&lt;code&gt;&lt;span&gt;countDown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法减到0时，线程才会继续执行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;计数器是无法重置的，当计数器被减到0时，调用 await 方法都会直接返回。最新最全的 Java 多线程面试题整理好了，点击Java面试库小程序在线刷题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;维护一个公共计数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式其实和 CountDownLatch 原理类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先维护一个静态变量&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static int taskNum = 0;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后在线程任务结束时，进行静态变量操作：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void staticCountTest() throws Exception {&lt;br/&gt;     Lock lock = new ReentrantLock();&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;/span&gt; (int i = 0; i &amp;lt; 30; i++) {&lt;br/&gt;         int index = i;&lt;br/&gt;         pool.execute(() -&amp;gt; {&lt;br/&gt;             sleepMtehod(index);&lt;br/&gt;             lock.lock();&lt;br/&gt;             taskNum++;&lt;br/&gt;             lock.unlock();&lt;br/&gt;         });&lt;br/&gt;     }&lt;br/&gt;     &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt;(taskNum &amp;lt; 30) {&lt;br/&gt;         Thread.sleep(1000);&lt;br/&gt;         System.out.println(&lt;span&gt;&quot;还没停止。。。当前完成任务数:&quot;&lt;/span&gt; + taskNum);&lt;br/&gt;     }&lt;br/&gt;     System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实就是加锁计数，循环判断。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优点 ：手动维护方式更加灵活，对于一些特殊场景可以手动处理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;缺点 ：和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 相比，一样需要知道线程数目，但是代码实现比较麻烦，相对于灵活这一个优势，貌似投入产出并不对等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Future 判断任务执行状态&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是用来装载线程结果的，不过，用这个来进行判断写代码总感觉怪怪的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只能装载一条线程的返回结果，多条线程总不能用 List 在接收 Future 。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里就开一个线程做个演示：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private static void futureTest() throws Exception {&lt;br/&gt;    Future&amp;lt;?&amp;gt; future = pool.submit(() -&amp;gt; sleepMtehod(1));&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (!future.isDone()){&lt;br/&gt;        Thread.sleep(500);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;还没停止。。。&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;全部执行完毕&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式就不写优缺点了，因为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Future&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的主要使用场景并不是用于判断任务执行状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>06e31cfaf9b59983cdda7e9609725d16</guid>
<title>读《Understanding Real-World Concurrency Bugs in Go》</title>
<link>https://toutiao.io/k/6fcoxmx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;《Understanding Real-World Concurrency Bugs in Go》这应该是第一篇基于数个流行的开源 Go 语言项目，统计并分析其中并发 Bug 的论文？&lt;/p&gt;&lt;p&gt;论文的统计与分析给相关领域研究员或 Go 开发者带来一些信息参考：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对 Go 的并发 Bug 做了分类。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指出了目前检测工具的不足与原因。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;讨论并发 Bug 的 Go 语言代码例子以及通常的 fix 方法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;论文讨论的一部分 Bug 属于比较常见，也容易发现或是不易重复犯错的。但另一部分比如 data race 类其实不一定容易发现，这其实也反映在开源项目上往往存在一些 Bug 的产生到发现需要很久。为了避免大部分 Bug，要求 Go 语言开发者提高对工具和标准库原理的熟悉度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6772334293948127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlfJ9xvT2b2RIN4poTwEvhfXKPa4ZBq4mt49wtgfdq296m2FCrS2LgFwOIWNIozd4JEZrk1KqEVomddRskv8Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;347&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一、分类&lt;/p&gt;&lt;p&gt;论文基于 Docker、Kubernetes、ETCD、BoltDB、CockroachDB、Grpc-go 这六个开源项目，按关键字在 git commit history 中筛选出最终 171 个 Bug，并去复现这些 Bug。论文将 171 个 Bug 分成两大类，Behavior（Bug 的表现） 和 Cause（Bug 的根因），每个大类再划分成两个小类：&lt;/p&gt;&lt;p&gt;Behavior&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;blocking，比如 goroutine 会被阻塞不能继续执行，传统的 deadlock 也属于这类。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;non-blocking，虽然没有被阻塞的 goroutine，但是当中已经出现错误的状态、数值等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;Cause&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;shared memory，也就是传统的通过共享内存来实现的并发能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;message passing，是 Go 语言提供的，基于 channel 的 SCP 能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4586387434554974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlfJ9xvT2b2RIN4poTwEvhfXKPa4ZBq4EkvwmAt3J0COibYwjmlFwWkLFJXU6nSXndXAgprPrNAdZnVwDQlwQKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1910&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;二、检测工具&lt;/p&gt;&lt;p&gt;论文提出的检测工具不足，分别是指(deadlock)死锁检测和(data race)竞态检测。&lt;/p&gt;&lt;p&gt;死锁检测上，论文在 21 个可复现的 Blocking Bug 上使用 deadlock detector，只有 2 个 Case 能被检测出来。给出两个原因：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果还有其它 goroutine 在执行时，不认为存在死锁。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;只在一些 Go 自带的并发原语操作上做检测，并不检测是否阻塞在某些资源的等待上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;竞态检测上，论文在 20 个可复现的 Non-Blocking Bug 上使用 race detector，只有 10 个 Case 能被检测出来，其中 4 个 Case 需要执行 100 次检测才能被发现。给出三个原因：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不是所有的 Non-Blocking Bug 都是 data race 造成的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;happen-before 算法依赖 goroutine 并发执行顺序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;检测器在更长的运行时间里可能会丢失一些用于竞态检测的信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;三、并发 Bug&lt;/p&gt;&lt;p&gt;在 Go 语言中，Shared Memory 通常是指 sync 标准包里面的 Mutex、Atomic、Once、WaitGroup、Cond 功能，Message Passing 则是 Channel 能力以及 sync 包与 Channel 的混用。&lt;/p&gt;&lt;p&gt;这里汇总论文列出的并发 Bug 的代码样例：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Blocking Bug&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、WaitGroup 使用不当&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; group sync.WaitGroup&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;   group.Add(&lt;span&gt;len&lt;/span&gt;(pm.plugins))&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; _,p := &lt;span&gt;range&lt;/span&gt; pm.plugins {&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(p *plugin)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;       &lt;span&gt;defer&lt;/span&gt; group.Done()&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;     }()&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; -   group.Wait()&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt;9&lt;/span&gt; + group.Wait()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、hcancel 可能在 timeout &amp;gt; 0 时被覆盖，导致 context 关联的 goroutine 可能会泄露&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt; - hctx, hcancel := context.WithCancel(ctx)&lt;br/&gt;&lt;span&gt;2&lt;/span&gt; + &lt;span&gt;var&lt;/span&gt; hctx context.Context&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; + &lt;span&gt;var&lt;/span&gt; hcancel context.CancelFunc&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; timeout &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;        hctx, hcancel = context.WithTimeout(ctx, timeout)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; + { &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; +     hctx, hcancel = context.WithCancel(ctx)&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、两个并行的 goroutine 造成死锁&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;goroutine1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;     m.Lock()&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; -   ch &amp;lt;- request &lt;span&gt;//blocks&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt; +   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt; +     &lt;span&gt;case&lt;/span&gt; ch &amp;lt;- request&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; +     &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; +   }&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;     m.Unlock()&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;   }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;goroutine2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;     m.Lock()&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;     m.Unlock()&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;     request &amp;lt;- ch&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Non-Blocking Bug&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、data race 问题&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;17&lt;/span&gt;; i &amp;lt;= &lt;span&gt;21&lt;/span&gt;; i++ { &lt;span&gt;// write&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt; -   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; { &lt;span&gt;/* Create a new goroutine */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; +   &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;       apiVersion := fmt.Sprintf(&lt;span&gt;&quot;v1.%d&quot;&lt;/span&gt;, i) &lt;span&gt;// read&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;       ...&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; -   }()&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; +   }(i)&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、误用 WaitGroup&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *peer)&lt;/span&gt; &lt;span&gt;send&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;    p.mu.Lock()&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;defer&lt;/span&gt; p.mu.Unlock()&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;    &lt;span&gt;switch&lt;/span&gt; p.status {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;      &lt;span&gt;case&lt;/span&gt; idle:&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; +      p.wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;        &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;8&lt;/span&gt; -        p.wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;          ...&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;         p.wg.Done()&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;       }()&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; stopped:&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;   }&lt;br/&gt;&lt;span&gt;14&lt;/span&gt; }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p * peer)&lt;/span&gt; &lt;span&gt;stop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;   p.mu.Lock()&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;   p.status = stopped&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;   p.mu.Unlock()&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;   p.wg.Wait()&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、重复 close(Channel)，可能两个 goroutine 会同时执行到这段代码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt; - &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;2&lt;/span&gt; -   &lt;span&gt;case&lt;/span&gt; &amp;lt;- c.closed:&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; -     &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;&lt;span&gt;4&lt;/span&gt; +     Once.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;        &lt;span&gt;close&lt;/span&gt;(c.closed)&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; +     })&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; - }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4、意外地过早 return。假如 dur &amp;lt;= 0 时，select 语句会直接命中 timer.C，从而过早退出。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;  - timer := time.NewTimer(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;  + &lt;span&gt;var&lt;/span&gt; timeout &amp;lt;- &lt;span&gt;chan&lt;/span&gt; time.Time&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; dur &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;  -  timer = time.NewTimer(dur)&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;  +  timeout = time.NewTimer(dur).C&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;  -  &lt;span&gt;case&lt;/span&gt; &amp;lt;- timer.C:&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;  +  &lt;span&gt;case&lt;/span&gt; &amp;lt;- timeout:&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;论文中还有一些论点是基于数据分析给出的，感兴趣的读者可以研读论文原文。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8266199649737302&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WlfJ9xvT2b0A8rJNnt3R8XpjibJnKuDficIaN4hcv82Y12BnwjBfpJ79WpLa3LanITnUEbrkHibcJsVqjD7XI29cg/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>