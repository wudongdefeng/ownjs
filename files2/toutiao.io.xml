<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bf4e2fb3c7a28c69210c2142210116d2</guid>
<title>聊聊Spring中最常用的11个扩展点</title>
<link>https://toutiao.io/k/dsdovcg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一说到spring，可能第一个想到的是 &lt;code&gt;IOC&lt;/code&gt;（控制反转） 和 &lt;code&gt;AOP&lt;/code&gt;（面向切面编程）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，它们是spring的基石，得益于它们的优秀设计，使得spring能够从众多优秀框架中脱颖而出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们在使用spring的过程中，有没有发现它的&lt;code&gt;扩展能力非常强&lt;/code&gt;。由于这个优势的存在，让spring拥有强大的包容能力，让很多第三方应用能够轻松投入spring的怀抱。比如：rocketmq、mybatis、redis等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊，在Spring中最常用的11个扩展点。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9602836879432625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxDmwa9TMnkpXkojB1z60Dh8Dtib4P74A3c1cmHS3ZnCS9UFQqfaMcJGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.自定义拦截器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器根spring拦截器相比，它里面能够获取&lt;code&gt;HttpServletRequest&lt;/code&gt;和&lt;code&gt;HttpServletResponse&lt;/code&gt;等web对象实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring mvc拦截器的顶层接口是：&lt;code&gt;HandlerInterceptor&lt;/code&gt;，包含三个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;preHandle 目标方法执行前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postHandle 目标方法执行后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;afterCompletion 请求完成时执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便我们一般情况会用&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口的实现类&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有权限认证、日志、统计的场景，可以使用该拦截器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，继承&lt;code&gt;HandlerInterceptorAdapter&lt;/code&gt;类定义拦截器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AuthInterceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HandlerInterceptorAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;preHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response, Object handler)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        String requestUrl = request.getRequestURI();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (checkAuth(requestUrl)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkAuth&lt;/span&gt;&lt;span&gt;(String requestUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===权限校验===&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，将该拦截器注册到spring容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebAuthConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AuthInterceptor &lt;span&gt;getAuthInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AuthInterceptor();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addInterceptors&lt;/span&gt;&lt;span&gt;(InterceptorRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addInterceptor(&lt;span&gt;new&lt;/span&gt; AuthInterceptor());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.获取Spring容器对象&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，经常需要从Spring容器中获取Bean，但你知道如何获取Spring容器对象吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 BeanFactoryAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BeanFactory beanFactory;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.beanFactory = beanFactory;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) beanFactory.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;BeanFactoryAware&lt;/code&gt;接口，然后重写&lt;code&gt;setBeanFactory&lt;/code&gt;方法，就能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 ApplicationContextAware接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationContextAware&lt;/code&gt;接口，然后重写&lt;code&gt;setApplicationContext&lt;/code&gt;方法，也能从该方法中获取到spring容器对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 ApplicationListener接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonService3&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent event)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        applicationContext = event.getApplicationContext();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Person person = (Person) applicationContext.getBean(&lt;span&gt;&quot;person&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.全局异常处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理请求add接口结果直接报错：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxuR5ZfQIjHZVVqwroDTtO8xiaVWQuY90wQD8fXYdGSACmOicnEzpfPic8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        retur nnull;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.类型转换器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring目前支持3中类型转换器：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Converter&amp;lt;S,T&amp;gt;：将 S 类型对象转为 T 类型对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ConverterFactory&amp;lt;S, R&amp;gt;：将 S 类型对象转为 R 类型及子类对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这3种类型转换器使用的场景不一样，我们以&lt;code&gt;Converter&amp;lt;S,T&amp;gt;为&lt;/code&gt;例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个实体User：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Date registerDate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，实现&lt;code&gt;Converter&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateConverter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Converter&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Date&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; SimpleDateFormat simpleDateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;convert&lt;/span&gt;&lt;span&gt;(String source)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (source != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(source)) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                simpleDateFormat.parse(source);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ParseException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，将新定义的类型转换器注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebConfig&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WebMvcConfigurerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addFormatters&lt;/span&gt;&lt;span&gt;(FormatterRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        registry.addConverter(&lt;span&gt;new&lt;/span&gt; DateConverter());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四步，调用接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/user&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/save&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(@RequestBody User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求接口时User对象中registerDate字段会被自动转换成Date类型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.导入配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时我们需要在某个配置类中引入另外一些类，被引入的类也加到spring容器中。这时可以使用&lt;code&gt;@Import&lt;/code&gt;注解完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过它的源码会发现，引入的类支持三种不同类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我认为最好将普通类和@Configuration注解的配置类分开讲解，所以列了四种不同类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30185185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaDcuvJ3nHO9icHddBSomYUxiclRH4kP1BV372N3MRDmMicxaLvBhSicAKfqmGNHh0zBf8weickJ9uHl2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 普通类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式是最简单的，被引入的类会被实例化bean对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;@Import&lt;/code&gt;注解引入A类，spring就能自动实例化A对象，然后在需要使用的地方通过&lt;code&gt;@Autowired&lt;/code&gt;注解注入即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; A a;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是挺让人意外的？不用加&lt;code&gt;@Bean&lt;/code&gt;注解也能实例化bean。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 配置类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式是最复杂的，因为&lt;code&gt;@Configuration&lt;/code&gt;注解还支持多种组合注解，比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;@Import&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@ImportResource&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;@PropertySource等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;B&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(B&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; A &lt;span&gt;a&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; A();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AConfiguration&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过@Import注解引入@Configuration注解的配置类，会把该配置类相关&lt;code&gt;@Import&lt;/code&gt;、&lt;code&gt;@ImportResource&lt;/code&gt;、&lt;code&gt;@PropertySource&lt;/code&gt;等注解引入的类进行递归，一次性全部引入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.3 ImportSelector&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式需要实现&lt;code&gt;ImportSelector&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLASS_NAME = &lt;span&gt;&quot;com.sue.cache.service.test13.A&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt; &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{CLASS_NAME};&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式的好处是&lt;code&gt;selectImports&lt;/code&gt;方法返回的是数组，意味着可以同时引入多个类，还是非常方便的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.4 ImportBeanDefinitionRegistrar&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种引入方式需要实现&lt;code&gt;ImportBeanDefinitionRegistrar&lt;/code&gt;接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AImportBeanDefinitionRegistrar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RootBeanDefinition rootBeanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(A&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, rootBeanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Import&lt;/span&gt;(AImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式是最灵活的，能在&lt;code&gt;registerBeanDefinitions&lt;/code&gt;方法中获取到&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;容器注册对象，可以手动控制BeanDefinition的创建和注册。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.项目启动时&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好消息是springboot提供了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CommandLineRunner&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicationRunner&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个接口帮助我们实现以上需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的用法还是挺简单的，以&lt;code&gt;ApplicationRunner&lt;/code&gt;接口为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRunner&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationRunner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; LoadDataService loadDataService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(ApplicationArguments args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        loadDataService.load();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;ApplicationRunner&lt;/code&gt;接口，重写&lt;code&gt;run&lt;/code&gt;方法，在该方法中实现自己定制化需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是使用&lt;code&gt;@Order(n)&lt;/code&gt;注解，n的值越小越先执行。当然也可以通过&lt;code&gt;@Priority&lt;/code&gt;注解指定顺序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.修改BeanDefinition&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到&lt;code&gt;BeanDefinition&lt;/code&gt;对象中，然后通过BeanDefinition对象，实例化Bean对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想修改BeanDefinition对象中的属性，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：我们可以实现&lt;code&gt;BeanFactoryPostProcessor&lt;/code&gt;接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory configurableListableBeanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        DefaultListableBeanFactory defaultListableBeanFactory = (DefaultListableBeanFactory) configurableListableBeanFactory;&lt;br/&gt;        BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        beanDefinitionBuilder.addPropertyValue(&lt;span&gt;&quot;id&quot;&lt;/span&gt;, &lt;span&gt;123&lt;/span&gt;);&lt;br/&gt;        beanDefinitionBuilder.addPropertyValue(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;        defaultListableBeanFactory.registerBeanDefinition(&lt;span&gt;&quot;user&quot;&lt;/span&gt;, beanDefinitionBuilder.getBeanDefinition());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在postProcessBeanFactory方法中，可以获取BeanDefinition的相关对象，并且修改该对象的属性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.初始化Bean前后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，你想在初始化Bean前后，实现一些自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以实现：&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口目前有两个方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;postProcessBeforeInitialization 该在初始化方法之前调用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;postProcessAfterInitialization 该方法再初始化方法之后调用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (bean &lt;span&gt;instanceof&lt;/span&gt; User) {&lt;br/&gt;            ((User) bean).setUserName(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果spring中存在User对象，则将它的userName设置成：苏三说技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.初始化方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前spring中使用比较多的初始化bean的方法有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用@PostConstruct注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现InitializingBean接口&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.1 使用@PostConstruct注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要初始化的方法上增加&lt;code&gt;@PostConstruct&lt;/code&gt;注解，这样就有初始化的能力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.2 实现InitializingBean接口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===初始化===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现&lt;code&gt;InitializingBean&lt;/code&gt;接口，重写&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法，该方法中可以完成初始化功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.关闭容器前&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要在关闭spring容器前，做一些额外的工作，比如：关闭资源文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以实现&lt;code&gt;DisposableBean&lt;/code&gt;接口，并且重写它的&lt;code&gt;destroy&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DService&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt;, &lt;span&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;DisposableBean destroy&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;InitializingBean afterPropertiesSet&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样spring容器销毁前，会调用该destroy方法，做一些额外的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们会同时实现InitializingBean和DisposableBean接口，重写初始化方法和销毁方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.自定义作用域&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道spring默认支持的&lt;code&gt;Scope&lt;/code&gt;只有两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;singleton 单例，每次从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;prototype 多例，每次从spring容器中获取到的bean都是不同的对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring web又对Scope进行了扩展，增加了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即便如此，有些场景还是无法满足我们的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要自定义Scope了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步实现Scope接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalScope&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Scope&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal THREAD_LOCAL_SCOPE = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String name, ObjectFactory&amp;lt;?&amp;gt; objectFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object value = THREAD_LOCAL_SCOPE.get();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Object object = objectFactory.getObject();&lt;br/&gt;        THREAD_LOCAL_SCOPE.set(object);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; object;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREAD_LOCAL_SCOPE.remove();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerDestructionCallback&lt;/span&gt;&lt;span&gt;(String name, Runnable callback)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;resolveContextualObject&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getConversationId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步将新定义的Scope注入到spring容器中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        beanFactory.registerScope(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ThreadLocalScope());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步使用新定义的Scope：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Scope&lt;/span&gt;(&lt;span&gt;&quot;threadLocalScope&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8cc5aa14e435815f6272508c6d4b211a</guid>
<title>Rust 太难？那是你没看到这套 Rust 语言语言学习总结（下)</title>
<link>https://toutiao.io/k/gi384gt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;cloud-blog-detail-content blog-content-block-0&quot; id=&quot;blogContent&quot;&gt;&amp;#13;
            &lt;h1&gt;&lt;b&gt;&lt;span&gt;2.6 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;原生类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/h1&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;内置的原生类型&lt;/span&gt;&lt;span&gt; (primitive types) &lt;/span&gt;&lt;span&gt;有以下几类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;布尔类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：有两个值&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示单个&lt;/span&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符，存储为&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;个字节。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;数值类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：分为有符号整数&lt;/span&gt;&lt;span&gt; (i8, i16, i32, i64, isize)&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;无符号整数&lt;/span&gt;&lt;span&gt; (u8, u16, u32, u64, usize) &lt;/span&gt;&lt;span&gt;以及浮点数&lt;/span&gt;&lt;span&gt; (f32, f64)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;字符串类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：最底层的是不定长类型&lt;/span&gt;&lt;span&gt;str&lt;/span&gt;&lt;span&gt;，更常用的是字符串切片&lt;/span&gt;&lt;span&gt;&amp;amp;str&lt;/span&gt;&lt;span&gt;和堆分配字符串&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;其中字符串切片是静态分配的，有固定的大小，并且不可变，而堆分配字符串是可变的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有固定大小，并且元素都是同种类型，可表示为&lt;/span&gt;&lt;span&gt;[T; N]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：引用一个数组的部分数据并且不需要拷贝，可表示为&lt;/span&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;元组&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有固定大小的有序列表，每个元素都有自己的类型，通过解构或者索引来获得每个元素的值。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;指针&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：最底层的是裸指针&lt;/span&gt;&lt;span&gt;const T&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;mut T&lt;/span&gt;&lt;span&gt;，但解引用它们是不安全的，必须放到&lt;/span&gt;&lt;span&gt;unsafe&lt;/span&gt;&lt;span&gt;块里。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：具有函数类型的变量实质上是一个函数指针。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;元类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：即&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;，其唯一的值也是&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数参数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当函数参数按值传递时，会转移所有权或者执行复制（&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;）语义。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;当函数参数按引用传递时，所有权不会发生变化，但是需要有生命周期参数（符合规则时不需要显示的标明）。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;函数参数模式匹配&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ref&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：使用模式匹配来获取参数的不可变引用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ref mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：使用模式匹配来获取参数的可变引用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;除了&lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;ref mut&lt;/span&gt;&lt;span&gt;，函数参数也可以使用通配符来忽略参数。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;泛型函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数参数并未指定具体的类型，而是用了泛型&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，对&lt;/span&gt;&lt;b&gt;&lt;span&gt;T&lt;/span&gt;&lt;/b&gt;&lt;span&gt;只有一个&lt;/span&gt;&lt;span&gt;Mult trait&lt;/span&gt;&lt;span&gt;限定，即只有实现了&lt;/span&gt;&lt;span&gt;Mul&lt;/span&gt;&lt;span&gt;的类型才可以作为参数，从而保证了类型安全。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;泛型函数并未指定具体类型，而是靠编译器来进行自动推断的。如果使用的都是基本原生类型，编译器推断起来比较简单。&lt;/span&gt;&lt;span&gt;如果编译器无法自动推断，就需要显式的指定函数调用的类型&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.4 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法和函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方法代表&lt;/span&gt;&lt;span&gt;某个实例对象的行为&lt;/span&gt;&lt;span&gt;，函数只是一段简单的代码，它可以通过名字来进行调用。方法也是通过名字来进行调用，但它必须关联一个&lt;/span&gt;&lt;span&gt;方法接受者&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.7.5 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;高阶函数&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高阶函数是指&lt;/span&gt;&lt;span&gt;以函数作为参数或返回值&lt;/span&gt;&lt;span&gt;的函数，它是函数式编程语言最基础的特性。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Closure&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;通常是指词法闭包，是一个&lt;/span&gt;&lt;span&gt;持有外部环境变量&lt;/span&gt;&lt;span&gt;的函数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;外部环境&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指闭包定义时所在的词法作用域。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;外部环境变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，在函数式编程范式中也被称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;自由变量&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，是指并不是在闭包内定义的变量。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将自由变量和自身绑定的函数就是&lt;/span&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包的大小在编译期是未知的。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包的基本语法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;由&lt;/span&gt;&lt;b&gt;&lt;span&gt;管道符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（两个对称的竖线）和&lt;/span&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;（或圆括号）组成。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;管道符&lt;/span&gt;&lt;/b&gt;&lt;span&gt;里是闭包函数的参数，可以向普通函数参数那样在冒号后添加类型标注，也可以省略。例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;let add = |a, b| -&amp;gt; i32 { a + b };&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;花括号&lt;/span&gt;&lt;/b&gt;&lt;span&gt;里包含的是闭包函数执行体，花括号和返回值也可以省略。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt;let add = |a, b| a + b;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;当闭包函数没有参数只有捕获的自由变量时，管道符里的参数也可以省略。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;b&gt;&lt;span&gt; let add = || a + b;&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包的实现&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;闭包&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是一种&lt;/span&gt;&lt;b&gt;&lt;span&gt;语法糖&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。闭包不属于&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;语言提供的基本语法要素，而是在基本语法功能之上又提供的一层方便开发者编程的语法。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包和普通函数的&lt;/span&gt;&lt;b&gt;&lt;span&gt;差别&lt;/span&gt;&lt;/b&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;闭包可以捕获环境中的自由变量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包可以作为函数参数，这一点直接提升了&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;语言的抽象表达能力。当它作为函数参数传递时，可以被用作泛型的&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;限定，也可以直接作为&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;对象来使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包无法直接作为函数的返回值，如果要把闭包作为返回值，必须使用&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;闭包与所有权&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包表达式会由编译器自动翻译为结构体实例，并为其实现&lt;/span&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;span&gt;三个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;中的一个。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：会转移方法接收者的所有权。没有改变环境的能力，只能调用一次。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行可变借用。有改变环境的能力，可以多次调用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行不可变借用。没有改变环境的能力，可以多次调用。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就必须实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就必须实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;；&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，就不需要实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;捕获环境变量的方式&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，以&lt;/span&gt;&lt;b&gt;&lt;span&gt;不可变引用（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;T&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，执行移动语义，&lt;/span&gt;&lt;b&gt;&lt;span&gt;转移所有权&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;对于&lt;/span&gt;&lt;b&gt;&lt;span&gt;可变绑定&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，并且在闭包中包含对其进行修改的操作，则以&lt;/span&gt;&lt;b&gt;&lt;span&gt;可变引用（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut T&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;来进行捕获。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字来&lt;/span&gt;&lt;span&gt;强制让闭包所定义环境中的自由变量转移到闭包中&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.8.3.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;规则总结&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;没有捕获&lt;/span&gt;&lt;span&gt;任何环境变量，则默认自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;捕获了&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;类型的环境变量，则：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，无论是否使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，均会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;需要修改&lt;/span&gt;&lt;span&gt;环境变量，则自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如果闭包中&lt;/span&gt;&lt;span&gt;捕获了&lt;/span&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;span&gt;类型的环境变量，则：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，而且没有使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，则会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnOnce&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;不需要修改&lt;/span&gt;&lt;span&gt;环境变量，而且使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字，则会自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;Fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;如果&lt;/span&gt;&lt;span&gt;需要修改&lt;/span&gt;&lt;span&gt;环境变量，则自动实现&lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;FnMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的闭包在使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;move&lt;/span&gt;&lt;/b&gt;&lt;span&gt;关键字时，如果捕获变量是&lt;/span&gt;&lt;span&gt;复制语义&lt;/span&gt;&lt;span&gt;类型的，则闭包会自动实现&lt;/span&gt;&lt;span&gt;Copy/Clone&lt;/span&gt;&lt;span&gt;。如果捕获变量是&lt;/span&gt;&lt;span&gt;移动语义&lt;/span&gt;&lt;span&gt;类型的，则闭包不会自动实现&lt;/span&gt;&lt;span&gt;Copy/Clone&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;迭代器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;使用的是外部迭代器，也就是&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环。外部迭代器：外部可以控制整个遍历进程。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;中使用了&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;来抽象迭代器模式。&lt;/span&gt;&lt;b&gt;&lt;span&gt;Iterator trait&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;中对迭代器模式的抽象接口。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;迭代器主要包含：&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;next&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：迭代其内部元素&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;关联类型&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Item&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：返回类型是一个元组，该元组表示迭代器剩余长度的边界信息。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;let iterator = iter&lt;/span&gt;&lt;b&gt;&lt;span&gt;.into_iter();      &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let size_lin = iterator&lt;/span&gt;&lt;b&gt;&lt;span&gt;.size_hint(); &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;let mut counter = Counter { count: 0};&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;counter&lt;/span&gt;&lt;b&gt;&lt;span&gt;.next();                         &lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型迭代器，&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;[T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;mut [T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值。&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环会自动调用迭代器的&lt;/span&gt;&lt;b&gt;&lt;span&gt;next&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中的循环变量则是通过模式匹配，从&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;返回的&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;[T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;&amp;amp;mut [T]&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型中获取&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;[T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;或&lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;mut [T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型迭代器在&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中产生的循环变量为&lt;/span&gt;&lt;b&gt;&lt;span&gt;引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型的迭代器的&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法返回的是&lt;/span&gt;&lt;b&gt;&lt;span&gt;Option&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;span&gt;类型，在&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环中产生的循环变量是&lt;/span&gt;&lt;b&gt;&lt;span&gt;值&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，而&lt;/span&gt;&lt;b&gt;&lt;span&gt;不是引用&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td valign=&quot;top&quot;&gt; &lt;p&gt;let v = vec![1, 2, 3];&lt;/p&gt; &lt;p&gt;for i in v {&lt;/p&gt; &lt;p&gt;    …&lt;/p&gt; &lt;p&gt;}&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了确保&lt;/span&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;span&gt;方法可以获得迭代器长度的准确信息，&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;引入了两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，他们是&lt;/span&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;span&gt;的子&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，均被定义在&lt;/span&gt;&lt;span&gt;std::iter&lt;/span&gt;&lt;span&gt;模块中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;ExactSizeIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：提供了两个额外的方法&lt;/span&gt;&lt;b&gt;&lt;span&gt;len&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;is_empty&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;TrustedLen&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：像一个标签&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，只要实现了&lt;/span&gt;&lt;span&gt;TrustLen&lt;/span&gt;&lt;span&gt;的迭代器，其&lt;/span&gt;&lt;span&gt;size_hint&lt;/span&gt;&lt;span&gt;获取的长度信息均是可信的。完全避免了容器的容量检查，提升了性能。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.1 IntoIterator trait&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;如果想要迭代某个集合容器中的元素，必须将其转换为迭代器才可以使用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;FromIterator&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;span&gt;两个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;，他们互为反操作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;FromIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以从迭代器转换为指定类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以从指定类型转换为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;Intoiter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;可以使用&lt;/span&gt;&lt;b&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;之类的方法来获取一个迭代器。&lt;/span&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;span&gt;的参数时&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;span&gt;，代表该方法会转移方法接收者的所有权。而还有其他两个迭代器不用转移所有权。具体的如下所示：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Intoiter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：转移所有权，对应&lt;/span&gt;&lt;span&gt;self&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：获取不可变借用，对应&lt;/span&gt;&lt;span&gt;&amp;amp;self&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;IterMut&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：获得可变借用，对应&lt;/span&gt;&lt;span&gt;&amp;amp;mut slef&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.2 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;哪些实现了&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;的类型？&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只有实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;Iterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的类型才能作为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的集合容器可以通过&lt;/span&gt;&lt;b&gt;&lt;span&gt;into_iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;方法来转换为迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;b&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;的集合容器有：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;Vec&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/b&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span/&gt;&lt;b&gt;&lt;span&gt;&amp;amp;’a [T]&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;&amp;amp;’a mut [T]&lt;/span&gt;&lt;/b&gt;&lt;span&gt;  =&amp;gt; &lt;/span&gt;&lt;span&gt;没有为&lt;/span&gt;&lt;b&gt;&lt;span&gt;[T]&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/b&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span&gt;IntoIterator&lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.9.3 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;迭代器适配器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过适配器模式可以将一个接口转换成所需要的另一个接口。适配器模式能够使得接口不兼容的类型在一起工作。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适配器也叫&lt;/span&gt;&lt;b&gt;&lt;span&gt;包装器（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Wrapper&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器适配器，都定义在&lt;/span&gt;&lt;b&gt;&lt;span&gt;std::iter&lt;/span&gt;&lt;/b&gt;&lt;span&gt;模块中：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Map&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过对原始迭代器中的每个元素调用指定闭包来产生一个新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;b&gt;&lt;span&gt;Chain&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过连接两个迭代器来创建一个新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cloned&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：通过拷贝原始迭代器中全部元素来创建新的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Cycle&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个永远循环迭代的迭代器，当迭代完毕后，再返回第一个元素开始迭代。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Enumerate&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个包含计数的迭代器，它返回一个元组（&lt;/span&gt;&lt;span&gt;i,val&lt;/span&gt;&lt;span&gt;），其中&lt;/span&gt;&lt;span&gt;i&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;usize&lt;/span&gt;&lt;span&gt;类型，为迭代的当前索引，&lt;/span&gt;&lt;span&gt;val&lt;/span&gt;&lt;span&gt;是迭代器返回的值。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个机遇谓词判断式过滤元素的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;FlatMap&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个类似&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;的结构的迭代器，但是其中不会包含任何嵌套。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;FilterMap&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：相当于&lt;/span&gt;&lt;span&gt;Filter&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Map&lt;/span&gt;&lt;span&gt;两个迭代器一次使用后的效果。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Fuse&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个可以快速遍历的迭代器。在遍历迭代器时，只要返回过一次&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;，那么之后所有的遍历结果都为&lt;/span&gt;&lt;span&gt;None&lt;/span&gt;&lt;span&gt;。该迭代器适配器可以用于优化。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Rev&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：创建一个可以反向遍历的迭代器。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;具体可见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;可以自定义迭代器适配器，具体的见《&lt;/span&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;编程之道》的第&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;&lt;span&gt;页。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.10 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;消费器&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;迭代器不会自动发生遍历行为，需要调用&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;方法去消费其中的数据。最直接消费迭代器数据的方法就是使用&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;提供了&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;循环之外的用于消费迭代器内数据的方法，叫做&lt;/span&gt;&lt;b&gt;&lt;span&gt;消费器（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;标准库&lt;/span&gt;&lt;b&gt;&lt;span&gt;std::iter::Iterator&lt;/span&gt;&lt;/b&gt;&lt;span&gt;中常用的消费器：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;any&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：可以查找容器中是否存在满足条件的元素。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;fold&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：该方法接收两个参数，第一个为初始值，第二个为带有两个参数的闭包。其中闭包的第一个参数被称为累加器，它会将闭包每次迭代执行的结果进行累计，并最终作为&lt;/span&gt;&lt;span&gt;fold&lt;/span&gt;&lt;span&gt;方法的返回值。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;collect&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：专门用来将迭代器转换为指定的集合类型。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;all&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;for_each&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;position&lt;/span&gt;&lt;/b&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;2.11 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;锁&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;RwLock&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;读写锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：是&lt;/span&gt;&lt;b&gt;&lt;span&gt;多读单写锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;，也叫共享独占锁。它允许&lt;/span&gt;&lt;span&gt;多个线程读&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;单个线程写&lt;/span&gt;&lt;span&gt;。但是在写的时候，只能有一个线程占有写锁；而在读的时候，允许任意线程获取读锁。&lt;/span&gt;&lt;b&gt;&lt;span&gt;读锁和写锁不能被同时获取&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;Mutex&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;互斥锁&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：只允许单个线程读和写。&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;三、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt; Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;属性&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “drop”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;drop&lt;/span&gt;&lt;span&gt;标记为语言项&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug)] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Copy, Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt; :&lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[derive(Debug,Copy,Clone)]&lt;/span&gt;&lt;/b&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “owned_box”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt; Box&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;与原生类型不同，并不具备类型名称，它代表所有权唯一的智能指针的特殊性，需要使用&lt;/span&gt;&lt;span&gt;lang item&lt;/span&gt;&lt;span&gt;来专门识别。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “fn/fn_mut/fn_once”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示其属于语言项，分别以&lt;/span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;fn_mut&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;fn_once&lt;/span&gt;&lt;span&gt;名称来查找这三个&lt;/span&gt;&lt;span&gt;trait&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn_once&lt;/span&gt;&lt;/b&gt;&lt;span&gt;：会转移方法接收者的所有权&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn_mut&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行可变借用&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/b&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;会对方法接收者进行不可变借用&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;  &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[lang = “rust_pareen_sugar”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：表示对括号调用语法的特殊处理。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;#[must_use=”iterator adaptors are lazy ……”] &lt;/span&gt;&lt;/b&gt;&lt;span&gt;：用来发出警告，提示开发者迭代器适配器是惰性的。&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;四、内存管理&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;4.1 &lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;内存回收&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         drop-flag&lt;/span&gt;&lt;span&gt;：在函数调用栈中为离开作用域的变量自动插入布尔标记，标注是否调用析构函数，这样，在运行时就可以根据编译期做的标记来调用析构函数。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;span&gt;实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型，是没有析构函数的。因为实现了&lt;/span&gt;&lt;span&gt;Copy&lt;/span&gt;&lt;span&gt;的类型会复制，其生命周期不受析构函数的影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要继续深入理解第&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;章并总结，待后续补充。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;五、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;unicode&lt;/span&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符集相当于一张表，每个字符对应一个非负整数，该数字称为&lt;/span&gt;&lt;b&gt;&lt;span&gt;码点（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Code Point&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些码点也分为不同的类型：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;span&gt;标量值&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;代理对码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;非字符码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;保留码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;私有码点&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;标量值&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指实际存在对应字符的码位，其范围是&lt;/span&gt;&lt;b&gt;&lt;span&gt;0x0000~0xD7FF&lt;/span&gt;&lt;/b&gt;&lt;span&gt;和&lt;/span&gt;&lt;b&gt;&lt;span&gt;0xE000~0x10FFFF&lt;/span&gt;&lt;/b&gt;&lt;span&gt;两段。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符集的每个字符占&lt;/span&gt;&lt;b&gt;&lt;span&gt;4&lt;/span&gt;&lt;/b&gt;&lt;span&gt;个字节，使用的存储方式是：&lt;/span&gt;&lt;b&gt;&lt;span&gt;码元（&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Code Unit&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;）&lt;/span&gt;&lt;/b&gt;&lt;span&gt;组成的序列。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;码元&lt;/span&gt;&lt;/b&gt;&lt;span&gt;是指用于处理和交换编码文本的最小比特组合。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Unicode&lt;/span&gt;&lt;span&gt;字符编码表：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;ul&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;/b&gt;&lt;span&gt;      =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;1&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-16&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;2&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;/li&gt; 
 &lt;li&gt;&lt;b&gt;&lt;span&gt;UTF-32&lt;/span&gt;&lt;/b&gt;&lt;span&gt;    =&amp;gt; &lt;/span&gt;&lt;b&gt;&lt;span&gt;4&lt;/span&gt;&lt;/b&gt;&lt;span&gt;字节码元&lt;/span&gt;&lt;span/&gt;&lt;/li&gt; 
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;span&gt;的源码文件&lt;/span&gt;&lt;span&gt;.rs&lt;/span&gt;&lt;span&gt;的默认文本编码格式是&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;六、&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;Rust&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;span&gt;字符串对象常用的方法&lt;/span&gt;&lt;/b&gt;&lt;b&gt;&lt;span/&gt;&lt;/b&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt; 
 &lt;tbody&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;原型&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;new()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub const fn new() -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;创建一个新的字符串对象&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;to_string()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;fn to_string(&amp;amp;self) -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;将字符串字面量转换为字符串对象&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;replace()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn replace&amp;lt;&#x27;a, P&amp;gt;(&amp;amp;&#x27;a self, from: P, to: &amp;amp;str) -&amp;gt; String&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;搜索指定模式并替换&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;as_str()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn as_str(&amp;amp;self) -&amp;gt; &amp;amp;str&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;将字符串对象转换为字符串字面量&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;push()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn push(&amp;amp;mut self, ch: char)&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;再字符串末尾追加字符&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;push_str()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn push_str(&amp;amp;mut self, string: &amp;amp;str)&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;再字符串末尾追加字符串&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;len()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn len(&amp;amp;self) -&amp;gt; usize&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;返回字符串的字节长度&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;trim()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn trim(&amp;amp;self) -&amp;gt; &amp;amp;str&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;去除字符串首尾的空白符&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;split_whitespace()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn split_whitespace(&amp;amp;self) -&amp;gt; SplitWhitespace&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;根据空白符分割字符串并返回分割后的迭代器&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;split()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn split&amp;lt;&#x27;a, P&amp;gt;(&amp;amp;&#x27;a self, pat: P) -&amp;gt; Split&amp;lt;&#x27;a, P&amp;gt;&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;根据指定模式分割字符串并返回分割后的迭代器。模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;可以是字符串字面量或字符或一个返回分割符的闭包&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
  &lt;tr&gt; 
   &lt;td&gt; &lt;p&gt;&lt;b&gt;&lt;span&gt;chars()&lt;/span&gt;&lt;/b&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;pub fn chars(&amp;amp;self) -&amp;gt; Chars&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
   &lt;td&gt; &lt;p&gt;&lt;span&gt;返回字符串所有字符组成的迭代器&lt;/span&gt;&lt;/p&gt; &lt;/td&gt; 
  &lt;/tr&gt; 
 &lt;/tbody&gt; 
&lt;/table&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&amp;#13;
        &lt;/div&gt;&amp;#13;
        &amp;#13;
&amp;#13;
        &amp;#13;
        &amp;#13;
            &amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f8d23d2740e476a2719c9fd455412a4</guid>
<title>哔哩哔哩如何基于 Trino+Iceberg 打造高效湖仓一体平台</title>
<link>https://toutiao.io/k/byi6i0p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;哔哩哔哩 OLAP平台负责人-李呈祥在2022年9月24日的Hadoop meetup 2022上海站活动分享了题为《哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台》的主题内容，以下是具体分享。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax9o4YDzSgribvBBA2EI81vaq9pTEbunBUjFvicL0SsXUJPicA1pwPeWKMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家好，我是来自哔哩哔哩的李呈祥，非常高兴来参加Hadoop Meetup，能和大家线下沟通交流，这次我主要分享的内容是哔哩哔哩如何基于Trino+Iceberg打造高效湖仓一体平台。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxafzuk3pC3yyjYjFq9HvplqGJN9r6icuNLpsO3icZ82TQNWVOTdEKuJJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先我介绍下哔哩哔哩的数据处理流程，我们的数据主要来自于三个方面：来自APP/网页端等的埋点数据，服务端的日志数据以及业务系统数据库中的数据，经过我们数据采集端的工具和服务，采集到大数据平台中，包括离线的HDFS数据和实时的Kafka数据。&lt;/p&gt;&lt;p&gt;进入大数据平台后，我们的数据开发人员按照数据需求对数据进行加工处理，分层数据建模。主要是用Hive和Spark进行离线的数据处理，使用Flink进行实时的数据处理。用户可以使用Spark或者Trino直接访问数据开发同学建模好的数据表，但是很多时候，为了更好地支持业务在数据探索/BI报表/数据服务/全文检索等方面的实际需求，我们还需要将数据从HDFS上的Hive表导出到外部存储，从而更高效地满足用户需求，比如ClickHouse/Redis/ES等。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxqPBYe62aywhVYujqKLbRuuuuOqbSPu9v0Pk3lNYOTT3ibH5DEY0ye8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;当前的这套架构可以基本满足我们对于数据分析的需求，但是也存在许多不足之处，主要问题在于：&lt;/p&gt;&lt;p&gt;第一，从Hive表导出到外部存储，需要额外的数据同步和数据存储成本，整个数据加工的链路也变长了，可靠性降低。&lt;/p&gt;&lt;p&gt;第二，各个存储之间实际上是数据孤岛，跨源查询的成本高，效率低，基本不太可行。&lt;/p&gt;&lt;p&gt;第三，我们内部基于Hadoop/Hive生态构建的数据质量/数据血缘/安全/元数据管理等平台服务工具链很难完整覆盖各个外部存储计算引擎。&lt;/p&gt;&lt;p&gt;所以我们引入了基于Trino+Iceberg的湖仓一体架构，希望能够简化当前的数据处理流程，核心的目标有两个：一是之前存在大量的通过Trino/Spark访问Hive的情况，我们希望通过湖仓一体加速这部分的查询效率，在提升用户体验的同时，降低查询的机器资源成本。&lt;/p&gt;&lt;p&gt;第二是对于之前很多需要同步到外部存储的场景，在对性能要求没有特别高的情况下，可以不用同步到外部存储，直接使用Iceberg表响应，简化业务的数据开发流程，提升开发效率。&lt;/p&gt;&lt;p&gt;最后基于Trino+Iceberg的湖仓一体的架构可以基本上完全兼容我们大数据开发平台的所有工具链，适配的成本非常低。&lt;/p&gt;&lt;p&gt;我们希望能够基于Trino和Iceberg实现高效的OLAP引擎，提供秒级的查询响应能力，支持大部分的交互式分析需求，少部分特殊需求通过ClickHouse/ElasticSearch以及KV类存储满足。业界对于湖仓一体有多个方向的实践，比如解决数据upsert场景，或者实时数据可见性等，B站在这些方向也都有一些探索和落地实践，不过我今天要介绍的重点是我们在湖仓一体中对于仓的查询性能方向的探索。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax8XBoibndcKtnBnseR4zB5DTyKzvkKmf8ia8licF7C7K8nuRySqQkl5u0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxxZ2RV3XDquQfwkqYgUfffuRHaurLnQqqnXqnDrrE5771VCHUsWy83Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们湖仓一体的整体架构如图所示，基于Spark/Flink的ETL任务读写Iceberg表，外部服务通过Trino引擎查询Iceberg表数据。&lt;/p&gt;&lt;p&gt;Magnus是我们自研的Iceberg智能数据管理服务，Spark/Flink每次向Iceberg commit新的文件时会向Magnus通知commit信息，Magnus根据表的commit信息以及相关的policy异步调度Spark任务用于对Iceberg表中的数据组织进行优化，比如小文件合并，数据排序等等。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxh4w3KKoWb1vRBibYx4KPj9DaEOCpPBImEmQE8ZeR0ZzAB7QFA0gxNug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们的目标是基于Trino和Iceberg构建秒级响应的湖仓一体平台，这个目标的设定主要基于以下的几个我们观察到的事实：&lt;/p&gt;&lt;p&gt;一是我们主要目标业务场景，比如报表/数据产品，他们的表都是经过我们数据开发同学ETL后的强Schema规范化数据，查询的场景也主要是投影/过滤/关联/聚合这几种基本算子的组合，像是两个大表关联，或者复杂嵌套子查询，当然可以执行，但不是我们主要的目标场景。对于这种SPJA查询，一般来说结果集都是非常小的。&lt;/p&gt;&lt;p&gt;二是我们可以通过对Iceberg和Trino进行增强，支持排序/索引/预计算等OLAP高级特性，使得查询时只扫描SQL逻辑上需要的数据，不需要的数据都Skip掉，同时控制需要扫描的数据量在一定的范围内。&lt;/p&gt;&lt;p&gt;第三，Iceberg的事务支持是的我们可以安全地对数据进行合理的重新组织，这个基础是我们能够通过Magnus服务异步进行数据排序/索引/预计算的基础。&lt;/p&gt;&lt;p&gt;同时我们也并不追求向ClickHouse那样的毫秒级响应的能力，主要是不同于ClickHouse的存算一体架构，Iceberg数据存储在HDFS分布式文件系统上，引入了额外网络和文件系统开销，Iceberg主要是在文件级别进行元数据管理，文件一般在256M左右大小级别，粒度相比ClickHouse更粗。&lt;/p&gt;&lt;p&gt;此外，开放的查询引擎在计算侧相比于其他基于native语言开发的，充分利用向量化能力的OLAP引擎也是有不少差距的。基于可预期的数据扫描量和可控的SPJA计算复杂度，我们可以有一个可预期的查询响应时间，那问题就在于：我们如何基于Trino和Iceberg做到在执行查询时，尽量只访问查询逻辑上需要的数据？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax5zm4b6JJYLhg0l5XuwOVRE2ZEkAu77sBmzuyRgZdOlXN7PaMibvEe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;对于典型的多位分析场景SPJA算子，我们针对每个算子类型进行分析。首先是投影，Iceberg表实际的数据存储类型是ORC列存格式，所以查询中投影的字段下推到TableScan层，ORC Reader只会读取需要的字段而不是所有字段，这是一个已经解决的问题。&lt;/p&gt;&lt;p&gt;对于过滤，我们需要考虑不同的过滤类型，找到合适的解决方案。过滤一般可以分为两种过滤条件，等值和范围过滤，过滤字段本身也可以根据字段基数的不同分为高基数字段和低基数字段。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxRUg6sKMMT8ictf8yjWUSSvtgqxzRADL7tWCiccrlSYqZ7t5gSOEwjNCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在当前Trino和Iceberg的社区版本中，已经有实现了一些针对过滤条件的Data Skipping相关技术。在引擎侧，Trino通过FiterPushDown相关优化器规则会尽可能把过滤条件下推到最底下的TableScan层。&lt;/p&gt;&lt;p&gt;Iceberg首先支持Partition Prunning，分区的文件存储在分区目录中，过滤条件中包含分区时可以skip不相干的分区目录，同时会在表的metadata中记录每个文件所有字段的minmax值信息，在生成InputSplit时，如果某个字段的过滤条件和该字段的minmax值匹配判断是否需要扫描这个文件。&lt;/p&gt;&lt;p&gt;此外，Iceberg还支持用户定义排序字段，比如示例中，age是常用的过滤字段，用户可以定义age为排序字段，Magnus会拉起异步的Spark任务，将该Iceberg表的数据按照用户的定义将数据按照age字段排序。数据排序的好处是重新调整数据的聚集性，让他们按照age字段聚集，比如对于age=16的查询，排序前需要扫描3个文件，排序后只需要扫描1个文件就行了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5611111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxF5Fiahh3RTfywA2lu0th1hXE07WX7p0mzuYkkT0dSQiaXkpdvogfI7ibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面的例子解释了数据的排序分布对于索引和查询性能的影响，我们进一步拓展了Iceberg对于数据排序分布的能力。我们首先将Iceberg表数据的排序分布分为两类：文件间的数据组织和文件内的数据组织，两者相互独立，可以分别单独配置。我们主要扩展的是文件间的数据组织，总共支持了Hash/Range/Zorder和HibertCurve四种数据组织方式。Hash和Range大家都比较熟悉，这里主要简单介绍下Zorder和HibertCurve两种Distribution。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxjT0zFoSlIYcic6ooZThT8SNo6M9EcgSfb4jVKHvibW9nYsicH6fo6aYUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果对于某个Iceberg表，有多个常用的过滤字段，我们使用Order By a，b，c对多个字段进行排序后，数据的聚集性对于a,b,c依次降低，data skipping效果也会依次下降，尤其是a的基数比较高的时候，很可能对只有b或c过滤条件的查询无法skip任何一个文件。&lt;/p&gt;&lt;p&gt;Zorder的做法就是将多个字段值的多维数据依照规则映射成一维数据，我们按照映射成的一维数据排序组织，这个一维数据按照大小顺序连接起来是一个嵌套的Z字型，所以被成为Zorder排序。&lt;/p&gt;&lt;p&gt;Zorder可以保证映射后的一维数据的顺序可以同时保证原始各个维度的聚集性，从而保证对于各个参与Zorder排序的过滤字段，都有比较好的Data Skipping效果。&lt;/p&gt;&lt;p&gt;针对不同数据类型和数据分布，Zorder的实现也是一个比较有挑战的事情，有兴趣的同学可以参考我们之前的一篇文章：https://zhuanlan.zhihu.com/p/354334895。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax0P13mGALouLV8XmWTkHsC9ia6hudZ2dqzf9wHfYkfW8oSxdkicGibsgbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们是在文件间排序阶段支持Zorder，所以实际上我们需要这个嵌套Z字型的数据分布切成很多段，每一段对应的数据存储在一个文件中。&lt;/p&gt;&lt;p&gt;可以看到，Zorder有些连接线的跨度比较大，如果跨度大的连接线连结的两个点的数据被切分到了一个文件的话，这个文件在对应字段上的minmax值的范围就会很大，对应字段过滤条件很可能就没法跳过这个文件，导致data skipping概率降低。希伯特曲线和Zorder类似，好处是它不存在跨度很大的连接线，所以是比Zorder更优的一种多维字段排序方式。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxakX7xt9fdvt0qAT07CJwk0TMSBJibibC52oQxZDBEGRmgbDNn6TmM9Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是我们一个具体的测试场景，用了star schema 1TB的数据集，总共1000个文件，可以看到，按照Zorder排序后，针对三个参与Zorder排序字段的等值过滤，都只需要扫描一百多个文件，可以skip掉80%以上的文件，而希伯特曲线排序后，需要扫描的文件数量有进一步的降低。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxw1rzw12iaE4IkhvFvM3sfM4UdB6icibib2voIolDJc50zRVOKcyFMgGB9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了数据排序分布，我们也在Iceberg支持的索引方面进行了增强，支持了多种索引，以应对不同的过滤条件和字段类型。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxiaPgibCG5WJ8Wzswcibms3OCMrDSxFmCvib91fjCCmRr253TXDM15ialA8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;BitMap索引可以支持范围过滤，并且多个过滤条件的bitmap可以求并，增加skip概率。但是bitmap的主要问题有两个，一个是对于每个基数值都存储一个bitmap代价太大了，二是范围查询时需要读取大量bitmap计算交并差，这大大限制了bitmap索引的应用场景，使用索引可能导致性能的逆优化。我们在这块也有一些探索，感兴趣的话可以参考：https://zhuanlan.zhihu.com/p/433622640。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxicl5x9fqjt6Ps0TUqm9zE0G09NOSOL6uAz506ricrGFhByCcJuFXtsicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;BloomRangeFilter是我们参考公开论文实现的一个类似BloomFilter但是支持Range过滤场景的索引，有False Positive的可能，但是需要的存储空间相比于BitMap这种精确索引大大减少，在我们实际测试中，一般可以达到我们优化后的Bitmap索引的十分之一大小。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxmsWzViaWY9OlbHibA6ia1VPFyiafGkMvrEm7Gtm1da9TG32vv95iciaXr3QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于Iceberg支持了丰富的索引类型 ，以及通过数据排序分布提升数据聚集性，保证索引的效果，那么Trino是怎么使用Iceberg的索引的呢？&lt;/p&gt;&lt;p&gt;可以分成两个阶段，第一个阶段是Coordinator在获取InputSplit时，这个阶段使用存储在Iceberg表metadata文件中的相关索引信息，比如每个文件各字段的minmax值，skip掉的文件不会生成InputSplit。&lt;/p&gt;&lt;p&gt;第二个阶段是在Trino Worker接收到分配的task，处理Input Split中的数据时，首先根据文件读取文件对应的索引文件数据，判读是否可以skip当前文件。&lt;/p&gt;&lt;p&gt;我们生成的索引文件和数据文件是一一对应的，当索引大小 小于某个阈值时保存在表的metadata中，在阶段一时使用，当大于阈值时，保存在独立文件中，阶段二使用。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHax4G0OD9PzaKSZwjLaQ2oq52lVOFTEC6ZKxtbqIJP62OfeO2j7DcJkHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;在有Join的查询中，如何有效地Skip不需要访问的数据是一个很难解决的问题。对于典型的星型模型场景，影响性能的关键是扫描事实表的数据量，但是过滤条件一般是根据维度表中的维度字段过滤，Trino是没办法使用维度字段的过滤条件去skip事实表的文件的。&lt;/p&gt;&lt;p&gt;我们支持了在Iceberg表上定义虚拟的关联列，关联列相当于把维度表的维度字段打宽到事实表上，当然实际上不会真的存储，只是一个逻辑上的定义，然后用户就可以像对待原始的列一样对待关联列，可以基于关联列定义数据排序组织，可以基于关联列定义索引。关联列要求事实表和维度表满足一定的约束关系，也就是事实表和维度表Join后的结果相当于对事实表的打宽，事实表的行数没有增加也没有减少，称为Record-Preserved Join。&lt;/p&gt;&lt;p&gt;一般满足这种条件的是：事实表Left Join维度表，且维度表的Join key满足Unique Key的约束，或者，两表的join key满足PKFK的约束，那么事实表和维度表LEFT JOIN或者Inner Join都可以保证Record-Preserved Join。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxhVPZARNeb3pBrANnrgd7O1dFRIE6OJKMt6YAkicfDYpNQFxOJSAomYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们能够根据关联列定义数据排序组织和索引后，针对维度字段的过滤条件，通过添加一个Trino的优化器Rule，把符合条件的过滤条件就可以从维度表的TableScan中抽取下推到事实表的TableScan中，利用定义在事实表上该字段的索引数据判断是否可以Skip当前的事实表数据文件，从而使得星型模型的Data Skipping效果可以达到和大款表类似的效果，对于我们支持星型模型的业务场景，是一个非常大的提升。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxczpxynfX1OOQvBxPTFdVEYQgNuXtDXTqK41ueakDLMmPwJII7sHPWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过对于数据排序组织，索引和关联列的支持，Trino + Iceberg可以基本上做到文件级的只实际扫描SQL逻辑上需要的数据到引擎中参与计算，但是对于部分包含聚合算子的查询场景，可以SQL逻辑上就需要计算大量的数据，聚合成少量结果集返回给用户，这样的场景主要是需要通过预计算解决性能上的问题，通过预计算的结果直接响应查询，从而避免实际扫描计算大量的数据。&lt;/p&gt;&lt;p&gt;我们当前支持了直接通过Iceberg metadata中的数据直接响应用户表/分区级别的count/min/max聚合查询。对于更通用的预计算方案，还在开发过程中，如何实现高效的文件级别预计算存储和查询，如何利用部分文件预计算结果加速查询，如何解决预计算cube维度爆炸问题等，这是一个非常有意思而且有挑战的方向，我们后面有实际成果的时候到时会和大家在分享在这个方面的工作。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxhCttSv3Ib8J9X3zdfSbntK7p7gYE79mUwC4dbKE81TFZWU4BHQxoIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;B站的湖仓一体平台目前处在快速发展的阶段，这里和大家分享下当前的一些关键指标，我们的Trino集群大概是5376个core，每天有7万的查询量，总接入的数据量目前是2PB，通过数据排序/索引等广泛的应用，平均查询只需要扫描2GB的数据，总体P90的响应时间在2s以内，基本上达到了我们建设秒级响应的湖仓一体平台的目标。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754RoGKPK5zXjNia7jdibiaBdHaxOKnThUQHKJAG3dakXC22rNODfxadnWpWubKB5FZIu2mOg0F3kI0U4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>974bb9abb3495fc9de94d8e8b7e386ad</guid>
<title>Python 3.12 目标：还可以更快！</title>
<link>https://toutiao.io/k/1uwa5jr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照发布计划，Python 3.11.0 将于 2022 年 10 月 24 日发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据测试，3.11 相比于 3.10，将会有 10-60% 的性能提升，这个成果主要归功于“Faster CPython”项目，即“香农计划”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于“香农计划”的详情，可查看 Python 之父的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247491986&amp;amp;idx=1&amp;amp;sn=9a20b39dc04a9abbe0f1e07c6f01036d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;主题分享&lt;/a&gt;，以及他的一则&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247494627&amp;amp;idx=1&amp;amp;sn=f2d1298b5f2f9d6596b542429bafe5a0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;播客访谈&lt;/a&gt;。&lt;span&gt;（点击阅读）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.11 版本为 Python 的提速开了一个激动人心的好头。接下来，3.12 还会有更多动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下文章翻译自“香农计划”的《Python 3.12 Goals》，大家先一睹为快吧！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;作者：Mark Shannon&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;译者：豌豆花下猫@Python猫&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;英文：&lt;/span&gt;&lt;span&gt;https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;本文内容可能会改动，以实际版本为准！&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是 Faster CPython 计划在 3.12 中实现的主要内容的概要。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跟踪优化器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 3.11 提升速度的主要方法是用更快的与上下文相关的操作码（自适应的专门化操作码）替换个别的操作码，下一个大的改进方法是优化多个操作码的运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，现有的许多高级操作码将被替换成低级操作码，例如，用于检查版本号和引用计数的操作码。这些更简单的操作码更容易进行优化，例如，可以删除冗余的引用计数操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些更底层的操作码还能让我们得到一组适合用于生成机器代码的指令（在 CPython 和第三方 JIT 项目中都适用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了做到这点，解释器循环（interpreter loop）将基于声明性的描述而生成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可减少一部分为了保持解释器循环与某些相关函数同步而产生的 bug（mark_stacks、stack_effect 等函数），同时也让我们可以对解释器循环作较大的更改试验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多线程并行&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python 当前每个进程有一个全局解释器锁（GIL），阻碍了多线程的并行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;PEP-684：https://peps.python.org/pep-0684&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PEP-554：https://peps.python.org/pep-0554&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34800550206327374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTM7KUE4ib83KzBicWs214mRbxqibiazhFZhqQiaOVwk5QnrHlvb4PALjhicawYLlp17uqVUItAFJEjJdiayg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;727&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PEP-684 提出了一个方案，即保证所有的全局状态都是线程安全的，并移动到每个子解释器的全局解释器锁中使用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3093622795115332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTM7KUE4ib83KzBicWs214mRbxvoiciakOTzKMk2UJElgjyea7VFIGbPIyXcw7DELYMOB42SFawib8qibQeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;737&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PEP-554 提出了让 Python 创建子解释器的方案（目前只是一个 C API 特性），从而实现真正的多线程并行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Python猫注：PEP-554 早在 2017 年就提出了，目标是落地在 Python 3.8-3.9 版本，然而事与愿违。早在 2019 年的时候，我还翻译了一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484233&amp;amp;idx=1&amp;amp;sn=85a59aaf933c8b048c7f20e532680ae7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Has the Python GIL been slain?&lt;/a&gt;》。屠刀已挥出，让它再飞一会~~&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;更多专门化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分析了哪些字节码将从专门化中获益最多，计划在 3.12 完成其余的高收益的改进。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;https://github.com/faster-cpython/ideas/issues/74&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0577149587750294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTM7KUE4ib83KzBicWs214mRbxXiagSw2JF7Je8YK0UZCMhR01juxdCdrCW1pp32gZlhZ8pcQAEXMgF7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;849&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;较小的对象结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有许多可以减少 Python 对象结构大小的机会。由于它们被频繁使用，这不仅有利于总体的内存使用，还有利于缓存的一致性。我们计划在 3.12 中实现最有希望的一些想法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有一些向后兼容性与性能之间的权衡问题，可能需要提出一个 PEP 来建立共识。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7967391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTM7KUE4ib83KzBicWs214mRbxqTVOuTtjtNtwvH0gF1pWhHmBgtNUVrUDlclQyLwYQwbr6sTPBtBR4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;减少内存管理的开销&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们不仅会减小对象的大小，还会使它们的 layout 更加规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不仅能优化内存的分配及释放，还能在 GC 和重新分配期间加快遍历对象的速度。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API 稳定性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了前述项目外，开发团队还将提升 CPython 代码库的整体质量：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通过减少不同编译阶段的耦合，使编译器更易于维护与测试。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;积极地在 C 语言级别监控和改进 CPython 测试套的代码覆盖率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;改进 Python 性能基准测试套，加入更具代表性的现实世界的负载测试。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协助处理 CPython 问题和 PR，特别是与性能有关的问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;增加用于标准基准测试的机器，增加 macOS 和 Windows 的测试结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;继续跟主要的深度使用 Python 内核的项目合作，帮助它们适配 CPython 解释器的更改。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;注：文中图片为译者所加。&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-w=&quot;22&quot; title=&quot;音符&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Python猫技术交流群开放啦！&lt;/span&gt;&lt;/strong&gt;群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请在公号内回复『&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;』，获取猫哥的微信&lt;span&gt;（谢绝广告党，非诚勿扰！）&lt;/span&gt;~&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;还不过瘾？试试它们&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247493608&amp;amp;idx=1&amp;amp;sn=3fb12dc3051c2f4aeef333e50af4e25a&amp;amp;chksm=fa5ba06dcd2c297b63f88ef7679f247e827e6c86aa328d746a9300d98ddea8fbc156649f704a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;CPython 有 GIL 是因为当年设计的人偷懒吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;CPython 有 GIL 是因为当年设计的人偷懒吗？&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247494627&amp;amp;idx=1&amp;amp;sn=f2d1298b5f2f9d6596b542429bafe5a0&amp;amp;chksm=fa5bac66cd2c257094dc456c8c2021305d4b401a8d9c1fbdbc81a4ced9a347394ac152f7638f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;与 Python 之父聊天：更快的 Python！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;与 Python 之父聊天：更快的 Python！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247491986&amp;amp;idx=1&amp;amp;sn=9a20b39dc04a9abbe0f1e07c6f01036d&amp;amp;chksm=fa5ba617cd2c2f01d08aab2b5d1d0fb0cf1573ac4feec0659631a1a0ec8c2bbfe7cf390ae539&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Python 之父爆料：明年至少令 Python 提速 1 倍！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 之父爆料：明年至少令 Python 提速 1 倍！&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247495333&amp;amp;idx=1&amp;amp;sn=d71dc180e28de66f49c6bbf9936c320d&amp;amp;chksm=fa5ba920cd2c2036904159cae97a61be4cf829bb78a1949720b369354a8ff8ae705caaf0a23b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Python 实现循环的最快方式（for、while 等速度对比）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 实现循环的最快方式（for、while 等速度对比）&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247488715&amp;amp;idx=1&amp;amp;sn=6cf984ef2c3253a33deb271ff4e56db1&amp;amp;chksm=fa58534ecd2fda58d6beebc0704bd758de04e6002e9f2d1448259191dc959e40d676db307e15&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2020年Python文章盘点，我选出了个人TOP10&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2020年Python文章盘点，我选出了个人TOP10&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247497501&amp;amp;idx=1&amp;amp;sn=fac7c909e29afbdd2b2b810e69e657d7&amp;amp;chksm=fa5bb098cd2c398e28f1d6da32fe401e3231a37207bd29178f5dfbcf539f260f67ac4ba4d654&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;专访 Python 之父：人类大脑才是软件开发效率的天花板&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;专访 Python 之父：人类大脑才是软件开发效率的天花板&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你觉得本文有帮助&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;请慷慨&lt;/span&gt;&lt;span&gt;&lt;span&gt;分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;点赞&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，感谢啦&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyOTk2MTcwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTOuJBy76lJMyLHHqm6Bco2meLzhkwEM2WjNcibxnv4flNJMcicuztZkUWWPuzV6bAYZSIFbp74BJPYA/0?wx_fmt=png&quot; data-nickname=&quot;Python猫&quot; data-alias=&quot;python_cat&quot; data-signature=&quot;分享Python进阶、Python哲学、文章翻译、资源工具等内容&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8c335d3f228693400b9fd5313494ee91</guid>
<title>Redis持久化锦囊在手，再也不会担心数据丢失了</title>
<link>https://toutiao.io/k/2lxxw5h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;Redis 的读写都是在内存中进行的，所以它的性能高。&lt;/span&gt;&lt;span&gt;而当我们的服务器断开或者重启的时候，数据就会&lt;/span&gt;&lt;strong&gt;消失&lt;/strong&gt;&lt;span&gt;，那么我们该怎么解决这个问题呢？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;其实 Redis 已经为我们提供了一种持久化的机制，分别是 &lt;code&gt;RDB&lt;/code&gt; 和 &lt;code&gt;AOF&lt;/code&gt; 两种方式，接下来跟着我一起看看这两个锦囊都是怎么保证数据的持久化的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;持久化&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于 Redis 是基于&lt;strong&gt;内存&lt;/strong&gt;的数据库，所以当服务器出现故障的时候，我们的数据就得不到安全保障。&lt;/p&gt;&lt;p&gt;这个时候就需要将内存中的数据存储到&lt;strong&gt;磁盘&lt;/strong&gt;中，当我们服务器重启时，便可以通过磁盘来&lt;strong&gt;恢复数据&lt;/strong&gt;，这个过程就叫做 Redis 持久化。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.31017369727047145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UoVicEnla4ibRGyBMEZ9q6tjM9nsiasEaMfGicDEJhCuN3GaiaezklRS9J7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;Redis持久化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;RDB&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;RDB全称&lt;code&gt;Redis Database Backup file&lt;/code&gt;（Redis数据备份文件），也可以称为&lt;strong&gt;Redis数据快照&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;创建&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;当 Redis 持久化时，程序会将当前内存中的&lt;strong&gt;数据库状态&lt;/strong&gt;保存到磁盘中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;179&quot; data-ratio=&quot;0.39617486338797814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UV5T7Ir89rBaAVSibduyTechd2jdEvyvPZe1rZkrQp7Ubj22ibLTA2ricw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;创建&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;创建 RDB 文件主要有两个 Redis 命令：&lt;code&gt;SAVE&lt;/code&gt; 和 &lt;code&gt;BGSAVE&lt;/code&gt;。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;SAVE&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;同步操作，执行命令时，会&lt;strong&gt;阻塞&lt;/strong&gt; Redis 服务器进程，拒绝客户端发送的命令请求。&lt;/p&gt;&lt;p&gt;&lt;em&gt;代码示例&lt;/em&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;SAVE&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 创建 RDB 文件&lt;/span&gt;&lt;br/&gt;    rdbSave()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图示&lt;/em&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;206&quot; data-ratio=&quot;0.5142378559463987&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UGHhQCzQicOMrqpZfmqIFhLZ9wCffA0WXhNRe1aOD3h9UKw15iaic1y17A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;Save命令&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;BGSAVE&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;异步操作，执行命令时，子进程执行保存工作，服务器还可以继续让主线程&lt;strong&gt;处理&lt;/strong&gt;客户端发送的命令请求。&lt;/p&gt;&lt;p&gt;&lt;em&gt;代码示例&lt;/em&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;BGSAVE&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 创建子进程&lt;/span&gt;&lt;br/&gt;    pid = fork()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; pid == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;# 子进程负责创建 RDB 文件&lt;/span&gt;&lt;br/&gt;        rdbSave()&lt;br/&gt;        &lt;span&gt;# 完成之后向父进程发送信号&lt;/span&gt;&lt;br/&gt;        signal_parent()&lt;br/&gt;    &lt;span&gt;elif&lt;/span&gt; pid &amp;gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;# 父进程继续处理命令请求，并通过轮训等待子进程的信号&lt;/span&gt;&lt;br/&gt;        handle_request_and_wait_signal()&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;        handle_fork_error()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;图示&lt;/em&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;297&quot; data-ratio=&quot;0.6345177664974619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UaRLqrCIgFaBU4iaR8rUPQYST5bv4j5X8pWInrJjtCkia3NDia4ladFZ0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;bgSave命令&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;载入&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;载入工作在服务器启动时&lt;strong&gt;自动&lt;/strong&gt;执行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;229&quot; data-ratio=&quot;0.356353591160221&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UwuulxFYXfKCHKwxdrpbFI0hZqZd342OtDxgMrZGJibKzCDZpkkjOo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;724&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;载入&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;服务器在载入 RDB 文件期间，会一直处于&lt;strong&gt;阻塞&lt;/strong&gt;状态，直到载入工作完成为止。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;主要设置&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Redis 允许用户通过设置服务器配置的 save 选项，让服务器每隔一段时间&lt;strong&gt;自动执行&lt;/strong&gt;一次 BGSAVE 命令。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;设置保存条件&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;提供配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;save&lt;/span&gt; &lt;span&gt;900&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;save &lt;span&gt;300&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这种情况下，只要满足以下条件中的&lt;strong&gt;一个&lt;/strong&gt;，BGSAVE 命令就会被执行：&lt;/p&gt;&lt;h5&gt;&lt;span&gt;saveparams&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;服务器程序会根据 save 选项所设置的&lt;strong&gt;保存条件&lt;/strong&gt;，设置服务器状态 redisServer 结构的 &lt;code&gt;saveparams&lt;/code&gt; 属性。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;saveparam&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 秒数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;time_t&lt;/span&gt; seconds;&lt;br/&gt;    &lt;span&gt;// 修改数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; changes;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;dirty&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;dirty&lt;/code&gt; 计数器记录距离上一次成功执行 SAVE 命令或 BGSAVE 命令之后，服务器对数据库状态进行了&lt;strong&gt;多少次&lt;/strong&gt;修改（包括写入、删除、更新等操作）。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;lastsave&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;是一个 &lt;code&gt;UNINX&lt;/code&gt; 时间戳，记录了服务器上一次成功执行 SAVE 命令或者 BGSAVE 命令的时间。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;检查保存条件是否满足&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;服务器周期性操作函数 &lt;code&gt;serverCron&lt;/code&gt; （该函数对正在运行的服务器进行维护）默认每隔 100 毫秒就会执行一次，其中一项工作就是检查 save 选项所设置的保存条件是否已经&lt;strong&gt;满足&lt;/strong&gt;，满足的话就执行 BGSAVE 命令。&lt;/p&gt;&lt;p&gt;&lt;em&gt;代码示例&lt;/em&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;serverCron&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# ....&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 遍历所有保存条件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; saveparam &lt;span&gt;in&lt;/span&gt; server.saveparams:&lt;br/&gt;        &lt;span&gt;# 计算距离上次执行保存操作有多少秒&lt;/span&gt;&lt;br/&gt;        save_interval = unixtime_now() - server.lastsave&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 如果数据库状态的修改次数超过条件所设置的次数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 如果距离上次保存的时间超过条件所设置的时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; server.dirty &amp;gt;= saveparam.changes &lt;span&gt;and&lt;/span&gt; save_interval &amp;gt; saveparam.seconds:&lt;br/&gt;            BGSAVE()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;默认配置&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;RDB 文件默认的配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;## SNAPSHOTTING  ################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Save the DB on disk:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#在给定的秒数和给定的对数据库的写操作数下，自动持久化操作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#   save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# &lt;/span&gt;&lt;br/&gt;save &lt;span&gt;900&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;save &lt;span&gt;300&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;br/&gt;save &lt;span&gt;60&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#bgsave发生错误时是否停止写入，一般为yes&lt;/span&gt;&lt;br/&gt;stop-writes-&lt;span&gt;on&lt;/span&gt;-bgsave-error &lt;span&gt;yes&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#持久化时是否使用LZF压缩字符串对象?&lt;/span&gt;&lt;br/&gt;rdbcompression &lt;span&gt;yes&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#是否对rdb文件进行校验和检验，通常为yes&lt;/span&gt;&lt;br/&gt;rdbchecksum &lt;span&gt;yes&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# RDB持久化文件名&lt;/span&gt;&lt;br/&gt;dbfilename dump.rdb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#持久化文件存储目录&lt;/span&gt;&lt;br/&gt;dir ./&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;AOF&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;AOF全称为 &lt;code&gt;Append Only File&lt;/code&gt;（追加日志文件）。日志是&lt;strong&gt;写后日志&lt;/strong&gt;，Redis 是先执行命令，把数据写入内存，然后才记录日志。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;161&quot; data-ratio=&quot;0.49581589958158995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UdicsdR2xItEG5hnIMeNnYkCQ3QbgeSyjcByZKLWdRibSXvlBYWUxPF4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;写后日志&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;实现&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;AOF 持久化流程实现主要是通过以下流程来实现的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;367&quot; data-ratio=&quot;0.6223021582733813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UDg7t3DmsjyQgd6mic8r6Jhzs1MRFfUz9RgkdKpxRGrM4b8GrgmGpY0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;AOF流程&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;命令追加&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;若 AOF 持久化功能处于打开状态，服务器在执行完一个命令后，会以协议格式将被执行的写命令&lt;strong&gt;追加&lt;/strong&gt;到服务器状态的 &lt;code&gt;aof_buf&lt;/code&gt; 缓冲区的末尾。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;文件同步&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;服务器每次结束一个事件循环之前，都会调用 &lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 函数，这个函数会考虑是否需要将 &lt;code&gt;aof_buf&lt;/code&gt; 缓冲区中的内容&lt;strong&gt;写入和保存&lt;/strong&gt;到 AOF 文件里。&lt;/p&gt;&lt;p&gt;&lt;code&gt;flushAppendOnlyFile&lt;/code&gt; 函数执行以下流程：&lt;/p&gt;&lt;p&gt;这个函数是由服务器配置的 &lt;code&gt;appendfsync&lt;/code&gt; 的三个值：&lt;code&gt;always、everysec、no&lt;/code&gt; 来影响的，也被称为三种策略。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;Always&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;每条&lt;strong&gt;命令&lt;/strong&gt;都会 fsync 到硬盘中，这样 redis 的写入数据就不会丢失。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;360&quot; data-ratio=&quot;0.32129277566539927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UianQpiaMr8KKCz28DbXibhImU1fJQVI96MNXmiamiaoCib7DhjkibXibU45YNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;Always&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;everysec&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;strong&gt;每秒&lt;/strong&gt;都会刷新缓冲区到硬盘中(默认值)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;186&quot; data-ratio=&quot;0.32386363636363635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9U0QeKCic5ygufhWrJYycqHVu6Vu5G9yWPAFdgGIqXZrwpSnveDk6ibh3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;everysec&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;no&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;根据当前&lt;strong&gt;操作系统&lt;/strong&gt;的规则决定什么时候刷新到硬盘中，不需要我们来考虑。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-ratio=&quot;0.27798507462686567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UWDLRoiaqMSbKAQibVAszxk0NX3rAhbDiaZDkTnuiaqs1C0jgUozKiaiabYzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;no&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;数据加载&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建一个不带网络连接的伪客户端；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从 AOF 文件中分析并读取出一条写命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用伪客户端执行被读出的写命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一直执行步骤 2 和 3，直到 AOF 文件中的所有写命令都被&lt;strong&gt;处理完毕&lt;/strong&gt;为止。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;文件重写&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;为何需要文件重写：&lt;/p&gt;&lt;h5&gt;&lt;span&gt;实现&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;文件重写的实现原理：&lt;/p&gt;&lt;h5&gt;&lt;span&gt;后台重写&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;为不阻塞父进程，Redis 将 AOF 重写程序放到&lt;strong&gt;子进程&lt;/strong&gt;里执行。&lt;/p&gt;&lt;p&gt;在子进程执行 AOF 重写期间，服务器进程需要执行三个流程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行客户端发来的命令；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将执行后的写命令追加到 AOF 缓冲区；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将执行后的写命令追加到 AOF 重写缓冲区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;287&quot; data-ratio=&quot;0.5008291873963516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Q5xqCucsiaSATzF31lGGXUkeaAAmT4G9UXOtkNE32xltMWdOs04aBHKShibPWcUMr1jSvjX2Nk3RUqnroRgZicdkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;服务器流程&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;默认配置&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;AOF 文件默认的配置如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt; APPEND ONLY MODE &lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;######&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#开启AOF持久化方式&lt;/span&gt;&lt;br/&gt;appendonly &lt;span&gt;no&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#AOF持久化文件名&lt;/span&gt;&lt;br/&gt;appendfilename &lt;span&gt;&quot;appendonly.aof&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#每秒把缓冲区的数据fsync到磁盘&lt;/span&gt;&lt;br/&gt;appendfsync everysec&lt;br/&gt;&lt;span&gt;# appendfsync no&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#是否在执行重写时不同步数据到AOF文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;no&lt;/span&gt;-appendfsync-&lt;span&gt;on&lt;/span&gt;-rewrite &lt;span&gt;no&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 触发AOF文件执行重写的增长率&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-percentage &lt;span&gt;100&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#触发AOF文件执行重写的最小size&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-min-size &lt;span&gt;64&lt;/span&gt;mb&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#redis在恢复时，会忽略最后一条可能存在问题的指令&lt;/span&gt;&lt;br/&gt;aof-load-truncated &lt;span&gt;yes&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#是否打开混合开关&lt;/span&gt;&lt;br/&gt;aof-use-rdb-preamble &lt;span&gt;yes&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;通过以上的简介，想必大家都对 Redis 持久化有了大致的了解，那么这两种方式，我们该如何选择呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;对于大中型的应用，我们既想保证数据完整性又想保证高效率，就应该&lt;strong&gt;结合&lt;/strong&gt;使用 RDB 和 AOF 两种方式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果只是需要保证数据的&lt;strong&gt;完整性&lt;/strong&gt;，保护数据不会丢失，那么优先使用 AOF 方式；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果是处理&lt;strong&gt;大规模&lt;/strong&gt;的数据恢复，追求更高更快的效率的话，优先使用 RDB 方式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;也可以参照下图进行选择：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>