<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9a9b3cb7a7dfb532a3fec121cf6e6bd7</guid>
<title>一文搞懂前端兼容问题</title>
<link>https://toutiao.io/k/plsx3t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5274151436031331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mzricSSj51xbyHo5ULFolCf03nylYpkxc0TD1kzDgkkrn0ZTm8mNtgWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1915&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📌&lt;/span&gt;&lt;p&gt;如果你喜欢我写的文章，可以把我的公众号设为&lt;strong&gt;星标 🌟&lt;/strong&gt;，这样每次有更新就可以及时推送给你啦&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分开发者来说，版本兼容是一件存在感很低的事情，因为它在绝大部分情况下都是一行配置，在一些前端工具链（例如 Babel、CoreJS，Autoprefixer 等工具）的帮助下适配到目标浏览器，只会在一些大的 break change 事件（例如 Vue3 必须在支持 Proxy 的现代浏览器下才能运行）下才会关注这件不起眼的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当你稍微研究一下的时候，才会发现这块儿内容知识非常杂，因为版本兼容的相关知识没有那么多内在逻辑性，很多细碎的知识点散落在在各个商业公司的博弈和版本变更中。前段时间因工作需要对部分语言/浏览器特性重点关注了一下，以此文做一下记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要记录了移动端的版本适配问题，未对桌面端做更多的研究，后面有可能补充相关内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.iOS &amp;amp; Safari&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iOS 和 Android 虽然都是一年更新一个大版本，但受益于生态的封闭性，iOS 的更新率&lt;strong&gt;极高&lt;/strong&gt;，基本上最近的两个版本就能覆盖 95% 以上的人群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 &lt;span&gt;Apple 官方统计&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，截止到 2022-05-31，Apple 四年内推出的新机型中，&lt;code&gt;iOS 15&lt;/code&gt; 已经有 89% 的装机率，&lt;code&gt;iOS 14&lt;/code&gt; 也有 10% 的装机率；而在所有历史机型里，&lt;code&gt;iOS 15&lt;/code&gt; 和 &lt;code&gt;iOS 14&lt;/code&gt; 加起来也有 96% 的装机率，隔壁 Android 都羡慕哭了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.419871794871795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mCLUsFIvu4XFeYszICdCVruZwCK36aI69Za3uhJPC6BG3OONS6ITf2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么如此关注 iOS 的版本号？&lt;strong&gt;因为 iOS 版本基本上和 Safari 版本一一对应的&lt;/strong&gt;，例如 &lt;code&gt;iOS 15.6&lt;/code&gt; 上安装着 &lt;code&gt;Safari 15.6&lt;/code&gt;，&lt;code&gt;iOS 14.5&lt;/code&gt; 上安装着 &lt;code&gt;Safari 14.1&lt;/code&gt;，具体的映射关系可见 &lt;span&gt;MDN 的映射表&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，或者可以看 &lt;span&gt;core-js: SafariToIOS&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，所以我们基本上只要比对 iOS 版本号即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个问题是，有一定 C 端开发经验的开发者可能还会关注 iOS 上运行的是 UIWebView 还是 WKWebView，在 2022 年这个时间点其实已经不需要关注了，因为 Apple Store 已经发过&lt;span&gt;公告&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，2020 12 月之后已经禁止含 UIWebView 的 APP 上架了，所以 iOS 平台只有 WKWebView 这一个 WebView 了，而且它&lt;span&gt;兼容性也不错&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，最低支持到 &lt;code&gt;iOS 8&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Android &amp;amp; Chrome&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完 iOS 我们再谈谈 Android。因为两个操作系统的发展策略不同，再加上国内各大厂商的魔改，Android 从一开始就深陷碎片化的深渊，有 Android 开发经历的同学一定都深有感触。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Android 系统本身碎片化，Android 系统自带的浏览器&lt;strong&gt;更碎片化&lt;/strong&gt;。在 Android 早期，Android 版本和 Chrome 浏览器版本是有绑定关系的，那这个早期是有多早？那就是 &lt;code&gt;Android 4&lt;/code&gt;，2014 年发布，绑定了 Chrome 早期几个版本，因为数据不多，我这里就直接列出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/mapping.mjs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ChromeToAndroid&lt;/span&gt;: [&lt;br/&gt;  [&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;&#x27;3.0&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&#x27;4.0&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;&#x27;4.4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;33&lt;/span&gt;, &lt;span&gt;&#x27;4.4.3&#x27;&lt;/span&gt;],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情的转机出现在 &lt;code&gt;Android 5&lt;/code&gt;，&lt;span&gt;这个版本&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;里 WebView 被移植为一个独立的 APK，可以独立更新，不再和 Android 系统深度绑定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 的想法初衷是好的，借助于 Google 商店，解耦更利于浏览器的版本迭代。但是在国内多厂商魔改和一些网络问题上，极有可能发生这样的事情：对于一台 &lt;code&gt;Android 5&lt;/code&gt; 手机，理论上用户可以安装 &lt;code&gt;Chrome 36&lt;/code&gt; - &lt;code&gt;Chrome 95&lt;/code&gt; &lt;strong&gt;任意一个版本&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以和 iOS 对比起来，Android 因为他的开放性带来严重的碎片化问题：Android 版本多样，Chrome 版本多样，还有各种魔改内核，对于开发者来说适配起来真的苦不堪言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Web Browser&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完操作系统的版本历史，我们再看看浏览器上最关键的 JavaScript 语法兼容度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近十年内，JS 这门语言的的最大变革就是 ES6（ES2015）的发布了，带来了非常多的新特性。下面我搞了一个表格，列出几个大家常用的 JS 语法是从哪个版本开始支持的：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语法/API&lt;/th&gt;&lt;th&gt;iOS&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;const&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;let&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;generators&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;39&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;33&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;async await&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;55&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;import&lt;/code&gt; &lt;code&gt;export&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10.3&lt;/td&gt;&lt;td&gt;61&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，这些语法的最低支持版本集中在 &lt;code&gt;iOS 10&lt;/code&gt;、&lt;code&gt;iOS 11&lt;/code&gt;，&lt;code&gt;Chrome 49&lt;/code&gt;，&lt;code&gt;Chrome 61&lt;/code&gt; 这几个版本上，我们把它们的版本发布时间列出来：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;事件&lt;/th&gt;&lt;th&gt;发布时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ES5&lt;/code&gt; 标准发布时间&lt;/td&gt;&lt;td&gt;2009.12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ES6&lt;/code&gt; 标准发布时间&lt;/td&gt;&lt;td&gt;2015.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;iOS 10&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2016.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;iOS 11&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2017.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Chrome 49&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2016.03&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Chrome 61&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2017.09&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间列出来后结论基本上是呼之欲出了：&lt;strong&gt;ES6 标准发布后的未来一年时间内，各大浏览器语法就支持的差不多了，两年后基本上就全部支持了&lt;/strong&gt;，&lt;strong&gt;这个时间点就是 2017 年，对应着&lt;/strong&gt; &lt;code&gt;iOS 11&lt;/code&gt; &lt;strong&gt;和&lt;/strong&gt; &lt;code&gt;Chrome 61&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;legacy vs modern&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完 ES6 的支持情况，我们再来了解两个概念，「经典浏览器」和「现代浏览器」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个词在英文里对应着「legacy browser」和「modern browser」。如果大家比较关注一些相对前沿的前端项目，比如说 Vue3，Solidjs，Vite，它们的官网里其实经常提到这两个词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，既然有两个称呼，那在工程里必然存在一个分界线去区分 legacy 和 modern，&lt;strong&gt;这个分界线就是 &lt;code&gt;iOS10.3&lt;/code&gt; 和 &lt;code&gt;Chrome 61&lt;/code&gt;，既浏览器支持 ES Modules 的版本&lt;/strong&gt;（支持 &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; &amp;amp; &lt;code&gt;import&lt;/code&gt; &amp;amp; &lt;code&gt;export&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一看是不是就和上面的内容对上了？Babel 官网也做了相关的&lt;span&gt;解释&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;，core-js 也专门做了&lt;span&gt;区分&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;，更详细的介绍可以看 MDN 的文章：&lt;span&gt;JavaScript modules&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，我就不做多余介绍了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;modern feature&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的探索，我们再回过来看看一些比较 modern 的 browser feature 的支持程度：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;browser fature&lt;/th&gt;&lt;th&gt;iOS&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Web Worker&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SubtleCrypto&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;37&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Service Worker&lt;/td&gt;&lt;td&gt;11.3&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WebAssembly&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;57&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CSS Grid Layout&lt;/td&gt;&lt;td&gt;10.3&lt;/td&gt;&lt;td&gt;58&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WebGPU&lt;/td&gt;&lt;td&gt;not support&lt;/td&gt;&lt;td&gt;not support&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看各个 API 的兼容度，再结合上文的内容，就可以发现很多「兼容性不好」人云亦云的说法不攻自破，&lt;strong&gt;其实大部分情况下不是兼容度不好从而不用，是项目还没有复杂到那个程度需要用这些高级功能&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Open Source Project&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中肯定不能写一行代码查一下兼容度，这些都是由社区工具做抹平的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兼容度数据源头可以追述到 MDN 的 &lt;span&gt;browser-compat-data&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，记录了各种 API 的兼容，MDN 网站的兼容度直接是从这个 repo 里读的。我们常用的 &lt;span&gt;caniuse&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 网站，一部分数据也是依赖于它的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是工程上依赖最多的 &lt;span&gt;browserslist&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;，babel、eslint、autoprefixer、postcss，webpack 等构建工具都依赖于它，browserslist 的数据又依赖于 &lt;span&gt;caniuse-lite&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;，其实也是依赖于 &lt;span&gt;caniuse&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;，lite 只保留了核心数据，对一些说明文案做了裁剪处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合以上分析，我们可以看出，在项目工程里依赖的 browserslist，数据准确性还是可以得到保证的，所以兼容性还是无需担心的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.Adaptation Suggestions&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，那么有什么配置建议呢？我个人认为主要有 3 点建议提供参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一个是参考国民级 APP 的最低支持度配置&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在国内，在日活上能称为国民级 APP 的就是微信抖音了，这两个 APP 因为日活巨大，基本上已经覆盖到全部中国人，所以他们的配置一定有所考量，可以反应出国内的整体手机版本水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 App Store/Android 应用商店/浏览器 UA 上看，我们可以得处以下结论（截止到 2022-8-8）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;微信&lt;/strong&gt;：最低支持到 &lt;code&gt;iOS 12&lt;/code&gt;、&lt;code&gt;Android 5&lt;/code&gt;、内置浏览器版本为 &lt;code&gt;Chrome 86&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;抖音&lt;/strong&gt;：最低支持到 &lt;code&gt;iOS 10&lt;/code&gt;、&lt;code&gt;Android 5&lt;/code&gt;、内置浏览器版本为 &lt;code&gt;Chrome 75&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你也可以参考其他 APP，由于精力有限我就不做过多展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据项目的迭代速度来看，iOS 基本上可以做到一年一升级，比如说今年 &lt;code&gt;iOS 16&lt;/code&gt; 出来后，明年最低适配版本基本上可以升到 &lt;code&gt;iOS 11&lt;/code&gt; 了，Android 因为长尾效应和版本不绑定的问题，应该还会支持到 &lt;code&gt;Android 5&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二个建议是直接看当前业务的版本数据&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的公司不同的项目都有不同的用户场景，比如说面向三四线 C 端用户的场景，一般低端机就会多一些；面向门店的场景，说不定还得适配 IE 浏览器；面向企业内的开发者项目，直接适配到最新几个浏览器即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景如此之多就要依赖于用户版本数据统计了。一般中大厂都有比较完善的数据监控中台，直接拉一份数据就能获取大致情况，基建不完善的小公司也可以单独开个接口记录数据，收集一个月做个去重统计也能得到相关数据。拿到数据后再结合业务场景做些&lt;strong&gt;取舍&lt;/strong&gt;，基本上就可以拿到最低适配了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三个建议结合前端框架和 Chrome 版本做兼容。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合前端框架其实很好理解，比如说你用了 Vue3，底层依赖于 Proxy，那么最低依赖已经锁死到 &lt;code&gt;iOS 10&lt;/code&gt; 和 &lt;code&gt;Chrome 49&lt;/code&gt; 了，那你的最低配置只能比以上版本高，假如你无脑设置为 &lt;code&gt;iOS 9&lt;/code&gt; 或 &lt;code&gt;Android 4&lt;/code&gt;，除了在最低版本上跑不起来，还要平白无故的多了许多语法转换和 polyfill，在 &lt;strong&gt;构建速度/运行时性能/产物体积&lt;/strong&gt; 上都会产生不必要的劣化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合 Chrome 版本做兼容其实就是本文第二大节的内容。因为 &lt;code&gt;Android 5&lt;/code&gt; 之后不再和 Chrome 做深度绑定，版本兼容设置 Android 版本其实是无意义的行为，应该根据统计结果直接设置 Chrome 版本，做更细粒度的配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Refs: Version History&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的版本历史和发布时间主要参考官方更新日志/文档 和 维基百科，相关链接如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;iOS 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/IOS_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/Android_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Chrome 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/Google_Chrome_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WKWebView API 兼容度：&lt;span&gt;https://developer.apple.com/documentation/webkit/wkwebview&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android Verison 和 APILevel 的对应关系：&lt;span&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📌&lt;/span&gt;&lt;p&gt;如果你喜欢我的文章，希望点赞👍 收藏 📁 在看 🌟 三连支持一下，谢谢你，这对我真的很重要！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎大家关注我的微信公众号：&lt;strong&gt;卤蛋实验室&lt;/strong&gt;，目前专注前端技术，对图形学也有一些微小研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以加我的微信 &lt;strong&gt;egg_labs&lt;/strong&gt;，欢迎大家来撩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9874476987447699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mINJEvt1UEUBBaR1hftktLbw5Wwzu3h0GMACiaNxcY9TWWUEkiaEcSfJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mKytNksWwTjQvricVbXuhKSt2Bwt0uBaJSTE4MgZjyQqncmzIzZbthfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Apple 官方统计: &lt;em&gt;https://developer.apple.com/support/app-store/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MDN 的映射表: &lt;em&gt;https://github.com/mdn/browser-compat-data/blob/main/browsers/safari_ios.json&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;core-js: SafariToIOS: &lt;em&gt;https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/mapping.mjs&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;公告: &lt;em&gt;https://developer.apple.com/cn/news/?id=edwud51q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;兼容性也不错: &lt;em&gt;https://developer.apple.com/documentation/webkit/wkwebview&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;这个版本: &lt;em&gt;https://developer.chrome.com/docs/multidevice/webview/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;解释: &lt;em&gt;https://babeljs.io/docs/en/options#targetsesmodules&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;区分: &lt;em&gt;https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/external.mjs&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;JavaScript modules: &lt;em&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;browser-compat-data: &lt;em&gt;https://github.com/mdn/browser-compat-data&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;caniuse: &lt;em&gt;https://caniuse.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;browserslist: &lt;em&gt;https://github.com/browserslist/browserslist&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;caniuse-lite: &lt;em&gt;https://github.com/browserslist/caniuse-lite&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;caniuse: &lt;em&gt;https://github.com/Fyrd/caniuse&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68ed88cd728129197dbdd3a42651ea12</guid>
<title>[新文导读] 深度解密钉钉即时消息服务DTIM的技术设计</title>
<link>https://toutiao.io/k/6ztt44k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;本文引用自InfoQ社区“5亿用户如何高效沟通？钉钉首次对外揭秘即时消息服务DTIM”一文，作者陈万红等、策划褚杏娟，即时通讯网有修订和改动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;一、引言&lt;/h2&gt;&lt;h1&gt;&lt;strong&gt;本文是国内企业IM的事实王者钉钉首次对外深度解密其即时消息服务（&lt;span&gt;即DingTalk IM，简称DTIM&lt;/span&gt;）的技术设计实践。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;本篇文章内容将从模型设计原理到具体的技术架构、最底层的存储模型到跨地域的单元化等，全方位展现了 DTIM 在实际生产应用中所遇到的各种技术挑战及相应的解决方案，希望借本文内容的分享能为国内企业级IM的开发带来思考和启发。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28134556574923547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLyNtiaBdfAUTDHq64ItbxThe103LyTAUYnpyb1BYrUAoJ82JBp6o38vQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;654&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_cover-opti.jpg&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;ignore_js_op&gt;&lt;br/&gt;&lt;/ignore_js_op&gt;&lt;/p&gt;&lt;h2&gt;二、技术看点&lt;/h2&gt;&lt;h1&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;/em&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;em&gt;三、&lt;/em&gt;钉钉的技术挑战&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;模型设计&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1、DTIM系统架构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2、消息收发链路&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3、存储模型设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.4、同步模型设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;五、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;消息存储设计&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;六、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;多端同步机制设计&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.1、概述&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.2、全量消息存储逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.3、消息多端同步逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.4、大量需同步离线消息的优化逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;七、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;高可用设计&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;八、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;本文小结&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;九、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;相关文章&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;三、钉钉的技术挑战&lt;/h2&gt;&lt;h1&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLOPeKY6WUr6NxZ3oSmBicn73DcxPDloTKG8OGWbRtMicWGVOxP1FsunPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_0.jpg&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;钉钉已经有 2100 万 + 组织、5 亿 + 注册用户在使用。DTIM 为钉钉用户提供即时消息服务，用于组织内外的沟通，这些组织包括公司、政府、学校等，规模从几人到百万人不等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;DTIM 有着丰富的功能，单聊、各种类型的群聊、消息已读、文字表情、多端同步、动态卡片、专属安全和存储等等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;同时：&lt;/strong&gt;&lt;span&gt;钉钉内部很多业务模块，比如文档、钉闪会、Teambition、音视频、考勤、审批等，每个业务都在使用 DTIM，用于实现业务流程通知、运营消息推送、业务信令下发等。每个业务模块对于 DTIM 调用的流量峰值模型各有差别，对可用性要求也不尽相同。&lt;/span&gt;&lt;strong&gt;DTIM 需要能够面对这些复杂的场景，保持良好的可用性和体验，同时兼顾性能与成本&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;通用的即时消息系统对消息发送的成功率、时延、到达率有很高的要求，企业 IM 由于 ToB 的特性，在数据安全可靠、系统可用性、多终端体验、开放定制等多个方面有着极致的要求。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;构建稳定高效的企业 IM 服务，DTIM 主要面临的挑战是：&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;企业 IM 极致的体验要求对于系统架构设计的挑战&lt;/span&gt;：比如数据长期保存可漫游、多端数据同步、动态消息等带来的数据存储效率和成本压力，多端数据同步带来的一致性问题等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;极限场景冲击、依赖系统错误带来的可用性问题&lt;/span&gt;：比如超大群消息，突发疫情带来的线上办公和线上教学高并发流量，系统需要能够应对流量的冲击，保障高可用；同时在中间件普遍可用性不到 99.99% 的时候，DTIM 服务需要保障核心功能的 99.995% 的可用性；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;不断扩大的业务规模，对于系统部署架构的挑战&lt;/span&gt;：比如持续增长的用户规模，突发事件如席卷全球的疫情，单地域架构已经无法满足业务发展的要求。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;DTIM 在系统设计上：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;为了实现消息收发体验、性能和成本的平衡，设计了高效的读写扩散模型和同步服务，以及定制化的 NoSQL 存储；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;通过对 DTIM 服务流量的分析，对于大群消息、单账号大量的消息热点以及消息更新热点的场景进行了合并、削峰填谷等处理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;核心链路的应用中间件的依赖做容灾处理，实现了单一中间件失败不影响核心消息收发，保障基础的用户体验。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;在消息存储过程中，一旦出现存储系统写入异常，系统会回旋缓冲重做，并且在服务恢复时，数据能主动向端上同步。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;随着用户数不断增长，单一地域已无法承载 DTIM 的容量和容灾需求，&lt;/span&gt;&lt;strong&gt;DTIM 实现了异地多单元的云原生的弹性架构&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;在分层上遵从的原则为重云轻端：&lt;/strong&gt;&lt;span&gt;业务数据计算、存储、同步等复杂操作尽量后移到云端处理，客户端只做终态数据的接收、展示，通过降低客户端业务实现的复杂度，最大化地提升客户端迭代速度，让端上开发可以专注于提升用户的交互体验，所有的功能需求和系统架构都围绕着该原则做设计和扩展。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;以下章节我们将对 DTIM 做更加详细的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;四、模型设计&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.1、DTIM系统架构&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;低延迟、高触达、高可用一直是 DTIM 设计的第一原则，依据这个原则在架构上 DTIM 将系统拆分为三个服务做能力的承载。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;三个服务分别是：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;消息服务&lt;/span&gt;：负责 IM 核心消息模型和开放 API，IM 基础能力包括消息发送、单聊关系维护、群组元信息管理、历史消息拉取、已读状态通知、IM 数据存储以及跨地域的流量转发；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;同步服务&lt;/span&gt;：负责用户消息数据以及状态数据的端到端同步，通过客户端到服务端长连接通道做实时的数据交互，当钉钉各类设备在线时 IM 及上游各业务通过同步服务做多端的数据同步，保障各端数据和体验一致；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;通知服务&lt;/span&gt;：负责用户第三方通道维护以及通知功能，当钉钉的自建通道无法将数据同步到端上时，通过三方提供的通知和透传能力做消息推送，保障钉钉消息的及时性和有效性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;同步服务和通知服务除了服务于消息服务，也面向其他钉钉业务比如音视频、直播、Ding、文档等多端 (&lt;/span&gt;&lt;span&gt;多设备&lt;/span&gt;&lt;span&gt;) 数据同步。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图1：&lt;/strong&gt;&lt;span&gt;DTIM架构图 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9615384615384616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicL2QruwvFSMJ5Je2q4KL7eslkhFg2ic8y8haAa01TkypgBEok6gsPLyoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_1.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;上图展示了 DTIM 系统架构，接下来详细介绍消息收发链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.2、消息收发链路&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;图2：&lt;/strong&gt;&lt;span&gt;DTIM消息处理架构 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7259978425026968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLgRvjAT2bibic15victO7g45fAj0JJ4q41KtgZolGg2nu18bbOzFqmBGWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_2.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;消息发送：&lt;/strong&gt;&lt;span&gt;消息发送接口由 Receiver 提供，钉钉统一接入层将用户从客户端发送的消息请求转发到 Receiver 模块，Receiver 校验消息的合法性（&lt;/span&gt;&lt;span&gt;文字图片等安全审核、群禁言功能是否开启或者是否触发会话消息限流规则等&lt;/span&gt;&lt;span&gt;）以及成员关系的有效性（&lt;/span&gt;&lt;span&gt;单聊校验二者聊天、群聊校验发送者在群聊成员列表中&lt;/span&gt;&lt;span&gt;），校验通过后为该消息生成一个全局唯一的 MessageId 随消息体以及接收者列表打包成消息数据包投递给异步队列，由下游 Processor 处理。消息投递成功之后，Receiver 返回消息发送成功的回执给客户端。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;消息处理 ：&lt;/strong&gt;&lt;span&gt;Processor 消费到 IM 发送事件首先做按接收者的地域分布（&lt;/span&gt;&lt;span&gt;DTIM 支持跨域部署， Geography，Geo&lt;/span&gt;&lt;span&gt;）做消息事件分流，将本域用户的消息做本地存储入库（&lt;/span&gt;&lt;span&gt;消息体、接收者维度、已读状态、个人会话列表红点更新&lt;/span&gt;&lt;span&gt;），最后将消息体以及本域接收者列表打包为 IM 同步事件通过异步队列转发给同步服务。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;消息接收 ：&lt;/strong&gt;&lt;span&gt;同步服务按接收者维度写入各自的同步队列，同时查取当前用户设备在线状态，当用户在线时捞取队列中未同步的消息，通过接入层长连接推送到各端。当用户离线时，打包消息数据以及离线用户状态列表为 IM 通知事件，转发给通知服务的 PNS 模块，PNS 查询离线设备做三方厂商通道推送，至此一条消息的推送流程结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.3、存储模型设计&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;了解 IM 服务最快的途径就是掌握它的存储模型。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;业界主流 IM 服务对于消息、会话、会话与消息的组织关系虽然不尽相同，但是归纳起来主要是两种形式：写扩散读聚合、读扩散写聚合。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;所谓读写扩散其实是定义消息在群组会话中的存储形式。如下图所示。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图3：&lt;/strong&gt;&lt;span&gt;读模式和写模式 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39438085327783556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLo1bib1OM58x3u4WsEPWOMKFQYjcDlLWbHzAjH1qQLDfRNpB7TffPCFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;961&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_3.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;如上图所示：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;读扩散的场景&lt;/span&gt;：消息归属于会话，对应到存储中相当于有张 conversation_message 的表存储着该会话产生的所有消息 (cid-&amp;gt;msgid-&amp;gt;message，cid 会话 ID、msgid 消息 ID、message 消息)，这样实现的好处是消息入库效率高，只存储会话与消息的绑定关系即可；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;写扩散的场景&lt;/span&gt;：会话产生的消息投递到类似于个人邮件的收件箱，即 message_inbox 表，存储个人的所有消息（uid-&amp;gt;msgid-&amp;gt;message， uid 用户 ID、msgid 消息 ID、message 消息），基于这种实现，会话中的每条消息面向不同的接收者可以呈现出不同状态。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;DTIM 对 IM 消息的及时性、前后端存储状态一致性要求异常严格，特别对于历史消息漫游的诉求十分强烈，当前业界 IM 产品对于消息长时间存储和客户端历史消息多端漫游都做得不尽如人意，主要是存储成本过高。因此在产品体验与投入成本之间需要找到一个平衡点。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;采用读扩散：&lt;/strong&gt;&lt;span&gt;在个性化的消息扩展及实现层面有很大的约束。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;采用写扩散带来的问题也很明显：&lt;/strong&gt;&lt;span&gt;一个群成员为 N 的会话一旦产生消息就会扩散 N 条消息记录，如果在消息发送和扩散量较少的场景，这样的实现相比于读扩散落地更为简单，存储成本也不是问题。但是 DTIM 会话活跃度超高，一条消息的平均扩散比可以达到 1：30，超大群又是企业 IM 最核心的沟通场景，如果采用完全写扩散所带来存储成本问题势必制约钉钉业务发展。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在 DTIM 的存储实现上，钉钉采取了混合的方案，将读扩散和写扩散针对不同场景做了适配，最终在用户视角系统会做统一合并&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如下图所示。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图4：&lt;/strong&gt;&lt;span&gt;DTIM 读写混合模式 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.612942612942613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLrczaF55bcjtLJ2MTA7TUjYgiaNbcWcddicrG6sBxuAKhiaQkuwGPhs6BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_4.png&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;作为读扩散、写扩散方案的混合形式存在，用户维度的消息分别从 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表中获取，在应用侧按消息发送时间做排序合并，&lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 表中记录了该会话面向所有群成员接收的普通消息 N（&lt;/span&gt;&lt;span&gt;Normal&lt;/span&gt;&lt;span&gt;），而 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表在以下两种场景下被写入：&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;第一种是：&lt;/strong&gt;&lt;span&gt;定向消息 P（&lt;/span&gt;&lt;span&gt;Private，私有消息&lt;/span&gt;&lt;span&gt;），群会话中发送的消息指定了接收者范围，那么会直接写入到接收者的 message_inbox 表中，比如红包的领取状态消息只能被红包发送者可见，那么这种消息即被定义为定向消息。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;第二种是：&lt;/strong&gt;&lt;span&gt;归属于会话消息的状态转换 NP（&lt;/span&gt;&lt;span&gt;Normal to Private，普通消息转私有消息&lt;/span&gt;&lt;span&gt;），当会话消息通过某种行为使得某些消息接收者的消息状态发生转换时，该状态会写入到 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表中，比如用户在接收侧删除了消息，那么消息的删除状态会写入到 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 中，在用户拉取时会通过 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 的删除状态将 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 中的消息做覆盖，最终用户拉取不到自己已删除的消息。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;当用户在客户端发起某个会话的历史消息漫游请求时，服务端根据用户上传的消息截止时间（&lt;/span&gt;&lt;span&gt;message_create_time&lt;/span&gt;&lt;span&gt;）分别从 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 表和 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表拉取消息列表，在应用层做状态的合并，最终返回给用户合并之后的数据，N、P、NP 三种类型消息在消息个性化处理和存储成本之间取得了很好的平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;4.4、同步模型设计&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.4.1&lt;/span&gt;推送模型&lt;/h3&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;用户在会话中发出的消息和消息状态变更等事件是如何同步到端上呢？&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;业界关于消息的同步模型的实现方案大致有三种：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;客户端拉取方案；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;服务端推送方案；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;服务端推送位点之后客户端拉取的推拉结合方案。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;三种方案各有优劣，在此简短总结：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;首先&lt;/span&gt;：客户端拉取方案的优点是该方案实施简单、研发成本低，是传统的 B/S 架构。劣势是效率低下，拉取间隔控制权在客户端，对于 IM 这种实时的场景，很难设置一个有效的拉取间隔，间隔太短对服务端压力大，间隔太长时效性差；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;其次&lt;/span&gt;：服务端主动推送方案的优点是低延迟、能做到实时，最重要的主动权在服务端。劣势相对拉取方案，如何协调服务端和客户端的处理能力存在问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;最后&lt;/span&gt;：推拉结合这个方案整合了拉和推的优点，但是方案更复杂，同时会比推的方案多一次 RTT，特别是在移动网络的场景下，不得不面临功耗和推送成功率的问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;DTIM 相对传统 toC 的场景，有较明显的区别：&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第一是对实时性的要求：&lt;/strong&gt;&lt;span&gt;在企业服务中，比如员工聊天消息、各种系统报警，又比如音视频中的共享画板，无不要求实时事件同步，因此需要一种低延时的同步方案。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第二是弱网接入的能力：&lt;/strong&gt;&lt;span&gt;在 DTIM 服务的对象中，上千万的企业组织涉及各行各业，从大城市 5G 的高速到偏远的山区弱网，都需要 DTIM 的消息能发送、能触达。对于复杂的网络环境，需要服务端能判断接入环境，并依据不同的环境条件调整同步数据的策略。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第三是功耗可控成本可控：&lt;/strong&gt;&lt;span&gt;在 DTIM 的企业场景中，消息收发频率比传统的 IM 多出一个数量级，在这么大的消息收发场景怎么保障 DTIM 的功耗可控，特别是移动端的功耗可控，是 DTIM 必须面对的问题。在这种要求下，就需要 DTIM 尽量降低 IO 次数，并基于不同的消息优先级进行合并同步，既能要保障实时性不被破坏，又要做到低功耗。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;从以上三点可知，服务端主动推送的模型更适合 DTIM 场景：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;首先可以做到极低的延时，保障推送耗时在毫秒级别；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;其次是服务端能通过用户接入信息判断用户接入环境好坏，进行对应的分包优化，保障弱网链路下的成功率；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;最后是主动推送相对于推拉结合来说，可以降低一次 IO，对 DTIM 这种每分钟过亿消息服务来说，能极大的降低设备功耗，同时配合消息优先级合并包的优化，进一步降低端的功耗。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;虽说主动推送有诸多优势，但是客户端会离线，甚至客户端处理速度无法跟上服务端的速度，必然导致消息堆积。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;DTIM 为了协调服务端和客户端处理能力不一致的问题，支持 Rebase 的能力，当服务端消息堆积的条数达到一定阈值时触发 Rebase，客户端会从 DTIM 拉取最新的消息，同时服务端跳过这部分消息从最新的位点开始推送消息。DTIM 称这个同步模型为推优先模型（&lt;/span&gt;&lt;span&gt;Preferentially-Push Model，PPM&lt;/span&gt;&lt;span&gt;）。﻿&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;在基于 PPM 的推送方案下，为了保障消息的可靠达到，DTIM 还做一系列优化。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;这些优化具体是：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持消息可重入&lt;/span&gt;：服务端可能会针对某条消息做重复推送，客户端需要根据 msgId 做去重处理，避免端上消息重复展示。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持消息排序&lt;/span&gt;：服务端推送消息特别是群比较活跃的场景，某条消息由于推送链路或者端侧网络抖动，推送失败，而新的消息正常推送到端侧，如果端上不做消息排序的话，消息列表就会发生乱序，所以服务端会为每条消息分配一个时间戳，客户端每次进入消息列表就是根据时间戳做排序再投递给 UI 层做消息展示。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持缺失数据回补&lt;/span&gt;：在某个极端情况下客户端群消息事件比群创建事件更早到达端上，此时端上没有群的基本信息消息也就无法展现，所以需要客户端主动向服务端拉取群信息同步到本地，再做消息的透出。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.4.2&lt;/span&gt;多端数据一致性&lt;/h3&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;多端数据一致性问题一直是多端同步最核心的问题，单个用户可以同时在 PC、Pad 以及 Mobile 登录，消息、会话红点等状态需要在多端保持一致，并且用户更换设备情况下消息可以做全量的回溯。﻿&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;基于上面的业务诉求以及系统层面面临的诸多挑战，钉钉自研了同步服务来解决一致性问题。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;钉钉的同步服务的设计理念和原则如下：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;统一消息模型抽象，对于 DTIM 服务产生的新消息以及已读事件、会话增删改、多端红点清除等事件统一抽象为同步服务的事件；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;同步服务不感知事件的类型以及数据序列化方式。同步服务为每个用户的事件分配一个自增的 ID（注：这里非连续递增），确保消息可以根据 ID 做遍历的有序查询；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;统一同步队列，同步服务为每个用户分配了一个 FIFO 的队列存储，自增 id 和事件串行写入队列；当有事件推送时，服务端根据用户当前各端在线设备状态做增量变更，将增量事件推送到各端；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/em&gt;根据设备和网络质量的不同可以做多种分包推送策略，确保消息可以有序、可靠、高效的发送给客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;上面介绍了 DTIM 的存储模型以及同步模型的设计与思考：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;五、相关资料&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 企业级IM王者——钉钉在后端架构上的过人之处&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-2848-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[2]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 现代IM系统中聊天消息的同步和存储方案探讨&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-1230-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[3]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 钉钉——基于IM技术的新一代企业OA平台的技术挑战(视频+PPT)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-527-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[4]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套亿级用户的IM架构技术干货(上篇)：整体架构、服务拆分等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3393-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[5]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套亿级用户的IM架构技术干货(下篇)：可靠性、有序性、弱网优化等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3445-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[6]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 从新手到专家：如何设计一套亿级消息量的分布式IM系统&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3472-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[7]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 企业微信的IM架构设计揭秘：消息模型、万人群、已读回执、消息撤回等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3631-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[8]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 全面揭秘亿级IM消息的可靠投递机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3638-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[9]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套高可用、易伸缩、高并发的IM群聊、单聊架构方案设计实践&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-2015-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[10]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套海量在线用户的移动端IM架构设计实践分享(含详细图文)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-812-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[11]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套原创分布式即时通讯(IM)系统理论架构方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-151-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;六、全文链接&lt;/h2&gt;&lt;p&gt;&lt;span&gt;即时通讯网(52im.net)&lt;/span&gt;&lt;span&gt;&lt;span&gt;社区链接：&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-4012-1-1.html&lt;/span&gt;&lt;span&gt;，或点击下文的“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6894b0f486d7d654c4c6bd2e48028fb2</guid>
<title>最强分布式锁工具：Redisson</title>
<link>https://toutiao.io/k/v9di3a4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文：juejin.cn/post/6961380552519712798&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来聊聊分布式锁的最强实现：&lt;strong&gt;Redisson&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从分布式锁到Redisson实现非常详细，适合慢慢咀嚼~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Redisson概述&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;什么是Redisson？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个基于Redis实现的分布式工具，有基本分布式对象和高级又抽象的分布式服务，为每个试图再造分布式轮子的程序员带来了大部分分布式问题的解决办法。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson和Jedis、Lettuce有什么区别？倒也不是雷锋和雷锋塔&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson和它俩的区别就像一个用鼠标操作图形化界面，一个用命令行操作文件。Redisson是更高层的抽象，Jedis和Lettuce是Redis命令的封装。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Jedis是Redis官方推出的用于通过Java连接Redis客户端的一个工具包，提供了Redis的各种命令支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Lettuce是一种可扩展的线程安全的 Redis 客户端，通讯框架基于Netty，支持高级的 Redis 特性，比如哨兵，集群，管道，自动重新连接和Redis数据模型。Spring Boot 2.x 开始 Lettuce 已取代 Jedis 成为首选 Redis 的客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redisson是架设在Redis基础上，通讯基于Netty的综合的、新型的中间件，企业级开发中使用Redis的最佳范本&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jedis把Redis命令封装好，Lettuce则进一步有了更丰富的Api，也支持集群等模式。但是两者也都点到为止，只给了你操作Redis数据库的脚手架，而Redisson则是基于Redis、Lua和Netty建立起了成熟的分布式解决方案，甚至redis官方都推荐的一种工具集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;分布式锁怎么实现？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁是并发业务下的刚需，虽然实现五花八门：ZooKeeper有Znode顺序节点，数据库有表级锁和乐/悲观锁，Redis有setNx，但是殊途同归，最终还是要回到互斥上来，本篇介绍Redisson，那就以redis为例。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;怎么写一个简单的Redis分布式锁？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以Spring Data Redis为例，用RedisTemplate来操作Redis（setIfAbsent已经是setNx + expire的合并命令），如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Boolean &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(String key, String value, &lt;span&gt;long&lt;/span&gt; timeout, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; redisTemplate.opsForValue().setIfAbsent(key, value, timeout, unit);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 解锁，防止删错别人的锁，以uuid为value校验是否自己的锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(String lockName, String uuid)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(uuid.equals(redisTemplate.opsForValue().get(lockName)){        redisTemplate.opsForValue().del(lockName);    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 结构&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(tryLock){&lt;br/&gt;    &lt;span&gt;// todo&lt;/span&gt;&lt;br/&gt;}&lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;    unlock;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单1.0版本完成，聪明的小张一眼看出，这是锁没错，但get和del操作非原子性，并发一旦大了，无法保证进程安全。于是小张提议，用Lua脚本&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;Lua脚本是什么？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lua脚本是redis已经内置的一种轻量小巧语言，其执行是通过redis的&lt;strong&gt;eval&lt;/strong&gt; /&lt;strong&gt;evalsha&lt;/strong&gt; 命令来运行，把操作封装成一个Lua脚本，如论如何都是一次执行的原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是2.0版本通过Lua脚本删除&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lockDel.lua如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == ARGV[&lt;span&gt;1&lt;/span&gt;] &lt;br/&gt;    then &lt;br/&gt; -- 执行删除操作&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) &lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;br/&gt; -- 不成功，返回&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;delete操作时执行Lua命令&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 解锁脚本&lt;/span&gt;&lt;br/&gt;DefaultRedisScript&amp;lt;Object&amp;gt; unlockScript = &lt;span&gt;new&lt;/span&gt; DefaultRedisScript();&lt;br/&gt;unlockScript.setScriptSource(&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;lockDel.lua&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 执行lua脚本解锁&lt;/span&gt;&lt;br/&gt;redisTemplate.execute(unlockScript, Collections.singletonList(keyName), value);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.0似乎更像一把锁，但好像又缺少了什么，小张一拍脑袋，synchronized和ReentrantLock都很丝滑，因为他们都是可重入锁，一个线程多次拿锁也不会死锁，我们需要可重入。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;怎么保证可重入？&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重入就是，同一个线程多次获取同一把锁是允许的，不会造成死锁，这一点synchronized偏向锁提供了很好的思路，synchronized的实现重入是在JVM层面，JAVA对象头MARK WORD中便藏有线程ID和计数器来对当前线程做重入判断，避免每次CAS。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁标志是否设置成1：没有则CAS竞争；设置了，则CAS将对象头偏向锁指向当前线程。&lt;/p&gt;&lt;p&gt;再维护一个计数器，同个线程进入则自增1，离开再减1，直到为0才能释放&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可重入锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仿造该方案，我们需改造Lua脚本：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.需要存储 锁名称&lt;strong&gt;lockName&lt;/strong&gt; 、获得该锁的&lt;strong&gt;线程id&lt;/strong&gt; 和对应线程的&lt;strong&gt;进入次数count&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2.加锁&lt;/p&gt;&lt;p&gt;每次线程获取锁时，判断是否已存在该锁&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不存在&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置hash的key为线程id，value初始化为1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回获取锁成功true&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存在&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续判断是否存在当前线程id的hash key&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存在，线程key的value + 1，重入次数增加1，设置过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不存在，返回加锁失败&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3.解锁&lt;/p&gt;&lt;p&gt;每次线程来解锁时，判断是否已存在该锁&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;存在&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否有该线程的id的hash key，有则减1，无则返回解锁失败&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减1后，判断剩余count是否为0，为0则说明不再需要这把锁，执行del命令删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.存储结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便维护这个对象，我们用Hash结构来存储这些字段。Redis的Hash类似Java的HashMap，适合存储对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/JfTPiahTHJhovmibd98agRTiamZFNibribDoFHZwGZ0fzwuYibicwTHO8aZT9UgPAOiblOwiaRtLLMhZT7WkVI8XR8LIRPw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&amp;amp;random=0.4520806851381116&quot; data-w=&quot;640&quot;/&gt;图片&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hset lockname1 threadId &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置一个名字为&lt;strong&gt;lockname1&lt;/strong&gt; 的hash结构，该hash结构key为&lt;strong&gt;threadId&lt;/strong&gt; ，值value为&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hget lockname1 threadId&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取lockname1的threadId的值&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储结构为&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;lockname 锁名称&lt;br/&gt;    key1：   threadId   唯一键，线程id&lt;br/&gt;    value1：  count     计数器，记录该线程获取锁的次数&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis中的结构&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3371104815864023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zQlJibwibtLoeUTxT9icas31E0eRtgpw0NfPia9xfibOFKE9aFUPqpuf93Lg/640?wx_fmt=other&amp;amp;random=0.1390218909689791&quot; data-type=&quot;other&quot; data-w=&quot;1412&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.计数器的加减&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当同一个线程获取同一把锁时，我们需要对对应线程的计数器count做加减&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断一个redis key是否存在，可以用&lt;code&gt;exists&lt;/code&gt;，而判断一个hash的key是否存在，可以用&lt;code&gt;hexists&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6464968152866242&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zgX7xHxGSKv0eOJfKHfFoSIpqRvsceIYruDc7ibYgOmgtpDmLrteU5Ig/640?wx_fmt=other&amp;amp;random=0.5893847106639996&quot; data-type=&quot;other&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而redis也有hash自增的命令&lt;code&gt;hincrby&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次自增1时 &lt;code&gt;hincrby lockname1 threadId 1&lt;/code&gt;，自减1时 &lt;code&gt;hincrby lockname1 threadId -1&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2139917695473251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zj7H1X1eNDBXibBGkhYHIk9ccbJSwolJ8xoJJ8Fg5PzccIIu2ibYr5EJg/640?wx_fmt=other&amp;amp;random=0.05510636950966741&quot; data-type=&quot;other&quot; data-w=&quot;486&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.解锁的判断&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一把锁不再被需要了，每次解锁一次，count减1，直到为0时，执行删除&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合上述的存储结构和判断流程，加锁和解锁Lua如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁 lock.lua&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;local key = KEYS[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;local threadId = ARGV[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;local releaseTime = ARGV[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;-- lockname不存在&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, key) == &lt;span&gt;0&lt;/span&gt;) then&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;hset&#x27;&lt;/span&gt;, key, threadId, &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;);&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;expire&#x27;&lt;/span&gt;, key, releaseTime);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- 当前线程已id存在&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, key, threadId) == &lt;span&gt;1&lt;/span&gt;) then&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, key, threadId, &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;);&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;expire&#x27;&lt;/span&gt;, key, releaseTime);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;end;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解锁 unlock.lua&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;local key = KEYS[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;local threadId = ARGV[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;-- lockname、threadId不存在&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, key, threadId) == &lt;span&gt;0&lt;/span&gt;) then&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- 计数器-&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;local count = redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, key, threadId, -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;-- 删除&lt;span&gt;lock&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(count == &lt;span&gt;0&lt;/span&gt;)&lt;/span&gt; then&lt;br/&gt;    redis.&lt;span&gt;call&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;, key)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;end;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 原生redis实现分布式锁&lt;br/&gt; **/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Setter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisLock&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisTemplate redisTemplate;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Long&amp;gt; lockScript;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; DefaultRedisScript&amp;lt;Object&amp;gt; unlockScript;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RedisLock&lt;/span&gt;&lt;span&gt;(RedisTemplate redisTemplate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.redisTemplate = redisTemplate;&lt;br/&gt;        &lt;span&gt;// 加载加锁的脚本&lt;/span&gt;&lt;br/&gt;        lockScript = &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.lockScript.setScriptSource(&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;lock.lua&quot;&lt;/span&gt;)));&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.lockScript.setResultType(Long&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 加载释放锁的脚本&lt;/span&gt;&lt;br/&gt;        unlockScript = &lt;span&gt;new&lt;/span&gt; DefaultRedisScript&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.unlockScript.setScriptSource(&lt;span&gt;new&lt;/span&gt; ResourceScriptSource(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;unlock.lua&quot;&lt;/span&gt;)));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;(String lockName, &lt;span&gt;long&lt;/span&gt; releaseTime)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 存入的线程信息的前缀&lt;/span&gt;&lt;br/&gt;        String key = UUID.randomUUID().toString();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 执行脚本&lt;/span&gt;&lt;br/&gt;        Long result = (Long) redisTemplate.execute(&lt;br/&gt;                lockScript,&lt;br/&gt;                Collections.singletonList(lockName),&lt;br/&gt;                key + Thread.currentThread().getId(),&lt;br/&gt;                releaseTime);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; result.intValue() == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; key;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 解锁&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; lockName&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;(String lockName, String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        redisTemplate.execute(unlockScript,&lt;br/&gt;                Collections.singletonList(lockName),&lt;br/&gt;                key + Thread.currentThread().getId()&lt;br/&gt;                );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此已经完成了一把分布式锁，符合互斥、可重入、防死锁的基本特点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严谨的小张觉得虽然当个普通互斥锁，已经稳稳够用，可是业务里总是又很多特殊情况的，&lt;strong&gt;比如A进程在获取到锁的时候，因业务操作时间太长，锁释放了但是业务还在执行，而此刻B进程又可以正常拿到锁做业务操作，两个进程操作就会存在依旧有共享资源的问题&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且如果负责储存这个分布式锁的&lt;strong&gt;Redis节点宕机以后，而且这个锁正好处于锁住的状态时，这个锁会出现锁死的状态&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张不是杠精，因为库存操作总有这样那样的特殊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们希望在这种情况时，可以延长锁的releaseTime延迟释放锁来直到完成业务期望结果，这种不断延长锁过期时间来保证业务执行完成的操作就是锁续约。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离也是常见，一个读多写少的业务为了性能，常常是有读锁和写锁的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而此刻的扩展已经超出了一把简单轮子的复杂程度，光是处理续约，就够小张喝一壶，何况在性能（锁的最大等待时间）、优雅（无效锁申请）、重试（失败重试机制）等方面还要下功夫研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在小张苦思冥想时，旁边的小白凑过来看了看小张，很好奇，都2021年了，为什么不直接用redisson呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson就有这把你要的锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Redisson分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;号称简单的Redisson分布式锁的使用姿势是什么？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 依赖&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 原生，本章使用--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.redisson&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;redisson&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.13.6&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 另一种Spring集成starter，本章未使用 --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.redisson&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;redisson-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.13.6&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 配置&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedissionConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${spring.redis.host}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String redisHost;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${spring.redis.password}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String password;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;6379&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedissonClient &lt;span&gt;getRedisson&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Config config = &lt;span&gt;new&lt;/span&gt; Config();&lt;br/&gt;        config.useSingleServer().&lt;br/&gt;                setAddress(&lt;span&gt;&quot;redis://&quot;&lt;/span&gt; + redisHost + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + port).&lt;br/&gt;                setPassword(password);&lt;br/&gt;        config.setCodec(&lt;span&gt;new&lt;/span&gt; JsonJacksonCodec());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Redisson.create(config);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 启用分布式锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; RedissonClient redissonClient;&lt;br/&gt;&lt;br/&gt;RLock rLock = redissonClient.getLock(lockName);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isLocked = rLock.tryLock(expireTime, TimeUnit.MILLISECONDS);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isLocked) {&lt;br/&gt;        &lt;span&gt;// TODO&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            rLock.unlock();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简洁明了，只需要一个RLock，既然推荐Redisson，就往里面看看他是怎么实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. RLock&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RLock是Redisson分布式锁的最核心接口，继承了concurrent包的Lock接口和自己的RLockAsync接口，RLockAsync的返回值都是RFuture，是Redisson执行异步实现的核心逻辑，也是Netty发挥的主要阵地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RLock如何加锁？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从RLock进入，找到RedissonLock类，找到&lt;strong&gt;tryLock&lt;/strong&gt; 方法再递进到干事的&lt;strong&gt;tryAcquireOnceAsync&lt;/strong&gt; 方法，这是加锁的主要代码（版本不一此处实现有差别，和最新3.15.x有一定出入，但是核心逻辑依然未变。此处以3.13.6为例）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;tryAcquireOnceAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leaseTime != -&lt;span&gt;1L&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            RFuture&amp;lt;Boolean&amp;gt; ttlRemainingFuture = &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, &lt;span&gt;this&lt;/span&gt;.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;            ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (ttlRemaining) {&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.scheduleExpirationRenewal(threadId);&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ttlRemainingFuture;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处出现leaseTime时间判断的2个分支，实际上就是加锁时是否设置过期时间，未设置过期时间（-1）时则会有&lt;strong&gt;watchDog&lt;/strong&gt; 的&lt;strong&gt;锁续约&lt;/strong&gt; （下文），一个注册了加锁事件的续约任务。我们先来看有过期时间&lt;strong&gt;tryLockInnerAsync&lt;/strong&gt; 部分，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;evalWriteAsync是eval命令执行lua的入口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;tryAcquireOnceAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leaseTime != -&lt;span&gt;1L&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            RFuture&amp;lt;Boolean&amp;gt; ttlRemainingFuture = &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, &lt;span&gt;this&lt;/span&gt;.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;            ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (ttlRemaining) {&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.scheduleExpirationRenewal(threadId);&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ttlRemainingFuture;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里揭开真面目，eval命令执行Lua脚本的地方，此处的Lua脚本展开&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-- 不存在该key时&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;) then &lt;br/&gt;  -- 新增该锁并且hash中该线程id对应的count置&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;  -- 设置过期时间&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;end; &lt;br/&gt;&lt;br/&gt;-- 存在该key 并且 hash中线程id的key也存在&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) then &lt;br/&gt;  -- 线程重入次数++&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil; &lt;br/&gt;end; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&#x27;pttl&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和前面我们写自定义的分布式锁的脚本几乎一致，看来redisson也是一样的实现，具体参数分析：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// keyName&lt;/span&gt;&lt;br/&gt;KEYS[&lt;span&gt;1&lt;/span&gt;] = Collections.singletonList(&lt;span&gt;this&lt;/span&gt;.getName())&lt;br/&gt;&lt;span&gt;// leaseTime&lt;/span&gt;&lt;br/&gt;ARGV[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;this&lt;/span&gt;.internalLockLeaseTime&lt;br/&gt;&lt;span&gt;// uuid+threadId组合的唯一值&lt;/span&gt;&lt;br/&gt;ARGV[&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;this&lt;/span&gt;.getLockName(threadId)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共3个参数完成了一段逻辑：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;判断该锁是否已经有对应hash表存在，&lt;/p&gt;&lt;p&gt;• 没有对应的hash表：则set该hash表中一个entry的key为锁名称，value为1，之后设置该hash表失效时间为leaseTime&lt;/p&gt;&lt;p&gt;• 存在对应的hash表：则将该lockName的value执行+1操作，也就是计算进入次数，再设置失效时间leaseTime&lt;/p&gt;&lt;p&gt;• 最后返回这把锁的ttl剩余时间&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也和上述自定义锁没有区别&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然如此，那解锁的步骤也肯定有对应的-1操作，再看unlock方法，同样查找方法名，一路到&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;unlockInnerAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.commandExecutor.evalWriteAsync(&lt;span&gt;this&lt;/span&gt;.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &lt;span&gt;&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then return nil;end; local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); if (counter &amp;gt; 0) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); return 0; else redis.call(&#x27;del&#x27;, KEYS[1]); redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); return 1; end; return nil;&quot;&lt;/span&gt;, Arrays.asList(&lt;span&gt;this&lt;/span&gt;.getName(), &lt;span&gt;this&lt;/span&gt;.getChannelName()), &lt;span&gt;new&lt;/span&gt; Object[]{LockPubSub.unlockMessage, &lt;span&gt;this&lt;/span&gt;.internalLockLeaseTime, &lt;span&gt;this&lt;/span&gt;.getLockName(threadId)});&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掏出Lua部分&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-- 不存在&lt;span&gt;key&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;(redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;3&lt;/span&gt;])&lt;/span&gt; &lt;/span&gt;== &lt;span&gt;0&lt;/span&gt;) then &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;end;&lt;br/&gt;-- 计数器 -&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;local counter = redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;3&lt;/span&gt;], -&lt;span&gt;1&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (counter &amp;gt; &lt;span&gt;0&lt;/span&gt;) then &lt;br/&gt;  -- 过期时间重设&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  -- 删除并发布解锁消息&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;del&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  redis.call(&lt;span&gt;&#x27;publish&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;end; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该Lua KEYS有2个&lt;code&gt;Arrays.asList(getName(), getChannelName())&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;name 锁名称&lt;br/&gt;channelName，用于pubSub发布消息的channel名称&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARGV变量有三个&lt;code&gt;LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId)&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LockPubSub.UNLOCK_MESSAGE，channel发送消息的类别，此处解锁为&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;internalLockLeaseTime，watchDog配置的超时时间，默认为&lt;span&gt;30&lt;/span&gt;s&lt;br/&gt;lockName 这里的lockName指的是uuid和threadId组合的唯一值&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.如果该锁不存在则返回nil；&lt;/p&gt;&lt;p&gt;2.如果该锁存在则将其线程的hash key计数器-1，&lt;/p&gt;&lt;p&gt;3.计数器counter&amp;gt;0，重置下失效时间，返回0；否则，删除该锁，发布解锁消息unlockMessage，返回1；&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中unLock的时候使用到了Redis发布订阅PubSub完成消息通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而订阅的步骤就在RedissonLock的加锁入口的lock方法里&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt; threadId = Thread.currentThread().getId();&lt;br/&gt;        Long ttl = &lt;span&gt;this&lt;/span&gt;.tryAcquire(-&lt;span&gt;1L&lt;/span&gt;, leaseTime, unit, threadId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ttl != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// 订阅&lt;/span&gt;&lt;br/&gt;            RFuture&amp;lt;RedissonLockEntry&amp;gt; future = &lt;span&gt;this&lt;/span&gt;.subscribe(threadId);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (interruptibly) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.commandExecutor.syncSubscriptionInterrupted(future);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.commandExecutor.syncSubscription(future);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 省略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当锁被其他线程占用时，通过监听锁的释放通知（在其他线程通过RedissonLock释放锁时，会通过发布订阅pub/sub功能发起通知），等待锁被其他线程释放，也是为了避免自旋的一种常用效率手段。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 解锁消息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了一探究竟通知了什么，通知后又做了什么，进入LockPubSub。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只有一个明显的监听方法onMessage，其订阅和信号量的释放都在父类PublishSubscribe，我们只关注监听事件的实际操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(RedissonLockEntry value, Long message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Runnable runnableToExecute;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (message.equals(unlockMessage)) {&lt;br/&gt;            &lt;span&gt;// 从监听器队列取监听线程执行监听回调&lt;/span&gt;&lt;br/&gt;            runnableToExecute = (Runnable)value.getListeners().poll();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (runnableToExecute != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                runnableToExecute.run();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// getLatch()返回的是Semaphore，信号量，此处是释放信号量&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 释放信号量后会唤醒等待的entry.getLatch().tryAcquire去再次尝试申请锁&lt;/span&gt;&lt;br/&gt;            value.getLatch().release();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (message.equals(readUnlockMessage)) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                runnableToExecute = (Runnable)value.getListeners().poll();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (runnableToExecute == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    value.getLatch().release(value.getLatch().getQueueLength());&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                runnableToExecute.run();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现一个是&lt;strong&gt;默认解锁消息&lt;/strong&gt; ，一个是&lt;strong&gt;读锁解锁消息&lt;/strong&gt; ，因为redisson是有提供读写锁的，而读写锁读读情况和读写、写写情况互斥情况不同，我们只看上面的默认解锁消息unlockMessage分支&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LockPubSub监听最终执行了2件事&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;runnableToExecute.run()&lt;/code&gt; 执行监听回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;value.getLatch().release();&lt;/code&gt; 释放信号量&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson通过&lt;strong&gt;LockPubSub&lt;/strong&gt; 监听解锁消息，执行监听回调和释放信号量通知等待线程可以重新抢锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时再回来看tryAcquireOnceAsync另一分支&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;tryAcquireOnceAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; waitTime, &lt;span&gt;long&lt;/span&gt; leaseTime, TimeUnit unit, &lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (leaseTime != -&lt;span&gt;1L&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, leaseTime, unit, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            RFuture&amp;lt;Boolean&amp;gt; ttlRemainingFuture = &lt;span&gt;this&lt;/span&gt;.tryLockInnerAsync(waitTime, &lt;span&gt;this&lt;/span&gt;.commandExecutor.getConnectionManager().getCfg().getLockWatchdogTimeout(), TimeUnit.MILLISECONDS, threadId, RedisCommands.EVAL_NULL_BOOLEAN);&lt;br/&gt;            ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (ttlRemaining) {&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.scheduleExpirationRenewal(threadId);&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ttlRemainingFuture;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，无超时时间时，在执行加锁操作后，还执行了一段费解的逻辑&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ttlRemainingFuture.onComplete((ttlRemaining, e) -&amp;gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (e == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (ttlRemaining) {&lt;br/&gt;                        &lt;span&gt;this&lt;/span&gt;.scheduleExpirationRenewal(threadId);&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                }&lt;br/&gt;            })&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处涉及到Netty的Future/Promise-Listener模型，Redisson中几乎全部以这种方式通信（所以说Redisson是基于Netty通信机制实现的），理解这段逻辑可以试着先理解&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;在 Java 的 Future 中，业务逻辑为一个 Callable 或 Runnable 实现类，该类的 call()或 run()执行完毕意味着业务逻辑的完结，在 Promise 机制中，可以在业务逻辑中人工设置业务逻辑的成功与失败，这样更加方便的监控自己的业务逻辑。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块代码的表面意义就是，在执行异步加锁的操作后，加锁成功则根据加锁完成返回的ttl是否过期来确认是否执行一段定时任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段定时任务的就是watchDog的核心。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 锁续约&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看&lt;code&gt;RedissonLock.this.scheduleExpirationRenewal(threadId)&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;scheduleExpirationRenewal&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RedissonLock.ExpirationEntry entry = &lt;span&gt;new&lt;/span&gt; RedissonLock.ExpirationEntry();&lt;br/&gt;        RedissonLock.ExpirationEntry oldEntry = (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.putIfAbsent(&lt;span&gt;this&lt;/span&gt;.getEntryName(), entry);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (oldEntry != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            oldEntry.addThreadId(threadId);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            entry.addThreadId(threadId);&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.renewExpiration();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;renewExpiration&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RedissonLock.ExpirationEntry ee = (RedissonLock.ExpirationEntry)EXPIRATION_RENEWAL_MAP.get(&lt;span&gt;this&lt;/span&gt;.getEntryName());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ee != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            Timeout task = &lt;span&gt;this&lt;/span&gt;.commandExecutor.getConnectionManager().newTimeout(&lt;span&gt;new&lt;/span&gt; TimerTask() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(Timeout timeout)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                    RedissonLock.ExpirationEntry ent = (RedissonLock.ExpirationEntry)RedissonLock.EXPIRATION_RENEWAL_MAP.get(RedissonLock.&lt;span&gt;this&lt;/span&gt;.getEntryName());&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (ent != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        Long threadId = ent.getFirstThreadId();&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (threadId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                            RFuture&amp;lt;Boolean&amp;gt; future = RedissonLock.&lt;span&gt;this&lt;/span&gt;.renewExpirationAsync(threadId);&lt;br/&gt;                            future.onComplete((res, e) -&amp;gt; {&lt;br/&gt;                                &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                                    RedissonLock.log.error(&lt;span&gt;&quot;Can&#x27;t update lock &quot;&lt;/span&gt; + RedissonLock.&lt;span&gt;this&lt;/span&gt;.getName() + &lt;span&gt;&quot; expiration&quot;&lt;/span&gt;, e);&lt;br/&gt;                                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                                    &lt;span&gt;if&lt;/span&gt; (res) {&lt;br/&gt;                                        RedissonLock.&lt;span&gt;this&lt;/span&gt;.renewExpiration();&lt;br/&gt;                                    }&lt;br/&gt;&lt;br/&gt;                                }&lt;br/&gt;                            });&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }, &lt;span&gt;this&lt;/span&gt;.internalLockLeaseTime / &lt;span&gt;3L&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;br/&gt;            ee.setTimeout(task);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拆分来看，这段连续嵌套且冗长的代码实际上做了几步&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;• 添加一个netty的Timeout回调任务，每（&lt;code&gt;internalLockLeaseTime / 3&lt;/code&gt;）毫秒执行一次，执行的方法是&lt;code&gt;renewExpirationAsync&lt;/code&gt;&lt;/p&gt;&lt;p&gt;• &lt;code&gt;renewExpirationAsync&lt;/code&gt;重置了锁超时时间，又注册一个监听器，监听回调又执行了&lt;code&gt;renewExpiration&lt;/code&gt;&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;renewExpirationAsync&lt;/code&gt; 的Lua如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;renewExpirationAsync&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; threadId)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.commandExecutor.evalWriteAsync(&lt;span&gt;this&lt;/span&gt;.getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN, &lt;span&gt;&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); return 1; end; return 0;&quot;&lt;/span&gt;, Collections.singletonList(&lt;span&gt;this&lt;/span&gt;.getName()), &lt;span&gt;new&lt;/span&gt; Object[]{&lt;span&gt;this&lt;/span&gt;.internalLockLeaseTime, &lt;span&gt;this&lt;/span&gt;.getLockName(threadId)});&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt;) then &lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;; &lt;br/&gt;end; &lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重新设置了超时时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Redisson加这段逻辑的目的是什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目的是为了某种场景下保证业务不影响，如任务执行超时但未结束，锁已经释放的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当一个线程持有了一把锁，由于并未设置超时时间leaseTime，Redisson默认配置了30S，开启watchDog，每10S对该锁进行一次续约，维持30S的超时时间，直到任务完成再删除锁。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是Redisson的&lt;strong&gt;锁续约&lt;/strong&gt; ，也就是&lt;strong&gt;WatchDog&lt;/strong&gt; 实现的基本思路。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 流程概括&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过整体的介绍，流程简单概括：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;A、B线程争抢一把锁，A获取到后，B阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B线程阻塞时并非主动CAS，而是PubSub方式订阅该锁的广播消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A操作完成释放了锁，B线程收到订阅消息通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B被唤醒开始继续抢锁，拿到锁&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细加锁解锁流程总结如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1055319148936171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4z6KL95s2fVjrD5ZuLl7MCsAF7NSEBnp3LpJicMsQnl1p5BqtQF2BAHRg/640?wx_fmt=other&amp;amp;random=0.4274622971093134&quot; data-type=&quot;other&quot; data-w=&quot;1175&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 公平锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上介绍的可重入锁是非公平锁，Redisson还基于Redis的队列（List）和ZSet实现了公平锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平的定义是什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平就是按照客户端的请求先来后到排队来获取锁，先到先得，也就是FIFO，所以队列和容器顺序编排必不可少&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;FairSync&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾JUC的ReentrantLock公平锁的实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Sync object for fair locks&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FairSync&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Sync&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -&lt;span&gt;3000897897090466540L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Fair version of tryAcquire.  Don&#x27;t grant access unless&lt;br/&gt;     * recursive call or no waiters or is first.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; c = getState();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!hasQueuedPredecessors() &amp;amp;&amp;amp;&lt;br/&gt;                compareAndSetState(&lt;span&gt;0&lt;/span&gt;, acquires)) {&lt;br/&gt;                setExclusiveOwnerThread(current);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nextc = c + acquires;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;br/&gt;            setState(nextc);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS已经提供了整个实现，是否公平取决于实现类取出节点逻辑是否顺序取&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9441747572815534&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zOD1SOEoS0j3HSLwIvFmANCesOgtDGNl84cdTPwvT2whaAEXQGBBVsw/640?wx_fmt=other&amp;amp;random=0.07091225780261312&quot; data-type=&quot;other&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer是用来构建锁或者其他同步组件的基础框架，通过内置FIFO队列来完成资源获取线程的排队工作，他自身没有实现同步接口，仅仅定义了若干同步状态获取和释放的方法来供自定义同步组件使用（上图），支持独占和共享获取，这是基于模版方法模式的一种设计，给公平/非公平提供了土壤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用2张图来简单解释AQS的等待流程（出自《JAVA并发编程的艺术》）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一张是同步队列（FIFO双向队列）&lt;strong&gt;管理 获取同步状态失败（抢锁失败）的线程引用、等待状态和前驱后继节点的流程图&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28445006321112515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zqthfQlhVnaL1ksAMBYJBzOTwTiaqakdM3WTes0y60Rm3OOfRhUVSpCg/640?wx_fmt=other&amp;amp;random=0.9592101252387035&quot; data-type=&quot;other&quot; data-w=&quot;791&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一张是&lt;strong&gt;独占式获取同步状态的总流程&lt;/strong&gt; ，核心acquire(int arg)方法调用流程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.925686591276252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zmX7C9nO61QUvLz5KZgKzIJDuAbX81L6NNcqzicPoV8Ck9cvNjVvOFoQ/640?wx_fmt=other&amp;amp;random=0.9514430855491649&quot; data-type=&quot;other&quot; data-w=&quot;619&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出锁的获取流程&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;AQS维护一个同步队列，获取状态失败的线程都会加入到队列中进行自旋，移出队列或停止自旋的条件是前驱节点为头节点切成功获取了同步状态。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而比较另一段非公平锁类&lt;code&gt;NonfairSync&lt;/code&gt;可以发现，控制公平和非公平的关键代码，在于&lt;code&gt;hasQueuedPredecessors&lt;/code&gt;方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NonfairSync&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Sync&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = &lt;span&gt;7316153563782823691L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Performs lock.  Try immediate barge, backing up to normal&lt;br/&gt;     * acquire on failure.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;            setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; nonfairTryAcquire(acquires);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NonfairSync&lt;/code&gt;减少了了&lt;code&gt;hasQueuedPredecessors&lt;/code&gt;判断条件，该方法的作用就是&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;查看同步队列中当前节点是否有前驱节点，如果有比当前线程更早请求获取锁则返回true。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;保证每次都取队列的第一个节点（线程）来获取锁，这就是公平规则&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么JUC以默认非公平锁呢？&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;因为当一个线程请求锁时，只要获取来同步状态即成功获取。在此前提下，刚释放的线程再次获取同步状态的几率会非常大，使得其他线程只能在同步队列中等待。但这样带来的好处是，非公平锁大大减少了系统线程上下文的切换开销。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见公平的代价是性能与吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis里没有AQS，但是有List和zSet，看看Redisson是怎么实现公平的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RedissonFairLock&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedissonFairLock 用法依然很简单&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RLock fairLock = redissonClient.getFairLock(lockName);&lt;br/&gt;&lt;br/&gt;fairLock.lock();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RedissonFairLock&lt;/code&gt;继承自&lt;code&gt;RedissonLock&lt;/code&gt;，同样一路向下找到加锁实现方法&lt;strong&gt;tryLockInnerAsync&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有2段冗长的Lua，但是Debug发现，公平锁的入口在 &lt;code&gt;command == RedisCommands.EVAL_LONG&lt;/code&gt; 之后，此段Lua较长，参数也多，我们着重分析Lua的实现规则&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-- lua中的几个参数&lt;br/&gt;KEYS = Arrays.&amp;lt;Object&amp;gt;asList(getName(), threadsQueueName, timeoutSetName)&lt;br/&gt;KEYS[&lt;span&gt;1&lt;/span&gt;]: lock_name, 锁名称                   &lt;br/&gt;KEYS[&lt;span&gt;2&lt;/span&gt;]: &lt;span&gt;&quot;redisson_lock_queue:{xxx}&quot;&lt;/span&gt;  线程队列&lt;br/&gt;KEYS[&lt;span&gt;3&lt;/span&gt;]: &lt;span&gt;&quot;redisson_lock_timeout:{xxx}&quot;&lt;/span&gt;  线程id对应的超时集合&lt;br/&gt;&lt;br/&gt;ARGV =  internalLockLeaseTime, getLockName(threadId), currentTime + threadWaitTime, currentTime&lt;br/&gt;ARGV[&lt;span&gt;1&lt;/span&gt;]: &lt;span&gt;&quot;{leaseTime}&quot;&lt;/span&gt; 过期时间&lt;br/&gt;ARGV[&lt;span&gt;2&lt;/span&gt;]: &lt;span&gt;&quot;{Redisson.UUID}:{threadId}&quot;&lt;/span&gt;   &lt;br/&gt;ARGV[&lt;span&gt;3&lt;/span&gt;] = 当前时间 + 线程等待时间:（&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;） + &lt;span&gt;5000&lt;/span&gt;毫秒 = &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt;&lt;br/&gt;ARGV[&lt;span&gt;4&lt;/span&gt;] = 当前时间（&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;）  部署服务器时间，非redis-server服务器时间&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁实现的Lua脚本&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-- &lt;span&gt;1&lt;/span&gt;.死循环清除过期key&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; &lt;br/&gt;  -- 获取头节点&lt;br/&gt;    local firstThreadId2 = redis.call(&lt;span&gt;&#x27;lindex&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    -- 首次获取必空跳出循环&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; firstThreadId2 == &lt;span&gt;false&lt;/span&gt; then &lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  end;&lt;br/&gt;  -- 清除过期key&lt;br/&gt;  local timeout = tonumber(redis.call(&lt;span&gt;&#x27;zscore&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], firstThreadId2));&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; timeout &amp;lt;= tonumber(ARGV[&lt;span&gt;4&lt;/span&gt;]) then&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;zrem&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], firstThreadId2);&lt;br/&gt;    redis.call(&lt;span&gt;&#x27;lpop&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  end;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;2&lt;/span&gt;.不存在该锁 &amp;amp;&amp;amp; （不存在线程等待队列 || 存在线程等待队列而且第一个节点就是此线程ID)，加锁部分主要逻辑&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;) and &lt;br/&gt;  ((redis.call(&lt;span&gt;&#x27;exists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;0&lt;/span&gt;)  or (redis.call(&lt;span&gt;&#x27;lindex&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;) == ARGV[&lt;span&gt;2&lt;/span&gt;])) then&lt;br/&gt;  -- 弹出队列中线程id元素，删除Zset中该线程id对应的元素&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;lpop&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;zrem&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;  local keys = redis.call(&lt;span&gt;&#x27;zrange&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  -- 遍历zSet所有key，将key的超时时间(score) - 当前时间ms&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;, #keys, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; &lt;br/&gt;    redis.call(&lt;span&gt;&#x27;zincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], -tonumber(ARGV[&lt;span&gt;3&lt;/span&gt;]), keys[i]);&lt;br/&gt;  end;&lt;br/&gt;    -- 加锁设置锁过期时间&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;hset&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;3&lt;/span&gt;.线程存在，重入判断&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;hexists&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt; then&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;hincrby&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;],&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;pexpire&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;], ARGV[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; nil;&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;4&lt;/span&gt;.返回当前线程剩余存活时间&lt;br/&gt;local timeout = redis.call(&lt;span&gt;&#x27;zscore&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; timeout ~= &lt;span&gt;false&lt;/span&gt; then&lt;br/&gt;  -- 过期时间timeout的值在下方设置，此处的减法算出的依旧是当前线程的ttl&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; timeout - tonumber(ARGV[&lt;span&gt;3&lt;/span&gt;]) - tonumber(ARGV[&lt;span&gt;4&lt;/span&gt;]);&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;5&lt;/span&gt;.尾节点剩余存活时间&lt;br/&gt;local lastThreadId = redis.call(&lt;span&gt;&#x27;lindex&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], -&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;local ttl;&lt;br/&gt;-- 尾节点不空 &amp;amp;&amp;amp; 尾节点非当前线程&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; lastThreadId ~= &lt;span&gt;false&lt;/span&gt; and lastThreadId ~= ARGV[&lt;span&gt;2&lt;/span&gt;] then&lt;br/&gt;  -- 计算队尾节点剩余存活时间&lt;br/&gt;  ttl = tonumber(redis.call(&lt;span&gt;&#x27;zscore&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], lastThreadId)) - tonumber(ARGV[&lt;span&gt;4&lt;/span&gt;]);&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  -- 获取lock_name剩余存活时间&lt;br/&gt;  ttl = redis.call(&lt;span&gt;&#x27;pttl&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;end;&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;6&lt;/span&gt;.末尾排队&lt;br/&gt;-- zSet 超时时间（score），尾节点ttl + 当前时间 + &lt;span&gt;5000&lt;/span&gt;ms + 当前时间，无则新增，有则更新&lt;br/&gt;-- 线程id放入队列尾部排队，无则插入，有则不再插入&lt;br/&gt;local timeout = ttl + tonumber(ARGV[&lt;span&gt;3&lt;/span&gt;]) + tonumber(ARGV[&lt;span&gt;4&lt;/span&gt;]);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;zadd&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;3&lt;/span&gt;], timeout, ARGV[&lt;span&gt;2&lt;/span&gt;]) == &lt;span&gt;1&lt;/span&gt; then&lt;br/&gt;  redis.call(&lt;span&gt;&#x27;rpush&#x27;&lt;/span&gt;, KEYS[&lt;span&gt;2&lt;/span&gt;], ARGV[&lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;end;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; ttl;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.公平锁加锁步骤&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上Lua，可以发现，lua操作的关键结构是列表（list）和有序集合（zSet）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中list维护了一个等待的线程队列&lt;code&gt;redisson_lock_queue:{xxx}&lt;/code&gt;，zSet维护了一个线程超时情况的有序集合&lt;code&gt;redisson_lock_timeout:{xxx}&lt;/code&gt;，尽管lua较长，但是可以拆分为6个步骤&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.队列清理&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.首次加锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.重入判断&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.返回ttl&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5.计算尾节点ttl&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6.末尾排队&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ttl + 2 * currentTime + waitTime&lt;/code&gt;是score的默认值计算公式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.模拟&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果模拟以下顺序，就会明了redisson公平锁整个加锁流程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 &lt;code&gt;t1 10:00:00 &amp;lt; t2 10:00:10 &amp;lt; t3 10:00:20&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;t1：当线程1初次获取锁&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.等待队列无头节点，跳出死循环-&amp;gt;2&lt;/p&gt;&lt;p&gt;2.不存在该锁 &amp;amp;&amp;amp; 不存在线程等待队列 成立&lt;/p&gt;&lt;p&gt;2.1 lpop和zerm、zincrby都是无效操作，只有加锁生效，说明是首次加锁，加锁后返回nil&lt;/p&gt;&lt;p&gt;加锁成功，线程1获取到锁，结束&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;t2：线程2尝试获取锁（线程1未释放锁）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.等待队列无头节点，跳出死循环-&amp;gt;2&lt;/p&gt;&lt;p&gt;2.不存在该锁 不成立-&amp;gt;3&lt;/p&gt;&lt;p&gt;3.非重入线程 -&amp;gt;4&lt;/p&gt;&lt;p&gt;4.score无值 -&amp;gt;5&lt;/p&gt;&lt;p&gt;5.尾节点为空，设置ttl初始值为lock_name的ttl -&amp;gt; 6&lt;/p&gt;&lt;p&gt;6.按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列，线程2为头节点&lt;/p&gt;&lt;p&gt;score = 20S + 5000ms + 10:00:10 + 10:00:10 = 10:00:35 + 10:00:10&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;t3：线程3尝试获取锁（线程1未释放锁）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.等待队列有头节点&lt;/p&gt;&lt;p&gt;1.1未过期-&amp;gt;2&lt;/p&gt;&lt;p&gt;2.不存在该锁不成立-&amp;gt;3&lt;/p&gt;&lt;p&gt;3.非重入线程-&amp;gt;4&lt;/p&gt;&lt;p&gt;4.score无值 -&amp;gt;5&lt;/p&gt;&lt;p&gt;5.尾节点不为空 &amp;amp;&amp;amp; 尾节点线程为2，非当前线程&lt;/p&gt;&lt;p&gt;5.1取出之前设置的score，减去当前时间：ttl = score - currentTime -&amp;gt;6&lt;/p&gt;&lt;p&gt;6.按照ttl + waitTime + currentTime + currentTime 来设置zSet超时时间score，并且加入等待队列&lt;/p&gt;&lt;p&gt;score = 10S + 5000ms + 10:00:20 + 10:00:20 = 10:00:35 + 10:00:20&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，三个需要抢夺一把锁的线程，完成了一次排队，在list中排列他们等待线程id，在zSet中存放过期时间（便于排列优先级）。其中返回ttl的线程2客户端、线程3客户端将会一直按一定间隔自旋重复执行该段Lua，尝试加锁，如此一来便和AQS有了异曲同工之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当线程1释放锁之后（这里依旧有通过Pub/Sub发布解锁消息，通知其他线程获取）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10:00:30 线程2尝试获取锁（线程1已释放锁）&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;1.等待队列有头节点，未过期-&amp;gt;2&lt;/p&gt;&lt;p&gt;2.不存在该锁 &amp;amp; 等待队列头节点是当前线程 成立&lt;/p&gt;&lt;p&gt;2.1删除当前线程的队列信息和zSet信息，超时时间为：&lt;/p&gt;&lt;p&gt;线程2 10:00:35 + 10:00:10 - 10:00:30 = 10:00:15&lt;/p&gt;&lt;p&gt;线程3 10:00:35 + 10:00:20 - 10:00:30 = 10:00:25&lt;/p&gt;&lt;p&gt;2.2线程2获取到锁，重新设置过期时间&lt;/p&gt;&lt;p&gt;加锁成功，线程2获取到锁，结束&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排队结构如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3871277617675312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/19cc2hfD2rA9CEavop032BOGjmsaVl4zLBGvibtoRWBodBPSgTM9l854uicKibL5Hoia27yyGfjzhZ7DfX98SB4INw/640?wx_fmt=other&amp;amp;random=0.35807781993817156&quot; data-type=&quot;other&quot; data-w=&quot;2082&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平锁的释放脚本和重入锁类似，多了一步加锁开头的清理过期key的while true逻辑，在此不再展开篇幅描述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上可以看出，Redisson公平锁的玩法类似于延迟队列的玩法，核心都在Redis的List和zSet结构的搭配，但又借鉴了AQS实现，在定时判断头节点上如出一辙（watchDog），保证了锁的竞争公平和互斥。并发场景下，lua脚本里，zSet的score很好地解决了顺序插入的问题，排列好优先级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且为了防止因异常而退出的线程无法清理，每次请求都会判断头节点的过期情况给予清理，最后释放时通过CHANNEL通知订阅线程可以来获取锁，重复一开始的步骤，顺利交接到下一个顺序线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson整体实现分布式加解锁流程的实现稍显复杂，作者Rui Gu对Netty和JUC、Redis研究深入，利用了很多高级特性和语义，值得深入学习，本次介绍也只是单机Redis下锁实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redisson也提供了多机情况下的联锁MultiLock：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#81-可重入锁reentrant-lock&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和官方推荐的红锁RedLock：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://github.com/redisson/redisson/wiki/8.-分布式锁和同步器#84-红锁redlock&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当你真的需要分布式锁时，不妨先来Redisson里找找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-recommend-type=&quot;list-normal&quot; data-recommend-tid=&quot;2&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501257_1&quot; data-recommend-article-time=&quot;1636251616&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/0?wx_fmt=jpeg&amp;amp;amp;random=0.27521905775014543&quot; data-recommend-article-title=&quot;强势开源一款小程序！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强势开源一款小程序！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-11-07&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501242_1&quot; data-recommend-article-time=&quot;1634952613&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;强力推荐一个完善的物流（WMS）管理项目（附代码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强力推荐一个完善的物流（WMS）管理项目（附代码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-23&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501238_1&quot; data-recommend-article-time=&quot;1634606700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-19&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501208_1&quot; data-recommend-article-time=&quot;1632101100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分享一套家庭理财系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;分享一套家庭理财系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-20&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42407407407407405&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501192_1&quot; data-recommend-article-time=&quot;1630718700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个互联网企业级别的开源支付系统&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个互联网企业级别的开源支付系统&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-04&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501176_1&quot; data-recommend-article-time=&quot;1629509100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一套开源通用后台管理系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一套开源通用后台管理系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-08-21&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501153_1&quot; data-recommend-article-time=&quot;1627704022&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一款神仙接私活儿软件，吊到不行！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一款神仙接私活儿软件，吊到不行！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-31&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501139_1&quot; data-recommend-article-time=&quot;1626571500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;基于 SpringBoot 的仿豆瓣平台【源码分享】&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;基于 SpringBoot 的仿豆瓣平台【源码分享】&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42427884615384615&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501105_1&quot; data-recommend-article-time=&quot;1623979500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;干掉 Wordpress！这个开源建站神器有点吊！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;干掉 Wordpress！这个开源建站神器有点吊！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-06-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42578125&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501098_2&quot; data-recommend-article-time=&quot;1623461160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;从朋友那里搞了 20 个实战项目，速领！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4#rd&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;从朋友那里搞了 20 个实战项目，速领！&lt;/a&gt;&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;2021-06-12&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7X6YPYGQITyP8Zdk96ab7CX0Ind5E05VokoepTP9Adic0xRwiaQrAvfTeC7iafngRibhBShpVqibqNcCCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100018364&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54JM0xl7WLNGnqqwbcXQBWIOCMuOgPHRoOjMamXzrCqMS2xgOo5ibic9icPk7u3zsVgic3s1ZUYJ4xHXg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;19&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2db63b691ae0141504e170bab0516fce</guid>
<title>如何做好分布式任务调度——Scheduler 的一些探索</title>
<link>https://toutiao.io/k/jp5tr8p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&quot; data-nickname=&quot;字节跳动技术团队&quot; data-alias=&quot;BytedanceTechBlog&quot; data-signature=&quot;字节跳动的技术实践分享&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动手点关注 干货不迷路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 👆&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;作者：张宇轩，章逸，曾丹&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初识 Scheduler&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;找准定位：分布式任务调度平台&lt;/h2&gt;&lt;p&gt;&lt;span&gt;无论是互联网应用或者企业级应用，都充斥着大量的任务。我们常常需要一些任务调度系统帮助我们解决问题。随着微服务化架构的逐步演进，单体架构逐渐演变为分布式、微服务架构。在此的背景下，很多原先的单点式任务调度平台已经不能满足业务系统的需求。于是出现了一些基于分布式的任务调度平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheduler 是飞书内的分布式任务调度平台。分布式任务调度能力主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;保证可扩展）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务调度：涉&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;及到任务状态管理、任务调度请求的发送与接收、具体任务的分配、任务的具体执行；（集群中哪些机器什么时候执行什么任务，所以又需要一个可以感知整个集群运行状态的配置中心）；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;配置中心：可以感知整个集群的状态、任务信息的注册。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;摸清脉络：Scheduler的结构和核心模块&lt;/h2&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;&lt;strong&gt;名词解释：&lt;/strong&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Processor: 编程处理器, 拥有一定的编程规范, 用户自定义实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Executor: 一个 SDK，运行 Processor 的进行容器，与 Scheduler 通信的载体。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Job：用户创建的任务，其中包含任务的调度规则、调度模型、执行器名称等信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Instance：运行态的Job，每当Job触发后会生成一个Instance，记录本次执行的调度信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Task：最小执行单元，不同调度模型的任务产生的Task数量不同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.7116071428571429&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4sSGiaIXXWIYibdzfKibuy2boZI1K4gXF8DogCMg32ic7zeia7bu38fwOnEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过架构图可以发现，Scheduler主要有以下三个部分：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;调度器 (Scheduler)：任务调度中心，负责管理任务的生命周期。接受任务注册，准时准确找出待触发的任务，进行任务拆分下发。找出与之关联的执行器并下发对应任务；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;执行器 (Executor)：接收调度任务，并将自身状态上报给调度器；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;控制台 (Web 前端)：负责配置执行器的信息以及调度任务的配置、任务状态、信息展示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;因此，我们可以用一句话解释清楚 Scheduler 所做的事情，即：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在「指定时间」「通知执行器」以「指定方式」执行任务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这句话中包含了三个关键点，也分别代表着 Scheduler 的三个核心模块：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指定时间&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：任务的触发规则，如：每天早上8点、每周二、每月15号等。&lt;strong&gt;触发器模块&lt;/strong&gt;（Launcher Cron）负责任务触发；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指定方式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：任务的执行形式，如：单播任务-指定一个机器执行；广播任务-指定所有机器执行；分片任务-任务分阶段分批的执行。&lt;strong&gt;分派器模块&lt;/strong&gt;（Assignment Cron）负责任务的执行方式；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通知执行器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：将任务发送到指定执行器，执行任务。&lt;strong&gt;派遣器模块&lt;/strong&gt;（Dispatcher Cron）负责任务的发送，采用流式通信，调度器以&lt;strong&gt;推送&lt;/strong&gt;的方式将任务发送给执行器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在一个Job的调度周期中，各个模块各司其职，整个流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.209375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4A59zI8eK454p5icQjusOLRykMWwGiah7PwmDn98liaicicJx6ibYuKWhnzWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;拥有这三个核心模块后，Scheduler 已具备了成熟的任务调度功能。另外，为了增加 Scheduler 的稳定性，有额外两个模块为其保驾护航：&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;健康管理模块&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; (Service Health Cron): 负责管理 Job 的生命周期，检测未正常派发执行的 Job、Instance 和 Task，并将结果上报给运维人员。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;任务进度刷新模块&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; (Task Cron): 异步更新 Task 状态，流量较高时进行削峰，保证依赖的 mysql 及 redis 不因为流量过高而出现问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;本篇文章不对 Scheduler 所支持的定时任务能力作赘述，而是从三个方面（&lt;strong&gt;易用性、多功能性、稳定性&lt;/strong&gt;）介绍 Scheduler 对于分布式任务调度的思考和探索：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「易用性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 决定了用户是否选择使用该框架的意愿，一个好的框架必须是易用且快速接入的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「多功能性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 接入方需求多种多样，要站在用户角度想问题，不能闭门造车；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「稳定性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 对于分布式任务调度平台来说，不仅仅局限于自身的稳定性，接入方的稳定性也十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;换位思考-快速接入&lt;/h1&gt;&lt;h2&gt;背景：效率至上，时间是金&lt;/h2&gt;&lt;p&gt;&lt;span&gt;以字节跳动内部为例，当前团队想要实现一个定时任务有多种方式：接入字节云的 cronjob 平台、自己实现一套定时任务框架或者接入第三方定时任务框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第一种接入 cronjob 平台，每一种定时任务都需要注册各自的 psm 和运行时环境（镜像），当任务需要访问依赖资源如 redis/db 等时，需要各自添加授权。任务代码逻辑有变化时也需要各自升级，导致开发、管理起来较为复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第二种自己实现一套定时任务框架，不仅整体开发时间较长，且需要大量时间进行测试回归来保证框架的稳定性。如果项目内使用到的定时任务较多，那么自身研发一套框架用途也较广泛；若项目中使用到的定时任务较少，则 ROI 较低，很多时候也只是为了造轮子而造轮子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，大多数项目面对增加定时任务的需求时，都会寻求直接接入第三方成熟的定时任务框架。对于他们来说，是否易于接入、与现有代码联系是否紧密、调试是否方便是很重要的选取指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于这种背景，Scheduler 在设计时就站在了接入方的角度，思考了如何让接入方能够在最短时间内以最低成本接入 Scheduler，实现自己的定时任务。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：站在用户角度想问题&lt;/h2&gt;&lt;p&gt;&lt;span&gt;站在接入方角度，对定时任务框架进行选型时最关注的几个点无非是定时任务执行准确性、最高支持 qps、定时设置多样性、接入成本这几个。对于前两个指标，Scheduler 目前接入业务方 50+，日均调度任务 20w+ 次，与公司内其他第三方定时任务框架相比也较有竞争性，同时对于后两个关注点，Scheduler 也有自己的风格。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;丰富的调度设置&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一般的定时任务框架只支持 crontab 表达式，例如 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;0 1 * * *&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; ，代表每天凌晨一点执行一次。cronTab 功能强大，但是若配置复杂的定时策略，有一定学习成本，且可读性不高。因此，鉴于这种情况，Scheduler 在 crontab 之上设计了更易读更强大的定时策略，做到所见即所得。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;startTime&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1648029600000&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;timeZone&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatLevel&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;month&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatInterval&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatDays&quot;&lt;/span&gt;:[&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;23&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;start_time: 开始时间戳，在此之前定时任务不会执行，到达该时间后会执行第一次&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;timeZone: 时区设置，根据当前设置的时区准确派发&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatLevel: 重复级别，目前可以设置按「小时」、「天」、「月」、「周」、「年」以及「工作日」进行重复&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatInterval: 重复间隔，代表每隔 $repertInterval $repeatLevel 执行一次&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatDays: 重复天数，重复级别是周或月时生效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，该设置所代表的定时间隔为：&lt;strong&gt;每两月的3、5、23号触发一次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;table data-ace-table-col-widths=&quot;178&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;strong&gt;触发时间（北京时间）&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-03-23 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-03 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-05 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-23 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;span&gt;为什么要做工作日调度&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;可能有同学注意到，Scheduler 对于重复级别的支持十分丰富，不仅可以按照普通的年、月、日等级别进行设置，还可以按照工作日进行重复调度（例如每两个工作日执行一次），这归因在 Scheduler 孵化于字节跳动内部企业服务系统，为诸如人事系统、权限系统等 ToB 服务提供定时任务能力。往往 ToB 客户的需求复杂多变，因此，需要提前具备更多能力，才能更好地服务好 ToB 客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheduler 在调研接入方需求时，得到了有些客户对于定时提醒这类任务的需求是尽量不要在「非工作日」打扰。于是，Scheduler 决定增加工作日调度选项来适配客户潜在需求，也侧面说明了 Scheduler 为了让接入方更快更小成本接入做出的努力。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;轻松的使用方式&lt;/h2&gt;&lt;p&gt;&lt;span&gt;相信「开箱即用」对于人们在采买诸如家电、数码产品时，是十分重要的一个考核指标。而对于对外提供的服务 or 框架，亦是如此。Scheduler 的目标就是让接入方能够在短时间熟悉 Scheduler、编写测试代码以及上线定时任务。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;专注业务&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;如果想实现一个定时任务，接入方只需要三步：引入 Scheduler sdk，绑定相应 processor，在 process 接口中实现具体业务逻辑。同时，由于定时任务的实现位于原代码中，启动配置无需更改，本地测试也较为便捷。同时，在字节跳动环境下，无需新增 psm、授权配置等，尽可能做到了「开箱即用」。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;code.byted.org/apaas/scheduler_sdk/executor&quot;&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    executorSvc, err := executor.NewExecutor(executor.NewDefaultExecutorConfig(), &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;amp;HelloWorld{}) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err = executorSvc.Run(); err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; HelloWorld &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ProcessorApiName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(h *HelloWorld)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GetApiName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; h.ProcessorApiName&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(h *HelloWorld)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SimpleProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc *executor.TaskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   tc.LogInfo(ctx, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;快速运维&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;没有程序员想主动写出 bug，但问题总是会突然出现。如何在出现问题时快速运维、快速止损，是所有工程师都追求的目标。Scheduler 在这方面做了几种尝试：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;报警更直观&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用户可以在创建 job 时，可以选择配置报警机器人，并把 Scheduler 机器人拉入对应报警群组。当检测到对应 job 出现问题时，Scheduler 机器人会把相应报警推送到对应群组，做到实时响应。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;状态更清晰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前 task 的相关状态如下，当一个 task 长期没有到终态时，根据状态码即可知 task 目前处于什么状&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;态，从而推断是哪一步骤出了问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;状态码&amp;quot;&quot;&gt;状态码&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;状态&amp;quot;&quot;&gt;状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;100&quot;&gt;100&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;等待触发&amp;quot;&quot;&gt;等待触发&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;101&quot;&gt;101&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Ready 就绪态，等待推送&amp;quot;&quot;&gt;Ready 就绪态，等待推送&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;201&quot;&gt;201&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;推送到 Executor，还未实际执行（任务太多排队）&amp;quot;&quot;&gt;推送到 Executor，还未实际执行（任务太多排队）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;202&quot;&gt;202&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行中&amp;quot;&quot;&gt;执行中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;203&quot;&gt;203&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行超时，逻辑复杂导致&amp;quot;&quot;&gt;执行超时，逻辑复杂导致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;301&quot;&gt;301&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行成功&amp;quot;&quot;&gt;执行成功&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;302&quot;&gt;302&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行失败&amp;quot;&quot;&gt;执行失败&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;401&quot;&gt;401&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Ready 超时，没有 Executor 拉取&amp;quot;&quot;&gt;Ready 超时，没有 Executor 拉取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;402&quot;&gt;402&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;推送到 Executor 后长期未执行 &amp;quot;&quot;&gt;推送到 Executor 后长期未执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;403&quot;&gt;403&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行超时，Executor 宕机导致&amp;quot;&quot;&gt;执行超时，Executor 宕机导致&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;并且一些 Scheduler 常见的报错也做了封装，帮助快速定位问题，例如&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;错误码&amp;quot;&quot;&gt;错误码&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;错误原因&amp;quot;&quot;&gt;错误原因&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_000004&amp;quot;&quot;&gt;k_sc_ec_000004&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到任务{{.jobApiName}}&amp;quot;&quot;&gt;找不到任务{{.jobApiName}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_100004&amp;quot;&quot;&gt;k_sc_ec_100004&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到任务实例{{.instanceID}}&amp;quot;&quot;&gt;找不到任务实例{{.instanceID}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_300001&amp;quot;&quot;&gt;k_sc_ec_300001&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Processor Name 未注册{{.content}}&amp;quot;&quot;&gt;Processor Name 未注册{{.content}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_300006&amp;quot;&quot;&gt;k_sc_ec_300006&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;processor({{.content}}) 找不到对应 executor&amp;quot;&quot;&gt;processor({{.content}}) 找不到对应 executor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_400002&amp;quot;&quot;&gt;k_sc_ec_400002&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到Executor {{.content}}&amp;quot;&quot;&gt;找不到Executor {{.content}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_400005&amp;quot;&quot;&gt;k_sc_ec_400005&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;无权限操作&amp;quot;&quot;&gt;无权限操作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h1&gt;并肩作战-分片任务&lt;/h1&gt;&lt;h2&gt;背景：任务越多，挑战越大&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一个成熟的项目中避免不了大型批量任务，比如通过 Excel、csv 或其他数据源批量创建或更新数据，批量任务一般数据量很大，如果按照单实例串行执行，那么不能充分利用计算机资源且一次运行会消费大量时间，用户体验不友好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以 Kunlun 举例， 旧阶段的批量任务依赖于消息队列、Redis 实现，总体分为三大部分：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;解析并校验Excel，将数据解析成一条条数据，将每条消息封装成一条消息发送至消息队列；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消费消息队列，进行创建、更新等操作，并在Redis记录总体进度并推送给用户，如果任务失败，会将行数和错误原因同时记录进redis；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;待所有数据处理结束后，如果redis中没有错误数据，则提示用户成功，否则根据错误信息生成Excel返回给用户。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;271&quot; data-backw=&quot;525&quot; data-ratio=&quot;0.5167394468704513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4Q5AERM5D3txQMnMrMMiasnJJcoeQYK4tE2vdhW3X6z0TvnN6KPEzdaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用消息队列、redis的定时任务可以提速和优化用户体验，但有以下不足：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;维护起来不方便，例如当有新服务需要此类功能时，需要自己再实现一套差不多的框架，所以需要将分片功能托管到第三方服务，而业务方只用专注于具体业务；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;依赖于消息队列和Redis两个外部组件，对两个组件的稳定性要求极高，当其中一个出现问题，都会带来不小的麻烦。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于这种背景，Scheduler 丰富了原本的任务调度能力，补充了分片能力，以满足复杂繁琐的任务分片处理的需求。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：旧问题，新解法&lt;/h2&gt;&lt;p&gt;&lt;span&gt;若打算做出一套贴合业务需求的分片任务框架，需要先了解现阶段的分片任务的实现步骤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现阶段的分片任务大致可以抽象成3个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。获取数据，可以从上传的文件解析数据、从 DB 查询出大批数据或其他数据源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。处理数据，聚焦于具体业务，如：创建、查询、更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。处理结果，将此次任务运行结果处理成结果报告返回给用户，报告可以为 Excel、一条消息、一封邮件等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Scheduler 要做的事情则是替换其中分片、消息队列、Redis 的功能，做出以下抽象：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; ShardingProcessor &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   PreProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ShardingProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Notify(ctx context.Context, tc *TaskContext)error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   PostProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PreProcess(总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：数据准备阶段。可在此方法中对数据进行额外处理，如计算拓扑关系，定义数据优先级。单机运行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ShardingProcess(分)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：分片处理阶段。实际处理函数，多机运行。分片处理函数，执行批量导入、更新等处理。（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;入参：Scheduler 对 PreProcess 返回结果的分片子参数）&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Notify(阶段式-总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：进度更新处理，每当进度变更的大小大于设定阈值，则生成一次 Notify 的Task。Executor 向 Scheduler 汇报子任务进度，Scheduler 计算出总体进度，当总进度发生变更后生成 NotifyTask 通知 Executor 进行处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PostProcess(总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：结果处理阶段。任务执行完毕后可在此函数进行后续处理，单机运行。当所有分片子任务都执行完后，Scheduler 会将子任务的执行结果发送到此函数处理。（&lt;strong&gt;入参：每一个子任务 ShardingProcess 后的结果数组）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;执行器需要实现ShardingProcessor接口以供调度器进行调度。调度过程如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;316&quot; data-backw=&quot;514&quot; data-ratio=&quot;0.614065180102916&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4icUAJ5LBx7RKYjgouRiby19HDMdvS7hV5EZq0SKeHKialepAmHZ64DiaoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Scheduler 支持分片任务重点在于丰富调度模型，提升调度器调度能力，完善执行器执行能力来达到支持分片任务的目的&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;调度侧能力&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;分批调度的能力&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;调度侧需要根据任务进度依次生成 PreTask、ProcessTask、NotifyTask、PostTask 来调度执行器 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ShardingProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 中的 PreProcess - Process - Notify - PostProcess 四个方法。单机调度 PreProcess，PostProcess，Notify，并行调度 PostProcess，总体调度呈现总-分-总的形式。调度过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4NwkHW1Fv8Uy7nvQoLtGWWyqIm1NGQzRIU7HhZoB8sicw5YXiaRThwkBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;数据拆分的能力&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;数据拆分即任务分片，指的是将单一任务按照特定的逻辑切分为多个&lt;strong&gt;独立的&lt;/strong&gt;子任务，将其分派到不同的节点执行，以提高任务的执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而 Scheduler 要处理的任务内部可能存在&lt;strong&gt;依赖关系&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（比如 kunlun 业务中 metadata 批量创建的需求，由于存在 lookup 和 reference 字段等，记录创建之间存在拓扑关系）&lt;/span&gt;&lt;span&gt;，所以在执行时需要&lt;strong&gt;优先级&lt;/strong&gt;的概念，而不能被简单拆分为&lt;strong&gt;独立&lt;/strong&gt;的子任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支持带优先级的任务分片，Scheduler 接收的分片任务的数据特点如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二维数组可以是下面这样：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;，可以是主键&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;101&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;，可以是SQL语句&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Insert into tablename xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;，可以是结构体等等...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;ID&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;999&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第二优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;、&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;、...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;102&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;103&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;了解了待分片任务的结构，我们来讨论如何对任务进行分片。比如，分片的数量由什么决定，单个分片上的信息是如何分配的，不同分片又是不同分派到不同的处理器上的...&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片数的确定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片数的确定基于以下参数的值：&lt;strong&gt;数据量&lt;/strong&gt;、任务创建时用户指定的&lt;strong&gt;单片最大数量、单片最小数量&lt;/strong&gt;，以及实际可用的&lt;strong&gt;执行器数量&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片特征值（sharding key）的选择要遵循的原则应该是&lt;strong&gt;基于最常用的访问方式&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于 Scheduler 分片时并不关心业务数据的结构，所以选用&lt;strong&gt;数据数组的下标&lt;/strong&gt;来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作为分片特征值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于分片数量确定后，不涉及到由于分片的增加或减少对数据进行 Rehash 的情况，所以无需考虑虚拟节点、一致性哈希等方式进行分片。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这里选用哈希分片的分片算法，原因是既可以均匀分布数据，实现起来也很简单。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片的存储和派发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片完成后，需要给每个分片创建一个 Task，并把分片的数据存储下来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;关于 Task 的派发，根据上面关于分片数的讨论，可以得到分片数和 Executor 数的关系：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在数据量合适的情况下（单片最大数量和单片最小数量设置合理时，是最普遍的情况），分片数和Executor 的数目是一致的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当数据量很小时，会出现分片数小于 Executor 数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当数据量很大时，会出现分片数大于 Executor 数，甚至可能是后者的几倍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;为了让各个 Task / 各个分片 能够均匀派发给各个 Executor，也为了避免某个executor挂掉时，其他Executor 不能均匀分摊挂掉的节点原先承担的分片，需要采用合理的分片策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分片时，我们保证了各分片的数据是尽量均匀分布的，所以从分片到 Executor 的分派方式可以尽可能地简单，采用平均分配的策略即可。对于挂掉的节点所承担的分片，也采用同样的策略派发到存活的 Executors 上即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;有3个 Executor，分成9片，则每个 Executor 分到的分片是: &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1=[0,1,2], 2=[3,4,5], 3=[6,7,8]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果Executor 1挂掉，则将1的分片&lt;em&gt;平均分配*&lt;/em&gt; 到Executor 2、3: &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2=[0,1,3,4,5], 3=[2,6,7,8]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;&lt;strong&gt;平均分配*&lt;/strong&gt;：对于不能均分的情况，为了避免靠前的 Executor 总是承担更多的压力，可以根据待分配分片数量的奇偶来决定是升序分派还是降序分派。&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;进度通知的能力&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Scheduler 支持通知 Executor 任务执行的整体进度&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Executor 上报子任务进度至 Scheduler；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Scheduler 计算总任务进度；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总任务进度发生变化，则生成 NotifyTask 发送至 Executor。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3936651583710407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4n9hTBcxHUJMR06QpDiaiaQQIbAeyB2zKuJ8Zk6m0Qd8K1iavp4Fibf27rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/section&gt;&lt;h2&gt;执行侧分批执行的能力&lt;/h2&gt;&lt;p&gt;&lt;span&gt;执行侧需要实现并注册 SDK 提供的ShardingProcessor接口，来处理由调度侧发来的多种类型的Task。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PreProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预处理方法，可以进行但不限于以下的操作：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;启动参数不符合 Scheduler 规定格式，可以通过 PreProcess 方法进行一次转换；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据存在导入优先级，可以在 PreProcess 中编写计算拓扑关系的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;如果不需要预处理，可直接在方法内 return，分片时数据使用启动时的 Data&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;s&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ShardingProcessor&lt;/span&gt;) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PreProcess&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Context&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tc&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;taskContext&lt;/span&gt;) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;error&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;oldData &lt;/span&gt;:= tc.&lt;span class=&quot;code-snippet__built_in&quot;&gt;GetData&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 用户业务, 数据处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    newData := &lt;span class=&quot;code-snippet__built_in&quot;&gt;Transform&lt;/span&gt;(oldData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 返回带拓扑排序的数据&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tc.&lt;span class=&quot;code-snippet__built_in&quot;&gt;SetResult&lt;/span&gt;(newData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return nil&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ShardingProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分片处理函数，主要是进行数据更新、创建操作。ShardingProcess 的入参是切分后的数组（&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;[]interface{}&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）。Executor 需要对参数进行两部分额外处理：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;将 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;[]interface{} &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;interface{} &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;断言成具体 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;struct{}&lt;/strong&gt;&lt;span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;处理后。计算当前子任务执行进度，进行上报；如果省略上报，服务端以分片粒度生成 NotifyTask通知执行器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *ShardingProcessor)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ShardingProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc taskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   taskData := tc.GetData()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, data := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; taskData{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   tc.SetResult(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PostProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接受所有分片处理结果，进行后续处理，如生成错误文件。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *ShardingProcessor)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PostProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc taskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    taskData := tc.GetData()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, result := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; taskData{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tc.SetResult(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Notify&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提供给子任务上报的能力，Scheduler 会根据所有子任务上报结果计算进度，通知 Executor，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;通知粒度为数据条数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。如果接入方不主动上报子任务进度，Scheduler 会根据子任务完成度进行通知，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;通知粒度为分片粒度&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分片任务流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2342342342342343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4crI1FmJdqIhxe9Dod49EtUH6R3mJibzaJ9vaGYmZ5b8T2Tl7Ycz6oKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot;/&gt;&lt;/p&gt;&lt;h1&gt;削峰填谷-流量控制&lt;/h1&gt;&lt;h2&gt;背景：提供能力，而非施加压力&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在 Scheduler 设计初期时，更多的是把注意力放在了如何能够快速、准确、低延迟的触发任务，为此还多次优化了触发器、分派器、派遣器三大模块的轮询逻辑，但是忽略了任务量过大时下游能否抗住流量的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 Scheduler 在调度时无法准确感知下游压力，那么很容易将下游打挂，如：在定时任务首次上线时，因为 kunlun 的装包机制导致数千个应用下配置了同样的定时任务，虽然一个包内的数十个定时任务触发时间分散，但是应用包之间的同一个任务触发时间相同，导致下游需要在同一时刻处理数千个任务，再加上任务的处理流程还会通过消息中间件进行扩散，导致数据库在任务执行阶段一直处理低IDLE 阶段。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：流量追踪，剥茧抽丝&lt;/h2&gt;&lt;section&gt;&lt;span&gt;目前大部分后端服务，通过分析任务的流量走向，可以大致确认每一条任务在执行过程中不论扩散还是非扩散流量都会走向DB，流量图大致如图。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24676850763807284&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv44TBZibG6RLeqgp1jF1u85r9gq99LEKlibxVxticyD0xX7MQtPJABx4NvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;851&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任务的流量最终打到了 DB，所以流量控制的目标就更加清晰：对 DB 的流量控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要对 DB 进行流量控制，那么就要设定合理的指标，理论上，只要指标采纳的足够合理，就能严格、准确的控制流量，指标则需要具备以下条件：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实时性。能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;准时&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;反应数据库健康状况；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;权威性。能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;准确&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;反应数据库健康状况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;优先级：实时性 &amp;gt; 权威性。当一个指标的实时性不够高，那么它的权威性就不再有价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只需要实时监听着 DB 的指标，来判断任务是立刻执行，还是延迟执行就能有效的保护 DB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标选择&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消费 metrics 的监控点，关于数据库的打点信息非常全面，能够非常轻易的获取到数据库宿主机的CPU、内存或数据库本身的连接数、查询数等指标，这些指标的权威性毋庸置疑，但是 metrics 通过将指标收集到本地代理，代理每 30s 做一次聚合发送至服务端，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;其时效性太差&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据库不可用因素为：大量任务触发 -&amp;gt; DB 访问流量增高 -&amp;gt; CPU idle 降低 -&amp;gt; 数据库不可用。造成 CPU idle 降低的因素为 DB 流量增高，可以将 DB 的流量作为指标进行流量控制，缺点是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;需要自己采集指标&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;指标收集&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;指标范围&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;反映 DB 压力较为直接的指标是 cpu idle，但考虑到服务部署往往多实例以及 cpu idle 采集难度大的情况，以近似指标来代替。另一方面，通过历史数据分析，DB 流量与 cpu idle 有一定的关联，因此以 DB 流量作为 DB 压力指标。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1286&quot; data-ratio=&quot;0.7485448195576252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4icDib3SOiaLpgJanDcpEFWuGosmEoCcQI0ib4IqibeL09iaq0spcnIY4l1ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot; data-width=&quot;1718&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据存储&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;参考限流的实现方案，采用单独的 Redis 存储流量数据，以 1s 为时间窗口作为 Redis key，每个时间窗口的流量作为 Redis value，每次发生 DB 操作时更新流量数据。系统中存在多个 DB，每个 DB 单独统计，在 Redis key 中加入db信息。Redis key 设置10s过期时间，查询时根据过去3个窗口的加权平均（80%/15%/5%）作为当前流量，以处理窗口交界处的突发流量。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;收集方式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;目前 DB 流量已有 metrics 监控数据，但由于 metrics 会在本地聚合 30s 数据后上报，至少会有 30s的延迟。而造成 DB 压力大的定时任务多为短期集中触发，使用 metrics 数据会有感知不及时的问题，因此需要额外收集数据。参考 DB metrics 数据采集的方式，通过 Gorm 的 callback 机制插入具体的采集逻辑，减少对业务代码的侵入。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SetMonitorCallBack&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(db *gorm.DB)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   db.Callback().Create().Before(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gorm:before_create&quot;&lt;/span&gt;).Register(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric:before_create&quot;&lt;/span&gt;, beforeCreateCallback)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   db.Callback().Delete().Before(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gorm:before_delete&quot;&lt;/span&gt;).Register(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric:before_delete&quot;&lt;/span&gt;, beforeDeleteCallback)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCreateCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    beforeCallback(scope, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;create&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope, method &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在采集逻辑上，需要考虑以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MetricType &lt;span class=&quot;code-snippet__keyword&quot;&gt;int8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  QueryCount MetricType = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; DBMetric &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DBName   &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DBMethod &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Type MetricType&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timestamp &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value     &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope, method &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dbName := getStringValueFromCtx(scope.DB().Ctx, CtxVariableDBName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    curMs := time.Now().UnixNano()/&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(time.Millisecond)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    metric := DBMetric{dbName, method, QueryCount, curMs, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; ch &amp;lt;- metric:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;metricAgent&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    windowSize := &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    aggrMetrics := &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]DBMetric&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer := time.NewTicker(windowSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       timer.Stop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; msg := &amp;lt;-ch:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           curWindow := curMs/windowSize&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           更新aggrMetrics中curWindow对应的metric（对queryCount来说是加&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-timer.C:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           将aggrMetrics中key+windowSize&amp;lt;=curTime的数据上报并清除&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运维成本：采集逻辑会运行在各个服务上，考虑到后续会收集更多的指标，直接上报 Redis 需要给各个服务开通读写权限，运维管理成本较高。基于此，使用额外的服务来管理指标数据，接收上报的指标数据存入 Redis，并通过接口的方式提供查询服务。指标存放在更加聚焦在DB资源的resource 服务中，在 resource 服务中通过增加接口的方式实现指标数据的管理功能，同时，为了不影响 resource 原有业务的稳定性，使用单独的集群提供服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8130563798219584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4kOfmWjv1vpJJGG03BYUjTNV1U1zU6feGtalm5Wp1mNa3oEQs2fvkvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-meta-block-props=&quot;{&amp;quot;blockType&amp;quot;:&amp;quot;DIAGRAM_BLOCK&amp;quot;,&amp;quot;initData&amp;quot;:&amp;quot;%7B%22data%22%3A%7B%22mxCellList%22%3A%5B%22Xfazc13W%22%2C%22Pect1uf9%22%2C%22IzcPPDCM%22%2C%22dKVFLhD7%22%2C%22y9MiJU2P%22%2C%221UWkGJ8U%22%2C%22cZiSN9SC%22%2C%221xAmiJGI%22%2C%22BqbtgSQN%22%2C%22saeOpCAs%22%2C%22AqV2vvLC%22%2C%22IwQZXnox%22%2C%22G11qs1VY%22%2C%22euPp4iCQ%22%2C%22Wq3ezNTp%22%2C%22oKbWjFpV%22%2C%22tkfJr3ne%22%2C%22h9QvUkVa%22%2C%22Oi2BPCn8%22%2C%22o31bDaCF%22%2C%225Ipy4vFs%22%2C%226tMpMM21%22%2C%22ISZYlo1D%22%2C%22rVZr7hBi%22%2C%224ZD4SYXv%22%2C%22cqRlqkVT%22%2C%22oiLT6GWI%22%2C%22oMOyPYSk%22%2C%22rCj21opl%22%2C%2287jAkrS5%22%2C%22FpSoaVYM%22%2C%22ROD88lM4%22%2C%22Oj3VFKah%22%2C%22eBKTH4D0%22%2C%22TaG2Gi4M%22%2C%221VuHPxBA%22%2C%22yF8bVHdP%22%2C%22Mo4BlpfR%22%5D%2C%22mxGraphModel%22%3A%7B%22arrows%22%3A%221%22%2C%22connect%22%3A%221%22%2C%22dx%22%3A%22946%22%2C%22dy%22%3A%22549%22%2C%22fold%22%3A%221%22%2C%22grid%22%3A%221%22%2C%22gridSize%22%3A%2210%22%2C%22guides%22%3A%221%22%2C%22page%22%3A%221%22%2C%22pageHeight%22%3A%221169%22%2C%22pageScale%22%3A%221%22%2C%22pageWidth%22%3A%22827%22%2C%22tooltips%22%3A%221%22%7D%2C%22mxCellMap%22%3A%7B%221UWkGJ8U%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22224%22%2C%22y%22%3A%22365%22%7D%2C%22id%22%3A%221UWkGJ8U%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u91C7%u96C6%22%2C%22vertex%22%3A%221%22%7D%2C%221VuHPxBA%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2277%22%2C%22x%22%3A%22531%22%2C%22y%22%3A%22245%22%7D%2C%22id%22%3A%221VuHPxBA%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3Brotation%3D30%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%221xAmiJGI%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22194%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%221xAmiJGI%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%224ZD4SYXv%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22150%22%2C%22width%22%3A%22250%22%2C%22x%22%3A%22373%22%2C%22y%22%3A%2270%22%7D%2C%22id%22%3A%224ZD4SYXv%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%225Ipy4vFs%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22534%22%2C%22y%22%3A%22349%22%7D%2C%22id%22%3A%225Ipy4vFs%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%226tMpMM21%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22634%22%2C%22y%22%3A%22349%22%7D%2C%22id%22%3A%226tMpMM21%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u7BA1%u7406%22%2C%22vertex%22%3A%221%22%7D%2C%2287jAkrS5%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22483%22%2C%22y%22%3A%2279%22%7D%2C%22id%22%3A%2287jAkrS5%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22Scheduler%22%2C%22vertex%22%3A%221%22%7D%2C%22AqV2vvLC%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22204%22%2C%22y%22%3A%22294%22%7D%2C%22id%22%3A%22AqV2vvLC%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22Metadata%22%2C%22vertex%22%3A%221%22%7D%2C%22BqbtgSQN%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22263%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%22BqbtgSQN%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22FpSoaVYM%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22568.75%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22568.25%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22FpSoaVYM%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22G11qs1VY%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22214.5%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22214%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22G11qs1VY%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22ISZYlo1D%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22599%22%2C%22y%22%3A%22314%22%7D%2C%22id%22%3A%22ISZYlo1D%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource%22%2C%22vertex%22%3A%221%22%7D%2C%22IwQZXnox%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22154%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22153.5%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22IwQZXnox%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22IzcPPDCM%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22150%22%2C%22width%22%3A%22250%22%2C%22x%22%3A%2294%22%2C%22y%22%3A%22285%22%7D%2C%22id%22%3A%22IzcPPDCM%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22Mo4BlpfR%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2277%22%2C%22x%22%3A%22416%22%2C%22y%22%3A%22367.5%22%7D%2C%22id%22%3A%22Mo4BlpfR%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u4E0A%u62A5%22%2C%22vertex%22%3A%221%22%7D%2C%22Oi2BPCn8%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22623%22%2C%22y%22%3A%22499%22%7D%2C%22id%22%3A%22Oi2BPCn8%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22redis%22%2C%22vertex%22%3A%221%22%7D%2C%22Oj3VFKah%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22689.25%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22688.75%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22Oj3VFKah%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22Pect1uf9%22%3A%7B%22id%22%3A%22Pect1uf9%22%2C%22parent%22%3A%22Xfazc13W%22%7D%2C%22ROD88lM4%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22629.25%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22628.75%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22ROD88lM4%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22TaG2Gi4M%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2257%22%2C%22x%22%3A%22510%22%2C%22y%22%3A%22260%22%7D%2C%22id%22%3A%22TaG2Gi4M%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3Brotation%3D30%3B%22%2C%22value%22%3A%22%u8DEF%u7531%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%22Wq3ezNTp%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22549%22%7D%2C%22id%22%3A%22Wq3ezNTp%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22Xfazc13W%22%3A%7B%22id%22%3A%22Xfazc13W%22%7D%2C%22cZiSN9SC%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%22cZiSN9SC%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22cqRlqkVT%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22393%22%2C%22y%22%3A%22110%22%7D%2C%22id%22%3A%22cqRlqkVT%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22dKVFLhD7%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22114%22%2C%22y%22%3A%22325%22%7D%2C%22id%22%3A%22dKVFLhD7%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22eBKTH4D0%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22170%22%2C%22y%22%3A%22240%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22220%22%2C%22y%22%3A%22190%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22eBKTH4D0%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22source%22%3A%22IzcPPDCM%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3BexitX%3D1%3BexitY%3D0.5%3BexitDx%3D0%3BexitDy%3D0%3BentryX%3D0%3BentryY%3D0.5%3BentryDx%3D0%3BentryDy%3D0%3B%22%2C%22target%22%3A%22o31bDaCF%22%2C%22value%22%3A%22%22%7D%2C%22euPp4iCQ%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22274.5%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22274%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22euPp4iCQ%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22h9QvUkVa%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%22102%22%2C%22x%22%3A%22592%22%2C%22y%22%3A%22494%22%7D%2C%22id%22%3A%22h9QvUkVa%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dcube%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BboundedLbl%3D1%3BbackgroundOutline%3D1%3BdarkOpacity%3D0.05%3BdarkOpacity2%3D0.1%3BfillColor%3D%23E6E6E6%3Bsize%3D32%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22o31bDaCF%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22524%22%2C%22y%22%3A%22309%22%7D%2C%22id%22%3A%22o31bDaCF%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22oKbWjFpV%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22194%22%2C%22y%22%3A%22549%22%7D%2C%22id%22%3A%22oKbWjFpV%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22oMOyPYSk%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22503%22%2C%22y%22%3A%22150%22%7D%2C%22id%22%3A%22oMOyPYSk%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%22oiLT6GWI%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22403%22%2C%22y%22%3A%22150%22%7D%2C%22id%22%3A%22oiLT6GWI%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%22rCj21opl%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22403%22%2C%22y%22%3A%22120%22%7D%2C%22id%22%3A%22rCj21opl%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource_sdk%22%2C%22vertex%22%3A%221%22%7D%2C%22rVZr7hBi%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22relative%22%3A%221%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22rVZr7hBi%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22source%22%3A%224ZD4SYXv%22%2C%22style%22%3A%22rounded%3D0%3BorthogonalLoop%3D1%3BjettySize%3Dauto%3Bhtml%3D1%3BexitX%3D0.5%3BexitY%3D1%3BexitDx%3D0%3BexitDy%3D0%3BentryX%3D0.5%3BentryY%3D0%3BentryDx%3D0%3BentryDy%3D0%3B%22%2C%22target%22%3A%22o31bDaCF%22%7D%2C%22saeOpCAs%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22335%22%7D%2C%22id%22%3A%22saeOpCAs%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource_sdk%22%2C%22vertex%22%3A%221%22%7D%2C%22tkfJr3ne%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22263%22%2C%22y%22%3A%22550%22%7D%2C%22id%22%3A%22tkfJr3ne%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22y9MiJU2P%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22365%22%7D%2C%22id%22%3A%22y9MiJU2P%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%22yF8bVHdP%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2257%22%2C%22x%22%3A%22423%22%2C%22y%22%3A%22341%22%7D%2C%22id%22%3A%22yF8bVHdP%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22%u8DEF%u7531%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%7D%7D%2C%22diagramType%22%3A%22flowchart%22%2C%22lastEditTime%22%3A0%7D&amp;quot;,&amp;quot;props&amp;quot;:{&amp;quot;diagramType&amp;quot;:&amp;quot;flowchart&amp;quot;,&amp;quot;viewType&amp;quot;:&amp;quot;card&amp;quot;},&amp;quot;blockId&amp;quot;:&amp;quot;d70932ee-7e6d-403a-bfcb-1563dab93403&amp;quot;}&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Scheduler 调度反馈&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;流量阈值限制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Scheduler 调度速率与 DB 负载之间的关系较为复杂，本期采用简单的阈值反馈机制，设置 DB 流量阈值，当流量超出阈值时，停止 Scheduler 当前周期调度。根据历史数据，设置阈值为5K。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当流量未超出阈值时，不能预估任务对 DB 流量的影响，采用简单策略对任务数进行限制：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;任务数 = max(（DB流量阈值 - DB当前流量）* 100 / DB 流量阈值, 0)&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;DB路由&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;目前 Kunlun 的 DB 资源根据租户进行分配，不同租户的数据和流量会落在不同的 DB 上。Scheduler会记录 Job 所处租户，所以在调度时，需要根据租户查找真实的 DB 资源，通过 DB 指标的健康状况来决定是否派遣任务：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;调度控制流程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.620253164556962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4urevd2cYIubSziaicP3CGWqJEzmwEGRQhKwRvZZia43mcr5xWwBLhBJEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-alias=&quot;BytedanceTechBlog&quot; data-from=&quot;2&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&amp;amp;wx_head=1&quot; data-nickname=&quot;字节跳动技术团队&quot; data-signature=&quot;字节跳动的技术实践分享&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;1&quot; data-origin_num=&quot;223&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9785dc5aa1ca1c26f2d5d29dfd23f9de</guid>
<title>Spring Boot 实现跨域的 5 种方式，总有一种适合你，建议收藏</title>
<link>https://toutiao.io/k/v14ga1m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、为什么会出现跨域问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、什么是跨域&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2613065326633166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/R3InYSAIZkFRZvaxxgibNH55YbguENmRO91HhpLwywywlIcnFyKxpgUhiaQqXian9vB00DGichYzSQHJxOwlmoNllQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;995&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、非同源限制&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法接触非同源网页的 DOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法向非同源地址发送 AJAX 请求&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、java 后端 实现 CORS 跨域请求的方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 CORS的跨域请求，主要有以下几种方式可供选择：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;返回新的CorsFilter&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重写 WebMvcConfigurer&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用注解 @CrossOrigin&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;手动设置响应头 (HttpServletResponse)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定web filter 实现跨域&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CorFilter / WebMvConfigurer / @CrossOrigin 需要 SpringMVC 4.2以上版本才支持，对应springBoot 1.3版本以上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上面前两种方式属于全局 CORS 配置，后两种属于局部 CORS配置。如果使用了局部跨域是会覆盖全局跨域的规则，所以可以通过 @CrossOrigin 注解来进行细粒度更高的跨域资源控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其实无论哪种方案，最终目的都是修改响应头，向响应头中添加浏览器所要求的数据，进而实现跨域&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Spring Boot 系列最全教程看这里：&lt;/span&gt;&lt;span&gt;https://blog.didispace.com/spring-boot-learning-2x/&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.返回新的 CorsFilter(全局跨域)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在任意配置类，返回一个 新的 CorsFIlter Bean ，并添加映射路径和具体的CORS配置路径。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;public class GlobalCorsConfig {&lt;br/&gt;    @Bean&lt;br/&gt;    public CorsFilter &lt;span&gt;&lt;span&gt;corsFilter&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        //1. 添加 CORS配置信息&lt;br/&gt;        CorsConfiguration config = new CorsConfiguration();&lt;br/&gt;        //放行哪些原始域&lt;br/&gt;        config.addAllowedOrigin(&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;        //是否发送 Cookie&lt;br/&gt;        config.setAllowCredentials(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        //放行哪些请求方式&lt;br/&gt;        config.addAllowedMethod(&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;        //放行哪些原始请求头部信息&lt;br/&gt;        config.addAllowedHeader(&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;        //暴露哪些头部信息&lt;br/&gt;        config.addExposedHeader(&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;        //2. 添加映射路径&lt;br/&gt;        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();&lt;br/&gt;        corsConfigurationSource.registerCorsConfiguration(&lt;span&gt;&quot;/**&quot;&lt;/span&gt;,config);&lt;br/&gt;        //3. 返回新的CorsFilter&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; new CorsFilter(corsConfigurationSource);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 重写 WebMvcConfigurer(全局跨域)&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Configuration&lt;br/&gt;public class CorsConfig implements WebMvcConfigurer {&lt;br/&gt;    @Override&lt;br/&gt;    public void addCorsMappings(CorsRegistry registry) {&lt;br/&gt;        registry.addMapping(&lt;span&gt;&quot;/**&quot;&lt;/span&gt;)&lt;br/&gt;                //是否发送Cookie&lt;br/&gt;                .allowCredentials(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;                //放行哪些原始域&lt;br/&gt;                .allowedOrigins(&lt;span&gt;&quot;*&quot;&lt;/span&gt;)&lt;br/&gt;                .allowedMethods(new String[]{&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;POST&quot;&lt;/span&gt;, &lt;span&gt;&quot;PUT&quot;&lt;/span&gt;, &lt;span&gt;&quot;DELETE&quot;&lt;/span&gt;})&lt;br/&gt;                .allowedHeaders(&lt;span&gt;&quot;*&quot;&lt;/span&gt;)&lt;br/&gt;                .exposedHeaders(&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 使用注解 (局部跨域)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在控制器(类上)上使用注解 @CrossOrigin:，表示该类的所有方法允许跨域。Spring Boot 系列最全教程看这里：https://blog.didispace.com/spring-boot-learning-2x/&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@CrossOrigin&lt;/span&gt;(origins = &lt;span&gt;&quot;*&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在方法上使用注解 &lt;code&gt;@CrossOrigin&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@CrossOrigin&lt;/span&gt;(origins = &lt;span&gt;&quot;*&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;//@CrossOrigin(value = &quot;http://localhost:8081&quot;) //指定具体ip允许跨域&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello world&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 手动设置响应头(局部跨域)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 HttpServletResponse 对象添加响应头(Access-Control-Allow-Origin)来授权原始域，这里 Origin的值也可以设置为 “*”,表示全部放行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RequestMapping(&lt;span&gt;&quot;/index&quot;&lt;/span&gt;)&lt;br/&gt;public String index(HttpServletResponse response) {&lt;br/&gt;    response.addHeader(&lt;span&gt;&quot;Access-Allow-Control-Origin&quot;&lt;/span&gt;,&lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;index&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 使用自定义filter实现跨域&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先编写一个过滤器，可以起名字为：&lt;code&gt;MyCorsFilter.java&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.mesnac.aop;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.io.IOException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.Filter;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.FilterChain;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.FilterConfig;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.ServletException;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.ServletRequest;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.ServletResponse;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; javax.servlet.http.HttpServletResponse;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; org.springframework.stereotype.Component;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyCorsFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest req, ServletResponse res, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;    HttpServletResponse response = (HttpServletResponse) res;&lt;br/&gt;    response.setHeader(&lt;span&gt;&quot;Access-Control-Allow-Origin&quot;&lt;/span&gt;, &lt;span&gt;&quot;*&quot;&lt;/span&gt;);&lt;br/&gt;    response.setHeader(&lt;span&gt;&quot;Access-Control-Allow-Methods&quot;&lt;/span&gt;, &lt;span&gt;&quot;POST, GET, OPTIONS, DELETE&quot;&lt;/span&gt;);&lt;br/&gt;    response.setHeader(&lt;span&gt;&quot;Access-Control-Max-Age&quot;&lt;/span&gt;, &lt;span&gt;&quot;3600&quot;&lt;/span&gt;);&lt;br/&gt;    response.setHeader(&lt;span&gt;&quot;Access-Control-Allow-Headers&quot;&lt;/span&gt;, &lt;span&gt;&quot;x-requested-with,content-type&quot;&lt;/span&gt;);&lt;br/&gt;    chain.doFilter(req, res);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在web.xml中配置这个过滤器，使其生效&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;!-- 跨域访问 START--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;CorsFilter&lt;span&gt;&amp;lt;/&lt;span&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;filter-class&lt;/span&gt;&amp;gt;&lt;/span&gt;com.mesnac.aop.MyCorsFilter&lt;span&gt;&amp;lt;/&lt;span&gt;filter-class&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;filter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;filter-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;CorsFilter&lt;span&gt;&amp;lt;/&lt;span&gt;filter-name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;span&gt;url-pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;filter-mapping&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!-- 跨域访问 END  --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都学会了吧？建议收藏备用！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>