<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ecb43153d72b040e13cb05153d562862</guid>
<title>解密负载均衡技术和负载均衡算法</title>
<link>https://toutiao.io/k/q1jz8l3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;什么是负载均衡技术&lt;/h1&gt;

&lt;p&gt;负载均衡器是一种软件或硬件设备，它起到了将网络流量分散到一组服务器的作用，可以防止任何一台服务器过载。负载均衡算法就是负载均衡器用来在服务器之间分配网络流量的逻辑（算法是一组预定义的规则），有时候也叫做负载均衡的类型。负载均衡算法的种类非常多，包括从简单的轮询负载均衡算法到基于响应状态信息的自适应负载均衡算法。&lt;/p&gt;

&lt;p&gt;负载均衡算法的选择会影响负载分配机制的有效性，从而影响性能和业务连续性（也就是对外承诺的SLA），选择正确的负载均衡算法会对应用程序性能产生重大影响。&lt;/p&gt;

&lt;p&gt;本文将会介绍常见的负载均衡算法，并结合主流负载均衡软件或硬件设备介绍各种负载均衡算法的实现方式&lt;/p&gt;

&lt;h1&gt;常见负载均衡算法介绍&lt;/h1&gt;

&lt;h2&gt;Round Robin（轮询负载均衡算法）&lt;/h2&gt;

&lt;p&gt;在所有负载均衡算法中，轮询负载均衡算法是最简单的、最常用的负载均衡算法。客户端请求以简单的轮换方式分发到应用程序服务器上。例如，假设有三台应用程序服务器：第一个客户端请求发送到第一台应用程序服务器，第二个客户端请求发送到第二台应用程序服务器，第三个客户端请求发送到第三台应用程序服务器，第四个客户端请求重新从第一台应用程序服务器开始，依次往复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-a0add0e56ac21fbad25fa5581ba4e1b2179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;轮询负载均衡适合所有客户端请求都需要相同的服务器负载，并且所有的服务器实例都具有相同的服务器容量和资源（比如网络带宽和存储）&lt;/p&gt;

&lt;h2&gt;Weighted Round Robin（加权轮询负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权负载均衡算法与轮询算法相似，增加了根据每个服务器的相对容量来将请求分散到不同服务器的能力。它适合将传入的客户端请求分散到一组具有不同功能或具有不同负载容量的服务器上。服务器集群管理员根据一个标准为每个应用程序服务器分配一个权重，这个标准表示每个服务器对请求的相对处理能力。&lt;/p&gt;

&lt;p&gt;例如，如果在其他资源都是无穷多的情况下，假如服务器#1的CPU核心数是服务器#2和服务器#3的CPU核心数的二倍，那么服务器#1的权重更高，而服务器#2和#3的权重相同（都比#1低）。如果我们有4个连续的客户端请求，那么有2次请求发送到#1，另外2次请求分别发送到#2和#3。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;加权轮询负载均衡算法描述的是在一段时间内负载的分布情况，不同的加权轮询负载均衡算法可能会产生不同的选择序列，不应该对处理下一次负载的服务器进行假设。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-40da0d3935acbb384b0f9c827ac0842ec6e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;Least Connections（最少连接负载均衡算法）&lt;/h2&gt;

&lt;p&gt;最少连接负载均衡算法又叫做最少等待请求算法（Least Outstanding Request, LOR）。最少连接负载均衡是一种动态负载均衡算法，客户端请求被分发到在接收到请求时活动连接数最少的应用服务器。在应用服务器具有类似规格的情况下，一台服务器可能会因为连接数过多而过载（无法接收请求也属于过载），这个算法考虑了活动连接负载。这种技术适合具有不同连接时间的传入请求（多机房）以及一组在处理能力和可用资源方面相对相似的服务器。&lt;/p&gt;

&lt;h2&gt;Weighted Least Connections（加权最少连接负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权最少连接建立在最少连接负载均衡算法上，考虑不同的应用程序服务器特性。与加权轮询负载均衡算法相同，服务器集群管理员根据一个标准为每个应用程序服务器分配一个权重，这个标准表示每个服务器对请求的相对处理能力。负载均衡器根据活动链接和分配的服务器权重做出负载平衡决策（例如，使用连接数乘以权重的倒数，选择值最高的服务器）。&lt;/p&gt;

&lt;h2&gt;Resource Based（基于资源的负载均衡算法）&lt;/h2&gt;

&lt;p&gt;基于资源的负载均衡算法又叫做自适应负载均衡算法。基于资源的负载均衡算法根据后端服务器提供的状态指标来做出决策。这个状态指标可以由一个运行在服务器上的自定义应用程序（比如agent），或从基础设施提供方的开放接口获取。负载均衡器定期查询每台服务器的状态指标，然后适当地调整服务器的动态权重。&lt;/p&gt;

&lt;p&gt;在这种方式下，负载均衡算法实际上是在每台真实服务器上执行健康检查。这个算法适用于任何需要来自每台服务器的详细健康检查信息来做出负载均衡决策的情况。&lt;/p&gt;

&lt;p&gt;例如：此算法适用于工作负载多变且需要详细的应用程序性能和状态来评估服务器运行状态的任何应用程序（例如CPU密集型的最短路径计算，或其他高性能计算场景）。&lt;/p&gt;

&lt;h2&gt;Fixed Weighting（固定权重负载均衡算法）&lt;/h2&gt;

&lt;p&gt;固定权重负载均衡算法允许服务器集群管理员根据他们的标准为每个应用程序服务器分配一个权重，以表示每个服务器的相对流量处理能力。权重最高的应用服务器将接收所有流量。如果权重最高的应用服务器出现故障，所有流量将会被引导到下一个权重最高的应用服务器。此方法适用于单个服务器能够处理所有预期传入请求的工作负载，如果当前活动的服务器发生故障，一个或多个“热备用”服务器可以直接用于承担负载。&lt;/p&gt;

&lt;h2&gt;Weighted Response Time（加权响应&lt;strong&gt;时间&lt;/strong&gt;负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权响应时间负载均衡算法使用应用程序的响应时间来计算服务器权重。响应速度最快的应用程序服务器接收下一个请求。此方法适用于应用程序响应时间是最重要的问题的场景。&lt;/p&gt;

&lt;p&gt;当应用程序提供的是对外开放服务时尤为重要，因为对外开放服务都会为合作伙伴提供服务级别协议（Service Level Argument，SLA），而SLA中承诺的主要就是服务的可用性与服务的响应时间（TP99、TP999等）。&lt;/p&gt;

&lt;h2&gt;Source IP Hash（源地址哈希负载均衡算法）&lt;/h2&gt;

&lt;p&gt;源地址哈希负载均衡算法使用客户端请求的源IP与目标IP地址生成唯一的哈希密钥，用于将客户端请求分配给特定的服务器。如果传输层会话中断，可以重新密钥，因此客户端请求将会被定向到它之前使用的统一服务器。当客户端对于每个连续连接始终返回到同一服务器至关重要时，此方法最适用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;服务端研发经常接触的数据库事务就适用于此场景&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Consistent Hash（一致性哈希负载均衡算法）&lt;/h2&gt;

&lt;p&gt;一致性哈希负载均衡算法类似于源地址哈希，不同在于一致性哈希负载均衡算法可以使用任意应用参数组成唯一的哈希密钥，并且当服务器集群发生变化时可以尽可能少地进行数据迁移。&lt;/p&gt;

&lt;h1&gt;常见负载均衡算法实现&lt;/h1&gt;

&lt;p&gt;本节将会介绍各种常见负载均衡算法的实现方式，某些负载均衡算法具有多种不同的实现方式，并且每种实现方式都有各自适用的场景，这些不同的实现方式也会在本节进行介绍。同时本节中会假设所有的请求都是线性的，不会处理并发安全相关的细节。&lt;/p&gt;

&lt;h2&gt;Round Robin（轮询负载均衡算法）&lt;/h2&gt;

&lt;p&gt;在所有负载均衡算法中，轮询负载均衡算法实现起来最简单，只需要一个变量表示当前位置并不断增加即可。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class RoundRobinLoadBalancer {

    private final List instances;

    private int position;

    public RoundRobinLoadBalancer(List instances) {
        this.instances = instances;
        this.position = ThreadLocalRandom.current().nextInt(instances.size());
    }

    public ServiceInstance peek(HttpServletRequest request) {
        int peeked = (position++) &amp;amp; Integer.MAX_VALUE;
        return instances.get(peeked % instances.size());
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有两个需要注意的点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当我们初始化位置时，需要将其设置为一个随机值，避免多个负载均衡器同时请求同一个服务器，造成服务器的瞬时压力&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在位置自增时，需要忽略符号位，因为Java没有无符号整数，所以当位置的值超出整型最大值时会变成负值导致抛出异常。至于为什么不能使用绝对值，是因为整型的最小值没有对应的绝对值，得到的依旧是负值(&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/issues/1074&quot;&gt;Spring Cloud #1074&lt;/a&gt;)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Weighted Round Robin（加权轮询负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权轮询负载均衡算法有很多主流的实现，并且各自都有各自的优点。虽然加权负载均衡产生任意符合全总分配比例分布的选择序列都是合适的，但在短时间窗口内是否能够选择尽可能多的节点提供服务仍是评价加权负载均衡实现的质量的关键指标。&lt;/p&gt;

&lt;h3&gt;数组展开方式&lt;/h3&gt;

&lt;p&gt;数组展开实现方式是一种适用空间换时间的策略，适用于较小的服务器集群或专用型负载均衡设备。它的优点是速度非常快，与Round Robin实现完全一致。它的缺点也很明显，当权重的总和很大时会带来很大的内存开销&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class WeightedLoadBalancer {

    private final List instances;

    private int position;

    public WeightedLoadBalancer(List instances) {
        this.instances = expandByWeight(instances);
    }

    public ServiceInstance peek(HttpServletRequest request) {
        int peeked = (position++) &amp;amp; Integer.MAX_VALUE;
        return instances.get(peeked % instances.size());
    }

    private List expandByWeight(List instances) {
        List newInstances = new ArrayList&amp;lt;&amp;gt;();

        for (ServiceInstance instance : instances) {
            int bound = instance.getWeight();
            for (int w = 0; weight &amp;lt; bound; weight++) {
                newInstances.add(instance);
            }
        }

        Collections.shuffle(newInstances);
        return newInstances;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有三个需要注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当实例按权重展开成数组的时候，可能会出现实例权重都很大，但是它们的最大公约数不为1，这个时候可以使用最大公约数来减少展开后的数组大小。因为最大公约数的诸多限制，例如任意自然数N与N+1互质，任意自然数N与1互质，所以很容易出现优化失败的情况，因此本示例并未给出，感兴趣的可以去看Spring Cloud相关PR（&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/pull/1140&quot;&gt;Spring Cloud #1140&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在实例按权重展开成数组后，需要对得到的数组进行洗牌，以保证流量尽可能均匀，避免连续请求相同实例（Java中实现的洗牌算法是Fisher-Yates算法，其他语言可以自行实现）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;因为是在构建负载均衡器的时候按权重展开成数组的，所以在负载均衡器构建完成后无法再改变实例的权值，对于频繁动态变更权重的场景不适用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;上界收敛选择方式&lt;/h3&gt;

&lt;p&gt;上界收敛选择方式提前计算出所有权重的最大值，并将初始上界设置为所有权重的最大值，接下来我们一轮一轮地去遍历所有实例，并找到权重大于等于上界的实例。当前轮遍历结束后，所有大于等于上界的元素都被选取到了，接下来开始尝试权重更低的节点，直到最后上界为0时，将其重新置为最大值。目前openresty （有人在&lt;a href=&quot;https://github.com/openresty/lua-resty-balancer/issues/44&quot;&gt;issue #44&lt;/a&gt;上分析了这种算法）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-195caa157af9c2fb09836082e04cd4f869f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-2e073ae19a8afb157c0695d7e1e6dda0efa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-1757431a56835ac32b2d123df22a60ebb2a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class WeightedLoadBalancer {

    private final List instances;

    private final int max;

    private final int gcd;

    private int bound;

    private int position;

    public WeightedLoadBalancer(List instances) {
        this.instances = instances;
        this.max = calculateMaxByWeight(instances);
        this.gcd = calculateGcdByWeight(instances);
        this.position = ThreadLocalRandom.current().nextInt(instances.size());
    }

    public ServiceInstance peek(HttpServletRequest request) {
        if (bound == 0) {
            bound = max;
        }

        while (instances.size() &amp;gt; 0) {
            for (int peeked = position; peeked &amp;lt; instances.size(); peeked++) {
                ServiceInstance instance = instances.get(peeked);
                if (instance.getWeight() &amp;gt;= bound) {
                    position = peeked + 1;
                    return instance;
                }
            }
            position = 0;
            bound = bound - gcd;
        }
        return null;
    }

    private static int calculateMaxByWeight(List instances) {
        int max = 0;
        for (ServiceInstance instance : instances) {
            if (instance.getWeight() &amp;gt; max) {
                max = instance.getWeight();
            }
        }
        return max;
    }

    private static int calculateGcdByWeight(List instances) {
        int gcd = 0;
        for (ServiceInstance instance : instances) {
            gcd = gcd(gcd, instance.getWeight());
        }
        return gcd;
    }

    private static int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有四个需要注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果是短频率请求，将会一直访问高权重实例，导致在短时间窗口内负载看起来并不均匀。这个可以通过改变方向，从下界向上界逼近来解决。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每一轮后降低上界的值可以取所有权重的最大公约数，因为如果每次下降1的话，中间这些轮会反复请求权重最高的那些实例，导致负载不均衡。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;虽然最大公约数可以减少下降次数，但是如果权重相差非常多，并且所有元素都是互质的（n与n+1互质，任意自然数n与1互质，在实践中非常容易出现），那么在上界下降的过程中将会带来很多空转。这个可以参考广度优先遍历的思想，使用先入先出的队列来减少空转。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;与数组展开方式遇到的问题相同，因为是在构建负载均衡器的时候计算最大公约数的值，所以对于频繁动态变更权重的场景依旧会有很大的性能开销，但是相较于数组展开方式可以避免频繁动态分配数组导致的性能与内存碎片问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;权重轮转实现&lt;/h3&gt;

&lt;p&gt;权重轮转算法中将会存储两个权重的值，一个是不会变化的原始权重，一个是会随着每次选择变化的当前权重。权重轮转实现中维护了一个循环不变量——所有节点的当前权重的和为0。每轮遍历过程中所有实例的有效权重都会增加它的原始权重，并选择出当前权重最高的节点。选择出权重最高的节点后将它的当前权重减去所有实例权重的总和，以避免它再次被选择。NGINX中加权轮询负载均衡算法使用此实现（&lt;a href=&quot;https://github.com/nginx/nginx/blob/master/src/http/ngx_http_upstream_round_robin.c#L431&quot;&gt;NGINX&lt;/a&gt;）。这种算法的优势是它很平滑，低权重节点的等待时间较短，并且每轮权重轮转的最小正周期很小，是所有服务器实例权重的和。。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;在NGINX中又叫做平滑加权负载均衡（Smooth Weighted Load Balancing，SWRR）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-11baf0f9d9f6cdeaad30b0b0e050898c285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class WeightedLoadBalancer {

    private final List instances;

    public WeightedLoadBalancer(List instances) {
        this.instances = instances;
    }

    public ServiceInstance peek(HttpServletRequest request) {
        ServiceInstance best = null;
        int total = 0;
        for (ServiceInstance instance : instances) {
            total += instance.getWeight();
            instance.setCurrentWeight(instance.getCurrentWeight() + instance.getWeight());
            if (best == null || instance.getCurrentWeight() &amp;gt; best.getCurrentWeight()) {
                best = instance;
            }
        }
        if (best != null) {
            best.setCurrentWeight(best.getCurrentWeight() - total);
        }
        return best;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有三个需要注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;权重轮转非常适合实例变化频率非常高的集合，因为它不需要提前构建数据结构&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;权重轮转实现的效率与实例数量相关，时间复杂度是O(n)，当集群服务器数量非常大时需要限制每次参与选择的服务器数量（&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/pull/1111&quot;&gt;Spring Cloud #1111&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;权重轮转实现需要修改服务器实例的数据结构，当服务实例是由其他机构提供时无法使用此实现&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;EDF（Earliest Deadline First）实现&lt;/h3&gt;

&lt;p&gt;EDF算法最早被用在CPU调度上，EDF是抢占式单处理器调度的最佳调度算法。EDF实现与权重轮转实现相似，引入了名为deadline的额外变量，可以认为权重越高的服务器实例完成任务的时间越快，那么在假设所有请求的成本相同时，所需要花费的时间是权重的倒数，所以可以很自然地选择可以最早空闲出来提供服务的服务器实例，并将任务分配给它。&lt;/p&gt;

&lt;p&gt;实现EDF算法只需要将每个下游服务器实例与deadline绑定，然后以deadline为优先级维护到优先队列中，并不断取出队首元素，调整它的deadline，并将它重新提交到优先队列中。知名Service Mesh代理envoy使用了此方法实现加权负载均衡（&lt;a href=&quot;https://github.com/envoyproxy/envoy/blob/main/source/common/upstream/edf_scheduler.h&quot;&gt;envoy&lt;/a&gt;），以及蚂蚁开源网络代理mosn中也实现了此方法（&lt;a href=&quot;https://github.com/mosn/mosn/pull/1920&quot;&gt;mosn #1920&lt;/a&gt;）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class WeightedLoadBalancer {

    private final PriorityQueue entries;

    public WeightedLoadBalancer(List instances) {
        this.entries = instances.stream().map(EdfEntry::new).collect(Collectors.toCollection(PriorityQueue::new));
    }

    public ServiceInstance peek(HttpServletRequest request) {
        EdfEntry entry = entries.poll();
        if (entry == null) {
            return null;
        }
        ServiceInstance instance = entry.instance;
        entry.deadline = entry.deadline + 1.0 / instance.getWeight();
        entries.add(entry);
        return instance;
    }

    private static class EdfEntry implements Comparable {

        final ServiceInstance instance;

        double deadline;

        EdfEntry(ServiceInstance instance) {
            this.instance = instance;
            this.deadline = 1.0 / instance.getWeight();
        }

        @Override
        public int compareTo(EdfEntry o) {
            return Double.compare(deadline, o.deadline);
        }
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;EDF每次选择的算法复杂度为O(log(n))，相较于数组展开要慢，但相较于上界收敛选择在最坏情况下以及权重轮转都需要O(n)的时间复杂度来说，其性能表现的非常好，并且对于超大集群，其性能下降不明显。其空间复杂度为O(n)，不会造成很大的内存开销。&lt;/p&gt;

&lt;h2&gt;Least Connections（最少连接负载均衡算法）&lt;/h2&gt;

&lt;h3&gt;遍历比较方式&lt;/h3&gt;

&lt;p&gt;最简单的实现方式，遍历所有实例，并找出当前连接数最少的实例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LeastConnectionLoadBalancer {

    private final List instances;

    public LeastConnectionLoadBalancer(List instances) {
        this.instances = instances;
    }

    public ServiceInstance peek(HttpServletRequest request) {
        ServiceInstance best = null;
        for (ServiceInstance instance : instances) {
            if (best == null || instance.getConnections() &amp;lt; best.getConnections()) {
                best = instance;
            }
        }
        if (best != null) {
            best.setConnections(best.getConnections() + 1);
        }
        return best;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;堆维护方式&lt;/h3&gt;

&lt;p&gt;所有动态有序集合都可以通过优先队列来实现，与EDF算法相同，取出队首的元素，修改它的优先级，并放回队列中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class LeastConnectionLoadBalancer {

    private final PriorityQueue instances;

    public LeastConnectionLoadBalancer(List instances) {
        this.instances = instances.stream().collect(toCollection(
                () -&amp;gt; new PriorityQueue&amp;lt;&amp;gt;(comparingInt(ServiceInstance::getConnections))));
    }

    public ServiceInstance peek(HttpServletRequest request) {
        ServiceInstance best = instances.poll();
        if (best == null) {
            return null;
        }
        best.setConnections(best.getConnections() + 1);
        return best;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Weighted Least Connections（加权最少连接负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权最少连接负载均衡算法的实现方式与最少连接负载均衡算法相同，只是在计算时增加了权重相关的参数&lt;/p&gt;

&lt;h3&gt;遍历比较方式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class LeastConnectionLoadBalancer {

    private final List instances;

    public LeastConnectionLoadBalancer(List instances) {
        this.instances = instances;
    }

    public ServiceInstance peek(HttpServletRequest request) {
        ServiceInstance best = null;
        for (ServiceInstance instance : instances) {
            if (best == null || instance.getConnections() * best.getWeight() &amp;lt; best.getConnections() * instance.getWeight()) {
                best = instance;
            }
        }
        if (best != null) {
            best.setConnections(best.getConnections() + 1);
        }
        return best;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;Tips，在不等式中 a/b &amp;lt; c/d 与 ad &amp;lt; bc等价，并且可以避免除法带来的性能与精度问题&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;堆维护方式&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public class LeastConnectionLoadBalancer {

    private final PriorityQueue instances;

    public LeastConnectionLoadBalancer(List instances) {
        this.instances = instances.stream().collect(toCollection(
                () -&amp;gt; new PriorityQueue&amp;lt;&amp;gt;(comparingDouble(ServiceInstance::getWeightedConnections))));
    }

    public ServiceInstance peek(HttpServletRequest request) {
        ServiceInstance best = instances.poll();
        if (best == null) {
            return null;
        }
        best.setConnections(best.getConnections() + 1);
        best.setWeightedConnections(1.0 * best.getConnections() / best.getWeight());
        return best;
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Weighted Response Time（加权响应&lt;strong&gt;时间&lt;/strong&gt;负载均衡算法）&lt;/h2&gt;

&lt;p&gt;加权响应时间负载均衡算法使用统计学的方法，通过历史的响应时间来得到预测值，使用这个预测值来选择相对更优的服务器实例。得到预测值的方法有很多，包括时间窗口内的平均值、时间窗口内的TP99、历史所有响应时间的指数移动加权平均数（EWMA）等等。其中Linkerd与APISIX使用了EWMA算法（&lt;a href=&quot;https://linkerd.io/2.11/features/load-balancing/#&quot;&gt;Linkerd&lt;/a&gt;和&lt;a href=&quot;https://apisix.apache.org/zh/docs/ingress-controller/concepts/apisix_upstream/&quot;&gt;APISIX&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;通过历史的响应时间来得到预测值这个操作通常是CPU开销很大的，实际使用时可以不用遍历所有元素，而是使用K-临近元素或直接随机选择两个元素进行比较即可，这种启发式方法办法无法保证全局最优但是可以保证不至于全局最差。&lt;/p&gt;

&lt;h2&gt;Source IP Hash（源地址哈希负载均衡算法）&lt;/h2&gt;

&lt;p&gt;源地址哈希负载均衡以任意算法将请求地址映射成整型数，并将这个整型数映射到实例列表的下标&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class IpHashLoadBalancer {

    private final List instances;

    public IpHashLoadBalancer(List instances) {
        this.instances = instances;
    }

    public ServiceInstance peek(HttpServletRequest request) {
        int h = hashCode(request);
        return instances.get(h % instances.size());
    }

    private int hashCode(HttpServletRequest request) {
        String xForwardedFor = request.getHeader(&quot;X-Forwarded-For&quot;);
        if (xForwardedFor != null) {
            return xForwardedFor.hashCode();
        } else {
            return request.getRemoteAddr().hashCode();
        }
    }
}



&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一个需要注意的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 面向公网提供服务的负载均衡器前面可能会经过任意多层反向代理服务器，为了获取到真实的源地址，需要先获取X-Forwarded-For头部，如果该头部不存在再去获取TCP连接的源地址&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;负载均衡技术扩展&lt;/h1&gt;

&lt;h2&gt;服务注册表与发现（Service Registry and Service Discovery）&lt;/h2&gt;

&lt;p&gt;在维护大型服务器集群时，服务器实例随时都有可能被创建或移除，当服务器被创建或移除时，集群管理员需要到各个负载均衡设备上去更新服务器实例列表。&lt;/p&gt;

&lt;p&gt;服务注册表会在内部维护服务对应的服务器实例列表。在服务器实例被创建并成功运行服务后，服务器实例会去服务注册表中注册自身，包括网络地址（IPv4/IPv6）、服务端口号、服务协议（TCP/TLS/HTTP/HTTPS）以及自身提供的服务名称等等，有的服务注册表本身也会提供主动健康检查的能力（如Eureka与Consul）。在服务器实例正常退出时会在服务注册表执行反注册逻辑，这个时候服务注册表就会将这个服务器实例从服务器实例列表中移除。即使服务器实例异常退出导致无法执行反注册逻辑，服务注册表也会通过主动健康检查机制将这个异常的服务器实例从服务器实例列表中移除。&lt;/p&gt;

&lt;p&gt;在拥有服务注册表后，负载均衡设备不需要再手动维护服务器实例列表，而是当请求到来时从服务注册表中拉取对应的服务器实例列表，并在这个服务器实例列表中进行负载均衡。为了提高服务的可用性，负载均衡设备会在本地（内存或本地文件注册表）缓存这些服务器实例列表，以避免由于负载均衡设备与服务注册表无法连接而导致服务不可用。&lt;/p&gt;

&lt;p&gt;缓存及重新获取服务器列表的策略根据不同业务场景有不同的实现，在Spring Cloud Loadbalancer中是通过缓存过期而触发重新获取的逻辑（&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-commons/blob/main/spring-cloud-loadbalancer/src/main/java/org/springframework/cloud/loadbalancer/core/CachingServiceInstanceListSupplier.java&quot;&gt;Spring Cloud&lt;/a&gt;），当服务注册表不可用时，因为负载均衡设备中无可用的服务器备份而导致服务完全不可用；在大部分的负载均衡设备中将缓存获取与更新逻辑改为定时器主动刷新的机制，这样当服务注册表不可用时可以主动决定是否将旧数据标记为过期。尽管本地缓存可以提高服务的可用性，但是要注意负载均衡设备在使用的仍旧是旧的服务提供方列表，当长时间无法获取到新的服务提供方列表时，负载均衡设备应当舍弃旧的服务提供方列表，并将服务不可用的问题暴露出来，通过基础设施提供的监控与告警能力通知集群管理员来进行处理。&lt;/p&gt;

&lt;h2&gt;健康检查（Health Check）&lt;/h2&gt;

&lt;p&gt;健康检查本质是一个预定规则，它向负载均衡器背后的服务器集群中的所有成员发送相同的请求，以确定每个成员服务器是否可以接受客户端请求。&lt;/p&gt;

&lt;p&gt;对于某些类型的健康检查，通过评估来自服务器的响应以及收到服务器响应所需的时间以确定每个成员服务器的运行状态。通常情况下，当成员服务器的状态变为不健康时，负载均衡器应该快速地将其从服务器实例列表中移除，并在成员服务器状态恢复正常时将其重新添加回服务器实例列表中。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对于网络层负载均衡器（也叫做NLB或L4LB），通过建立TCP连接，根据是否能够成功建立连接以及建立连接所需要的时间来确定成员服务器的状态。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对于应用层负载均衡器（也叫做ALB或L7LB），通过发送应用层协议（不只是HTTP协议）定义的用于健康检查的请求报文，并根据响应报文内容以及整个请求从建立连接到完整收到所有响应所花费的时间来确定成员服务器的状态。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;应用负载均衡器没有固定的模式。例如，对于提供HTTP协议服务的应用，可以提供用于健康检查的URL，设置通过健康检查的HTTP状态码（或状态码集），并验证响应报文中用于表示服务器状态的字段（通过JSONPath或XMLPath等提取）是否是预期值等方式来确认成员服务器状态；对于RPC协议，可以提供专门的ping-pong服务，负载均衡器根据RPC协议组装请求报文，并发送ping请求到成员服务器上，并根据成员服务器返回的内容是否为pong响应来确认成员服务器的状态，具体设计可以参考websocket的ping-pong机制（&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc6455#section-5.5&quot;&gt;RFC 6455&lt;/a&gt;）。&lt;/p&gt;

&lt;h2&gt;慢启动（Slow Start）&lt;/h2&gt;

&lt;p&gt;负载均衡器中的慢启动思想来自于TCP的拥塞控制理论，其核心也是为了避免大量请求涌入刚刚启动完成的应用程序，导致大量请求阻塞、超时或异常的情况。 众所周知，Java是半编译半解释型语言，包括Java语言在内，现代解释型语言的解释器都带有即时编译器（Just In Time，JIT），JIT编译器会跟踪每个方法的执行点，对那些热点路径（Hotspot）进行更高效的优化，这也是Hotspot JVM名字的由来。而JIT对热点路径的优化全都来自于自应用程序启动以来的所有方法调用，也就是说应用程序的系统承载能力是随着程序的运行而不断得到强化的，经过JIT优化的Java代码甚至可以得到近似GCC中O3（最高级别）优化的性能。跟多关于JIT编译器的细节可以看Oracle的Java开发者指南（&lt;a href=&quot;https://docs.oracle.com/cd/E11882_01/java.112/e10588/chnine.htm#JJDEV09000&quot;&gt;Java Developer Guide&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;同时，现代应用程序都不可避免的会使用本地缓存，当应用程序刚刚启动时内存中的缓存是空的，随着应用程序的运行，不断地访问外部系统获取数据并将数据写入到内存缓存中，应用程序与外部系统的交互会不断减少，应用程序的系统承载能力也会逐渐达到峰值。&lt;/p&gt;

&lt;p&gt;上面是应用程序在启动后性能不断提升的因素中最常见的，初次之外还有很多的因素。所以为了避免大量请求涌入刚刚启动完成的应用程序的现象发生，负载均衡器会通过慢启动的方式，随着服务器运行不断增加这些服务器实例的权重，最终达到服务器的实际权重，从而达到动态调整分配给这些服务器实例的流量的效果。&lt;/p&gt;

&lt;p&gt;服务器权重变化算法有很多，包括随时间线性增长、随时间对数增长、随时间指数增长、随时间变幂增长、与随时间按Logistic增长等。目前京东服务框架（JSF）实现的是随时间线性增长；envoy实现了随时间变幂增长，并引入了渐进因子来调整变化速率（&lt;a href=&quot;https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/load_balancing/slow_start&quot;&gt;envoy slow start&lt;/a&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.envoyproxy.io/docs/envoy/latest/_images/slow_start_aggression.svg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;总结&lt;/h1&gt;

&lt;p&gt;负载均衡技术是网络代理与网关组件最核心的组成部分，本文简单介绍了什么是负载均衡技术、常见的负载均衡算法以及常见负载均衡算法的实现，并给出了负载均衡技术的扩展，为将来更深入学习网络代理相关技术打下基础。&lt;/p&gt;

&lt;p&gt;因本人才学疏浅经验能力有限，文中难免会有疏忽和遗漏，以及不连贯的地方，欢迎大家与我沟通交流给出建议。&lt;/p&gt;

&lt;p&gt;作者：纪卓志&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b1993a1c1603eabb0a0280ea335a2778</guid>
<title>分布式 ID 生成系统  Leaf 的设计思路，源码解读</title>
<link>https://toutiao.io/k/7onx06i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们好呀，我是 4ye，今天来分享下最近研究的&lt;strong&gt;分布式 ID 生成系统&lt;/strong&gt; —— &lt;strong&gt;Leaf&lt;/strong&gt;  ，一起来思考下这个分布式ID的设计吧 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;229&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.41110065851364064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs4mV1SYwYtRkLmYGlfto0pSG4qibGRZpfdjbTl41w5aicMglbEdID34ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是分布式ID？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ID 最大的特点是 &lt;strong&gt;唯一&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而分布式 ID，就是指分布式系统下的 ID，它是 &lt;strong&gt;全局唯一&lt;/strong&gt; 的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为啥需要分布式ID呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就和 &lt;strong&gt;唯一&lt;/strong&gt; 息息相关了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们用 MySQL 存储数据，一开始数据量不大，但是业务经过一段时间的发展，单表数据每日剧增，最终突破 1000w，2000w ……  系统开始变慢了，此时我们已经尝试了 &lt;strong&gt;优化索引&lt;/strong&gt;， &lt;strong&gt;读写分离&lt;/strong&gt; ，&lt;strong&gt;升级硬件&lt;/strong&gt;，&lt;strong&gt;升级网络&lt;/strong&gt; 等操作，但是 &lt;strong&gt;单表瓶颈&lt;/strong&gt; 还是来了，我们只能去 &lt;strong&gt;分库分表&lt;/strong&gt; 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而问题也随着而来了，分库分表后，如果还用 &lt;strong&gt;数据库自增ID&lt;/strong&gt; 的方式的话，那么在用户表中，就会出现 &lt;strong&gt;两个不同的用户有相同的ID&lt;/strong&gt; 的情况，这个是不能接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 &lt;strong&gt;分布式ID全局唯一&lt;/strong&gt; 的特点，正是我们所需要的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分布式ID的生成方式&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;UUID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库自增ID （MySQL，Redis）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;雪花算法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就上面几种了，UUID 的最大缺点就是太长，36个字符长度，而且无序，不适合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而其他两种的缺点还有办法补救，可能这也是 Leaf 提供这两种生成 ID 方式的原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;项目简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leaf ，分布式 ID 生成系统，有两种生成 ID 的方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;号段模式&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Snowflake模式&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;380&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.6811377245508982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsWBWp7bUuy0icaYiaAiaAVNlnww2ZWg37C945LCRGXGdqWVhap0omFibMcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;号段模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;strong&gt;数据库自增ID&lt;/strong&gt; 的基础上进行优化&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加一个 &lt;strong&gt;segement&lt;/strong&gt; ，减少访问数据库的次数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双 Buffer 优化，提前缓存下一个 Segement，降低网络请求的耗时（降低系统的TP999指标）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2568203198494826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs6iaPMXB9HAiaz6nZhSkUmUnrMOicxrR8Kxu1PLGicrNr2MTkkibzWM7ibLAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;figcaption&gt;来自美团技术团队&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没优化前，每次都从 db 获取，现在获取的频率和 step 字段相关。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08342133051742344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsCodetQO2eeRbgWNiaAo931lwEHAjrwAwOJFas7UUu4ejHxcny0TQYow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双 Buffer 优化思路 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46794871794871795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs6cu1Ro4ARLWCYAJHZDuuRmxsHCk7MWYuszTQXozQ4V2KCcZ2kmEaMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;号段模式源码解读&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7189460476787954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsib56ME3AAB39vOj3MSOcQNDMf1ywVsL1tpBwZyhjkcP6uXRSK14YTOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SegmentService 构造方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作用 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;配置 dataSource&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置 MyBatis&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例化 SegmentIDGenImpl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行 init 方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;311&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.5572374645222328&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsxzTicMDKLPCPN8iaiaMJWhF4p1W7qFj0z1icPibrxuHLPxMK1FxHN7SXHpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1057&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码我也忘了 哈哈，已经多久没直接用 mybatis 了，还是重新去官网翻看的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2828870779976717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsWicfcGic8xIiciajvH2FAlZ2hINZbzU4kwmNCxzBFG1uRVBACIXQ0egweg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;859&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2671957671957672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs18bPcHevsZHEDTqh5DJtxIYrMXVDh3gzHuY6ZicowpuhlwW3m7dzmBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;figcaption&gt;mybatis 官网例子&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例化 SegmentIDGenImpl 时，其中有两个变量要留意下 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SEGMENT_DURATION，&lt;strong&gt;智能调节 step 的关键&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cache ，其中 SegmentBuffer 是双 Buffer 的关键设计。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先不展开，看看 init 方法先。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsvV4lcD1gqFXWklLrzAibJFHicj5rBaEjZNUHJOX2pqXD0yib1nAmFdBPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SegmentIDGenImpl init 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作用 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;执行 updateCacheFromDb 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开后台线程，每分钟执行一次 updateCacheFromDb() 方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4433497536945813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsnUvgWmcvZ5Jw24nAnudUJZuroqawBrrXib7LYt3XOpjlT9pOAzeVkrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1015&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，核心在 &lt;strong&gt;updateCacheFromDb&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;updateCacheFromDb 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就直接看源码和我加的注释&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateCacheFromDb&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        logger.info(&lt;span&gt;&quot;update cache from db&quot;&lt;/span&gt;);&lt;br/&gt;        StopWatch sw = &lt;span&gt;new&lt;/span&gt; Slf4JStopWatch();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 执行 SELECT biz_tag FROM leaf_alloc 语句，获取所有的 业务字段。&lt;/span&gt;&lt;br/&gt;            List&amp;lt;String&amp;gt; dbTags = dao.getAllTags();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (dbTags == &lt;span&gt;null&lt;/span&gt; || dbTags.isEmpty()) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 缓存中的 biz_tag&lt;/span&gt;&lt;br/&gt;            List&amp;lt;String&amp;gt; cacheTags = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;(cache.keySet());&lt;br/&gt;            &lt;span&gt;// 要插入的 db 中的 biz_tag&lt;/span&gt;&lt;br/&gt;            Set&amp;lt;String&amp;gt; insertTagsSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(dbTags);&lt;br/&gt;            &lt;span&gt;// 要移除的缓存中的 biz_tag &lt;/span&gt;&lt;br/&gt;            Set&amp;lt;String&amp;gt; removeTagsSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(cacheTags);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 缓存中有的话，不用再插入，从 insertTagsSet 中移除&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cacheTags.size(); i++) {&lt;br/&gt;                String tmp = cacheTags.get(i);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (insertTagsSet.contains(tmp)) {&lt;br/&gt;                    insertTagsSet.remove(tmp);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;// 为新增的 biz_tag 创建缓存 SegmentBuffer&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String tag : insertTagsSet) {&lt;br/&gt;                SegmentBuffer buffer = &lt;span&gt;new&lt;/span&gt; SegmentBuffer();&lt;br/&gt;                buffer.setKey(tag);&lt;br/&gt;                Segment segment = buffer.getCurrent();&lt;br/&gt;                segment.setValue(&lt;span&gt;new&lt;/span&gt; AtomicLong(&lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;                segment.setMax(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                segment.setStep(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                cache.put(tag, buffer);&lt;br/&gt;                logger.info(&lt;span&gt;&quot;Add tag {} from db to IdCache, SegmentBuffer {}&quot;&lt;/span&gt;, tag, buffer);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;// db中存在的，从要移除的 removeTagsSet 移除。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; dbTags.size(); i++) {&lt;br/&gt;                String tmp = dbTags.get(i);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (removeTagsSet.contains(tmp)) {&lt;br/&gt;                    removeTagsSet.remove(tmp);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;// 从 cache 中移除不存在的 bit_tag。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String tag : removeTagsSet) {&lt;br/&gt;                cache.remove(tag);&lt;br/&gt;                logger.info(&lt;span&gt;&quot;Remove tag {} from IdCache&quot;&lt;/span&gt;, tag);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;update cache from db exception&quot;&lt;/span&gt;, e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            sw.stop(&lt;span&gt;&quot;updateCacheFromDb&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完后，会出现这样的 log&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Add tag leaf-segment-test from db to IdCache, SegmentBuffer SegmentBuffer{key=&lt;span&gt;&#x27;leaf-segment-test&#x27;&lt;/span&gt;, segments=[Segment(value:0,max:0,step:0), Segment(value:0,max:0,step:0)], currentPos=0, nextReady=&lt;span&gt;false&lt;/span&gt;, initOk=&lt;span&gt;false&lt;/span&gt;, threadRunning=&lt;span&gt;false&lt;/span&gt;, step=0, minStep=0, updateTimestamp=0}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后 init 方法结束后，会将 initOk 设置为 &lt;strong&gt;true&lt;/strong&gt;。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目启动完毕后，我们就可以调用这个 API 了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15702479338842976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsqdzGwf6EgvgiaY8D4ricoQjpaNibX6JYm7lxXzEW434c3XQibvNrlQpQFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;605&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，访问 LeafController 中的 Segment API，可以获取到一个 id。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SegmentIDGenImpl get 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，init 不成功会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及会直接从 cache 中查找这个 key(biz_tag) , 没有的话会报错。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5297619047619048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsj7JtOON9swkfvA8S0Sz0oPzvgVYW5XNlPyyp8u2eJYk3CktvN7DxAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿到这个 SegmentBuffer 时，还得看看它 init 了 没有，没有的话用双检查锁的方式去更新&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看下一眼 SegmentBuffer  的结构 👇&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SegmentBuffer 类&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6206060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs2C87VYsnJXickCHGEWWz4qxtaGPNGOjokhK62fURROZmEJyNSXIXjmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3237639553429027&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsFKVPpw8VnyFHibO3nTicem5E1VllBbO8eeNiaTDgqiaomxVbc1vxVjpiaug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;627&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;⭐updateSegmentFromDb 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是更新缓存的方法了，主要是更新 Segment 的 value ， max，step 字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到有三个 if 分支，下面展开说&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5824561403508772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsMcTL43mCDQUfjicBKT2ekRtsL1W4y9Hiadn9toNAG1aAbJYHUQxLMXAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;855&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分支一：初始化&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次，buffer 还没 init，如上图，执行完后会更新 SegmentBuffer 的 step 和 minStep 字段。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分支二：第二次更新&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是更新这个 updateTimestamp ，它的作用看分支三&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41731066460587324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibssHMk4M9tcHMSrUkAOs3qQkoFMmPkXZbYcVwKVBRLTflo5YsDc4ib6Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分支三：剩下的更新&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就比较有意思了，就是说如果这个号段在 15分钟 内用完了，那么它会扩大这个 step （不超过 10w），创建一个更大的 MaxId ，降低访问 DB 的频率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsSFdUHDyCnGxT7dyGIW5Eia3vRDqqic32Ribmkw4G3UicYNPdr43gcIbQFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1100&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，到这里，我们完成了 &lt;strong&gt;updateSegmentFromDb&lt;/strong&gt; 方法，更新了 Segment 的 value ， max，step 字段。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5297619047619048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsj7JtOON9swkfvA8S0Sz0oPzvgVYW5XNlPyyp8u2eJYk3CktvN7DxAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，我们不是每次 get 都走上面的流程，它还得走这个缓存方法 👇&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;⭐getIdFromSegmentBuffer 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这是另一个重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图，在死循环中，先获取读锁，拿到当前的号段 Segment，进行判断&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用超过 10% 就开新线程去更新下一个号段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没超过则将 value （AtomicLong 类型）+1 ，小于 maxId 则直接返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要重点留意 &lt;strong&gt;读写锁的使用&lt;/strong&gt; ，比如 开新线程时，使用了这个 &lt;strong&gt;写锁&lt;/strong&gt; ，里面的 nextReady 等变量使用了 &lt;strong&gt;volatile&lt;/strong&gt; 修饰&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6231155778894473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs01icwLTZuOE1tlGIYRZfxiahIKGEP6UdaeDlO3wa2JG4cGVCZVBvJBWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;995&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的核心就是切换 Segment。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4569327731092437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsPzRK8A1U0ibibTicKl3ibib67aCibSsBcCy9eJYCDv8o4bW7QSksGdXZBU2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;952&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，号段模式结束。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优缺点&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;信息安全&lt;/strong&gt;：&lt;strong&gt;如果ID是连续的&lt;/strong&gt;，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。—— 《Leaf——美团点评分布式ID生成系统》&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36373507057546145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibskGzsCQtImqia4E1nj4RXLKPKSD0r2QRT2FGM6CLnWpMDnuMOW6PWBhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;figcaption&gt;美团&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这个号段模式的最大弊端就是 信息不安全，所以在使用时得三思，能不能用到这些业务中去。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Snowflake模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;雪花算法，核心就是将 64bit 分段，用来表示时间，机器，序列号等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25359712230215825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsG0L0L3Ug5sPyhIB2V66HrRNa5R7HNNwCAtEeUprXNzzUPHuTqEwUSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;41-bit的时间可以表示（1L&amp;lt;&amp;lt;41）/(1000L&lt;em&gt;3600&lt;/em&gt;24*365)=69年的时间，10-bit机器可以分别表示1024台机器。&lt;/p&gt;&lt;p&gt;12个自增序列号可以表示2^12个ID，理论上snowflake方案的QPS约为 2^12 * 1000 = 409.6w/s&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用 &lt;strong&gt;Zookeeper&lt;/strong&gt; 持久顺序节点的特性自动对 snowflake 节点配置 wokerID，不用手动配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;时钟回拨问题&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4393305439330544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsX3gYFlHu8Jm3uKNyeQibauGdHOTuZfjCJQQ6h1ibZ0DK9GNjNbolA1ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Snowflake模式源码解读&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分源码就不一一展开了，直接展示核心代码&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SnowflakeZookeeperHolder init 方法&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4154929577464789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibszqjicMiaMiciaQFuLICpSYEYXSc2sbN2WQrCNf5xN06Rcbu1qibDMibLf0DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要注意调整这个  connectionTimeoutMs 和  sessionTimeoutMs ，不然两种模式都启动的话，这个 zk 的 session 可能会超时，造成启动失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中流程 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;看看 zk 节点存不存在，不存在就创建&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时将 worker id 保存到本地。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建定时任务，更新 znode。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6246648793565683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs5icqF7m72Is7CugwKZe9wZ7EGRGn6L4fhNZnQeH0rs17UUJsg96afOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;figcaption&gt;znode&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25464949928469244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsl5bZ1iaWJbxHpah7jica4LQYb6aV1icyy2NY3Y27D7O2AbNgp7ywmGDeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;figcaption&gt;worker Id&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6648351648351648&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs6pk8j8UVRiaM6MNagHADEGRpQU2k5BnYBFUrCbyvwTib7BFk76LO3KibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;定时任务&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SnowflakeIDGenImpl  get 方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接看代码和注释了 👇&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; Result &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timestamp = timeGen();&lt;br/&gt;        &lt;span&gt;//  发生了回拨，此刻时间小于上次发号时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (timestamp &amp;lt; lastTimestamp) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; offset = lastTimestamp - timestamp;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (offset &amp;lt;= &lt;span&gt;5&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//时间偏差大小小于5ms，则等待两倍时间&lt;/span&gt;&lt;br/&gt;                    wait(offset &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    timestamp = timeGen();&lt;br/&gt;                    &lt;span&gt;//还是小于，抛异常并上报&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (timestamp &amp;lt; lastTimestamp) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(-&lt;span&gt;1&lt;/span&gt;, Status.EXCEPTION);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    LOGGER.error(&lt;span&gt;&quot;wait interrupted&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(-&lt;span&gt;2&lt;/span&gt;, Status.EXCEPTION);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(-&lt;span&gt;3&lt;/span&gt;, Status.EXCEPTION);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (lastTimestamp == timestamp) {&lt;br/&gt;            &lt;span&gt;// sequenceMask = ~(-1L &amp;lt;&amp;lt; 12 ) = 4095 二进制即 12 个1&lt;/span&gt;&lt;br/&gt;            sequence = (sequence + &lt;span&gt;1&lt;/span&gt;) &amp;amp; sequenceMask;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (sequence == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//seq 为0的时候表示是下一毫秒时间开始对seq做随机&lt;/span&gt;&lt;br/&gt;                sequence = RANDOM.nextInt(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;                timestamp = tilNextMillis(lastTimestamp);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//如果是新的ms开始&lt;/span&gt;&lt;br/&gt;            sequence = RANDOM.nextInt(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        lastTimestamp = timestamp;&lt;br/&gt;        &lt;span&gt;// timestampLeftShift = 22， workerIdShift = 12 &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; id = ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift) | (workerId &amp;lt;&amp;lt; workerIdShift) | sequence;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Result(id, Status.SUCCESS);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;tilNextMillis&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; lastTimestamp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timestamp = timeGen();&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (timestamp &amp;lt;= lastTimestamp) {&lt;br/&gt;            timestamp = timeGen();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; timestamp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;timeGen&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.currentTimeMillis();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;API 效果&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 ID&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20535714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibs5KqDmImEgD3ufzbz9oXw4zg8r5RicXgRIguW2RiaUEetlYt1oDDaHKGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;448&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反解 ID&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13191489361702127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYG2orAOE2mqcpTvwOt2KSibsTdypIjAUh2mJ99AgHzoBFYUkGYNIhyHRs3OBwmvHlB94D0fKSXebibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，这个 Snowflake 模式也了解完毕了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完上面两种模式，我觉得两种模式都有它适用的场景，号段模式更适合对内使用（比如 用户ID），而如果你这个 ID 会被用户看到，暴露出去有其他风险（比如爬虫恶意爬取等），那就得多斟酌了，。而订单号 就更适合用 snowflake 模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式ID 的特点&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;全局唯一&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;趋势递增（有序一直很重要，粗略有序还是严格有序就看情况了）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可反解（可选）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;信息安全（可选）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Github 地址：https://github.com/Meituan-Dianping/Leaf/blob/master/README_CN.md&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leaf——美团点评分布式ID生成系统：https://tech.meituan.com/2017/04/21/mt-leaf.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式id生成方案总结：https://www.cnblogs.com/javaguide/p/11824105.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2MjUzODc5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFUAO47rDkQycV4q8RTDe4kKXORDlaNmjGLiaxZxbHdOJ32ict5W0wEejBficWOLqDYELibIe5IEdtzeA/0?wx_fmt=png&quot; data-nickname=&quot;Java4ye&quot; data-alias=&quot;Java4ye&quot; data-signature=&quot;小目标 —— 写个三年(还剩两年啦~），尽力保持一周一原创的最低频率~ 分享一些实战，快速上手的小 demo ，图解框架，探索源码 ，以及程序员的生活~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c1daaa47f85bae785de0d1ecab6f3583</guid>
<title>黑客“劫持”了一颗卫星，用它直播黑客大会和放电影</title>
<link>https://toutiao.io/k/5x7x2f4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021年8月，在拉斯维加斯举行的DEF CON黑客大会上，一个名为Shadytel的黑客爱好者团体的成员卡尔·科舍尔(Karl Koscher)展示了一项工作：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;他们“劫持”了一颗加拿大卫星，用它进行直播黑客大会，还放映黑客电影。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，这是一颗已经完成使命的卫星，名为Anik F1R，发射于2005年，是一颗地球同步轨道卫星，在2020年达到了“寿命终结”的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为他们拥有接入这个废弃的上行设施的权限，所以科舍尔和他的朋友需要的只是一个HackRF，成本约300美元。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;277:451&quot;&gt;HackRF是一种软件定义无线电外设，能够传输或接收1MHz 至6GHz 的无线电信号。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这不是DEF CON第一次涉及太空安全问题，实际上在2019年举办的DEFCON 27会议上，主办方就宣布要在下一次会议上举行太空信息安全挑战赛，正式名称是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Hack-A-Sat&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（以下简称HAS）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujfsv5bMlKG9oETbWiaW7wR6XV0Vg2jIa4KlzKTpEco0maeIeicQLPpEaQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比赛分为资格赛和决赛两个阶段，采用积分制，资格赛中积分靠前的8支参赛队将进入决赛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参赛团队的规模不限，可以是独立的团队，也可以是由学术机构或公司赞助的，由来自不同公司或大学的人组成，只要其中包括一名美国公民。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在2020年5&lt;/span&gt;&lt;span&gt;月22日至24日举行的Hack-A-Sat2020（以下简称HAS2020）资格赛中&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，有6298人参赛，组成了2213支队伍（科舍尔也参加了，他所在的队伍是ADDVulcan）。这次比赛引起美国空军的注意，所以2020年8月7日至8日HAS2020的决赛由美国空军组织。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2021年，&lt;/span&gt;&lt;span&gt;第2届太空信息安全挑战赛&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，即Hack-A-Sat 2021（以下简称HAS2021），由美国空军与美国天军联合组织，2021年6月26日至27日举行了资格赛，有2962人参赛，组成了1088支队伍，积分排名前7的参赛队与HAS2020决赛的第1名，共8支队伍进入决赛，决赛于2021年12月11日至12日举行，持续24h。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2022年，&lt;/span&gt;&lt;span&gt;第3届太空信息安全挑战赛，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;即Hack-A-Sat 2022（以下简称HAS2022），依然是由美国空军与美国天军联合组织，2022年5月21日至22日举行了资格赛，有2495人参赛，组成了803支队伍，决赛将于2022年10月22日至23日举行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HAS采用夺旗赛CTF（Capture The Flag）的形式，主办方会给出每道题目的部分背景信息，并提供一个模拟环境，要求参赛队通过这个模拟环境，利用已知的信息获取隐藏的flag，并将flag发送给主办方，以评判结果、记录成绩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6663157894736842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujyyIcvMI7nmISmK7fjMpa7UTU77A3uYpKp9QE69Z7CYdEzVZoPOZicaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HAS2020与HAS2021资格赛的前3名均为Poland Can Into Space、PPP、FluxRepeatRocket（顺序有所不同），HAS2020决赛冠军是PFS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HAS2021决赛冠军是Solar Wine。下面对这几支队伍进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Poland Can Into Space：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;这支参赛队的名字取自“波兰上不了太空（Poland cannot into Space）”，而“波兰上不了太空”来自一副漫画，内容是陨石来了，有航天技术的各国都跑了，只有波兰留在地上，来嘲讽波兰上不了太空。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本支参赛队将队名命名为Poland Can Into Space，就是对这个嘲讽的回击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这支队伍实际上是由来自波兰的两支队伍组成的，分别是Dragon Sector、P4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，Dragon Sector成立于2013年，现有17名成员，自成立以来，其在世界CTFTIME上的排名一直很靠前，如表1所示，其logo如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P4现有18名成员，其在世界CTFTIME上的排名最好成绩是2018年第3名，其logo如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在HAS2020决赛中，虽然Poland Can Into Space没有获得冠军，但是他们的解决方案被最终选中上传至实际卫星，并成功拍下了月球图像，如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujicXwpHgqMSVr3dlqpAMXVpSibuYEPol1qMpua4Nt1deQSNvMCTOMfu7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;320&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujQGvbuIZH7XLLgpgoqNuQvPrEpJk7zzTndbJ8f0E8oWwJtv3XtzSQyA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujQGvbuIZH7XLLgpgoqNuQvPrEpJk7zzTndbJ8f0E8oWwJtv3XtzSQyA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图1  Dragon Sector队伍的logo&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujtibMBVRJYSQ2tzBPZGfBbFw9XEop5iaxtfmrGOOWMgicYBxYn51e2gS6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;250&quot; data-width=&quot;99px&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2  P4队伍的logo&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6132404181184669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujQorNurnD0icpLmrgEr5QFeoWdMPwZNHlEKObXKIx6uz73Dv46X4Rt5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot; data-width=&quot;194px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3  Poland Can Into Space参赛队的方案被上传至真实卫星所拍摄的月球照片&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.85&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujxWQKh0JQavNBPzjKaQ5vAMGgXuzkfib5XibzJ3HodlibEmt2GxzBrBp9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot; data-width=&quot;112px&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图4  PPP队伍的logo&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46539379474940334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujibVqpeE7ia44SxM3lj6yD1KH9j5ibYJHkU8FfMZ1BZc0tkcMk8bvNiab9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;419&quot; data-width=&quot;228px&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;图5  FluxFingers队伍的logo&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujG1vm83P65RYrrQyen02oRjuUIzU6qNicapeMf3ZEgS1ECiaVibjrkelYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;150&quot; data-width=&quot;121px&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6  PFS队伍的logo&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;从上述分析可知，参加HAS最后取得优异成绩的参赛队都是世界上顶尖的黑客团队，也从侧面说明了HAS比赛水平很高，太空与信息安全相结合很吸引黑客关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1  资格赛前3名及决赛第1名的参赛队的世界CTFTIME排名&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4816112084063047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6guj3ic9z3unVJPecHic2uGOu49Lic97FDcXtiaBZLoUr3jQXdSOEIuag1KJyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;HAS是结合了航天与信息安全两个领域的比赛，在其题目设置上也体现了这一点，有别于传统的信息安全夺旗赛。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般的卫星运行都包括3部分：地面站、星地链路、卫星。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;HAS的挑战题也是围绕这3部分进行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在题目中，除了传统的密码破解、逆向工程、信号截获分析等信息安全知识，还结合了天体物理学、天文学的相关知识，体现了太空信息安全的特殊性。涉及的技术也是相当广泛的，既有与嵌入式操作系统相关的技术，也有与处理器相关的技术，还有与信号处理、软件无线电相关的技术，因此对参赛者的能力和知识面提出了极高的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正是在这样的背景下，几位信息安全爱好者、航天工作从业者共同努力，对这个比赛进行了深入的分析研究，在此基础上，将相关研究成果编辑成册，形成了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;《Hack-A-Sat太空信息安全挑战赛深度题解》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一书。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6guj5tbiaWpKmVds0LGGXlL9SyPk6bnkjGcfyovw4jENJpvroZytoTh8uQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-width=&quot;251px&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93528&quot;&gt;&lt;section hm_fix=&quot;228:352&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujL4Xoicfl0dj8rCwbsGgdFxD9lajwnESTlMqsFQpic8I6z2ZBdlPAicuuw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;55&quot; data-width=&quot;10%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;该书以HAS2020资格赛的部分题目为例，进行深度讲解，重点是讲解解题的思路过程，分为7章：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;对于介绍的每道挑战题都会先介绍题目给出的基本信息，然后编译得到镜像，并测试题目的正确性，接着介绍相关背景知识，最后给出解题思路、过程。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;6.767857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujS1P5vbgibYEqribW217ONYl6Zm5CouzGQIBWxWDSMnMiafvLVCAEHubBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;7.891336270190895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujMVqbJWsNGicRc2puWY2zWuANUSZ5vzcCqjwEoKViaxKfFYSB1t7La4Fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3kQx0vSZ1F9TkhqmicXG6gujQicAwSiaEo7KBHqDXG9cp4CatXwomoMtFvekyJmbOx3QCVl8HpQgKBfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;136px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫码了解本书详情&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布：刘恩惠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92644&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt; &lt;strong&gt;热文推荐 &lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3m3jibtjia3lCrCvUY6N19QMZ3FjCcpuHouXkdLicQVUiaLicgR8cgSbk7RA8G427GKowhbEvVefuJp53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▼点击阅读原文，了解本书详情~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>30b344a2969135f8ef7c9f60e22e29a8</guid>
<title>云架构师进阶攻略（完整版）</title>
<link>https://toutiao.io/k/aghcor1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、架构的三个维度和六个层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.503125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBMvch6HfJ0slh7DyamvYNNVOFThicqdL71W4QSD0cyF0ntHl3NIeolQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1、三大架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在互联网时代，要做好一个合格的云架构师，需要熟悉三大架构。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一个是IT架构，其实就是计算，网络，存储。这是云架构师的基本功，也是最传统的云架构师应该首先掌握的部分，良好设计的IT架构，可以降低CAPEX和OPEX，减轻运维的负担。数据中心，虚拟化，云平台，容器平台都属于IT架构的范畴。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二个是应用架构，随着应用从传统应用向互联网应用转型，仅仅搞定资源层面的弹性还不够，常常会出现创建了大批机器，仍然撑不住高并发流量。因而基于微服务的互联网架构，越来越成为云架构师所必需的技能。良好设计的应用架构，可以实现快速迭代和高并发。数据库，缓存，消息队列等PaaS，以及基于SpringCloud和Dubbo的微服务框架，都属于应用架构的范畴。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三个是数据架构，数据成为人工智能时代的核心资产，在做互联网化转型的同时，往往进行的也是数字化转型，并有战略的进行数据收集，这就需要云架构师同时又大数据思维。有意识的建设统一的数据平台，并给予数据进行数字化运营。搜索引擎，Hadoop，Spark，人工智能都属于数据架构的范畴。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2、六个层面&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面的三个维度是从人的角度出发的，如果从系统的角度出发，架构分六个层次。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6535982814178303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB1BDQx4mcRP4osvhjkytkuU9tLH9X586vZ7ESamg7yF53WUS6WicY4Yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1862&quot;/&gt;  &lt;/p&gt;&lt;p&gt;第一个层次是基础设施层，在数据中心里面，会有大量的机架，大量的服务器，并通过交换机和路由器将服务器连接起来，有的应用例如Oracle是需要部署在物理机上的。为了管理的方便，在物理机之上会部署虚拟化，例如Vmware，可以将对于物理机复杂的运维简化为虚拟机灵活的运维。虚拟化采取的运维方式多是由运维部门统一管理，当一个公司里面部门非常多的时候，往往要引入良好的租户管理，基于Quota和QoS的资源控制，基于VPC的网络规划等，实现从运维集中管理到租户自助使用模式的转换，托生于公有云的OpenStack在这方面做的是比较好的。随着应用架构越来越重要，对于标准化交付和弹性伸缩的需求越来越大，容器最为软件交付的集装箱，可以实现基于镜像的跨环境迁移，Kubernetes是容器管理平台的事实标准。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二个层次是数据层，也即一个应用的中军大营，如果是传统应用，可能会使用Oracle，并使用大量的存储过程，有大量的表联合查询，成本也往往比较高。但是对于高并发的互联网应用，需要进行微服务的拆分，数据库实例会比较多，使用开源的Mysql是常见的选择，大量的存储过程和联合查询往往会使得微服务无法拆分，性能会比较差，因而需要放到应用层去做复杂的业务逻辑，数据库表和索引的设计非常重要。当并发量比较大的时候，需要实现横向扩展，就需要基于分布式数据库，也是需要基于单库良好的表和索引设计。对于结构比较灵活的数据，可以使用MongoDB数据库，横向扩展能力比较好。对于大量的联合查询需求，可以使用ElasticSearch之类的搜索引擎来做，速度快，更加灵活。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三个层次是中间件层，因为数据库层往往需要保证数据的不丢失以及一些事务，因而并发性能不可能非常大，所以我们经常说，数据库是中军大营，不能所有的请求都到这里来，因而需要一层缓存层，用来拦截大部分的热点请求。Memcached适合做简单的key-value存储，内存使用率比较高，而且由于是多核处理，对于比较大的数据，性能较好。但是缺点也比较明显，Memcached严格来讲没有集群机制，横向扩展完全靠客户端来实现。另外Memcached无法持久化，一旦挂了数据就都丢失了，如果想实现高可用，也是需要客户端进行双写才可以。Redis的数据结构比较丰富，提供持久化的功能，提供成熟的主备同步，故障切换的功能，从而保证了高可用性。另外微服务拆分以后，有时候处理一个订单要经过非常多的服务，处理过程会比较慢，这个时候需要使用消息队列，让服务之间的调用变成对于消息的订阅，实现异步处理。RabbitMQ和Kafka是常用的消息队列，当事件比较重要的时候，会结合数据库实现可靠消息队列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第四个层次是基础服务层，有的时候成为中台层，将通用的能力抽象为服务对外提供原子化接口。这样上层可以根据业务需求，通过灵活的组合这些原子化接口，灵活的应对业务需求的变化，实现能力的复用，以及数据的统一管理，例如用户数据，支付数据，不会分散到各个应用中。另外基础服务层称为应用和数据库和缓存的一个分界线，不应该所有的应用都直接连数据库，一旦出现分库分表，数据库迁移，缓存选型改变等，影响面会非常大，几乎无法执行。如果将这些底层的变更拦截在基础服务层，上层仅仅使用基础服务层的接口，这样底层的变化会对上层透明，可以逐步演进。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第五个层次是业务服务层，或者组合服务层，大部分的业务逻辑都是在这个层面实现，业务逻辑比较面向用户，因而会经常改变，所以需要组合基础服务的接口进行实现。在这一层，会经常进行服务的拆分，实现开发独立，上线独立，扩容独立，容灾降级独立。微服务的拆分不应该是一个运动，而应该是一个遇到耦合痛点的时候，不断解决，不断演进的一个过程。微服务拆分之后，有时候需要通过分布式事务，保证多个操作的原子性，也是在组合服务层来实现的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第六个层次是用户接口层，也即对终端客户呈现出来的界面和APP，但是却不仅仅是界面这么简单。这一层有时候称为接入层。在这一层，动态资源和静态资源应该分离，静态资源应该在接入层做缓存，使用CDN进行缓存。也应该UI和API分离，界面应该通过组合API进行数据拼装。API会通过统一的API网关进行统一的管理和治理，一方面后端组合服务层的拆分对APP是透明的，一方面当并发量比较大的时候，可以在这一层实现限流和降级。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了支撑这六个层次，在上图的左侧是一些公共能力。&lt;/p&gt;&lt;ul data-list-style=&quot;circle&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;持续集成和持续发布是保证微服务拆分过程中的快速迭代，以及变更后保证功能不变的，不引入新的Bug。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;服务发现和服务治理是微服务之间互相的调用，以及调用过程中出现异常情况下的熔断，限流，降级策略。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大数据和人工智能是通过收集各个层面的数据，例如用户访问数据，用户下单数据，客服询问数据等，结合统一的中台，对数据进行分析，实现智能推荐。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监控与APM是基础设施的监控和应用的监控，发现资源层面的问题以及应用调用的问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作为一个云架构师还是很复杂的，千里之行，始于足下，让我们慢慢来。&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、了解云计算的历史演进与基本原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在一头扎进云计算的汪洋大海之前，我们应该先有一个全貌的了解，有人说了解一个知识的起点，就是了解他的历史，也就是知道他是如何一步一步到今天的，这样如此庞大的一个体系，其实是逐步加进来的，这样的知识体系对我们来说，就不是一个冷冰冰的知识网，而是一个有血有肉的人，我们只要沿着演进的线索，一步一步摸清楚他的脾气就可以了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如何把云计算讲的通俗易懂，我本人思考了半天，最终写下了下面这篇文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484855&amp;amp;idx=1&amp;amp;sn=2ffdb5414c5010b69eec120c231be1d3&amp;amp;chksm=ea151295dd629b837bca75dc8222bac7148a18e6c7daa79b821587f6e34cf2ece598616a96e2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;终于有人把云计算、大数据和人工智能讲明白了！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这里，我把核心的要点在这里写一下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一：云计算的本质是实现从资源到架构的全面弹性。所谓的弹性就是时间灵活性和空间灵活性，也即想什么时候要就什么时候要，想要多少就要多少。&lt;/p&gt;&lt;p&gt;资源层面的弹性也即实现计算、网络、存储资源的弹性。这个过程经历了从物理机，到虚拟化，到云计算的一个演进过程。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtkdK1C6TdzrGQfBMibDPibAUrUQkic3apIend5oPrcpZTBnr0aiaiaAI5J49zTUS1tqjrlkXtEMrXoFWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;      &lt;/p&gt;&lt;p&gt;架构层面的弹性也即实现通用应用和自有应用的弹性扩展。对于通用的应用，多集成为PaaS平台。对于自己的应用，通过基于脚本的Puppet, Chef, Ansible到基于容器镜像的容器平台CaaS。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBp2XibyBibGHpNjTRmnaXMLfzKhUCU2vH8PtJQnrFiaMlnYY36JCSzYbGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;      &lt;/p&gt;&lt;p&gt;第二：大数据包含数据的收集，数据的传输，数据的存储，数据的处理和分析，数据的检索和挖掘等几个过程。 &lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtkdK1C6TdzrGQfBMibDPibAUhsUk99SkB4qEmotCEejicXibY5iblibITZhd9kHqGgvG1lRqm0RmzbVgsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当数据量很小时，很少的几台机器就能解决。慢慢的，当数据量越来越大，最牛的服务器都解决不了问题时，怎么办呢？这时就要聚合多台机器的力量，大家齐心协力一起把这个事搞定，众人拾柴火焰高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三：人工智能经历了基于专家系统的计划经济，基于统计的宏观调控，基于神经网络的微观经济学三个阶段。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38645833333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBdAGqLumjacSHHxbA8tia63qpZRCy3BDuYBEvO2vxJLcBUZQYFulp2Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;      &lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、开源软件是进阶的利器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;架构师除了要掌握大的架构和理论之外，指导落地也是必备的技能，所谓既要懂设计模式，也要懂代码。那从哪里去学习这些良好的，有借鉴意义的，可以落地的架构实践呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个世界上还是有很多有情怀的大牛的，尤其是程序员里面，他们喜欢做一件什么事情呢？开源。很多软件都是有闭源就有开源，源就是源代码。当某个软件做的好，所有人都爱用，这个软件的代码呢，我封闭起来只有我公司知道，其他人不知道，如果其他人想用这个软件，就要付我钱，这就叫闭源。但是世界上总有一些大牛看不惯钱都让一家赚了去。大牛们觉得，这个技术你会我也会，你能开发出来，我也能，我开发出来就是不收钱，把代码拿出来分享给大家，全世界谁用都可以，所有的人都可以享受到好处，这个叫做开源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;非常建议大家了解，深入研究，甚至参与贡献开源软件，因为收益匪浅。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第一：通过开源软件，我们可以了解大牛们的架构原则，设计模式。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实咱们平时的工作中，是很难碰到大牛的，他可能是你渴望而不可及的公司的员工，甚至在国外，你要想进这种公司，不刷个几年题目，面试个N轮是进不去的。即便进去了，他可能是公司的高层，每天很忙，不怎么见得到他，就算当面讨教，时间也不会很长，很难深入交流。也有的大牛会选择自主创业，或者是自由职业者，神龙见首不见尾，到了大公司都见不到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是感谢互联网和开源社区，将大牛们拉到了我们身边，你可以订阅邮件组，可以加入讨论群，可以看到大牛们的设计，看到很多人的评论，提问，还有大牛的回答，可以看到大牛的设计也不是一蹴而就完美的，看到逐渐演进的过程，等等。这些都是能够帮助我们快速提升水平的地方，有的时候，拿到一篇设计，都要查资料看半天，一开始都可能好多的术语都看不懂，没关系肯下他，当你看blueprints越来越顺畅的时候，你就进步了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第二：通过开源软件，我们可以学习到代码级的落地实践。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有时候我们能看到很多大牛写的书和文章，也能看到很多理论的书籍，但是存在一个问题是，理论都懂，但是还是做不好架构。这是因为没有看到代码，所有的理论都是空中楼阁，当你到了具体的代码设计层面，那些学会的设计模式，无法转化为你自己的实践。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;好在开源软件的代码都是公开的，凝结了大牛的心血，也能够看到大牛在具体落地时候的取舍，一切那么真实，看得见，摸得着。通过代码进行学习，配合理论知识，更容易获得第一手的经验，并且在自己做设计和写代码的时候，马上能够映射到可以参考的场景，让我们在做自己的系统的时候，少走弯路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第三：通过开源软件，我们可以加入社区，和其他技术人员在同一背景下共同进步&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大牛我们往往不容易接触到，正面讨论技术问题的时间更是难能可贵，但是没有关系，开源软件构建了一个社区，大家可以在一起讨论，你是怎么理解的，别人是怎么理解的，越讨论越交流，越明晰，有时候和比你经验稍微丰富一点的技术人员交流，可能比直接和大牛对话更加有直接作用。大牛的话可能让你消化半天，依然不知所云，大牛可能觉得很多普通人觉得的难点是显而易见的，不屑去解释。但是社区里面的技术人员，可能和你一样慢慢进步过来的，知道哪些点是当年自己困惑的，如果踩过这一个个的坑，他们一点拨，你就会豁然开朗。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而且每个人遇到的具体情况不同，从事的行业不同，客户的需求不同，因而软件设计的时候考虑的因素不同，大牛是牛，但是不一定能够遇到和你一样的场景，但是社区里面，有你的同行业的，背景相近的技术人员，你们可以讨论出符合你们特定场景的解决方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第四：通过开源软件，我们作为个人，比较容易找到工作&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们面试的时候，常常遇到的问题是，怎么能够把在原来工作中自己的贡献，理解，设计，技术能力。其实我发现很多程序员不能很好的做的这一点，所以造成很多人面试很吃亏。原因之一是背景信息不对称，例如原来面临的业务上很难的问题，面试官由于不理解背景，而且短时间解释不清楚，而轻视候选人的水平，我也遇到过很多面试官才听了几分钟，就会说，这不挺简单的，你这样这样不就行了，然后彻底否定你们一个团队忙了三年的事情。原因之二是很多有能力的程序员不会表达，导致真正写代码的说不明白，可能原来在公司里面一个绩效非常好，一个绩效非常差，但是到了面试官那里就拉平了。原因之三是新的公司不能确定你在上家公司做的工作，到这一家都能用的，例如你做的工作有30%是和具体业务场景相关的，70%是通用技术，可能下家公司只会为你的通用技术部分买单。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开源软件的好处就是，参与的人所掌握的技能都是通的，而且大家在同一个上下文里面对话，面试官和候选人之间的信息差比较少。掌握某个开源软件有多难，不用候选人自己说，大家心里都有数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于很多技术能力强，但是表达能力较弱的极少数人员来讲，talk is cheap, show me the code，代码呈上去，就能够表现出实力来了，而且面试官也不需要根据短短的半个小时了解一个人，可以做很多背景调查。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外由于掌握的技术的通用的，你到下一家公司，马上就能够上手，几乎不需要预热时间，对于双方都有好处。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第五：通过开源软件，我们作为招聘方，比较容易招到相应人员。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果在创业公司待过的朋友会了解到创业公司招人很难，人员流失很快，而且创业公司往往对于开发进度要求很快，因为大家都在抢时间。因而开源软件对于招聘方来讲，也是好消息。首先创业公司没办法像大公司一样，弄这么多的技术大牛，自己完全落地一套自己的体系，使用开源软件快速搭建一套平台先上线是最好的选择。其次使用开源软件，会使得招聘相对容易，市场上火的开源软件会有大批的从业者，参与各种论坛和社区，比较容易挖到人。最后，开源软件的使用使得新人来了之后没有预热时间，来了就上手，保证开发速度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那如何快速上手一款开源软件呢？我写了一篇文章&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484691&amp;amp;idx=1&amp;amp;sn=7d25a80dc67ee40c5af32905d217f3db&amp;amp;chksm=ea151231dd629b27305f8a8240bfdf10bc858bc691c430eb84e2d59e78450fa74c4a428d7cbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;如何快速上手一款开源软件&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这篇文章中，我总结了九个步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;一、手动安装起来，一定要手动&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;二、使用一下，推荐XXX in Action系列&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;三、读文档，读所有的官方文档，记不住，看不懂也要读下来&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;四、了解核心的原理和算法，推荐XXX the definitive guide系列&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;五、看一本源码分析的书，会让你的源码阅读之旅事半功倍&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;六、开始阅读核心逻辑源代码&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;七、编译并Debug源代码&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;八、开发一个插件，或者对组件做少量的修改&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;九、大量的运维实践经验和面向真实场景的定制开发&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以做一个云架构师，一定不能脱离代码，反而要不断的拥抱开源软件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、了解Linux基础知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作为一个云架构师，首要的一点，就是要熟悉Linux的基础知识，基本原理了。&lt;/p&gt;&lt;p&gt;说到操作系统，一般有三个维度，一个是桌面操作系统，一个是移动操作系统，一个是服务器操作系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Stack Overflow Developer Survey 2018有这样一个统计，对于开发人员来说，桌面操作系统的排名是Windows，MacOS，Linux，所以大部分人平时的办公系统都是windows。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39514978601997147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBeJoUiabNF0QfKruFvZ4YBAqbeNx7asWH9y2ibrxzYzElpoVuibd0QdKtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当然因为办公的原因，平时使用windows的比较多，所以在学校里，很多同学接触到的操作系统基本上都是Windows，但是一旦从事计算机行业，就一定要跨过Linux这道坎。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据今年W3Techs的统计，对于服务器端，Unix-Like OS占到的比例为近70%。所谓Unix-Like OS 包括下图的Linux，BSD等一系列。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3398203592814371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB5IyhiaFDPWiaudF2Ad4CTAiaO9PZrHwicYkCXZrW7u3Giaw6p4jaBzDCBLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;      &lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5831739961759083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBuMUa1XSvFgK0cic9aicKl57zicwMbNf6fXA4ib2ZEDPmd1TcuSqqicCBfpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;523&quot;/&gt;      &lt;/p&gt;&lt;p&gt;从这个统计可以看出，随着云计算的发展，软件SaaS化，服务化，甚至微服务化，大部分的计算都是在服务端做的，因而要成为云架构师，就必须懂Linux。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;随着移动互联网的发展，客户端基本上以Android和iOS为主，下图是Gartner的统计。Android是基于Linux内核的。因而客户端也进入了Linux阵营，很多智能终端，智能设备等开发职位，都需要懂Linux的人员。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3617021276595745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBVOfMz94lg1wtaq3TrXO1XNzDRTsr81JKdc8HVx8uIDicwln6liaXk2Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;      &lt;/p&gt;&lt;p&gt;学习Linux主要包含两部分，一个是怎么用，一个是怎么编程，背后原理是什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于怎么用，上手的话，推荐《鸟哥的Linux私房菜》，按着这个手册，就能够学会基本的Linux的使用，如果再深入一点，推荐《Linux系统管理技术手册》，砖头厚的一本书，是Linux运维手边必备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于怎么编程，上手的话，推荐《UNIX环境高级编程》，有代码，有介绍，有原理，如果对内核的原理感兴趣，推荐《深入理解LINUX内核》。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Linux的架构如下图&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7531645569620253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBdJnrLhZNibfibgvc0rpJoX9KMricvibLq6lWEz4nKn5GYQFUEM5xRXY1pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;474&quot;/&gt;      &lt;/p&gt;&lt;p&gt;我们知道，一台物理机上有很多的硬件，最重要的是CPU，内存，硬盘，网络，但是一个物理机上要跑很多的程序，这些资源应该给谁用呢？当然是大家轮着用，谁也别独占，谁也别饿死。为了完成这件事情，操作系统的内核就起到了大管家的作用，将硬件资源分配给不同的用户程序使用，并且在适当的时间将资源拿回来，再分配给其他的用户进程，这个过程称为调度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统的功能之一是系统调用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当用户程序想请求资源的时候，需要调用操作系统的系统调用接口，这是内核和用户态程序的分界线，就像你要打车，要通过打车软件的界面，下发打车指令一样，这样打车软件才会给你调度一辆车。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统的功能之二是进程管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当一个用户进程运行的时候，内核为他分配的资源，总要有一个数据结构保存，哪些资源分配给了这个进程。分配给这个进程的资源往往包括打开的文件，内存空间等。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6436394271272114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBEZthErGey1mVzRib4iaP1Lj2s2TJ1an6WSuJyo2J9n6icwQeXZ88TyRXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1187&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统的功能之三是内存管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个进程有独立的内存空间，内存空间是进程用来存放数据的，就像一间一间的仓库。为了进程使用方便，每个进程内存空间，在进程的角度来看都是独立的，也即都是从0号仓库，1号仓库，一直到N号仓库，都是独享的。但是从操作系统内核的角度来看，当然不可能独享，而是大家共享，M号仓库只有一个，你用他就不能用，这就需要一个仓库调度系统，将用户进程的仓库号和实际使用的仓库号对应起来，例如进程1的10号仓库，对应到真实的仓库是110号，进程2的20号仓库，对应到真实的仓库是120号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统功能之四是文件系统&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于Linux来讲，很多东西都是文件，例如进程号回对应一个文件，建立一个网络连接也对应一个文件。文件系统多种多样，为了能够统一适配，有一个虚拟文件系统的中间层VFS。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统功能之五是设备管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;设备分两种，一种是块设备，一种是字符设备，例如硬盘就是块设备，可以格式化为文件系统，再如鼠标和键盘的输入输出是字符设备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;操作系统功能之六是网络管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实对于Linux来讲，网络也是基于设备和文件系统的，但是由于网络有自己的协议栈，要遵循TCP/IP协议栈标准。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB6Wx0fsgZvYS4sejIlb6LCJsNytOPWTcNwGgoffibPKX5NphBlricTiakw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;      &lt;/p&gt;&lt;p&gt;对于Linux的基础知识方面，我写了几篇文章如下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484592&amp;amp;idx=1&amp;amp;sn=3cf26fa86e85dd0d9ebe2cfc024cae80&amp;amp;chksm=ea151392dd629a8475483982c35bd822e9eeaf2a46f5e22a6d0d24c7139e466d9173e2ee8b1e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图说Linux进程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484603&amp;amp;idx=1&amp;amp;sn=856134c3ed2f0bee371eeb49033b9592&amp;amp;chksm=ea151399dd629a8fa34c324cb9da13d8d390e4732bf21daf90f52313e148a3c512b0d52d3ec1&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图说Linux进程之二&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484618&amp;amp;idx=1&amp;amp;sn=b3761343ebf9fdae302cbfb72bd8c97a&amp;amp;chksm=ea1513e8dd629afe6eef7c59fa206a0b756d9d6fa597f2b449b508f9ae51b6f24479e8eb683b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图说Linux进程之三&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484659&amp;amp;idx=1&amp;amp;sn=c3c0a4972d82e3ee64e1006c269490f9&amp;amp;chksm=ea1513d1dd629ac764340e27d426c0dd31fce97020cf9d6eb0c9eaf27df6cf85ffcf17c87c0d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图解Linux文件系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484676&amp;amp;idx=1&amp;amp;sn=f0f9b62ccc9c060d9b57a404d3d3c97e&amp;amp;chksm=ea151226dd629b30552a4a9c136b2344b2bde6dbf192aaf09b9561511899839bc53a374a5ccc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图解Linux系统调用&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484584&amp;amp;idx=1&amp;amp;sn=0b17428192281bf0066151f49a3c78ef&amp;amp;chksm=ea15138add629a9c43825c93499569f4546d0089915467da5cc1d47d902b3b587b9de184e17c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;Linux的虚拟文件系统VFS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484672&amp;amp;idx=1&amp;amp;sn=c2a0a16a6f38ae64b5be08cba08a5549&amp;amp;chksm=ea151222dd629b34294062f4c0f171e10c06767656bc2bf61b4066e24dc0ef467206ef1a6900&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;图解Linux的Socket&lt;/a&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、了解数据中心和网络基础知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云平台当然会部署在数据中心里面，由于数据中心里面的硬件设备也是非常专业的，因而很多地方机房部门和云计算部门是两个部门，但是作为一个云架构师，需要和机房部门进行沟通，因而需要一定的数据中心知识，在数据中心里面，最难搞定的是网络，因而这里面网络知识是重中之重。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面这个图是一个典型的数据中心图。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8323615160349854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBpn5dYZLMzI9ChC4icFBwHQbDE20ZQWxuvWIKB3rz2YibY6YGcwnicre7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1372&quot;/&gt;      &lt;/p&gt;&lt;p&gt;最外层是Internet Edge，也叫Edge Router，也叫Border Router，它提供数据中心与Internet的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第一层core network，包含很多的core switches&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第二层也即每个AZ的最上层，我们称为Aggregation layer。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;第三层是access layer，就是一个个机架的服务器，用接入交换机连接在一起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是一个典型的三层网络结构，也即接入层、汇聚层、核心层三层。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于数据中心，我写了几篇文章&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484433&amp;amp;idx=1&amp;amp;sn=d723d5e47d77e59d14b1faee636ab897&amp;amp;chksm=ea151333dd629a25ee2a2e31e0fc1350e3f8140be40acec4298c7ef03668b81e916125e6186c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;数据中心长啥样？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484441&amp;amp;idx=1&amp;amp;sn=7cc23be2715490388630a4552295050a&amp;amp;chksm=ea15133bdd629a2db6cde1c49004fa13885eedb83be73be8752a6af8b18ace4ac0cb748d25d0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;高可用性的几个级别&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484499&amp;amp;idx=1&amp;amp;sn=acd6b919667bd39a47a68b84394d6b8c&amp;amp;chksm=ea151371dd629a67f8671299643de9df789b574c0028919ffdc6645846eeffb7eecdb94b5d2c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;当客户在说要安全的时候，客户在想什么？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了数据中心以外，哪怕是做应用架构，对于网络的了解也是必须的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云架构说到底是分布式架构，既然是分布式，就是去中心化的，因而就需要系统之间通过网络进行互通，因而网络是作为大规模系统架构绕不过去的一个坎。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于网络的基本原理，推荐书籍《计算机网络-严伟与潘爱民译》，《计算机网络：自顶向下方法》。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于TCP/IP协议栈的了解，推荐书籍《TCP/IP详解》，《The TCP/IP Guide》&lt;/p&gt;&lt;p&gt;对于&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于网络程序设计，推荐书籍《UNIX网络编程》&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果你想了解网络协议栈的实现，推荐书籍《深入理解LINUX网络内幕》&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里还自我推荐一下本人写的极客时间专栏《趣谈网络协议》。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484908&amp;amp;idx=1&amp;amp;sn=22cb72440115e55d07d95808d2fd28de&amp;amp;chksm=ea1512cedd629bd8f8b84596d81763d22f721f54545f3482284ecd764a4ef60e43bdb463d56a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;极客时间《趣谈网络协议》：小说一样的网络协议入门课&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中有个综合场景，串起来所有的网络协议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484936&amp;amp;idx=1&amp;amp;sn=0faa4ecc14e96f7fa98e6a2b147a6e5d&amp;amp;chksm=ea15112add62983c06670c584f339b338ae46b5c1e9a4c276639f92bc143406630c6a9fc6c1f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;用双十一的故事串起碎片的网络协议（下）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484932&amp;amp;idx=1&amp;amp;sn=f2419a8a2951ca05056779c4d5cb3d10&amp;amp;chksm=ea151126dd62983074347df0bd0db58a69e615ea339a2d4a128aa90462dd33bb8d7c8c733364&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;用双十一的故事串起碎片的网络协议（中）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484928&amp;amp;idx=1&amp;amp;sn=4b4b4cc351bf01fea3d777886142546e&amp;amp;chksm=ea151122dd62983419a53171414eeae2f54f40643ba430e3e3a39bf648464a9c7277fa2ffa12&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;用双十一的故事串起碎片的网络协议（上）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8143236074270557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBghD2pa5dFduzYYS8BsdAibCwicJLaQ6n2ssicWWPIm7AmBLdtRB24oC3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1131&quot;/&gt;      &lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、基于KVM了解计算虚拟化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当物理机搭建完毕之后，接下来就是基于物理机上面搭建虚拟机了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;没有了解虚拟机的同学，可以在自己的笔记本电脑上用VirtualBox或者Vmware创建虚拟机，你会发现，很容易就能在物理机的操作系统之内再安装多个操作系统，通过这种方式，你可以很方便的在windows办公系统之内安装一个Linux系统。从而保持LInux系统的持续学习。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5888738127544098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBbUn37JicaYnksjNicDPdo7Yn2qpL2kyEJ7YiajR3o5whxZdDcwoN5CDfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot;/&gt;      &lt;/p&gt;&lt;p&gt;前面讲linux操作系统的时候，说到操作系统，就是整个系统的管家。应用程序要申请资源，都需要通过操作系统的系统调用接口，向操作系统内核申请将CPU，内存，网络，硬盘等资源分配给他。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候你会发现，虚拟机也是物理机上的一个普通进程，当虚拟机内部的应用程序申请资源的时候，需要向虚拟机的操作系统请求。然而虚拟机的操作系统自己本身也没有权限操作资源，因而又需要像物理机的操作系统申请资源。这中间要多一次翻译的工作，完成这件事情的称为虚拟化软件。例如上面说的VirtualBox和Vmware都是虚拟化软件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是多一层翻译，就多一层性能损耗，如果虚拟机里面的每一个操作都要翻译，都不能直接操作硬件，性能就会差很多，简直没办法用，于是就出现了上图中的硬件辅助虚拟化，也即通过硬件的特殊配置，例如VT-x和VT-d等，让虚拟机里面的操作系统知道，他不是一个原生的操作系统了，是一个虚拟机的操作系统，不能按照原来的模式操作资源了，而是通过特殊的驱动以硬件辅助的方式抄近道操作物理资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;刚才说的是桌面虚拟化，也就是在你的笔记本电脑上，在数据中心里面，也可以使用Vmware进行虚拟化，但是价格比较贵，如果规模比较大，会采取开源的虚拟化软件qemu-kvm。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5021312872975278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBmicBewgRSQ8pF4V0h2eC6BfJOOUjP3F96LBic7yyNfKOtk3PicABowicJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;      &lt;/p&gt;&lt;p&gt;对于qemu-kvm来说，和上面的原理是一样的，其中qemu的emu是emulator的意思，也即模拟器，就是翻译的意思。KVM是一个可以使用CPU的硬件辅助虚拟化的方式，而网络和存储的，需要通过特殊的virtio的方式，提供高性能的设备虚拟化功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要了解虚拟化的基本原理，推荐书籍《系统虚拟化——原理与实现》&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要了解KVM，推荐两本书籍《KVM Virtualization Cookbook》和《Mastering KVM Virtualization》。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外KVM和qemu的官方文档也是必须要看的，还有Redhat的官网很多文章非常值得学习。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于虚拟化方面，我写了以下的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483820&amp;amp;idx=1&amp;amp;sn=8a44b992491aea03e55eefb4815a1958&amp;amp;chksm=ea15168edd629f98e622dcb94e64fbb4a75055da98d620e7c83071b5d6d428904fa5c8e9c4ad&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;我是虚拟机内核我困惑？！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483831&amp;amp;idx=1&amp;amp;sn=650c5965dcc837308652a7a6bb328754&amp;amp;chksm=ea151695dd629f830a90a221e85c27197b775e38091934395289183701336ba363d77e2fd2ad&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;Qemu，KVM，Virsh傻傻的分不清&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483858&amp;amp;idx=1&amp;amp;sn=74406c9f1369ba028f4cae6bf59cee78&amp;amp;chksm=ea1516f0dd629fe6701815ec55bfe6f5e9717b23b7597edd4fd6da0379e4538404da11601fd1&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;裸用KVM创建虚拟机，体验virtualbox为你做的10件事情&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483881&amp;amp;idx=1&amp;amp;sn=909f3682feeca50b6a16981538bde498&amp;amp;chksm=ea1516cbdd629fdd13becbf908a83c8079bdc9484fa43541632c3f82c16467b0fc35de7d7d06&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;KVM虚拟机镜像那点儿事，qcow2六大功能，内部快照和外部快照有啥区别？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483913&amp;amp;idx=1&amp;amp;sn=dc54c5667a37553cbfbda318fd48d264&amp;amp;chksm=ea15152bdd629c3d44ab4ca0d924279781b601009fe5f8c1b95cb388745eda51a3427de28edd&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;KVM半虚拟化设备virtio及性能调优最佳实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484091&amp;amp;idx=1&amp;amp;sn=49ba65f20da2f29c5e7bce16ad416660&amp;amp;chksm=ea151599dd629c8f116fd2cd12963338c314ab6e86fa1781efa64ff394b9417163d99d4a58d2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;我的虚拟机挂了！怎么把镜像里面的数据找回来？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483985&amp;amp;idx=1&amp;amp;sn=2f5e1a17440edb0bb99b7b02a2d26633&amp;amp;chksm=ea151573dd629c6577d01f40460aab2f0d9b9169d6887b38ed330a99cb8f5f691fc5da43bc4f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;不仅Docker有镜像，KVM也有多种方式操作镜像&lt;/a&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、基于Openvswitch了解网络虚拟化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当虚拟机创建出来了，最主要的诉求就是要能上网，他能访问到网上的资源，如果虚拟机里面部署一个网站，也希望别人能够访问到他。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这一方面依赖于qemu-KVM的网络虚拟化，将网络包从虚拟机里面传播到虚拟机外面，这需要物理机内核转换一把，形成虚拟机内部的网卡和虚拟机外部的虚拟网卡。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7601683029453016&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBUzcdyFVOTAaYLLoicwyRsZXZxufw5Sciazckuns1MibxJDqVDUUcMcEpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;      &lt;/p&gt;&lt;p&gt;另外一方面就是虚拟机的网络如何能够连接到物理网络里面。物理网络常常称为underlay network，虚拟网络常常称为overlay network，从物理网络到虚拟网络称为网络虚拟化，能非常好的完成这件事情的是一个叫Openvswitch的虚拟交换机软件。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7770382695507487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBNCod0OibKEGtTemvpE05dmxRh5gM5CNuQ5awicWnE8vxCpRbGnurucuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;      &lt;/p&gt;&lt;p&gt;Openvswitch会有一个内核驱动，监听物理网卡，可以将物理网卡上收到的包拿进来。虚拟机创建出来的外部的虚拟网卡也可以添加到Openvswitch上，而Openvswitch可以设定各种的网络包处理策略，将网络包在虚拟机和物理机之间进行传递，从而实现了网络虚拟化。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7053789731051344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBcsWtHoEmhibA7hmWLVR1E2d6foBf1xficcW5NkHSg1VvstKMq7VR2FGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;      &lt;/p&gt;&lt;p&gt;对于Openvswitch，我主要是通过官方文档进行研究，写下了这个系列。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Openvswitch的入门篇&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484643&amp;amp;idx=1&amp;amp;sn=b89c3835032fa90beba8deeb5c0c23f6&amp;amp;chksm=ea1513c1dd629ad7fb54cdceb0ccde3a1950687ac4ca75ba08b562d4968f16ae5f222724ca7e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;通俗说Openvswitch&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Openvswitch的操作篇&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484172&amp;amp;idx=1&amp;amp;sn=cfe2ec15ba25a578e8559a5b6c2375ab&amp;amp;chksm=ea15142edd629d38e051e235c65a78a208b60647ae8c56c7371adf537acdb114fc41df525d0c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第一站：Manager和SSL&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484191&amp;amp;idx=1&amp;amp;sn=0e2a18318f692ea0f3a6fb8de1537740&amp;amp;chksm=ea15143ddd629d2b3ede245b9c5ef3736ef610b3cebd70438130007b9d34399bf6162938c231&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第二站：Bridge和Controller&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484221&amp;amp;idx=1&amp;amp;sn=c6fca0a0f6341dac7cf1af6e76876898&amp;amp;chksm=ea15141fdd629d0946e7f62d84e07b7f37eb5fe759f6c31d05dbafe0646c4c9a917805fc73b0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第四站：Bridge和Mirror&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=ce5d32691572ff55dd360da5606a495e&amp;amp;chksm=ea151462dd629d74d117873b9736763779e6cf2b25fc444c542f75c3d209c1e3f2d5fde32935&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第五站：Port和VLAN&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484225&amp;amp;idx=1&amp;amp;sn=e4e86b922d1a80b663e2b48906f24ab8&amp;amp;chksm=ea151463dd629d75f370775a3d6755fd93ae8f31e274300dabd9fb5ac5e93701a3bbfddbdfbf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第六站：Port和Bond&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484256&amp;amp;idx=1&amp;amp;sn=2af28261524c200a08bf645032621404&amp;amp;chksm=ea151442dd629d54a41a0923a882ef9b0c3d10f5336e09aaf3e74fcaa93709bee06cb9237476&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvwitch第七站：Port和QoS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484298&amp;amp;idx=1&amp;amp;sn=488e80cf5e37eddd08745e73e43a7982&amp;amp;chksm=ea1514a8dd629dbe22e0b7e82d78b2267b5c5f9c20ea9dfa309b09e4e0e41a7f3c7c49856229&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvswitch第八站：Interface和Tunnel (下)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484279&amp;amp;idx=1&amp;amp;sn=9060ba7f34ef8439facecd15950343e2&amp;amp;chksm=ea151455dd629d43493fffa81410855174cc9919db2c6a7db537ff73e0d7e99035abb0daaadb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvswitch第八站：Interface和Tunnel (上)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484268&amp;amp;idx=1&amp;amp;sn=53d7ffea92ddc43524a96e481f94fb3a&amp;amp;chksm=ea15144edd629d589a7717babc3a3409b8ccfd33fddc90e08d851c12d431eb5cd690b5756333&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvswitch第十站：Flow Table&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484300&amp;amp;idx=1&amp;amp;sn=541017e9185e7e6ab5fd9c2cb0b7ebc5&amp;amp;chksm=ea1514aedd629db8d2d6c7bfe07dd82dff7eaf146f168c997a70c28d2af8350fdbeba384cecb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;玩转Openvswitch之综合篇&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Openvswitch的代码分析篇&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484129&amp;amp;idx=1&amp;amp;sn=740d35e19dc44ba605d2c123c46414b3&amp;amp;chksm=ea1515c3dd629cd5b20a788b68e098e6a1fdc7f20bbb8702b65c34c227c7c13939b571c54a86&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;Openvswitch总体架构与代码结构&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484355&amp;amp;idx=1&amp;amp;sn=b3e2a5ef565e11482bbba9ff41a57aae&amp;amp;chksm=ea1514e1dd629df7f929550be4565158aad6bf00b096a5b1056b5b6d726b9c54c2956dfeb044&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;从Openvswitch代码看网络包的旅程&lt;/a&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;八、基于OpenStack了解云平台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当有了虚拟机，并且虚拟机能够上网了之后，接下来就是搭建云平台的时候了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云是基于计算，网络，存储虚拟化技术的，云和虚拟化的主要区别在于，管理员的管理模式不同，用户的使用模式也不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虚拟化平台没有多层次的丰富的租户管理，没有灵活quota配额的限制，没有灵活的QoS的限制，多采用虚拟网络和物理网络打平的桥接模式，虚拟机直接使用机房网络，没有虚拟子网VPC的概念，虚拟网络的管理和隔离不能和租户隔离完全映射起来。对于存储也是，公司采购了统一的存储，也不能和租户的隔离完全映射起来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用虚拟化平台的特点是，对于这个平台的操作完全由运维部门统一管理，而不能将权限下放给业务部门自己进行操作。因为一旦允许不同的部门自己操作，大家都用机房网络，在没有统一管控的情况下，很容易网段冲突了。如果业务部门向申请虚拟机，需要通过工单向运维部门统一的申请。当然这个运维部门很适应这种方式，因为原来物理机就是这样管理的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是公有云，例如aws就没办法这样，租户千千万万，只能他们自己操作。在私有云里面，随着服务化甚至微服务化的进行，服务数目越来越多，迭代速度越来越快，业务部门需要更加频繁的创建和消耗虚拟机，如果还是由运维部统一审批，统一操作，会使得运维部门压力非常大，而且极大限制了迭代速度，因而要引入 租户管理，运维部灵活配置每个租户的配额quota和QoS，在这个配额里面，业务部门随时可以按照自己的需要，创建和删除虚拟机，无需知会运维部门。每个部门都可以创建自己的虚拟网络VPC，不同租户的VPC之前完全隔离，所以网段可以冲突，每个业务部门自己规划自己的网络架构，只有少数的机器需要被外网或者机房访问的时候，需要少数的机房IP，这个也是和租户映射起来的，可以分配给业务部门机房网IP的个数范围内，自由的使用。这样每个部门自主操作，迭代速度就能够加快了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云平台中的开源软件的代表是OpenStack，建议大家研究OpenStack的设计机制，是在云里面通用的，了解了OpenStack，对于公有云，容器云，都能发现相似的概念和机制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;沿着OpenStack创建虚拟机的过程，我总结了100个知识点，写下了下面的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=8197b210fa170e24a82b0b9bb57e9405&amp;amp;chksm=ea1515ebdd629cfd1adf34c286d0d3a212ba1f6d258d8564eaf6342bee1edaeee08978ed2804&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;OpenStack虚拟机创建的50个步骤和100个知识点&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483860&amp;amp;idx=1&amp;amp;sn=c8b734a13c082ff5524e578fd1112847&amp;amp;chksm=ea1516f6dd629fe01e88d12552022eea94b0b43f523e2a4e68e24825de9d74b1c2bcccb4bd4f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;用OpenStack界面轻松创建虚拟机的你，看得懂虚拟机启动的这24个参数么？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=fee4910ef47cdf9ca769824cec2b8a59&amp;amp;chksm=ea15153fdd629c29dca985b103d718c551117c0c2329a29ef424fbc1a9acd2269d89cf2c36d7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;觉得OpenStack的网络复杂？其实你家里就有同样一个网络&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483947&amp;amp;idx=1&amp;amp;sn=c7a1fa0b9b032fb4c49bae6713f457d4&amp;amp;chksm=ea151509dd629c1f76264e9dbaf465639a4e269c67bdd41930d70cd5c9c043f666b0f57d1c73&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;当发现你的OpenStack虚拟机网络有问题，不妨先试一下这16个步骤&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483894&amp;amp;idx=1&amp;amp;sn=f200254bfe601a12101ab67f42ce090d&amp;amp;chksm=ea1516d4dd629fc2d1fded125b853e600a57eff00719d8521f0518d2c8b4bdf4ea667370fa52&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;手动用KVM模拟OpenStack Cinder挂载iSCSI卷&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484037&amp;amp;idx=1&amp;amp;sn=c2af1e4c163a006c759ea09ae347ae08&amp;amp;chksm=ea1515a7dd629cb1095376588a97d6fd40bce9488a0bed82a4802fa80ca9f4a19d23d0968013&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;不仅Docker会使用Control Group，KVM也会使用Cgroup来控制资源分配&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过我们研究OpenStack，我们会发现很多非常好的云平台设计模式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第一：基于PKI Token的认证模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果我们要实现一个Restful API，希望有个统一的认证中心的话，Keystone的三角形工作模式是常用的。&lt;/p&gt;&lt;p&gt;当我们要访问一个资源，通过用户名密码或者AK/SK登录之后，如果认证通过，接下来对于资源的访问，不应该总带着用户名密码，而是登录的时候形成一个Token，然后访问资源的时候带着Token，服务端通过Token去认证中心进行验证即可。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9690721649484536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBtqOGDwpl0kPEMFNeCL4nPJurmdnOLRl9lHmObvzewIUjeQ53bPHgQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;679&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果每次验证都去认证中心，效率比较差，后来就有了PKI Token，也即Token解密出来是一个有详细租户信息的字符串，这样本地就可以进行认证和鉴权。&lt;/p&gt;&lt;p&gt;&lt;span&gt;﻿&lt;span&gt;﻿&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9451776649746193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBicialWhR8sYSnibNq6ZzaaUmoXFTPjxtcqugxPacbMAVkTibzp3DVrV0ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;985&quot;/&gt;﻿&lt;/span&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第二：基于Role Based Access Control的鉴权模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于权限控制，我们学会比较通用的Role Based Access Control的权限控制模式，形成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系，可以非常灵活的控制权限。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.593900481540931&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBxBY8ialfKf4oPficib4gOBXSwjp989QYuAZiaBsxCIodOeJZBibibkRc2oNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第三：基于Quota的配额管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以通过设置计算，网络，存储的quota，设置某个租户自己可以自主操作的资源量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第四：基于预选和优选两阶段的Scheduler机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当需要从一个资源池里面，选择一个节点，使用这个节点上的资源的时候，一个通用的Scheduler机制是：&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBW5b5pSdicZbrcXe3PaSKFnWzduCwLmJyfjAjNO9NkqkibWfHmDf3xdGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第五：基于独立虚拟子网的网络模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了每个租户可以独立操作，因而虚拟网络应该是独立于物理网络的，这样不同的租户可以进行独立的网络规划而互不影响，也不影响物理网络，当需要跨租户访问，或者要访问物理网络的时候，需要通过路由器。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB5Vo9D9btShH0MQ0tQssdDj3TxJomaErVbnbiaJMfxdXGDkZ9VeXmuicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2750&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第六：基于Copy on Write的镜像机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有时候我们在虚拟机里面做了一些操作以后，希望能够把这个时候的镜像保存下来，好随时恢复到这个时间点，一个最最简单的方法就是完全复制一份，但是由于镜像太大了，这样效率很差。因而采取Copy on write的机制，当打镜像的时刻，并没有新的存储消耗，而是当写入新的东西的时候，将原来的数据找一个地方复制保存下来，这就是Copy on Write。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于Openstack，有一种镜像qcow2就是采取的这样的机制。&lt;/p&gt;&lt;p&gt;       &lt;img data-ratio=&quot;0.05927180355630821&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBjjDtQPuYrmUf3oDGoianc7qHmBZ4l01oOd9jIFy4baqA9ic8NpBcKNBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;      &lt;/p&gt;&lt;p&gt;这样镜像就像分层一样，一层一层的罗上去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第七：基于namespace和cgroup的隔离和Qos机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在OpenStack里面，网络节点的路由器是由network namespace来隔离的。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9571544058205336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBbsXAmof3NbWB0n6YlrBiaLYMh6umM1uuCbzoyC2POJGtialAZHV0ahKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1237&quot;/&gt;      &lt;/p&gt;&lt;p&gt;KVM的占用的CPU和内存，使用Cgroup来隔离的。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3993231810490694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBquPTHib4IP2KpKjMcu6VbneDoZ03jQ47ct2SiaDU2LJvkS3eibwmYdsEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;      &lt;/p&gt;&lt;p&gt;网络的QoS使用TC来隔离的。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5451505016722408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBV2DrFMgAeU1DS4x64VWHj4T2Bl4cr2XRw6fpV06fWboRWzG8wrnfDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;      &lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;第八：基于iptables的安全机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有时候，我们希望网络中的节点之间不能相互访问，作为最简单的防火墙，iptables起到了很重要的作用，以后实现ACL机制的，都可以考虑使用iptables。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4082304526748971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBVclgDqpsCM2X7OLO17E1Oo36VI9jMYBN90CukN9jZjO0GYue4CADcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1215&quot;/&gt;      &lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;九、基于Mesos和Kubernetes了解容器平台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;搭建完毕虚拟化层和云平台层，接下来就是容器层了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Docker有几个核心技术，一个是镜像，一个是运行时，运行时又分看起来隔离的namespace和用起来隔离的cgroup。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Docker的镜像也是一种Copy on Write的镜像格式，下面的层级是只读的，所有的写入都在最上层。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6031518624641834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBqQQRic0n0AOK1fA4PXDPLpGzA5WWsnC1fVtLq5xLn1ZP8Q9SsQQHUNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;      &lt;/p&gt;&lt;p&gt;对于运行时，Docker使用的namespace除了network namespace外，还有很多，如下表格所示。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2800925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBuZoJQWCribkHTsnTIIlg6kvM4qtM51dJJl50dwawA1XEu5x35pZaZibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;      &lt;/p&gt;&lt;p&gt;Docker对于cgroup的使用是在运行Docker的时候，在路径/sys/fs/cgroup/cpu/docker/下面控制容器运行使用的资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可见容器并没有使用更新的技术，而是一种新型的交付方式，也即应用的交付应该是一容器镜像的方式交付，容器一旦启动起来，就不应该进入容器做各种修改，这就是不可改变基础设施。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于容器的镜像不包含操作系统内核，因而小的多，可以进行跨环境的迁移和弹性伸缩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我写下了下面的文章，总结了几点容器的正确使用姿势。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484586&amp;amp;idx=1&amp;amp;sn=f10335c7926d9fa300c6fa90c5dc3e4c&amp;amp;chksm=ea151388dd629a9eb78bcc038a32cda074d8df171205a7631797417f8fa91bff9540099314c0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;容器化的本质？基于镜像的跨环境迁移&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484858&amp;amp;idx=1&amp;amp;sn=1b8c65da65285932cc44275e9c74a8cf&amp;amp;chksm=ea151298dd629b8e53581d4de4211d21021f0c923b08b43a000a9c1dc3b25c18c802bd35937e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;有关容器的六大误区和八大正确场景&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了容器之后，接下来就是容器平台的选型，其实swarm, mesos, kubernetes各有优势，也可以在不同的阶段，选择使用不同的容器平台。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484465&amp;amp;idx=1&amp;amp;sn=a2bfa705daa5f74315ca30a5d5c63d6d&amp;amp;chksm=ea151313dd629a055f1c522203ed59532e7087d12a08e85eb971a801fa0d51522b03e84844e0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;Docker, Kubernetes, DCOS 不谈信仰谈技术&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484679&amp;amp;idx=1&amp;amp;sn=60344c7d43fd8a90324f4f90b9f83aad&amp;amp;chksm=ea151225dd629b33ad01036012457b0afcd43781c694c6e50c720e8156cba6bc4fb1a524c7ab&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;容器平台选型的十大模式：Docker、DC/OS、K8S谁与当先？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于Mesos的DCOS更像是一个数据中心管理平台，而非仅仅容器管理平台，他可以兼容Kubernetes的编排，同时也能跑各种大数据应用。&lt;/p&gt;&lt;p&gt;            &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484124&amp;amp;idx=1&amp;amp;sn=273fc3ae5ecb3849b5e5250e2d5b88d4&amp;amp;chksm=ea1515fedd629ce89ea7d52473c5f7b140dd4f3bc31a23db8fe00f0103b3e0d433db033163f6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;DC/OS的基本思想——为什么说他是数据中心操作系统&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484131&amp;amp;idx=1&amp;amp;sn=c7e94f5a6885733cd5cd79436a22c540&amp;amp;chksm=ea1515c1dd629cd73c0f391ecf39d70e11c2e0592e9826d71cff191bc1db935b48eca64929a6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;号称了解mesos双层调度的你，先来回答下面这五个问题！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484141&amp;amp;idx=1&amp;amp;sn=70d1f0c09e3db3a22c6a58aa2fd05f44&amp;amp;chksm=ea1515cfdd629cd97fc4233aafec4778faf45fef7ae0f2e4ba8dfcbc92c45fce2a99890531cb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;DC/OS的容器功能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484222&amp;amp;idx=1&amp;amp;sn=28474c23a78723a9eec835e2ae5aa350&amp;amp;chksm=ea15141cdd629d0a7f5f4ddea944dcf368d7113f0283216b4d3839a98e4b19fd528fd19c1154&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;DC/OS的网络功能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484223&amp;amp;idx=1&amp;amp;sn=a20cdd1976ae194a6c552222ddf27ce1&amp;amp;chksm=ea15141ddd629d0b422a34a50f436882ba28dd6b337c4627a4e83bc7ad0eea2975a4dcfc11b2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;DC/OS的存储功能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484226&amp;amp;idx=1&amp;amp;sn=7fcbef9bfdb808eb47011e94643c0132&amp;amp;chksm=ea151460dd629d764125302643591babbdbf8d2d6965c1a0b3d710628b0f4bbf8ceaba4aaf89&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;DC/OS的服务发现与负载均衡功能&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在容器领域，基于Kubernetes的容器编排已经成为事实标准。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7334123222748815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxByibbuzQ03vYibpSGHibXQtERImypLUiajQOj6IicII5Q3P8CN8DDcc1iaojg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1688&quot;/&gt;      &lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4OTMxODQwNA==&amp;amp;mid=2650978674&amp;amp;idx=1&amp;amp;sn=12ed6c7ffb7a48fb56f954d062c58563&amp;amp;chksm=8beaac19bc9d250f6c9e635f70e11fa38e5e90d0a6a5958ead45d4536bfbeef85b35f28868d5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;基于万节点Kubernetes支撑大规模云应用实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484377&amp;amp;idx=1&amp;amp;sn=28a1ecd0227157c86dab453b955f71f3&amp;amp;chksm=ea1514fbdd629dedb8054305b5084adfa93ec46bb2efd6bec880fd7d3c91acb5abc2935fb28f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;支撑大规模公有云的Kubernetes改进与优化 (1)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484394&amp;amp;idx=1&amp;amp;sn=cab696bf16eadfe6b6a664a3e655691c&amp;amp;chksm=ea1514c8dd629dde24c2294c06e239de03d3ed2701b1c9b1f000079eab668c3715f65194ebbb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;支撑大规模公有云的Kubernetes改进与优化 (2)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484418&amp;amp;idx=1&amp;amp;sn=d1d8c2420391830c46d15b0d8b9d2050&amp;amp;chksm=ea151320dd629a36f9129b506dcbd81cda152268a9791999da307967123f6ec0d5581b114a40&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;支撑大规模公有云的Kubernetes改进与优化 (3)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484636&amp;amp;idx=1&amp;amp;sn=eec7ea7a8ea847cf4bb7f7a41128bc7c&amp;amp;chksm=ea1513fedd629ae8f4eca6babdc8a3866f931867a1156897ce5bbb6d0b4b85272f4e11b8d528&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;为支撑高并发应用的 Kubernetes 的性能优化&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我们深入分析Kubernetes管理容器模式的时候，我们也能看到熟悉的面孔。&lt;/p&gt;&lt;p&gt;在Kubernetes里面，租户之间靠namespace进行隔离，这个不是Docker的namespace，而是Kubernetes的概念。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;API Server的鉴权，也是基于Role Based Access Control模式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Kubernetes对于namespace，也有Quota配置，使用ResourceQuota。&lt;/p&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6852791878172588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBh4jxE5VD1WMmAAjllITTrd34hd2ibXYbibZS3GYxZwqnHIcKUSAZ4xOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当Kubernetes想选择一个节点运行pod的时候，选择的过程也是通过预选和优选两个阶段。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Kubernetes规定了以下的网络模型定义。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也即容器平台应该有自己的私有子网，常用的有Flannel, Calico, Openvswitch都是可以的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既可以使用Overlay的方式，如图flannel.&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39325842696629215&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBGSlWIZVooDIRlwGAwjLQaGoRxBrRIFD6Q6gMAeeugSxxjVlaC3b7gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1869&quot;/&gt;      &lt;/p&gt;&lt;p&gt;也可以使用BGP的方式，如图Calico&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.214928057553957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBanfDTmEbN6VY2ES1Jjib6d5SwjDuAytmoebqXLVux0JQJkjnrl6JHtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;      &lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;十、基于Hadoop和Spark了解大数据平台&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于数据架构的部分，其实经历了三个过程，分别是Hadoop Map-Reduce 1.0，基于Yarn的Map-Reduce 2.0, 还有Spark。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图是Map-Reduce 1.0的过程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0418353576248314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBSia2eBLapugHegYSmJAX4GsLnhXHsJBtzicuiacIXCQleKsAefJNmxfYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;741&quot;/&gt;      &lt;/p&gt;&lt;p&gt;Map-Reduce的过程将一个大任务，split称为多个Map Task，分散到多台机器并行处理，将处理的结果保存到本地，第二个阶段，Reduce Task将中间结果拷贝过来，将结果集中处理，取得最终结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在Map-Reduce 1.0的时候，跑任务的方式只有这一种，为了应对复杂的场景，将任务的调度和资源的调度分成两层。其中资源的调用由Yarn进行，Yarn不管是Map还是Reduce，只要向他请求，他就找到空闲的资源分配给他。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个任务启动的时候，专门启动一个Application Master，管理任务的调度，他是知道Map和Reduce的。这就是Map-Reduce 2.0如下图。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.650595575723199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBmLyS850h2RvhGnHeYauQMyRzEvJ2YvoxJ051DBJTaZVH8WGqZ5FvoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1763&quot;/&gt;      &lt;/p&gt;&lt;p&gt;这里Yarn相当于外包公司的老板，所有的员工都是worker，都是他的资源，外包公司的老板是不清楚接的每一个项目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Application Master相当于接的每个项目的项目经理，他是知道项目的具体情况的，他在执行项目的时候，如果需要员工干活，需要向外包公司老板申请。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Yarn是个通用的调度平台，能够跑Map-Reduce 2，就能跑Spark。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5778947368421052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBcXJ82b3FyFSibmzABgojltPdPFru6JNAkj269mrVeH4CSoLEzePWRibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;950&quot;/&gt;      &lt;/p&gt;&lt;p&gt;Spark也是创建Spark自己的Application Master，用于调度任务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Spark之所以比较快，是因为前期规划做的好，不是像Map-Reduce一样，每一次分配任务和聚合任务都要写一次硬盘，而是将任务分成多个阶段，将所有在一个Map都做了的合成一个阶段，这样中间不用落盘，但是到了需要合并的地方，还是需要落盘的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于Hadoop和Spark的基本原理，我写了下面的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484663&amp;amp;idx=1&amp;amp;sn=d1640a05ae66b3afbb7804e1a59f3b06&amp;amp;chksm=ea1513d5dd629ac35d655b9c02727b1fc73f6d2835cebcb921d878582a93a345fa5da3c27aa8&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;通俗说基于Yarn的Map-Reduce过程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484684&amp;amp;idx=1&amp;amp;sn=ea3d63bba137773efd1290bab7b7ed89&amp;amp;chksm=ea15122edd629b3899c933d09633de4dbb58eba7a634fd16d2d5a64598f68621d976be79d8ae&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;通俗说Spark&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;真正写Map-Reduce程序的时候，有很多的方法论，这里我总结了几个，供您参考。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484556&amp;amp;idx=1&amp;amp;sn=d193aa5f25475eec7841fc23c025277a&amp;amp;chksm=ea1513aedd629ab8f0f0af8300324c3f9b41e5f5cd8e73650cea71f642e1924ca8d6f7f80441&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;大数据方法论之优化Map-Reduce过程&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484550&amp;amp;idx=1&amp;amp;sn=1147bad161a97b8c2aca5fc831b4d958&amp;amp;chksm=ea1513a4dd629ab2121e38d591c85fd39a08871cc92baa572d4d53185386ea49b138c2e6a4a1&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;大数据方法论之网页消重的Map-Reduce算法&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484541&amp;amp;idx=1&amp;amp;sn=45f9028c7a9a209ebc8b78e83b338498&amp;amp;chksm=ea15135fdd629a49b5206c57799071363719f5bec1835f612fc58afaa35a9a7d182f090cdee7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;大数据方法论之PageRank的Map-Reduce计算&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=f8295cf876239bfced29c6aae3210a1b&amp;amp;chksm=ea151353dd629a45ded62dd6c873c6f3cb7522b01b145abd9e52bbcb14c57cfccf705b8a92ff&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;大数据方法论之Nutch基于Map-Reduce的爬取方法&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;十一、基于Lucene和ElasticSearch了解搜索引擎&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5704545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtkdK1C6TdzrGQfBMibDPibAUIjLrUa8zywkNQCv8VFGIHd1CfBFNtC8A1x1yPCAN3rbw27md0FgH1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;880&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当大数据将收集好的数据处理完毕之后，一般会保存在两个地方，一个是正向索引，可以用Hbase，Cassandra等文档存储，一个是反向索引，方便搜索，就会保存在基于Lucene的ElasticSearch里面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于Lucene，在职业生涯的早期，写过一个《Lucene 原理与代码分析完整版》有500多页。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于搜索引擎的通用原理，写了下面的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483678&amp;amp;idx=1&amp;amp;sn=0d2e8d5aa353aa1f1e9f7537d7210c62&amp;amp;chksm=ea15163cdd629f2aa5e0cb740994f14d42f6f749dd40db614f15a264a8e33732cca010c0648c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;不是技术也能看懂搜索引擎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483753&amp;amp;idx=1&amp;amp;sn=69e4ce9e4d3218a983296bf5d40d72ca&amp;amp;chksm=ea15164bdd629f5d54e3c8456593c6c38ae6ce9383199179f1527a7ed1d81d0deb77be71ba71&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;搜索引擎的设计(1)：词典的设计&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483805&amp;amp;idx=1&amp;amp;sn=32343cb7ea16378cc149bd762f752c13&amp;amp;chksm=ea1516bfdd629fa9245db9e8badfe873038635940a8f64e372f4c1f39987330c7ec599f87fd0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;搜索引擎的设计(2)：倒排表的设计上&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247483810&amp;amp;idx=1&amp;amp;sn=e03cea594491c9235580c20b5433c8a7&amp;amp;chksm=ea151680dd629f96b8b555bef214f8e0edda0c297ce9625cd1f006923ea3e0206218cf25ccab&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;搜索引擎的设计(3)：倒排表的设计下&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;十二、基于SpringCloud了解微服务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后到了应用架构，也即微服务。&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.496875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB7oLUewYXswFBt84DBQ4nSkibn5CF57JMEEJ9tJgpOCRicpMjKCTvp6wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;      &lt;/p&gt;&lt;p&gt;接下来细说微服务架构设计中不得不知的十大要点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点一：负载均衡 + API 网关&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43833333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBpPsoO6Q89e2iadEsjoOQZDFLpLhV0ibSGP8X3RxN6Y0odib0xYibjrcoqQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;在实施微服务的过程中，不免要面临服务的聚合与拆分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当后端服务的拆分相对比较频繁的时候，作为手机 App 来讲，往往需要一个统一的入口，将不同的请求路由到不同的服务，无论后面如何拆分与聚合，对于手机端来讲都是透明的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了 API 网关以后，简单的数据聚合可以在网关层完成，这样就不用在手机 App 端完成，从而手机 App 耗电量较小，用户体验较好。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了统一的 API 网关，还可以进行统一的认证和鉴权，尽管服务之间的相互调用比较复杂，接口也会比较多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;API 网关往往只暴露必须的对外接口，并且对接口进行统一的认证和鉴权，使得内部的服务相互访问的时候，不用再进行认证和鉴权，效率会比较高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了统一的 API 网关，可以在这一层设定一定的策略，进行 A/B 测试，蓝绿发布，预发环境导流等等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;API 网关往往是无状态的，可以横向扩展，从而不会成为性能瓶颈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点二：无状态化与独立有状态集群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBVw42SicvY2xmxRXO2vAeP9vuibObcticgIib7c7a856SGNxiaRwdxmf21ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt; &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;影响应用迁移和横向扩展的重要因素就是应用的状态。无状态服务，是要把这个状态往外移，将 Session 数据，文件数据，结构化数据保存在后端统一的存储中，从而应用仅仅包含商务逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;状态是不可避免的，例如 ZooKeeper，DB，Cache 等，把这些所有有状态的东西收敛在一个非常集中的集群里面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整个业务就分两部分，一个是无状态的部分，一个是有状态的部分。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;无状态的部分能实现两点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有状态的部分，如 ZooKeeper，DB，Cache 有自己的高可用机制，要利用到它们自己高可用的机制来实现这个状态的集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽说无状态化，但是当前处理的数据，还是会在内存里面的，当前的进程挂掉数据，肯定也是有一部分丢失的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了实现这一点，服务要有重试的机制，接口要有幂等的机制，通过服务发现机制，重新调用一次后端服务的另一个实例就可以了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点三：数据库的横向扩展&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB5HCVq2guibFqaGm7Tiau8JGGGjntRwIV2qbs5jq41UTg1ic51LM174ibKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;数据库是保存状态，是最重要的也是最容易出现瓶颈的。有了分布式数据库可以使数据库的性能随着节点增加线性地增加。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分布式数据库最最下面是 RDS，是主备的，通过 MySQL 的内核开发能力，我们能够实现主备切换数据零丢失。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以数据落在这个 RDS 里面，是非常放心的，哪怕是挂了一个节点，切换完了以后，你的数据也是不会丢的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再往上就是横向怎么承载大的吞吐量的问题，上面有一个负载均衡 NLB，用  LVS，HAProxy，Keepalived，下面接了一层 Query Server。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Query Server 是可以根据监控数据进行横向扩展的，如果出现了故障，可以随时进行替换的修复，对于业务层是没有任何感知的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个就是双机房的部署，DDB 开发了一个数据运河 NDC 的组件，可以使得不同的 DDB 之间在不同的机房里面进行同步。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这时候不但在一个数据中心里面是分布式的，在多个数据中心里面也会有一个类似双活的一个备份，高可用性有非常好的保证。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点四：缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5116666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBqFEf2bx6icJCpTEyxF7WZQ5RGv5qfOrIIbegSooPRdZuDlIZicajazAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;在高并发场景下缓存是非常重要的。要有层次的缓存，使得数据尽量靠近用户。数据越靠近用户能承载的并发量也越大，响应时间越短。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在手机客户端 App 上就应该有一层缓存，不是所有的数据都每时每刻从后端拿，而是只拿重要的，关键的，时常变化的数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;尤其对于静态数据，可以过一段时间去取一次，而且也没必要到数据中心去取，可以通过 CDN，将数据缓存在距离客户端最近的节点上，进行就近下载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有时候 CDN 里面没有，还是要回到数据中心去下载，称为回源，在数据中心的最外层，我们称为接入层，可以设置一层缓存，将大部分的请求拦截，从而不会对后台的数据库造成压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果是动态数据，还是需要访问应用，通过应用中的商务逻辑生成，或者去数据库读取，为了减轻数据库的压力，应用可以使用本地的缓存，也可以使用分布式缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如 Memcached 或者 Redis，使得大部分请求读取缓存即可，不必访问数据库。&lt;/p&gt;&lt;p&gt;当然动态数据还可以做一定的静态化，也即降级成静态数据，从而减少后端的压力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点五：服务拆分与服务发现&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBYP7EgxsKYrbrZmYNhOZRQjbsfYF2yzt1hM64LhxW7sp1LOn0K7gHIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当系统扛不住，应用变化快的时候，往往要考虑将比较大的服务拆分为一系列小的服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这样第一个好处就是开发比较独立，当非常多的人在维护同一个代码仓库的时候，往往对代码的修改就会相互影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;常常会出现我没改什么测试就不通过了，而且代码提交的时候，经常会出现冲突，需要进行代码合并，大大降低了开发的效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一个好处就是上线独立，物流模块对接了一家新的快递公司，需要连同下单一起上线，这是非常不合理的行为。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我没改还要我重启，我没改还让我发布，我没改还要我开会，都是应该拆分的时机。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再就是高并发时段的扩容，往往只有最关键的下单和支付流程是核心，只要将关键的交易链路进行扩容即可，如果这时候附带很多其他的服务，扩容既是不经济的，也是很有风险的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外的容灾和降级，在大促的时候，可能需要牺牲一部分的边角功能，但是如果所有的代码耦合在一起，很难将边角的部分功能进行降级。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然拆分完毕以后，应用之间的关系就更加复杂了，因而需要服务发现的机制，来管理应用相互的关系，实现自动的修复，自动的关联，自动的负载均衡，自动的容错切换。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点六：服务编排与弹性伸缩&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBNIjTibInFLsiaXfd2Buo0XIHqORdIznRqtpWtmGMiaEht3FRvicQsJrQzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当服务拆分了，进程就会非常的多，因而需要服务编排来管理服务之间的依赖关系，以及将服务的部署代码化，也就是我们常说的基础设施即代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这样对于服务的发布，更新，回滚，扩容，缩容，都可以通过修改编排文件来实现，从而增加了可追溯性，易管理性，和自动化的能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;既然编排文件也可以用代码仓库进行管理，就可以实现一百个服务中，更新其中五个服务，只要修改编排文件中的五个服务的配置就可以。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当编排文件提交的时候，代码仓库自动触发自动部署升级脚本，从而更新线上的环境。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当发现新的环境有问题时，当然希望将这五个服务原子性地回滚，如果没有编排文件，需要人工记录这次升级了哪五个服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了编排文件，只要在代码仓库里面 Revert，就回滚到上一个版本了。所有的操作在代码仓库里都是可以看到的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点七：统一配置中心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBvhIccACQcJ5KqRMfOVRcyBbXasdVmNdogoiaTwjBNbnCmtPZkKm2bfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;服务拆分以后，服务的数量非常多，如果所有的配置都以配置文件的方式放在应用本地的话，非常难以管理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以想象当有几百上千个进程中有一个配置出现了问题，是很难将它找出来的，因而需要有统一的配置中心，来管理所有的配置，进行统一的配置下发。&lt;/p&gt;&lt;p&gt;在微服务中，配置往往分为以下几类：&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;设计要点八：统一日志中心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBMhA1FN880XsEzxMZrDQyhqjHPSWbmafoeG9nIOFXgQNLpiasGicJNSzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;同样是进程数目非常多的时候，很难对成千上百个容器，一个一个登录进去查看日志，所以需要统一的日志中心来收集日志。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了使收集到的日志容易分析，对于日志的规范，需要有一定的要求，当所有的服务都遵守统一的日志规范的时候，在日志中心就可以对一个交易流程进行统一的追溯。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如在最后的日志搜索引擎中，搜索交易号，就能够看到在哪个过程出现了错误或者异常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点九：熔断，限流，降级&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48833333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxBBq6vyFSnDagpfTUcxZBGIR7GibLaac9XxbM5N9KICGtYKMxxOiaBvyJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;服务要有熔断，限流，降级的能力，当一个服务调用另一个服务，出现超时的时候，应及时返回，而非阻塞在那个地方，从而影响其他用户的交易，可以返回默认的托底数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当一个服务发现被调用的服务，因为过于繁忙，线程池满，连接池满，或者总是出错，则应该及时熔断，防止因为下一个服务的错误或繁忙，导致本服务的不正常，从而逐渐往前传导，导致整个应用的雪崩。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当发现整个系统的确负载过高的时候，可以选择降级某些功能或某些调用，保证最重要的交易流程的通过，以及最重要的资源全部用于保证最核心的流程。&lt;/p&gt;&lt;p&gt;还有一种手段就是限流，当既设置了熔断策略，又设置了降级策略，通过全链路的压力测试，应该能够知道整个系统的支撑能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因而就需要制定限流策略，保证系统在测试过的支撑能力范围内进行服务，超出支撑能力范围的，可拒绝服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你下单的时候，系统弹出对话框说 “系统忙，请重试”，并不代表系统挂了，而是说明系统是正常工作的，只不过限流策略起到了作用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;设计要点十：全方位的监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HO2NI1o25ZbZAN9Kbl4EDJ6EHH5FonxB72Nnn3pPSH6JWZrwc6agV62fliaYMAJBNE8FVw4hFoLibWwof0g70owQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;      &lt;/p&gt;&lt;p&gt;当系统非常复杂的时候，要有统一的监控，主要有两个方面，一个是是否健康，一个是性能瓶颈在哪里。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当系统出现异常的时候，监控系统可以配合告警系统，及时地发现，通知，干预，从而保障系统的顺利运行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当压力测试的时候，往往会遭遇瓶颈，也需要有全方位的监控来找出瓶颈点，同时能够保留现场，从而可以追溯和分析，进行全方位的优化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我会将微服务相关的文章更加细化的写出来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484925&amp;amp;idx=1&amp;amp;sn=5c15ba98fb03a2a0d9c823136f34e162&amp;amp;chksm=ea1512dfdd629bc9971b4ec7ccc6d2c844fee66a7b7fc1a25a7cf78467996d76b5ef33e56190&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化之服务拆分与服务发现&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484868&amp;amp;idx=1&amp;amp;sn=5e6a6960557e373b4e21afa05f9a49ab&amp;amp;chksm=ea1512e6dd629bf0e53545da90b761965033ed1447db0a4d22d5c6a70b4c4364ef443c5aa3e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化之缓存的设计&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484852&amp;amp;idx=1&amp;amp;sn=bf08e717f6d0b4dde432109753c00f36&amp;amp;chksm=ea151296dd629b80fbf9d623b7fa7c8c063b9bfab74913ca3e7e7eb3daf0bfa331e7125678de&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化之无状态化与容器化&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484821&amp;amp;idx=1&amp;amp;sn=1d73b718ddb6bcbdd28a7fa98d7dcda0&amp;amp;chksm=ea1512b7dd629ba12412b22a213f281638b2e21161938fbb82c176a2b8a869753afa46a841f6&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化的数据库设计与读写分离&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484791&amp;amp;idx=1&amp;amp;sn=4cb4fb04b481c3aee8a882934c8d925f&amp;amp;chksm=ea151255dd629b43c6383d912234ae0d53fad34e354fdf985a6461aa2774deaf313a234d64fb&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务的接入层设计与动静资源隔离&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484778&amp;amp;idx=1&amp;amp;sn=f3a29677d7030370fdd9b8931a0449d0&amp;amp;chksm=ea151248dd629b5e1439bc4fa84411cdb5444d0bf0e8c09267a868fcb18f78602482dea51107&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化的基石——持续集成&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有关微服务和容器之间的结合，写了下面的文章。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=4c40df039911e7ef7d355c1435271eb0&amp;amp;chksm=ea1512e5dd629bf368bae145c6c42ad89f260c529d0eb006779768c6f124e0318b653d2d1821&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;为什么 kubernetes 天然适合微服务&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4OTMxODQwNA==&amp;amp;mid=2650979597&amp;amp;idx=1&amp;amp;sn=9e0af66461cda850f52b36dc19485a90&amp;amp;chksm=8beaa866bc9d21703846ab3e2da25096859083d89852a447bb7ecdbc2f6a71a7e0cc92d8245a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;微服务化不同阶段 Kubernetes 的不同玩法&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4OTMxODQwNA==&amp;amp;mid=2650979578&amp;amp;idx=1&amp;amp;sn=2fdde4f1b73472c306abc7d670b80077&amp;amp;chksm=8beaa991bc9d20870506fca421f61aaf33c006b709cd18cb18bab403e3a1eb3504b80a0f775d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;金融创新业务基于容器云的微服务化实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484901&amp;amp;idx=1&amp;amp;sn=810eb4f09a3412a805d480814a2c9560&amp;amp;chksm=ea1512c7dd629bd1f236357813113755eba51f1f4aaa1d389ec47a06ae116e8549db9de00fa3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;深入解读Service Mesh背后的技术细节&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI1NzYzODk4OQ==&amp;amp;mid=2247484954&amp;amp;idx=1&amp;amp;sn=7cfb13dd227f902fdae5b43e461e251e&amp;amp;chksm=ea151138dd62982e6690b245163e9d16db29d8abf3e4b13f0700490a802ec8804f1ae0766891&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener noreferrer nofollow&quot; data-linktype=&quot;2&quot;&gt;深入解读Service Mesh的数据面Envoy&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;小弟参加GIAC年度新人评选，马了这么多字，能帮忙投个票吗？请点击原文连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;刘超 网易云技术架构部总监&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;长期致力于云计算开源技术的分享，布道和落地，将网易内部最佳实践服务客户与行业。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术分享：出版《Lucene应用开发解密》，极客时间专栏《趣谈网络协议》，个人公众号《刘超的通俗云计算》文章Kubernetes及微服务系列18篇，Mesos系列30篇，KVM系列25篇，Openvswitch系列31篇，OpenStack系列24篇，Hadoop系列10篇。公众号文章《终于有人把云计算，大数据，人工智能讲明白了》累积10万+&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大会布道：InfoQ架构师峰会明星讲师，作为邀请讲师在QCon，LC3，SACC，GIAC，CEUC，SoftCon，NJSD等超过10场大型技术峰会分享网易的最佳实践&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;行业落地：将网易的容器和微服务产品在银行，证券，物流，视频监控，智能制造等多个行业落地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;技术琐话 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;188&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;188&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWEup6pcFSoqDWX2CnKtr2ibick4zKc3GbnGwOU6OfRibTYDbP4ueZgYDVIQX96Wic9KibEX710j1jsqWicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1b1aafcf8e24624cc5e51f5e0cfacc4c</guid>
<title>图片不压缩，前端要背锅</title>
<link>https://toutiao.io/k/w3um3sg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;56&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：JustCarryOn&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://juejin.cn/post/7153086294409609229&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/sz_mmbiz/2A8tXicCG8ymRVice8ZMkq935DJ6ZTeoLRKH3uLG2mHdWdHMo7icP6vy4a7iamRlr5QonVoVy7szqdj6f65TuibhYlA/0?wx_fmt=other&quot; data-cropx1=&quot;54.19354838709677&quot; data-cropx2=&quot;2953.548387096774&quot; data-cropy1=&quot;390.19354838709677&quot; data-cropy2=&quot;1300.6451612903224&quot; data-ratio=&quot;0.31296296296296294&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/2A8tXicCG8ymRVice8ZMkq935DJ6ZTeoLRlTYFFE7RM6ADt23MwuTAxISjzOn1TsibUOEN4BxbktRGnJIw4VcESAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，这次要聊的主题是「图片压缩」。在一般页面里面，使用最多的「静态素材」非图片莫属了，这次轮到对它动手 👊 ！&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🎨(美术): 这是这次需求的切图 📁 ，你看看有没问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🧑‍💻(前端): 好的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面上线 ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🧑‍💼(产品): 这图片怎么半天加载不出来 💢 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🧑‍💻(前端): 我看看 🤔 (卑微)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;... 📁(size: 15MB)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;🧑‍💻(前端): 😅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们从 &lt;code&gt;PS&lt;/code&gt; 、&lt;code&gt;蓝湖&lt;/code&gt;或&lt;code&gt;摹客&lt;/code&gt;等工具导出来的图片，或者是美术直接给到切图，都是未经过压缩的，体积都比较大。这里，就有了可优化的空间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TinyPng&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;TinyPNG&lt;/code&gt;使用智能的「有损压缩技术」来减少&lt;code&gt;WEBP&lt;/code&gt;、&lt;code&gt;JPEG&lt;/code&gt;和&lt;code&gt;PNG&lt;/code&gt;文件的文件大小。通过选择性地减少图像中的「颜色数量」，使用更少的字节来存储数据。这种效果几乎是看不见的，但在文件大小上有非常大的差别。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用过TinyPng的都知道，它的压缩效果非常好，体积大幅度降低且显示效果几乎没有区别( 👀 看不出区别）。因此，选择其作为压缩工具，是一个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TinyPng&lt;/code&gt;提供两种压缩方法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过在官网上进行手动压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过官方提供的&lt;code&gt;tinify&lt;/code&gt;进行压缩；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;身为一个程序员 🧑‍💻 ，是不能接受手动一张张上传压缩这种方法的。因此，选择第二种方法，通过封装一个工具，对项目内的图片自动压缩，彻底释放双手 🤲 。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;工具类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，思考这个工具的「目的」是什么？没错，「压缩图片」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，思考在哪个「环节」进行压缩？没错，「发布前」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样看来，开发一个&lt;code&gt;webpack plugin&lt;/code&gt;是一个不错选择，在打包「生产环境」代码的时候，启用该&lt;code&gt;plugin&lt;/code&gt;对图片进行处理，完美 🥳 ！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这样会面临两个问题 🤔 ：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;页面迭代，新增了几张图片，重新打包上线时，会导致旧图片被多次压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无法选择哪些图片要被压缩，哪些图片不被压缩；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然可以通过「配置」的方式解决上述问题，但每次打包都要特殊配置，略显麻烦，这样看来&lt;code&gt;plugin&lt;/code&gt;好像不是最好的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上两个问题，使用「命令行工具」就能完美解决。在打包「生产环境」代码之前，执行「压缩命令」，通过命令行交互，选择需要压缩的图片。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效果演示&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，先上才艺 💃 ！&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;安装&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ &lt;span&gt;npm&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;yx-tiny&lt;/span&gt; &lt;span&gt;-D&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ npx tiny &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据命令行提示输入&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程：输入「文件夹名称-&lt;code&gt;tinyImg&lt;/code&gt;」，接着工具会找到当前项目下所有的&lt;code&gt;tinyImg&lt;/code&gt;，接着选择一或多个&lt;code&gt;tinyImg&lt;/code&gt;，紧接着，工具会找出&lt;code&gt;tinyImg&lt;/code&gt;下所有的&lt;code&gt;png&lt;/code&gt;、&lt;code&gt;jpe?g&lt;/code&gt;和&lt;code&gt;svga&lt;/code&gt;，最后选择压缩模式「全量」或「自定义」，选择需要压缩的图片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从最后的输出结果可以看到，压缩前的资源体积为&lt;code&gt;2.64MB&lt;/code&gt;，压缩后体积为&lt;code&gt;1.02MB&lt;/code&gt;，足足压缩了&lt;code&gt;1.62MB&lt;/code&gt; 👍 ！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现思路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体分为五个过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;查找：找出所有的图片资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配：均分任务到每个进程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上传：把原图上传到&lt;code&gt;TinyPng&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下载：从&lt;code&gt;TinyPng&lt;/code&gt;中下载压缩好的图片；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写入：用下载的图片覆盖本地图片；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：&lt;span&gt;yx-tiny&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查找&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找出所有的图片资源。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/index.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 递归找出所有图片&lt;br/&gt; * @param { string } path&lt;br/&gt; * @returns { Array&amp;lt;imageType&amp;gt; }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IdeepFindImg {&lt;br/&gt;  (path: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Array&lt;/span&gt;&amp;lt;imageType&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; deepFindImg: IdeepFindImg&lt;br/&gt;deepFindImg = &lt;span&gt;(&lt;span&gt;path: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 读取文件夹的内容&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; content = fs.readdirSync(path)&lt;br/&gt;  &lt;span&gt;// 用于保存发现的图片&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; images: &lt;span&gt;Array&lt;/span&gt;&amp;lt;imageType&amp;gt; = []&lt;br/&gt;  &lt;span&gt;// 遍历该文件夹内容&lt;/span&gt;&lt;br/&gt;  content.forEach(&lt;span&gt;&lt;span&gt;folder&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; filePath = resolve(path, folder)&lt;br/&gt;    &lt;span&gt;// 获取当前内容的语法信息&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; info = fs.statSync(filePath)&lt;br/&gt;    &lt;span&gt;// 当前内容为“文件夹”&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (info.isDirectory()) {&lt;br/&gt;      &lt;span&gt;// 对该文件夹进行递归操作&lt;/span&gt;&lt;br/&gt;      images = [...images, ...deepFindImg(filePath)]&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; fileNameReg = &lt;span&gt;/\.(jpe?g|png|svga)$/&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; shouldFormat = fileNameReg.test(filePath)&lt;br/&gt;      &lt;span&gt;// 判断当前内容的路径是否包含图片格式&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (shouldFormat) {&lt;br/&gt;        &lt;span&gt;// 读取图片内容保存到images&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; imgData = fs.readFileSync(filePath)&lt;br/&gt;        images.push({&lt;br/&gt;          path: filePath,&lt;br/&gt;          file: imgData&lt;br/&gt;        })&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; images&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过命令行交互后，拿到目标文件夹的路径&lt;code&gt;path&lt;/code&gt;，然后获取该&lt;code&gt;path&lt;/code&gt;下的所有内容，接着遍历所有内容。首先判断该内容的文件信息：若为“文件夹”，则把该文件夹路径作为&lt;code&gt;path&lt;/code&gt;，递归调用&lt;code&gt;deepFindImg&lt;/code&gt;；若不为“文件夹”，判断该内容为图片，则读取图片数据，&lt;code&gt;push&lt;/code&gt;到&lt;code&gt;images&lt;/code&gt;中。最后，返回所有找到的图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分配&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;均分任务到每个进程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/index.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;cluster.setupPrimary({&lt;br/&gt;    exec: resolve(__dirname, &lt;span&gt;&#x27;features/process.js&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 若资源数小于则创建一个进程，否则创建多个进程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; works: &lt;span&gt;Array&lt;/span&gt;&amp;lt;{&lt;br/&gt;    work: Worker;&lt;br/&gt;    tasks: &lt;span&gt;Array&lt;/span&gt;&amp;lt;imageType&amp;gt;&lt;br/&gt;}&amp;gt; =[]&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (list.length &amp;lt;= cpuNums) {&lt;br/&gt;    works.push({&lt;br/&gt;        work: cluster.fork(),&lt;br/&gt;        tasks: list&lt;br/&gt;    })&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cpuNums; ++i) {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; work = cluster.fork()&lt;br/&gt;        works.push({&lt;br/&gt;            work,&lt;br/&gt;            tasks: []&lt;br/&gt;        })&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 平均分配任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; workNum = &lt;span&gt;0&lt;/span&gt; &lt;br/&gt;list.forEach(task = &amp;gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (works.length === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workNum &amp;gt;= works.length) {&lt;br/&gt;        works[&lt;span&gt;0&lt;/span&gt;].tasks.push(task)&lt;br/&gt;        workNum = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        works[workNum].tasks.push(task)&lt;br/&gt;        workNum += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 用于记录进程完成数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; pageNum = works.length&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 初始化进度条&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;works.forEach(({&lt;br/&gt;    work,&lt;br/&gt;    tasks&lt;br/&gt;}) = &amp;gt;{&lt;br/&gt;    &lt;span&gt;// 发送任务到每个进程&lt;/span&gt;&lt;br/&gt;    work.send(tasks)&lt;br/&gt;    &lt;span&gt;// 接收任务完成&lt;/span&gt;&lt;br/&gt;    work.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, (details: Idetail[]) = &amp;gt;{&lt;br/&gt;        &lt;span&gt;// 更新进度条&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;        pageNum--&lt;br/&gt;        &lt;span&gt;// 所有任务执行完毕&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (pageNum === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// 关闭进程&lt;/span&gt;&lt;br/&gt;            cluster.disconnect()&lt;br/&gt;        }&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;cluster&lt;/code&gt;，根据「cpu核心数」创建等量的进程，&lt;code&gt;works&lt;/code&gt;用于保存已创建的进程，&lt;code&gt;list&lt;/code&gt;中保存的是要处理的压缩任务，通过遍历&lt;code&gt;list&lt;/code&gt;，把任务依次分给每一个进程。接着遍历&lt;code&gt;works&lt;/code&gt;，通过&lt;code&gt;send&lt;/code&gt;方法发送进程任务。通过监听&lt;code&gt;message&lt;/code&gt;事件，利用&lt;code&gt;pageNum&lt;/code&gt;记录进程任务的完成情况，当所有进程任务执行完毕后，则关闭进程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方提供的&lt;code&gt;tinify&lt;/code&gt;工具有「500张/月」的限额，超过限额后，需要付费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6189516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/2A8tXicCG8ymRVice8ZMkq935DJ6ZTeoLRhyX5V6vDUJlm0zOsJfzias26Joo9BZz6oAcR2zA7LmJ2mAVQSIE1XoA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;992&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于家境贫寒，且出于学习的目的，就没有使用&lt;code&gt;tinify&lt;/code&gt;，而是通过构造随机&lt;code&gt;IP&lt;/code&gt;来直接请求「压缩接口」来达到「破解限额」的目的。大家在真正使用的时候，还是要使用&lt;code&gt;tinyfy&lt;/code&gt;来压缩，不要做这种投机取巧的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，回到正文。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把原图上传到&lt;code&gt;TinyPng&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/features/index.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 上传函数&lt;br/&gt; * @param { Buffer } file 文件buffer数据&lt;br/&gt; * @returns { Promise&amp;lt;DataUploadType&amp;gt; }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Iupload {&lt;br/&gt;  (file: Buffer): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;DataUploadType&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; upload: Iupload&lt;br/&gt;upload = &lt;span&gt;(&lt;span&gt;file: Buffer&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 生成随机请求头&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; header = randomHeader()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; req = Https.request(header, &lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      res.on(&lt;span&gt;&#x27;data&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; resp = &lt;span&gt;JSON&lt;/span&gt;.parse(data.toString()) &lt;span&gt;as&lt;/span&gt; DataUploadType&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (resp.error) {&lt;br/&gt;            reject(resp)&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            resolve(resp)&lt;br/&gt;          }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;          reject(err)&lt;br/&gt;        }&lt;br/&gt;      })&lt;br/&gt;    })&lt;br/&gt;    &lt;span&gt;// 上传图片buffer&lt;/span&gt;&lt;br/&gt;    req.write(file)&lt;br/&gt;    req.on(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; reject(err))&lt;br/&gt;    req.end()&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;node&lt;/code&gt;自带的&lt;code&gt;Https&lt;/code&gt;模块，构造请求头，把&lt;code&gt;deepFindImg&lt;/code&gt;中返回的图片进行上传。上传成功后，会返回已经压缩好的图片的&lt;code&gt;url&lt;/code&gt;链接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下载&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从&lt;code&gt;TinyPng&lt;/code&gt;中下载压缩好的图片。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/features/index.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 下载函数&lt;br/&gt; * @param { string } path&lt;br/&gt; * @returns { Promise&amp;lt;string&amp;gt; }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Idownload {&lt;br/&gt;  (path: &lt;span&gt;string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; download: Idownload&lt;br/&gt;download = &lt;span&gt;(&lt;span&gt;path: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; header = &lt;span&gt;new&lt;/span&gt; Url.URL(path)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; req = Https.request(header, &lt;span&gt;&lt;span&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;let&lt;/span&gt; content = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;      res.setEncoding(&lt;span&gt;&#x27;binary&#x27;&lt;/span&gt;)&lt;br/&gt;      res.on(&lt;span&gt;&#x27;data&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; (content += data))&lt;br/&gt;      res.on(&lt;span&gt;&#x27;end&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resolve(content))&lt;br/&gt;    })&lt;br/&gt;    req.on(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; reject(err))&lt;br/&gt;    req.end()&lt;br/&gt;  })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;node&lt;/code&gt;自带的&lt;code&gt;Https&lt;/code&gt;模块把&lt;code&gt;upload&lt;/code&gt;中返回的图片链接进行下载。下载成功后，返回图片的&lt;code&gt;buffer&lt;/code&gt;数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把下载好的图片覆盖本地图片。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/features/process.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 接收进程任务&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;process.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, &lt;span&gt;(&lt;span&gt;tasks: imageType[]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  ;&lt;span&gt;(&lt;span&gt;&lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 优化 png/jpg&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; data = tasks&lt;br/&gt;      .filter(&lt;span&gt;(&lt;span&gt;{ path }: { path: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt; /\.(&lt;span&gt;jpe?g|png&lt;/span&gt;)$/.test(&lt;span&gt;path&lt;/span&gt;)&lt;/span&gt;)&lt;br/&gt;      .map(&lt;span&gt;ele =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; compressImg(&lt;span&gt;{ ...ele, file: Buffer.&lt;span&gt;from&lt;/span&gt;(&lt;span&gt;ele.file&lt;/span&gt;) }&lt;/span&gt;)&lt;br/&gt;      }&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 优化 svga&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; svgaData = tasks&lt;br/&gt;      .filter(&lt;span&gt;(&lt;span&gt;{ path }: { path: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt; /\.(&lt;span&gt;svga&lt;/span&gt;)$/.test(&lt;span&gt;path&lt;/span&gt;)&lt;/span&gt;)&lt;br/&gt;      .map(&lt;span&gt;ele =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; compressSvga(&lt;span&gt;ele.path, Buffer.&lt;span&gt;from&lt;/span&gt;(&lt;span&gt;ele.file&lt;/span&gt;)&lt;/span&gt;)&lt;br/&gt;      }&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; details = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.all(&lt;span&gt;[&lt;br/&gt;      ...data.map(&lt;span&gt;fn =&amp;gt; fn()&lt;/span&gt;),&lt;br/&gt;      ...svgaData.map(&lt;span&gt;fn =&amp;gt; fn()&lt;/span&gt;)&lt;br/&gt;    ]&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 写入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.all(&lt;span&gt;&lt;br/&gt;      details.map(&lt;span&gt;&lt;br/&gt;        (&lt;span&gt;{ path, file }&lt;/span&gt;) =&amp;gt;&lt;br/&gt;          &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve, reject&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;            fs.writeFile(&lt;span&gt;path, file, err =&amp;gt; {&lt;br/&gt;              &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;err&lt;/span&gt;) reject(&lt;span&gt;err&lt;/span&gt;)&lt;br/&gt;              resolve(&lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;            }&lt;/span&gt;)&lt;br/&gt;          }&lt;/span&gt;)&lt;br/&gt;      &lt;/span&gt;)&lt;br/&gt;    &lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 发送结果&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;process.send&lt;/span&gt;) {&lt;br/&gt;      process.send(&lt;span&gt;details&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;  }&lt;/span&gt;)&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;process.on&lt;/code&gt;监听每个进程发送的任务，当接收到任务类型为「图片」，使用&lt;code&gt;compressImg&lt;/code&gt;方法来处理图片。当任务类型为「svga」，使用&lt;code&gt;compressSvga&lt;/code&gt;方法来处理&lt;code&gt;svga&lt;/code&gt;。最后把处理好的资源写入到本地覆盖旧资源。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;compressImg&lt;/span&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/features/process.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 压缩图片&lt;br/&gt; * @param { imageType } 图片资源&lt;br/&gt; * @returns { promise&amp;lt;Idetail&amp;gt; }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IcompressImg {&lt;br/&gt;  (payload: imageType): &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;Idetail&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; compressImg: IcompressImg&lt;br/&gt;compressImg = &lt;span&gt;(&lt;span&gt;{ path, file }: imageType&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = {&lt;br/&gt;      input: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      output: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      ratio: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      path,&lt;br/&gt;      file,&lt;br/&gt;      msg: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 上传&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; dataUpload = &lt;span&gt;await&lt;/span&gt; upload(file)&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 下载&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; dataDownload = &lt;span&gt;await&lt;/span&gt; download(dataUpload.output.url)&lt;br/&gt;&lt;br/&gt;      result.input = dataUpload.input.size&lt;br/&gt;      result.output = dataUpload.output.size&lt;br/&gt;      result.ratio = &lt;span&gt;1&lt;/span&gt; - dataUpload.output.ratio&lt;br/&gt;      result.file = Buffer.alloc(dataDownload.length, dataDownload, &lt;span&gt;&#x27;binary&#x27;&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;      result.msg = &lt;span&gt;`[&lt;span&gt;${chalk.blue(path)}&lt;/span&gt;] &lt;span&gt;${chalk.red(&lt;span&gt;JSON&lt;/span&gt;.stringify(err))}&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;compressImg&lt;/code&gt;返回一个&lt;code&gt;async&lt;/code&gt;函数，该函数先调用&lt;code&gt;upload&lt;/code&gt;进行图片上传，接着调用&lt;code&gt;download&lt;/code&gt;进行下载，最终返回该图片的&lt;code&gt;buffer&lt;/code&gt;数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;compressSvga&lt;/span&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;packages/tiny/src/features/process.ts&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 压缩svga&lt;br/&gt; * @param { string } path 路径&lt;br/&gt; * @param { buffer } source svga buffer&lt;br/&gt; * @returns { promise&amp;lt;Idetail&amp;gt; }&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IcompressSvga {&lt;br/&gt;  (path: &lt;span&gt;string&lt;/span&gt;, source: Buffer): &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;Idetail&amp;gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; compressSvga: IcompressSvga&lt;br/&gt;compressSvga = &lt;span&gt;(&lt;span&gt;path, source&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; result = {&lt;br/&gt;      input: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      output: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      ratio: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;      path,&lt;br/&gt;      file: source,&lt;br/&gt;      msg: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// 解析svga&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; data = ProtoMovieEntity.decode(&lt;br/&gt;        pako.inflate(toArrayBuffer(source))&lt;br/&gt;      ) &lt;span&gt;as&lt;/span&gt; unknown &lt;span&gt;as&lt;/span&gt; IsvgaData&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { images } = data&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; list = &lt;span&gt;Object&lt;/span&gt;.keys(images).map(&lt;span&gt;&lt;span&gt;path&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; compressImg({ path, file: toBuffer(images[path]) })&lt;br/&gt;      })&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 对svga图片进行压缩&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; detail = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;.all(list.map(&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; =&amp;gt;&lt;/span&gt; fn()))&lt;br/&gt;      detail.forEach(&lt;span&gt;(&lt;span&gt;{ path, file }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        data.images[path] = file&lt;br/&gt;      })&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 压缩buffer&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; file = pako.deflate(&lt;br/&gt;        toArrayBuffer(ProtoMovieEntity.encode(data).finish() &lt;span&gt;as&lt;/span&gt; Buffer)&lt;br/&gt;      )&lt;br/&gt;      result.input = source.length&lt;br/&gt;      result.output = file.length&lt;br/&gt;      result.ratio = &lt;span&gt;1&lt;/span&gt; - file.length / source.length&lt;br/&gt;      result.file = file&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (err) {&lt;br/&gt;      result.msg = &lt;span&gt;`[&lt;span&gt;${chalk.blue(path)}&lt;/span&gt;] &lt;span&gt;${chalk.red(&lt;span&gt;JSON&lt;/span&gt;.stringify(err))}&lt;/span&gt;`&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;compressSvga&lt;/code&gt;的「输入」、「输出」和&lt;code&gt;compressImg&lt;/code&gt;保持一致，目的是为了可以使用&lt;code&gt;promise.all&lt;/code&gt;同时调用。在&lt;code&gt;compressSvga&lt;/code&gt;内部，对&lt;code&gt;svga&lt;/code&gt;进行解析成&lt;code&gt;data&lt;/code&gt;，获取到&lt;code&gt;svga&lt;/code&gt;的图片列表&lt;code&gt;images&lt;/code&gt;，接着调用&lt;code&gt;compressImg&lt;/code&gt;对&lt;code&gt;images&lt;/code&gt;进行压缩，使用压缩后的图片覆盖&lt;code&gt;data.images&lt;/code&gt;，最后再把&lt;code&gt;data&lt;/code&gt;编码后，写入到本地覆盖原本的&lt;code&gt;svga&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再说一遍，大家真正使用的时候，要使用官方的&lt;code&gt;tinify&lt;/code&gt;进行压缩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考文章：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;protobuf.js&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SVGAPlayer-Web-Lite&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;tinify&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;祝大家生活愉快，工作顺利！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>