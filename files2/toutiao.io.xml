<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b7dfc292ae7a965fcabd26f38df99b9b</guid>
<title>大文件上传时如何做到秒传？</title>
<link>https://toutiao.io/k/iyhuoxx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点击&lt;strong&gt;&lt;span&gt;关注&lt;/span&gt;&lt;/strong&gt;公众号：&lt;/span&gt;&lt;/strong&gt;互联网架构师，后台回复&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 2T&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2TB&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2TB&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;strong&gt;&lt;span&gt;学习资源！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;Alibaba开源内网高并发编程手册.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件上传是一个老生常谈的话题了，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传，这可不是一个好的办法，毕竟很少有人会忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种让人不爽的体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有没有比较好的上传体验呢，答案有的，就是下边要介绍的几种上传方式&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;秒传&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是秒传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗的说，你把要上传的东西上传，服务器会先做&lt;span&gt;MD5&lt;/span&gt;校验，如果服务器上有一样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让&lt;span&gt;MD5&lt;/span&gt;改变，就是对文件本身做一下修改（改名字不行），例如一个文本文件，你多加几个字，MD5就变了，就不会秒传了.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、本文实现的秒传核心逻辑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;a&lt;/span&gt;、利用redis的set方法存放文件上传状态，其中key为文件上传的md5，value为是否上传完成的标志位，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;b&lt;/span&gt;、当标志位true为上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为false，则说明还没上传完成，此时需要在调用set的方法，保存块号文件记录的路径，其中key为上传文件md5加一个固定前缀，value为块号文件记录路径&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;分片上传&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是分片上传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、分片上传的场景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.大文件上传&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.网络环境环境不好，存在需要重传风险的场景&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;断点续传&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是断点续传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2、应用场景&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断点续传可以看成是分片上传的一个衍生，因此可以使用分片上传的场景，都可以使用断点续传。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3、实现断点续传的核心逻辑&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4、实现流程步骤&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、方案一，常规步骤&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;初始化一个分片上传任务，返回本次分片上传唯一标识；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照一定的策略（串行或并行）发送各个分片数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、方案二、本文实现的步骤&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;5、分片上传/断点上传代码实现&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、前端采用百度提供的webuploader的插件，进行分片。因本文主要介绍服务端代码实现，webuploader如何进行分片，具体实现可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;http://fex.baidu.com/webuploader/getting-started.html&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、后端用两种方式实现文件写入，一种是用&lt;span&gt;RandomAccessFile&lt;/span&gt;，如果对&lt;span&gt;RandomAccessFile&lt;/span&gt;不熟悉的朋友，可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://blog.csdn.net/dimudan2015/article/details/81910690&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种是使用&lt;span&gt;MappedByteBuffer&lt;/span&gt;，对&lt;span&gt;MappedByteBuffer&lt;/span&gt;不熟悉的朋友，可以查看如下链接进行了解:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://www.jianshu.com/p/f90866dcbffc&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后端进行写入操作的核心代码&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、RandomAccessFile实现方式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@UploadMode&lt;/span&gt;(mode = UploadModeEnum.RANDOM_ACCESS)  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RandomAccessUploadStrategy&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${upload.chunkSize}&quot;&lt;/span&gt;)  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    RandomAccessFile accessTmpFile = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = &lt;span&gt;super&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      accessTmpFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//这个必须与前端设定的值一致  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; offset = chunkSize * param.getChunk();  &lt;br/&gt;      &lt;span&gt;//定位到该分片的偏移量  &lt;/span&gt;&lt;br/&gt;      accessTmpFile.seek(offset);  &lt;br/&gt;      &lt;span&gt;//写入该分片数据  &lt;/span&gt;&lt;br/&gt;      accessTmpFile.write(param.getFile().getBytes());  &lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;super&lt;/span&gt;.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;      FileUtil.close(accessTmpFile);  &lt;br/&gt;    }  &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、MappedByteBuffer实现方式&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@UploadMode&lt;/span&gt;(mode = UploadModeEnum.MAPPED_BYTEBUFFER)  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MappedByteBufferUploadStrategy&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${upload.chunkSize}&quot;&lt;/span&gt;)  &lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    RandomAccessFile tempRaf = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    FileChannel fileChannel = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    MappedByteBuffer mappedByteBuffer = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = &lt;span&gt;super&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      tempRaf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      fileChannel = tempRaf.getChannel();  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      &lt;span&gt;//写入该分片数据  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; offset = chunkSize * param.getChunk();  &lt;br/&gt;      &lt;span&gt;byte&lt;/span&gt;[] fileData = param.getFile().getBytes();  &lt;br/&gt;      mappedByteBuffer = fileChannel  &lt;br/&gt;.map(FileChannel.MapMode.READ_WRITE, offset, fileData.length);  &lt;br/&gt;      mappedByteBuffer.put(fileData);  &lt;br/&gt;      &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;super&lt;/span&gt;.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;      FileUtil.freedMappedByteBuffer(mappedByteBuffer);  &lt;br/&gt;      FileUtil.close(fileChannel);  &lt;br/&gt;      FileUtil.close(tempRaf);  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、文件操作核心模板类代码&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SliceUploadTemplate&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SliceUploadStrategy&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;upload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; File &lt;span&gt;createTmpFile&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    FilePathUtil filePathUtil = SpringContextHolder.getBean(FilePathUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;    param.setPath(FileUtil.withoutHeadAndTailDiagonal(param.getPath()));  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;    String tempFileName = fileName + &lt;span&gt;&quot;_tmp&quot;&lt;/span&gt;;  &lt;br/&gt;    File tmpDir = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath);  &lt;br/&gt;    File tmpFile = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath, tempFileName);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tmpDir.exists()) {  &lt;br/&gt;      tmpDir.mkdirs();  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tmpFile;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FileUploadDTO &lt;span&gt;sliceUpload&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isOk = &lt;span&gt;this&lt;/span&gt;.upload(param);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isOk) {  &lt;br/&gt;      File tmpFile = &lt;span&gt;this&lt;/span&gt;.createTmpFile(param);  &lt;br/&gt;      FileUploadDTO fileUploadDTO = &lt;span&gt;this&lt;/span&gt;.saveAndFileUploadDTO(param.getFile().getOriginalFilename(), tmpFile);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String md5 = FileMD5Util.getFileMD5(param.getFile());  &lt;br/&gt;  &lt;br/&gt;    Map&amp;lt;Integer, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;    map.put(param.getChunk(), md5);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FileUploadDTO.builder().chunkMd5Info(map).build();  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/**  &lt;br/&gt;   * 检查并修改文件上传进度  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;checkAndSetUploadProgress&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param, String uploadDirPath)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    File confFile = &lt;span&gt;new&lt;/span&gt; File(uploadDirPath, fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt; isComplete = &lt;span&gt;0&lt;/span&gt;;  &lt;br/&gt;    RandomAccessFile accessConfFile = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;      accessConfFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(confFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//把该分段标记为 true 表示完成  &lt;/span&gt;&lt;br/&gt;      System.out.println(&lt;span&gt;&quot;set part &quot;&lt;/span&gt; + param.getChunk() + &lt;span&gt;&quot; complete&quot;&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;//创建conf文件文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认0,已上传的就是Byte.MAX_VALUE 127  &lt;/span&gt;&lt;br/&gt;      accessConfFile.setLength(param.getChunks());  &lt;br/&gt;      accessConfFile.seek(param.getChunk());  &lt;br/&gt;      accessConfFile.write(Byte.MAX_VALUE);  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;//completeList 检查是否全部完成,如果数组里是否全部都是127(全部分片都成功上传)  &lt;/span&gt;&lt;br/&gt;      &lt;span&gt;byte&lt;/span&gt;[] completeList = FileUtils.readFileToByteArray(confFile);  &lt;br/&gt;      isComplete = Byte.MAX_VALUE;  &lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; completeList.length &amp;amp;&amp;amp; isComplete == Byte.MAX_VALUE; i++) {  &lt;br/&gt;        &lt;span&gt;//与运算, 如果有部分没有完成则 isComplete 不是 Byte.MAX_VALUE  &lt;/span&gt;&lt;br/&gt;        isComplete = (&lt;span&gt;byte&lt;/span&gt;) (isComplete &amp;amp; completeList[i]);  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;check part &quot;&lt;/span&gt; + i + &lt;span&gt;&quot; complete?:&quot;&lt;/span&gt; + completeList[i]);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;      FileUtil.close(accessConfFile);  &lt;br/&gt;    }  &lt;br/&gt; &lt;span&gt;boolean&lt;/span&gt; isOk = setUploadProgress2Redis(param, uploadDirPath, fileName, confFile, isComplete);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;/**  &lt;br/&gt;   * 把上传进度信息存进redis  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;setUploadProgress2Redis&lt;/span&gt;&lt;span&gt;(FileUploadRequestDTO param, String uploadDirPath,  &lt;br/&gt;      String fileName, File confFile, &lt;span&gt;byte&lt;/span&gt; isComplete)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    RedisUtil redisUtil = SpringContextHolder.getBean(RedisUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isComplete == Byte.MAX_VALUE) {  &lt;br/&gt;      redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;true&quot;&lt;/span&gt;);  &lt;br/&gt;      redisUtil.del(FileConstant.FILE_MD5_KEY + param.getMd5());  &lt;br/&gt;      confFile.delete();  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;  &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!redisUtil.hHasKey(FileConstant.FILE_UPLOAD_STATUS, param.getMd5())) {  &lt;br/&gt;        redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;false&quot;&lt;/span&gt;);  &lt;br/&gt;        redisUtil.set(FileConstant.FILE_MD5_KEY + param.getMd5(),  &lt;br/&gt;            uploadDirPath + FileConstant.FILE_SEPARATORCHAR + fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;  }  &lt;br/&gt;&lt;span&gt;/**  &lt;br/&gt;   * 保存文件操作  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FileUploadDTO &lt;span&gt;saveAndFileUploadDTO&lt;/span&gt;&lt;span&gt;(String fileName, File tmpFile)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;  &lt;br/&gt;    FileUploadDTO fileUploadDTO = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;      fileUploadDTO = renameFile(tmpFile, fileName);  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (fileUploadDTO.isUploadComplete()) {  &lt;br/&gt;        System.out  &lt;br/&gt;            .println(&lt;span&gt;&quot;upload complete !!&quot;&lt;/span&gt; + fileUploadDTO.isUploadComplete() + &lt;span&gt;&quot; name=&quot;&lt;/span&gt; + fileName);  &lt;br/&gt;        &lt;span&gt;//TODO 保存文件信息到数据库  &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;&lt;span&gt;/**  &lt;br/&gt;   * 文件重命名  &lt;br/&gt;   *  &lt;br/&gt;   * &lt;span&gt;@param&lt;/span&gt; toBeRenamed 将要修改名字的文件  &lt;br/&gt;   * &lt;span&gt;@param&lt;/span&gt; toFileNewName 新的名字  &lt;br/&gt;   */&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; FileUploadDTO &lt;span&gt;renameFile&lt;/span&gt;&lt;span&gt;(File toBeRenamed, String toFileNewName)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;//检查要重命名的文件是否存在，是否是文件  &lt;/span&gt;&lt;br/&gt;    FileUploadDTO fileUploadDTO = &lt;span&gt;new&lt;/span&gt; FileUploadDTO();  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!toBeRenamed.exists() || toBeRenamed.isDirectory()) {  &lt;br/&gt;      log.info(&lt;span&gt;&quot;File does not exist: {}&quot;&lt;/span&gt;, toBeRenamed.getName());  &lt;br/&gt;      fileUploadDTO.setUploadComplete(&lt;span&gt;false&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String ext = FileUtil.getExtension(toFileNewName);  &lt;br/&gt;    String p = toBeRenamed.getParent();  &lt;br/&gt;    String filePath = p + FileConstant.FILE_SEPARATORCHAR + toFileNewName;  &lt;br/&gt;    File newFile = &lt;span&gt;new&lt;/span&gt; File(filePath);  &lt;br/&gt;    &lt;span&gt;//修改文件名  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; uploadFlag = toBeRenamed.renameTo(newFile);  &lt;br/&gt;  &lt;br/&gt;    fileUploadDTO.setMtime(DateUtil.getCurrentTimeStamp());  &lt;br/&gt;    fileUploadDTO.setUploadComplete(uploadFlag);  &lt;br/&gt;    fileUploadDTO.setPath(filePath);  &lt;br/&gt;    fileUploadDTO.setSize(newFile.length());  &lt;br/&gt;    fileUploadDTO.setFileExt(ext);  &lt;br/&gt;    fileUploadDTO.setFileId(toFileNewName);  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实现分片上传的过程，需要前端和后端配合，比如前后端的上传块号的文件大小，前后端必须得要一致，否则上传就会有问题。其次文件相关操作正常都是要搭建一个文件服务器的，比如使用&lt;span&gt;fastdfs&lt;/span&gt;、&lt;span&gt;hdfs&lt;/span&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本示例代码在电脑配置为4核内存8G情况下，上传24G大小的文件，上传时间需要30多分钟，主要时间耗费在前端的&lt;span&gt;md5&lt;/span&gt;值计算，后端写入的速度还是比较快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目组觉得自建文件服务器太花费时间，且项目的需求仅仅只是上传下载，那么推荐使用阿里的oss服务器，其介绍可以查看官网:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://help.aliyun.com/product/31815.html&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的oss它本质是一个对象存储服务器，而非文件服务器，因此如果有涉及到大量删除或者修改文件的需求，oss可能就不是一个好的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文末提供一个oss表单上传的链接demo，通过oss表单上传，可以直接从前端把文件上传到oss服务器，把上传的压力都推给oss服务器:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;https://www.cnblogs.com/ossteam/p/4942227.html&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;-End-&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;527&quot; data-mpa-category=&quot;image&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-id=&quot;1357582&quot; data-mpa-category=&quot;image&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1423611111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRI2cbvKcYHPMKYlo4ibO3ZXG4kRnuC195QBJzMR0VLd7p08kYInDEEiasufnLsY7LhFwPIml2fPergw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;288&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;正文结束&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;推荐阅读 ↓↓↓&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;1.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247527958&amp;amp;idx=1&amp;amp;sn=6d407650c574b304b681aecbf5c1323b&amp;amp;chksm=ea5fa370dd282a66a8b6463fb60ad850d47cc35d727ac4b66fdf29f88ce30eef400287b1b746&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全新 IDEA 2022.2 正式发布，新特性真香！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全新 IDEA 2022.2 正式发布，新特性真香！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;2&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488035&amp;amp;idx=1&amp;amp;sn=5300893903094128bdc20ce2a5717a50&amp;amp;chksm=ea5cdf45dd2b56531ac0c3a8fb8b56b06bc546785f8772a4d02e2ca87c4e30f25b24bf21f784&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;从零开始搭建创业公司后台技术栈&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488928&amp;amp;idx=1&amp;amp;sn=4c56dd675e1b32a73b698df3d5e8609f&amp;amp;chksm=ea5cd8c6dd2b51d05e6d6d715418241f471ccb3002719263b2d0e092763f68f3691249970a08&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;程序员一般可以从什么平台接私活？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;4&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247527535&amp;amp;idx=1&amp;amp;sn=6cb6c086057aebaedc47859518eb80da&amp;amp;chksm=ea5fa109dd28281f3a90a36ea1deb7e8d1658d221f718ea15023b0345b53fc496c137496d10d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring中毒太深，离开Spring我连最基本的CRUD都不会写了...&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring中毒太深，离开Spring我连最基本的CRUD都不会写了...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247513283&amp;amp;idx=1&amp;amp;sn=3b3d8e893a1241cf5af2150370ae9d71&amp;amp;chksm=ea5f79a5dd28f0b3a7603b1fbdb306f77ac64223bd05c4b7f0dc0469f77a68359810c5de2a01&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么国内 996 干不过国外的 955呢？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;为什么国内 996 干不过国外的 955呢？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;6&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247528236&amp;amp;idx=1&amp;amp;sn=c675d5d3aede21b4b7ebbba21eadf96c&amp;amp;chksm=ea5fa24add282b5cfb13757cd534ec600fb910f9dcb7f3ee3dea5e7929e0fbbd22381625ff20&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;中国的铁路订票系统在世界上属于什么水平？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;中国的铁路订票系统在世界上属于什么水平？&lt;/a&gt;                        &lt;/span&gt;&lt;/p&gt;&lt;p&gt;7&lt;span&gt;.&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247488564&amp;amp;idx=1&amp;amp;sn=256862239b12a1313919ee3ea6ff0d1c&amp;amp;chksm=ea5cd952dd2b50443feec88eb893233d2f6cf33f89e2ce72192c98035fd26cb0eb797a86f8f0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;15张图看懂瞎忙和高效的区别！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100030073&quot; data-ratio=&quot;0.1328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GQek52mKtWDXtSkfViaQ2FZ2ZfSyjBcSkArjQVCMH4a7uxg6Vkibiaiciaiae2uxvzia7yib04tleLiaqcFVGUf2vcMf4A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b102fb53d64a9d5b002ddf4b7c1a623f</guid>
<title>携程海外MySQL数据复制实践</title>
<link>https://toutiao.io/k/tlkmfx5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;oy，携程软件技术专家，负责MySQL双向同步DRC和数据库访问中间件DAL的开发演进，对分布式系统高可用设计、分布式存储，数据一致性领域感兴趣。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在携程国际化战略背景下，海外业务将成为新的发力点，为了保证用户高品质的服务体验，底层数据势必需要就近服务业务应用。一套标准且普适的数据复制解决方案能够提升业务决策效率，助力业务更快地触达目标用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC (Data Replicate Center) 作为携程内部数据库上云标准解决方案，支撑了包括但不限于即时通讯、用户账号、IBU在内的核心基础服务和国际业务顺利上云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、业务上云场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务上云前，要先要思考2个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 应用上云&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对用户延迟不敏感或者离线业务，可以采用只应用上云数据库不上云，请求回源国内。该方案下业务需要改造应用中读写数据库操作，根据应用部署地，决定流量是否需要转发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不建议海外应用直连国内数据库，网络层面专线距离远，成本太高，不现实；安全层面应禁止跨海访问，否则可能导致预期就近访问流量由于非预期错误，将海外流量写入国内数据库，从而引起国内数据错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4236111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEjY3SE0W4eXc9CGKgwc8FmlIVuibabQczpicqIZmIRXibKVCKwyIa8AUdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 数据库上云&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于在线用户延迟敏感应用，数据库必须跟随应用一同上云，将请求闭环在海外，从而就近提供服务响应。在确定数据库上云的前提下，根据不同业务特点，可再细分为海外只读和读写两种场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;只读场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于海外只读场景，国内数据只需要单向复制，该方案下业务海外账号默认无写权限或者业务改造写操作，避免出现由于误写导致国内海外数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49226804123711343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEoaib6gzW5aBSF0GYxx9X7BiayvEQyNvhFhXaBwp28w2dbNj9Gxxd7X0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;读写场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于海外读写场景，国内海外数据需要双向复制，业务代码无需改造。该方案下由于有2个Master可以写入，业务需要在应用层对流量进行切分，比如用户归属地维度，从而避免在两侧同时修改同一条数据，进而导致复制过程出现数据冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.493573264781491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEibpKzBCU33Wt5tc9FgJYwEL37t9quHGUnD6iaGxbW8AnIeADV3ukZKcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 上云成本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据距离用户越近，应用直接提供的服务功能越丰富，对应业务改造量越小，机器资源消耗量越大。携程海外应用部署在AWS公有云上，AWS入口流量不计费，只针对出口流量计费。应用上云数据库不上云场景，请求回源国内产生出口流量费用；只读业务单方向数据复制流入，不收费；读写业务数据复制回国内产生出口流量费用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table role=&quot;grid&quot; resolved=&quot;&quot;&gt;&lt;tbody aria-live=&quot;polite&quot; aria-relevant=&quot;all&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;上云场景&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;AWS出口流量&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;数据库成本&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;机器成本&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;业务改造&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;应用上云&lt;/span&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;业务请求流量&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;改造读写请求&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;数据库上云/只读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;无&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;RDS费用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt; 单向复制&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;改造写请求&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr role=&quot;row&quot;&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;数据库上云/读写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;海外→国内复制流量&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;RDS费用&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt; 双向复制&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td colspan=&quot;1&quot; align=&quot;center&quot; valign=&quot;top&quot;&gt;&lt;span&gt;无&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;上云成本主要集中在流量和数据库费用。AWS出口Internet流量0.09$/GB，当流量大时，可通过数据压缩，损耗复制延迟降低出口流量；RDS根据核数计费，1004元/核/月，业务流量少时采用普通4C16G机型即可，流量增加后动态提升配置。核心业务RDS配置一主一从，非核心业务单主即可，并且多个DB可共用一个集群，进而降低成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提供高品质的用户体验，数据势必需要上云。在解决了是否上云的问题后，如何上云就成为新的疑问点。下面就详细分析携程内部上云过程中依赖的数据库复制组件DRC实现细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、数据库上云方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC基于开源模式开发，公司内部生产版本和开源保持一致，开源地址&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/ctripcorp/drc&quot; textvalue=&quot;https://github.com/ctripcorp/drc&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/drc&lt;/a&gt;，欢迎关注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DRC孵化于异地多活项目，参见&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697269807&amp;amp;idx=1&amp;amp;sn=1d32b44d6108309309e93c4810b24b83&amp;amp;chksm=8376ed1bb401640d74f875189e75c085434e834de9ec8b8cdbf8083bdcfe0717e39e5723e49c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《携程异地多活-MySQL实时双向（多向）复制实践》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《携程异地多活-MySQL实时双向（多向）复制实践》&lt;/a&gt;，解决国内异地机房间数据库同步问题。当其中一个或多个机房位置转变为公有云时，伴随着物理距离的扩大，新的问题应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就DRC自身架构实现而言：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41590214067278286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsE837xZ60R1cOAu7E9icUgseJrQ8CMa1EXKbu1ePXicxMCh3NNgoPVop7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就业务接入而言：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上限制，DRC调整架构，引入代理模块解决网络联通性问题，借用事务表降低复制链路对权限的要求；为了适应业务的多样性，分别从库、表和行维度支持按需复制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 架构改造挑战&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）架构升级&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DRC中有2个核心功能需要跨公网传输数据：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据复制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以单向复制为例，在Binlog拉取模块Replicator和解析应用模块Applier之间引入Proxy，负责在TCP层将内网/公网流量转发到公网/内网。Proxy绑定公网IP，采用TLS协议加密传输内网流量。鉴于公网质量不稳定特性，Proxy使用BBR拥塞控制算法，优化丢包引起的卡顿。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Proxy作为公网数据传输携程内部统一的解决方案，参见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697267768&amp;amp;idx=1&amp;amp;sn=d8f38ab6e6e034ad36b9d1a47a792e45&amp;amp;chksm=8376f50cb4017c1a23ee0ac7ee7e4bd02599565598fdc57d7aaa48e130e4863fb6241a212f67&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程Redis海外机房数据同步实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;携程Redis海外机房数据同步实践&lt;/a&gt;》，开源地址：&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/ctripcorp/x-pipe&quot; textvalue=&quot;https://github.com/ctripcorp/x-pipe&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/x-pipe&lt;/a&gt;，欢迎关注。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3314037626628075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEubMgzibgqcpkD4yuRJYc3pUO8kaGkgo3ZxpMiaRic3rQJiaJGdTFac2xtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1382&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;延迟监控&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;延迟监控探针从业务流量同侧机房的Console写入到业务数据库延迟监控表(初始化时新建)，经过双向复制链路，从异侧机房接收延迟探针，从而计算差值得到复制延迟。为了提升Proxy间隔离性，数据复制和延迟监控可以分别配置不同的Proxy实例实现数据传输。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47324414715719065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsExBW4B6O45KBNgMXWdoXUUmficSXiaqrbUFuaClwHIgCI8Hc30tCLd9Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Proxy Client&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于Applier和Console都需要对接Proxy，如何降低Proxy对DRC系统的侵入性就成为一个需要解决的问题。为此我们借助Java Agent技术，动态修改字节码，实现了可插拔的接入方式。接入方只需要引入proxy-client独立Jar包，业务层按需实现Proxy的注册和注销。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）网络优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公网网络丢包和拥塞频发，为了在弱网环境下实现平稳复制，就需要快速地异常检测恢复机制。除了在系统层将Proxy拥塞控制算法优化为BBR外，DRC在应用层额外增加：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27167630057803466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEeicunCaZWPfNh6QXiajK59RnQiapfzw79fg4r27bdibYB5iaLjvYJSSNSJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;心跳检测&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Binlog生产方Replicator定时对下游消费方进行心跳检测，消费方接收到心跳检测需回复响应，Replicator根据最后一次接收时间检测并自动关闭长期没有响应的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里有一种场景需要特别处理，当下游消费方比较忙，主动关闭连接auto_read属性时，由于应用层无法读取暂存在缓冲区的心跳包，从而造成无法响应。这就需要消费方在auto_read改变时，主动上报生产方自身的auto_read状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;公网网络质量下降导致复制延迟变大，数据堆积在发送端Proxy，进而引起Replicator和Proxy触发流控；MySQL性能抖动，应用Binlog速度减缓，数据堆积在Applier，进而引起Applier触发流控并逐层反馈到Replicator。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;运营商线路&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Proxy出口IP，分别配置移动和联通两条运营商线路，当Binlog消费方由于触发空闲检测出现超时重连时，Proxy会随机选择一个运营商出口IP，从而实现运营商线路的互备。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）事务表复制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内机房间数据复制时，DBA可以给予DRC拥有root权限的账号，以实现Applier模拟原生Slave节点set gtid_next工作方式应用Binlog，从而将一个事务变更从源机房复制到目标机房，并且在两端分配到同一个gtid下。但是公有云上RDS出于安全原因是无法开放root权限，直接从原理上否定了原有的复制方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了找到合理的替换方案，我们首先从MySQL服务端视角分析下set gtid_next的效果：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其根本性作用在于将DRC指定的gtid值保存到MySQL系统变量。既然无法利用MySQL系统变量，那么从业务层增加一个复制变量保存gtid信息即可实现同等效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，转换到DRC复制视角，set gtid_next起到如下作用：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上分析，新的替代方案需要引入持久化变量，记录复制位点并且能够提供循环阻断信息功效，为此DRC引入基于事务表的同步方案解决了海外复制难题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;位点记录&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;海外复制业务集群需要新增复制库drcmonitordb，其中新建事务表gtid_executed。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;TABLE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;`drcmonitordb`.`gtid_executed` (&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`id` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(11) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`server_uuid` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;char&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(36) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`gno` &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;bigint&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;(20) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;NOT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;NULL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;`gtidset` longtext,&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;PRIMARY&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;KEY&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;(`id`,`server_uuid`)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;) ENGINE=InnoDB &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;DEFAULT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;CHARSET=utf8mb4;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当Applier应用SQL到目标数据库前，需要先更新事务表，记录gtid，然后再执行事务中变更语句，完整的复制流程如下图所示。事务表中gno=0行中gtidset等效MySQL系统变量gtid_executed，Applier执行过程中定时汇总非0行事务gno，从而达到记录位点功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42216358839050133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEsMZ2YC4oMyeOFKELDicnlV272HIq6HHOxdYxt26oWT5VaESnXv6xricg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;循环阻断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对Binlog中第一个写事件是事务表gtid_executed操作的事务，Replicator将其判断为DRC复制数据，从而阻断循环复制，否则一条数据会在双向复制环内无限死循环。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 业务落地挑战&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此DRC解决了理论上阻碍复制的已知技术问题，在实际业务落地过程中，出于数据安全、费用和改造成本的考虑，业务对数据复制提出了更精细化控制的需求。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）数据隔离&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;出于合规的要求，业务上云后，需要完成国内和海外用户数据的隔离。业务上云前，国内和海外用户数据全部在国内数据库；上云时就需要将海外用户数据单独复制到公有云而过滤掉国内用户数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;库表映射&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;上云前国内和海外数据在同一张母表。为了上云，业务通过在国内数据库新增子表，实现国内数据的分离。海外由于只存在海外数据，所以物理上只需要一张母表即可，即国内子表与海外母表相对应，搭建DRC实现双向复制即可。由于母表和子表表名不同，复制时需要做库表映射，从而屏蔽应用层对不同表名的感知，降低业务改造量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2825788751714678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEYicoTNBLZqNYXMukMgHtH38yg5ESAjTuozquW7w2yHZyO0zJcs5cAvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;行过滤&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;库表映射不涉及数据过滤，经过DRC的流量都会进行复制，因此映射在Applier端处理，直接根据映射规则替换表名即可。为此业务需要进行2处改造：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了进一步降低业务改造量，DRC提供行过滤功能，用户无需进行业务改造，只需保证表中包含Uid字段即可，DRC根据Uid自动判断数据归属地，进行数据过滤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2934472934472934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEJt4828Ap03HibXicxtEZHWNIo5e6YpfJJibFM6hJz4BHAMMWgtgjbicXxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;单向复制链路级别添加行过滤配置，其中包括：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）Uid过滤，业务层面一般通过Uid维度进行拆分，通过SPI动态加载Uid过滤实现，携程内部由于Uid无特殊标记，无法通过Uid名称判断出归属地，只能通过SOA远程调用实时判断Uid归属地获得过滤结果；如果Uid有规则可循，则可以通过正则表达式匹配即可&lt;/p&gt;&lt;p&gt;（2）Java正则表达式，支持针对单字段的Java正则表达式简单匹配计算，适合单一维度数值有规则的业务场景&lt;/p&gt;&lt;p&gt;（3）Aviator表达式，支持针对多字段的Aviator表达式复杂匹配计算，适合多维度数值相关联的业务场景&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;包含表到过滤字段的映射关系，以及与过滤类型对应的上下文，比如正则表达式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3460559796437659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEvAWDs405YibU8LYg9v1en6uueySCO1ggaGlnu13KvE2riceTObrnK3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Applier Binlog请求中携带行过滤配置，Replicator根据过滤类型加载对应的过滤规则，从而计算出过滤结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;行过滤在发送端Replicator实现，这样实现的好处是跨海发送数据量大大降低，但同时也带来了解析和重构Rows Event的复杂性和性能损耗，即先解析Rows Event并根据过滤后的行数据生成新的Rows Event。Rows Event的解析需要表结构信息，而表结构信息是保存在Binlog的头中，势必在Rows Event前保证能够获得对应的表结构；解析后就可以将每行过滤字段值应用到过滤规则上，若匹配出需要过滤的行，则需要根据过滤后的行构造新的Rows Event并发送，否则直接发送即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.171900826446281&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEFrWJZnDbRfJkibuXBbAx2qGiaDburLibEwAH3hFGsn5UUBz4kmibxRS07g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）数据库混部&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心业务随着数据量的膨胀，会采用分库来降低数据库压力，在公有云部署时，鉴于云上初始流量不多，并且可动态提升机器配置，DBA部署时会将所有分库部署在同一个RDS集群，此时复制从一对一变成一对多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.650137741046832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEzKCtGxm87w5z5BpFkibNIicf2R4VkIDnicupdo4em2Fdl0RSLx5T4cb4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;表过滤&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;单向复制链路级别添加库表过滤配置，支持Aviator表达式。Replicator发送前，通过将从Binlog中解析的库表名作用于Aviator表达式从而得到过滤结果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1989795918367347&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEZpXQGq08IHDgNgzYdjJM4WE7lMia44UFSSzEw3qmrSd4ACcSFfLYMwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 数据库上云流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;完整的业务上云流程一般分为四步：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;数据库先上云，搭建国内海外数据库复制，验证海外数据可用性和完整性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在海外数据可用的前提下，应用上云，就近访问海外数据库，验证部署海外应用可行性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;流量路由层灰度业务流量，可根据Uid白名单、流量百分比在流量接入层进行灰度，验证业务逻辑正确性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;灰度完成，国内和海外流量完成切分，验证国内和海外业务隔离性，为此后下线底层数据复制做准备&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08717105263157894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEHXypqLovHiaUfnzfjzllaI9l1m7iaXOWJia9IdxJV9PbQnbRXianRImseA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据库上云在每一步都有所涉及，第一步通过DRC解决了数据的可用性问题，第二步通过数据库访问中间件解决了数据可达性问题，第三步业务通过流量准确切分保证数据一致性问题，第四步国内海外实现数据隔离后，即可下线DRC数据复制。在分析完DRC原理后，下面再分析下其他几步数据库相关问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）数据访问层&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Dal包含中心化配置管理服务端Dal Cluster和Dal客户端两部分。上云前同一个数据库物理上只有一个集群，上云后海外增加相同集群，服务端Dal Cluster就需要根据客户端环境下发正确的MySQL配置文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEwc1J1zDaPjQFPU7hZ4WwtfStE6J3dg9fcVg04Sb5EHo47C9KgK6TBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Dal Cluster原理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Dal Cluster变更推送功能借由分布式配置中心完成，配置中心提供子环境功能，国内数据库配置默认放在父环境，海外数据库则会在上线流程中生成对应的子环境数据库配置。这样在Dal Client启动时，带有不同环境配置的客户端会拉取到不同的配置，从而实现数据库的就近访问，整个过程对业务透明，代码无需改造。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3423076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEjHoWuZgS8LlzD09uZx6xlVdZ1O53KZQEBYMHpcNjcWgnmWMicEs9WKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）流量切分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;业务上云一般采用Uid归属地进行流量切分，当流量开始灰度后，两端数据库都开始接收写流量。如果流量灰度不干净，针对同一个Uid数据在两端同时被修改，则会导致底层DRC数据复制时出现数据冲突。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当冲突发生时，Applier默认根据时间戳进行冲突策处理，接入DRC的表都有一个精确到毫秒自动更新的时间戳，时间戳最新的数据会被采用，从而实现数据的一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）表结构变更&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过DRC复制的集群，在表结构变更流程中，会自动关联到公有云集群，在两端同时进行变更操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于变更完成时间有先后，假设一个增加字段的变更海外先完成，在国内完成变更前的时间范围内，针对该表海外到国内的复制将出现复制冲突，默认DRC会捕获该异常，并从异常信息中提取出列名，将多出的列从SQL中移除后再执行，从而自动处理掉冲突。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当国内集群完成表结构变更后，新增列的值在两端都为默认值，数据仍然一致。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3609341825902335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsETwn04kzcKt935L9LibXPQKaVGBufG7UmazLTc2FctanyiajzzLm7Q9uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4 业务落地成果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;海外数据库复制从2021年11月上线至今，接入公司90+复制集群；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上海↔新加坡AWS复制平均延迟90ms，上海↔法兰克福AWS复制平均延迟260ms；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;账号集群通过库表映射，常旅、收藏等通过行过滤实现用户数据隔离；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过一对多部署，公有云/国内机房MySQL集群比维持在1/5，DRC复制成本/MySQL集群成本维持在2/5；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DRC开源地址：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ctripcorp/drc&quot; src=&quot;https://github.com/ctripcorp/drc&quot; data-linktype=&quot;2&quot;&gt;https://github.com/ctripcorp/drc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1cdd1XmruicdVVgGlAcRtpsEzpVTCEmmvAb4IMEQpEpZT44P1k4cecduytGtvRjVjNTjwhMugwBlhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>61746e52937c1eb4e8810e0eb1ca7c43</guid>
<title>接口性能优化实战：从20s到500ms，三招搞定</title>
<link>https://toutiao.io/k/atde79x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;接口性能问题，对于从事后端开发的同学来说，是一个绕不开的话题。想要优化一个接口的性能，需要从多个方面着手。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将会接着接口性能优化这个话题，从实战的角度出发，聊聊我是如何优化一个慢查询接口的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上周我优化了一下线上的批量评分查询接口，将接口性能从最初的20s，优化到目前的500ms以内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体来说，用三招就搞定了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到底经历了什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;案发现场&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我们每天早上上班前，都会收到一封线上慢查询接口汇总邮件，邮件中会展示&lt;/span&gt;&lt;strong&gt;&lt;span&gt;接口地址、调用次数、最大耗时、平均耗时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;和&lt;/span&gt;&lt;strong&gt;&lt;span&gt;traceId&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;等信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我看到其中有一个批量评分查询接口，最大耗时达到了20s，平均耗时也有2s。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用&lt;/span&gt;&lt;strong&gt;&lt;span&gt;skywalking&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看该接口的调用信息，发现绝大数情况下，该接口响应还是比较快的，大部分情况都是500ms左右就能返回，但也有少部分超过了20s的请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个现象就非常奇怪了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;莫非跟数据有关？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如：要查某一个组织的数据，是非常快的。但如果要查平台，即组织的根节点，这种情况下，需要查询的数据量非常大，接口响应就可能会非常慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但事实证明不是这个原因。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很快有个同事给出了答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们在结算单列表页面中，批量请求了这个接口，但他传参的数据量非常大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么回事呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当初说的需求是这个接口给分页的列表页面调用，每页大小有：10、20、30、50、100，用户可以选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;换句话说，调用批量评价查询接口，一次性最多可以查询100条记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但实际情况是：结算单列表页面还包含了很多订单。基本上每一个结算单，都有多个订单。调用批量评价查询接口时，需要把结算单和订单的数据合并到一起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样导致的结果是：调用批量评价查询接口时，一次性传入的参数非常多，入参list中包含几百、甚至几千条数据都有可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;现状&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;如果一次性传入几百或者几千个id，批量查询数据还好，可以走主键索引，查询效率也不至于太差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但那个批量评分查询接口，逻辑不简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;伪代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;ScoreEntity&amp;gt; query(&lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;SearchEntity&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;ScoreEntity&amp;gt; result = Lists.newArrayList();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Long&amp;gt; orgIds = &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt;.stream().map(SearchEntity::getOrgId).collect(Collectors.toList());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;OrgEntity&amp;gt; orgList = feginClient.getOrgByIds(orgIds);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt;(SearchEntity entity : &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String orgCode = findOrgCode(orgList, entity.getOrgId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ScoreSearchEntity scoreSearchEntity = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ScoreSearchEntity();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        scoreSearchEntity.setOrgCode(orgCode);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        scoreSearchEntity.setCategoryId(entity.getCategoryId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        scoreSearchEntity.setBusinessId(entity.getBusinessId());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        scoreSearchEntity.setBusinessType(entity.getBusinessType());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;ScoreEntity&amp;gt; resultList = scoreMapper.queryScore(scoreSearchEntity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(CollectionUtils.isNotEmpty(resultList)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ScoreEntity scoreEntity = resultList.get(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            result.add(scoreEntity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实在真实场景中，代码比这个复杂很多，这里为了给大家演示，简化了一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最关键的地方有两点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中的第1点，即：在接口中远程调用了另外一个接口，这个代码是必须的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为如果在评价表中冗余一个组织code字段，万一哪天组织表中的组织code有修改，不得不通过某种机制，通知我们同步修改评价表的组织code，不然就会出现数据不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很显然，如果要这样调整的话，业务流程上要改了，代码改动有点大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，还是先保持在接口中远程调用吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样看来，可以优化的地方只能在：for循环中查询数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一次优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;由于需要在for循环中，每条记录都要根据不同的条件，查询出想要的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于业务系统调用这个接口时，没有传id，不好在where条件中用id in (...)，这方式批量查询数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，有一种办法不用循环查询，一条sql就能搞定需求：使用or关键字拼接，例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(org_code=&#x27;001&#x27; and category_id=123 and business_id=111 and business_type=1) or (org_code=&#x27;002&#x27; and category_id=123 and business_id=112 and business_type=2) or (org_code=&#x27;003&#x27; and category_id=124 and business_id=117 and business_type=1)...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式会导致sql语句会非常长，性能也会很差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实还有一种写法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;where&lt;/span&gt; (a,b) &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; ((1,2),(1,3)...)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过这种sql，如果一次性查询的数据量太多的话，性能也不太好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;居然没法改成批量查询，就只能优化单条查询sql的执行效率了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先从索引入手，因为改造成本最低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一次优化是优化索引。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;评价表之前建立一个business_id字段的普通索引，但是从目前来看效率不太理想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我果断加了联合索引：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;alter&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; user_score &lt;span class=&quot;code-snippet__keyword&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;index&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;`un_org_category_business`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`org_code`&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;`category_id`&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;`business_id`&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;`business_type`&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;USING&lt;/span&gt; BTREE;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该联合索引由：org_code、category_id、business_id和business_type四个字段组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过这次优化，效果立竿见影。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;批量评价查询接口最大耗时，从最初的20s，缩短到了5s左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二次优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;由于需要在for循环中，每条记录都要根据不同的条件，查询出想要的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只在一个线程中查询数据，显然太慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，为何不能改成多线程调用？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二次优化，查询数据库由单线程改成多线程。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但由于该接口是要将查询出的所有数据，都返回回去的，所以要获取查询结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用多线程调用，并且要获取返回值，这种场景使用java8中的CompleteFuture非常合适。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码调整为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CompletableFuture[] futureArray = dataList.stream()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     .&lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;(data -&amp;gt; CompletableFuture&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          .supplyAsync(() -&amp;gt; query(data), asyncExecutor)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          .whenComplete((result, th) -&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       })).toArray(CompletableFuture[]::&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CompletableFuture.allOf(futureArray).join();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CompleteFuture的本质是创建线程执行，为了避免产生太多的线程，所以使用线程池是非常有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优先推荐使用ThreadPoolExecutor类，我们自定义线程池。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体代码如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ExecutorService threadPool = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span class=&quot;code-snippet__number&quot;&gt;500&lt;/span&gt;), &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以使用ThreadPoolTaskExecutor类创建线程池：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Configuration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ThreadPoolConfig&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; corePoolSize = &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; maxPoolSize = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; keepAliveSeconds = &lt;span class=&quot;code-snippet__number&quot;&gt;60&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; queueCapacity = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; boolean allowCoreThreadTimeOut = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Bean(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;asyncExecutor&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; Executor &lt;span class=&quot;code-snippet__title&quot;&gt;asyncExecutor&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ThreadPoolTaskExecutor executor = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolTaskExecutor();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setCorePoolSize(corePoolSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setMaxPoolSize(maxPoolSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setQueueCapacity(queueCapacity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setKeepAliveSeconds(keepAliveSeconds);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setAllowCoreThreadTimeOut(allowCoreThreadTimeOut);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.setRejectedExecutionHandler(&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        executor.initialize();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; executor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过这次优化，接口性能也提升了5倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从5s左右，缩短到1s左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但整体效果还不太理想。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三次优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过前面的两次优化，批量查询评价接口性能有一些提升，但耗时还是大于1s。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出现这个问题的根本原因是：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一次性查询的数据太多。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，我们为什么不限制一下，每次查询的记录条数呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三次优化，限制一次性查询的记录条数。其实之前也做了限制，不过最大是2000条记录，从目前看效果不好。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限制该接口一次只能查200条记录，如果超过200条则会报错提示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果直接对该接口做限制，则可能会导致业务系统出现异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免这种情况的发生，必须跟业务系统团队一起讨论一下优化方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要有下面两个方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、前端做分页&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在结算单列表页中，每个结算单默认只展示1个订单，多余的分页查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的话，如果按照每页最大100条记录计算的话，结算单和订单最多一次只能查询200条记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这就需要业务系统的前端做分页功能，同时后端接口要调整支持分页查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但目前现状是前端没有多余开发资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于人手不足的原因，这套方案目前只能暂时搁置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、分批调用接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;业务系统后端之前是一次性调用评价查询接口，现在改成分批调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如：之前查询500条记录，业务系统只调用一次查询接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在改成业务系统每次只查100条记录，分5批调用，总共也是查询500条记录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样不是变慢了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;答：如果那5批调用评价查询接口的操作，是在for循环中单线程顺序的，整体耗时当然可能会变慢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但业务系统也可以改成多线程调用，只需最终汇总结果即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，有人可能会问题：在评价查询接口的服务器多线程调用，跟在其他业务系统中多线程调用不是一回事？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还不如把批量评价查询接口的服务器中，线程池的最大线程数调大一点？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然你忽略了一件事：线上应用一般不会被部署成单点。绝大多数情况下，为了避免因为服务器挂了，造成单点故障，基本会部署至少2个节点。这样即使一个节点挂了，整个应用也能正常访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;当然也可能会出现这种情况：假如挂了一个节点，另外一个节点可能因为访问的流量太大了，扛不住压力，也可能因此挂掉。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;换句话说，通过业务系统中的多线程调用接口，可以将访问接口的流量负载均衡到不同的节点上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他们也用8个线程，将数据分批，每批100条记录，最后将结果汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过这次优化，接口性能再次提升了1倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从1s左右，缩短到小于500ms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;温馨提醒一下，无论是在批量查询评价接口查询数据库，还是在业务系统中调用批量查询评价接口，使用多线程调用，都只是一个临时方案，并不完美。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样做的原因主要是为了先快速解决问题，因为这种方案改动是最小的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要从根本上解决问题，需要重新设计这一套功能，需要修改表结构，甚至可能需要修改业务流程。但由于牵涉到多条业务线，多个业务系统，只能排期慢慢做了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨苏三呀&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：苏三说技术（ID：susanSayJava）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>476fa89d3d4e1550e19d3a27ea82ea30</guid>
<title>一文聊透Netty核心引擎Reactor的运转架构</title>
<link>https://toutiao.io/k/law381n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本系列Netty源码解析文章基于 &lt;strong&gt;4.1.56.Final&lt;/strong&gt;版本&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6411290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFZs7zYlwcxqnqELVwBvckheWP16qjRea4hxuzibk6tfhReyicy8TMDs4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者来为大家介绍下Netty的核心引擎Reactor的运转架构，希望通过本文的介绍能够让大家对Reactor是如何驱动着整个Netty框架的运转有一个全面的认识。也为我们后续进一步介绍Netty关于处理网络请求的整个生命周期的相关内容做一个前置知识的铺垫，方便大家后续理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在开始本文正式的内容之前，笔者先来带着大家回顾下前边文章介绍的关于Netty整个框架如何搭建的相关内容，没有看过笔者前边几篇文章的读者朋友也没关系，这些并不会影响到本文的阅读，只不过涉及到相关细节的部分，大家可以在回看下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前文回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中，我们介绍了Netty服务端的核心引擎&lt;code&gt;主从Reactor线程组&lt;/code&gt;的创建过程以及相关核心组件里的重要属性。在这个过程中，我们还提到了Netty对各种细节进行的优化，比如针对JDK NIO 原生Selector做的一些优化，展现了Netty对性能极致的追求。最终我们创建出了如下结构的Reactor。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2602941176470588&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYF9BJtQsWzRMtsGVOSD9OJycXuOW0pTtpic1aib4GpeEicBuNl814Qv6PxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中，我们完整地介绍了Netty服务端启动的整个流程，并介绍了在启动过程中涉及到的ServerBootstrap相关的属性以及配置方式。用于接收连接的服务端NioServerSocketChannel的创建和初始化过程以及其类的继承结构。其中重点介绍了NioServerSocketChannel向Reactor的注册过程以及Reactor线程的启动时机和pipeline的初始化时机。最后介绍了NioServerSocketChannel绑定端口地址的整个流程。在这个过程中我们了解了Netty的这些核心组件是如何串联起来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Netty启动完毕后，我们得到了如下的框架结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7161290322580646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYF3Sb4eQydEPlaoaZL8mIAf56VDPab5J8r2YdoIu4qAdWR3Y433jc6lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor启动后的结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主Reactor线程组中管理的是&lt;code&gt;NioServerSocketChannel&lt;/code&gt;用于接收客户端连接，并在自己的pipeline中的&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;里初始化接收到的客户端连接，随后会将初始化好的客户端连接注册到从Reactor线程组中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Reactor线程组主要负责监听处理注册其上的所有客户端连接的IO就绪事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一个Channel只能分配给一个固定的Reactor。一个Reactor负责处理多个Channel上的IO就绪事件，这样可以将服务端承载的&lt;code&gt;全量客户端连接&lt;/code&gt;分摊到多个&lt;code&gt;Reactor&lt;/code&gt;中处理，同时也能保证&lt;code&gt;Channel上IO处理的线程安全性&lt;/code&gt;。Reactor与Channel之间的对应关系如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9016129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFXJ6bzvZa8dt6DAKEkUHIomLTwlV4A3k8R7icd1aH7ibpb1UxRhiawoDcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是对笔者前边几篇文章的相关内容回顾，大家能回忆起来更好，回忆不起来也没关系，一点也不影响大家理解本文的内容。如果对相关细节感兴趣的同学，可以在阅读完本文之后，在去回看下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们言归正传，正式开始本文的内容，笔者接下来会为大家介绍这些核心组件是如何相互配合从而驱动着整个Netty Reactor框架运转的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Netty Reactor框架启动完毕后，接下来第一件事情也是最重要的事情就是如何来高效的接收客户端的连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在探讨Netty服务端如何接收连接之前，我们需要弄清楚&lt;code&gt;Reactor线程&lt;/code&gt;的运行机制，它是如何监听并处理&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文相当于是后续我们介绍&lt;code&gt;Reactor线程&lt;/code&gt;监听处理&lt;code&gt;ACCEPT事件&lt;/code&gt;，&lt;code&gt;Read事件&lt;/code&gt;，&lt;code&gt;Write事件&lt;/code&gt;的前置篇，本文专注于讲述&lt;code&gt;Reactor线程&lt;/code&gt;的整个运行框架。理解了本文的内容，对理解后面&lt;code&gt;Reactor线程&lt;/code&gt;如何处理&lt;code&gt;IO事件&lt;/code&gt;会大有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在Netty框架的&lt;code&gt;创建阶段&lt;/code&gt;和&lt;code&gt;启动阶段&lt;/code&gt;无数次的提到了&lt;code&gt;Reactor线程&lt;/code&gt;，那么在本文要介绍的&lt;code&gt;运行阶段&lt;/code&gt;就该这个&lt;code&gt;Reactor线程&lt;/code&gt;来大显神威了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边文章的介绍，我们了解到Netty中的&lt;code&gt;Reactor线程&lt;/code&gt;主要干三件事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;轮询注册在&lt;code&gt;Reactor&lt;/code&gt;上的所有&lt;code&gt;Channel&lt;/code&gt;感兴趣的&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;执行Netty中的异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是这三个部分组成了&lt;code&gt;Reactor&lt;/code&gt;的运行框架，那么我们现在来看下这个运行框架具体是怎么运转的~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Reactor线程的整个运行框架&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家还记不记得笔者在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中提到的，&lt;code&gt;IO模型的演变&lt;/code&gt;是围绕着&lt;code&gt;&quot;如何用尽可能少的线程去管理尽可能多的连接&quot;&lt;/code&gt;这一主题进行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty的&lt;code&gt;IO模型&lt;/code&gt;是通过&lt;code&gt;JDK NIO Selector&lt;/code&gt;实现的&lt;code&gt;IO多路复用模型&lt;/code&gt;，而Netty的&lt;code&gt;IO线程模型&lt;/code&gt;为&lt;code&gt;主从Reactor线程模型&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中介绍的&lt;code&gt;IO多路复用模型&lt;/code&gt;我们很容易就能理解到Netty会使用一个用户态的&lt;code&gt;Reactor线程&lt;/code&gt;去不断的通过&lt;code&gt;Selector&lt;/code&gt;在内核态去轮训&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了&lt;code&gt;Reactor线程&lt;/code&gt;其实执行的就是一个&lt;code&gt;死循环&lt;/code&gt;，在&lt;code&gt;死循环&lt;/code&gt;中不断的通过&lt;code&gt;Selector&lt;/code&gt;去轮训&lt;code&gt;IO就绪事件&lt;/code&gt;，如果发生&lt;code&gt;IO就绪事件&lt;/code&gt;则从&lt;code&gt;Selector&lt;/code&gt;系统调用中返回并处理&lt;code&gt;IO就绪事件&lt;/code&gt;，如果没有发生&lt;code&gt;IO就绪事件&lt;/code&gt;则一直&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;系统调用上，直到满足&lt;code&gt;Selector唤醒条件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下三个条件中只要满足任意一个条件，Reactor线程就会被从Selector上唤醒：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当Selector轮询到有IO活跃事件发生时。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当Reactor线程需要执行的&lt;code&gt;定时任务&lt;/code&gt;到达任务执行时间&lt;code&gt;deadline&lt;/code&gt;时。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当有&lt;code&gt;异步任务&lt;/code&gt;提交给Reactor时，Reactor线程需要从&lt;code&gt;Selector&lt;/code&gt;上被唤醒，这样才能及时的去执行&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看出Netty对&lt;code&gt;Reactor线程&lt;/code&gt;的压榨还是比较狠的，反正现在也没有&lt;code&gt;IO就绪事件&lt;/code&gt;需要去处理，不能让&lt;code&gt;Reactor线程&lt;/code&gt;在这里白白等着，要立即唤醒它，转去处理提交过来的异步任务以及定时任务。&lt;code&gt;Reactor线程&lt;/code&gt;堪称&lt;code&gt;996典范&lt;/code&gt;一刻不停歇地运作着。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFStYibtFGcGpgBia49BM6Jvxw7NnD4XDqB5kA93lJVNyblXRYmYVbVBXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了&lt;code&gt;Reactor线程&lt;/code&gt;的大概运行框架后，我们接下来就到源码中去看下它的核心运转框架是如何实现出来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这块源码比较庞大繁杂，所以笔者先把它的运行框架提取出来，方便大家整体的理解整个运行过程的全貌。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9887096774193549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFOF4Su0ibt9XMdrY13gqzSyRU1iaWEtYnvBZC7I4mnjgGEuupMz2QfnMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor工作流程图.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所展示的就是Reactor整个工作体系的全貌，主要分为如下几个重要的工作模块：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Reactor线程在Selector上阻塞获取IO就绪事件。在这个模块中首先会去检查当前是否有异步任务需要执行，如果有异步需要执行，那么不管当前有没有IO就绪事件都不能阻塞在Selector上，随后会去非阻塞的轮询一下Selector上是否有IO就绪事件，如果有，正好可以和异步任务一起执行。优先处理IO就绪事件，在执行异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果当前没有异步任务需要执行，那么Reactor线程会接着查看是否有定时任务需要执行，如果有则在Selector上阻塞直到定时任务的到期时间deadline，或者满足其他唤醒条件被唤醒。如果没有定时任务需要执行，Reactor线程则会在Selector上一直阻塞直到满足唤醒条件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当Reactor线程满足唤醒条件被唤醒后，首先会去判断当前是因为有IO就绪事件被唤醒还是因为有异步任务需要执行被唤醒或者是两者都有。随后Reactor线程就会去处理IO就绪事件和执行异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后Reactor线程返回循环起点不断的重复上述三个步骤。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是Reactor线程运行的整个核心逻辑，下面是笔者根据上述核心逻辑，将Reactor的整体代码设计框架提取出来，大家可以结合上边的Reactor工作流程图，从总体上先感受下整个源码实现框架，能够把Reactor的核心处理步骤和代码中相应的处理模块对应起来即可，这里不需要读懂每一行代码，要以逻辑处理模块为单位理解。后面笔者会将这些一个一个的逻辑处理模块在单独拎出来为大家详细介绍。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//记录轮询次数 用于解决JDK epoll的空轮训bug&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;//轮询结果&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//根据轮询策略获取轮询结果 这里的hasTasks()主要检查的是普通队列和尾部队列中是否有异步任务等待执行&lt;/span&gt;&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;                        &lt;span&gt;// NIO不支持自旋（BUSY_WAIT）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;&lt;br/&gt;                      核心逻辑是有任务需要执行，则Reactor线程立马执行异步任务，如果没有异步任务执行，则进行轮询IO事件&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                       ................省略...............&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                执行到这里说明满足了唤醒条件，Reactor线程从selector上被唤醒开始处理IO就绪事件和执行异步任务&lt;br/&gt;                &lt;span&gt;/**&lt;br/&gt;                 * Reactor线程需要保证及时的执行异步任务，只要有异步任务提交，就需要退出轮询。&lt;br/&gt;                 * 有IO事件就优先处理IO事件，然后处理异步任务&lt;br/&gt;                 * */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                selectCnt++;&lt;br/&gt;                &lt;span&gt;//主要用于从IO就绪的SelectedKeys集合中剔除已经失效的selectKey&lt;/span&gt;&lt;br/&gt;                needsToSelectAgain = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;//调整Reactor线程执行IO事件和执行异步任务的CPU时间比例 默认50，表示执行IO事件和异步任务的时间比例是一比一&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ioRatio = &lt;span&gt;this&lt;/span&gt;.ioRatio;&lt;br/&gt;             &lt;br/&gt;               这里主要处理IO就绪事件，以及执行异步任务&lt;br/&gt;               需要优先处理IO就绪事件，然后根据ioRatio设置的处理IO事件CPU用时与异步任务CPU用时比例，&lt;br/&gt;               来决定执行多长时间的异步任务&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;//判断是否触发JDK Epoll BUG 触发空轮询&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (ranTasks || strategy &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selectCnt &amp;gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;amp;&amp;amp; logger.isDebugEnabled()) {&lt;br/&gt;                        logger.debug(&lt;span&gt;&quot;Selector.select() returned prematurely {} times in a row for Selector {}.&quot;&lt;/span&gt;,&lt;br/&gt;                                selectCnt - &lt;span&gt;1&lt;/span&gt;, selector);&lt;br/&gt;                    }&lt;br/&gt;                    selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (unexpectedSelectorWakeup(selectCnt)) { &lt;span&gt;// Unexpected wakeup (unusual case)&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//既没有IO就绪事件，也没有异步任务，Reactor线程从Selector上被异常唤醒 触发JDK Epoll空轮训BUG&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//重新构建Selector,selectCnt归零&lt;/span&gt;&lt;br/&gt;                    selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException e) {&lt;br/&gt;                ................省略...............&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Error e) {&lt;br/&gt;                ................省略...............&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;              ................省略...............&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;              ................省略...............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面提取出来的Reactor的源码实现框架中，我们可以看出&lt;code&gt;Reactor线程&lt;/code&gt;主要做了下面几个事情：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;JDK NIO Selector&lt;/code&gt;轮询注册在&lt;code&gt;Reactor&lt;/code&gt;上的所有&lt;code&gt;Channel&lt;/code&gt;感兴趣的&lt;code&gt;IO事件&lt;/code&gt;。对于NioServerSocketChannel来说因为它主要负责接收客户端连接所以监听的是&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，对于客户端NioSocketChannel来说因为它主要负责处理连接上的读写事件所以监听的是&lt;code&gt;OP_READ&lt;/code&gt;和&lt;code&gt;OP_WRITE&lt;/code&gt;事件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里需要注意的是netty只会自动注册&lt;code&gt;OP_READ&lt;/code&gt;事件，而&lt;code&gt;OP_WRITE事件&lt;/code&gt;是在当Socket写入缓冲区以满无法继续写入发送数据时由用户自己注册。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果有异步任务需要执行，则立马停止轮询操作，转去执行异步任务。这里分为两种情况：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里第二种情况下只会执行&lt;code&gt;64&lt;/code&gt;个异步任务，目的是为了&lt;code&gt;防止过度&lt;/code&gt;执行异步任务，&lt;code&gt;耽误了&lt;/code&gt;最重要的事情&lt;code&gt;轮询IO事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;既有&lt;code&gt;IO就绪事件&lt;/code&gt;发生，也有&lt;code&gt;异步任务&lt;/code&gt;需要执行。则优先处理&lt;code&gt;IO就绪事件&lt;/code&gt;，然后根据&lt;code&gt;ioRatio&lt;/code&gt;设置的&lt;code&gt;执行时间比例&lt;/code&gt;决定执行多长时间的异步任务。这里Reactor线程需要控制异步任务的执行时间，因为Reactor线程的核心是处理IO就绪事件，不能因为异步任务的执行而耽误了最重要的事情。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;没有&lt;code&gt;IO就绪事件&lt;/code&gt;发生，但是有异步任务或者定时任务到期需要执行。则只执行&lt;code&gt;异步任务&lt;/code&gt;，尽可能的去压榨Reactor线程。没有IO就绪事件发生也不能闲着。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在最后Netty会判断本次&lt;code&gt;Reactor线程&lt;/code&gt;的唤醒是否是由于触发了JDK epoll 空轮询 BUG导致的，如果触发了该BUG，则重建&lt;code&gt;Selector&lt;/code&gt;。绕过JDK BUG，达到解决问题的目的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;正常情况下Reactor线程从Selector中被唤醒有两种情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;轮询到有IO就绪事件发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有异步任务或者定时任务需要执行。而JDK epoll 空轮询 BUG会在上述两种情况都没有发生的时候，&lt;code&gt;Reactor线程&lt;/code&gt;会意外的从&lt;code&gt;Selector&lt;/code&gt;中被唤醒，导致CPU空转。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;JDK epoll 空轮询 BUG：https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6670302&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，&lt;code&gt;Reactor线程&lt;/code&gt;的总体运行结构框架我们现在已经了解了，下面我们来深入到这些核心处理模块中来各个击破它们~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Reactor线程轮询IO就绪事件&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中，笔者在讲述主从Reactor线程组&lt;code&gt;NioEventLoopGroup&lt;/code&gt;的创建过程的时候，提到一个构造器参数&lt;code&gt;SelectStrategyFactory&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioEventLoopGroup&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nThreads, Executor executor, &lt;span&gt;final&lt;/span&gt; SelectorProvider selectorProvider)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioEventLoopGroup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; nThreads, Executor executor, &lt;span&gt;final&lt;/span&gt; SelectorProvider selectorProvider,&lt;br/&gt;                             &lt;span&gt;final&lt;/span&gt; SelectStrategyFactory selectStrategyFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor线程&lt;/code&gt;最重要的一件事情就是&lt;code&gt;轮询IO就绪事件&lt;/code&gt;，&lt;code&gt;SelectStrategyFactory&lt;/code&gt;就是用于指定轮询策略的，默认实现为&lt;code&gt;DefaultSelectStrategyFactory.INSTANCE&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在&lt;code&gt;Reactor线程&lt;/code&gt;开启轮询的一开始，就是用这个&lt;code&gt;selectStrategy&lt;/code&gt;去计算一个&lt;code&gt;轮询策略strategy&lt;/code&gt;，后续会根据这个&lt;code&gt;strategy&lt;/code&gt;进行不同的逻辑处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//记录轮询次数 用于解决JDK epoll的空轮训bug&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;//轮询结果&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//根据轮询策略获取轮询结果 这里的hasTasks()主要检查的是普通队列和尾部队列中是否有异步任务等待执行&lt;/span&gt;&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;                        &lt;span&gt;// NIO不支持自旋（BUSY_WAIT）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;&lt;br/&gt;                      核心逻辑是有任务需要执行，则Reactor线程立马执行异步任务，如果没有异步任务执行，则进行轮询IO事件&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                       ................省略...............&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ................省略...............&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看这个&lt;code&gt;轮询策略strategy&lt;/code&gt;具体的计算逻辑是什么样的？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 轮询策略&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFRjvX4vtsxTw9saKgjLCukHZumCxiaENW9iaHZs7WeiarxDYX11Ot5Hqcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor流程处理分支走向.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;SelectStrategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Indicates a blocking select should follow.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; SELECT = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Indicates the IO loop should be retried, no blocking select to follow directly.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; CONTINUE = -&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Indicates the IO loop to poll for new events without blocking.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; BUSY_WAIT = -&lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;calculateStrategy&lt;/span&gt;&lt;span&gt;(IntSupplier selectSupplier, &lt;span&gt;boolean&lt;/span&gt; hasTasks)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先来看下Netty中定义的这三种轮询策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SelectStrategy.SELECT：&lt;/code&gt;此时没有任何异步任务需要执行，&lt;code&gt;Reactor线程&lt;/code&gt;可以安心的&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO就绪事件&lt;/code&gt;的来临。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SelectStrategy.CONTINUE：&lt;/code&gt;重新开启一轮&lt;code&gt;IO轮询&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;SelectStrategy.BUSY_WAIT：&lt;/code&gt; Reactor线程进行&lt;code&gt;自旋轮询&lt;/code&gt;，由于&lt;code&gt;NIO 不支持自旋操作&lt;/code&gt;，所以这里直接跳到&lt;code&gt;SelectStrategy.SELECT&lt;/code&gt;策略。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下&lt;code&gt;轮询策略&lt;/code&gt;的计算逻辑&lt;code&gt;calculateStrategy&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultSelectStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SelectStrategy&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SelectStrategy INSTANCE = &lt;span&gt;new&lt;/span&gt; DefaultSelectStrategy();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;DefaultSelectStrategy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;calculateStrategy&lt;/span&gt;&lt;span&gt;(IntSupplier selectSupplier, &lt;span&gt;boolean&lt;/span&gt; hasTasks)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * Reactor线程要保证及时的执行异步任务&lt;br/&gt;         * 1：如果有异步任务等待执行，则马上执行selectNow()非阻塞轮询一次IO就绪事件&lt;br/&gt;         * 2：没有异步任务，则跳到switch select分支&lt;br/&gt;         * */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;Reactor线程&lt;/code&gt;的轮询工作开始之前，需要首先判断下当前是否有&lt;code&gt;异步任务&lt;/code&gt;需要执行。判断依据就是查看&lt;code&gt;Reactor&lt;/code&gt;中的异步任务队列&lt;code&gt;taskQueue&lt;/code&gt;和用于统计信息任务用的尾部队列&lt;code&gt;tailTask&lt;/code&gt;是否有&lt;code&gt;异步任务&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasTasks&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.hasTasks() || !tailTasks.isEmpty();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasTasks&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; !taskQueue.isEmpty();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;Reactor&lt;/code&gt;中有&lt;code&gt;异步任务&lt;/code&gt;需要执行，那么&lt;code&gt;Reactor线程&lt;/code&gt;需要立即执行，不能阻塞在&lt;code&gt;Selector&lt;/code&gt;上。在返回前需要再顺带调用&lt;code&gt;selectNow()&lt;/code&gt;非阻塞查看一下当前是否有&lt;code&gt;IO就绪事件&lt;/code&gt;发生。如果有，那么正好可以和&lt;code&gt;异步任务&lt;/code&gt;一起被处理，如果没有，则及时地处理&lt;code&gt;异步任务&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里Netty要表达的语义是：首先Reactor线程需要优先保证&lt;code&gt;IO就绪事件&lt;/code&gt;的处理，然后在保证&lt;code&gt;异步任务&lt;/code&gt;的及时执行。如果当前没有IO就绪事件但是有异步任务需要执行时，Reactor线程就要去及时执行异步任务而不是继续阻塞在Selector上等待IO就绪事件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; IntSupplier selectNowSupplier = &lt;span&gt;new&lt;/span&gt; IntSupplier() {&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; selectNow();&lt;br/&gt;        }&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;selectNow&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//非阻塞&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; selector.selectNow();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果当前&lt;code&gt;Reactor线程&lt;/code&gt;没有异步任务需要执行，那么&lt;code&gt;calculateStrategy&lt;/code&gt;方法直接返回&lt;code&gt;SelectStrategy.SELECT&lt;/code&gt;也就是&lt;code&gt;SelectStrategy接口&lt;/code&gt;中定义的常量&lt;code&gt;-1&lt;/code&gt;。当&lt;code&gt;calculateStrategy&lt;/code&gt;方法通过&lt;code&gt;selectNow()&lt;/code&gt;返回&lt;code&gt;非零&lt;/code&gt;数值时，表示此时有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;，返回的数值表示有多少个&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//记录轮询次数 用于解决JDK epoll的空轮训bug&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;//轮询结果&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;//根据轮询策略获取轮询结果 这里的hasTasks()主要检查的是普通队列和尾部队列中是否有异步任务等待执行&lt;/span&gt;&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:&lt;br/&gt;                        &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;                        &lt;span&gt;// NIO不支持自旋（BUSY_WAIT）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;&lt;br/&gt;                      核心逻辑是有任务需要执行，则Reactor线程立马执行异步任务，如果没有异步任务执行，则进行轮询IO事件&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                       ................省略...............&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ................处理IO就绪事件以及执行异步任务...............&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从默认的轮询策略我们可以看出&lt;code&gt;selectStrategy.calculateStrategy&lt;/code&gt;只会返回三种情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFRjvX4vtsxTw9saKgjLCukHZumCxiaENW9iaHZs7WeiarxDYX11Ot5Hqcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor流程处理分支走向.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;返回 -1：&lt;/code&gt; switch逻辑分支进入&lt;code&gt;SelectStrategy.SELECT分支&lt;/code&gt;，表示此时&lt;code&gt;Reactor&lt;/code&gt;中没有&lt;code&gt;异步任务&lt;/code&gt;需要执行，&lt;code&gt;Reactor线程&lt;/code&gt;可以安心的阻塞在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO就绪事件&lt;/code&gt;发生。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;返回 0：&lt;/code&gt; switch逻辑分支进入&lt;code&gt;default分支&lt;/code&gt;，表示此时&lt;code&gt;Reactor&lt;/code&gt;中没有&lt;code&gt;IO就绪事件&lt;/code&gt;但是有&lt;code&gt;异步任务&lt;/code&gt;需要执行，流程通过&lt;code&gt;default分支&lt;/code&gt;直接进入了处理&lt;code&gt;异步任务&lt;/code&gt;的逻辑部分。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;返回 &amp;gt; 0：&lt;/code&gt;switch逻辑分支进入&lt;code&gt;default分支&lt;/code&gt;，表示此时&lt;code&gt;Reactor&lt;/code&gt;中既有&lt;code&gt;IO就绪事件&lt;/code&gt;发生也有&lt;code&gt;异步任务&lt;/code&gt;需要执行，流程通过&lt;code&gt;default分支&lt;/code&gt;直接进入了处理&lt;code&gt;IO就绪事件&lt;/code&gt;和执行&lt;code&gt;异步任务&lt;/code&gt;逻辑部分。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在&lt;code&gt;Reactor&lt;/code&gt;的流程处理逻辑走向我们清楚了，那么接下来我们把重点放在SelectStrategy.SELECT分支中的轮询逻辑上。&lt;strong&gt;这块是Reactor监听IO就绪事件的核心。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 轮询逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5830645161290322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFppsKicLX6qTzetw7xTSCSBXf1t3oDqpwOFPExEpTkicby9KKN6kx500g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor轮询逻辑.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;                        &lt;span&gt;//当前没有异步任务执行，Reactor线程可以放心的阻塞等待IO就绪事件&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;//从定时任务队列中取出即将快要执行的定时任务deadline&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;long&lt;/span&gt; curDeadlineNanos = nextScheduledTaskDeadlineNanos();&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (curDeadlineNanos == -&lt;span&gt;1L&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;// -1代表当前定时任务队列中没有定时任务&lt;/span&gt;&lt;br/&gt;                            curDeadlineNanos = NONE; &lt;span&gt;// nothing on the calendar&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;//最早执行定时任务的deadline作为 select的阻塞时间，意思是到了定时任务的执行时间&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;//不管有无IO就绪事件，必须唤醒selector，从而使reactor线程执行定时任务&lt;/span&gt;&lt;br/&gt;                        nextWakeupNanos.set(curDeadlineNanos);&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (!hasTasks()) {&lt;br/&gt;                                &lt;span&gt;//再次检查普通任务队列中是否有异步任务&lt;/span&gt;&lt;br/&gt;                                &lt;span&gt;//没有的话开始select阻塞轮询IO就绪事件&lt;/span&gt;&lt;br/&gt;                                strategy = select(curDeadlineNanos);&lt;br/&gt;                            }&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            &lt;span&gt;// 执行到这里说明Reactor已经从Selector上被唤醒了&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;// 设置Reactor的状态为苏醒状态AWAKE&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;// lazySet优化不必要的volatile操作，不使用内存屏障，不保证写操作的可见性（单线程不需要保证）&lt;/span&gt;&lt;br/&gt;                            nextWakeupNanos.lazySet(AWAKE);&lt;br/&gt;                        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程走到这里，说明现在&lt;code&gt;Reactor&lt;/code&gt;上没有任何事情可做，可以安心的&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO就绪事件&lt;/code&gt;到来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么&lt;code&gt;Reactor线程&lt;/code&gt;到底应该在&lt;code&gt;Selector&lt;/code&gt;上阻塞多久呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在回答这个问题之前，我们在回顾下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中在讲述&lt;code&gt;Reactor的创建&lt;/code&gt;时提到，&lt;code&gt;Reactor线程&lt;/code&gt;除了要轮询&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;，以及处理&lt;code&gt;IO就绪事件&lt;/code&gt;外，还有一个任务就是负责执行Netty框架中的&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0638516992790936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYF2z2StLK5aqZCVvhqW8H1aRad648gic3vczTpajsorJMdHtfmTcSYicSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;figcaption&gt;Reactor结构更新.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Netty框架中的&lt;code&gt;异步任务&lt;/code&gt;分为三类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存放在普通任务队列&lt;code&gt;taskQueue&lt;/code&gt;中的普通异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存放在尾部队列&lt;code&gt;tailTasks&lt;/code&gt;中的用于执行统计任务等收尾动作的尾部任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;还有一种就是这里即将提到的&lt;code&gt;定时任务&lt;/code&gt;。存放在&lt;code&gt;Reactor&lt;/code&gt;中的定时任务队列&lt;code&gt;scheduledTaskQueue&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Reactor&lt;code&gt;NioEventLoop类&lt;/code&gt;中的继承结构我们也可以看出，&lt;code&gt;Reactor&lt;/code&gt;具备执行定时任务的能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9387096774193548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFe5Q1CmQVQBfs4EJbg5JT1aHqetdpD0moOicZsdKRcm7hpksgRL8LbeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然&lt;code&gt;Reactor&lt;/code&gt;需要执行定时任务，那么它就不能一直&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上无限等待&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们回到本小节一开始提到的问题上，为了保证&lt;code&gt;Reactor&lt;/code&gt;能够及时地执行&lt;code&gt;定时任务&lt;/code&gt;，&lt;code&gt;Reactor线程&lt;/code&gt;需要在即将要执行的的第一个定时任务&lt;code&gt;deadline&lt;/code&gt;到达之前被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在&lt;code&gt;Reactor&lt;/code&gt;线程开始轮询&lt;code&gt;IO就绪事件&lt;/code&gt;之前，我们需要首先计算出来&lt;code&gt;Reactor线程&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上的阻塞超时时间。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1 Reactor的轮询超时时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要从&lt;code&gt;Reactor&lt;/code&gt;的定时任务队列&lt;code&gt;scheduledTaskQueue&lt;/code&gt;中取出即将快要执行的定时任务&lt;code&gt;deadline&lt;/code&gt;。将这个&lt;code&gt;deadline&lt;/code&gt;作为&lt;code&gt;Reactor线程&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上轮询的超时时间。这样可以保证在定时任务即将要执行时，Reactor现在可以及时的从Selector上被唤醒。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; AWAKE = -&lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; NONE = Long.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// nextWakeupNanos is:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//    AWAKE            when EL is awake&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//    NONE             when EL is waiting with no wakeup scheduled&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//    other value T    when EL is waiting with wakeup scheduled at time T&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicLong nextWakeupNanos = &lt;span&gt;new&lt;/span&gt; AtomicLong(AWAKE);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;long&lt;/span&gt; curDeadlineNanos = nextScheduledTaskDeadlineNanos();&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (curDeadlineNanos == -&lt;span&gt;1L&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;// -1代表当前定时任务队列中没有定时任务&lt;/span&gt;&lt;br/&gt;            curDeadlineNanos = NONE; &lt;span&gt;// nothing on the calendar&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      nextWakeupNanos.set(curDeadlineNanos);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractScheduledEventExecutor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractEventExecutor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    PriorityQueue&amp;lt;ScheduledFutureTask&amp;lt;?&amp;gt;&amp;gt; scheduledTaskQueue;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nextScheduledTaskDeadlineNanos&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ScheduledFutureTask&amp;lt;?&amp;gt; scheduledTask = peekScheduledTask();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; scheduledTask != &lt;span&gt;null&lt;/span&gt; ? scheduledTask.deadlineNanos() : -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; ScheduledFutureTask&amp;lt;?&amp;gt; peekScheduledTask() {&lt;br/&gt;        Queue&amp;lt;ScheduledFutureTask&amp;lt;?&amp;gt;&amp;gt; scheduledTaskQueue = &lt;span&gt;this&lt;/span&gt;.scheduledTaskQueue;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; scheduledTaskQueue != &lt;span&gt;null&lt;/span&gt; ? scheduledTaskQueue.peek() : &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nextScheduledTaskDeadlineNanos&lt;/code&gt;方法会返回当前&lt;code&gt;Reactor&lt;/code&gt;定时任务队列中最近的一个定时任务&lt;code&gt;deadline&lt;/code&gt;时间点，如果定时任务队列中没有定时任务，则返回&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NioEventLoop&lt;/code&gt;中&lt;code&gt;nextWakeupNanos&lt;/code&gt;变量用来存放Reactor从&lt;code&gt;Selector&lt;/code&gt;上被唤醒的时间点，设置为最近需要被执行定时任务的&lt;code&gt;deadline&lt;/code&gt;，如果当前并没有定时任务需要执行，那么就设置为&lt;code&gt;Long.MAX_VALUE&lt;/code&gt;一直阻塞，直到有&lt;code&gt;IO就绪事件&lt;/code&gt;到达或者有&lt;code&gt;异步任务&lt;/code&gt;需要执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2 Reactor开始轮询IO就绪事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;     &lt;span&gt;if&lt;/span&gt; (!hasTasks()) {&lt;br/&gt;             &lt;span&gt;//再次检查普通任务队列中是否有异步任务， 没有的话  开始select阻塞轮询IO就绪事件&lt;/span&gt;&lt;br/&gt;            strategy = select(curDeadlineNanos);&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Reactor线程&lt;/code&gt;开始&lt;code&gt;阻塞&lt;/code&gt;轮询&lt;code&gt;IO就绪事件&lt;/code&gt;之前还需要再次检查一下是否有&lt;code&gt;异步任务&lt;/code&gt;需要执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时恰巧有&lt;code&gt;异步任务&lt;/code&gt;提交，就需要停止&lt;code&gt;IO就绪事件&lt;/code&gt;的轮询，转去执行&lt;code&gt;异步任务&lt;/code&gt;。如果没有&lt;code&gt;异步任务&lt;/code&gt;，则正式开始轮询&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deadlineNanos)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (deadlineNanos == NONE) {&lt;br/&gt;            &lt;span&gt;//无定时任务，无普通任务执行时，开始轮询IO就绪事件，没有就一直阻塞 直到唤醒条件成立&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; selector.select();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeoutMillis = deadlineToDelayNanos(deadlineNanos + &lt;span&gt;995000L&lt;/span&gt;) / &lt;span&gt;1000000L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; timeoutMillis &amp;lt;= &lt;span&gt;0&lt;/span&gt; ? selector.selectNow() : selector.select(timeoutMillis);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;deadlineNanos == NONE&lt;/code&gt;，经过上小节的介绍，我们知道&lt;code&gt;NONE&lt;/code&gt;表示当前&lt;code&gt;Reactor&lt;/code&gt;中并没有定时任务，所以可以安心的&lt;code&gt;阻塞&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO就绪事件&lt;/code&gt;到来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;selector.select()&lt;/code&gt;调用是一个阻塞调用，如果没有&lt;code&gt;IO就绪事件&lt;/code&gt;，&lt;code&gt;Reactor线程&lt;/code&gt;就会一直阻塞在这里直到&lt;code&gt;IO就绪事件&lt;/code&gt;到来。这里占时不考虑前边提到的&lt;code&gt;JDK NIO Epoll的空轮询BUG&lt;/code&gt;.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读到这里那么问题来了，此时&lt;code&gt;Reactor线程&lt;/code&gt;正阻塞在&lt;code&gt;selector.select()&lt;/code&gt;调用上等待&lt;code&gt;IO就绪事件&lt;/code&gt;的到来，如果此时正好有&lt;code&gt;异步任务&lt;/code&gt;被提交到&lt;code&gt;Reactor&lt;/code&gt;中需要执行，并且此时无任何&lt;code&gt;IO就绪事件&lt;/code&gt;，而&lt;code&gt;Reactor线程&lt;/code&gt;由于没有&lt;code&gt;IO就绪事件&lt;/code&gt;到来，会继续在这里阻塞，那么如何去执行&lt;code&gt;异步任务&lt;/code&gt;呢？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFJJPIIfkCKgCHElXfQZDLmeZqu180PMHCjdxp8sgjiaUomcwuvA82VrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解铃还须系铃人，既然&lt;code&gt;异步任务&lt;/code&gt;在被提交后希望立马得到执行，那么就在提交&lt;code&gt;异步任务&lt;/code&gt;的时候去唤醒&lt;code&gt;Reactor线程&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;//addTaskWakesUp = true 表示 当且仅当只有调用addTask方法时 才会唤醒Reactor线程&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//addTaskWakesUp = false 表示 并不是只有addTask方法才能唤醒Reactor 还有其他方法可以唤醒Reactor 默认设置false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addTaskWakesUp;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(Runnable task, &lt;span&gt;boolean&lt;/span&gt; immediate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; inEventLoop = inEventLoop();&lt;br/&gt;        addTask(task);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!inEventLoop) {&lt;br/&gt;            &lt;span&gt;//如果当前线程不是Reactor线程，则启动Reactor线程&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//这里可以看出Reactor线程的启动是通过 向NioEventLoop添加异步任务时启动的&lt;/span&gt;&lt;br/&gt;            startThread();&lt;br/&gt;            .....................省略...................&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!addTaskWakesUp &amp;amp;&amp;amp; immediate) {&lt;br/&gt;            &lt;span&gt;//io.netty.channel.nio.NioEventLoop.wakeup&lt;/span&gt;&lt;br/&gt;            wakeup(inEventLoop);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;code&gt;execute方法&lt;/code&gt;我想大家一定不会陌生，在上篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中我们在介绍&lt;code&gt;Reactor线程的启动&lt;/code&gt;时介绍过该方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动过程中涉及到的重要操作&lt;code&gt;Register操作&lt;/code&gt;，&lt;code&gt;Bind操作&lt;/code&gt;都需要封装成&lt;code&gt;异步任务&lt;/code&gt;通过该方法提交到&lt;code&gt;Reactor&lt;/code&gt;中执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们将重点放在&lt;code&gt;execute方法&lt;/code&gt;后半段&lt;code&gt;wakeup&lt;/code&gt;逻辑部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先介绍下和&lt;code&gt;wakeup&lt;/code&gt;逻辑相关的两个参数&lt;code&gt;boolean immediate&lt;/code&gt;和&lt;code&gt;boolean addTaskWakesUp&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;immediate：&lt;/code&gt;表示提交的&lt;code&gt;task&lt;/code&gt;是否需要被立即执行。Netty中只要你提交的任务类型不是&lt;code&gt;LazyRunnable&lt;/code&gt;类型的任务，都是需要立即执行的。&lt;code&gt;immediate = true&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;addTaskWakesUp :&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 表示&lt;code&gt;当且仅当只有&lt;/code&gt;调用&lt;code&gt;addTask&lt;/code&gt;方法时才会唤醒&lt;code&gt;Reactor线程&lt;/code&gt;。调用别的方法并不会唤醒&lt;code&gt;Reactor线程&lt;/code&gt;。在初始化&lt;code&gt;NioEventLoop&lt;/code&gt;时会设置为&lt;code&gt;false&lt;/code&gt;，表示&lt;code&gt;并不是只有&lt;/code&gt;addTask方法才能唤醒&lt;code&gt;Reactor线程&lt;/code&gt; 还有其他方法可以唤醒&lt;code&gt;Reactor线程&lt;/code&gt;，比如这里的&lt;code&gt;execute方法&lt;/code&gt;就会唤醒&lt;code&gt;Reactor线程&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对execute方法中的这个唤醒条件&lt;code&gt;!addTaskWakesUp &amp;amp;&amp;amp; immediate&lt;/code&gt;，&lt;strong&gt;netty这里要表达的语义是&lt;/strong&gt;：当immediate参数为true的时候表示该异步任务需要立即执行，addTaskWakesUp 默认设置为false 表示不仅只有addTask方法可以唤醒Reactor，还有其他方法比如这里的execute方法也可以唤醒。但是当设置为true时，语义就变为只有addTask才可以唤醒Reactor，即使execute方法里的immediate = true也不能唤醒Reactor，因为执行的是execute方法而不是addTask方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; AWAKE = -&lt;span&gt;1L&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicLong nextWakeupNanos = &lt;span&gt;new&lt;/span&gt; AtomicLong(AWAKE);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;wakeup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;boolean&lt;/span&gt; inEventLoop)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!inEventLoop &amp;amp;&amp;amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) {&lt;br/&gt;            &lt;span&gt;//将Reactor线程从Selector上唤醒&lt;/span&gt;&lt;br/&gt;            selector.wakeup();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;nextWakeupNanos = AWAKE&lt;/code&gt;时表示当前Reactor正处于苏醒状态，既然是苏醒状态也就没有必要去执行&lt;code&gt;selector.wakeup()&lt;/code&gt;重复唤醒Reactor了，同时也能省去这一次的系统调用开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在《1.2小节 轮询逻辑》开始介绍的源码实现框架里Reactor被唤醒之后执行代码会进入&lt;code&gt;finally{...}&lt;/code&gt;语句块中，在那里会将&lt;code&gt;nextWakeupNanos&lt;/code&gt;设置为&lt;code&gt;AWAKE&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            &lt;span&gt;if&lt;/span&gt; (!hasTasks()) {&lt;br/&gt;                                strategy = select(curDeadlineNanos);&lt;br/&gt;                            }&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            &lt;span&gt;// 执行到这里说明Reactor已经从Selector上被唤醒了&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;// 设置Reactor的状态为苏醒状态AWAKE&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;// lazySet优化不必要的volatile操作，不使用内存屏障，不保证写操作的可见性（单线程不需要保证）&lt;/span&gt;&lt;br/&gt;                            nextWakeupNanos.lazySet(AWAKE);&lt;br/&gt;                        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里Netty用了一个&lt;code&gt;AtomicLong类型&lt;/code&gt;的变量&lt;code&gt;nextWakeupNanos&lt;/code&gt;，既能表示当前&lt;code&gt;Reactor线程&lt;/code&gt;的状态，又能表示&lt;code&gt;Reactor线程&lt;/code&gt;的阻塞超时时间。我们在日常开发中也可以学习下这种技巧。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续回到&lt;code&gt;Reactor线程&lt;/code&gt;轮询&lt;code&gt;IO就绪事件&lt;/code&gt;的主线上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deadlineNanos)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (deadlineNanos == NONE) {&lt;br/&gt;            &lt;span&gt;//无定时任务，无普通任务执行时，开始轮询IO就绪事件，没有就一直阻塞 直到唤醒条件成立&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; selector.select();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeoutMillis = deadlineToDelayNanos(deadlineNanos + &lt;span&gt;995000L&lt;/span&gt;) / &lt;span&gt;1000000L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; timeoutMillis &amp;lt;= &lt;span&gt;0&lt;/span&gt; ? selector.selectNow() : selector.select(timeoutMillis);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;deadlineNanos&lt;/code&gt;不为&lt;code&gt;NONE&lt;/code&gt;，表示此时&lt;code&gt;Reactor&lt;/code&gt;有&lt;code&gt;定时任务&lt;/code&gt;需要执行，&lt;code&gt;Reactor线程&lt;/code&gt;需要阻塞在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO就绪事件&lt;/code&gt;直到最近的一个定时任务执行时间点&lt;code&gt;deadline&lt;/code&gt;到达。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;deadlineNanos&lt;/code&gt;表示的就是&lt;code&gt;Reactor&lt;/code&gt;中最近的一个定时任务执行时间点&lt;code&gt;deadline&lt;/code&gt;，单位是&lt;code&gt;纳秒&lt;/code&gt;。指的是一个&lt;code&gt;绝对时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们需要计算的是&lt;code&gt;Reactor线程&lt;/code&gt;阻塞在&lt;code&gt;Selector&lt;/code&gt;的超时时间&lt;code&gt;timeoutMillis&lt;/code&gt;，单位是&lt;code&gt;毫秒&lt;/code&gt;，指的是一个&lt;code&gt;相对时间&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFQKicHibKHQnbntmpLxEMVrVhgejqLickoDxYHomJiaH2Amrn9wo9Fv3Bzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;deadline.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在&lt;code&gt;Reactor线程&lt;/code&gt;开始阻塞在&lt;code&gt;Selector&lt;/code&gt;上之前，我们需要将这个单位为&lt;code&gt;纳秒&lt;/code&gt;的绝对时间&lt;code&gt;deadlineNanos&lt;/code&gt;转化为单位为&lt;code&gt;毫秒&lt;/code&gt;的相对时间&lt;code&gt;timeoutMillis&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deadlineNanos)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (deadlineNanos == NONE) {&lt;br/&gt;            &lt;span&gt;//无定时任务，无普通任务执行时，开始轮询IO就绪事件，没有就一直阻塞 直到唤醒条件成立&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; selector.select();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; timeoutMillis = deadlineToDelayNanos(deadlineNanos + &lt;span&gt;995000L&lt;/span&gt;) / &lt;span&gt;1000000L&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; timeoutMillis &amp;lt;= &lt;span&gt;0&lt;/span&gt; ? selector.selectNow() : selector.select(timeoutMillis);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里大家可能会好奇，通过&lt;code&gt;deadlineToDelayNanos方法&lt;/code&gt;计算&lt;code&gt;timeoutMillis&lt;/code&gt;的时候，为什么要给&lt;code&gt;deadlineNanos&lt;/code&gt;在加上&lt;code&gt;0.995毫秒&lt;/code&gt;呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家想象一下这样的场景，当最近的一个定时任务的&lt;code&gt;deadline&lt;/code&gt;即将在&lt;code&gt;5微秒&lt;/code&gt;内到达，那么这时将纳秒转换成毫秒计算出的&lt;code&gt;timeoutMillis&lt;/code&gt;会是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Netty中&lt;code&gt;timeoutMillis = 0&lt;/code&gt;要表达的语义是：定时任务执行时间已经到达&lt;code&gt;deadline&lt;/code&gt;时间点，需要被执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而现实情况是定时任务还有&lt;code&gt;5微秒&lt;/code&gt;才能够到达&lt;code&gt;deadline&lt;/code&gt;，所以对于这种情况，需要在&lt;code&gt;deadlineNanos&lt;/code&gt;在加上&lt;code&gt;0.995毫秒&lt;/code&gt;凑成&lt;code&gt;1毫秒&lt;/code&gt;不能让其为0。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以从这里我们可以看出，&lt;code&gt;Reactor&lt;/code&gt;在有定时任务的情况下，&lt;code&gt;至少要阻塞1毫秒&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractScheduledEventExecutor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractEventExecutor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;deadlineToDelayNanos&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deadlineNanos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ScheduledFutureTask.deadlineToDelayNanos(deadlineNanos);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ScheduledFutureTask&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PromiseTask&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ScheduledFuture&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt;, &lt;span&gt;PriorityQueueNode&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;deadlineToDelayNanos&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deadlineNanos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; deadlineNanos == &lt;span&gt;0L&lt;/span&gt; ? &lt;span&gt;0L&lt;/span&gt; : Math.max(&lt;span&gt;0L&lt;/span&gt;, deadlineNanos - nanoTime());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//启动时间点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; START_TIME = System.nanoTime();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.nanoTime() - START_TIME;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;deadlineNanos&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; delay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//计算定时任务执行deadline  去除启动时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; deadlineNanos = nanoTime() + delay;&lt;br/&gt;        &lt;span&gt;// Guard against overflow&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; deadlineNanos &amp;lt; &lt;span&gt;0&lt;/span&gt; ? Long.MAX_VALUE : deadlineNanos;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意一下，在创建定时任务时会通过&lt;code&gt;deadlineNanos方法&lt;/code&gt;计算定时任务的执行&lt;code&gt;deadline&lt;/code&gt;，&lt;code&gt;deadline&lt;/code&gt;的计算逻辑是&lt;code&gt;当前时间点&lt;/code&gt;+&lt;code&gt;任务延时delay&lt;/code&gt;-&lt;code&gt;系统启动时间&lt;/code&gt;。&lt;strong&gt;这里需要扣除系统启动的时间&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里在通过&lt;code&gt;deadline&lt;/code&gt;计算延时&lt;code&gt;delay&lt;/code&gt;（也就是timeout）的时候需要在加上&lt;code&gt;系统启动的时间&lt;/code&gt; : &lt;code&gt;deadlineNanos - nanoTime()&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当通过&lt;code&gt;deadlineToDelayNanos&lt;/code&gt;计算出的&lt;code&gt;timeoutMillis &amp;lt;= 0&lt;/code&gt;时，表示&lt;code&gt;Reactor&lt;/code&gt;目前有临近的&lt;code&gt;定时任务&lt;/code&gt;需要执行，这时候就需要立马返回，不能阻塞在&lt;code&gt;Selector&lt;/code&gt;上影响&lt;code&gt;定时任务&lt;/code&gt;的执行。当然在返回执行&lt;code&gt;定时任务&lt;/code&gt;前，需要在顺手通过&lt;code&gt;selector.selectNow()&lt;/code&gt;非阻塞轮询一下&lt;code&gt;Channel&lt;/code&gt;上是否有&lt;code&gt;IO就绪事件&lt;/code&gt;到达，防止耽误&lt;code&gt;IO事件&lt;/code&gt;的处理。真是操碎了心~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;timeoutMillis &amp;gt; 0&lt;/code&gt;时，&lt;code&gt;Reactor线程&lt;/code&gt;就可以安心的阻塞在&lt;code&gt;Selector&lt;/code&gt;上等待&lt;code&gt;IO事件&lt;/code&gt;的到来，直到&lt;code&gt;timeoutMillis&lt;/code&gt;超时时间到达。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;timeoutMillis &amp;lt;= &lt;span&gt;0&lt;/span&gt; ? selector.selectNow() : selector.select(timeoutMillis)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当注册在&lt;code&gt;Reactor&lt;/code&gt;上的&lt;code&gt;Channel&lt;/code&gt;中有&lt;code&gt;IO事件&lt;/code&gt;到来时，&lt;code&gt;Reactor线程&lt;/code&gt;就会从&lt;code&gt;selector.select(timeoutMillis)&lt;/code&gt;调用中唤醒，立即去处理&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里假设一种极端情况，如果最近的一个定时任务的deadline是在未来很远的一个时间点，这样就会使timeoutMillis的时间非常非常久，那么Reactor岂不是会一直阻塞在Selector上造成 Netty 无法工作？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者觉得大家现在心里应该已经有了答案，我们在《1.2.2 Reactor开始轮询IO就绪事件》小节一开始介绍过，当Reactor正在Selector上阻塞时，如果此时用户线程向Reactor提交了异步任务，Reactor线程会通过execute方法被唤醒。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程到这里，Reactor中最重要也是最核心的逻辑：轮询&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;的处理流程我们就讲解完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Reactor轮询到有IO活跃事件或者有异步任务需要执行时，就会从Selector上被唤醒，下面就到了该介绍Reactor被唤醒之后是如何处理&lt;code&gt;IO就绪事件&lt;/code&gt;以及如何执行&lt;code&gt;异步任务&lt;/code&gt;的时候了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty毕竟是一个网络框架，所以它会优先去处理&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO事件&lt;/code&gt;，基于这个事实，所以Netty不会容忍&lt;code&gt;异步任务&lt;/code&gt;被无限制的执行从而影响&lt;code&gt;IO吞吐&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty通过&lt;code&gt;ioRatio变量&lt;/code&gt;来调配&lt;code&gt;Reactor线程&lt;/code&gt;在处理&lt;code&gt;IO事件&lt;/code&gt;和执行&lt;code&gt;异步任务&lt;/code&gt;之间的&lt;code&gt;CPU时间&lt;/code&gt;分配比例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看下这个执行时间比例的分配逻辑是什么样的~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. Reactor处理IO与处理异步任务的时间比例分配&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论什么时候，当有&lt;code&gt;IO就绪事件&lt;/code&gt;到来时，&lt;code&gt;Reactor&lt;/code&gt;都需要保证&lt;code&gt;IO事件&lt;/code&gt;被及时完整的处理完，而&lt;code&gt;ioRatio&lt;/code&gt;主要限制的是执行&lt;code&gt;异步任务&lt;/code&gt;所需用时，防止&lt;code&gt;Reactor线程&lt;/code&gt;处理&lt;code&gt;异步任务&lt;/code&gt;时间过长而导致&lt;code&gt;I/O 事件&lt;/code&gt;得不到及时地处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7879032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYF89hoiboMviaWTmOCOfqpKCQt54pgyPDGL4yGucynSa0dHdjxn8KRy82g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor分配任务执行时间.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                &lt;span&gt;//调整Reactor线程执行IO事件和执行异步任务的CPU时间比例 默认50，表示执行IO事件和异步任务的时间比例是一比一&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ioRatio = &lt;span&gt;this&lt;/span&gt;.ioRatio;&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; ranTasks;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (ioRatio == &lt;span&gt;100&lt;/span&gt;) { &lt;span&gt;//先一股脑执行IO事件，在一股脑执行异步任务（无时间限制）&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (strategy &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;//如果有IO就绪事件 则处理IO就绪事件&lt;/span&gt;&lt;br/&gt;                            processSelectedKeys();&lt;br/&gt;                        }&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;// Ensure we always run tasks.&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;//处理所有异步任务&lt;/span&gt;&lt;br/&gt;                        ranTasks = runAllTasks();&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (strategy &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//先执行IO事件 用时ioTime  执行异步任务只能用时ioTime * (100 - ioRatio) / ioRatio&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ioStartTime = System.nanoTime();&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        processSelectedKeys();&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;// Ensure we always run tasks.&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ioTime = System.nanoTime() - ioStartTime;&lt;br/&gt;                        &lt;span&gt;// 限定在超时时间内 处理有限的异步任务 防止Reactor线程处理异步任务时间过长而导致 I/O 事件阻塞&lt;/span&gt;&lt;br/&gt;                        ranTasks = runAllTasks(ioTime * (&lt;span&gt;100&lt;/span&gt; - ioRatio) / ioRatio);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//没有IO就绪事件处理，则只执行异步任务 最多执行64个 防止Reactor线程处理异步任务时间过长而导致 I/O 事件阻塞&lt;/span&gt;&lt;br/&gt;                    ranTasks = runAllTasks(&lt;span&gt;0&lt;/span&gt;); &lt;span&gt;// This will run the minimum number of tasks&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;ioRatio = 100&lt;/code&gt;时，表示无需考虑执行时间的限制，当有&lt;code&gt;IO就绪事件&lt;/code&gt;时（&lt;code&gt;strategy &amp;gt; 0&lt;/code&gt;）&lt;code&gt;Reactor线程&lt;/code&gt;需要优先处理&lt;code&gt;IO就绪事件&lt;/code&gt;，处理完&lt;code&gt;IO事件&lt;/code&gt;后，执行所有的&lt;code&gt;异步任务&lt;/code&gt;包括：普通任务，尾部任务，定时任务。无时间限制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;strategy&lt;/code&gt;的数值表示&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;个数。它是前边介绍的&lt;code&gt;io.netty.channel.nio.NioEventLoop#select&lt;/code&gt;方法的返回值。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当&lt;code&gt;ioRatio&lt;/code&gt;设置的值不为&lt;code&gt;100&lt;/code&gt;时，默认为&lt;code&gt;50&lt;/code&gt;。需要先统计出执行&lt;code&gt;IO事件&lt;/code&gt;的用时&lt;code&gt;ioTime&lt;/code&gt;，根据&lt;code&gt;ioTime * (100 - ioRatio) / ioRatio&lt;/code&gt;计算出，后面执行&lt;code&gt;异步任务&lt;/code&gt;的限制时间。也就是说&lt;code&gt;Reactor线程&lt;/code&gt;需要在这个限定的时间内，执行有限的异步任务，防止&lt;code&gt;Reactor线程&lt;/code&gt;由于处理&lt;code&gt;异步任务&lt;/code&gt;时间过长而导致&lt;code&gt;I/O 事件&lt;/code&gt;得不到及时地处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下，执行&lt;code&gt;IO事件&lt;/code&gt;用时和执行&lt;code&gt;异步任务&lt;/code&gt;用时比例设置的是一比一。&lt;code&gt;ioRatio&lt;/code&gt;设置的越高，则&lt;code&gt;Reactor线程&lt;/code&gt;执行异步任务的时间占比&lt;code&gt;越小&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要想得到&lt;code&gt;Reactor线程&lt;/code&gt;执行&lt;code&gt;异步任务&lt;/code&gt;所需的时间限制，必须知道执行&lt;code&gt;IO事件&lt;/code&gt;的用时&lt;code&gt;ioTime&lt;/code&gt;然后在根据&lt;code&gt;ioRatio&lt;/code&gt;计算出执行&lt;code&gt;异步任务&lt;/code&gt;的时间限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那如果此时并没有&lt;code&gt;IO就绪事件&lt;/code&gt;需要&lt;code&gt;Reactor线程&lt;/code&gt;处理的话，这种情况下我们无法得到&lt;code&gt;ioTime&lt;/code&gt;，那怎么得到执行&lt;code&gt;异步任务&lt;/code&gt;的限制时间呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种特殊情况下，Netty只允许&lt;code&gt;Reactor线程&lt;/code&gt;最多执行&lt;code&gt;64&lt;/code&gt;个异步任务，然后就结束执行。转去继续轮训&lt;code&gt;IO就绪事件&lt;/code&gt;。核心目的还是防止&lt;code&gt;Reactor线程&lt;/code&gt;由于处理&lt;code&gt;异步任务&lt;/code&gt;时间过长而导致&lt;code&gt;I/O 事件&lt;/code&gt;得不到及时地处理。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下，当&lt;code&gt;Reactor&lt;/code&gt;有&lt;code&gt;异步任务&lt;/code&gt;需要处理但是没有&lt;code&gt;IO就绪事件&lt;/code&gt;时，Netty只会允许&lt;code&gt;Reactor线程&lt;/code&gt;执行最多&lt;code&gt;64&lt;/code&gt;个异步任务。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们对&lt;code&gt;Reactor&lt;/code&gt;处理&lt;code&gt;IO事件&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;的整体框架已经了解了，下面我们就来分别介绍下&lt;code&gt;Reactor线程&lt;/code&gt;在处理&lt;code&gt;IO事件&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;的具体逻辑是什么样的？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Reactor线程处理IO就绪事件&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;//该字段为持有selector对象selectedKeys的引用，当IO事件就绪时，直接从这里获取&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; SelectedSelectionKeySet selectedKeys;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKeys&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//是否采用netty优化后的selectedKey集合类型 是由变量DISABLE_KEY_SET_OPTIMIZATION决定的 默认为false&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (selectedKeys != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            processSelectedKeysOptimized();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            processSelectedKeysPlain(selector.selectedKeys());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这段代码大家眼熟吗？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2244897959183674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFc0ReOAm5mPCWVIdgCUzTQTFjkwGsUBn75Lu4qxicLwRibsn7kgIEDe6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;147&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知大家还记不记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中介绍Reactor &lt;code&gt;NioEventLoop类&lt;/code&gt;在创建&lt;code&gt;Selector&lt;/code&gt;的过程中提到，出于对&lt;code&gt;JDK NIO Selector&lt;/code&gt;中&lt;code&gt;selectedKeys 集合&lt;/code&gt;的&lt;code&gt;插入&lt;/code&gt;和&lt;code&gt;遍历&lt;/code&gt;操作性能的考虑Netty将自己用数组实现的&lt;code&gt;SelectedSelectionKeySet 集合&lt;/code&gt;替换掉了&lt;code&gt;JDK NIO Selector&lt;/code&gt;中&lt;code&gt;selectedKeys&lt;/code&gt;的&lt;code&gt;HashSet&lt;/code&gt;实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SelectorImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// The set of keys with data ready for an operation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// //IO就绪的SelectionKey（里面包裹着channel）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Set&amp;lt;SelectionKey&amp;gt; selectedKeys;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// The set of keys registered with this Selector&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//注册在该Selector上的所有SelectionKey（里面包裹着channel）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; HashSet&amp;lt;SelectionKey&amp;gt; keys;&lt;br/&gt;&lt;br/&gt;    ...............省略...................&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty中通过优化开关&lt;code&gt;DISABLE_KEY_SET_OPTIMIZATION&lt;/code&gt;控制是否对&lt;code&gt;JDK NIO Selector&lt;/code&gt;进行优化。默认是需要优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在优化开关开启的情况下，Netty会将创建的&lt;code&gt;SelectedSelectionKeySet 集合&lt;/code&gt;保存在&lt;code&gt;NioEventLoop&lt;/code&gt;的&lt;code&gt;private SelectedSelectionKeySet selectedKeys&lt;/code&gt;字段中，方便&lt;code&gt;Reactor线程&lt;/code&gt;直接从这里获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKey&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在优化开关关闭的情况下，Netty会直接采用&lt;code&gt;JDK NIO Selector&lt;/code&gt;的默认实现。此时&lt;code&gt;NioEventLoop&lt;/code&gt;的&lt;code&gt;selectedKeys&lt;/code&gt;字段就会为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;忘记这段的同学可以在回顾下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中关于&lt;code&gt;Reactor&lt;/code&gt;的创建过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过对前边内容的回顾，我们看到了在&lt;code&gt;Reactor&lt;/code&gt;处理&lt;code&gt;IO就绪事件&lt;/code&gt;的逻辑也分为两个部分，一个是经过Netty优化的，一个是采用&lt;code&gt;JDK 原生&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看采用&lt;code&gt;JDK 原生&lt;/code&gt;的&lt;code&gt;Selector&lt;/code&gt;的处理方式，理解了这种方式，在看Netty优化的方式会更加容易。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 processSelectedKeysPlain&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中介绍&lt;code&gt;JDK NIO Selector&lt;/code&gt;的工作过程时讲过，当注册在&lt;code&gt;Selector&lt;/code&gt;上的&lt;code&gt;Channel&lt;/code&gt;发生&lt;code&gt;IO就绪事件&lt;/code&gt;时，&lt;code&gt;Selector&lt;/code&gt;会将&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKey&lt;/code&gt;插入到&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys&lt;/code&gt;集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时&lt;code&gt;Reactor线程&lt;/code&gt;会从&lt;code&gt;java.nio.channels.Selector#select(long)&lt;/code&gt;调用中返回。随后调用&lt;code&gt;java.nio.channels.Selector#selectedKeys&lt;/code&gt;获取&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKey&lt;/code&gt;集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以&lt;code&gt;Reactor线程&lt;/code&gt;在调用&lt;code&gt;processSelectedKeysPlain方法&lt;/code&gt;处理&lt;code&gt;IO就绪事件&lt;/code&gt;之前需要调用&lt;code&gt;selector.selectedKeys()&lt;/code&gt;去获取所有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKeys&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;processSelectedKeysPlain(selector.selectedKeys())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKeysPlain&lt;/span&gt;&lt;span&gt;(Set&amp;lt;SelectionKey&amp;gt; selectedKeys)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (selectedKeys.isEmpty()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        Iterator&amp;lt;SelectionKey&amp;gt; i = selectedKeys.iterator();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; SelectionKey k = i.next();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Object a = k.attachment();&lt;br/&gt;            &lt;span&gt;//注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。&lt;/span&gt;&lt;br/&gt;            i.remove();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; AbstractNioChannel) {&lt;br/&gt;                processSelectedKey(k, (AbstractNioChannel) a);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                NioTask&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;) a;&lt;br/&gt;                processSelectedKey(k, task);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!i.hasNext()) {&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//目的是再次进入for循环 移除失效的selectKey(socketChannel可能从selector上移除)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (needsToSelectAgain) {&lt;br/&gt;                selectAgain();&lt;br/&gt;                selectedKeys = selector.selectedKeys();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// Create the iterator again to avoid ConcurrentModificationException&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (selectedKeys.isEmpty()) {&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    i = selectedKeys.iterator();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.1 获取IO就绪的Channel&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys&lt;/code&gt;集合里面装的全部是&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKey&lt;/code&gt;，注意，此时&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys&lt;/code&gt;的实现类型为&lt;code&gt;HashSet类型&lt;/code&gt;。因为我们这里首先介绍的是JDK NIO 原生实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过获取&lt;code&gt;HashSet&lt;/code&gt;的迭代器，开始逐个处理&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Iterator&amp;lt;SelectionKey&amp;gt; i = selectedKeys.iterator();&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; SelectionKey k = i.next();&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; Object a = k.attachment();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家还记得这个&lt;code&gt;SelectionKey&lt;/code&gt;中的&lt;code&gt;attachment属性&lt;/code&gt;里存放的是什么吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;token=773025719&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中我们在讲&lt;code&gt;NioServerSocketChannel&lt;/code&gt;向&lt;code&gt;Main Reactor&lt;/code&gt;注册的时候，通过this指针将自己作为&lt;code&gt;SelectionKey&lt;/code&gt;的&lt;code&gt;attachment属性&lt;/code&gt;注册到&lt;code&gt;Selector&lt;/code&gt;中。&lt;strong&gt;这一步完成了Netty自定义&lt;code&gt;Channel&lt;/code&gt;和&lt;code&gt;JDK NIO Channel&lt;/code&gt;的绑定&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42258064516129035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYF1kPicnyrV1febibdBk3TvKxZiavcfsOib6jBVvME5cEl2sVkEEENeFORdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;channel与SelectionKey对应关系.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//channel注册到Selector后获得的SelectKey&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; SelectionKey selectionKey;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRegister&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; selected = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException e) {&lt;br/&gt;                ...............省略....................&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们也提到&lt;code&gt;SelectionKey&lt;/code&gt;就相当于是&lt;code&gt;Channel&lt;/code&gt;在&lt;code&gt;Selector&lt;/code&gt;中的一种表示，当&lt;code&gt;Channel&lt;/code&gt;上有&lt;code&gt;IO就绪事件&lt;/code&gt;时，&lt;code&gt;Selector&lt;/code&gt;会将&lt;code&gt;Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;返回给&lt;code&gt;Reactor线程&lt;/code&gt;，我们可以通过返回的这个&lt;code&gt;SelectionKey&lt;/code&gt;里的&lt;code&gt;attachment属性&lt;/code&gt;获取到对应的Netty自定义&lt;code&gt;Channel&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于客户端连接事件（&lt;code&gt;OP_ACCEPT&lt;/code&gt;）活跃时，这里的&lt;code&gt;Channel类型&lt;/code&gt;为&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。对于客户端读写事件（&lt;code&gt;Read&lt;/code&gt;，&lt;code&gt;Write&lt;/code&gt;）活跃时，这里的&lt;code&gt;Channel类型&lt;/code&gt;为&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们通过&lt;code&gt;k.attachment()&lt;/code&gt;获取到Netty自定义的&lt;code&gt;Channel&lt;/code&gt;时，就需要把这个&lt;code&gt;Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;从&lt;code&gt;Selector&lt;/code&gt;的就绪集合&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys&lt;/code&gt;中删除。&lt;strong&gt;因为Selector自己不会主动删除已经处理完的SelectionKey&lt;/strong&gt;，需要调用者自己主动删除，这样当这个&lt;code&gt;Channel&lt;/code&gt;再次&lt;code&gt;IO就绪时&lt;/code&gt;，&lt;code&gt;Selector&lt;/code&gt;会再次将这个&lt;code&gt;Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;放入就绪集合&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys&lt;/code&gt;中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;i.remove();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2 处理Channel上的IO事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;     &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; AbstractNioChannel) {&lt;br/&gt;                processSelectedKey(k, (AbstractNioChannel) a);&lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                NioTask&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;) a;&lt;br/&gt;                processSelectedKey(k, task);&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这里我们可以看出Netty向&lt;code&gt;SelectionKey&lt;/code&gt;中的&lt;code&gt;attachment属性&lt;/code&gt;附加的对象分为两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一种是我们熟悉的&lt;code&gt;Channel&lt;/code&gt;，无论是服务端使用的&lt;code&gt;NioServerSocketChannel&lt;/code&gt;还是客户端使用的&lt;code&gt;NioSocketChannel&lt;/code&gt;都属于&lt;code&gt;AbstractNioChannel&lt;/code&gt;。&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO事件&lt;/code&gt;是由Netty框架负责处理，也是本小节我们要重点介绍的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一种就是&lt;code&gt;NioTask&lt;/code&gt;，这种类型是Netty提供给用户可以自定义一些当&lt;code&gt;Channel&lt;/code&gt;上发生&lt;code&gt;IO就绪事件&lt;/code&gt;时的自定义处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;NioTask&lt;/span&gt;&amp;lt;&lt;span&gt;C&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SelectableChannel&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Invoked when the {&lt;span&gt;@link&lt;/span&gt; SelectableChannel} has been selected by the {&lt;span&gt;@link&lt;/span&gt; Selector}.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelReady&lt;/span&gt;&lt;span&gt;(C ch, SelectionKey key)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Invoked when the {&lt;span&gt;@link&lt;/span&gt; SelectionKey} of the specified {&lt;span&gt;@link&lt;/span&gt; SelectableChannel} has been cancelled and thus&lt;br/&gt;     * this {&lt;span&gt;@link&lt;/span&gt; NioTask} will not be notified anymore.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; cause the cause of the unregistration. {&lt;span&gt;@code&lt;/span&gt; null} if a user called {&lt;span&gt;@link&lt;/span&gt; SelectionKey#cancel()} or&lt;br/&gt;     *              the event loop has been shut down.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelUnregistered&lt;/span&gt;&lt;span&gt;(C ch, Throwable cause)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;NioTask&lt;/code&gt;和&lt;code&gt;Channel&lt;/code&gt;其实本质上是一样的都是负责处理&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO就绪事件&lt;/code&gt;，只不过一个是&lt;code&gt;用户自定义处理&lt;/code&gt;，一个是Netty框架处理。这里我们重点关注&lt;code&gt;Channel&lt;/code&gt;的&lt;code&gt;IO处理逻辑&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取Channel的底层操作类Unsafe&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!k.isValid()) {&lt;br/&gt;            ......如果SelectionKey已经失效则关闭对应的Channel......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//获取IO就绪事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;            &lt;span&gt;//处理Connect事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ops = k.interestOps();&lt;br/&gt;                &lt;span&gt;//移除对Connect事件的监听，否则Selector会一直通知&lt;/span&gt;&lt;br/&gt;                ops &amp;amp;= ~SelectionKey.OP_CONNECT;&lt;br/&gt;                k.interestOps(ops);&lt;br/&gt;                &lt;span&gt;//触发channelActive事件处理Connect事件&lt;/span&gt;&lt;br/&gt;                unsafe.finishConnect();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//处理Write事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                ch.unsafe().forceFlush();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;             &lt;span&gt;//处理Read事件或者Accept事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先我们需要获取&lt;code&gt;IO就绪Channel&lt;/code&gt;底层的操作类&lt;code&gt;Unsafe&lt;/code&gt;，用于对具体&lt;code&gt;IO就绪事件&lt;/code&gt;的处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看出，Netty对&lt;code&gt;IO就绪事件&lt;/code&gt;的处理全部封装在&lt;code&gt;Unsafe类&lt;/code&gt;中。比如：对&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的具体处理逻辑是封装在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;中的&lt;code&gt;UnSafe类&lt;/code&gt;中。对&lt;code&gt;OP_READ或者OP_WRITE事件&lt;/code&gt;的处理是封装在&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;Unsafe类&lt;/code&gt;中。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从&lt;code&gt;Selectionkey&lt;/code&gt;中获取具体&lt;code&gt;IO就绪事件 readyOps&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SelectonKey&lt;/code&gt;中关于&lt;code&gt;IO事件&lt;/code&gt;的集合有两个。一个是&lt;code&gt;interestOps&lt;/code&gt;,用于记录&lt;code&gt;Channel&lt;/code&gt;感兴趣的&lt;code&gt;IO事件&lt;/code&gt;，在&lt;code&gt;Channel&lt;/code&gt;向&lt;code&gt;Selector&lt;/code&gt;注册完毕后，通过&lt;code&gt;pipeline&lt;/code&gt;中的&lt;code&gt;HeadContext&lt;/code&gt;节点的&lt;code&gt;ChannelActive事件回调&lt;/code&gt;中添加。下面这段代码就是在&lt;code&gt;ChannelActive事件回调&lt;/code&gt;中Channel在向Selector注册自己感兴趣的IO事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;             &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBeginRead&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;// Channel.read() or ChannelHandlerContext.read() was called&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;final&lt;/span&gt; SelectionKey selectionKey = &lt;span&gt;this&lt;/span&gt;.selectionKey;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (!selectionKey.isValid()) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    readPending = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps = selectionKey.interestOps();&lt;br/&gt;                    &lt;span&gt;/**&lt;br/&gt;                       * 1：ServerSocketChannel 初始化时 readInterestOp设置的是OP_ACCEPT事件&lt;br/&gt;                       * 2：SocketChannel 初始化时 readInterestOp设置的是OP_READ事件&lt;br/&gt;                     * */&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; readInterestOp) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;//注册监听OP_ACCEPT或者OP_READ事件&lt;/span&gt;&lt;br/&gt;                        selectionKey.interestOps(interestOps | readInterestOp);&lt;br/&gt;                    }&lt;br/&gt;              }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个就是这里的&lt;code&gt;readyOps&lt;/code&gt;，用于记录在&lt;code&gt;Channel&lt;/code&gt;感兴趣的&lt;code&gt;IO事件&lt;/code&gt;中具体哪些&lt;code&gt;IO事件&lt;/code&gt;就绪了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty中将各种事件的集合用一个&lt;code&gt;int型&lt;/code&gt;变量来保存。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用&lt;code&gt;&amp;amp;&lt;/code&gt;操作判断，某个事件是否在事件集合中：&lt;code&gt;(readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0&lt;/code&gt;，这里就是判断Channel是否对Connect事件感兴趣。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用&lt;code&gt;|&lt;/code&gt;操作向事件集合中添加事件：&lt;code&gt;interestOps | readInterestOp&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从事件集合中删除某个事件，是通过先将要删除事件取反&lt;code&gt;~&lt;/code&gt;，然后在和事件集合做&lt;code&gt;&amp;amp;&lt;/code&gt;操作：&lt;code&gt;ops &amp;amp;= ~SelectionKey.OP_CONNECT&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty这种对空间的极致利用思想，很值得我们平时在日常开发中学习~~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经知道哪些&lt;code&gt;Channel&lt;/code&gt;现在处于&lt;code&gt;IO就绪状态&lt;/code&gt;，并且知道了具体哪些类型的&lt;code&gt;IO事件&lt;/code&gt;已经就绪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就该针对&lt;code&gt;Channel&lt;/code&gt;上的不同&lt;code&gt;IO就绪事件&lt;/code&gt;做出相应的处理了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2.1 处理Connect事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty客户端向服务端发起连接，并向客户端的&lt;code&gt;Reactor&lt;/code&gt;注册&lt;code&gt;Connect事件&lt;/code&gt;，当连接建立成功后，客户端的&lt;code&gt;NioSocketChannel&lt;/code&gt;就会产生&lt;code&gt;Connect就绪事件&lt;/code&gt;，通过前面内容我们讲的&lt;code&gt;Reactor的运行框架&lt;/code&gt;，最终流程会走到这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ops = k.interestOps();&lt;br/&gt;                ops &amp;amp;= ~SelectionKey.OP_CONNECT;&lt;br/&gt;                k.interestOps(ops);&lt;br/&gt;                &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                unsafe.finishConnect();&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;IO就绪&lt;/code&gt;的事件是&lt;code&gt;Connect事件&lt;/code&gt;，那么就调用对应客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;Unsafe操作类&lt;/code&gt;中的&lt;code&gt;finishConnect方法&lt;/code&gt;处理&lt;code&gt;Connect事件&lt;/code&gt;。这时会在Netty客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;中传播&lt;code&gt;ChannelActive事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后需要将&lt;code&gt;OP_CONNECT事件&lt;/code&gt;从客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;所关心的事件集合&lt;code&gt;interestOps&lt;/code&gt;中删除。否则&lt;code&gt;Selector&lt;/code&gt;会一直通知&lt;code&gt;Connect事件就绪&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2.2 处理Write事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于&lt;code&gt;Reactor线程&lt;/code&gt;处理Netty中的&lt;code&gt;Write事件&lt;/code&gt;的流程，笔者后续会专门用一篇文章来为大家介绍。本文我们重点关注&lt;code&gt;Reactor线程&lt;/code&gt;的整体运行框架。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            ch.unsafe().forceFlush();&lt;br/&gt;      }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大家只需要记住，OP_WRITE事件的注册是由用户来完成的，当Socket发送缓冲区已满无法继续写入数据时，用户会向Reactor注册OP_WRITE事件，等到Socket发送缓冲区变得可写时，Reactor会收到OP_WRITE事件活跃通知，随后在这里调用客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;forceFlush方法&lt;/code&gt;将剩余数据发送出去。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.2.3 处理Read事件或者Accept事件&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            unsafe.read();&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里可以看出Netty中处理&lt;code&gt;Read事件&lt;/code&gt;和&lt;code&gt;Accept事件&lt;/code&gt;都是由对应&lt;code&gt;Channel&lt;/code&gt;中的&lt;code&gt;Unsafe操作类&lt;/code&gt;中的&lt;code&gt;read方法&lt;/code&gt;处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;中的&lt;code&gt;Read方法&lt;/code&gt;处理的是&lt;code&gt;Accept事件&lt;/code&gt;，客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;Read方法&lt;/code&gt;处理的是&lt;code&gt;Read事件&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里大家只需记住各个&lt;code&gt;IO事件&lt;/code&gt;在对应&lt;code&gt;Channel&lt;/code&gt;中的处理入口，后续文章我们会详细分析这些入口函数。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1.3 从Selector中移除失效的SelectionKey&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;            &lt;span&gt;//用于及时从selectedKeys中清除失效的selectKey 比如 socketChannel从selector上被用户移除&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; needsToSelectAgain;&lt;br/&gt;&lt;br/&gt;             &lt;span&gt;//目的是再次进入for循环 移除失效的selectKey(socketChannel可能被用户从selector上移除)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (needsToSelectAgain) {&lt;br/&gt;                selectAgain();&lt;br/&gt;                selectedKeys = selector.selectedKeys();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;// Create the iterator again to avoid ConcurrentModificationException&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (selectedKeys.isEmpty()) {&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    i = selectedKeys.iterator();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边介绍&lt;code&gt;Reactor运行框架&lt;/code&gt;的时候，我们看到在每次&lt;code&gt;Reactor线程&lt;/code&gt;轮询结束，准备处理&lt;code&gt;IO就绪事件&lt;/code&gt;以及&lt;code&gt;异步任务&lt;/code&gt;的时候，都会将&lt;code&gt;needsToSelectAgain&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么这个&lt;code&gt;needsToSelectAgain&lt;/code&gt;究竟是干嘛的？以及为什么我们需要去&lt;code&gt;“Select Again”&lt;/code&gt;呢?&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看下在什么情况下会将&lt;code&gt;needsToSelectAgain&lt;/code&gt;这个变量设置为&lt;code&gt;true&lt;/code&gt;，通过这个设置的过程，我们是否能够从中找到一些线索？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道&lt;code&gt;Channel&lt;/code&gt;可以将自己注册到&lt;code&gt;Selector&lt;/code&gt;上，那么当然也可以将自己从&lt;code&gt;Selector&lt;/code&gt;上取消移除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上篇文章中我们也花了大量的篇幅讲解了这个注册的过程，现在我们来看下&lt;code&gt;Channel&lt;/code&gt;的取消注册。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//channel注册到Selector后获得的SelectKey&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; SelectionKey selectionKey;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doDeregister&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        eventLoop().cancel(selectionKey());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; SelectionKey &lt;span&gt;selectionKey&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;assert&lt;/span&gt; selectionKey != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; selectionKey;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Channel&lt;/code&gt;取消注册的过程很简单，直接调用&lt;code&gt;NioChannel&lt;/code&gt;的&lt;code&gt;doDeregister&lt;/code&gt;方法，&lt;code&gt;Channel&lt;/code&gt;绑定的&lt;code&gt;Reactor&lt;/code&gt;会将其从&lt;code&gt;Selector&lt;/code&gt;中取消并停止监听&lt;code&gt;Channel&lt;/code&gt;上的&lt;code&gt;IO事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//记录Selector上移除socketChannel的个数 达到256个 则需要将无效的selectKey从SelectedKeys集合中清除掉&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; cancelledKeys;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CLEANUP_INTERVAL = &lt;span&gt;256&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将socketChannel从selector中移除 取消监听IO事件&lt;br/&gt;     * */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;(SelectionKey key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        key.cancel();&lt;br/&gt;        cancelledKeys ++;&lt;br/&gt;        &lt;span&gt;// 当从selector中移除的socketChannel数量达到256个，设置needsToSelectAgain为true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 在io.netty.channel.nio.NioEventLoop.processSelectedKeysPlain 中重新做一次轮询，将失效的selectKey移除，&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 以保证selectKeySet的有效性&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cancelledKeys &amp;gt;= CLEANUP_INTERVAL) {&lt;br/&gt;            cancelledKeys = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            needsToSelectAgain = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用&lt;code&gt;JDK NIO SelectionKey&lt;/code&gt;的API &lt;code&gt;cancel方法&lt;/code&gt;，将&lt;code&gt;Channel&lt;/code&gt;从&lt;code&gt;Selector&lt;/code&gt;中取消掉。&lt;code&gt;SelectionKey#cancel方法&lt;/code&gt;调用完毕后，此时调用&lt;code&gt;SelectionKey#isValid&lt;/code&gt;将会返回&lt;code&gt;false&lt;/code&gt;。&lt;strong&gt;&lt;code&gt;SelectionKey#cancel方法&lt;/code&gt;调用后，&lt;code&gt;Selector&lt;/code&gt;会将要取消的这个&lt;code&gt;SelectionKey&lt;/code&gt;加入到&lt;code&gt;Selector&lt;/code&gt;中的&lt;code&gt;cancelledKeys集合&lt;/code&gt;中&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractSelector&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Selector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Set&amp;lt;SelectionKey&amp;gt; cancelledKeys = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;SelectionKey&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;cancel&lt;/span&gt;&lt;span&gt;(SelectionKey k)&lt;/span&gt; &lt;/span&gt;{                      &lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (cancelledKeys) {&lt;br/&gt;            cancelledKeys.add(k);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当&lt;code&gt;Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;取消完毕后，&lt;code&gt;Channel&lt;/code&gt;取消计数器&lt;code&gt;cancelledKeys&lt;/code&gt;会加1，当&lt;code&gt;cancelledKeys = 256&lt;/code&gt;时，将&lt;code&gt;needsToSelectAgain&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后在&lt;code&gt;Selector&lt;/code&gt;的**&lt;code&gt;下一次&lt;/code&gt;&lt;strong&gt;轮询过程中，会将&lt;code&gt;cancelledKeys集合&lt;/code&gt;中的&lt;code&gt;SelectionKey&lt;/code&gt;从&lt;code&gt;Selector&lt;/code&gt;中&lt;/strong&gt;所有的&lt;code&gt;KeySet&lt;/code&gt;中移除**。这里的&lt;code&gt;KeySet&lt;/code&gt;包括&lt;code&gt;Selector&lt;/code&gt;用于存放就绪&lt;code&gt;SelectionKey&lt;/code&gt;的&lt;code&gt;selectedKeys集合&lt;/code&gt;，以及用于存放所有注册的&lt;code&gt;Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;的&lt;code&gt;keys集合&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SelectorImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Set&amp;lt;SelectionKey&amp;gt; selectedKeys = &lt;span&gt;new&lt;/span&gt; HashSet();&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; HashSet&amp;lt;SelectionKey&amp;gt; keys = &lt;span&gt;new&lt;/span&gt; HashSet();&lt;br/&gt;    &lt;br/&gt;     .....................省略...............&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到&lt;code&gt;Reactor线程&lt;/code&gt;中对&lt;code&gt;needsToSelectAgain&lt;/code&gt;的判断是在&lt;code&gt;processSelectedKeysPlain方法&lt;/code&gt;处理&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;SelectionKey&lt;/code&gt;的循环体中进行判断的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以这里特别提到&lt;code&gt;needsToSelectAgain&lt;/code&gt;判断的位置，是要让大家注意到此时&lt;code&gt;Reactor&lt;/code&gt;正在处理&lt;code&gt;本次&lt;/code&gt;轮询的&lt;code&gt;IO就绪事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边也说了，当调用&lt;code&gt;SelectionKey#cancel方法&lt;/code&gt;后，需要等到&lt;code&gt;下次轮询&lt;/code&gt;的过程中&lt;code&gt;Selector&lt;/code&gt;才会将这些取消的&lt;code&gt;SelectionKey&lt;/code&gt;从&lt;code&gt;Selector&lt;/code&gt;中的所有&lt;code&gt;KeySet集合&lt;/code&gt;中移除，当然这里也包括就绪集合&lt;code&gt;selectedKeys&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;当在&lt;code&gt;本次&lt;/code&gt;轮询期间，假如大量的&lt;code&gt;Channel&lt;/code&gt;从&lt;code&gt;Selector&lt;/code&gt;中取消，Selector中的就绪集合&lt;code&gt;selectedKeys&lt;/code&gt;中依然会保存这些&lt;code&gt;Channel&lt;/code&gt;对应&lt;code&gt;SelectionKey&lt;/code&gt;直到&lt;code&gt;下次轮询&lt;/code&gt;。那么当然会影响本次轮询结果&lt;code&gt;selectedKeys&lt;/code&gt;的有效性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以为了保证&lt;code&gt;Selector&lt;/code&gt;中所有&lt;code&gt;KeySet&lt;/code&gt;的有效性&lt;/strong&gt;，需要在&lt;code&gt;Channel&lt;/code&gt;取消个数达到&lt;code&gt;256&lt;/code&gt;时，触发一次&lt;code&gt;selectNow&lt;/code&gt;，目的是清除无效的&lt;code&gt;SelectionKey&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;selectAgain&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        needsToSelectAgain = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            selector.selectNow();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;Failed to update SelectionKeys.&quot;&lt;/span&gt;, t);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，我们就对&lt;code&gt;JDK 原生 Selector&lt;/code&gt;的处理方式&lt;code&gt;processSelectedKeysPlain方法&lt;/code&gt;就介绍完了，其实 对&lt;code&gt;IO就绪事件&lt;/code&gt;的处理逻辑都是一样的，在我们理解了&lt;code&gt;processSelectedKeysPlain方法&lt;/code&gt;后，&lt;code&gt;processSelectedKeysOptimized方法&lt;/code&gt;对&lt;code&gt;IO就绪事件&lt;/code&gt;的处理，我们理解起来就非常轻松了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 processSelectedKeysOptimized&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty默认会采用优化过的&lt;code&gt;Selector&lt;/code&gt;对&lt;code&gt;IO就绪事件&lt;/code&gt;的处理。但是处理逻辑是大同小异的。下面我们主要介绍一下这两个方法的不同之处。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKeysOptimized&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 在openSelector的时候将JDK中selector实现类中得selectedKeys和publicSelectKeys字段类型&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 由原来的HashSet类型替换为 Netty优化后的数组实现的SelectedSelectionKeySet类型&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; selectedKeys.size; ++i) {&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; SelectionKey k = selectedKeys.keys[i];&lt;br/&gt;            &lt;span&gt;// 对应迭代器中得remove   selector不会自己清除selectedKey&lt;/span&gt;&lt;br/&gt;            selectedKeys.keys[i] = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Object a = k.attachment();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; AbstractNioChannel) {&lt;br/&gt;                processSelectedKey(k, (AbstractNioChannel) a);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                NioTask&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;) a;&lt;br/&gt;                processSelectedKey(k, task);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (needsToSelectAgain) {&lt;br/&gt;&lt;br/&gt;                selectedKeys.reset(i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;                selectAgain();&lt;br/&gt;                i = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;JDK NIO 原生 Selector&lt;/code&gt;存放&lt;code&gt;IO就绪的SelectionKey&lt;/code&gt;的集合为&lt;code&gt;HashSet类型&lt;/code&gt;的&lt;code&gt;selectedKeys&lt;/code&gt;。而Netty为了优化对&lt;code&gt;selectedKeys 集合&lt;/code&gt;的&lt;code&gt;遍历效率&lt;/code&gt;采用了自己实现的&lt;code&gt;SelectedSelectionKeySet类型&lt;/code&gt;，从而用对&lt;code&gt;数组&lt;/code&gt;的遍历代替用&lt;code&gt;HashSet&lt;/code&gt;的迭代器遍历。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Selector&lt;/code&gt;会在每次轮询到&lt;code&gt;IO就绪事件&lt;/code&gt;时，将&lt;code&gt;IO就绪的Channel&lt;/code&gt;对应的&lt;code&gt;SelectionKey&lt;/code&gt;插入到&lt;code&gt;selectedKeys集合&lt;/code&gt;，但是&lt;code&gt;Selector&lt;/code&gt;只管向&lt;code&gt;selectedKeys集合&lt;/code&gt;放入&lt;code&gt;IO就绪的SelectionKey&lt;/code&gt;，&lt;strong&gt;当&lt;code&gt;SelectionKey&lt;/code&gt;被处理完毕后，&lt;code&gt;Selector&lt;/code&gt;是不会自己主动将其从&lt;code&gt;selectedKeys集合&lt;/code&gt;中移除的，典型的&lt;code&gt;管杀不管埋&lt;/code&gt;&lt;/strong&gt;。所以需要Netty自己在遍历到&lt;code&gt;IO就绪的 SelectionKey&lt;/code&gt;后，将其删除。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;processSelectedKeysPlain&lt;/code&gt;中是直接将其从迭代器中删除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在&lt;code&gt;processSelectedKeysOptimized&lt;/code&gt;中将其在数组中对应的位置置为&lt;code&gt;Null&lt;/code&gt;，方便垃圾回收。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在最后清除无效的&lt;code&gt;SelectionKey&lt;/code&gt;时，在&lt;code&gt;processSelectedKeysPlain&lt;/code&gt;中由于采用的是&lt;code&gt;JDK NIO 原生的Selector&lt;/code&gt;，所以只需要执行&lt;code&gt;SelectAgain&lt;/code&gt;就可以，&lt;code&gt;Selector&lt;/code&gt;会自动清除无效Key。但是在&lt;code&gt;processSelectedKeysOptimized&lt;/code&gt;中由于是Netty自己实现的优化类型，所以需要Netty自己将&lt;code&gt;SelectedSelectionKeySet&lt;/code&gt;数组中的&lt;code&gt;SelectionKey&lt;/code&gt;全部清除，最后在执行&lt;code&gt;SelectAgain&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到这里，我们就将&lt;code&gt;Reactor线程&lt;/code&gt;如何处理&lt;code&gt;IO就绪事件&lt;/code&gt;的整个过程讲述完了，下面我们就该到了介绍&lt;code&gt;Reactor线程&lt;/code&gt;如何处理Netty框架中的异步任务了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Reactor线程处理异步任务&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty关于处理&lt;code&gt;异步任务&lt;/code&gt;的方法有两个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一个是无超时时间限制的&lt;code&gt;runAllTasks()方法&lt;/code&gt;。当&lt;code&gt;ioRatio&lt;/code&gt;设置为&lt;code&gt;100&lt;/code&gt;时，&lt;code&gt;Reactor线程&lt;/code&gt;会先一股脑的处理&lt;code&gt;IO就绪事件&lt;/code&gt;，然后在一股脑的执行&lt;code&gt;异步任务&lt;/code&gt;，并没有时间的限制。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一个是有超时时间限制的&lt;code&gt;runAllTasks(long timeoutNanos)方法&lt;/code&gt;。当&lt;code&gt;ioRatio != 100&lt;/code&gt;时，&lt;code&gt;Reactor线程&lt;/code&gt;执行&lt;code&gt;异步任务&lt;/code&gt;会有时间限制，优先一股脑的处理完&lt;code&gt;IO就绪事件&lt;/code&gt;统计出执行&lt;code&gt;IO任务&lt;/code&gt;耗时&lt;code&gt;ioTime&lt;/code&gt;。根据公式&lt;code&gt;ioTime * (100 - ioRatio) / ioRatio)&lt;/code&gt;计算出&lt;code&gt;Reactor线程&lt;/code&gt;执行&lt;code&gt;异步任务&lt;/code&gt;的超时时间。在超时时间限定范围内，执行有限的&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7879032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFQzpYkeAj6OPCbVND2MkRIuJ51EIOUubjvia8WEIyAurmRDPaMtdTxvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor执行比例分配.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下这两个执行&lt;code&gt;异步任务&lt;/code&gt;的方法处理逻辑：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 runAllTasks()&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;runAllTasks&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; fetchedAll;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; ranAtLeastOne = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//将到达执行时间的定时任务转存到普通任务队列taskQueue中，统一由Reactor线程从taskQueue中取出执行&lt;/span&gt;&lt;br/&gt;            fetchedAll = fetchFromScheduledTaskQueue();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (runAllTasksFrom(taskQueue)) {&lt;br/&gt;                ranAtLeastOne = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;while&lt;/span&gt; (!fetchedAll); &lt;span&gt;// keep on processing until we fetched all scheduled tasks.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ranAtLeastOne) {&lt;br/&gt;            lastExecutionTime = ScheduledFutureTask.nanoTime();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//执行尾部队列任务&lt;/span&gt;&lt;br/&gt;        afterRunningAllTasks();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ranAtLeastOne;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Reactor线程&lt;/code&gt;执行&lt;code&gt;异步任务&lt;/code&gt;的核心逻辑就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;先将到期的&lt;code&gt;定时任务&lt;/code&gt;一股脑的从定时任务队列&lt;code&gt;scheduledTaskQueue&lt;/code&gt;中取出并转存到普通任务队列&lt;code&gt;taskQueue&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由&lt;code&gt;Reactor线程&lt;/code&gt;统一从普通任务队列&lt;code&gt;taskQueue&lt;/code&gt;中取出任务执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在&lt;code&gt;Reactor线程&lt;/code&gt;执行完&lt;code&gt;定时任务&lt;/code&gt;和&lt;code&gt;普通任务&lt;/code&gt;后，开始执行存储于尾部任务队列&lt;code&gt;tailTasks&lt;/code&gt;中的&lt;code&gt;尾部任务&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下上述几个核心步骤的实现：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.1 fetchFromScheduledTaskQueue&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 从定时任务队列中取出达到deadline执行时间的定时任务&lt;br/&gt;     * 将定时任务 转存到 普通任务队列taskQueue中，统一由Reactor线程从taskQueue中取出执行&lt;br/&gt;     *&lt;br/&gt;     * */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;fetchFromScheduledTaskQueue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (scheduledTaskQueue == &lt;span&gt;null&lt;/span&gt; || scheduledTaskQueue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; nanoTime = AbstractScheduledEventExecutor.nanoTime();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;//从定时任务队列中取出到达执行deadline的定时任务  deadline &amp;lt;= nanoTime&lt;/span&gt;&lt;br/&gt;            Runnable scheduledTask = pollScheduledTask(nanoTime);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (scheduledTask == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!taskQueue.offer(scheduledTask)) {&lt;br/&gt;                &lt;span&gt;// taskQueue没有空间容纳 则在将定时任务重新塞进定时任务队列中等待下次执行&lt;/span&gt;&lt;br/&gt;                scheduledTaskQueue.add((ScheduledFutureTask&amp;lt;?&amp;gt;) scheduledTask);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前要执行&lt;code&gt;异步任务&lt;/code&gt;的时间点&lt;code&gt;nanoTime&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ScheduledFutureTask&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PromiseTask&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ScheduledFuture&lt;/span&gt;&amp;lt;&lt;span&gt;V&lt;/span&gt;&amp;gt;, &lt;span&gt;PriorityQueueNode&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; START_TIME = System.nanoTime();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;nanoTime&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; System.nanoTime() - START_TIME;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从定时任务队列中找出&lt;code&gt;deadline &amp;lt;= nanoTime&lt;/code&gt;的异步任务。也就是说找出所有到期的定时任务。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Runnable &lt;span&gt;pollScheduledTask&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; nanoTime)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//从定时队列中取出要执行的定时任务  deadline &amp;lt;= nanoTime&lt;/span&gt;&lt;br/&gt;        ScheduledFutureTask&amp;lt;?&amp;gt; scheduledTask = peekScheduledTask();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (scheduledTask == &lt;span&gt;null&lt;/span&gt; || scheduledTask.deadlineNanos() - nanoTime &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//符合取出条件 则取出&lt;/span&gt;&lt;br/&gt;        scheduledTaskQueue.remove();&lt;br/&gt;        scheduledTask.setConsumed();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; scheduledTask;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将&lt;code&gt;到期的定时任务&lt;/code&gt;插入到普通任务队列&lt;code&gt;taskQueue&lt;/code&gt;中，如果&lt;code&gt;taskQueue&lt;/code&gt;已经没有空间容纳新的任务，则将&lt;code&gt;定时任务&lt;/code&gt;重新塞进&lt;code&gt;定时任务队列&lt;/code&gt;中等待下次拉取。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;            &lt;span&gt;if&lt;/span&gt; (!taskQueue.offer(scheduledTask)) {&lt;br/&gt;                scheduledTaskQueue.add((ScheduledFutureTask&amp;lt;?&amp;gt;) scheduledTask);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fetchFromScheduledTaskQueue方法&lt;/code&gt;的返回值为&lt;code&gt;true&lt;/code&gt;时表示到期的定时任务已经全部拉取出来并转存到普通任务队列中。返回值为&lt;code&gt;false&lt;/code&gt;时表示到期的定时任务只拉取出来一部分，因为这时普通任务队列已经满了，当执行完普通任务时，还需要在进行一次拉取。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;到期的定时任务&lt;/code&gt;从定时任务队列中拉取完毕或者当普通任务队列已满时，这时就会停止拉取，开始执行普通任务队列中的&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.2 runAllTasksFrom&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;runAllTasksFrom&lt;/span&gt;&lt;span&gt;(Queue&amp;lt;Runnable&amp;gt; taskQueue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Runnable task = pollTaskFrom(taskQueue);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            safeExecute(task);&lt;br/&gt;            task = pollTaskFrom(taskQueue);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先&lt;code&gt;runAllTasksFrom 方法&lt;/code&gt;的返回值表示是否执行了至少一个异步任务。后面会赋值给&lt;code&gt;ranAtLeastOne变量&lt;/code&gt;，这个返回值我们后续会用到。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从普通任务队列中拉取&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Runnable &lt;span&gt;pollTaskFrom&lt;/span&gt;&lt;span&gt;(Queue&amp;lt;Runnable&amp;gt; taskQueue)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            Runnable task = taskQueue.poll();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (task != WAKEUP_TASK) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; task;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;safeExecute&lt;/span&gt;&lt;span&gt;(Runnable task)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            task.run();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;A task raised an exception. Task: {}&quot;&lt;/span&gt;, task, t);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1.3 afterRunningAllTasks&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;if&lt;/span&gt; (ranAtLeastOne) {&lt;br/&gt;            lastExecutionTime = ScheduledFutureTask.nanoTime();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//执行尾部队列任务&lt;/span&gt;&lt;br/&gt;        afterRunningAllTasks();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ranAtLeastOne;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;Reactor线程&lt;/code&gt;执行了至少一个&lt;code&gt;异步任务&lt;/code&gt;，那么设置&lt;code&gt;lastExecutionTime&lt;/code&gt;，并将&lt;code&gt;ranAtLeastOne标识&lt;/code&gt;返回。这里的&lt;code&gt;ranAtLeastOne标识&lt;/code&gt;就是&lt;code&gt;runAllTasksFrom方法&lt;/code&gt;的返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后执行收尾任务，也就是执行尾部任务队列中的尾部任务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterRunningAllTasks&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        runAllTasksFrom(tailTasks);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 runAllTasks(long timeoutNanos)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7879032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFQzpYkeAj6OPCbVND2MkRIuJ51EIOUubjvia8WEIyAurmRDPaMtdTxvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor执行比例分配.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里在处理&lt;code&gt;异步任务&lt;/code&gt;的核心逻辑还是和之前一样的，只不过就是多了对&lt;code&gt;超时时间&lt;/code&gt;的控制。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;runAllTasks&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeoutNanos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        fetchFromScheduledTaskQueue();&lt;br/&gt;        Runnable task = pollTask();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//普通队列中没有任务时  执行队尾队列的任务&lt;/span&gt;&lt;br/&gt;            afterRunningAllTasks();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//异步任务执行超时deadline&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; deadline = timeoutNanos &amp;gt; &lt;span&gt;0&lt;/span&gt; ? ScheduledFutureTask.nanoTime() + timeoutNanos : &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; runTasks = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; lastExecutionTime;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            safeExecute(task);&lt;br/&gt;            runTasks ++;&lt;br/&gt;            &lt;span&gt;//每运行64个异步任务 检查一下 是否达到 执行deadline&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((runTasks &amp;amp; &lt;span&gt;0x3F&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                lastExecutionTime = ScheduledFutureTask.nanoTime();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (lastExecutionTime &amp;gt;= deadline) {&lt;br/&gt;                    &lt;span&gt;//到达异步任务执行超时deadline，停止执行异步任务&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            task = pollTask();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (task == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                lastExecutionTime = ScheduledFutureTask.nanoTime();&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        afterRunningAllTasks();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.lastExecutionTime = lastExecutionTime;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先还是通过&lt;code&gt;fetchFromScheduledTaskQueue 方法&lt;/code&gt;从&lt;code&gt;Reactor&lt;/code&gt;中的定时任务队列中拉取&lt;code&gt;到期的定时任务&lt;/code&gt;，转存到普通任务队列中。当普通任务队列已满或者&lt;code&gt;到期定时任务&lt;/code&gt;全部拉取完毕时，停止拉取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将&lt;code&gt;ScheduledFutureTask.nanoTime() + timeoutNanos&lt;/code&gt;作为&lt;code&gt;Reactor线程&lt;/code&gt;执行异步任务的超时时间点&lt;code&gt;deadline&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;由于系统调用&lt;code&gt;System.nanoTime()&lt;/code&gt;需要一定的系统开销，所以每执行完&lt;code&gt;64&lt;/code&gt;个&lt;code&gt;异步任务&lt;/code&gt;的时候才会去检查一下&lt;code&gt;执行时间&lt;/code&gt;是否到达了&lt;code&gt;deadline&lt;/code&gt;&lt;/strong&gt;。如果到达了执行截止时间&lt;code&gt;deadline&lt;/code&gt;则退出停止执行&lt;code&gt;异步任务&lt;/code&gt;。如果没有到达&lt;code&gt;deadline&lt;/code&gt;则继续从普通任务队列中取出任务循环执行下去。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从这个细节又可以看出Netty对性能的考量还是相当讲究的&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程走到这里，我们就对&lt;code&gt;Reactor&lt;/code&gt;的整个运行框架以及&lt;code&gt;如何轮询IO就绪事件&lt;/code&gt;，&lt;code&gt;如何处理IO就绪事件&lt;/code&gt;，&lt;code&gt;如何执行异步任务&lt;/code&gt;的具体实现逻辑就剖析完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面还有一个小小的尾巴，就是Netty是如何解决文章开头提到的&lt;code&gt;JDK NIO Epoll 的空轮询BUG&lt;/code&gt;的，让我们一起来看下吧~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 解决JDK Epoll空轮询BUG&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到，由于&lt;code&gt;JDK NIO Epoll的空轮询BUG&lt;/code&gt;存在，这样会导致&lt;code&gt;Reactor线程&lt;/code&gt;在没有任何事情可做的情况下被意外唤醒，导致CPU空转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实Netty也没有从根本上解决这个&lt;code&gt;JDK BUG&lt;/code&gt;，而是选择巧妙的绕过这个&lt;code&gt;BUG&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下Netty是如何做到的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUYTp9c1sNkZNVOxaic2cTaYFTnM9CIZtxrHYK0A5iaUKOFqWslWpHBDtxcdsbJAY2tibu7MbuSpPqSMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;探测JDK NIO Epoll空轮询BUG.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                &lt;span&gt;if&lt;/span&gt; (ranTasks || strategy &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (selectCnt &amp;gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;amp;&amp;amp; logger.isDebugEnabled()) {&lt;br/&gt;                        logger.debug(&lt;span&gt;&quot;Selector.select() returned prematurely {} times in a row for Selector {}.&quot;&lt;/span&gt;,&lt;br/&gt;                                selectCnt - &lt;span&gt;1&lt;/span&gt;, selector);&lt;br/&gt;                    }&lt;br/&gt;                    selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (unexpectedSelectorWakeup(selectCnt)) { &lt;span&gt;// Unexpected wakeup (unusual case)&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//既没有IO就绪事件，也没有异步任务，Reactor线程从Selector上被异常唤醒 触发JDK Epoll空轮训BUG&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//重新构建Selector,selectCnt归零&lt;/span&gt;&lt;br/&gt;                    selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Reactor线程&lt;/code&gt;处理完&lt;code&gt;IO就绪事件&lt;/code&gt;和&lt;code&gt;异步任务&lt;/code&gt;后，会检查这次&lt;code&gt;Reactor线程&lt;/code&gt;被唤醒有没有执行过异步任务和有没有&lt;code&gt;IO就绪的Channel&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;boolean ranTasks&lt;/code&gt; 这时候就派上了用场，这个&lt;code&gt;ranTasks&lt;/code&gt;正是前边我们在讲&lt;code&gt;runAllTasks方法&lt;/code&gt;时提到的返回值。用来表示是否执行过至少一次&lt;code&gt;异步任务&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;int strategy&lt;/code&gt; 正是&lt;code&gt;JDK NIO Selector&lt;/code&gt;的&lt;code&gt;select方法&lt;/code&gt;的返回值，用来表示&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel个数&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;ranTasks = false 并且 strategy = 0&lt;/code&gt;这代表&lt;code&gt;Reactor线程&lt;/code&gt;本次既没有&lt;code&gt;异步任务&lt;/code&gt;执行也没有&lt;code&gt;IO就绪&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;需要处理却被意外的唤醒。等于是空转了一圈啥也没干。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下Netty就会认为可能已经触发了&lt;code&gt;JDK NIO Epoll的空轮询BUG&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;int&lt;/span&gt; SELECTOR_AUTO_REBUILD_THRESHOLD = SystemPropertyUtil.getInt(&lt;span&gt;&quot;io.netty.selectorAutoRebuildThreshold&quot;&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;unexpectedSelectorWakeup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; selectCnt)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;          ..................省略...............&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 走到这里的条件是 既没有IO就绪事件，也没有异步任务，Reactor线程从Selector上被异常唤醒&lt;br/&gt;         * 这种情况可能是已经触发了JDK Epoll的空轮询BUG，如果这种情况持续512次 则认为可能已经触发BUG，于是重建Selector&lt;br/&gt;         *&lt;br/&gt;         * */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (SELECTOR_AUTO_REBUILD_THRESHOLD &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;&lt;br/&gt;                selectCnt &amp;gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {&lt;br/&gt;            &lt;span&gt;// The selector returned prematurely many times in a row.&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// Rebuild the selector to work around the problem.&lt;/span&gt;&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;Selector.select() returned prematurely {} times in a row; rebuilding Selector {}.&quot;&lt;/span&gt;,&lt;br/&gt;                    selectCnt, selector);&lt;br/&gt;            rebuildSelector();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;Reactor&lt;/code&gt;这种意外唤醒的次数&lt;code&gt;selectCnt&lt;/code&gt;超过了配置的次数&lt;code&gt;SELECTOR_AUTO_REBUILD_THRESHOLD&lt;/code&gt;,那么Netty就会认定这种情况可能已经触发了&lt;code&gt;JDK NIO Epoll空轮询BUG&lt;/code&gt;，则重建&lt;code&gt;Selector&lt;/code&gt;(&lt;code&gt;将之前注册的所有Channel重新注册到新的Selector上并关闭旧的Selector&lt;/code&gt;)，&lt;code&gt;selectCnt计数&lt;/code&gt;归&lt;code&gt;0&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;SELECTOR_AUTO_REBUILD_THRESHOLD&lt;/code&gt;默认为&lt;code&gt;512&lt;/code&gt;，可以通过系统变量&lt;code&gt;-D io.netty.selectorAutoRebuildThreshold&lt;/code&gt;指定自定义数值。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果&lt;code&gt;selectCnt&lt;/code&gt;小于&lt;code&gt;SELECTOR_AUTO_REBUILD_THRESHOLD&lt;/code&gt;，则返回不做任何处理，&lt;code&gt;selectCnt&lt;/code&gt;继续计数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty就这样通过计数&lt;code&gt;Reactor&lt;/code&gt;被意外唤醒的次数，如果计数&lt;code&gt;selectCnt&lt;/code&gt;达到了&lt;code&gt;512次&lt;/code&gt;，则通过&lt;code&gt;重建Selector&lt;/code&gt; 巧妙的绕开了&lt;code&gt;JDK NIO Epoll空轮询BUG&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们在日常开发中也可以借鉴Netty这种处理问题的思路，比如在项目开发中，当我们发现我们无法保证彻底的解决一个问题时，或者为了解决这个问题导致我们的投入产出比不高时，我们就该考虑是不是应该换一种思路去绕过这个问题，从而达到同样的效果。&lt;em&gt;*解决问题的最高境界就是不解决它，巧妙的绕过去~~~~~！！&lt;/em&gt;*&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文花了大量的篇幅介绍了&lt;code&gt;Reactor&lt;/code&gt;整体的运行框架，并深入介绍了&lt;code&gt;Reactor&lt;/code&gt;核心的工作模块的具体实现逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过本文的介绍我们知道了&lt;code&gt;Reactor&lt;/code&gt;如何轮询注册在其上的所有Channel上感兴趣的IO事件，以及Reactor如何去处理IO就绪的事件，如何执行Netty框架中提交的异步任务和定时任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后介绍了Netty如何巧妙的绕过JDK NIO Epoll空轮询的BUG,达到解决问题的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提炼了新的解决问题的思路：&lt;strong&gt;解决问题的最高境界就是不解决它，巧妙的绕过去&lt;/strong&gt;~~~~~！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本文的内容就到这里了，我们下篇文章见~~~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6da6b77976d5ec6a0b64037c1e098041</guid>
<title>计算机极简公开课推荐</title>
<link>https://toutiao.io/k/3n242s7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;网上有很多推荐计算机公开课的帖子，但有的文章推荐了太多，反而容易收藏后吃灰。故针对计算机的基础知识，推荐几门我觉得不错的公开课给大家。&lt;/p&gt;&lt;p&gt;这些课大部分我都做过一些（惭愧，都没有完全做完），用打星的方式来标识下难度，五星最难，打分难免主观，欢迎拍砖。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;工具环境：MIT:The Missing Semester of Your CS Education&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工欲善其事，必先利其器。操作系统、数据库这些计算机基础诚然重要，但是一个程序员实际工作中天天打交道的其实是这些工具。因此，这门课值得放在最前面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;The Missing Semester of Your CS Education：https:/missing.csail.mit.edu&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中文翻译：https://missing-semester-cn.github.io/&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NTcxNzY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jHMBqsHehTOuL8q0hDhPPF0wYIIkDAHic3Ks2NXSFsVVMGaiaZp9V0vXMdhibMiaI3Sicp57KjZdKic0zVOMgVGwhVnw/0?wx_fmt=png&quot; data-nickname=&quot;木鸟杂记&quot; data-alias=&quot;distributed-system&quot; data-signature=&quot;分布式系统、分布式存储、摄影分享、读书笔记&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编程思维：CS 61A&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本门课程以巫书（Wizard Book） SICP 为教材。涵盖了编程思维中非常重要的方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;抽象之——函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;抽象之——数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解构程序执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据处理范式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其有本关联的小书讲的尤其不错：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Composing Programs&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。另外，他用了 Python 这样一门很 handy 的语言作为授课和实验的辅助语言，于是，你还可以顺手学个这么火的 Python。这门课类似于各种编程世界中武功心法总纲，想必能苦苦思索计算机“为什么”的你十分受用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;操作系统：MIT 6.828&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用一个简单的 xv6 教学操作系统，通过实验实现一些操作系统中的关键算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Operating System Engineering&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据库开发：cmu15445&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲义和资料都很翔实。四个实验，构成一个简单的数据库 DBMS。可以看之前 Andy 授课的版本，他讲课比较有激情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CMU 15-445/645 : Database Systems (Fall 2020)&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分布式系统：MIT 6.824&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难度级别：★★★★&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统作为当今工业界系统的基石，值得一门公开课。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该课程梳理了近年来工业界分布式系统各种广为应用系统后的论文，设置了分布式系统基石——分布式共识协议的实验，绝对值得一学。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.824 Distributed Systems: Spring 2020&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Composing Programs: &lt;em&gt;http://composingprograms.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Operating System Engineering: &lt;em&gt;https://pdos.csail.mit.edu/6.828/2018/schedule.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;CMU 15-445/645 : Database Systems (Fall 2020): &lt;em&gt;https://15445.courses.cs.cmu.edu/fall2020/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Distributed Systems: &lt;em&gt;http://nil.csail.mit.edu/6.824/2020&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;题图故事&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jHMBqsHehTNdtFIj5fDOd520Y5DvNbZLMFE2rQFnXicbJVmia0YOUNJ7r10nOwHHaicDFzz3MicsffmeEDxYaS3V8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;公司杭州办公室的窗外，最喜欢的大落地窗&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我是青藤木鸟，一个喜欢摄影的分布系统程序员，欢关注我的公众号：&lt;strong&gt;木鸟杂记&lt;/strong&gt;。如果觉得我的文章还不错，就点个在看支持一下吧，感谢。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>