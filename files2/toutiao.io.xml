<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>08eaeb3aba0caa4db81bc3d0be7ef45d</guid>
<title>代码质量管理平台 SonarLint 在监控宝中的实践总结</title>
<link>https://toutiao.io/k/39hakmk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：云智慧开发工程师 Kori Zhang。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cloudwise.com/cn/page/synmonitoring.html&quot;&gt;点击直达监控宝官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;监控宝作为云智慧推出的新一代用户体验监控工具，向用户提供了 IT 性能监控（IT Performance Monitoring）的 SaaS 产品服务。Sonar（代码质量管理平台）是一个开源平台，用于管理源代码的质量。从 Sonar 1.6 版本开始，Sonar 从一个质量数据报告工具，转变成为代码质量管理平台。本文将通过介绍免费开源 IDE 扩展 SonarLint 的使用方法，总结 SonarLint 在监控宝中的落地实践效果。&lt;/p&gt;

&lt;h2&gt;SonarLint 是什么&lt;/h2&gt;

&lt;p&gt;SonarLint 是一个免费的开源 IDE 扩展,可在您编写代码时查找和修复错误、漏洞和代码质量问题。&lt;/p&gt;

&lt;h3&gt;SonarLint 作用&lt;/h3&gt;

&lt;p&gt;SonarLint 发现的问题后，会根据问题类型给出推荐的的范例代码协助开发人员找到合适的修改思路。&lt;/p&gt;

&lt;h3&gt;SonarLint 安装使用&lt;/h3&gt;

&lt;p&gt;SonarLint 目前支持多种 IDE 的插件安装，我使用的是 idea 所以这里介绍在 idea 中的安装方式其它的可以查看官网 sonar。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 选择file→settings→plugins→输入sonarlint。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c89aff01ef4e06a91a327ef77650c6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 下图显示为已安装过的界面，所以界面为 uninstall，如果没安装显示的则是 install，安装完重启之后就可以使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12ce8dd6a1f4bb5ac2f2df0bb59a7cc%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 右键项目进行如下操作：&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d221cef8085a4630b125a79f73e34740%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 执行之后可以看到如下信息，如果代码中有不合理的地方会在 report 中显示。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c550713762174689bc76d6b5667a1963%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其他设置请参考: &lt;a href=&quot;https://blog.csdn.net/baixf/article/details/88534198&quot;&gt;https://blog.csdn.net/baixf/article/details/88534198&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;监控宝中 SonarLint 实践效果&lt;/h3&gt;

&lt;p&gt;SonarLint 已在监控宝 jkbFileServer、Alertd 重构、jkbApiServer 重构中运用，实践效果如下：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  SonarLint 的及时反馈，可以帮助我们在编写阶段就保持一定的代码质量进而提高编码能力；&lt;/li&gt;
&lt;li&gt;  通过 Sonar 扫描后减少不必要返工；&lt;/li&gt;
&lt;li&gt;  SonarLint 配合 IDE 使用方便；&lt;/li&gt;
&lt;li&gt;  对于完美主义的程序员绝对是利器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;Alibaba代码规范插件 vs SonarLint&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  Alibaba 代码规范插件比较关心的是代码规范，编码风格上的，例如命名规范、注释、代码行数等；&lt;/li&gt;
&lt;li&gt;  SonarLint 比较关心代码正确性，存在的问题、风险、漏洞等，例如重复代码、空指针、安全漏洞。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总体来讲，Alibaba 代码规范插件与 SonarLint ****二者侧的重点不同。机器配置高的情况下建议二者配合使用，可提高工程整体的代码质量，并且能够在编码阶段规避风险，提高程序的健壮性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cloudwise.com/cn/page/synmonitoring.html&quot;&gt;点击直达监控宝官网&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1d5d72c3249d1a95f9f8da3c8986a6c</guid>
<title>八万字《高并发的哲学原理》第五章：拆分网络单点(上)--应用网关、负载均衡和路由器(网关)</title>
<link>https://toutiao.io/k/2qnehmg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;本文共 7000 字，阅读大约需要 23 分钟。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;上一篇文章的末尾，我们提到了一个假想出来的五万 QPS 的系统，以及这种规模的系统架构中必然存在的负载均衡器，那本篇文章我们就来一起利用负载均衡搭建一个能够支撑五万 QPS 的系统。&lt;/section&gt;&lt;h2&gt;“监听 HTTPS 443 端口的进程”这个单点&lt;/h2&gt;&lt;p&gt;之前，我们拆出了“监听 HTTPS 443 端口的进程”这个单点，并用 kong 网关来承载了这个单点。目前，在 2 vCore 的虚拟机上，2000 QPS 的压力对应的大约是 20% 的 CPU 占用率，经过换算我们可以知道：假如 kong 的性能可以随着核心数增加而线性提升的话，在维持最大 40% CPU 占用率的情况下，需要：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;(50000 / 2000) &lt;em&gt;2&lt;/em&gt; (20% / 40%) = 25 核&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这里我们先假设我们搞了一个 25 核的虚拟机，接住了这五万 QPS（实际上接不住，我们后面会说），那这个 Kong 网关到底是什么玩意儿呢？它就是标题中的“应用网关”。&lt;/p&gt;&lt;h3&gt;应用网关&lt;/h3&gt;&lt;p&gt;应用网关，又称 API 网关，顾名思义，它就是所有 API 请求的大门：自己接下所有的 HTTP/HTTPS/TCP 请求，再将请求转发给真正的上游服务器。而这些上游服务器可能是一堆虚拟机，也可能是一堆容器，甚至可以是多个数据中心各自的应用网关。由于应用网关做的事情非常少，所以它能支撑很高 QPS 的系统。&lt;/p&gt;&lt;p&gt;常见的应用网关软件有 HAProxy、Nginx、Envoy 等，而 Cisco、Juniper、F5 等一体化设备厂商也有相关的硬件产品。&lt;/p&gt;&lt;p&gt;应用网关除了提升系统容量外，还有很多别的优势。&lt;/p&gt;&lt;h4&gt;1. 解放后端架构&lt;/h4&gt;&lt;p&gt;经过对应用网关两年的使用，我现在认为所有系统都应该放在应用网关的背后，包括开发环境。&lt;/p&gt;&lt;p&gt;应用网关对后端架构的解放作用实在是太大了，可以让你在后端玩出花来：各种语言、各种技术、各种部署形式、甚至全国各地的机房都可以成为某条 URL 的最终真实服务方，让你的后端架构彻底起飞。&lt;/p&gt;&lt;h4&gt;2. TLS 卸载&lt;/h4&gt;&lt;p&gt;终端用户访问应用网关的时候采用的是 HTTPS 协议，这个协议是需要对数据进行加密解密的，应用网关非常适合干这件事情，而背后的业务系统只提供标准 HTTP 协议即可，降低了业务系统的部署复杂度和资源消耗。&lt;/p&gt;&lt;h4&gt;3. 身份验证和安全性提升&lt;/h4&gt;&lt;p&gt;应用网关可以对后端异构系统进行统一的身份验证，无需一个一个单独实现。也可以统一防火墙白名单，后端系统防火墙只对网关 ip 开放，极大提升了后端系统的安全性，降低了海量服务器安全管理的难度。甚至可以针对某条 API 进行单独鉴权，让系统的安全管控能力大幅提升。&lt;/p&gt;&lt;h4&gt;4. 指标和数据收集&lt;/h4&gt;&lt;p&gt;由于所有流量都会经过网关，所以对指标进行收集也变的简单了，你甚至可以将双向流量的内容全部记录下来，用于数据统计和安全分析。&lt;/p&gt;&lt;h4&gt;5. 数据压缩与转换&lt;/h4&gt;&lt;p&gt;应用网关还可以统一对流量进行 gzip 压缩，可以将所有业务一次性升级到 HTTP/2 和 HTTP/3，可以对数据进行格式转换（XML 到 JSON）和修改（增加/修改/删除字段），总是就是能各种上下其手，翻云覆雨，随心所欲。&lt;/p&gt;&lt;h3&gt;负载均衡&lt;/h3&gt;&lt;p&gt;应用网关的另一个价值就是负载均衡了：可以将请求的流量按照各种比例分发给不同的后端服务器，提升系统容量；可以做红蓝发布和金丝雀发布；可以针对流量特点做灰度发布；可以主动调节各个后端服务器的压力；屏蔽失效的后端服务器等等。&lt;/p&gt;&lt;h4&gt;低负载下应用网关和负载均衡可以是同一个软件&lt;/h4&gt;&lt;p&gt;虽然应用网关和负载均衡是两个不同的概念，但在低负载系统里，他们两个往往由同一个软件来扮演，例如前面说到的 Kong 网关就同时具备这两个功能。&lt;/p&gt;&lt;h2&gt;拆分应用网关&lt;/h2&gt;&lt;p&gt;一个五万 QPS 的系统，是无法使用 25 核的单机安装 Kong 网关来承载的，因为此时单机 TCP 连接数已经达到了十万以上，在这个条件下强如 Nginx 也达到性能极限了，性能不再增长甚至会开始下降，用户体验也会迅速变差。此时，我们需要对应用网关进行拆分。&lt;/p&gt;&lt;h3&gt;应用网关怎么拆&lt;/h3&gt;&lt;p&gt;逻辑上，应用网关执行的是“反向代理+数据过滤”任务，并没有要求应用网关只能由一台服务器来承接，换句话说，应用网关&lt;code&gt;不是单点&lt;/code&gt;，只要多个节点的行为一致，那就可以共同承接这五万 QPS 的真实用户流量。&lt;/p&gt;&lt;p&gt;我们只需要在多台机器上装上同样版本的应用网关软件，然后在他们之间同步配置文件即可。Kong 采用的策略是让多个实例连接同一个&lt;code&gt;PostgreSQL&lt;/code&gt;数据库，每五秒从数据库获取一次最新的配置，如果数据库挂掉，那就保持内存中的现有配置继续运行。&lt;/p&gt;&lt;p&gt;Kong 集群追求的是“最终一致性”，不追求五秒的得失，反而让系统格外地容易扩展，格外的健壮，最后一篇文章我们还会见到使用类似思维的“DNS 分布式拆分”。这个朴素的分布式架构颇有毛子暴力美学的风范，后面我们讨论列存储 clickhouse 的时候还能见到。&lt;/p&gt;&lt;p&gt;如果单个应用网关扛不住五万 QPS，那我们搞一个负载均衡器放在应用网关的前面，架构图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8650306748466258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYSwKvVf2YNWyRL868SmEFxamMQFjia1gtFb5KN3cuBt7Z33mwUZMV3UA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;h2&gt;分层的网络&lt;/h2&gt;&lt;h3&gt;负载均衡器为何能抗住五万 QPS&lt;/h3&gt;&lt;p&gt;看到这里有人可能会疑惑，既然单机的 Nginx 都顶不住五万 QPS 带来的 TCP 资源开销，那负载均衡器如何抗住呢？因为负载均衡器承载的是比 Nginx 所承载的 TCP 更下面一层的协议：IP 协议。&lt;/p&gt;&lt;p&gt;至此，我们正式进入了网络拆分之路，这条路很难走，但收益也会很大，最终我们将得到一个 200Gbps 带宽的&lt;code&gt;软件定义负载均衡集群&lt;/code&gt;，让我们正式开始。&lt;/p&gt;&lt;h3&gt;网络是分层的&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3932702418506835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYwM5J4u0tvW3oWeDcq9hiaF97E0rjnGnwoLvYlr8vCroTOIJYuIc9fJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1902&quot;/&gt;&lt;/p&gt;&lt;center&gt;经典 TCP/IP 四层网络协议的首部&lt;/center&gt;&lt;p&gt;上面这张图引用自我的另一个系列文章：软件工程师需要了解的网络知识：从铜线到HTTP（三）—— TCP/IP¹。&lt;/p&gt;&lt;p&gt;如果你查看过网页的源代码，你就能知道网页背后是一段 HTML 代码，这段代码是被&lt;code&gt;层层包裹&lt;/code&gt;之后，再在网络中传输的，就像上图中一样。以太网之所以拥有如此之强的扩展性和兼容能力，就是因为它的“分层特性”：每一层都有专门的硬件设备来对网络进行扩展，最终组成了这个容纳全球数十亿台网络设备的“互联网”。最近，这些传统硬件设备的工作越来越多地被软件所定义，即&lt;code&gt;软件定义网络&lt;/code&gt;(SDN)。&lt;/p&gt;&lt;h3&gt;应用数据是什么&lt;/h3&gt;&lt;p&gt;应用数据就是网页背后的 HTTP 协议所包含的全部数据。&lt;/p&gt;&lt;p&gt;我们使用 Charles 反向代理软件可以轻易地得到 HTTP 协议的细节。下面我们展示一个普通的 GET 例子。使用浏览器访问 http://httpbin.org （自己尝试的时候不要选择 HTTPS 网站）：&lt;/p&gt;&lt;h4&gt;请求内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1&lt;br/&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&lt;br/&gt;Accept-Encoding: gzip, deflate&lt;br/&gt;Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6&lt;br/&gt;Cache-Control: max-age=0&lt;br/&gt;Connection: keep-alive&lt;br/&gt;Host: httpbin.org&lt;br/&gt;Upgrade-Insecure-Requests: 1&lt;br/&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36 Edg/108.0.1462.54&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;数据解释：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;第一行有三个元素：HTTP 方法、uri、HTTP 版本&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;之后的每一行均以冒号&lt;code&gt;:&lt;/code&gt;作为间隔符，左边是 key，右边是 value&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HTTP 协议中，换行采用的不是 Linux 系统的 \n，而是跟 Windows 一样的 \r\n&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;响应内容&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&lt;br/&gt;Date: Wed, 04 Jan 2023 12:07:36 GMT&lt;br/&gt;Content-Type: text/html; charset=utf-8&lt;br/&gt;Content-Length: 9593&lt;br/&gt;Connection: keep-alive&lt;br/&gt;Server: gunicorn/19.9.0&lt;br/&gt;Access-Control-Allow-Origin: *&lt;br/&gt;Access-Control-Allow-Credentials: true&lt;br/&gt;&lt;br/&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;br/&gt;    &amp;lt;title&amp;gt;httpbin.org&amp;lt;/title&amp;gt;&lt;br/&gt;    &amp;lt;link href=&quot;https://fonts.googleapis.com/css?family=Open+Sans:400,700|Source+Code+Pro:300,600|Titillium+Web:400,600,700&quot;&lt;br/&gt;        rel=&quot;stylesheet&quot;&amp;gt;&lt;br/&gt;    &amp;lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;/flasgger_static/swagger-ui.css&quot;&amp;gt;&lt;br/&gt;    &amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;/static/favicon.ico&quot; sizes=&quot;64x64 32x32 16x16&quot; /&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;a href=&quot;https://github.com/requests/httpbin&quot; class=&quot;github-corner&quot; aria-label=&quot;View source on Github&quot;&amp;gt;&lt;br/&gt;    &amp;lt;/a&amp;gt;&lt;br/&gt;    ... ... 此处省略一万个字&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;响应数据的基本规则和请求一样，第一行的三个元素分别是 协议版本、状态码、状态码的简短解释。唯一的不同是，返回值里面还有 HTTP body。&lt;/p&gt;&lt;h5&gt;HTTP header 和 HTTP body&lt;/h5&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;两个换行即 \r\n\r\n 之前的内容为 HTTP header&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;两个换行之后的内容为 HTTP body&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HTTP body 就是你在浏览器“查看源代码”所看到的内容&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;HTTP 下面是 TCP 层&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6573529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYm94vcoJnudG9DAov3BptbRSV7egY07mpyyvGKBmzkbbPicG2ljia7icXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;center&gt;TCP 首部图示&lt;/center&gt;&lt;h4&gt;TCP 首部重要数据描述&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;TCP 首部中最重要的数据是&lt;code&gt;源端口&lt;/code&gt;和&lt;code&gt;目的端口&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;他们各由 16 位二进制数组成，2^16 = 65536，所以网络端口的范围是 0-65535&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我们可以注意到，目的端口号这个重要数据是放在 TCP 首部的，和更下层的 IP 首部、以太网帧首部毫无关系&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;TCP 下面是 IP 层&lt;/h3&gt;&lt;p&gt;全球所有公网 IPv4 组成了一个大型网络，这个 IP 网络其实就是&lt;code&gt;互联网&lt;/code&gt;的本体。（IPv6 比较复杂，本文再次不做详细讨论，以下示例均基于 IPv4）&lt;/p&gt;&lt;p&gt;在 IP 层中，每台设备都有一个 ip 地址，形如&lt;code&gt;123.123.123.123&lt;/code&gt;：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;IPv4 地址范围为 0.0.0.0 - 255.255.255.255&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;255 为 2 的 8 次方减一，也就是说用八位二进制可以表示 0-255&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;四个八位即为 32 位，4 个字节&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;IP 首部有哪些信息&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5528846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYicAc4IbskwTZvLbeGwEuvQAFOkA9GURaUOGELTuPBhO897VSCaR1dQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可以看出，ip 首部有 20 字节的固定长度是用来存储这个 IP 数据包的基本信息的：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源地址 32 位（4 个字节）：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的地址 32 位（4 个字节）：110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 8 位（1 个字节）：内部数据包使用的协议，即 TCP、UDP 或 ICMP（就是 ping 命令使用的协议）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;首部检验和 16 位（2 个字节）：此 IP 首部的数据校验和，用于验证 IP 首部的数据完整性&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;ip 首部最重要的数据是&lt;code&gt;源 ip 地址&lt;/code&gt;和&lt;code&gt;目的 ip 地址&lt;/code&gt;&lt;/h4&gt;&lt;h3&gt;IP 层下面是 MAC 层(物理层)&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3555992141453831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLYRu9jSgPq1m5EXJLYo4OL4ewZcjJ62niaumGY4Ar8KGyHZADuFGRaycw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1018&quot;/&gt;&lt;/p&gt;&lt;p&gt;物理层中的二进制数据以上图中的格式进行组织，其基本单元被称为“MAC 帧”。&lt;/p&gt;&lt;p&gt;每一台网络设备的 MAC 帧的长度不一定一致，默认为 1500，即 IP 层的数据会按照这个长度进行分包。在局域网速度跑不到协商速率，需要做性能优化时（例如 iSCSI 网络磁盘），可以使用“巨型帧”技术，将这个数字增加到一万，可以提升网络传输性能。不过，根据我的实际优化经验，绝大多数场景下，巨型帧对网络性能的提升小于 5%，属于一种聊胜于无的优化手段。&lt;/p&gt;&lt;p&gt;目的地址和源地址均为 MAC 地址，形式如 AA:BB:CC:DD:EE:FF，共有六段，每一段是一个两位的 16 进制数，两位 16 进制数换算成二进制就是 8 位，所以 MAC 地址的长度为 8*6 = 48 位。&lt;/p&gt;&lt;p&gt;类型字段采用 16 位二进制表示更上一层（ip 层）的网络层数据包的类型：IPv4、IPv6、ARP、iSCSI、RoCE 等等。&lt;/p&gt;&lt;p&gt;MAC 层就是交换机工作的地方，我们下篇文章会讲。&lt;/p&gt;&lt;h2&gt;Nginx 的性能极限&lt;/h2&gt;&lt;p&gt;在真实世界中，QPS 一般比保持 TCP 连接的客户端的数量要少，在此我们假设为四分之一，即：有 20 万个客户端设备在这段时间内访问我们的系统，每个客户端设备平均每 4 秒发送一个 HTTPS 请求。&lt;/p&gt;&lt;h3&gt;单台 Nginx 反向代理的性能极限&lt;/h3&gt;&lt;p&gt;由于 Nginx 不仅需要建立 TCP 连接，还需要将 TCP 连接中发送过来的数据包和某个进程/线程进行匹配，还需要对 HTTP 协议的信息进行解析、识别、转换、添加，所以它也有 QPS 上限：&lt;/p&gt;&lt;p&gt;在 2015 年主流的服务器 CPU 上，Nginx 官方在进行了极限优化的情况下进行了反向代理性能测试，在“建立 TCP 连接-发送 HTTPS 请求-断开 TCP 连接”的极限拉扯下，最高性能为 6W QPS（SSL TPS RSA 2048bit）²。&lt;/p&gt;&lt;p&gt;假设我们使用最新的服务器硬件，当虚拟机 CPU 达到 32 vCore 的时候，未经优化的单机 Nginx 性能就已经达到极限，能承受大约 1 万 HTTPS QPS，对应的连接用户就是 4 万，这个数字其实已经很夸张了。&lt;/p&gt;&lt;h2&gt;TCP 负载均衡器为何能抗住五万 QPS&lt;/h2&gt;&lt;p&gt;我们假设单台 Kong 应用网关的极限为 1 万 QPS，于是我们就需要五台 Kong，那这五台 Kong 前面的 TCP 负载均衡为何能够抗住呢？因为 TCP 负载均衡器要干的事情比 Kong 少非常多：它只需要在 IP 层做少量的工作即可。&lt;/p&gt;&lt;h3&gt;使用负载均衡器拆分 TCP 单点&lt;/h3&gt;&lt;p&gt;TCP 协议是一种“可靠地传输信息”的方法，它不仅有三次握手四次挥手等复杂的控制流程，还会对每一个报文段进行排序、确认、重发等操作来保证最终数据的完整和正确，所以，TCP 本身就是一种需要很多资源处理的&lt;code&gt;单点&lt;/code&gt;，接下来我们开始拆这个单点。&lt;/p&gt;&lt;h3&gt;TCP 负载均衡器的工作过程&lt;/h3&gt;&lt;p&gt;我们假设客户端 ip 为 123.123.123.123，负载均衡器的 ip 为 110.242.68.3（公网）和 10.0.0.100（私网），五台 Kong 服务器的 ip 为 10.0.0.1 ~ 10.0.0.5，架构图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8775252525252525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA3ENoeFVCSfeyaSoUibPZYLY0fpcxRuUicslPo9gALgZzI5SGicb41dRwTV7WY14GEnbDbf8SzwIVpOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/p&gt;&lt;p&gt;负载均衡器的工作过程如下：&lt;/p&gt;&lt;h4&gt;1. 接收数据（左侧）&lt;/h4&gt;&lt;p&gt;负载均衡器接收客户端数据包（报文）的过程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;负载均衡器收到了一个 ip 报文：源地址 123.123.123.123，目的地址 110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ip 报文内包裹着一个 TCP 报文，详情如下：源端口 52387，目的端口 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注意，负载均衡器只是接收了一个 IP 报文，并没有和客户端进行三次握手，并没有和客户端建立“TCP 连接”&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;2. 发送数据给上游服务器（右侧）&lt;/h4&gt;&lt;p&gt;在接收到客户端的 IP 报文以后，负载均衡器会找一台上游服务器，准备把数据发送过去：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内部 TCP 报文首部：源端口 45234，目的端口 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TCP 报文外面包裹的 IP 首部：源地址 10.0.0.100，目的地址 10.0.0.1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;负载均衡器将包裹着 TCP 数据包的 IP 报文发送了出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;3. 建立两个报文的映射关系并进行数据转发&lt;/h4&gt;&lt;p&gt;负载均衡器会在内存里创建两个五元组：&lt;/p&gt;&lt;p&gt;左侧五元组&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;左侧源地址 123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧目的地址 110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧源端口 52387&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;左侧目的地址 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 TCP&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;右侧五元组&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;右侧源地址 10.0.0.100&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧目的地址 10.0.0.1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧源端口 45234&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;右侧目的地址 443&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;协议 TCP&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;然后，负载均衡器会关联这两个五元组：对两侧发来的数据包（报文）进行拆包和修改（两个地址+两个端口），并从另一侧发送出去。&lt;/p&gt;&lt;h3&gt;这是什么？这就是你家的路由器（网关）呀&lt;/h3&gt;&lt;p&gt;看过我《软件工程师需要了解的网络知识》系列文章的同学应该能一眼看出，这就是网关的工作模式，你家几百块的路由器主要干的就是这个工作。&lt;/p&gt;&lt;h4&gt;为什么性能开销比 Kong 低&lt;/h4&gt;&lt;p&gt;我们可以看出，负载均衡器/网关只需要做两件事：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;建立两个五元组并关联&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改数据包的地址和端口，再将数据包发送出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这个操作在网络领域内被称作 NAT（网络地址转换）。&lt;/p&gt;&lt;p&gt;由于这个工作非常简单，其中大部分的工作都可以用专用硬件来解决：例如开发专门的五元组存储和关联芯片，开发专门的 NPU（网络数据包处理器）来进行快速数据修改。所以，家用路由器可以做到在 300 块终端售价的情况下实现超过 1Gbit/S 的 NAT 性能。&lt;/p&gt;&lt;h4&gt;Kong 网关需要建立“TCP 连接”&lt;/h4&gt;&lt;p&gt;Kong 网关需要真的和客户端“建立 TCP 连接”：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;三次握手建立连接&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对数据包进行排序、校验，收到心跳包需要回复&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要将这个 TCP 连接和一个进程/线程进行绑定：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;在收到数据以后，找出这个进程/线程，把数据发送给它&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等进程/线程回复以后，再找到该进程/线程对应的那个 TCP 连接，把数据发送出去&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;h4&gt;四层负载均衡（L4）和七层负载均衡（L7）&lt;/h4&gt;&lt;p&gt;在卖负载均衡的商业公司那里，应用网关也叫七层负载均衡，因为它工作在 OSI 七层网络模型的第七层，而我们讨论的工作在 IP 层的负载均衡叫四层负载均衡，工作在 OSI 七层网络模型的第四层。再看到 L4 L7 这两个词，你们就能一眼看穿它了，其实一点都不神秘。&lt;/p&gt;&lt;h3&gt;还记得我们的目标吗？一百万 QPS&lt;/h3&gt;&lt;p&gt;我们通过使用一个负载均衡器，可以完美抗下五万 QPS 的负载：一个 TCP 负载均衡器，下挂五个安装了 Kong 应用网关的虚拟机，再下挂 N 台虚拟机，无论是 PHP 语言还是 golang，都可以实现五万 QPS 的设计目标。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将着手突破普通 Linux 系统网络性能的上限：使用软件定义网络（SDN）替代百万人民币的负载均衡硬件，并最终搭建出一个能够支撑 200 Gbps 带宽的负载均衡集群。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;软件工程师需要了解的网络知识：从铜线到HTTP（三）—— TCP/IP https://lvwenhan.com/tech-epic/487.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;6W QPS（SSL TPS RSA 2048bit） https://www.nginx.com/resources/datasheets/nginx-plus-sizing-guide/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本系列文章已经汇总成开源技术书《PPHC》发布在 Github：https://github.com/johnlui/PPHC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d4806c47f947409bf1fdb92542466235</guid>
<title>分布式定时任务框架选型，写的太好了 ！</title>
<link>https://toutiao.io/k/uqhrn50</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.前言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.定时任务框架&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.分布式任务调度系统对比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.和quartz框架对比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5.综合对比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6.总结和结论&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;7.附定时任务的其他方案&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先思考下面几个业务场景的解决方案:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支付系统每天凌晨1点跑批，进行一天清算，每月1号进行上个月清算&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;电商整点抢购，商品价格8点整开始优惠&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;12306购票系统，超过30分钟没有成功支付订单的，进行回收处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;商品成功发货后，需要向客户发送短信提醒&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;“&lt;/p&gt;&lt;p&gt;类似的业务场景非常多，我们怎么解决？&lt;/p&gt;&lt;p&gt;”&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多业务场景需要我们某一特定的时刻去做某件任务，定时任务解决的就是这种业务场景。一般来说，系统可以使用消息传递代替部分定时任务，两者有很多相似之处，可以相互替换场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如，上面发货成功发短信通知客户的业务场景，我们可以在发货成功后发送MQ消息到队列，然后去消费mq消息，发送短信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在某些场景下不能互换：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间驱动/事件驱动：内部系统一般可以通过时间来驱动，但涉及到外部系统，则只能使用时间驱动。如怕取外部网站价格，每小时爬一次&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量处理/逐条处理：批量处理堆积的数据更加高效，在不需要实时性的情况下比消息中间件更有优势。而且有的业务逻辑只能批量处理。如移动每个月结算我们的话费&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实时性/非实时性：消息中间件能够做到实时处理数据，但是有些情况下并不需要实时，比如：vip升级&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统内部/系统解耦：定时任务调度一般是在系统内部，而消息中间件可用于两个系统间&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;2. 定时任务框架&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;单机&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;timer&lt;/strong&gt; ：是一个定时器类，通过该类可以为指定的定时任务进行配置。TimerTask类是一个定时任务类，该类实现了Runnable接口，缺点异常未检查会中止线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ScheduledExecutorService&lt;/strong&gt; ：相对延迟或者周期作为定时任务调度，缺点没有绝对的日期或者时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;spring定时框架&lt;/strong&gt; ：配置简单功能较多，如果系统使用单机的话可以优先考虑spring定时器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分布式&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Quartz&lt;/strong&gt; ：Java事实上的定时任务标准。但Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TBSchedule&lt;/strong&gt; ：阿里早期开源的分布式任务调度系统。代码略陈旧，使用timer而非线程池执行任务调度。众所周知，timer在处理异常状况时是有缺陷的。而且TBSchedule作业类型较为单一，只能是获取/处理数据一种模式。还有就是文档缺失比较严重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;elastic-job&lt;/strong&gt; ：当当开发的弹性分布式任务调度系统，功能丰富强大，采用zookeeper实现分布式协调，实现任务高可用以及分片，目前是版本2.15，并且可以支持云开发，这个我写了系列教程了，在码猿技术专栏公从号可以搜索阅读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Saturn&lt;/strong&gt; ：是唯品会自主研发的分布式的定时任务的调度平台，基于当当的elastic-job 版本1开发，并且可以很好的部署到docker容器上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;xxl-job&lt;/strong&gt; ：是大众点评员工徐雪里于2015年发布的分布式任务调度平台，是一个轻量级分布式任务调度框架，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;3. 分布式任务调度系统对比&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参与对比的可选系统方案：elastic——job （以下简称E-Job）与 xxx-job(以下简称X-Job)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目背景及社区力量&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：大众点评公司下员工许雪里、贡献者 3人; github有2470star、1015fork; QQ讨论群6个; 有登记在使用的超过40家公司; 文档齐全&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：当当网开源，贡献者17人; github有2524star、1015fork; QQ讨论群１个、源码讨论群１个; 有登记在使用的超过50家公司; 文档齐全; 有明确的发展计划&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;支持集群部署&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;X-Job：集群部署唯一要求为：保证每个集群节点配置（db和登陆账号等）保持一致。调度中心通过db配置区分不同集群。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行器支持集群部署，提升调度系统可用性，同时提升任务处理能力。集群部署唯一要求为：保证集群中每个执行器的配置项 xxl.job.admin.addresses/调度中心地址”保持一致，执行器根据该配置进行执行器自动注册等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;E-Job：重写Quartz基于数据库的分布式功能，改用Zookeeper实现注册中心&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作业注册中心：基于Zookeeper和其客户端Curator实现的全局作业注册控制中心。用于注册，控制和协调分布式作业执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多节点部署时任务不能重复执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：使用Quartz基于数据库的分布式功能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：将任务拆分为n个任务项后，各个服务器分别执行各自分配到的任务项。一旦有新的服务器加入集群，或现有服务器下线，elastic-job将在保留本次任务执行不变的情况下，下次任务开始前触发任务重分片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;日志可追溯&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：支持，有日志查询界面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：可通过事件订阅的方式处理调度过程的重要事件，用于查询、统计和监控。Elastic-Job目前提供了基于关系型数据库两种事件订阅方式记录事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;监控告警&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;X-Job：调度失败时，将会触发失败报警，如发送报警邮件。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;E-Job：通过事件订阅方式可自行实现&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作业运行状态监控、监听作业服务器存活、监听近期数据处理成功、数据流类型作业（可通过监听近期数据处理成功数判断作业流量是否正常,如果小于作业正常处理的阀值，可选择报警。）、监听近期数据处理失败（可通过监听近期数据处理失败数判断作业处理结果，如果大于0，可选择报警。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;弹性扩容缩容&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：使用Quartz基于数据库的分布式功能，服务器超出一定数量会给数据库造成一定的压力&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：通过zk实现各服务的注册、控制及协调&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;支持并行调度&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：调度系统多线程（默认10个线程）触发调度运行，确保调度精确执行，不被堵塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：采用任务分片方式实现。将一个任务拆分为n个独立的任务项，由分布式的服务器并行执行各自分配到的分片项。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;高可用策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：“调度中心”通过DB锁保证集群分布式调度的一致性, 一次任务调度只会触发一次执行；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：调度器的高可用是通过运行几个指向同一个ZooKeeper集群的Elastic-Job-Cloud-Scheduler实例来实现的。ZooKeeper用于在当前主Elastic-Job-Cloud-Scheduler实例失败的情况下执行领导者选举。通过至少两个调度器实例来构成集群，集群中只有一个调度器实例提供服务，其他实例处于”待命”状态。当该实例失败时，集群会选举剩余实例中的一个来继续提供服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;失败处理策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job：调度失败时的处理策略，策略包括：失败告警（默认）、失败重试；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job：弹性扩容缩容在下次作业运行前重分片，但本次作业执行的过程中，下线的服务器所分配的作业将不会重新被分配。失效转移功能可以在本次作业运行中用空闲服务器抓取孤儿作业分片执行。同样失效转移功能也会牺牲部分性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动态分片策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;X-Job：分片广播任务以执行器为维度进行分片，支持动态扩容执行器集群从而动态增加分片数量，协同进行业务处理；在进行大数据量业务操作时可显著提升任务处理能力和速度。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行器集群部署时，任务路由策略选择”分片广播”情况下，一次任务调度将会广播触发对应集群中所有执行器执行一次任务，同时传递分片参数；可根据分片参数开发分片任务；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;E-Job：支持多种分片策略，可自定义分片策略&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认包含三种分片策略：基于平均分配算法的分片策略、 作业名的哈希值奇偶数决定IP升降序算法的分片策略、根据作业名的哈希值对Job实例列表进行轮转的分片策略，支持自定义分片策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;elastic-job的分片是通过zookeeper来实现的。分片的分片由主节点分配，如下三种情况都会触发主节点上的分片算法执行：a、新的Job实例加入集群 b、现有的Job实例下线（如果下线的是leader节点，那么先选举然后触发分片算法的执行） c、主节点选举”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;4. 和quartz框架对比&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;调用API的的方式操作任务，不人性化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要持久化业务QuartzJobBean到底层数据表中，系统侵入性相当严重。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调度逻辑和QuartzJobBean耦合在同一个项目中，这将导致一个问题，在调度任务数量逐渐增多，同时调度任务逻辑逐渐加重的情况加，此时调度系统的性能将大大受限于业务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Quartz关注点在于定时任务而非数据，并无一套根据数据处理而定制化的流程。虽然Quartz可以基于数据库实现作业的高可用，但缺少分布式并行调度的功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;5. 综合对比&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.05712319339298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLEPwJRAUeujG1lMc9wfEj9WfY6GZvahzichQ3XnvNzcs9W8YrgywuIwHdZK4MMdngze5XKshsWgNZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1453&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;6. 总结和结论&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;共同点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job和X-job都有广泛的用户基础和完整的技术文档，都能满足定时任务的基本功能需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;X-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;E-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;7. 附定时任务的其他方案&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;发货后超过10天未收货时系统自动确认收货的多种实现方式：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每天定时半夜筛选第二天 可以自动确认收货的订单,然后第二天 每10分钟 执行一次确认收货 开销不会太大吧 时间也相对精确&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动确认收货这个状态如果仅仅是让客户端看的话，等用户下一次上线的时间，做一次运算就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;延迟和定时消息投递&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ActiveMQ提供了一种broker端消息定时调度机制。适用于：1、不希望消息马上被broker投递出去，而是想要消息60秒以后发给消费者，2、想让消息没隔一定时间投递一次，一共投递指定的次数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter。利用DLX，当消息在一个队列中变成死信后，它能被重新publish到另一个Exchange。这时候消息就可以重新被消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天就分享到这里。希望对你有所帮助！&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;转载自：https://blog.csdn.net/Moonxiyue/article/details/125147094&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cac1419b70cb87fee0d22a9132ee7c31</guid>
<title>从实现到原理，聊聊 Java 中的 SPI 动态扩展</title>
<link>https://toutiao.io/k/x9omrl4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;八股文背多了，相信大家都听说过一个词，&lt;strong&gt;SPI扩展&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的面试官就很喜欢问这个问题，&lt;strong&gt;SpringBoot的自动装配是如何实现的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上，你一说是基于spring的SPI扩展机制，再把&lt;code&gt;spring.factories&lt;/code&gt;文件和&lt;code&gt;EnableAutoConfiguration&lt;/code&gt;提一下，那么这个问题就答的八九不离十了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像四五年前，我去面试的时候被问到这个问题，&lt;strong&gt;SPI动态扩展机制&lt;/strong&gt;这几个词从嘴里一说出来，就把面试官唬的一愣一愣的。可能他们也没见过这么能装逼的，一句话能简简单单说明白，非要拽一个听上去很高大上的词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话说回来，被唬住的可不止是面试官，其实还有我自己。至于SPI扩展究竟是个啥，是怎么实现的，我当时也根本不明白。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过现在的面试就是这样，对线八股文，要想唬住面试官，就得先唬住自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们今天暂且不提spring的SPI扩展，先来看看java本身自带的SPI扩展机制是怎么一回事。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SPI的全称是&lt;code&gt;Service Provider Interface&lt;/code&gt;，翻译过来就是&lt;strong&gt;服务提供者的接口&lt;/strong&gt;，它所实现的其实是一种服务的发现机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说起来可能还是有点不好理解，我举个例子来类比一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring项目中，写service层代码前，会约定俗成的会添加一个接口层。然后通过spring中的依赖注入，可以借助&lt;code&gt;@Autowired&lt;/code&gt;等方式注入这个接口的实现类的实例对象，之后对于service的调用一般也基于接口操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单形容就是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.569620253164557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvsQXtFUib1xJNic4PaV02N4RkhlZClwoIA8JKJkmIt4VeQRf8w3Ipue8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，接口、实现类都是由服务提供方提供，我们可以把controller看作服务调用者，调用方只管调用接口就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然也有声音认为，大部分情况下service只有一个实现类，接口层显得有些多余。但是在《Head First Design Patterns》这本书中，大佬们还是建议过：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Program to an interface, not an implementation.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，就是常说的&lt;strong&gt;要面向接口编程&lt;/strong&gt;。至于好处，也不外乎是降低耦合度、方便日后扩展、提高了代码的灵活性和可维护性等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这个例子里，这个接口层和其中的方法我们可以称之为&lt;strong&gt;API&lt;/strong&gt;，而我们要讨论的&lt;strong&gt;SPI&lt;/strong&gt;和它相比，有类似也有差异，还是先看图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5540355677154583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvncqKicLHDvfeVsq4WkkUqDl3qc9iceQNmRMHQnN1Ka1RDV20ltwMmwHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;731&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，就是服务的调用方定义一个接口规范，可以由不同的服务提供者实现。并且，调用方能够通过某种机制来发现服务提供方，并通过接口调用它的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过对比，我们可以看出它们虽然都有着&lt;strong&gt;接口&lt;/strong&gt;这一层面，但还是有很大的不同：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API中的接口是服务提供者给服务调用者的一个功能列表，而SPI中更多强调的是，服务调用者对服务实现的一种约束，服务提供者根据这种约束实现的服务，可以被服务调用者发现。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，Java中的SPI实现的就是，你按我的接口规范实现服务，我就能通过某种机制为这个接口寻找到这个服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说起来可能还有些抽象，下面我们举一个例子，类比具体描述一下这个过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、定义接口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起智能家居系统，大家现在都比较熟悉了，只要是相同品牌下的产品，连上wifi就能够通过手机app控制了，非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然产品不断更新换代，型号更新层出不穷，但是同种家电在app上操作起来，功能一般都是一样的。就拿空调来说，我们在app上操作起来一般也就三个主要功能：&lt;strong&gt;开关&lt;/strong&gt;，&lt;strong&gt;选模式&lt;/strong&gt;，&lt;strong&gt;调节温度&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我现在在客厅、卧室、书房安装了3款不同型号的空调，并把它们都接入到了我app中，那么之后的操作都是相同的几个按键，简单粗暴。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0044444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvxlScQERnvm4oEuDerMyhic9faUia6bFDysgEkDfggrIyYQZMwlV4OunQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考一下，无论是开关还是调温，都是通过app去调用设备的接口罢了，那么如果不同型号的空调各写各的接口，后端app在开发的时候光对接接口都麻烦的要死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方法也很简单，我先定义一套接口规范，不管你以后什么型号的空调，都按我的规范来实现接口。以后只要我能发现你的设备，那么都可以按相同的方法来调用接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么下面就先来定义这么一套接口规范，如果你以后想要接入智能家居系统，那么就要遵循这个规范来开发接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个项目作为标准，就叫&lt;code&gt;aircondition-standard&lt;/code&gt;好了，然后创建一个接口。除了3个操作以外，我们再添加一个获取空调型号的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 获取型号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 开关&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 调节温度&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; temperature)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 模式变更&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; modelId)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口后面要给服务的实现方来使用，用maven把它打成jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mvn clean install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后服务提供者在项目中就可以引入这个jar包了，有了这套规范，就保证了产品后期不管怎么更新换代，都能接入到系统来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、服务实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;制定并发布完规则后，&lt;strong&gt;挂式空调&lt;/strong&gt;作为第一个服务提供者就来了，新建一个项目&lt;code&gt;aircondition-hanging-type&lt;/code&gt;，并引入刚才打好的jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-standard&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建服务类，并实现前面定义的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HangingTypeAircondition&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;HangingType&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调开关&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调调节温度&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;挂式空调更换模式&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目的&lt;code&gt;resources&lt;/code&gt;的目录下，创建&lt;code&gt;META-INF/services&lt;/code&gt;目录，然后以前面定义的接口名&lt;code&gt;com.cn.hydra.IAircondition&lt;/code&gt;创建文件，并在文件中写入实现类的全限定名。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.cn.hydra.HangingTypeAircondition&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个项目结构非常简单：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgveHdCpm2HIKiaO6icEPnuL6CrkPbqr3AsqEwIOXOgN9dr0RIrgg7c7mGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;960&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，一个服务方的简单实现就搞定了，用maven打成jar包，之后就可以提供给调用方使用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，我们可以再创建一个&lt;strong&gt;立式空调&lt;/strong&gt;的项目&lt;code&gt;aircondition-vertical-type&lt;/code&gt;，也只创建一个服务类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;VerticalTypeAircondition&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IAircondition&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;VerticalType&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOnOff&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调开关&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;adjustTemperature&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调调节温度&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;changeModel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;立式空调更换模式&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是按上面的命名规则，创建一个配置文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;com.cn.hydra.VerticalTypeAircondition&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，打成jar包就完事了，至于服务调用者如何去发现和调用这两个服务，下面详细再说。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、服务发现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在两个服务提供方都实现了接口，下面关键的一步就是服务发现，这一步java中的spi发现机制已经帮我们实现好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新项目&lt;code&gt;aircondition-app&lt;/code&gt;，引入上面打好的两个jar包。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-hanging-type&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.cn.hydra&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;aircondition-vertical-type&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上面的说法，虽然每个服务提供者对于接口都有不同的实现，但是作为调用者来说，它并不需要关心具体的实现类，我们要做的是通过接口来调用服务提供者实现的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，就是关键的服务发现环节，我们写一个方法，根据型号去调用对应空调的开关方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AirconditionApp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; AirconditionApp().turnOn(&lt;span&gt;&quot;VerticalType&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;turnOn&lt;/span&gt;&lt;span&gt;(String type)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        ServiceLoader&amp;lt;IAircondition&amp;gt; load = ServiceLoader&lt;br/&gt;                .load(IAircondition&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (IAircondition iAircondition : load) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;检测到:&quot;&lt;/span&gt;+iAircondition.getClass().getSimpleName());&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (type.equals(iAircondition.getType())){&lt;br/&gt;                iAircondition.turnOnOff();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38996763754045305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvYBqibxHMVIqx42OIMadPlpEnmEeUrKoEtibrMlZiaeyRoT02eDH6Z2BAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，测试过程中，通过定义的接口&lt;code&gt;IAircondition&lt;/code&gt;发现了两个实现类，并通过参数，调用了特定实现类的某个方法。整段代码中没有出现过具体的服务实现类，操作都是通过接口调用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了spi的工作流程，我们再来看看它的实现，其实最关键的就是上面代码中出现的&lt;code&gt;ServiceLoader&lt;/code&gt;这个类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例代码中，对于&lt;code&gt;ServiceLoader&lt;/code&gt;的&lt;code&gt;load()&lt;/code&gt;方法的结果，我们用&lt;code&gt;for&lt;/code&gt;循环进行了遍历，这一点我们看一下源码就能明白，因为&lt;code&gt;ServiceLoader&lt;/code&gt;实现了&lt;code&gt;Iterable&lt;/code&gt;这一接口，而整个服务发现的核心，就在它的&lt;code&gt;iterator()&lt;/code&gt;方法中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7875457875457875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvdUlKNx3BzhJ2pv9XwI01QibpNSffOFWSHmYpaic8XJUkzVonrX39rN7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里面有两个关键的东西，找一下在源码中定义的地方：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3041018387553041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvE0VBUWsoZBLPtbbnMYAEzeIrvRZobcicssFXVTwELSL08GMgfR0C3UA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释写的非常明白，&lt;code&gt;providers&lt;/code&gt;就是一个缓存，在迭代器中如果先从这里面进行查找，如果里面有就继续往下找，没有了的话就用这个懒加载的&lt;code&gt;lookupIterator&lt;/code&gt;查找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就简单了，接着往下看&lt;code&gt;LazyIterator&lt;/code&gt;，看看它里面的&lt;code&gt;hasNext()&lt;/code&gt;和&lt;code&gt;next()&lt;/code&gt;两个方法是怎么实现的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7274939172749392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvAP4huniaR59K63vBeUib5IH6qb6jtMHfzMzAcRDF16Mhz17J5dWYgsWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;code&gt;acc&lt;/code&gt;是一个安全管理器，在前面通过&lt;code&gt;System.getSecurityManager()&lt;/code&gt;判断并赋值，debug看一下这里都是&lt;code&gt;null&lt;/code&gt;，所以直接看&lt;code&gt;hasNextService()&lt;/code&gt;和&lt;code&gt;nextService()&lt;/code&gt;方法就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;hasNextService()&lt;/code&gt;方法中，会取出接口取出实现类的类名放到&lt;code&gt;nextName&lt;/code&gt;中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5337124289195776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvIMlNdWpAIiam0JdBV8qibErZ92LXKd1SX63XpGVomaSXqQnmic7nicSaaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1231&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，在&lt;code&gt;nextService()&lt;/code&gt;方法中，则会先加载这个实现类，然后实例化对象，最终放入缓存中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.54911131898971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvAiaW8tAn7dwe1IIg1RrQOoQb52FtG5T4m5n956kQjcibkeHbRicMNxVJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1069&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在迭代器的迭代过程中，会完成所有实现类的实例化，其实归根结底，还是基于java反射去实现的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6、应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说spi的实际应用，大家最常见的应该就是日志框架&lt;code&gt;slf4j&lt;/code&gt;了，它利用spi实现了插槽式接入其他具体的日志框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，&lt;code&gt;slf4j&lt;/code&gt;本身就是个日志门面，并不提供具体的实现，需要绑定其他具体实现才能真正的引入日志功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如我们可使用&lt;code&gt;log4j2&lt;/code&gt;作为具体的绑定器，只需要在pom中引入&lt;code&gt;slf4j-log4j12&lt;/code&gt;，就可以使用具体功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;slf4j-log4j12&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.3&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入项目后，点开它的jar包看一下具体结构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5280701754385965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgvxMMqIrpO7wlicS3DSMr9WcHGXY9kunxXEqc5RgaPANJv7rZdHm3gAzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有发现一个彩蛋，先说为什么我们pom中引入的明明是&lt;code&gt;slf4j-log4j12&lt;/code&gt;，实际上引入的是&lt;code&gt;slf4j-reload4j&lt;/code&gt;？翻一下官网的文档：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3105196451204056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZUOEzJAic3O79nCyjV9pzgviaXF5VXaPPpfWPQ7QU8AGrdHl3k52AjRGibsTXS6jSysdVvI4Y0SmoYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大意就是在2015年和2022年，&lt;code&gt;log4j1.x&lt;/code&gt;就已经宣布&lt;code&gt;end of life&lt;/code&gt;终止了，原因也不难猜，估计是因为频繁爆出的漏洞。在那之后，&lt;code&gt;slf4j-log4j&lt;/code&gt;在构建阶段就会自动重定向到&lt;code&gt;slf4j-reload4j&lt;/code&gt;了，并且官方也强烈建议使用&lt;code&gt;slf4j-reload4j&lt;/code&gt;作为替代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回头看一下jar包的&lt;code&gt;META-INF.services&lt;/code&gt;里面，通过spi注入了&lt;code&gt;Reload4jServiceProvider&lt;/code&gt;这个实现类，它实现了&lt;code&gt;SLF4JServiceProvider&lt;/code&gt;这一接口，在它的初始化方法&lt;code&gt;initialize()&lt;/code&gt;中，会完成初始化等工作，后续可以继续获取到&lt;code&gt;LoggerFactory&lt;/code&gt;和&lt;code&gt;Logger&lt;/code&gt;等具体日志对象。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7、总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中的SPI提供了一种比较特别的服务发现和调用机制，通过接口灵活的将服务调用与服务提供者分离，用于提供给第三方实现扩展时还是很方便的。但是也有缺点，比方说一旦加载一个接口，就会把所有实现类都加载进来，可能会加载到不需要的冗余服务。不过站在整体角度上，还是给我们提供了一种非常不错的框架扩展、集成的思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这次的分享就到这里，我是Hydra，我们下篇再见。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f080f8861e2e9be746ff6c13a2c6ad9</guid>
<title>如何从 0 开始搭建 Vue 组件库</title>
<link>https://toutiao.io/k/i15vxw7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东零售 陈艳春&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;组件设计是通过对功能及视觉表达中元素的拆解、归纳、重组，并基于可被复用的目的，形成规范化的组件，通过多维度组合来构建整个设计方案，將这些组件整理在一起，便形成组件库。本文我们主要讲述基于Vant CLI的自建组件库。Vant CLI 是一个基于 Vite 实现的 Vue 组件库构建工具，通过 Vant CLI 可以快速搭建一套功能完备的 Vue 组件库。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;建立组件库的意义&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;首先组件库可以给我们降本提效，其次可以保持视觉风格统一以及交互一致，可以帮助我们快速构建使用场景，便于多个项目后续迭代升级 。&lt;/p&gt;

&lt;p&gt;视觉风格统一以及交互的一致性，可以减少用户学习成本培养用户习惯，让产品拥有良好的用户体验。比如一个四级地址的选择组件，在整个产品中应该就一种交互方式，如果一会是滚动选择，一会是点击选择，会让用户操作起来比较烦躁，统一交互可以减少用户学习成本。&lt;/p&gt;

&lt;p&gt;新产品上线后，还需要不断的去完善，在迭代过程中可能会新增其他功能，这时候我们就可以只修改组件库一套代码，所有不同项目相同组件就可以达到了迭代升级的效果。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;如何创建组件库&lt;/strong&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;strong&gt;一、梳理组件清单&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;首先梳理出项目中样式相同的模块，和产品讨论未来会有哪些规划，现有的组件是否能够满足需求，是否需要补充设计方案，清单整理完毕后，将每一个组件建成一个独立任务，像日常需求那样，方便随时更新使用。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、场景整合&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;把自己变成产品的深度用户，把现有线上产品完整体验一遍，绘制用户行为路径，并和需求方沟通了解后续计划，将组件的所有的当前/潜在应用场景总结出来，尽可能不遗漏场景。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、组件库框架选型&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;看了开源的 Vue3 组件库，总结了一些前端目前流行的趋势，列出来多个版本和框架的，本文只讨论 Vue3 版本。&lt;/p&gt;

&lt;p&gt;1.element-plus - 经典中的经典，全面支持 Vue 3&lt;/p&gt;

&lt;p&gt;2.tdesign-vue-next - 鹅厂优质 UI 组件，配套工具完满，设计工整，文档清晰&lt;/p&gt;

&lt;p&gt;3.arco-design-vue- 字节跳动开源 UI 组件库，大厂逻辑，设计文档完美&lt;/p&gt;

&lt;p&gt;4.ant-design-vue - 蚂蚁前端 UI 库，面向企业级中后台&lt;/p&gt;

&lt;p&gt;5.naive-ui - 宝藏 Vue UI 库，Vue UI 新星，从 Vue 3 起步&lt;/p&gt;

&lt;p&gt;6.vant - 有赞团队开源移动 UI 组件库，全面支持 Vue 3&lt;/p&gt;

&lt;p&gt;7.nutui - 京东出品，移动端友好，面向电商业务场景&lt;/p&gt;

&lt;p&gt;8.vuetify - 老牌 Vue UI ，基于谷歌的 Material Design 样式开发&lt;/p&gt;

&lt;p&gt;9.varlet - Varlet 是一个基于 Vue3 开发的 Material 风格移动端组件库，全面拥抱 Vue3 生态，由社区建立起来的组件库团队进行维护。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;四、组件库搭建&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;我们以Vant CLI为例来详细剖析具体搭建过程:&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;（1）首先确保本地node版本^12.13.0 || ^14.15.0 || &amp;gt;=16.0.0&lt;/strong&gt;&lt;/h4&gt;

&lt;h4&gt;&lt;strong&gt;（2）执行以下命令可以快速创建一个基于 Vant CLI 的项目&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;yarn create vant-cli-app
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（3）手动安装&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# 通过 npm
npm i @vant/cli -D

# 通过 yarn
yarn add @vant/cli -D

# 通过 pnpm
pnpm add @vant/cli -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（4）手动配置&lt;/strong&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;{
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;vant-cli dev&quot;,
    &quot;test&quot;: &quot;vant-cli test&quot;,
    &quot;lint&quot;: &quot;vant-cli lint&quot;,
    &quot;build&quot;: &quot;vant-cli build&quot;,
    &quot;prepare&quot;: &quot;husky install&quot;,
    &quot;release&quot;: &quot;vant-cli release&quot;,
    &quot;build-site&quot;: &quot;vant-cli build-site&quot;
  },
  &quot;nano-staged&quot;: {
    &quot;*.md&quot;: &quot;prettier --write&quot;,
    &quot;*.{ts,tsx,js,vue,less,scss}&quot;: &quot;prettier --write&quot;,
    &quot;*.{ts,tsx,js,vue}&quot;: &quot;eslint --fix&quot;
  },
  &quot;eslintConfig&quot;: {
    &quot;root&quot;: true,
    &quot;extends&quot;: [&quot;@vant&quot;]
  },
  &quot;prettier&quot;: {
    &quot;singleQuote&quot;: true
  },
  &quot;browserslist&quot;: [&quot;Chrome &amp;gt;= 51&quot;, &quot;iOS &amp;gt;= 10&quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;（5）本地启动&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;npm run dev启动项目，页面如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b370cbd3f56e4848b0b5410705065f02%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注：介绍、快速上手、定制主题、编码规范、开发指南是根据自己组内的规范编写。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;（6）如何开发组件库&lt;/strong&gt;&lt;/h4&gt;

&lt;h5&gt;&lt;strong&gt;目录结构&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;•仓库的组件代码位于 src 下，每个组件一个文件夹&lt;/p&gt;

&lt;p&gt;•docs 目录下是文档网站的代码，本地开发时可以在目录下运行 npm run dev 开启文档网站&lt;/p&gt;

&lt;p&gt;项目主要目录如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;m-tetris
├─ build     # 构建
├─ docs      # 文档
├─ es        # 打包
├─ lib       # 打包
├─ site      # 静态站点资源
├─ src       # 组件
├─ test      # 单测
└─ static    # 图片等资源
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;strong&gt;添加新组件&lt;/strong&gt;&lt;/h5&gt;

&lt;p&gt;添加新组件时，请按照下面的目录结构组织文件，并在 &lt;code&gt;vant.config.js&lt;/code&gt; 中配置组件名称。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;src
└─ button
   ├─ demo             # 示例代码
   ├─ test             # 单元测试
   ├─ index.vue        # 组件入口
   ├─ index.less       # 组件样式
   └─ README.md        # 组件文档说明
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;strong&gt;本地测试&lt;/strong&gt;&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;# 打包,生成lib es文件夹
npm run build

# 生成压缩包
npm pack

# 在项目中安装测试包
npm install 压缩包的绝对路径（例如：/Users/用户名/work/XXX/XXX.0.tgz）
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;五、如何发布到公司npm私服或者npm官网&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;所有公司内网用户都能够发布包到 jnpm 库。&lt;/p&gt;

&lt;p&gt;如果你之前没有发布包的经验，请先查看 npm 官方文档 &lt;a href=&quot;https://docs.npmjs.com/cli/publish&quot;&gt;npm publish&lt;/a&gt; 。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 拉取最新的master
# 构建npm包
npm run build

# 登录（如已登录，请忽略）
npm login

# 发布
# 如果是公司私服、请保证源是公司源
npm publish
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;&lt;strong&gt;六、如何在项目中使用组件&lt;/strong&gt;&lt;/h3&gt;

&lt;h4&gt;&lt;strong&gt;方式一. 自动按需引入组件 (推荐)&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;﻿&lt;a href=&quot;https://github.com/ant-design/babel-plugin-import&quot;&gt;babel-plugin-import&lt;/a&gt; 是一款 babel 插件，它会在编译过程中将 import 的写法自动转换为按需引入的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 安装插件
npm i babel-plugin-import -D
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 在.babelrc 中添加配置
// 注意：webpack 1 无需设置 libraryDirectory
{
  &quot;plugins&quot;: [
    [&quot;import&quot;, {
      &quot;libraryName&quot;: &quot;xxx-vant&quot;,
      &quot;libraryDirectory&quot;: &quot;es&quot;,
      &quot;style&quot;: true
    }]
  ]
}

// 对于使用 babel7 的用户，可以在 babel.config.js 中配置
module.exports = {
  plugins: [
    [&#x27;import&#x27;, {
      libraryName: &#x27;xxx-vant&#x27;,
      libraryDirectory: &#x27;es&#x27;,
      style: true
    }, &#x27;xxx-vant&#x27;]
  ]
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// 接着你可以在代码中直接引入 xxx-vant 组件
// 插件会自动将代码转化为方式二中的按需引入形式
import { IndexBar } from &#x27;xxx-vant&#x27;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;方式二. 手动按需引入组件&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;在不使用插件的情况下，可以手动引入需要的组件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Button from &#x27;xxx-vant/lib/index-bar&#x27;;
import &#x27;xxx-vant/lib/index-bar/style&#x27;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;&lt;strong&gt;方式三. 导入所有组件&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;xxx-vant 支持一次性导入所有组件，引入所有组件会增加代码包体积，因此不推荐这种做法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Vue from &#x27;vue&#x27;;
import Jdxxx from &#x27;xxx-vant&#x27;;
import &#x27;xxx-vant/lib/index.css&#x27;;

Vue.use(Jdxxx);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;﻿  &lt;/p&gt;

&lt;p&gt;参考资料：vant-cli官网：&lt;a href=&quot;https://github.com/youzan/vant/blob/HEAD/packages/vant-cli/README.zh-CN.md&quot;&gt;https://github.com/youzan/vant/blob/HEAD/packages/vant-cli/README.zh-CN.md&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>