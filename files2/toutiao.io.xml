<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>918a4d9af9cbfe26d964101677cf50f9</guid>
<title>八万字开源图书《高并发的哲学原理》第一章 -- 找出单点，进行拆分</title>
<link>https://toutiao.io/k/04odf6a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h3&gt;本文共 3800 字，阅读大约需要 12 分钟。&lt;/h3&gt;&lt;hr/&gt;&lt;h3&gt;人列计算机&lt;/h3&gt;&lt;p&gt;《三体》中，刘慈欣设计了一个用人进行二进制运算的计算机，使用了三千万名士兵(晶体管)：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6137171286425018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA1QcMpmiaoxTbiadicR3OzkffeN0BWV6yZDmTw8h607EHdiaXEay5ria0hM5R3cAGb9wzTlY7F8xC8nNpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2814&quot;/&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;挥舞旗帜进行二进制运算&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用三个士兵来组成与门、或门、与非门、或非门、异或门、同或门和三态门，又用两个士兵组成了非门&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将这些基本部件组合起来，构成了计算阵&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;内存：由文化程度较高的人组成，每个人挥舞多个颜色的旗帜，可以替代 20 个挥舞单色旗帜的人&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;硬盘：三百万文化程度较高的人（据说是上次坑儒留下来的）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;显示阵列：至少配有红色和绿色像素单元（双色显示阵列）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;维护部件：一组骑兵&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;传输信号&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理“故障”士兵&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由秦始皇最精锐的骑兵团构成&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;维护方式：更换出错部件&lt;/p&gt;&lt;/li&gt;&lt;h4&gt;一提到高并发，很多人的第一反应都可以归纳为以下两种情况：&lt;/h4&gt;&lt;h4&gt;1. 进程间通信(IPC)、共享内存、管道、队列、事件：这是学院派&lt;/h4&gt;&lt;h4&gt;2. 内存缓存、消息队列、分库分表、NoSQL、ES 搜索：这是实战派&lt;/h4&gt;&lt;p&gt;其实，高并发之路，无论是学院派还是实战派，甚至是刘慈欣设计的人列计算机，其背后的哲学原理都是一样的。如果你问人列计算机和高并发有什么关系？按照上面的设计，最多一万名士兵就够了，为什么需要三千万呢？还不是为了提高性能。&lt;/p&gt;&lt;p&gt;其实，高并发的哲学原理早就隐藏在了现代计算机的基础结构之中，感兴趣的欢迎去看我的《性能之殇（二）-- 分支预测、流水线与多核 CPU》¹。&lt;/p&gt;&lt;h2&gt;本文目标&lt;/h2&gt;&lt;p&gt;上面的只是我的喃喃私语，下面我们进入正题。&lt;/p&gt;&lt;p&gt;本文的目标是在我有限的认知范围内，讨论一下高并发问题背后隐藏的一个哲学原理。我们将从动静分离讲起，一步步深入 Apache、Nginx、epoll、虚拟机、k8s、异步非阻塞、协程、应用网关、L4/L7 负载均衡器、路由器(网关)、交换机、LVS、软件定义网络(SDN)、Keepalived、DPDK、ECMP、全冗余架构、用户态网卡、集中式存储、分布式存储、PCI-E 5.0、全村的希望 CXL、InnoDB 三级索引、内存缓存、KV 数据库、列存储、内存数据库、Shared-Nothing、计算存储分离、Paxos、微服务架构、削峰、基于地理位置拆分、高可用等等等等。并最终基于地球和人类社会的基本属性，设计出可以服务地球全体人类的高并发架构。&lt;/p&gt;&lt;p&gt;先说结论，这个哲学原理就是：&lt;code&gt;找出单点，进行拆分&lt;/code&gt;。&lt;/p&gt;&lt;h2&gt;准备工作&lt;/h2&gt;&lt;h3&gt;性能问题要靠架构解决&lt;/h3&gt;&lt;p&gt;在展开这个哲学原理前，我们需要先明确一下高并发问题的解决思路：性能问题要靠架构解决。&lt;/p&gt;&lt;p&gt;首先，在架构上动刀是最简单的，也是最容易获得收益的。其次，即便是真的去做单个资源的性能优化，例如 MySQL 单机性能优化(软件优化)、x86 CPU 多核性能提升(硬件优化)，拆到微观来看，也是在做架构优化：&lt;/p&gt;&lt;p&gt;&lt;code&gt;没有银弹&lt;/code&gt;就是计算机世界的第一准则，你想获得收益，总得拿出一些东西，和&lt;code&gt;信息之神&lt;/code&gt;交换。&lt;/p&gt;&lt;h3&gt;我们讨论“哪个”高并发？&lt;/h3&gt;&lt;p&gt;本文讨论的是“web 服务高并发”问题，典型场景为电商秒杀：同一个时刻，数万人抢同一个低价商品，会给系统的每一个层面都造成显著的性能瓶颈，这种场景的集大成者，就是每年的双 11。&lt;/p&gt;&lt;h2&gt;一个小目标&lt;/h2&gt;&lt;p&gt;&lt;code&gt;找出单点，进行拆分&lt;/code&gt;，就是将每一个大单点都拆成一个小单点+多资源并行的形式。&lt;/p&gt;&lt;p&gt;在解决高并发问题的过程中，我们会不断地遇到新的单点：web server、单个操作系统、虚拟化/容器技术、编程语言运行架构、网络、UNIX 进程模型、数据库等。每遇到一个单点，我们都要见招拆招，使用&lt;code&gt;架构&lt;/code&gt;工具拆掉它。计算机的虚拟化程度非常高，几乎每个单点都可以继续往下拆。&lt;/p&gt;&lt;p&gt;接下来大家就跟着我一起，一步一步将系统性能的上限从单机 100 QPS 提升到 1,000,000（一百万）QPS。&lt;/p&gt;&lt;h3&gt;文章列表&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;找出单点，进行拆分（本文）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Apache 的性能瓶颈与 Nginx 的性能优势&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基础设施并发：虚拟机与 Kubernetes（k8s）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;隐藏在语言背后的魔鬼：运行架构为何会成为性能瓶颈&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拆分网络单点(上)：应用网关、负载均衡和路由器(网关)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;拆分网络单点(下)：SDN 如何替代百万人民币的负载均衡硬件(网关、LVS、交换机)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最难以解决的单点：数据库以及它背后的存储&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将 InnoDB 剥的一丝不挂：B+ 树与 Buffer Pool&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;细数四代分布式数据库并拆解 TiDB 和 OceanBase（主从、中间件、KV、计算与存储分离、列存储、CAP定理）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;理论无限容量：站在地球表面&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;找出第一个单点&lt;/h2&gt;&lt;p&gt;大部分系统都是从单个虚拟机开始的，原始的资源可能只有 1 核 2G，你安装了一个 Apache，一个 MySQL，把代码部署上去，这个系统就开始对外服务了。如果系统用户数量增加了，你会发现，CPU 满了，这个时候，我们第一个应该拆的就是静态流量。&lt;/p&gt;&lt;h3&gt;动静分离&lt;/h3&gt;&lt;p&gt;大概是在 2013 年，我用从同学那里买的二手 MacBook Pro 跑过 Apache 和 Nginx 的性能测试，在本机访问同一张 jpg 图片的情况下，Apache 的 QPS 为 2 万出头，而 Nginx 则超过 8 万，四倍性能。&lt;/p&gt;&lt;p&gt;所以，如果你还在用 Apache 承载所有流量，在前面加一个 Nginx 就能显著降低 CPU 占用率，大幅提升系统性能。如果你再利用云服务商把这些静态资源用 CDN 来承载，你的静态资源压力还能再降低 90%。&lt;/p&gt;&lt;p&gt;动静分离以后，CPU 又满了，该怎么办呢？这个时候就需要把数据库拆出去了。&lt;/p&gt;&lt;h3&gt;最适合独立部署的软件：数据库&lt;/h3&gt;&lt;p&gt;如果应用代码和数据库跑在一个系统上，压力稍微大一点，很容易出现“债股双杀”的局面：MySQL 的响应变慢，应用代码就需要更长时间的等待，又要消耗更多的 CPU 资源，从而形成“内卷”和“踩踏”。只要你的系统不是用户极其少，或者你们公司极其扣，把数据库独立部署的收益都是要高于投入的：1 核 2G 的虚拟机就够 MySQL 跑到 200 QPS了，配合缓存支撑一个日 PV 100 万的小系统应该够了。&lt;/p&gt;&lt;h3&gt;我的实际经验&lt;/h3&gt;&lt;h4&gt;进击的爬虫&lt;/h4&gt;&lt;p&gt;2017 年，我维护的一个 SEO 网站突然遭遇大量爬虫的袭击：由于这个网站拥有数百万个内容页面，页面内也有着大量的“类似文章推荐”，在只依靠 MySQL &lt;code&gt;like&lt;/code&gt;语句的情况下，单个页面的返回时间长达 300-500ms。一天两万的真实用户 UV 对系统的压力并不大，但这些爬虫不讲武德，上来就是 100 QPS，当时 1 核 2G 的虚拟机和 1 核 1G 的 MySQL 可遭了殃了，完全顶不住。&lt;/p&gt;&lt;p&gt;这些爬虫并不是正规大厂的爬虫，而是采集机器人，由于拥有海量代理 ip，对网站形成了 DDOS 态势，没法使用常规手段封禁，只能想办法抗住。&lt;/p&gt;&lt;p&gt;我首先做的，就是将静态资源全部 CDN 化，直接让 CPU 占用率降低了一半。然后就开始着手提升系统性能：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;使用 ElasticSearch 提供“类似文章推荐”，将每个页面的响应时间压缩到了 200ms&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;提升数据库性能：增加索引，增加 Redis 缓存，使用定时任务刷新文章总数而不是实时计算，将响应时间压缩到了 120ms&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问 ES 的 HTTP 请求进行并行化：虽然 PHP 是一种阻塞语言，但是一次性发送多个 HTTP 请求的能力还是有的，平均每个页面有五次请求，每次 15ms，并行化以后从 15ms*5 减少到了 25ms，最终将平均响应时间压缩到了 70ms&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;同时，服务器和数据库也进行了计算资源的扩容，增加到了 2 核 4G 的虚拟机和 2 核 4G 的 MySQL，最终顶住了每天 200 万次页面访问的冲击，对比之下，真实用户 PV 每天只有十万左右。&lt;/p&gt;&lt;p&gt;这个时候可能有人会问了，既然是内容网站，为什么不静态化呢？因为数据量太大了，500 万个页面，一个页面 100KB，就是 476GB 的磁盘容量，这个量级太夸张了，不如做性能优化硬抗了，这么多静态资源的管理和刷新反而是个更大的问题。在百万量级下，数据库绝对是更好的数据存储解决方案，远比自己管理文件要更简单更稳定。&lt;/p&gt;&lt;p&gt;即便我做了那么多，还是不乏有一些爬虫愣头青在学习了 swoole 和 go 协程之后，对我的网站发动数千 QPS 的死亡冲锋，这个时候再怎么性能优化都是没用的，这时就需要使用倒数第二个工具：限流。&lt;/p&gt;&lt;p&gt;我做了三道限流关卡才最终顶住采集机器人 DDOS：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;针对单个 ip 做请求频率限制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对整个 /24 ip 段做请求频率限制（很多爬虫采用同一段内的多个 ip 绕过限流）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;针对每个 UA 做请求频率限制&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这三板斧使出来以后，天下太平了，网站再也没有被突然发起的死亡冲锋搞挂过。&lt;/p&gt;&lt;p&gt;对了，既然限流是倒数第二个工具，肯定有人好奇最后一个工具是什么？那就是熔断，熔断属于系统鲁棒性工具，是善后用的，我们最后一篇文章还会再提一嘴。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将看到真实的 Apache 性能瓶颈与 Nginx 的性能优势，同时我会继续现身说法，讲述团购秒杀业务的故事。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;性能之殇（二）-- 分支预测、流水线与多核 CPU https://lvwenhan.com/tech-epic/493.html&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>77eadebd16da6e5606632b198d83f372</guid>
<title>优质网站同好者周刊（第 104 期） | 倾城博客</title>
<link>https://toutiao.io/k/0f7dz8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;&lt;code&gt;Markdown&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/component&quot;&gt;&lt;code&gt;component&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：mdx, markdown, jsx, oss, react&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;MDX allows you to use JSX in your markdown content. You can import components, such as interactive charts or alerts, and embed them within your content. This makes writing long-form content with components a blast.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/mdxjs.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Markdown for the component era | MDX&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mdxjs.com/&quot;&gt;MDX&lt;/a&gt; ，&lt;strong&gt;组件时代&lt;/strong&gt;的 &lt;a href=&quot;https://nicelinks.site/tags/Markdown&quot;&gt;Markdown&lt;/a&gt;，允许你在 markdown 内容中使用 JSX。您可以导入组件，例如交互式图表或警报，并将它们嵌入到您的内容中。这使得使用组件编写长篇内容成为一种乐趣。经过多年的努力，MDX 的第 2 版发布了，并且有很多改进。以下是亮点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;❤️&lt;strong&gt;强大&lt;/strong&gt;：MDX 融合了 markdown 和 JSX 语法，完美适合基于 JSX 的项目；&lt;/li&gt;&lt;li&gt;💻&lt;strong&gt;万物皆组件&lt;/strong&gt;：在您的 MDX 中使用现有组件并将其他 MDX 文件导入为组件；&lt;/li&gt;&lt;li&gt;🔧&lt;strong&gt;可定制&lt;/strong&gt;：决定为每个 Markdown 构造呈现哪个组件 ( &lt;code&gt;{h1: MyHeading}&lt;/code&gt;)；&lt;/li&gt;&lt;li&gt;📚&lt;strong&gt;Markdown-based&lt;/strong&gt; : Markdown 的简单和优雅仍然存在，你只在你想要的时候使用 JSX；&lt;/li&gt;&lt;li&gt;🔥 非常&lt;strong&gt;快&lt;/strong&gt;：MDX 没有运行时，所有编译都发生在构建阶段；&lt;/li&gt;&lt;li&gt;📝&lt;strong&gt;改进的语法&lt;/strong&gt;使得在 JSX 中使用 markdown 更容易；&lt;/li&gt;&lt;li&gt;🧑‍💻 JavaScript 表达式变成 &lt;code&gt;{2 * Math.PI}&lt;/code&gt; 6.283185307179586；&lt;/li&gt;&lt;li&gt;🔌 新的 esbuild、Rollup 和 Node.js 集成；&lt;/li&gt;&lt;li&gt;⚛️&lt;strong&gt;任何 JSX 运行时&lt;/strong&gt;：React、Preact、Vue、Emotion，应有尽有，它们都受支持&lt;/li&gt;&lt;li&gt;🌳 改进的 AST 可以更详细地公开更多信息；&lt;/li&gt;&lt;li&gt;🏃‍♀️ 编译速度至少提高 &lt;code&gt;25%&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;🚴 生成的代码运行速度是原来的两倍（快 &lt;code&gt;100%&lt;/code&gt;）；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Markdown 是一种轻量级标记语言（该文件后缀为 &lt;code&gt;.md&lt;/code&gt;），可用于将格式元素添加到纯文本文档，现在是世界上最流行的标记语言之一，Markdown 使在网络上写作变得快速和容易，任何人都能轻易学会。 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://mdxjs.com/&quot;&gt;MDX&lt;/a&gt; （结合了 Markdown 和 JSX）允许你在 markdown 内容中使用 JSX。对于诸如强调或标题之类的常见内容，Markdown 通常感觉比 HTML 或 JSX 更自然，Markdown 通常看起来更符合预期并且更简洁，而不是 HTML；在 Web 前端项目中，尤其文档类，可以让您的工作效率、开发体验更上一层楼。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;倾城之链 - Markdown for the component era | MDX&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/React&quot;&gt;&lt;code&gt;React&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%A1%86%E6%9E%B6&quot;&gt;&lt;code&gt;框架&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%BD%91%E7%AB%99%E7%94%9F%E6%88%90%E5%99%A8&quot;&gt;&lt;code&gt;网站生成器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Make beautiful websites with Next.js &amp;amp; MDX.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/nextra.site.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Nextra – Next.js Static Site Generator&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; ，基于 &lt;a href=&quot;https://nicelinks.site/post/61c928af5be6454b4e3d5146&quot;&gt;Next.js&lt;/a&gt; （ &lt;a href=&quot;https://nicelinks.site/post/5b1294b5e93ed2618cfac134&quot;&gt;React&lt;/a&gt; ） 和 &lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;MDX&lt;/a&gt; 的静态网站生成器，可制作漂亮的网站；它简单、强大和灵活的站点生成框架，包含您喜欢的 Next.js 的一切。Next.js，一个用于 生产环境的 React 框架，为您提供生产所需的所有功能的最佳开发人员体验：混合静态和服务器渲染、TypeScript 支持、智能捆绑、路由预取等。无需配置。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; 在 Next.js 基础上再封装，引入 &lt;a href=&quot;https://nicelinks.site/post/62989af00f40a860b1599de2&quot;&gt;pnpm&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/5fd20cb4c06d6302c1907ec7&quot;&gt;Tailwind CSS&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/63e4e3eee63ccd089dee6686&quot;&gt;MDX&lt;/a&gt;、&lt;a href=&quot;https://github.com/nextapps-de/flexsearch&quot;&gt;flexsearch&lt;/a&gt;、&lt;a href=&quot;https://nicelinks.site/post/635936a6775cbe1cdc6eb333&quot;&gt;Turbo&lt;/a&gt;、&lt;a href=&quot;https://shiki.matsu.io/&quot;&gt;Shiki&lt;/a&gt;（漂亮的语法高亮库）等，使得开发更加高效、便捷，而且对链接、图片、全文搜索、暗黑主题、多语言等做了优化，开箱即用。如果您有基于 React 搭建网站的诉求，推荐 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://nextra.site/&quot;&gt;Nextra&lt;/a&gt; 进入您首选考虑范畴。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e4db7ee63ccd089dee6599&quot;&gt;倾城之链 - Nextra – Next.js Static Site Generator&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Docker&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%80%E6%BA%90&quot;&gt;&lt;code&gt;开源&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AE%B9%E5%99%A8&quot;&gt;&lt;code&gt;容器&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Moby is an open-source project created by Docker to enable and accelerate software containerization.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/mobyproject.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Moby Project - a collaborative project for the container ecosystem to assemble container-based systems&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://mobyproject.org/&quot;&gt;Moby&lt;/a&gt; ，是 &lt;a href=&quot;https://nicelinks.site/tags/Docker&quot;&gt;Docker&lt;/a&gt; 创建的一个开放框架，用于组装专门的容器系统，而无需重新发明轮子。它提供了一个由数十个标准组件组成的“乐高集”，以及一个将它们组装到定制平台的框架。Moby 的核心是一个用于组装专用容器系统的框架，它提供：&lt;/p&gt;&lt;h3 id=&quot;成分components&quot;&gt;&lt;a href=&quot;#%E6%88%90%E5%88%86components&quot; aria-label=&quot;成分components permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;成分（Components）&lt;/h3&gt;&lt;p&gt;用于容器系统所有重要方面的容器化组件库：操作系统、容器运行时、编排、基础设施管理、网络、存储、安全、构建、图像分发等。&lt;/p&gt;&lt;p&gt;将组件组装成适用于各种平台和架构的可运行工件的工具：裸机（x86 和 Arm）；适用于 Linux、Mac 和 Windows 的可执行文件；适用于流行云和虚拟化提供商的 VM 映像。&lt;/p&gt;&lt;h3 id=&quot;组件assemblies&quot;&gt;&lt;a href=&quot;#%E7%BB%84%E4%BB%B6assemblies&quot; aria-label=&quot;组件assemblies permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;组件（Assemblies）&lt;/h3&gt;&lt;p&gt;一组参考程序集，可以按原样使用、修改或用作创建您自己的参考程序集的灵感。所有 Moby 组件都是容器，因此创建新组件就像构建新的 OCI 兼容容器一样简单。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Moby 推荐给任何想要组装基于容器的系统的人&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;想要自定义或修补其 Docker 构建的黑客；&lt;/li&gt;&lt;li&gt;构建容器系统的系统工程师或集成商；&lt;/li&gt;&lt;li&gt;希望使现有容器系统适应其环境的基础架构提供商；&lt;/li&gt;&lt;li&gt;想要尝试最新容器技术的容器爱好者；&lt;/li&gt;&lt;li&gt;希望在各种不同系统中测试其项目的开源开发人员；&lt;/li&gt;&lt;li&gt;任何对 Docker 内部结构及其构建方式感到好奇的人；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不建议将 Moby 用于以下用例&lt;/strong&gt;：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;正在寻找一种在容器中运行应用程序的简单方法的应用程序开发人员。我们推荐使用 Docker CE。&lt;/li&gt;&lt;li&gt;企业 IT 和开发团队正在寻找即用型、商业支持的容器平台。我们推荐使用 Docker EE。&lt;/li&gt;&lt;li&gt;任何对容器感兴趣并正在寻找一种简单的学习方法的人。我们建议改用 docker.com 网站。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Moby Project 面向希望修改、破解、修复、试验、发明和构建基于容器的系统的工程师、集成商和爱好者。它不是为寻找商业支持系统的人准备的，而是为想要使用开源代码工作和学习的人准备的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;与 Docker 的关系&lt;/strong&gt;，Moby Project 中的组件和工具，最初是 Docker 和社区为 Docker Project 构建的开源组件。如果新项目符合社区目标，则可以添加新项目。Docker 致力于使用 Moby 作为 Docker 产品的上游。但是，也鼓励其他项目使用 Moby 作为上游，并以不同的方式重用组件，所有这些使用将以相同的方式处理。欢迎外部维护者和贡献者。&lt;/p&gt;&lt;p&gt;Moby 项目不是作为 Docker 产品的支持或功能请求的位置，而是作为贡献者处理开源代码、修复错误并使代码更有用的地方。这些版本仅在尽力而为的基础上得到维护者、社区和用户的支持，并不适用于需要企业或商业支持的客户；Docker EE 是适合这些用例的产品。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e3a8afe7eec03b5eacebff&quot;&gt;倾城之链 - Moby Project - a collaborative project for the container ecosystem to assemble container-based systems&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/Mac&quot;&gt;&lt;code&gt;Mac&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BA%94%E7%94%A8&quot;&gt;&lt;code&gt;应用&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%85%8D%E8%B4%B9&quot;&gt;&lt;code&gt;免费&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Move and resize windows in macOS using keyboard shortcuts or snap areas. The official page for Rectangle.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/rectangleapp.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Rectangle Mac&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://rectangleapp.com/&quot;&gt;Rectangle&lt;/a&gt; 一款免费开源的 Mac 分屏软件；使用键盘快捷键或捕捉区域在 macOS 中移动和调整窗口大小。在安装和配置好 Rectangle 后，你会在菜单栏上看到它的图标，该按钮提供了常用的分屏功能，比如左右分屏、上下分屏、四角分屏、左中右分屏以及窗口大小设置等，只需要选中需要分屏的窗口，再点击相关选项就可以快速分屏。&lt;/p&gt;&lt;p&gt;你也可以使用快捷键来实现分屏，Rectangle 默认已经为每个分屏选项提供了快捷键，但是你还可以到软件的偏好设置中定制自己的快捷键；如果想要更方便地分屏，你还可以使用拖拽的方式管理分屏，将窗口拖动到屏幕边缘，Rectangle 就会自动为你分屏，还可以快速恢复原窗口。如果你需要在 Mac 上进行分屏操作，推荐尝试使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://rectangleapp.com/&quot;&gt;Rectangle&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e393dce7eec03b5eaceb34&quot;&gt;倾城之链 - Rectangle Mac&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%B9%B3%E5%8F%B0&quot;&gt;&lt;code&gt;平台&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9C%A8%E7%BA%BF&quot;&gt;&lt;code&gt;在线&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E7%A4%BE%E5%8C%BA&quot;&gt;&lt;code&gt;社区&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Building new spaces for communities that can&#x27;t share a place.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/frond.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Frond - A better way to build community online&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 是一个新的在线社区平台。因为它是从线程而不是聊天构建的，所以对话更深入、更容易跟进并自动扩展。Frond 团队相信社区是一种超级力量。无论您的目标是什么，一个有意义的社区都会让您更快地到达那里，并让旅程充满乐趣。这就是为什么他们要重新设想如何&lt;strong&gt;建立在线社区&lt;/strong&gt;。在 Frond 中设置需要几秒钟，任何人都可以通过一个简单的链接被邀请。 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 具备以下功能特征：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提醒&lt;/strong&gt;：有每日或每周线程吗？我们的反复提醒确保对话永远不会平息。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;社区模板&lt;/strong&gt;：我们知道你需要什么。一切都恰到好处，快速启动您的社区。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;丰富的分享&lt;/strong&gt;：给别人发帖？照片、视频或其他任何内容的预览都会吸引他们。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;管理控制&lt;/strong&gt;：通过将他们提升为管理员以获得更多控制，从您的社区获得支持。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;广播&lt;/strong&gt;：你的团队住在 Slack 吗？Frond 可以自动为您分享最近活动的摘要。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;整合&lt;/strong&gt;：连接 Slack 以获取通知和广播。更多集成即将推出。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;为各类社区而建&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E5%90%84%E7%B1%BB%E7%A4%BE%E5%8C%BA%E8%80%8C%E5%BB%BA&quot; aria-label=&quot;为各类社区而建 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为各类社区而建&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;公司&lt;/strong&gt;：伟大的工作需要良好的关系。团队使用 Frond 来寻找他们在办公室的归属感。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;创作者&lt;/strong&gt;：将您的内容转变为繁荣的社区。给你的听众一个属于自己的空间，让他们真正了解彼此。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;学校&lt;/strong&gt;：为学生提供一个相互了解、提出问题、创建学习小组和放松身心的场所。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Web3&lt;/strong&gt;：你的社区就是一切，它在 Frond 中更加丰富。提出问题、分享、集思广益和消除错误。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;项目&lt;/strong&gt;：一个集思广益、设定目标、回答问题和相互了解的地方。链接你的 &lt;a href=&quot;https://nicelinks.site/tags/&quot;&gt;Github&lt;/a&gt; ，它就可以开始了。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;维权人士&lt;/strong&gt;：运动建立在强大的社区之上。为您的积极分子提供一个组织、分享想法并真正相互了解的场所。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;顾客&lt;/strong&gt;：将最活跃的用户聚集在一起。提出问题、获得帮助、分享想法和报告错误的空间。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;团队&lt;/strong&gt;：场外的朋友在这上面取得了更大的成功。谈论策略，谈论垃圾，并分享您在实践之外的身份。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;作者对当今的社区工具感到失望：社交媒体强调我们的差异，因为它的目的是关注而不是社区。聊天工具在开始时运行良好，但随着它们的发展变得混乱和难以抗拒。并且认为社区值得更好。于是构建了 Frond——在线社区平台。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/redirect?url=https://frond.com/&quot;&gt;Frond&lt;/a&gt; 将对话组织成线程（threads）的原因，每个线程都以比聊天更丰富的内容开始：照片、视频、链接或只是长篇写作。更好的对话，更容易理解。线程被组织成组（groups），您的社区可以随着它的发展而形成。无论是烹饪、法国新浪潮电影还是可爱的柯基犬照片，您的小组都会引发丰富的对话。值得一提的是，所有在 2023 年 4 月 30 日之前注册 Frond Beta 的社区都将永久免费访问 Frond。如果您有意搭建属于自己的社区，不妨即刻取尝试 &amp;amp; 体验。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e251895769b373841a6065&quot;&gt;倾城之链 - Frond - A better way to build community online&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/HTML&quot;&gt;&lt;code&gt;HTML&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot;&gt;&lt;code&gt;CSS&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Web%E5%BC%80%E5%8F%91&quot;&gt;&lt;code&gt;Web开发&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Library of free and customizable HTML and CSS UI elements. It&lt;code&gt;s all open-source, and it&lt;/code&gt;s all free. Try it out to save you many hours spent on building; customizing UI components for your next project.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/uiverse.io.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Open-Source UI elements - made with CSS and HTML&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://uiverse.io/&quot;&gt;uiverse.io&lt;/a&gt; ，免费和可定制的 &lt;a href=&quot;https://nicelinks.site/tags/HTML&quot;&gt;HTML&lt;/a&gt; 和 &lt;a href=&quot;https://nicelinks.site/tags/CSS&quot;&gt;CSS&lt;/a&gt; UI 元素库，让您的网站更独特。涉及元素颇为丰富，涵盖卡片、开关、输入框、复选框 ☑️、加载动画、按钮（Button）等，使用非常简单，复制粘贴即可。它完全是开源的，免费供给个人和商业使用，可以给你的项目增加一些有趣的元素，为你的下一个项目节省许多花在构建和定制 UI 组件上的时间。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e23bda5769b373841a5fa0&quot;&gt;倾城之链 - Open-Source UI elements - made with CSS and HTML&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B8%B8%E6%88%8F&quot;&gt;&lt;code&gt;游戏&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%95%E6%93%8E&quot;&gt;&lt;code&gt;引擎&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/3D&quot;&gt;&lt;code&gt;3D&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Godot provides a huge set of common tools, so you can just focus on making your game without reinventing the wheel.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/godotengine.org.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Godot Engine - Free and open source 2D and 3D game engine&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://godotengine.org/&quot;&gt;Godot&lt;/a&gt; 引擎是一款免费的一体化跨平台游戏引擎，可让您轻松创建 2D 和 3D 游戏；可运行于 Windows、macOS、Linux 等多种操作系统。而其创建的游戏可运行于 PC、Android、iOS、HTML5 等平台。Godot 旨在提供另一种制作游戏的方式，&lt;/p&gt;&lt;h3 id=&quot;创新设计&quot;&gt;&lt;a href=&quot;#%E5%88%9B%E6%96%B0%E8%AE%BE%E8%AE%A1&quot; aria-label=&quot;创新设计 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;创新设计&lt;/h3&gt;&lt;p&gt;Godot 的节点和场景系统为您提供了创建任何东西的能力和灵活性。&lt;/p&gt;&lt;h3 id=&quot;为工作使用正确的语言&quot;&gt;&lt;a href=&quot;#%E4%B8%BA%E5%B7%A5%E4%BD%9C%E4%BD%BF%E7%94%A8%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%AD%E8%A8%80&quot; aria-label=&quot;为工作使用正确的语言 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;为工作使用正确的语言&lt;/h3&gt;&lt;p&gt;使用 Godot 自己的 GDScript、C#、C++ 或使用 GDNative 自带的面向对象的 API 使您的代码模块化。&lt;/p&gt;&lt;h3 id=&quot;专用二维引擎&quot;&gt;&lt;a href=&quot;#%E4%B8%93%E7%94%A8%E4%BA%8C%E7%BB%B4%E5%BC%95%E6%93%8E&quot; aria-label=&quot;专用二维引擎 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;专用二维引擎&lt;/h3&gt;&lt;p&gt;使用 Godot 的专用 2D 渲染引擎和真正的 2D 像素坐标和 2D 节点制作清晰和高性能的 2D 游戏。&lt;/p&gt;&lt;h3 id=&quot;简单而强大的-3d&quot;&gt;&lt;a href=&quot;#%E7%AE%80%E5%8D%95%E8%80%8C%E5%BC%BA%E5%A4%A7%E7%9A%84-3d&quot; aria-label=&quot;简单而强大的 3d permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;简单而强大的 3D&lt;/h3&gt;&lt;p&gt;Godot 的 3D 节点为您提供构建、动画和渲染 3D 世界和角色所需的一切。&lt;/p&gt;&lt;h3 id=&quot;在所有平台上发布&quot;&gt;&lt;a href=&quot;#%E5%9C%A8%E6%89%80%E6%9C%89%E5%B9%B3%E5%8F%B0%E4%B8%8A%E5%8F%91%E5%B8%83&quot; aria-label=&quot;在所有平台上发布 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;在所有平台上发布&lt;/h3&gt;&lt;p&gt;在几秒钟内将您的游戏部署到桌面、移动设备和 Web 上。Godot 甚至通过第三方发行商支持控制台。&lt;/p&gt;&lt;h3 id=&quot;开源&quot;&gt;&lt;a href=&quot;#%E5%BC%80%E6%BA%90&quot; aria-label=&quot;开源 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;开源&lt;/h3&gt;&lt;p&gt;真正开放的开发：任何为 Godot 做出贡献的人都可以从他人的贡献中平等受益。&lt;/p&gt;&lt;p&gt;Godot 内置的 GDScript 脚本语言是一种高级动态类型编程语言，语法与 Python 类似。与 Python 不同，GDScript 是针对 Godot 的场景架构设计的，一个文件就是一个类，并且可以为变量限定类型。开发 GDScript 之前，Godot 的开发者尝试使用过 Lua、Python、Squirrel 等第三方脚本语言，但最终为了优化和编辑器集成选择使用自定义的语言。&lt;/p&gt;&lt;p&gt;Godot 最初于 2007 年开始开发，2014 年 12 月 15 日，Godot 迎来了首个稳定版本 1.0；2016 年 2 月 24 日上架 Steam；2023 年 2 月，Godot 4.0 版本发布。从宏观上看，Godot 与 &lt;a href=&quot;https://nicelinks.site/post/60f8020181b2dc066ea4bd73&quot;&gt;Unity&lt;/a&gt;、Unreal 尚有差距，但颇受开发者好评，如果您对其感兴趣，不妨前往官网了解更多。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e0ffe75769b373841a5526&quot;&gt;倾城之链 - Godot Engine - Free and open source 2D and 3D game engine&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%B8%B8%E6%88%8F&quot;&gt;&lt;code&gt;游戏&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%BC%95%E6%93%8E&quot;&gt;&lt;code&gt;引擎&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/3D&quot;&gt;&lt;code&gt;3D&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：Digital content development, game engine, native game development, WeChat mini-game production, H5 game development, introduction to game development, real-time 3D rendering, AR&amp;amp;VR content development, virtual character, smart city, smart cockpit, IoT, HMI, digital twin, Smart Education, Smart Fitness, Metaverse, 2D&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The world&#x27;s top lightweight, efficient, cross-platform digital content development platform can meet different development needs for 3D, 2D, AR&amp;amp;VR and other unique content creation, and can provide complete solutions in frontier fields such as smart cockpit, digital twin, virtual character, and smart education industry solutions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.cocos.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Cocos - The world&#x27;s top 2D&amp;amp;3D engine, game / smart cockpit /AR/VR/ virtual character / education&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.cocos.com/&quot;&gt;Cocos&lt;/a&gt; 是由厦门雅基软件有限公司推出的数字内容开发一站式解决方案，具备开源、免费、轻量、高性能等特点，服务了 2D 和 3D 游戏开发、智能座舱、在线教育、XR、数字人、数字孪生、数字文创等领域开发者。Cocos 在全球 203 个国家和地区，拥有 150 万开发者，覆盖全球超过 16 亿终端用户。&lt;/p&gt;&lt;p&gt;Cocos 成立于 2010 年，核心产品包括开源引擎框架 Cocos2d-x、编辑器 Cocos Creator、游戏加速框架 Cocos Runtime、智能座舱解决方案 Cocos HMI、互动课件编辑器 Cocos ICE、XR 方向创作工具 Cocos Creator XR 等等。Cocos 产品具有以下优势：&lt;/p&gt;&lt;h3 id=&quot;游戏开发一站式解决方案低成本高效率&quot;&gt;&lt;a href=&quot;#%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E4%B8%80%E7%AB%99%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BD%8E%E6%88%90%E6%9C%AC%E9%AB%98%E6%95%88%E7%8E%87&quot; aria-label=&quot;游戏开发一站式解决方案低成本高效率 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;游戏开发一站式解决方案，低成本、高效率&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 提供了全套的引擎和开发工具，涵盖从前期设计、资源制作、开发调试、打包上线全套的解决方案。cocos 重点优化了工作流，规范了整个游戏开发流程，降低沟通成本，提高开发效率。&lt;/p&gt;&lt;h3 id=&quot;高性能一次制作多终端平台共享&quot;&gt;&lt;a href=&quot;#%E9%AB%98%E6%80%A7%E8%83%BD%E4%B8%80%E6%AC%A1%E5%88%B6%E4%BD%9C%E5%A4%9A%E7%BB%88%E7%AB%AF%E5%B9%B3%E5%8F%B0%E5%85%B1%E4%BA%AB&quot; aria-label=&quot;高性能一次制作多终端平台共享 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;高性能，一次制作，多终端平台共享&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 不断的优化游戏性能，以保证高帧速率下可以获得更华丽的效果；即使是千元低端机，运行华丽特效丝毫不卡顿，让您的游戏可以得到尽情的发挥。&lt;/p&gt;&lt;p&gt;跨平台特性确保一次制作，全平台支持。无需为后期移植耗尽人力和时间，极大的降低了时间成本，确保游戏不会错过珍贵的黄金上线档期&lt;/p&gt;&lt;h3 id=&quot;windows-与-mac-同步发布更新团队协作更容易&quot;&gt;&lt;a href=&quot;#windows-%E4%B8%8E-mac-%E5%90%8C%E6%AD%A5%E5%8F%91%E5%B8%83%E6%9B%B4%E6%96%B0%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E6%9B%B4%E5%AE%B9%E6%98%93&quot; aria-label=&quot;windows 与 mac 同步发布更新团队协作更容易 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;Windows 与 Mac 同步发布更新，团队协作更容易&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;目前大部分开发团队根据不同需求会在不同的操作系统下工作，而一套可以运行在多个平台的游戏引擎显得至关重要。Cocos 同时支持 Windows 和 Mac 操作系统，功能完全同步。提升团队协作便捷性，不再为了配合而频繁的切换系统或者使用双系统。&lt;/p&gt;&lt;h3 id=&quot;插件商店素材丰富游戏开发更灵活更便捷&quot;&gt;&lt;a href=&quot;#%E6%8F%92%E4%BB%B6%E5%95%86%E5%BA%97%E7%B4%A0%E6%9D%90%E4%B8%B0%E5%AF%8C%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E6%9B%B4%E7%81%B5%E6%B4%BB%E6%9B%B4%E4%BE%BF%E6%8D%B7&quot; aria-label=&quot;插件商店素材丰富游戏开发更灵活更便捷 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;插件商店，素材丰富，游戏开发更灵活更便捷&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos 开放了强大的扩展功能并推出了 Cocos Store，提供了插件、资源、工具、素材等丰富的资源，为用户的开发提供了更大的灵活性。Cocos Store 将为用户提供了一个自由的平台，连接全球的开发者，用户可以获得和分享自己的成果。&lt;/p&gt;&lt;h3 id=&quot;同步支持-2d-和-3d满足全方位开发需求&quot;&gt;&lt;a href=&quot;#%E5%90%8C%E6%AD%A5%E6%94%AF%E6%8C%81-2d-%E5%92%8C-3d%E6%BB%A1%E8%B6%B3%E5%85%A8%E6%96%B9%E4%BD%8D%E5%BC%80%E5%8F%91%E9%9C%80%E6%B1%82&quot; aria-label=&quot;同步支持 2d 和 3d满足全方位开发需求 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;strong&gt;同步支持 2D 和 3D，满足全方位开发需求&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Cocos Creator 支持 2D、3D 方面的游戏开发，基于华为提供的延迟渲染管线，可以为开发者提供高品质美术创作。具有可满足开发者各种游戏类型特定需求的功能，并且优化了纯 2D 游戏的编辑器使用体验和引擎性能，内建了 Spine、DragonBones、TiledMap、Box2D 和 Texture Packer 等 2D 开发中间件的支持。&lt;/p&gt;&lt;p&gt;2022 年 4 月，Cocos 宣布完成 5000 万美元 B 轮融资，投资方为建信信托、GGV 纪源资本、声网 Agora 等。本轮融资后，Cocos 将借助资本的助力，持续提升引擎核心技术，促进引擎进一步与游戏、汽车、教育、XR、家居设计、建筑工程设计等场景的结合，Cocos 也坚持将每年的利润全部投入引擎功能研发、新场景拓展、生态建设上，持续为开发者提供更便捷的创作工具，为跨行业的客户带来可靠的技术解决方案和提供更多元的产品与服务。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63e0f4695769b373841a54aa&quot;&gt;倾城之链 - Cocos - The world&#x27;s top 2D&amp;amp;3D engine, game / smart cockpit /AR/VR/ virtual character / education&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;圣人无常师。孔子师郯子、苌弘、师襄、老聃。郯子之徒，其贤不及孔子。孔子曰：三人行，则必有我师。&lt;strong&gt;是故弟子不必不如师，师不必贤于弟子，闻道有先后，术业有专攻，如是而已&lt;/strong&gt;。── 唐朝 · 韩愈《师说》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ba6a3768103a6f870b429183bdcfc4cf</guid>
<title>在 4G 内存的机器上，申请 8G 内存会怎么样？</title>
<link>https://toutiao.io/k/tznheo5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是田螺。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章其实之前发过，但是最近有位读者跟我反馈，我文章中的实验在 64 位操作系统、2 G 物理内存的场景，申请 8G 内存是没问题的，而他也是这个环境，为什么他就无法申请成功呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我帮他排查了下，原来是跟 Linux 的 overcommit_memory 参数有关，这个参数主要是定义进程申请的内存收否允许激进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这位读者很用心，写了个 world 文档总结我和他交流的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9851258581235698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecyzu4FoiaOpo3OZNsnphRlwOxnVFdrkdib92OpiayT9o9AKP1J43mtyRZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我现在把这部分内容也补充了进来，相比以前的文章会更全面了一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，发车辣！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8020833333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecalTd5aPGyf0dthKl9QYTm5Fx4NACDzfnMRH83EGmdSI3YfYkeiaYzNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到读者在群里讨论这些面试题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9181585677749361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecAd4UfefyD3KtLpsvqPc0Qy13BaQXMzxhKGDOib88Fl02hD9DrTFEfsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，第一个问题「&lt;strong&gt;在 4GB 物理内存的机器上，申请 8G 内存会怎么样？&lt;/strong&gt;」存在比较大的争议，有人说会申请失败，有的人说可以申请成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题在没有前置条件下，就说出答案就是耍流氓。这个问题要考虑三个前置条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;操作系统是 32 位的，还是 64 位的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;申请完 8G 内存后会不会被使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;操作系统有没有使用 Swap 机制？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们要分场景讨论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作系统虚拟内存大小&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存， CPU 就会产生&lt;strong&gt;缺页中断&lt;/strong&gt;，进程会从用户态切换到内核态，并将缺页中断交给内核的 Page Fault Handler （缺页中断函数）处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺页中断处理函数会看是否有空闲的物理内存：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，如果回收内存工作结束后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了触发 OOM （Out of Memory）机制。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32 位操作系统和 64 位操作系统的虚拟地址空间大小是不同的，在 Linux 操作系统中，虚拟地址空间的内部又被分为&lt;strong&gt;内核空间和用户空间&lt;/strong&gt;两部分，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3846855059252507&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecibyDI7O9QmicQwibibrGPQjjrmu55PWoUPPNPl1dJfqxzuWBoMPichZbZbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这里可以看出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;32&lt;/code&gt; 位系统的内核空间占用 &lt;code&gt;1G&lt;/code&gt;，位于最高处，剩下的 &lt;code&gt;3G&lt;/code&gt; 是用户空间；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;64&lt;/code&gt; 位系统的内核空间和用户空间都是 &lt;code&gt;128T&lt;/code&gt;，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32 位操作系统的场景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;现在可以回答这个问题了：在 32 位操作系统、4GB 物理内存的机器上，申请 8GB 内存，会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 32 位操作系统，进程最多只能申请 3 GB 大小的虚拟内存空间，所以进程申请 8GB 内存的话，在申请虚拟内存阶段就会失败（我手上没有 32 位操作系统测试，我估计失败的错误是 cannot allocate memory，也就是无法申请内存失败）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;64 位操作系统的场景&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 64 位操作系统、4GB 物理内存的机器上，申请 8G 内存，会怎么样？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;64 位操作系统，进程可以使用 128 TB 大小的虚拟内存空间，所以进程申请 8GB 内存是没问题的，因为进程申请内存是申请虚拟内存，只要不读写这个虚拟内存，操作系统就不会分配物理内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以简单做个测试，我的服务器是 64 位操作系统，但是物理内存只有 2 GB：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13376623376623376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecsSSH5gBQibiaJEp0KsPz73icIr17nJmu4hGV9b59QO2Joowz2hm5VXumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我在机器上，连续申请 4 次 1 GB 内存，也就是一共申请了 4 GB 内存，&lt;span&gt;注意下面代码只是单纯分配了虚拟内存，并没有使用该虚拟内存&lt;/span&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        addr[i] = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;(MEM_SIZE);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!addr[i]) {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;执行 malloc 失败, 错误：%s\n&quot;&lt;/span&gt;,strerror(errno));&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，申请1gb大小得内存，此内存起始地址：0X%p\n&quot;&lt;/span&gt;, addr[i]);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//输入任意字符后，才结束&lt;/span&gt;&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后运行这个代码，可以看到，我的物理内存虽然只有 2GB，但是程序正常分配了 4GB 大小的虚拟内存：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20496894409937888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec0HYQvxhRCvHMwibJLcnzQXskClWxXH3z57zdr7yxBZqHTQmrbnwMV7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过下面这条命令查看进程（test）的虚拟内存大小：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ps aux | grep &lt;span&gt;test&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND&lt;br/&gt;root      7797  0.0  0.0 4198540  352 pts/1    S+   16:58   0:00 ./test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，VSZ 就代表进程使用的虚拟内存大小，RSS 代表进程使用的物理内存大小。可以看到，VSZ 大小为 4198540，也就是 4GB 的虚拟内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开头说的读者跟我反馈，说他自己也做了这个实验，然后发现 64 位操作系统、2G 物理内存的机子上，在申请 4GB 虚拟内存的时候失败了，这是为什么呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;失败的错误：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07112526539278131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec39nvuHYV23k13fgGUWicIlzHm5UXicDZaVibGoVZYNQoIj5SZRDO8J4vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时帮他排查了下，发现跟 Linux 中的 overcommit_memory 参数有关，可以使用 &lt;code&gt;cat /proc/sys/vm/overcommit_memory&lt;/code&gt; 来查看这个参数，这个参数接受三个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果值为 0（默认值），代表：Heuristic overcommit handling，它允许overcommit，但过于明目张胆的 overcommit 会被拒绝，比如malloc一次性申请的内存大小就超过了系统总内存。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，大概可以理解为单次申请不能超过free memory + free swap + pagecache的大小 + SLAB中可回收的部分 ，超过了就会拒绝overcommit。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果值为 1，代表：Always overcommit. 允许overcommit，对内存申请来者不拒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果值为 2，代表：Don’t overcommit. 禁止overcommit。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时那位读者的 overcommit_memory 参数是默认值 0 ，所以申请失败的原因可能是内核认为我们申请的内存太大了，它认为不合理，所以 malloc() 返回了 Cannot allocate memory 错误，这里申请 4GB 虚拟内存失败的同学可以将这个 overcommit_memory 设置为1，就可以 overcommit 了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;echo 1 &amp;gt; /proc/sys/vm/overcommit_memory &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置完为 1 后，读者的机子就可以正常申请 4GB 虚拟内存了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecqnSicrHW5ubvhU2prdj7fVpdUF0JHmibH5miaFDXJFFAtXZTeu7w2V80Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;不过我的环境 &lt;span&gt;overcommit_memory 是 0，在 64 系统、2 G 物理内存场景下，也是可以成功申请 4 G 内存的，我怀疑可能是不同版本的内核在 &lt;span&gt;overcommit_memory 为 0 时，检测内存申请是否合理的算法可能是不同的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总之，如果你申请大内存的时候，不想被内核检测内存申请是否合理的算法干扰的话，将 overcommit_memory 设置为 1 就行。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么将这个 overcommit_memory 设置为 1 之后，64 位的主机就可以申请接近 128T 虚拟内存了吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一定，还得看你服务器的物理内存大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读者的服务器物理内存是 2 GB，实验后发现，进程还没有申请到 128T 虚拟内存的时候就被杀死了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4245709123757904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecjNuVxBOPlGJ7HzAibYK0AHia7ibcxmz8D7WMXNic0RZZ0wRc4tLNbaAomQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，这次是 killed，而不是 Cannot Allocate Memory，说明并不是内存申请有问题，而是触发 OOM 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是为什么会触发 OOM 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那得看你的主机的「物理内存」够不够大了，即使 malloc 申请的是虚拟内存，只要不去访问就不会映射到物理内存，但是申请虚拟内存的过程中，还是使用到了物理内存（比如内核保存虚拟内存的数据结构，也是占用物理内存的），如果你的主机是只有 2GB 的物理内存的话，大概率会触发 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用 top 命令，点击两下 m，通过进度条观察物理内存使用情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1086398631308811&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecibcHsfT7MlFAmJgLPj17CtTUiclLiaiaqXxuw8pJMv2ibTZSIdrvKiadTN6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1169&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到申请虚拟内存的过程中&lt;strong&gt;物理内存使用量一直在增长&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06429192006950478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec7Ok2BKu4wrJXPdxoX6jI4VRUk7p0y8lAia6Dvd1d1xlUz8nTu9mjfiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1151&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0636672325976231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec0VCazAPwdkGH9baSOuwiawXAiaWom6doJqDHaOib0YEegvGbzksmCFjYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05736301369863014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec4f0l2clbdx9b4os5tfIbM0kHicJrDN5ZicnkG9kOWJBNUChk7rZCe5zA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直到直接内存回收之后，也无法回收出一块空间供这个进程使用，这个时候就会触发 OOM，给所有能杀死的进程打分，分数越高的进程越容易被杀死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里当然是这个进程得分最高，那么操作系统就会将这个进程杀死，所以最后会出现 killed，而不是Cannot allocate memory。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么 2GB 的物理内存的 64 位操作系统，就不能申请128T的虚拟内存了吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实可以，上面的情况是还没开启 swap 的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 swapfile 的方式开启了 1GB 的 swap 空间之后再做实验：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10577777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecxHSIviaGBGmNE6oPyGMp1dg0GgaDfdrMlMcClxIaHT5o6XZgcHib9oiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1125&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5283926852743022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecQsIJXwc3YjJdsaR42hfkkr7ibZDaVflWicTSIaOwtGZkI6XHrQxqs4MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现出现了 Cannot allocate memory，但是其实到这里已经成功了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开计算器计算一下，发现已经申请了 127.998T 虚拟内存了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3052109181141439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecjaqIJ72icOl8rIAhpr9tGmqRhQv9SVwSKQNQerUf748svVwoicX8Qu6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请 127T 虚拟内存试试：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40971585701191565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0eclrON8lDwjoY88V6q3FciaoOO5B8UP3wWkSYMAAd0e7OdwXU0YdkOR2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现进程没有被杀死，也没有 Cannot allocate memory，也正好是 127T 虚拟内存空间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecI72V1chdoAKjtsmxWDfXzgjibeJHRG7RBZ4r0Kkq6n6WvVcLIicuhTFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 top 中我们可以看到这个申请了127T虚拟内存的进程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecLcPibbUjwlK0cgyyXJibU4VLgGqGqEicFGfDluiaqPXWydlUqmOXrqcCNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swap 机制的作用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讨论在 32 位/64 位操作系统环境下，申请的虚拟内存超过物理内存后会怎么样？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。当访问这块虚拟内存后，操作系统才会进行物理内存分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有开启 Swap 机制，程序就会直接 OOM；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有开启 Swap 机制，程序可以正常运行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是 Swap 机制？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种，将内存数据换出磁盘，又从磁盘中恢复数据到内存的过程，就是 Swap 机制负责的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swap 就是把一块磁盘空间或者本地文件，当成内存来使用，它包含换出和换入两个过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;换出（Swap Out）&lt;/strong&gt; ，是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;换入（Swap In）&lt;/strong&gt;，是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Swap 换入换出的过程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6095305832147937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecp9CWO1dLo8hJDQbkOjpQgf73kD6MRMQpylJlE1UpnjDLXQR87rCoog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Swap 机制优点是，应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比内存要低，因此这种方式无疑是经济实惠的。当然，频繁地读写硬盘，会显著降低操作系统的运行速率，这也是 Swap 的弊端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 中的 Swap 机制会在内存不足和内存闲置的场景下触发：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存不足&lt;/strong&gt;：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;内存闲置&lt;/strong&gt;：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换（Page replacement）的守护进程，它也是负责交换闲置内存的主要进程，它会在时，回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 提供了两种不同的方法启用 Swap，分别是 Swap 分区（Swap Partition）和 Swap 文件（Swapfile）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Swap 分区是硬盘上的独立区域，该区域只会用于交换分区，其他的文件不能存储在该区域上，我们可以使用 &lt;code&gt;swapon -s&lt;/code&gt; 命令查看当前系统上的交换分区；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Swap 文件是文件系统中的特殊文件，它与文件系统中的其他文件也没有太多的区别；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Swap 换入换出的是什么类型的内存？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核缓存的文件数据，因为都有对应的磁盘文件，所以在回收文件数据的时候， 直接写回到对应的文件就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是像进程的堆、栈数据等，它们是没有实际载体，这部分内存被称为匿名页。而且这部分内存很可能还要再次被访问，所以不能直接释放内存，于是就需要有一个能保存匿名页的磁盘载体，这个载体就是 Swap 分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;匿名页回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，通过两个实验，看看申请的物理内存超过物理内存会怎样？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实验一：没有开启 Swap 机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实验二：有开启 Swap 机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实验一：没有开启 Swap 机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的服务器是 64 位操作系统，但是物理内存只有 2 GB，而且没有 Swap 分区：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13376623376623376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecsSSH5gBQibiaJEp0KsPz73icIr17nJmu4hGV9b59QO2Joowz2hm5VXumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1540&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们改一下前面的代码，使得在申请完 4GB 虚拟内存后，通过 memset 函数访问这个虚拟内存，看看在没有 Swap 分区的情况下，会发生什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;errno.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        addr[i] = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;(MEM_SIZE);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!addr[i]) {&lt;br/&gt;            &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;执行 malloc 失败, 错误：%s\n&quot;&lt;/span&gt;,strerror(errno));&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，申请1gb大小得内存，此内存起始地址：0X%p\n&quot;&lt;/span&gt;, addr[i]);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;4&lt;/span&gt;; ++i) {&lt;br/&gt;        &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;开始访问第 %d 块虚拟内存(每一块虚拟内存为 1 GB)\n&quot;&lt;/span&gt;, i + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;memset&lt;/span&gt;(addr[i], &lt;span&gt;0&lt;/span&gt;, MEM_SIZE);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//输入任意字符后，才结束&lt;/span&gt;&lt;br/&gt;    getchar();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25877192982456143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecDyWgvIFI9IYOEGCd371Lw7XbM4C2TnBuUE1IChB9gWo46bicb2iaoKkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1368&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在访问第 2 块虚拟内存（每一块虚拟内存是 1 GB）的时候，因为超过了机器的物理内存（2GB），进程（test）被操作系统杀掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过查看 message 系统日志，可以发现该进程是被操作系统 OOM killer 机制杀掉了，日志里报错了 Out of memory，也就是发生 OOM（内存溢出错误）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07548701298701299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecC645GCiaIF6IzVJKbAtSF31O3Lr3Qia07j560ry1jszru1g9Ty3PZzjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;什么是 OOM?&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实验二：有开启 Swap 机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用我的 mac book pro 笔记本做测试，我的笔记本是 64 位操作系统，物理内存是 8 GB， 目前 Swap 分区大小为 1 GB（&lt;em&gt;注意，这个大小不是固定不变的，Swap 分区总大小是会动态变化的，当没有使用 Swap 分区时，Swap 分区总大小是 0；当使用了 Swap 分区，Swap 分区总大小会增加至 1 GB；当 Swap 分区已使用的大小超过 1 GB 时；Swap 分区总大小就会增加到至 2 GB；当 Swap 分区已使用的大小超过 2 GB 时；Swap 分区总大小就增加至 3GB，如此往复。这个估计是 macos 自己实现的，Linux 的分区则是固定大小的，Swap 分区不会根据使用情况而自动增长&lt;/em&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23342175066312998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecEbgw4QIicdUBc5T3ge4iaLicqgMiabniaNtuDwZDzCkqHBQsBCmsgU25icFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便观察磁盘 I/O 情况，我们改进一下前面的代码，分配完 32 GB虚拟内存后（笔记本物理内存是 8 GB），通过一个 while 循环频繁访问虚拟内存，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; MEM_SIZE 32 * 1024 * 1024 * 1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* addr = (&lt;span&gt;char&lt;/span&gt;*) &lt;span&gt;malloc&lt;/span&gt;((&lt;span&gt;long&lt;/span&gt;)MEM_SIZE);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;主线程调用malloc后，目前共申请了 32gb 的虚拟内存\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;//循环频繁访问虚拟内存&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;开始访问 32gb 大小的虚拟内存...\n&quot;&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;memset&lt;/span&gt;(addr, &lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;long&lt;/span&gt;)MEM_SIZE);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5410526315789473&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecib7UYic109Ic6XMx9fpITmtO544tmn2cYibPdaRF8ADArE7KqmjlSpRsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在有 Swap 分区的情况下，即使笔记本物理内存是 8 GB，申请并使用 32 GB 内存是没问题，程序正常运行了，并没有发生 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从下图可以看到，进程的内存显示 32 GB（这个不要理解为占用的物理内存，理解为已被访问的虚拟内存大小，也就是在物理内存呆过的内存大小），系统已使用的 Swap 分区达到 2.3 GB。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29236641221374043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ecHiaQiceJVZ70acicnOTco6vaLoqaUOSRwyUO0dGKuVgt71AS03ibWJdGLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我的笔记本电脑的磁盘开始出现“沙沙”的声音，通过查看磁盘的 I/O 情况，可以看到磁盘 I/O 达到了一个峰值，非常高：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5122615803814714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0ec6lM9GcZJCoReKtx7lVuSRasic4gvow5tsKhPDuBWEB4hJ7QbLYD2MlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有了 Swap 分区，是不是意味着进程可以使用的内存是无上限的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把上面的代码改成了申请 64GB 内存后，当进程申请完 64GB 虚拟内存后，使用到 56 GB （这个不要理解为占用的物理内存，理解为已被访问的虚拟内存大小，也就是在物理内存呆过的内存大小）的时候，进程就被系统 kill 掉了，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2524719841793013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcoxxWCYHT1TIPmRm6fc0eclf5MbcdQAVl8Sw6JPaOwcSXF58agj6XeU8mfRjSFibkUPE6ia4fXc77A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3034&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统多次尝试回收内存，还是无法满足所需使用的内存大小，进程就会被系统 kill 掉了，意味着发生了 OOM。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此， 验证完成了。简单总结下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 32 位操作系统，因为进程理论上最大能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败，报错 Cannot allocate memory&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 64位 位操作系统，因为进程理论上最大能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。如果这块虚拟内存被访问了，要看系统有没有 Swap 分区：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果没有 Swap 分区，因为物理空间不够，进程会被操作系统杀掉，原因是 OOM（内存溢出）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有 Swap 分区，即使物理内存只有 4GB，程序也能正常使用 8GB 的内存，进程可以正常运行；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;溜啦溜啦！&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d537d0e2ff3d4bf0ba2ffe27a11c8543</guid>
<title>一分钟读论文：《基于 ChatGPT、AR 和 Voicebots 的儿童外教软件设计框架》</title>
<link>https://toutiao.io/k/lynpu1m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-post&quot;&gt;                
&lt;p&gt;ChatGPT 催生了很多教育领域的创业项目，欧盟大约有&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2600万4到8岁的儿童，美国大约有1700万4到8岁的儿童&lt;/code&gt;，外语软件将服务于数百万家庭。美国的佛罗里达理工大学与南佛罗里达大学合著的论文&lt;a href=&quot;https://dergipark.org.tr/en/download/article-file/2864638&quot;&gt;《Framework for A Foreign Language Teaching Software for Children Utilizing AR, Voicebots and ChatGPT (Large Language Models)》&lt;/a&gt;设计出一个框架，用于利用 AR+Voicebots+ChatGPT 技术开发语言学习软件，框架遵循了⼉童外语教学的设计原则：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;游戏化、社交互动、惊喜奖励&lt;/code&gt;。利用论文中提到的技术平台，开发人员、研究人员和企业家能够比以往更快地实现产品化，本设计框架和设计原则可以成为开发高效外语教学软件的蓝图。&lt;/p&gt;

&lt;h2 id=&quot;设计框架的构成&quot;&gt;设计框架的构成&lt;/h2&gt;



&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;增强现实 (AR)&lt;/code&gt;：AR 将计算机⽣成的数据（图像、声⾳等）叠加到⽤⼾视图，向其中添加数字信息层来增强⽤⼾对现实世界的感知。可以使⽤多种 AR 框架（例如 ARCore、ARKit 或 Vuforia）将 AR 技术嵌⼊到移动应⽤程序中。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;语音机器人（Voicebots）&lt;/code&gt;：用于语⾳转⽂本或⽂本转语⾳。可以使用聊天机器⼈平台：Dialogflow、IBM Watson Assistant、Amazon Lex、 ManyChat、Chatfuel 、Wit.ai 、MindMeld、Chatbot 、Azure Bot Service。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChatGPT（大型语言模型 AI）&lt;/code&gt;：设计对话是⼀项⾮常重要、具有挑战性且耗时的任务，为了克服内容生成的任务，建议&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;利用 ChatGPT 创建内容&lt;/code&gt;。测试表明 ChatGPT 有助于学习外语的对话。在教授外语时，特别是对于年幼的孩子，一些最初的对话和主题是自我介绍，以及关于动物、食物、车辆、家庭成员、身体部位、车辆、职业等的对话。通过提供对高质量、定制化和个性化语言学习材料的访问，ChatGPT 可能彻底改变语言的教学和学习方式。&lt;/li&gt;
&lt;/ul&gt;



&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;


                
&lt;/article&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9fd2ec9f73eb596798cec6666ee7b4a7</guid>
<title>如何做一个看板搭建系统</title>
<link>https://toutiao.io/k/sm2zqtq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;一、什么是数据看板，数据看板有什么用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解释数据看板概念之前，我们要先知道，什么是数据可视化。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;数据可视化被许多学科视为与视觉传达含义相同的现代概念。它涉及到数据的可视化表示的创建和研究。为了清晰有效地传递信息，数据可视化使用统计图形、图表、信息图表和其他工具。可以使用点、线或条对数字数据进行编码，以便在视觉上传达定量信息。有效的可视化可以帮助用户分析和推理数据和证据。它使复杂的数据更容易理解和使用。- 维基百科&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据看板即是数据可视化的&lt;strong&gt;载体&lt;/strong&gt;，通过合理的页面布局、效果设计来将可视化数据更好的展现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人认为，数据看板的作用大致为以下两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;strong&gt;掌握情况&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数据呈现，决策者们能较为清晰地掌握自己产品的运营情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;strong&gt;问题解决&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数据分析，能够通过数据可视化，从动态数据中提炼出规律，发现不符合预期的部分并给出修改意见。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、配置文件数据结构设计&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有如下这样的一个看板页面，让你用一份 json 文件来记录组件的信息，类似，宽高、位置以及标题等等，试想一下你会怎么设计 json 的数据结构（可以不用关心具体的值是什么）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31203703703703706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sticlevzdTIA19vT8edryDYdCp7ZzRBBCiaQnZEWkXfsda10TDNIXGDfyfcmcrdZMNDTgg11aHc0rVTRj84JaV9A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题并不是很难，相信大部分人都能设计一份自己的数据结构，比如我设计的结构就是下面这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &#x27;line&#x27;, &lt;span&gt;// 类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;// 唯一标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;data&quot;&lt;/span&gt;: [], &lt;span&gt;// 数据存放&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;title&quot;&lt;/span&gt;: &lt;span&gt;&quot;货物销售情况&quot;&lt;/span&gt;, &lt;span&gt;// 组件标题&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;layout&quot;&lt;/span&gt;: { x: &lt;span&gt;0&lt;/span&gt;, y: &lt;span&gt;0&lt;/span&gt;, w: &lt;span&gt;3&lt;/span&gt;, h: &lt;span&gt;2&lt;/span&gt; }, &lt;span&gt;// 页面布局信息（坐标、宽高）&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &#x27;bar&#x27;,&lt;br/&gt;    &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;data&quot;&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;&quot;title&quot;&lt;/span&gt;: &lt;span&gt;&quot;货物留存情况&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;layout&quot;&lt;/span&gt;: { i: &#x27;c&#x27;, x: &lt;span&gt;3&lt;/span&gt;, y: &lt;span&gt;0&lt;/span&gt;, w: &lt;span&gt;3&lt;/span&gt;, h: &lt;span&gt;2&lt;/span&gt; },&lt;br/&gt;  }&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这样一份数据结构之后，接下来，我们接下来就要开发组件，比如&lt;code&gt;{type:line}&lt;/code&gt;的配置项就去用 line 组件渲染，并且我们需要把数据还有一些其他配置项传给组件。关于每个组件的开发，这里就不深入探讨了，需要考虑的就是你的内部组件要具有接受数据并处理配置的能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、组件容器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在组件有了，配置也有了，接下来就很简单了，根组件直接循环遍历下，就可以了，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;br/&gt; {widgets.map(&lt;span&gt;&lt;span&gt;widget&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; WidgetComp = getWidgetComp(widget.type);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;WidgetComp&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;=&lt;span&gt;{widget}&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{widget.id}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt; })}&lt;br/&gt;&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，大功告成，页面渲染完成！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先别着急，我们想想看，是不是每个组件，我们都需要去做同样的工作，比如数据请求、布局处理等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，我们就需要在一个统一的地方去做这些同样且重复的工作。这里我想到了两种方式：1、公共的 util 函数。2、给所有组件增加一层包裹容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方法虽然可以满足我们的要求，但是还是存在局限性，那就是当我们想要在 dom 上做一些处理的时候，还是不可避免的会有重复代码量，比如给组件添加点击事件、设置 dom 的 style 属性等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人比较推荐第二种方法，也就是组件容器。一个组件容器大概长这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Widget = &lt;span&gt;(&lt;span&gt;{config}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 组件点击事件&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; handleClick=&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;span&gt;/**/};&lt;br/&gt;  // 布局处理&lt;br/&gt;  const handleLayout=() =&amp;gt; {/**/&lt;/span&gt;};&lt;br/&gt;  &lt;span&gt;// 获取组件数据&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; getWidgetData=&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;span&gt;/**/};&lt;br/&gt;  // 其他的一些公共逻辑&lt;br/&gt;  .......&lt;br/&gt;&lt;br/&gt; const WidgetComp = getWidgetComp(widget.type);&lt;br/&gt; return (&lt;br/&gt;  return &amp;lt;WidgetComp config={widget} /&amp;gt;&lt;br/&gt; )&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的根组件代码可以改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;br/&gt; {widgets.map(&lt;span&gt;&lt;span&gt;widget&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;Widget&lt;/span&gt; &lt;span&gt;config&lt;/span&gt;=&lt;span&gt;{widget}&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{widget.id}&lt;/span&gt; /&amp;gt;&lt;/span&gt;)}&lt;br/&gt;&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、配置文件的编辑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的工作做完之后，我们可以做一个简单的渲染了，但是既然是搭建系统，怎么可能仅仅满足于渲染呢？接下来，我们要考虑下，给搭建的用户提供一个可以修改配置的地方。为了统一口径，我们把使用配置的地方，称&lt;strong&gt;用户侧&lt;/strong&gt;，修改配置的地方，称&lt;strong&gt;编辑侧&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个编辑侧可能长这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4027777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sticlevzdTIA19vT8edryDYdCp7ZzRBBCicTrdpMKr0CKn51f7hVZ1CIydj2qaI1Dqr22DG5icd0jOLicMRH3nzbPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致分为三个区域，组件商店、展示区域和配置区域，这里我们先说右侧的组件配置区域。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里拿 line 组件 举例。假设，现在产品小姐姐给你提了第一个需求，需要这个 line 组件支持修改名称。so easy！直接写个 form 表单：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;Form form={form}&amp;gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Item&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;name&quot;&lt;/span&gt; &lt;span&gt;label&lt;/span&gt;=&lt;span&gt;&quot;名称&quot;&lt;/span&gt; &lt;span&gt;rules&lt;/span&gt;=&lt;span&gt;{[{&lt;/span&gt; &lt;span&gt;required:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;message:&lt;/span&gt; &#x27;请输入&#x27; }]}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Input&lt;/span&gt; &lt;span&gt;placeholder&lt;/span&gt;=&lt;span&gt;&quot;请输入&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;Item&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;&lt;span&gt;/Form&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改完之后，直接把新的名称发给后端存起来就完事了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一天后，产品小姐姐又提了另一个需求，bar 组件需要支持修改宽度。没办法，接着改，不能让产品小姐姐看不起！于是你的代码可能变成了这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; renderForm = &lt;span&gt;(&lt;span&gt;{type}&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(type === &lt;span&gt;&#x27;line&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Item&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;name&quot;&lt;/span&gt; &lt;span&gt;label&lt;/span&gt;=&lt;span&gt;&quot;名称&quot;&lt;/span&gt; &lt;span&gt;rules&lt;/span&gt;=&lt;span&gt;{[{&lt;/span&gt; &lt;span&gt;required:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;message:&lt;/span&gt; &#x27;请输入&#x27; }]}&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Input&lt;/span&gt; &lt;span&gt;placeholder&lt;/span&gt;=&lt;span&gt;&quot;请输入&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;Item&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  )&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(type === &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Item&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;width&quot;&lt;/span&gt; &lt;span&gt;label&lt;/span&gt;=&lt;span&gt;&quot;宽度&quot;&lt;/span&gt; &lt;span&gt;rules&lt;/span&gt;=&lt;span&gt;{[{&lt;/span&gt; &lt;span&gt;required:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;message:&lt;/span&gt; &#x27;请输入&#x27; }]}&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;Input&lt;/span&gt; &lt;span&gt;placeholder&lt;/span&gt;=&lt;span&gt;&quot;请输入&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;Item&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  )&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Form&lt;/span&gt; &lt;span&gt;form&lt;/span&gt;=&lt;span&gt;{form}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  {renderForm()}&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;Form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着，产品小姐姐的需求与日增多，组件数量也越来越庞大，你的 if else 越写越多....。所以我们需要一个统一的&lt;strong&gt;配置器&lt;/strong&gt;，和一个统一的描述组件配置的 &lt;strong&gt;schema&lt;/strong&gt; 文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说组件的 schema 文件，每一个组件都配带一个 schema 文件，schema 里主要记录当前组件支持修改的配置项（fields），和当前组件配置项的默认值（models）。类似这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt; &lt;span&gt;&quot;fields&quot;&lt;/span&gt;: [{&lt;br/&gt;    &lt;span&gt;&quot;label&quot;&lt;/span&gt;: &lt;span&gt;&quot;名称&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;input&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;br/&gt;  }],&lt;br/&gt; &lt;span&gt;&quot;models&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;默认名称&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当点击一个组件的编辑按钮时，根据组件类型获取到对应的 schema 文件，将组件配置项默认值 models 和从后端拿到的数据，做一个 merge，将 merge 后的数据和 fieds 传给配置器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置器要做的工作就是，根据 fileds 动态渲染表单，关于表单动态渲染，我们团队有一篇不错的文章《表单数据形式配置化设计》(https://juejin.cn/post/7119639489567260686),大家有兴趣可以参考下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下编辑侧的工作，第一步，拿到对应组件的 schema 文件，传给配置器。第二步，配置器根据 fileds 动态渲染表单，并根据后端返回数据和 schema 中的默认数据，用作表单回显。最后就是，搭建用户修改配置项，再把修改后的数据发送给后端保存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五、从远程组件商店加载组件&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上已经完成了配置的产出、使用和修改。接下来我们再思考思考组件。我们现在的组件都是存在本地的，后期随着组件数量的增多，页面 js 文件肯定会越来越大，即使你使用了代码分割，也不可避免会导致 build 后的包体积越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要一个远端存放组件的地方，也就是&lt;strong&gt;组件商店&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么商店既然是远端的，那把这个商店建在哪里呢？我们团队的解决方案就是，把每个组件打上版本号上传到静态服务器上这样，版本号的作用这里先不管，这样不管在编辑侧还是用户侧，我们可以根据项目的配置数据远程加载组件，关于远程组件的加载方案，可以参考下我们团队另一篇写的不错的文章《浅谈低代码平台远程组件加载方案》(https://juejin.cn/post/7127440050937151525)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，一个组件商店不仅于此，我们目前只实现了一些基本功能，一个完整的组件商店功能包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;组件线上编辑(上传)模块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件审核模块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件更新/发布模块。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组件管理(上架/下架/删除/下载/版本)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;六、静态化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们在编辑侧修改提交，用户侧就能实时地得到修改后的配置了，对应的页面刷新就会变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是这样会导致一个问题，假设以前的老版本 v1.0 需要修改到新版本 v2.0，并且工作量很大，需要两天才能完成，那么你第一天只能改一半，第二天早上你准备改另一半的时候，可能你们公司的投诉电话已经被打爆了，因为，你的客户早上打开页面的时候，是你第一天只改了一半配置的页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么解决这个问题呢？答案是增加一个发布操作，只有发布过后，你修改的配置才会在用户侧生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样还是会有问题，假设你在项目 B 修改了一个组件，该组件在项目 A 也用到了，那一旦该组件引发了 bug，项目 A，项目 B都发出问题，如果是十几个项目，那就会引起十几个项目的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，我们需要思考一种方法，针对发布过后的项目，即使对应组件有修改，也不会影响到它们，我们团队使用的解决方案就是&lt;strong&gt;组件静态化&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致思路就是，发布时，首先获取对应的项目配置，根据项目配置获取组件列表。然后根据列表，获取远程组件商店的 js 文件，将获取到的 js 文件插入到对应的 html 模版中。最后，将拼装好的 html 放到静态服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，后续用户侧只需要访问静态服务器上的 html 就可以了，即使组件也修改，已发布的项目只要不重新发布，就不会影响已经发布的项目。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;Tips: 进一步的话，我们可以把项目配置也做成静态化，这样，第一可以省去后端同学同步两份不同环境数据的工作量，但对于前端来说，就是顺手的事。第二，方便前端自己管理已发布的配置数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果组件修改，后续已发布的项目也需要重新发布呢？怎么尽量减少发布风险呢？这个就需要做组件的版本管理和容器的版本管理了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;七、组件和容器的版本管理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们在介绍组件商店的时候说到，上传组件的时候，我们给对应组件打上了版本号，后续组件有修改的时候，修改过的组件，会被打上新的版本号。这样，针对已发布的项目，只要不更新对应组件的版本号，便不会影响对应的项目组件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么要做容器的版本管理呢？前面我们介绍了组件容器的作用就是处理组件的通用逻辑，如果说组件的修改&lt;strong&gt;有可能&lt;/strong&gt;会影响到其他项目，那么组件容器的修改就是&lt;strong&gt;一定会&lt;/strong&gt;影响到其他项目。所以容器的版本管理比组件的版本管理更加重要。思路其实跟组件差不多，我们可以把容器理解成一个特殊的组件，跟组件不同的是，这个组件不在配置文件解析出来的组件列表中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;八、组件之间的通信&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的搭建场景中，避免不了的就是，组件之间需要通信，比如，点击组件 A，组件 B 需要做出对应的响应。我们在这里借鉴的是【发布-订阅】。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们设计一个事件调度中心，可以处理所有的事件注册与事件响应。订阅者发布对应的事件，事件调度中心负责将事件放入事件池中。发布者负责在对应的时机触发对应事件，上面例子中，组件 A 就是发布者，当组件 A 被点击的时候，就是触发事件的对应时机。事件在调度中心出发后，再将结果反馈给订阅者。订阅者拿到反馈结果做出行为。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39957716701902746&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sticlevzdTIA19vT8edryDYdCp7ZzRBBCXZ0pHE2twUrC8qLWfFsc4cOU56w8YxK53vkIjvsEPb9TNb0QhQ6VvA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于事件的配置描述的数据结构，形式有很多种，这里贴一份我们目前项目中使用的数据结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;publish&lt;/span&gt;:[ &lt;span&gt;// 事件发布&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;      &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;电子卖场预警发布/流程/onChange&quot;&lt;/span&gt;, &lt;span&gt;// 发布事件名&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;reflectName&lt;/span&gt;: &lt;span&gt;&quot;onChange&quot;&lt;/span&gt; &lt;span&gt;// 什么行为触发该事件&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt; ],&lt;br/&gt;  &lt;span&gt;subscribe&lt;/span&gt;: [  &lt;span&gt;// 事件订阅&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;      &lt;span&gt;list&lt;/span&gt;: [&lt;span&gt;&quot;电子卖场预警发布/onChange&quot;&lt;/span&gt;], &lt;span&gt;// 订阅的事件集合&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;action&lt;/span&gt;: &lt;span&gt;&quot;setClass&quot;&lt;/span&gt;, &lt;span&gt;// 事件行为，就是你订阅的事件被触发后，你要干什么&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;handler&lt;/span&gt;: &lt;span&gt;&quot;function parse(params) {↵ return {};↵ }&quot;&lt;/span&gt; &lt;span&gt;// 结合事件行为与该事件的返回值，组件做出自身行为&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;九、参考&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、《如何设计可视化搭建平台的组件商店》(https://juejin.cn/post/6986824393653485605)&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>