<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e966677c2f9bee21e4ca708cae9da564</guid>
<title>RedisJson 横空出世，这性能杀疯了！</title>
<link>https://toutiao.io/k/y4wdv6t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期官网给出了RedisJson（RedisSearch）的性能测试报告，可谓碾压其他NoSQL，下面是核心的报告内容，先上结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于隔离写入(isolated writes)，RedisJSON 比 MongoDB 快 5.4 倍，比 ElasticSearch 快 200 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于隔离读取(isolated reads)，RedisJSON 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在混合工作负载场景中，实时更新不会影响 RedisJSON 的搜索和读取性能，而 ElasticSearch 会受到影响。以下是具体的数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 支持的操作数/秒比 MongoDB 高约 50 倍，比 ElasticSearch 高 7 倍/秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 的延迟比 MongoDB 低约 90 倍，比 ElasticSearch 低 23.7 倍。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON 的读取、写入和负载搜索延迟在更高的百分位数中远比 ElasticSearch 和 MongoDB 稳定。当增加写入比率时，RedisJSON 还能处理越来越高的整体吞吐量，而当写入比率增加时，ElasticSearch 会降低它可以处理的整体吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、查询引擎&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，reresearch和RedisJSON的开发非常强调性能。对于每一个版本，我们都想确保开发者可以体验到稳定和产品。为此，我们我们给出了一些分析工具、探测器来进行性能分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，我们每次发行新版本时时，也在不断的提升性能。特别是对于reresearch来说，2.2版本在加载和查询性能上都比2.0快了1.7倍，同时还改进了吞吐量和数据加载的延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 加载优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的两个图显示了运行纽约市出租车基准测试的运行结果&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOouUUmLMqP94KHoG85Mpgbawqb3lXIN8UyVAfS5bJ36bRnGomLcMRTZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo2QA3eUh1wNVHB9BrptR4y68ibjYicglGW1VCLraaN1errGw3ChXDrYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这些图表中可以看出，每一个reresearch的新版本都有一个实质性的性能改进。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 全文搜索优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估搜索性能，我们索引了590万篇维基百科摘要。然后我们运行一个全文搜索查询面板，得到的结果如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.583791895947974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoQ1bib9tUV4VWib0uXLP99O5Zv0xKzCBlwVr0LM1ngpHXmibB1eMTbstOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoVnXV6q7ibg0IwMR40f64ia5HsWzREt0fBjuFAejFrgFq2T7Z7N7ibz5PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图可以看出，通过从v2.0迁移到v2.2，同样的数据，在写、读、搜索(延迟图)方面都有了大幅度的改进，从而提高了运行Search和JSON的可实现吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、和其他框架的对比&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估RedisJSON的性能，我们决定将它与MongoDB和ElasticSearch进行比较。为了方便对比，我们会从文档存储、本地可用、云中可用、专业支持和提供可伸缩性、性能等方面进行全方位的对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用了完善的YCSB标准来进行测试对比，它能够基于常见的工作负载来评估不同的产品，测量延迟、吞吐量曲线直到饱和。除了CRUD YCSB操作之外，我们还添加了一个两个字的搜索操作，专门帮助开发人员、系统架构师和DevOps从业者找到适合他们用例的最佳搜索引擎。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 基准测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次测试，我们使用了如下的一些软件环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MongoDB v5.0.3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch 7.15&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON (RediSearch 2.2+RedisJSON 2.0)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次是在Amazon Web Services 实例上运行基准测试，这三种解决方案都是分布式数据库，并且最常用于生产中的分布式方式。这就是为什么所有产品都使用相同的通用 m5d.8xlarge VM 和本地 SSD，并且每个设置由四个 VM 组成：一个客户端 + 三个数据库服务器。基准测试客户端和数据库服务器都在处于最佳网络条件下的单独 m5d.8xlarge 实例上运行，将实例紧密地打包在一个可用区内，实现稳态分析所需的低延迟和稳定的网络性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试是在三节点集群上执行的，部署细节如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MongoDB 5.0.3&lt;/code&gt;：三成员副本集（Primary-Secondary-Secondary）。副本用于增加读取容量并允许更低的延迟读取。为了支持对字符串内容的文本搜索查询，在搜索字段上创建了一个文本索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ElasticSearch 7.15&lt;/code&gt;：15 个分片设置，启用查询缓存，并为 2 个基于 NVMe 的本地 SSD 提供 RAID 0 阵列，以实现更高级别的文件系统相关弹性操作性能。这 15 个分片为我们为 Elastic 所做的所有分片变体提供了可实现的最佳性能结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;RedisJSON*&lt;/code&gt;：RediSearch 2.2 and RedisJSON 2.0: OSS Redis Cluster v6.2.6，有27个分片，均匀分布在三个节点上，加载了RediSearch 2.2和RedisJSON 2.0 OSS模块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个主要的基准/性能分析场景之外，我们还在网络、内存、CPU 和 I/O 上运行基准基准测试，以了解底层网络和虚拟机特性。在整个基准测试集期间，网络性能保持在带宽和 PPS 的测量限制以下，以产生稳定稳定的超低延迟网络传输（每个数据包 p99 &amp;lt; 100micros）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们将从提供单独的操作性能 [100% 写入] 和 [100% 读取] 开始，并以一组混合工作负载结束以模拟现实工作中的应用程序场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 100% 写入基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，该基准测试表明，RedisJSON* 的摄取速度比 ElasticSearch 快 8.8 倍，比 MongoDB 快 1.8 倍，同时保持每个操作的亚毫秒级延迟。值得注意的是，99% 的 Redis 请求在不到 1.5 毫秒的时间内完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON* 是我们测试过的唯一一种在每次写入时自动更新其索引的解决方案。这意味着任何后续的搜索查询都会找到更新的文档。ElasticSearch 没有这种细粒度的容量；它将摄取的文档放在一个内部队列中，并且该队列由服务器（不受客户端控制）每 N 个文档或每 M 秒刷新一次。他们称这种方法为近实时 (NRT)。Apache Lucene 库（它实现了 ElasticSearch 的全文功能）旨在快速搜索，但索引过程复杂且繁重。如这些 WRITE 基准测试图表所示，由于这种“设计”限制，ElasticSearch 付出了巨大的代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合延迟和吞吐量改进，RedisJSON* 比 Mongodb 快 5.4 倍，比 ElasticSearch 快 200 倍以上，用于隔离写入。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo611nYGmaGGrcVeWIiaMTxFOhlSibia3uibp6RJzBIWhsMcJHGSHRCl5GnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoY4jdTU9WZ3ibIpicV9VothEic8RZDKh3aia9WEybIMicaI70jusuXpoMe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 100% 读取基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与写类似，我们可以观察到 Redis 在读取方面表现最佳，允许读取比 ElasticSearch 多 15.8 倍，比 MongoDB 多 2.8 倍，同时在整个延迟范围内保持亚毫秒级延迟，如下表所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在结合延迟和吞吐量改进时，RedisJSON* 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上，用于隔离读取。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo6TfKUcIy5oaI2pqQgoQnC0CBXDw6TukKDaBqkZBmjRAU6sFHHI1z6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.618421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOovwFn6X4ALlkicQX45iallAqcaXDV7WzEFFDWTSfN5hWQxBWSSV0Jk6oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1520&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 混合读/写/搜索基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际应用程序工作负载几乎总是读取、写入和搜索查询的混合。因此，在接近饱和时了解由此产生的混合工作负载吞吐量曲线更为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为起点，我们考虑了 65% 搜索和 35% 读取的场景，这代表了一个常见的现实世界场景，在该场景中，我们执行的搜索/查询比直接读取更多。65% 搜索、35% 读取和 0% 更新的初始组合也导致 ElasticSearch 和 RedisJSON* 的吞吐量相等。尽管如此，YCSB 工作负载允许您指定搜索/读取/更新之间的比率以满足您的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“搜索性能”可以指不同类型的搜索，例如“匹配查询搜索”、“分面搜索”、“模糊搜索”等等。我们所做的最初向 YCSB 增加的搜索工作负载仅专注于“匹配查询搜索”，模仿分页的两词查询匹配，按数字字段排序。“匹配查询搜索”是任何启用搜索功能的供应商进行搜索分析的起点，因此，每个支持 YCSB 的数据库/驱动程序都应该能够在其基准驱动程序上轻松启用此功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个测试变体中，我们添加了 10% 的写入，以按相同的比例混合和减少搜索和读取百分比。这些测试变体的目标是了解每个产品如何处理数据的实时更新，我们认为这是事实上的架构目标，即写入立即提交到索引，读取始终是最新的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6423444976076556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo0yed0ibm9bF1AplAt4TgcS42aFwUfR28C1tCuC4484bypMia942nGOTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1672&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如您在图表中所看到的，在 RedisJSON* 上不断更新数据和增加写入比例不会影响读取或搜索性能并提高整体吞吐量。对数据产生的更新越多，对 ElasticSearch 性能的影响就越大，最终导致读取和搜索速度变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ElasticSearch 可实现的 ops/sec 从 0% 更新到 50% 的演变，我们注意到它在 0% 更新基准上以 10k Ops/sec 开始，并受到严重影响，减少了 5 倍的 ops/sec，在50% 更新率基准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与我们在上述单个操作基准中观察到的类似，MongoDB 搜索性能比 RedisJSON* 和 ElasticSearch 慢两个数量级，MongoDB 的最大总吞吐量为 424 ops/sec，而 RedisJSON* 为 16K 最大 ops/sec。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，对于混合工作负载，RedisJSON* 支持的操作数/秒比 MongoDB 高 50.8 倍，比 ElasticSearch 高 7 倍。如果我们将分析集中在混合工作负载期间的每种操作类型的延迟上，与 MongoDB 相比，RedisJSON* 可将延迟降低多达 91 倍，与 ElasticSearch 相比，延迟降低 23.7 倍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5 完整延迟分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与测量每个解决方案饱和之前产生的吞吐量曲线类似，在所有解决方案通用的可持续负载下进行完整的延迟分析也很重要。这将使您能够了解对于所有已发布操作在延迟方面最稳定的解决方案是什么，以及哪种解决方案不易受到应用程序逻辑引发的延迟峰值的影响（例如，弹性查询缓存未命中）。如果您想更深入地了解我们为什么要这样做，Gil Tene 提供了延迟测量注意事项的深入概述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看上一节的吞吐量图表，并关注 10% 更新基准以包含所有三个操作，我们做了两种不同的可持续负载变化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;250 ops/sec&lt;/code&gt;：比较 MongoDB、ElasticSearch 和 RedisJSON*，低于 MongoDB 的压力率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;6000 ops/sec&lt;/code&gt;：比较 ElasticSearch 和 RedisJSON*，低于 ElasticSearch 压力率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.1 MongoDB 与 ElasticSearch 与 RedisJSON* 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的第一张图片中，展示了从 p0 到 p9999 的百分位数，很明显，在每次搜索时，MongoDB 的表现都远远优于 Elastic 和 RedisJSON&lt;em&gt;。此外，关注 ElasticSearch 与 RedisJSON&lt;/em&gt;，很明显，ElasticSearch 容易受到较高延迟的影响，这很可能是由垃圾收集 (GC) 触发器或搜索查询缓存未命中引起的。RedisJSON* 的 p99 低于 2.61 毫秒，而 ElasticSearch p999 搜索达到 10.28 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoSIgCOft3OEc0H9BW2zQQyF1diamfHdHXyxFxgBfIvy6lSBM6Ldhnu6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的读取和更新图表中，我们可以看到 RedisJSON* 在所有延迟范围内表现最佳，其次是 MongoDB 和 ElasticSearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 是在所有分析的延迟百分位数上保持亚毫秒级延迟的唯一解决方案。在 p99，RedisJSON* 的延迟为 0.23 毫秒，其次是 MongoDB 的 5.01 毫秒和 ElasticSearch 的 10.49 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoJN5FLx51FRmGNXYV4cJHPr2lHpha5T9RYtfZWjGnaXy5zmFw0D7k3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入时，MongoDB 和 RedisJSON* 即使在 p99 时也能保持亚毫秒级的延迟。另一方面，ElasticSearch 显示出高尾延迟（&amp;gt; 10 毫秒），这很可能与导致 ElasticSearch 搜索峰值的原因 (GC) 相同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoAicsbeISKwnTjxmRicsZ6RWjcVpib7Q32nB05bhgtc1MuHGnzoUXbzA8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.2 ElasticSearch 与 RedisJSON 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅关注 ElasticSearch 和 RedisJSON&lt;em&gt;，在保持 6K ops/sec 的可持续负载的同时，我们可以观察到 Elastic 和 RedisJSON&lt;/em&gt; 的读取和更新模式与以 250 ops/sec 进行的分析保持一致。RedisJSON* 是更稳定的解决方案，其 p99 读取时间为 3 毫秒，而 Elastic 的 p99 读取时间为 162 毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新时，RedisJSON* 保留了 3 毫秒的 p99，而 ElasticSearch 则保留了 167 毫秒的 p99。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoLoJVvKgRRI3rmCNLzUjCvpk1MA5l6Ioxqm7dPF6qf2vrqoSIQ2hgOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOohq9AdiaxdPAohSbybaM0Iwey2nQD6GEt0v1nwW8oxnhic8fzcdhBGvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专注于搜索操作，ElasticSearch 和 RedisJSON* 以个位数 p50 延迟开始（p50 RedisJSON* 为 1.13 毫秒，而 ElasticSearch 的 p50 为 2.79 毫秒），其中 ElasticSearch 付出了 GC 触发和查询缓存未命中的代价在较高的百分位数上，在 &amp;gt;= p90 百分位数上清晰可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 将 p99 保持在 33 毫秒以下，而 ElasticSearch 上的 p99 百分位数为 163 毫秒，高出 5 倍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoKUACUUMo6ttA42WSADP4nRFwA1PsibTDibRpwGAj7g5bnicy3BW0K56qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、如何开始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始使用RedisJSON*，我们可以创建一个免费的数据库在所有地区的Redis云，或者使用RedisJSON docker容器。我们已经更新了redisjson的文档，以方便开发者快速的开始使用查询和搜索功能。此外，正如我们在最近的客户机库声明中提到的，以下是几种流行语言的客户机驱动程序，可以帮助您快速入门。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;RedisJSON*&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Node.js&lt;/td&gt;&lt;td&gt;node-redis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;Jedis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET&lt;/td&gt;&lt;td&gt;NRedisJSON NRediSearch&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;&lt;td&gt;redis-py&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>99ca66fcc49e4d9f2325fbe3bfdec968</guid>
<title>看Go中的struct如何被优化，还有小插曲</title>
<link>https://toutiao.io/k/zv2dasc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;struct中的字段顺序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下面的结构为例，咱们看看下面的结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;       &lt;span&gt;// Sizeof: 8 byte  Alignof: 8  Offsetof: 0&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 8&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 16&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 32&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 48&lt;/span&gt;&lt;br/&gt;    Created     time.Time   &lt;span&gt;// Sizeof: 24 byte Alignof: 8  Offsetof: 56&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// output&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的输出可以看出打印结果为 80 字节，但是所有字段加起来是66 字节。那额外的 14 个字节是怎么来的呢？想必大部分同学也很清楚。64 位CPU处理器每次可以以 64 位（8 字节）块的形式传输数据。32 位 CPU的话则是32 位（4 字节）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个字段&lt;code&gt;ID&lt;/code&gt;占用 8 个字节，&lt;code&gt;Gender&lt;/code&gt;字段占用了1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个和第三个字段为字符串类型为16字节，接下来是&lt;code&gt;IsDeleted&lt;/code&gt;字段，它需要 1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好的情况是是按字段的大小从大到小对字段进行排序。对上述结构体进行排序，大小减少到 72 个字节。最后两个字段 &lt;code&gt;Gender&lt;/code&gt; 和 &lt;code&gt;IsDeleted&lt;/code&gt; 被放在同一个块中，从而将未使用的字节数从 14 (2x7) 减少到 6 (1 x 6)，在此过程中节省了 8 个字节。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    CreatedAt   time.Time &lt;span&gt;// 24 bytes&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;     &lt;span&gt;// 8 bytes&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面咱们看看&lt;span&gt;Go 白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;中对字节大小保证的一些说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;span&gt;数字类型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，有下面的大小保证：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;占用字节大小&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte, uint8, int8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint16, int16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint32, int32, float32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint64, int64, float64, complex64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;complex128&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证以下最小对齐属性：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任何类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于struct 类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;是所有字段字节对齐的最大值&lt;code&gt;unsafe.Alignof(x.f)&lt;/code&gt;，但至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量&lt;code&gt;x&lt;/code&gt; ：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;与数组元素类型的变量的对齐方式相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果struct或数组类型不包含大小大于零的字段（或元素），则其大小为零。两个不同的零大小变量在内存中可能具有相同的地址。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出占用小于8 字节的 Go 类型有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;bool：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int8/uint8：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int16/uint16：2 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int32/uint32/rune：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;float32：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte：1个字节&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么你知道了这些小于8字节的类型，要手动检查他的大小然后对其进行排序嘛，NONONO，小土下面给大家推荐一个&lt;code&gt;linter&lt;/code&gt; &lt;span&gt;fieldalignment&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;来检查并进行正确地排序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;fieldalignment 小工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里小土给大家介绍一个检测和对齐结构体字段的小工具&lt;code&gt;fieldalignment&lt;/code&gt;,顾名思义就是&lt;strong&gt;字段对齐&lt;/strong&gt;的意思。下面让我们在项目中安装和运行一下&lt;code&gt;fieldalignment&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先别着急运行，咱们先来看下filedalignment的使用，fieldalignment可以找到那些可以重新排列以减少内存的结构，并提供
建议编辑最紧凑的顺序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ fieldalignment&lt;br/&gt;fieldalignment: find structs that would use less memory &lt;span&gt;if&lt;/span&gt; their fields were sorted&lt;br/&gt;&lt;br/&gt;Usage: fieldalignment [-flag] [package]&lt;br/&gt;&lt;br/&gt;This analyzer find structs that can be rearranged to use less memory, and provides&lt;br/&gt;a suggested edit with the most compact order.&lt;br/&gt;&lt;br/&gt;Note that there are two different diagnostics reported. One checks struct size,&lt;br/&gt;and the other reports &lt;span&gt;&quot;pointer bytes&quot;&lt;/span&gt; used. Pointer bytes is how many bytes of the&lt;br/&gt;object that the garbage collector has to potentially scan &lt;span&gt;for&lt;/span&gt; pointers, &lt;span&gt;for&lt;/span&gt; example:&lt;br/&gt;&lt;br/&gt;        struct { uint32; string }&lt;br/&gt;&lt;br/&gt;have 16 pointer bytes because the garbage collector has to scan up through the string&lt;span&gt;&#x27;s&lt;br/&gt;inner pointer.&lt;br/&gt;&lt;br/&gt;        struct { string; *uint32 }&lt;br/&gt;&lt;br/&gt;has 24 pointer bytes because it has to scan further through the *uint32.&lt;br/&gt;&lt;br/&gt;        struct { string; uint32 }&lt;br/&gt;&lt;br/&gt;has 8 because it can stop immediately after the string pointer.&lt;br/&gt;&lt;br/&gt;Be aware that the most compact order is not always the most efficient.&lt;br/&gt;In rare cases it may cause two variables each updated by its own goroutine&lt;br/&gt;to occupy the same CPU cache line, inducing a form of memory contention&lt;br/&gt;known as &quot;false sharing&quot; that slows down both goroutines.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Flags:&lt;br/&gt;  -V    print version and exit&lt;br/&gt;  -all&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -c int&lt;br/&gt;        display offending line with this many lines of context (default -1)&lt;br/&gt;  -cpuprofile string&lt;br/&gt;        write CPU profile to this file&lt;br/&gt;  -debug string&lt;br/&gt;        debug flags, any subset of &quot;fpstv&quot;&lt;br/&gt;  -fix&lt;br/&gt;        apply all suggested fixes&lt;br/&gt;  -flags&lt;br/&gt;        print analyzer flags in JSON&lt;br/&gt;  -json&lt;br/&gt;        emit JSON output&lt;br/&gt;  -memprofile string&lt;br/&gt;        write memory profile to this file&lt;br/&gt;  -source&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -tags string&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -test&lt;br/&gt;        indicates whether test files should be analyzed, too (default true)&lt;br/&gt;  -trace string&lt;br/&gt;        write trace log to this file&lt;br/&gt;  -v    no effect (deprecated)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看帮助的说明这里小土总结一下fieldalignment的介绍：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fieldalignment 会有两个不同的报告，一个是检查结构体的大小。另一个报告所使用的指针字节数(是指gc会对struct中的这些字节进行潜在的指针扫描)。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;struct { uint32; string } ：16个指针字节，gc会扫描字符串的内部指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; *uint32 } : 24个指针字节，gc会进一步扫描 *uint32。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; uint32 }：8个指针字节，因为扫描到string会立马停止。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出最紧凑的顺序并不总是最有效的。在极少数情况下，它可能会导致两个变量分别被自己的goroutine更新占用同一个CPU缓存线，从而引起一种被称为 &quot;假共享 &quot;的内存争夺。这样会降低了两个goroutine的速度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;运行fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土在项目中使用了&lt;code&gt;fieldalignment&lt;/code&gt;命令，可以看出检测出不少的不符合排序规则的struct，而且&lt;code&gt;fieldalignment&lt;/code&gt;将未对齐的字段进行了重新排序，再次执行可以看到就没有相关的提示了。从下面的检测信息中大家也可以看出未对齐的&lt;code&gt;struct&lt;/code&gt;中有8-64字节的空间浪费。&lt;code&gt;struct&lt;/code&gt;较多的项目，算下来也是一笔不小的开销(8B*1024=8K,觉得这些内存占用微不足道的同学也可以忽略哈)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$fieldalignment&lt;/span&gt; -fix ./...        &lt;br/&gt;... &lt;span&gt;# 前面代码就省略了&lt;/span&gt;&lt;br/&gt;struct with 2568 pointer bytes could be 2560&lt;br/&gt;struct with 56 pointer bytes could be 48&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct of size 80 could be 72&lt;br/&gt;struct with 200 pointer bytes could be 176&lt;br/&gt;struct with 104 pointer bytes could be 72&lt;br/&gt;struct with 80 pointer bytes could be 72&lt;br/&gt;struct with 32 pointer bytes could be 24&lt;br/&gt;struct with 40 pointer bytes could be 32&lt;br/&gt;struct with 104 pointer bytes could be 40&lt;br/&gt;struct with 72 pointer bytes could be 56&lt;br/&gt;struct of size 256 could be 248&lt;br/&gt;struct with 64 pointer bytes could be 48&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment的小bug&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过小土前面一顿操作执行，在准备commit的时候发现之前struct中的注释居然变没了，于是小土也给Go官方提了一个小issue，&lt;span&gt;https://github.com/golang/go/issues/54333&lt;/span&gt;，都好几天了也都没给回复，sad😭，看来这问题有点微不足道。希望在大家使用&lt;code&gt;fieldalignment&lt;/code&gt;的时候注意这一点，小土是在fix之后进行了一些注释恢复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，小土开始对struct中的字段字节对齐做了一些分析并推荐了一个对struct中的字段顺序错乱fix的工具fieldalignment。希望今天的文章对大家有一些帮助，如有相关看法欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Go 白皮书: &lt;em&gt;https://go.dev/ref/spec#Size_and_alignment_guarantees&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;数字类型: &lt;em&gt;https://go.dev/ref/spec#Numeric_types&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;fieldalignment: &lt;em&gt;https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03f9ddb7fd8f282f6a57ada300643fca</guid>
<title>go错误处理的一种实践</title>
<link>https://toutiao.io/k/oqb90id</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近写了个程序，因为是急活（貌似没有不急的...），所以这个程序又是我东拷一段，西粘一块拼出来的。代码写完了后，感觉这代码屎一样，都快把自己看哭了。真的是在心里边写别骂，先是骂以前做这个项目的人蠢，项目搞的跟屎一样，后来代码跑起来了，顺利交工后，变成了骂我自己蠢，这么写又不是不能用！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5616161616161616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicIFviaPQ7ACCjbrNlyFRqlKKia5fmgxWZWGWY6a17gH7RaliaSDKma7KkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;figcaption&gt;又不是不能用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在这个过程中，先不提项目里的业务逻辑、接口设计合不合理的事儿，这个我觉得在时间紧，加上人员更迭快的时候，正常人都会能粘就粘，不行了就再包一层，别改出线上问题了就行。有一点我把自己蠢哭的是，Go 的这个错误处理也太TM蠢了，一个程序我写了七八个错误判断，我给你们用伪代码描述一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;err, file :=  接收传文件(文件)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, fh :=  打开上传文件(file)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data := 把文件里的行记录解析/转换一下(row)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data3 := 调一下第三方接口拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data2 := 调一下内部其他服务拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err := 写库&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子毫不夸张，我相信各位在自己的项目里一定见过，如果你是做业务开发的会更常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有人肯定会问，Go的错误处理就这样你难道第一天见吗，还能被蠢哭。诶，这不是降本提效后人员少了一半，我们这帮级别没混上去的虚线Leader，这不又开始自己写代码了嘛，以前蠢又蠢不到自己。再加上以前的系统、项目分层、服务隔离整的还凑活，不会像上面这样，在控制层调这么多业务对象，把蠢瓜代码集中在了一起…… 官感马上不一样了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎我就在思考，有没有什么设计模式什么的，能把这些东西隐藏下去，应该有吧，没有什么是包一层代码解决不了的吧，实在不行就包两层……诶，咋一不小心把设计模式的精髓给说出来了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 优雅处理错误的几种方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这几天在网上看了不少说，Go 错误处理的，但基本上都是说怎么自定义包装 error 、传递error 之类的，讲怎么在写 Go 代码时能更优雅更好看的文章比较少，写的最好的是左耳朵耗子老师在自己博客里介绍的两种方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;下面的部分代码参考自老师的博客：https://coolshell.cn/articles/21140.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是用函数式编程的 Closure 把相同的 if err !=nil 之类的代码抽象出来重新定义一个函数，但是这种方式会导致新的问题--在每个函数里都需要引入内部函数和一个 error 变量，所以咱就不多说了，有兴趣的可以去原博文查看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接介绍另外一种更好的，对项目侵入不是很大的方案给大家。在 Go 语言官方库 &lt;code&gt;bufio&lt;/code&gt; 中 &lt;code&gt;Scanner&lt;/code&gt;对象的错处理的实现方式可以给我们一点启发，它大概是这么实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scanner := bufio.NewScanner(input)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; scanner.Scan() {&lt;br/&gt;    token := scanner.Text()&lt;br/&gt;    &lt;span&gt;// process token&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err := scanner.Err(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// process the error&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码我们可以看到，&lt;code&gt;scanner&lt;/code&gt;在操作底层的I/O的时候，那个for-loop中没有任何的 &lt;code&gt;if err !=nil&lt;/code&gt; 的情况，退出循环后有一个 &lt;code&gt;scanner.Err()&lt;/code&gt; 的检查。看来使用了结构体的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下 &lt;code&gt;Scanner&lt;/code&gt;类型的定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Scanner &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; r            io.Reader&lt;br/&gt;  ...&lt;span&gt;//其他字段省略&lt;/span&gt;&lt;br/&gt; err          error    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类型内部持有一个&lt;code&gt;error&lt;/code&gt; 在迭代执行 Scan 方法时，遇到错误后会往这个 error 中记录错误。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Scan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ...&lt;span&gt;// 其余代码省略&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    s.setErr(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; s.err == io.EOF {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s.err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以参考这个思路继续搞下去。比如来一个读取业务对象的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.0905797101449277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPiclkub7qO0hvlyqqop6sdYicVSXLY83m6F4jedVFqFuCgZUWZMuOdssqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个示例相信大家很容易看懂，不过，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理，对于多个业务对象的话，还是得需要各种 &lt;code&gt;if err != nil&lt;/code&gt;的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法呢，咱们之前说过一次：没有什么是包一层代码解决不了的吧，实在不行就包两层。那么接下来我们再做一层包装，以下是我对解决这个问题的一点点理解，会借鉴一点DDD中分层的概念解决这个事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更容易落地的方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才那个例子的问题是只适合减少单个业务对象逻辑操作中的 if err != nill 判断，那么针对这块呢，咱们可以把涉及多个业务对象的操作放在一个应用服务里，把刚才在业务对象做的错误处理判断拿到应用服务里，这样业务对象里，比如Model之类的下层模块里，就还能按照正常的流程写代码了，不用每个方法开头都要先判断一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提前说一下，在一些架构设计里会分应用服务和领域服务，这两者的概念完全不一样，应用服务是面向产品需求的用例实现的，负责业务用例流的任务协调，就是我们实现API时，往往会控制层调应用服务，多个不同的业务对象可以放到一个应用服务里。而领域服务是专一给一个领域的，这块我就不多解释了，DDD这些我也是看了几本书，看过COLA框架的实现，还在似懂非懂的水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之记住一点，通过应用服务可以协调多个业务对象执行任务，同时我们上面业务对象加的那些错误处理抽离到应用服务层里，让业务对象更专注自己的职责。这样的话，你的服务层代码，可能就得变成了这样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7468531468531467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicLT9DGCBN8n1SS9yt6xCe1Zkq3WafDmHws5Kx3RF1hmFO2CD22jibtww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们的控制层呢，调用应用服务层拿到结果，并且在这个时候判断整个需求任务执行的过程中有没有错误，有的话记录错误，返回错误响应给客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7300177619893428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPic8TuLH1LiaDZKvRLQJVtfTRdqsZVCzyKtfOITGkkCh3DyjhOOKiaMzG5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 错误处理的基础&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前分享过一篇文章  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247489442&amp;amp;idx=1&amp;amp;sn=1805944e5acbe8629fdfa534c53a27dd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;关于Go程序错误处理的一些建议&lt;/a&gt; 说的是我们应该怎么用好 Go 的error 接口，自定义错误，包装整个错误链等相关的技能。跟本文的内容关联起来看，可能会对错误处理有个更全局的理解，在这里也推荐给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享了一些在让Go代码的错误处理更优雅上，我学到和&lt;span data-change-font=&quot;1&quot;/&gt;想到的一些东西。其实大家可以发现，我们是把多个 if err != nil 分散到了多个方法里，这样代码最起码从感官上看起来比在一个方法里写七八个错误判断更好一点。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对错误处理方面你有哪些见解呢，欢迎在评论区里积极发言，喜欢这篇文章还请帮忙来个点赞在看加分享吧，接下来内容还在向你们招手🙋‍♂️。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e7d93e2f2bcd53ad69f84a1d65a48af</guid>
<title>一文看懂大数据生态圈完整知识体系（文末赠书）</title>
<link>https://toutiao.io/k/j95wj12</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-alias=&quot;zhiming_data&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;新书推荐，先看看正文介绍，文末赠书2本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;635&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着大数据行业的发展，大数据生态圈中相关的技术也在一直迭代进步，作者有幸亲身经历了国内大数据行业从零到一的发展历程，通过本文希望能够帮助大家快速构建大数据生态圈完整知识体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前大数据生态圈中的核心技术总结下来如图1所示，分为以下9类，下面分别介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;314&quot; data-backw=&quot;562&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;291&quot; data-ratio=&quot;0.5589798087141339&quot; data-type=&quot;png&quot; data-w=&quot;941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6XaT8kkJSbzXTy2icxdzqADqgzibo9MhfPbsHbQI2ueueNibkDXcaaPbVg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;158:346&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据采集技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采集也被称为数据同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着互联网、移动互联网、物联网等技术的兴起，产生了海量数据。这些数据散落在各个地方，我们需要将这些数据融合到一起，然后从这些海量数据中计算出一些有价值的内容。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此时第一步需要做的是把数据采集过来。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;数据采集是大数据的基础，没有数据采集，何谈大数据！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采集技术框架包括以几种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Flume、Logstash和FileBeat&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于日志数据实时监控采集，它们之间的细节区别见表1；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Sqoop和Datax&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于关系型数据库离线数据采集，它们之间的细节区别见表2；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Cannal和Maxwell&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于关系型数据库实时数据采集，它们之间的细节区别见表3。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47286012526096033&quot; data-type=&quot;png&quot; data-w=&quot;958&quot; data-backw=&quot;578&quot; data-backh=&quot;273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqniccsib9fPTXx9LnBJD8NdrWGicfbnaicJ8icsa08Uo2wujOrMCzpprqdTZg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42250740375123397&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot; data-backw=&quot;578&quot; data-backh=&quot;244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnC1DEGW6yGMv8LEuNnRM5Ur4NS07IQBiaxLLIFIDIO8Mv3icFre7iagI2Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41544477028348&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot; data-backw=&quot;578&quot; data-backh=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqn6YryQHLFhOEesvjNcEZiclDicaX6LUBjqv1fw2h2pdXMhfkDkFJjribFg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Flume、Logstash和FileBeat的技术选型如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;357&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;232&quot; data-ratio=&quot;0.7052896725440806&quot; data-type=&quot;png&quot; data-w=&quot;794&quot; data-backw=&quot;357&quot; data-backh=&quot;252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx63uGZToJNQrgIqqhkkKoEYsMIibiceSVdRfAXe8MYj0MzOvOLBQpv1diaQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Sqoop和Datax之间的技术选型如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;364&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;213&quot; data-ratio=&quot;0.66015625&quot; data-type=&quot;png&quot; data-w=&quot;768&quot; data-backw=&quot;364&quot; data-backh=&quot;240&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6v0Vqc8wxibCNoHxYq41CRqFcIHvMugfEWXNUwRgCJQWFLkzjyJMF8EA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cannal和Maxwell之间的技术选型如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;210&quot; data-ratio=&quot;0.6729222520107239&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; data-backw=&quot;354&quot; data-backh=&quot;238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6MY1tfEued4icp1LQE1JxWiaicQdG9uib5S2Uq0lfjkxgQ5b4FbjYbObr5g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;270:746&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据存储技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据的快速增长推动了技术的发展，涌现出了一批优秀的、支持分布式的存储系统。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;数据存储技术框架包括HDFS、HBase、Kudu、Kafka等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HDFS&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;它可以解决海量数据存储的问题，但是其最大的缺点是不支持单条数据的修改操作，因为它毕竟不是数据库。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HBase&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是一个基于HDFS的分布式NoSQL数据库。这意味着，HBase可以利用HDFS的海量数据存储能力，并支持修改操作。但HBase并不是关系型数据库，所以它无法支持传统的SQL语法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kudu&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是介于HDFS和HBase之间的技术组件，既支持数据修改，也支持基于SQL的数据分析功能；目前Kudu的定位比较尴尬，属于一个折中的方案，在实际工作中应用有限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;常用于海量数据的临时缓冲存储，对外提供高吞吐量的读写能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;258:664&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;分布式资源管理框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的IT领域中，企业的服务器资源（内存、CPU等）是有限的，也是固定的。但是，服务器的应用场景却是灵活多变的。例如，今天临时上线了一个系统，需要占用几台服务器；过了几天，需要把这个系统下线，把这几台服务器清理出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大数据时代到来之前，服务器资源的变更对应的是系统的上线和下线，这些变动是有限的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着大数据时代的到来，临时任务的需求量大增，这些任务往往需要大量的服务器资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果此时还依赖运维人员人工对接服务器资源的变更，显然是不现实的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，分布式资源管理系统应运而生，常见的包括YARN、Kubernetes和Mesos，它们的典型应用领域如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;402&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;112&quot; data-ratio=&quot;0.3933002481389578&quot; data-type=&quot;png&quot; data-w=&quot;806&quot; data-backw=&quot;402&quot; data-backh=&quot;158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6zdlI6GXE0r1HEuq7SZAQmk7xrdsic13bic9KIYmKXF4Od26AKsJnwGqA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;245:670&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据计算技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;数据计算分为离线数据计算和实时数据计算。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）离线数据计算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大数据中的离线数据计算引擎经过十几年的发展，到目前为止主要发生了3次大的变更。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MapReduce&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以称得上是大数据行业的第一代离线数据计算引擎，主要用于解决大规模数据集的分布式并行计算。MapReduce计算引擎的核心思想是，将计算逻辑抽象成Map和Reduce两个阶段进行处理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Tez计算引擎&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在大数据技术生态圈中的存在感较弱，实际工作中很少会单独使用Tez去开发计算程序。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最大的特点就是内存计算：任务执行阶段的中间结果全部被放在内存中，不需要读写磁盘，极大地提高了数据的计算性能。Spark提供了大量高阶函数（也可以称之为算子），可以实现各种复杂逻辑的迭代计算，非常适合应用在海量数据的快速且复杂计算需求中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（2）实时数据计算&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业内最典型的实时数据计算场景是天猫“双十一”的数据大屏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据大屏中展现的成交总金额、订单总量等数据指标，都是实时计算出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户购买商品后，商品的金额就会被实时增加到数据大屏中的成交总金额中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用于实时数据计算的工具主要有以下3种。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spark Streaming&lt;/span&gt;&lt;span&gt;和Storm、Flink之间的区别见表4。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23055555555555557&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;578&quot; data-backh=&quot;133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnk1E8LOn0GfPaAN9AbViaVGU2sqY2waH6fic5WlI8gnL4cD4g5GrrZggQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Storm、Spark、Flink 之间的技术选型如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;398&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;101&quot; data-ratio=&quot;0.35434007134363854&quot; data-type=&quot;png&quot; data-w=&quot;841&quot; data-backw=&quot;398&quot; data-backh=&quot;141&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6DE07erCBzl0ZTAoWoyvfvajuFsHT5QdibNq33PQjJPvQB0eoodpRjug/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前企业中离线计算主要使用Spark，实时计算主要使用Flink。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;222:661&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;5&quot;&gt;5&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据分析技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据分析技术框架包括Hive、Impala、Kylin、Clickhouse、Druid、Doris等，它们的典型应用场景如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;406&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;228&quot; data-ratio=&quot;0.6544117647058824&quot; data-type=&quot;png&quot; data-w=&quot;816&quot; data-backw=&quot;406&quot; data-backh=&quot;266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6RRE5Qic6tLXASrzNF75LA02DfRRKO4clAGMNUUDSZXwLoiafWuDcWKaw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnFCSZy1z2yZ9r5zrqLP9FXKQQsJG3Ihq7ohboUWIlibu7SrEdAzqn1Tw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Hive、Impala和Kylin属于典型的离线OLAP数据分析引擎，主要应用在离线数据分析领域，它们之间的区别见表5。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16342412451361868&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot; data-backw=&quot;578&quot; data-backh=&quot;94&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnqQIezGPaTf0nvmCPWiaY4TdtODj0fgvicRzSmJwiahYL7DucX0rX7kLBw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Clickhouse、Druid和Doris属于典型的实时OLAP数据分析引擎，主要应用在实时数据分析领域，它们之间的区别见表6。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.19166666666666668&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;578&quot; data-backh=&quot;111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnGQVnQUtiaMrApOPbAMP2xr47d5UO2rJ0LeHYBMiaq15stoibvMGuA3yibA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;231:651&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;6&quot;&gt;6&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;任务调度技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;任务调度技术框架包括&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Azkaban、Ooize、DolphinScheduler等&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;它们适用于普通定时执行的例行化任务，以及包含复杂依赖关系的多级任务进行调度，支持分布式，保证调度系统的性能和稳定性，它们之间的区别见表7。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;表7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4140625&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-backw=&quot;578&quot; data-backh=&quot;239&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnJbs1CophuTiapiaMcLGqibWTav8nYhibKg4vRUicutxnOznK1AQjXH0647Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它们之前的技术选型如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;419&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;117&quot; data-ratio=&quot;0.3951332560834299&quot; data-type=&quot;png&quot; data-w=&quot;863&quot; data-backw=&quot;419&quot; data-backh=&quot;166&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6pJHKwia2ha5vDOsSLtN5wSLN4VibCGEQZfuO0WrlKHRic9n7H0opbibdxA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;7&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;220:684&quot;&gt;&lt;span&gt;&lt;strong&gt;大数据底层基础技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;大数据底层基础技术框架主要是指&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Zookeeper&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;Zookeepe主要提供常用的基础功能（例如：命名空间、配置服务等），大数据生态圈中的Hadoop（HA）、HBase、Kafka等技术组件的运行都会用到Zookeeper。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;173:675&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;8&quot;&gt;8&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;数据检索技术框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;随着企业中数据的逐步积累，针对海量数据的统计分析需求会变得越来越多样化：不仅要进行分析，还要实现多条件快速复杂查询。例如，电商网站中的商品搜索功能，以及各种搜索引擎中的信息检索功能，这些功能都属于多条件快速复杂查询的范畴。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在选择全文检索引擎工具时，可以从易用性、扩展性、稳定性、集群运维难度、项目集成程度、社区活跃度这几个方面进行对比。Lucene、Solr和Elasticsearch的对比见表8。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2667964946445959&quot; data-type=&quot;png&quot; data-w=&quot;1027&quot; data-backw=&quot;578&quot; data-backh=&quot;154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnE9tCQxsG6lNNOIL6D0pLrC1oaqzyV8G96C25MYibrduIzpfdj6qyK4g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-id=&quot;98856&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;227:671&quot;&gt;&lt;section data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;9&quot;&gt;9&lt;/section&gt;&lt;section data-width=&quot;15%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;大数据集群安装管理框架&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;企业如果想从传统的数据处理转型到大数据处理，首先要做就是搭建一个稳定可靠的大数据平台。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一个完整的大数据平台需要包含数据采集、数据存储、数据计算、数据分析、集群监控等功能，这就意味着其中需要包含Flume、Kafka、HaDoop、Hive、HBase、Spark、Flink等组件，这些组件需要部署到上百台甚至上千台机器中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果依靠运维人员单独安装每一个组件，则工作量比较大，而且需要考虑版本之间的匹配问题及各种冲突问题，并且后期集群维护工作也会给运维人员造成很大的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，国外一些厂商就对大数据中的组件进行了封装，提供了一体化的大数据平台，利用它可以快速安装大数据组件。目前业内最常见的是包括CDH、HDP、CDP等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86005&quot;&gt;&lt;section data-autoskip=&quot;1&quot; data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;HDP：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称是 Hortonworks Data Platform。它由 Hortonworks 公司基于 Apache Hadoop 进行了封装，借助于 Ambari 工具提供界面化安装和管理，并且集成了大数据中的常见组件， 可以提供一站式集群管理。HDP 属于开源版免费大数据平台，没有提供商业化服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CDH：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;全称是 Cloudera Distribution Including Apache Hadoop。它由 Cloudera 公司基于 Apache Hadoop 进行了商业化，借助于 Cloudera Manager 工具提供界面化安装和管理，并且集成了大数据中的常见组件，可以提供一站式集群管理。CDH 属于商业化收费大 数据平台，默认可以试用 30 天。之后，如果想继续使用高级功能及商业化服务，则需要付费购买授权，如果只使用基础功能，则可以继续免费使用；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CDP：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Cloudera 公司在 2018 年 10 月份收购了 Hortonworks，之后推出了新一代的大数据平台产品 CDP（Cloudera Data Center）。CDP 的版本号延续了之前 CDH 的版本号。从 7.0 版本开始， CDP 支持 Private Cloud（私有云）和 Hybrid Cloud（混合云）。CDP 将 HDP 和 CDH 中比较优秀的组件进行了整合，并且增加了一些新的组件。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三者的关系如图9所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;150&quot; data-ratio=&quot;0.4074074074074074&quot; data-type=&quot;png&quot; data-w=&quot;918&quot; data-backw=&quot;562&quot; data-backh=&quot;229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nPJpjtezpjPicR4yfx7ARx6jfzkLgZnnicCtibjlHXlh8G0mvfFWGicMXCH4oSH3LDesFUFqUeVsty4w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot; hm_fix=&quot;310:479&quot;&gt;以上内容出自于《大数据技术及架构图解实战派》一书，欢迎阅读此书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8533333333333333&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-backw=&quot;578&quot; data-backh=&quot;1071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnAITwE7ON3WBib2lqbRoPxqvgicqOxaGDEUpZbzE0JNticds6dj0hy1hVw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;2446&quot; data-backw=&quot;460&quot; data-ratio=&quot;5.317391304347826&quot; data-type=&quot;png&quot; data-w=&quot;460&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqn4o2gR4W8mGOVc2YqLTyexzvVK87vbr7lS8NHoTiafGfjJ2fLqicvJpWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;155px&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lcYIbxWw19Z0lTlaCgjaqnUB3ciagotcysgpIxZq8uMReOXx9XHvUGnNWPD6Zceviaic0U6icg0iaXCUg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;粉丝专享六折购书码，快快扫码抢购吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;575b8c6b-c343-456f-a1da-14fc844368d4&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;101_10056709578969&quot; data-appuin=&quot;3075341621&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;101_10056709578969&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3075341621&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;575b8c6b-c343-456f-a1da-14fc844368d4&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;101_10056709578969&amp;quot;,&amp;quot;source_id&amp;quot;:2,&amp;quot;source_name&amp;quot;:&amp;quot;京东&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://img.zhls.qq.com/3/8cae711c1834414aa80a09af0b1d990e.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;大数据技术及架构图解实战派 徐葳 体系完整 从零起步 丰富实战案例 衔接运维 覆盖大数据生态圈完整技术体系 电子工业出版社&amp;quot;,&amp;quot;current_price&amp;quot;:8800,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;appuin&amp;quot;:&amp;quot;3075341621&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Puv74VHDtgNjyJbpQvt1gicgSpjrlpDy6BheYoAmtjiaF7cdIuPkuUlFkw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1920&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;29.8961937716263&quot; data-fileid=&quot;503655759&quot; data-ratio=&quot;0.01574074074074074&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3ntPMYAJur3UuYzhSDgO7Pu8DQL5f0FQIuDZC87yrAuNLy4frEdlMeWkthrlzczb0RbMOBQCAwDrA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-alias=&quot;zhiming_data&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;赠书规则&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;评论区走心留言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;名+获赞数(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;28+&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;)第&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;名&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;截止&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2022年08月28日周日晚22点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欢迎转发分享到你的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据圈&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Af5F8mdTheAvIIM9ftyBDVMSOnias7b1QyR3JpT6EicOPWLB0lp5fbXwxTma580ibzbJljhUzJ4UnqZA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注志明 | 新书不断 | 好书不停&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562037037037037&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7iaMpruNx3AfEoklpib3AX98zT5icTZvhAVic9xvcDrE4EGtHNlWdAyRc4rqLcxrRuVyefpRpakRPuIgQXeOfHRCZQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;新到实物书，随机翻开看，感觉还不错。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>24b3a992431f69b3cf14b74542a471bc</guid>
<title>分布式接口幂等性、分布式限流：Guava 、Nginx和lua限流</title>
<link>https://toutiao.io/k/xqrfbe8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;965972&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击关注#互联网架构师公众号，领取&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;架构师全套资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构师全套资料&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 都在这里&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100029587&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21&amp;amp;token=171858062&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;0、2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;0、&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T架构师学习资料干货分&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247530269&amp;amp;idx=1&amp;amp;sn=9f4f45fe6e961b139fb0f4448b339ca4&amp;amp;chksm=ea5fba7bdd28336d2a1a4b0234c6a1a4375668213c49b3579352a0bff57af09661cd66d4d094&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Spring Boot+Redis+拦截器+自定义Annotation实现接口自动幂等&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot+Redis+拦截器+自定义Annotation实现接口自动幂等&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;大家好，我是互联网架构师！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口幂等性就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个最简单的例子，那就是支付，用户购买商品后支付，支付扣款成功，但是返回结果的时候网络异常，此时钱已经扣了，用户再次点击按钮，此时会进行第二次扣款，返回结果成功，用户查询余额返发现多扣钱了，流水记录也变成了两条,这就没有保证接口的幂等性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幂等性的核心思想：通过唯一的业务单号保障幂等性，非并发的情况下，查询业务单号有没有操作过，没有则执行操作，并发情况下，这个操作过程需要加锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1、Update操作的幂等性&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）根据唯一业务号去更新数据&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过版本号的方式，来控制update的操作的幂等性，用户查询出要修改的数据，系统将数据返回给页面，将数据版本号放入隐藏域，用户修改数据，点击提交，将版本号一同提交给后台，后台使用版本号作为更新条件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;version&lt;/span&gt; = &lt;span&gt;version&lt;/span&gt; +&lt;span&gt;1&lt;/span&gt; ,xxx=${xxx} &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; =xxx &lt;span&gt;and&lt;/span&gt; &lt;span&gt;version&lt;/span&gt; = ${&lt;span&gt;version&lt;/span&gt;};  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2、使用Token机制，保证update、insert操作的幂等性&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）没有唯一业务号的update与insert操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入到注册页时，后台统一生成Token， 返回前台隐藏域中，用户在页面点击提交时，将Token一同传入后台，使用Token获取分布式锁，完成Insert操作，执行成功后，不释放锁，等待过期自动释放。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、分布式限流&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、分布式限流的几种维度&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间 限流基于某段时间范围或者某个时间点，也就是我们常说的“时间窗口”，比如对每分钟、每秒钟的时间窗口做限定 资源 基于可用资源的限制，比如设定最大访问次数，或最高可用连接数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两个维度结合起来看，限流就是在某个时间窗口对资源访问做限制，比如设定每秒最多100个访问请求。但在真正的场景里，我们不止设置一种限流规则，而是会设置多个限流规则共同作用，主要的几种限流规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1）QPS和连接数控制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对上图中的连接数和QPS(query per second)限流来说，我们可以设定IP维度的限流，也可以设置基于单个服务器的限流。在真实环境中通常会设置多个维度的限流规则，比如设定同一个IP每秒访问频率小于10，连接数小于5，再设定每台机器QPS最高1000，连接数最大保持200。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更进一步，我们可以把某个服务器组或整个机房的服务器当做一个整体，设置更high-level的限流规则，这些所有限流规则都会共同作用于流量控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2）传输速率&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于“传输速率”大家都不会陌生，比如资源的下载速度。有的网站在这方面的限流逻辑做的更细致，比如普通注册用户下载速度为100k/s，购买会员后是10M/s，这背后就是基于用户组或者用户标签的限流逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3）黑白名单&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;黑白名单是各个大型企业应用里很常见的限流和放行手段，而且黑白名单往往是动态变化的。举个例子，如果某个IP在一段时间的访问次数过于频繁，被系统识别为机器人用户或流量攻击，那么这个IP就会被加入到黑名单，从而限制其对系统资源的访问，这就是我们俗称的“封IP”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时见到的爬虫程序，比如说爬知乎上的美女图片，或者爬券商系统的股票分时信息，这类爬虫程序都必须实现更换IP的功能，以防被加入黑名单。有时我们还会发现公司的网络无法访问12306这类大型公共网站，这也是因为某些公司的出网IP是同一个地址，因此在访问量过高的情况下，这个IP地址就被对方系统识别，进而被添加到了黑名单。使用家庭宽带的同学们应该知道，大部分网络运营商都会将用户分配到不同出网IP段，或者时不时动态更换用户的IP地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白名单就更好理解了，相当于御赐金牌在身，可以自由穿梭在各种限流规则里，畅行无阻。比如某些电商公司会将超大卖家的账号加入白名单，因为这类卖家往往有自己的一套运维系统，需要对接公司的IT系统做大量的商品发布、补货等等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4）分布式环境&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的分布式限流，其实道理很简单，一句话就可以解释清楚。分布式区别于单机限流的场景，它把整个分布式环境中所有服务器当做一个整体来考量。比如说针对IP的限流，我们限制了1个IP每秒最多10个访问，不管来自这个IP的请求落在了哪台机器上，只要是访问了集群中的服务节点，那么都会受到限流规则的制约。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子不难看出，我们必须将限流信息保存在一个“中心化”的组件上，这样它就可以获取到集群中所有机器的访问状态，目前有两个比较主流的限流方案：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关层限流&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间件限流&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将限流信息存储在分布式环境中某个中间件里（比如Redis缓存），每个组件都可以从这里获取到当前时刻的流量统计，从而决定是拒绝服务还是放行流量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、限流方案常用算法讲解&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;1）令牌桶算法&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Token Bucket令牌桶算法是目前应用最为广泛的限流算法，顾名思义，它有以下两个关键角色：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;令牌 获取到令牌的Request才会被处理，其他Requests要么排队要么被直接丢弃&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;桶 用来装令牌的地方，所有Request都从这个桶里面获取令牌&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAm8H0a8AQx38EIe3lIEdywfDFGbCUpcygn8f4QoXugbuLnqSpAISDqnwtxMI7NQNHRs9Vk5nbx9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;令牌生成&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程涉及到令牌生成器和令牌桶，前面我们提到过令牌桶是一个装令牌的地方，既然是个桶那么必然有一个容量，也就是说令牌桶所能容纳的令牌数量是一个固定的数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于令牌生成器来说，它会根据一个预定的速率向桶中添加令牌，比如我们可以配置让它以每秒100个请求的速率发放令牌，或者每分钟50个。注意这里的发放速度是匀速，也就是说这50个令牌并非是在每个时间窗口刚开始的时候一次性发放，而是会在这个时间窗口内匀速发放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在令牌发放器就是一个水龙头，假如在下面接水的桶子满了，那么自然这个水（令牌）就流到了外面。在令牌发放过程中也一样，令牌桶的容量是有限的，如果当前已经放满了额定容量的令牌，那么新来的令牌就会被丢弃掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;令牌获取&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个访问请求到来后，必须获取到一个令牌才能执行后面的逻辑。假如令牌的数量少，而访问请求较多的情况下，一部分请求自然无法获取到令牌，那么这个时候我们可以设置一个“缓冲队列”来暂存这些多余的令牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓冲队列其实是一个可选的选项，并不是所有应用了令牌桶算法的程序都会实现队列。当有缓存队列存在的情况下，那些暂时没有获取到令牌的请求将被放到这个队列中排队，直到新的令牌产生后，再从队列头部拿出一个请求来匹配令牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当队列已满的情况下，这部分访问请求将被丢弃。在实际应用中我们还可以给这个队列加一系列的特效，比如设置队列中请求的存活时间，或者将队列改造为PriorityQueue，根据某种优先级排序，而不是先进先出。算法是死的，人是活的，先进的生产力来自于不断的创造，在技术领域尤其如此。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2）漏桶算法&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leaky Bucket&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5972222222222222&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XAm8H0a8AQx38EIe3lIEdywV2z4moFZkz7II8aOylfO5DGl8WkfrPYO0pFOL55SEhStfj2iavXAa9w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法的前半段和令牌桶类似，但是操作的对象不同，令牌桶是将令牌放入桶里，而漏桶是将访问请求的数据包放到桶里。同样的是，如果桶满了，那么后面新来的数据包将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法的后半程是有鲜明特色的，它永远只会以一个恒定的速率将数据包从桶内流出。打个比方，如果我设置了漏桶可以存放100个数据包，然后流出速度是1s一个，那么不管数据包以什么速率流入桶里，也不管桶里有多少数据包，漏桶能保证这些数据包永远以1s一个的恒定速度被处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;漏桶 vs 令牌桶的区别&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据它们各自的特点不难看出来，这两种算法都有一个“恒定”的速率和“不定”的速率。令牌桶是以恒定速率创建令牌，但是访问请求获取令牌的速率“不定”，反正有多少令牌发多少，令牌没了就干等。而漏桶是以“恒定”的速率处理请求，但是这些请求流入桶的速率是“不定”的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这两个特点来说，漏桶的天然特性决定了它不会发生突发流量，就算每秒1000个请求到来，那么它对后台服务输出的访问速率永远恒定。而令牌桶则不同，其特性可以“预存”一定量的令牌，因此在应对突发流量的时候可以在短时间消耗所有令牌，其突发流量处理效率会比漏桶高，但是导向后台系统的压力也会相应增多。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、分布式限流的主流方案&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要讲nginx和lua的限流，gateway和hystrix放在后面springcloud中讲&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;1）Guava RateLimiter客户端限流&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.引入maven&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;18.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.编写Controller&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Controller&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;//每秒钟可以创建两个令牌  &lt;/span&gt;&lt;br/&gt;    RateLimiter limiter = RateLimiter.create(&lt;span&gt;2.0&lt;/span&gt;);  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;//非阻塞限流  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/tryAcquire&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(Integer count)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;//count 每次消耗的令牌  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(limiter.tryAcquire(count)){  &lt;br/&gt;            log.info(&lt;span&gt;&quot;成功，允许通过，速率为{}&quot;&lt;/span&gt;,limiter.getRate());  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;  &lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;{  &lt;br/&gt;            log.info(&lt;span&gt;&quot;错误，不允许通过，速率为{}&quot;&lt;/span&gt;,limiter.getRate());  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;fail&quot;&lt;/span&gt;;  &lt;br/&gt;        }  &lt;br/&gt;    }  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;//限定时间的非阻塞限流  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/tryAcquireWithTimeout&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;tryAcquireWithTimeout&lt;/span&gt;&lt;span&gt;(Integer count, Integer timeout)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;//count 每次消耗的令牌  timeout 超时等待的时间  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(limiter.tryAcquire(count,timeout,TimeUnit.SECONDS)){  &lt;br/&gt;            log.info(&lt;span&gt;&quot;成功，允许通过，速率为{}&quot;&lt;/span&gt;,limiter.getRate());  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;  &lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;{  &lt;br/&gt;            log.info(&lt;span&gt;&quot;错误，不允许通过，速率为{}&quot;&lt;/span&gt;,limiter.getRate());  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;fail&quot;&lt;/span&gt;;  &lt;br/&gt;        }  &lt;br/&gt;    }  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;//同步阻塞限流  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/acquire&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(Integer count)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        limiter.acquire(count);  &lt;br/&gt;        log.info(&lt;span&gt;&quot;成功，允许通过，速率为{}&quot;&lt;/span&gt;,limiter.getRate());  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;2）基于Nginx的限流&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.iP限流&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.编写Controller&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Controller&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;//nginx测试使用  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/nginx&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;nginx&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        log.info(&lt;span&gt;&quot;Nginx success&quot;&lt;/span&gt;);  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.修改host文件，添加一个网址域名&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;127.0.0.1   www.test.com  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.修改nginx，将步骤2中的域名，添加到路由规则当中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开nginx的配置文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;vim /usr/&lt;span&gt;local&lt;/span&gt;/nginx/conf/nginx.conf  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加一个服务&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#根据IP地址限制速度  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#1）$binary_remote_addr   binary_目的是缩写内存占用，remote_addr表示通过IP地址来限流  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#2）zone=iplimit:20m   iplimit是一块内存区域（记录访问频率信息），20m是指这块内存区域的大小  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;#3）rate=1r/s  每秒放行1个请求  &lt;/span&gt;&lt;br/&gt;limit_req_zone &lt;span&gt;$binary_remote_addr&lt;/span&gt; zone=iplimit:20m rate=1r/s;  &lt;br/&gt;  &lt;br/&gt;server{  &lt;br/&gt;    server_name www.test.com;  &lt;br/&gt;    location /access-limit/ {  &lt;br/&gt;        proxy_pass http://127.0.0.1:8080/;  &lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;#基于ip地址的限制  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;#1）zone=iplimit 引用limit_rep_zone中的zone变量  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;#2）burst=2  设置一个大小为2的缓冲区域，当大量请求到来，请求数量超过限流频率时，将其放入缓冲区域  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;#3）nodelay   缓冲区满了以后，直接返回503异常  &lt;/span&gt;&lt;br/&gt;        limit_req zone=iplimit burst=2 nodelay;  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.访问地址，测试是否限流&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;www.test.com/access-limit/nginx&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.多维度限流&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.修改nginx配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#根据IP地址限制速度  &lt;/span&gt;&lt;br/&gt;limit_req_zone &lt;span&gt;$binary_remote_addr&lt;/span&gt; zone=iplimit:20m rate=10r/s;  &lt;br/&gt;&lt;span&gt;#根据服务器级别做限流  &lt;/span&gt;&lt;br/&gt;limit_req_zone &lt;span&gt;$server_name&lt;/span&gt; zone=serverlimit:10m rate=1r/s;  &lt;br/&gt;&lt;span&gt;#根据ip地址的链接数量做限流  &lt;/span&gt;&lt;br/&gt;limit_conn_zone &lt;span&gt;$binary_remote_addr&lt;/span&gt; zone=perip:20m;  &lt;br/&gt;&lt;span&gt;#根据服务器的连接数做限流  &lt;/span&gt;&lt;br/&gt;limit_conn_zone &lt;span&gt;$server_name&lt;/span&gt; zone=perserver:20m;  &lt;br/&gt;  &lt;br/&gt;  &lt;br/&gt;server{  &lt;br/&gt;    server_name www.test.com;  &lt;br/&gt;    location /access-limit/ {  &lt;br/&gt;        proxy_pass http://127.0.0.1:8080/;  &lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;#基于ip地址的限制  &lt;/span&gt;&lt;br/&gt;        limit_req zone=iplimit burst=2 nodelay;  &lt;br/&gt;        &lt;span&gt;#基于服务器级别做限流  &lt;/span&gt;&lt;br/&gt;        limit_req zone=serverlimit burst=2 nodelay;  &lt;br/&gt;        &lt;span&gt;#基于ip地址的链接数量做限流  最多保持100个链接  &lt;/span&gt;&lt;br/&gt;        limit_conn zone=perip 100;  &lt;br/&gt;        &lt;span&gt;#基于服务器的连接数做限流 最多保持100个链接  &lt;/span&gt;&lt;br/&gt;        limit_conn zone=perserver 1;  &lt;br/&gt;        &lt;span&gt;#配置request的异常返回504（默认为503）  &lt;/span&gt;&lt;br/&gt;        limit_req_status 504;  &lt;br/&gt;        limit_conn_status 504;  &lt;br/&gt;    }  &lt;br/&gt;      &lt;br/&gt;     location /download/ {  &lt;br/&gt;        &lt;span&gt;#前100m不限制速度  &lt;/span&gt;&lt;br/&gt;        limit_rate_affer 100m;  &lt;br/&gt;        &lt;span&gt;#限制速度为256k  &lt;/span&gt;&lt;br/&gt;        limit_rate 256k;  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3）基于Redis+Lua的分布式限流&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.Lua脚本&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lua是一个很小巧精致的语言，它的诞生（1993年）甚至比JDK 1.0还要早。Lua是由标准的C语言编写的，它的源码部分不过2万多行C代码，甚至一个完整的Lua解释器也就200k的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lua往大了说是一个新的编程语言，往小了说就是一个脚本语言。对于有编程经验的同学，拿到一个Lua脚本大体上就能把业务逻辑猜的八九不离十了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis内置了Lua解释器，执行过程保证原子性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.Lua安装&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装Lua：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.参考&lt;code&gt;http://www.lua.org/ftp/&lt;/code&gt;教程，下载5.3.5_1版本，本地安装&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用的是Mac，那建议用brew工具直接执行brew install lua就可以顺利安装，有关brew工具的安装可以参考&lt;code&gt;https://brew.sh/&lt;/code&gt;网站，使用brew安装后的目录在&lt;code&gt;/usr/local/Cellar/lua/5.3.5_1&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.安装IDEA插件，在IDEA-&amp;gt;Preferences面板，Plugins，里面Browse repositories，在里面搜索lua，然后就选择同名插件lua。安装好后重启IDEA&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.配置Lua SDK的位置：&lt;code&gt;IDEA-&amp;gt;File-&amp;gt;Project Structure&lt;/code&gt;,选择添加Lua，路径指向Lua SDK的bin文件夹，关于nginx面试资料，公众 号互联网架构师，回复2T，领取面试资料。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.都配置好之后，在项目中右键创建Module，左侧栏选择lua，点下一步，选择lua的sdk，下一步，输入lua项目名，完成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.编写hello lua&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;print&lt;/span&gt; &lt;span&gt;&#x27;Hello Lua&#x27;&lt;/span&gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4.编写模拟限流&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-- 模拟限流  &lt;br/&gt;  &lt;br/&gt;-- 用作限流的key  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; key = &lt;span&gt;&#x27;my key&#x27;&lt;/span&gt;  &lt;br/&gt;  &lt;br/&gt;-- 限流的最大阈值  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; = 2  &lt;br/&gt;  &lt;br/&gt;-- 当前限流大小  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; currentLimit = 2  &lt;br/&gt;  &lt;br/&gt;-- 是否超过限流标准  &lt;br/&gt;&lt;span&gt;if&lt;/span&gt; currentLimit + 1 &amp;gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&#x27;reject&#x27;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;print&lt;/span&gt; &lt;span&gt;&#x27;accept&#x27;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;  &lt;br/&gt;end  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5.限流组件封装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.添加maven&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-aop&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.google.guava&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;guava&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;18.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.添加Spring配置&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是重要内容就随便写点，主要就是把reids配置一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.port=8080  &lt;br/&gt;  &lt;br/&gt;spring.redis.database=0  &lt;br/&gt;spring.redis.host=localhost  &lt;br/&gt;spring.redis.port=6376  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.编写限流脚本&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lua脚本放在resource目录下就可以了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;-- 获取方法签名特征  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; methodKey = KEYS[1]  &lt;br/&gt;redis.log(redis.LOG_DEBUG,&lt;span&gt;&#x27;key is&#x27;&lt;/span&gt;,methodKey)  &lt;br/&gt;  &lt;br/&gt;-- 调用脚本传入的限流大小  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; = tonumber(ARGV[1])  &lt;br/&gt;  &lt;br/&gt;-- 获取当前流量大小  &lt;br/&gt;&lt;span&gt;local&lt;/span&gt; count = tonumber(redis.call(&lt;span&gt;&#x27;get&#x27;&lt;/span&gt;,methodKey) or &lt;span&gt;&quot;0&quot;&lt;/span&gt;)  &lt;br/&gt;  &lt;br/&gt;--是否超出限流值  &lt;br/&gt;&lt;span&gt;if&lt;/span&gt; count + 1 &amp;gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;then&lt;/span&gt;  &lt;br/&gt;    -- 拒绝访问  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;else&lt;/span&gt;  &lt;br/&gt;    -- 没有超过阈值  &lt;br/&gt;    -- 设置当前访问数量+1  &lt;br/&gt;    redis.call(&lt;span&gt;&#x27;INCRBY&#x27;&lt;/span&gt;,methodKey,1)  &lt;br/&gt;    -- 设置过期时间  &lt;br/&gt;    redis.call(&lt;span&gt;&#x27;EXPIRE&#x27;&lt;/span&gt;,methodKey,1)  &lt;br/&gt;    -- 放行  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;  &lt;br/&gt;end  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.使用&lt;code&gt;spring-data-redis&lt;/code&gt;组件集成Lua和Redis&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建限流类&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AccessLimiter&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; StringRedisTemplate stringRedisTemplate;  &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisScript&amp;lt;Boolean&amp;gt; rateLimitLua;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;limitAccess&lt;/span&gt;&lt;span&gt;(String key,Integer limit)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; acquired = stringRedisTemplate.execute(  &lt;br/&gt;            rateLimitLua,&lt;span&gt;//lua脚本的真身  &lt;/span&gt;&lt;br/&gt;            Lists.newArrayList(key),&lt;span&gt;//lua脚本中的key列表  &lt;/span&gt;&lt;br/&gt;            limit.toString()&lt;span&gt;//lua脚本的value列表  &lt;/span&gt;&lt;br/&gt;        );  &lt;br/&gt;  &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(!acquired){  &lt;br/&gt;            log.error(&lt;span&gt;&quot;Your access is blocked,key={}&quot;&lt;/span&gt;,key);  &lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;Your access is blocked&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建配置类&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisConfiguration&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedisTemplate&amp;lt;String,String&amp;gt; &lt;span&gt;redisTemplate&lt;/span&gt;&lt;span&gt;(RedisConnectionFactory factory)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StringRedisTemplate(factory);  &lt;br/&gt;    }  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; DefaultRedisScript &lt;span&gt;loadRedisScript&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        DefaultRedisScript redisScript = &lt;span&gt;new&lt;/span&gt; DefaultRedisScript();  &lt;br/&gt;        redisScript.setLocation(&lt;span&gt;new&lt;/span&gt; ClassPathResource(&lt;span&gt;&quot;rateLimiter.lua&quot;&lt;/span&gt;));  &lt;br/&gt;        redisScript.setResultType(java.lang.Boolean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; redisScript;  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.在Controller中添加测试方法验证限流效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Controller&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AccessLimiter accessLimiter;  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;test&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        accessLimiter.limitAccess(&lt;span&gt;&quot;ratelimiter-test&quot;&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;}   &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6.编写限流注解&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.新增注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.METHOD})  &lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)  &lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; AccessLimiterAop{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;String &lt;span&gt;methodKey&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.新增切面&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;@Aspect&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AccessLimiterAspect&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AccessLimiter  accessLimiter;  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//根据注解的位置，自己修改  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Pointcut&lt;/span&gt;(&lt;span&gt;&quot;@annotation(com.gyx.demo.annotation.AccessLimiter)&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;cut&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        log.info(&lt;span&gt;&quot;cut&quot;&lt;/span&gt;);  &lt;br/&gt;    }  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;@Before&lt;/span&gt;(&lt;span&gt;&quot;cut()&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;before&lt;/span&gt;&lt;span&gt;(JoinPoint joinPoint)&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;//获取方法签名，作为methodkey  &lt;/span&gt;&lt;br/&gt;        MethodSignature signature =(MethodSignature) joinPoint.getSignature();  &lt;br/&gt;        Method method = signature.getMethod();  &lt;br/&gt;        AccessLimiterAop annotation = method.getAnnotation(AccessLimiterAop&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(annotation == &lt;span&gt;null&lt;/span&gt;){  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;  &lt;br/&gt;        }  &lt;br/&gt;        String key = annotation.methodKey();  &lt;br/&gt;        Integer limit = annotation.limit();  &lt;br/&gt;        &lt;span&gt;//如果没有设置methodKey，就自动添加一个  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(StringUtils.isEmpty(key)){  &lt;br/&gt;            Class[] type = method.getParameterType();  &lt;br/&gt;            key = method.getName();  &lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (type != &lt;span&gt;null&lt;/span&gt;){  &lt;br/&gt;                String paramTypes=Arrays.stream(type)  &lt;br/&gt;                    .map(Class::getName)  &lt;br/&gt;                    .collect(Collectors.joining(&lt;span&gt;&quot;,&quot;&lt;/span&gt;));  &lt;br/&gt;                    key += &lt;span&gt;&quot;#&quot;&lt;/span&gt;+paramTypes;  &lt;br/&gt;            }  &lt;br/&gt;        }  &lt;br/&gt;          &lt;br/&gt;        &lt;span&gt;//调用redis  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; accessLimiter.limitAccess(key,limit);  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.在Controller中添加测试方法验证限流效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Controller&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AccessLimiter accessLimiter;  &lt;br/&gt;      &lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;test&quot;&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;@AccessLImiterAop&lt;/span&gt;(limit =&lt;span&gt;1&lt;/span&gt;)  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;test&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;} &lt;/code&gt;&lt;/pre&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;来源：blog.csdn.net/qq_34886352/article/details/104694550&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Alibaba开源内网高并发编程手册.pdf&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2T架构师学习资料干货分享&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523100&amp;amp;idx=1&amp;amp;sn=82a70350577bde0bca6dd2dde811ca17&amp;amp;chksm=ea5f567add28df6cb6a780ff744c3ffdc79e498d2c2536ffb1853d8082ebfa986e1e5c43d532&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10000+TB 资源，阿里云盘，牛逼！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;10000+TB 资源，阿里云盘，牛逼！！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523863&amp;amp;idx=1&amp;amp;sn=4d2a2b5da60f14f3e8947e174d485c03&amp;amp;chksm=ea5f5371dd28da6791af6cb3a164c8052f1e77d7392cbbc87c5a73ccc6916b76eab29dbc9991&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本涵盖了Spring所有核心知识点总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;基本涵盖了Spring所有核心知识点总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;  · END ·&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRL358RWHQSLbUws79uyGm5RJ6WZibYJMAKUQibz8aYNA5LPSmbo1boibnD3IhggQ2F7kS37xgk3WXQ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>