<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>00046e6406013972e205f83ffd166683</guid>
<title>有哪些公司大规模使用了prometheus？有没有经典案例分享下？</title>
<link>https://toutiao.io/k/p5qn7s3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;fmt&quot;&gt;
          &lt;h1 id=&quot;cloudflare--prometheus&quot;&gt;Cloudflare 如何大规模运行 Prometheus&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuDvqbQdq.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用Prometheus来深入了解构成我们全球网络的所有不同硬件和软件。Prometheus 允许我们随着时间的推移衡量健康状况和绩效，如果任何服务有任何问题，请在它成为问题之前通知我们的团队。&lt;/p&gt;
&lt;p&gt;在撰写本文时，我们运行了 916 个 Prometheus 实例，总共有大约 49 亿个时间序列。这是显示确切数字的屏幕截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuFhft1VE.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这平均每个实例大约有 500 万个时间序列，但实际上我们混合了非常小和非常大的实例，最大的实例每个存储大约 3000 万个时间序列。&lt;/p&gt;
&lt;p&gt;运行如此庞大的 Prometheus 部署并非没有挑战。在这篇博文中，我们将介绍在尝试为每个 Prometheus 实例收集数百万个时间序列时可能遇到的一些问题。&lt;/p&gt;
&lt;h2 id=&quot;heading&quot;&gt;指标基数&lt;/h2&gt;
&lt;p&gt;当您开始运行自己的 Prometheus 实例时，您可能会听到的第一个问题是基数，这个问题最引人注目的案例被称为“基数爆炸”。&lt;/p&gt;
&lt;p&gt;因此，让我们首先从 Prometheus 的角度来看一下基数意味着什么，什么时候它可能成为问题，以及一些处理它的方法。&lt;/p&gt;
&lt;p&gt;假设我们有一个我们想要检测的应用程序，这意味着以 Prometheus 可以从我们的应用程序读取的指标形式添加一些可观察的属性。指标可以是您可以用数字表示的任何内容，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;车辆行驶的速度。&lt;/li&gt;
&lt;li&gt;当前温度。&lt;/li&gt;
&lt;li&gt;某些特定事件发生的次数。&lt;br/&gt;
要在我们的应用程序中创建指标，我们可以使用许多 Prometheus 客户端库之一。为简单起见，我们选择client_python，但无论您使用何种语言，相同的概念都将适用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

# Declare our first metric.
# First argument is the name of the metric.
# Second argument is the description of it.
c = Counter(mugs_of_beverage_total, &#x27;The total number of mugs drank.&#x27;)

# Call inc() to increment our metric every time a mug was drank.
c.inc()
c.inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这个简单的代码，Prometheus 客户端库将创建一个单一的指标。为了让 Prometheus 收集此指标，我们需要我们的应用程序运行 HTTP 服务器并在那里公开我们的指标。最简单的方法是使用 client_python 本身提供的功能 - 请参阅此处的文档。&lt;/p&gt;
&lt;p&gt;当 Prometheus 向我们的应用程序发送 HTTP 请求时，它将收到以下响应：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP mugs_of_beverage_total The total number of mugs drank.
# TYPE mugs_of_beverage_total counter
mugs_of_beverage_total 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Prometheus 自己的文档中广泛介绍了这种格式和底层数据模型。&lt;/p&gt;
&lt;p&gt;有关详细信息，请参阅数据模型和说明格式页面。&lt;/p&gt;
&lt;p&gt;如果愿意，我们可以添加更多指标，它们都将出现在对指标端点的 HTTP 响应中。&lt;/p&gt;
&lt;p&gt;Prometheus 指标可以具有标签形式的额外维度。我们可以使用这些向我们的指标添加更多信息，以便我们可以更好地了解正在发生的事情。&lt;/p&gt;
&lt;p&gt;通过我们的示例指标，我们知道消耗了多少杯，但如果我们还想知道它是哪种饮料怎么办？或者我们想知道这是冷饮还是热饮？添加标签非常容易，我们需要做的就是指定它们的名称。一旦我们这样做了，我们需要在递增我们的计数器以传递这些额外信息时传递标签值（与指定标签名称的顺序相同）。&lt;/p&gt;
&lt;p&gt;让我们调整示例代码来执行此操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(mugs_of_beverage_total, &#x27;The total number of mugs drank.&#x27;, [&#x27;content&#x27;, &#x27;temperature&#x27;])

c.labels(&#x27;coffee&#x27;, &#x27;hot&#x27;).inc()
c.labels(&#x27;coffee&#x27;, &#x27;hot&#x27;).inc()
c.labels(&#x27;coffee&#x27;, &#x27;cold&#x27;).inc()
c.labels(&#x27;tea&#x27;, &#x27;hot&#x27;).inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的 HTTP 响应现在将显示更多条目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP mugs_of_beverage_total The total number of mugs drank.
# TYPE mugs_of_beverage_total counter
mugs_of_beverage_total{content=&quot;coffee&quot;, temperature=&quot;hot&quot;} 2
mugs_of_beverage_total{content=&quot;coffee&quot;, temperature=&quot;cold&quot;} 1
mugs_of_beverage_total{content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如我们所看到的，我们为每个唯一的标签组合都有一个条目。&lt;/p&gt;
&lt;p&gt;这将我们带到了指标上下文中基数的定义。基数是所有标签的唯一组合的数量。您拥有的标签越多，每个标签可以取的值越多，您可以创建的独特组合就越多，基数就越高。&lt;/p&gt;
&lt;h2 id=&quot;-vs--vs-&quot;&gt;指标 vs 样本 vs 时间序列&lt;/h2&gt;
&lt;p&gt;现在我们应该停下来对指标和时间序列进行重要区分。&lt;/p&gt;
&lt;p&gt;指标是具有某些已定义维度（标签）的可观察属性。在我们的示例中，它是一个 Counter 类对象。&lt;/p&gt;
&lt;p&gt;时间序列是该指标的一个实例，具有所有维度（标签）的独特组合，加上一系列时间戳和值对——因此得名“时间序列”。名称和标签告诉我们正在观察什么，而时间戳和值对告诉我们可观察的属性如何随时间变化，允许我们使用这些数据绘制图表。&lt;/p&gt;
&lt;p&gt;这意味着单个指标将创建一个或多个时间序列。时间序列的数量完全取决于标签的数量以及这些标签可以取的所有可能值的数量。&lt;/p&gt;
&lt;p&gt;每次我们为我们的指标添加一个新标签时，我们都冒着增加将作为结果导出到 Prometheus 的时间序列数量的风险。&lt;/p&gt;
&lt;p&gt;在我们的示例中，我们有两个标签，“内容”和“温度”，它们都可以有两个不同的值。所以我们最终可以创建的时间序列的最大数量是四个 (2&lt;em&gt;2)。如果我们添加另一个也可以有两个值的标签，那么我们现在最多可以导出八个时间序列 (2&lt;/em&gt;2*2)。我们拥有的标签越多或它们可以拥有的时间序列越多。&lt;/p&gt;
&lt;p&gt;如果所有标签值都由您的应用程序控制，您将能够计算出所有可能的标签组合的数量。但真正的风险是当您使用来自外部世界的标签值创建指标时。&lt;/p&gt;
&lt;p&gt;如果我们跟踪对 Web 服务器的 HTTP 请求数量而不是饮料，并且我们使用请求路径作为标签值之一，那么任何发出大量随机请求的人都可能迫使我们的应用程序创建大量时间序列. 为避免这种情况，通常最好永远不要接受来自不受信任来源的标签值。&lt;/p&gt;
&lt;p&gt;使事情变得更复杂的是，您在阅读 Prometheus 文档时可能还会听到“示例”。样本介于指标和时间序列之间——它是特定时间戳的时间序列值。这里的时间戳可以是显式的也可以是隐式的。如果样本缺少任何明确的时间戳，则意味着该样本代表最新值——它是给定时间序列的当前值，而时间戳只是您进行观察的时间。&lt;/p&gt;
&lt;p&gt;如果您查看我们示例指标的 HTTP 响应，您会发现返回的条目都没有时间戳。实际上任何地方都没有时间戳。这是因为 Prometheus 服务器本身负责时间戳。当 Prometheus 收集指标时，它会记录开始每次收集的时间，然后它将使用它为每个时间序列编写时间戳和值对。&lt;/p&gt;
&lt;p&gt;这就是为什么我们的应用程序导出的不是真正的指标或时间序列——它是样本。&lt;/p&gt;
&lt;p&gt;令人困惑？让我们回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们从一个指标开始——它只是对我们可以观察到的事物的定义，比如喝醉的杯子数。&lt;/li&gt;
&lt;li&gt;我们的指标作为 HTTP 响应公开。该响应将包含一个样本列表——这些是我们指标的各个实例（由名称和标签表示），加上当前值。&lt;/li&gt;
&lt;li&gt;当 Prometheus 从我们的 HTTP 响应中收集所有样本时，它会添加该收集的时间戳，并将所有这些信息结合在一起，我们就有了一个时间序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuZFwhuG1.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;heading-1&quot;&gt;基数相关问题&lt;/h2&gt;
&lt;p&gt;每个时间序列都会消耗我们的资源，因为它需要保存在内存中，所以我们拥有的时间序列越多，消耗的资源指标就越多。对于客户端库和 Prometheus 服务器来说都是如此，但对于 Prometheus 本身来说更像是一个问题，因为单个 Prometheus 服务器通常会从许多应用程序收集指标，而应用程序只保留自己的指标。&lt;/p&gt;
&lt;p&gt;因为我们知道我们拥有的标签越多，我们最终得到的时间序列就越多，你可以看到这什么时候会成为一个问题。简单地向我们所有的指标添加一个具有两个不同值的标签可能会使我们必须处理的时间序列数量增加一倍。这反过来将使我们的 Prometheus 服务器的内存使用量增加一倍。如果我们让 Prometheus 消耗的内存超过它实际使用的内存，那么它就会崩溃。&lt;/p&gt;
&lt;p&gt;这种情况通常被描述为“基数爆炸”——一些指标突然添加了大量不同的标签值，创建了大量的时间序列，导致普罗米修斯耗尽内存，结果你失去了所有的可观察性。&lt;/p&gt;
&lt;h2 id=&quot;prometheus-&quot;&gt;Prometheus 是如何使用内存的？&lt;/h2&gt;
&lt;p&gt;为了更好地处理基数问题，最好先更好地了解 Prometheus 的工作原理以及时间序列如何消耗内存。&lt;/p&gt;
&lt;p&gt;为此，让我们遵循普罗米修斯内部时间序列生命周期中的所有步骤。&lt;/p&gt;
&lt;h2 id=&quot;---http-&quot;&gt;第一步 - HTTP 抓取&lt;/h2&gt;
&lt;p&gt;从 Prometheus 向我们的应用程序发送 HTTP 请求的过程称为“抓取”。在 Prometheus 配置文件中，我们定义了一个“抓取配置”，告诉 Prometheus 发送 HTTP 请求的位置、发送频率，以及可选地对请求和响应应用额外处理。&lt;/p&gt;
&lt;p&gt;它将记录它发送 HTTP 请求的时间，并稍后将其用作所有收集的时间序列的时间戳。&lt;/p&gt;
&lt;p&gt;发送请求后，它将解析响应以查找那里公开的所有样本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZv5TDe91G.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;heading-2&quot;&gt;第二步——新的时间序列还是更新？&lt;/h2&gt;
&lt;p&gt;一旦 Prometheus 有了从我们的应用程序收集的样本列表，它将把它保存到TSDB - 时间序列数据库 - Prometheus 保存所有时间序列的数据库。&lt;/p&gt;
&lt;p&gt;但在此之前，它需要首先检查哪些样本属于 TSDB 中已经存在的时间序列，哪些属于全新的时间序列。&lt;/p&gt;
&lt;p&gt;正如我们之前提到的，时间序列是从指标生成的。每个唯一的指标标签组合都有一个时间序列。&lt;/p&gt;
&lt;p&gt;这意味着 Prometheus 必须检查是否已经存在具有相同名称和完全相同标签集的时间序列。在内部，时间序列名称只是另一个名为 &lt;strong&gt;name&lt;/strong&gt; 的标签，因此名称和标签之间没有实际区别。下面的两种表示都是导出相同时间序列的不同方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mugs_of_beverage_total{content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
{__name__=&quot;mugs_of_beverage_total&quot;, content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于一切都是标签，Prometheus 可以简单地使用 sha256 或任何其他算法对所有标签进行哈希处理，以得出每个时间序列唯一的单个 ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZv9KGR6vS.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知道它可以快速检查是否有任何时间序列已经存储在 TSDB 中具有相同的哈希值。基本上我们的标签哈希被用作 TSDB 中的主键。&lt;/p&gt;
&lt;h2 id=&quot;----tsdb&quot;&gt;第三步 - 附加到 TSDB&lt;/h2&gt;
&lt;p&gt;一旦 TSDB 知道它是否必须插入新的时间序列或更新现有的时间序列，它就可以开始真正的工作。&lt;/p&gt;
&lt;p&gt;在内部，所有时间序列都存储在名为Head的结构上的地图中。该映射使用标签哈希作为键，使用名为memSeries 的结构作为值。这些 memSeries 对象存储所有时间序列信息。memSeries 的结构定义相当大，但我们真正需要知道的是它具有所有时间序列标签和包含所有样本（时间戳和值对）的块的副本。&lt;/p&gt;
&lt;p&gt;每个 memSeries 实例都存储一次标签。&lt;/p&gt;
&lt;p&gt;样本使用“varbit”编码存储在块内，这是一种针对时间序列数据优化的无损压缩方案。每个块代表特定时间范围内的一系列样本。这有助于 Prometheus 更快地查询数据，因为它需要做的就是首先找到标签与我们的查询匹配的 memSeries 实例，然后找到负责查​​询时间范围的块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvcYLtYAU.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下， Prometheus 将每两小时wall clock创建一个块。所以会有一个块用于：00:00 - 01:59、02:00 - 03:59、04:00 - 05:59、...、22:00 - 23:59。&lt;/p&gt;
&lt;p&gt;我们只能附加一个块，它被称为“头块”。这是负责最近时间范围的块，包括我们抓取的时间。任何其他块都包含历史样本，因此是只读的。&lt;/p&gt;
&lt;p&gt;每个块最多可以容纳120 个样本。这是因为一旦我们在一个块上有超过 120 个样本，“varbit”编码的效率就会下降。TSDB将尝试估计给定块何时达到 120 个样本，并相应地设置当前 Head Chunk 的最大允许时间。&lt;/p&gt;
&lt;p&gt;如果我们尝试附加一个时间戳高于当前 Head Chunk 的最大允许时间的样本，则 TSDB 将创建一个新的 Head Chunk 并根据附加速率为其计算新的最大时间。&lt;/p&gt;
&lt;p&gt;所有块都必须与挂钟时间的那两个小时时段对齐，因此如果 TSDB 正在为 10:00-11:59 构建一个块并且它在 11:30 已经“满”，那么它将为11:30-11:59时间范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZveSuiPL5.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于默认的 Prometheus 抓取间隔是一分钟，因此需要两个小时才能达到 120 个样本。&lt;/p&gt;
&lt;p&gt;这意味着使用 Prometheus 默认值，每个 memSeries 应该有一个块，每两个小时的数据有 120 个样本。&lt;/p&gt;
&lt;p&gt;回到我们的时间序列——此时 Prometheus 要么创建一个新的 memSeries 实例，要么使用已经存在的 memSeries。一旦有了要使用的 memSeries 实例，它就会将我们的样本附加到 Head Chunk。如果需要，这可能需要 Prometheus 创建一个新块。&lt;/p&gt;
&lt;h2 id=&quot;heading-3&quot;&gt;第四步——内存映射旧块&lt;/h2&gt;
&lt;p&gt;经过几个小时的 Prometheus 运行和抓取指标后，我们的时间序列上可能会有不止一个块：&lt;/p&gt;
&lt;p&gt;一个“Head Chunk”——包含最后两个小时的挂钟插槽中的最多两个小时。&lt;br/&gt;
一个或多个用于历史范围 - 这些块仅供阅读，Prometheus 不会尝试在此处附加任何内容。&lt;br/&gt;
由于所有这些块都存储在内存中，Prometheus 将尝试通过将它们写入磁盘和内存映射来减少内存使用。这样做的好处是内存映射块不使用内存，除非 TSDB 需要读取它们。&lt;/p&gt;
&lt;p&gt;Head Chunk 从不进行内存映射，它始终存储在内存中。&lt;/p&gt;
&lt;h2 id=&quot;---&quot;&gt;第五步 - 将块写入磁盘&lt;/h2&gt;
&lt;p&gt;到目前为止，所有时间序列都完全存储在内存中，您拥有的时间序列越多，Prometheus 的内存使用率就越高。唯一的例外是内存映射块，它们被卸载到磁盘，但如果查询需要，将被读入内存。&lt;/p&gt;
&lt;p&gt;这允许 Prometheus 每秒抓取和存储数千个样本，我们最大的实例每秒附加 550k 个样本，同时还允许我们同时查询所有指标。&lt;/p&gt;
&lt;p&gt;但是您不能将所有内容永远保存在内存中，即使数据的内存映射部分也是如此。&lt;/p&gt;
&lt;p&gt;每两个小时 Prometheus 就会将内存中的块持久化到磁盘上。这个过程也与挂钟对齐，但偏移了一个小时。&lt;/p&gt;
&lt;p&gt;当使用普罗米修斯默认值并假设我们每两个小时的挂钟有一个块时，我们会看到：&lt;/p&gt;
&lt;p&gt;02:00 - 为 02:00 - 03:59 时间范围创建一个新块&lt;br/&gt;
03:00 - 为 00:00 - 01:59 写一个块&lt;br/&gt;
04:00 - 为 04:00 - 05:59 时间范围创建一个新块&lt;br/&gt;
05:00 - 为 02:00 - 03:59 写一个块&lt;br/&gt;
……&lt;br/&gt;
22:00 - 为 22:00 - 23:59 时间范围创建一个新块&lt;br/&gt;
23:00 - 为 20:00 - 21:59 写一个块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvjBXjSYG.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦一个块被写入一个块，它就会从 memSeries 中移除，从而从内存中移除。Prometheus 将在配置的保留期内将每个块保留在磁盘上。&lt;/p&gt;
&lt;p&gt;块最终将被“压缩”，这意味着 Prometheus 将采用多个块并将它们合并在一起以形成一个覆盖更大时间范围的块。这个过程有助于减少磁盘使用，因为每个块都有一个占用大量磁盘空间的索引。通过将多个块合并在一起，可以重复使用该索引的大部分，从而允许 Prometheus 使用相同数量的存储空间存储更多数据。&lt;/p&gt;
&lt;h2 id=&quot;heading-4&quot;&gt;第六步——垃圾收集&lt;/h2&gt;
&lt;p&gt;在将块写入块并从 memSeries 中删除后，我们可能会得到一个没有块的 memSeries 实例。如果任何时间序列不再被任何应用程序公开，那么就会发生这种情况，因此没有试图向其附加更多样本的刮擦。&lt;/p&gt;
&lt;p&gt;一种常见的模式是将软件版本导出为 build_info 指标，Prometheus 本身也这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.42.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 Prometheus 2.43.0 发布时，该指标将导出为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.43.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这意味着带有 version=”2.42.0” 标签的时间序列将不再接收任何新样本。&lt;/p&gt;
&lt;p&gt;一旦这个时间序列的最后一个块被写入一个块并从 memSeries 实例中删除，我们就没有剩下的块了。这意味着我们的 memSeries 仍然消耗一些内存（主要是标签），但实际上没有做任何事情。&lt;/p&gt;
&lt;p&gt;为了摆脱这样的时间序列，Prometheus 将在写入一个块后立即运行“head 垃圾回收”（记住 Head 是包含所有 memSeries 的结构）。这个垃圾收集，除其他外，将寻找任何没有单个块的时间序列，并将其从内存中删除。&lt;/p&gt;
&lt;p&gt;由于这发生在写入一个块之后，并且写入一个块发生在块窗口的中间（与挂钟对齐的两个小时片），唯一会找到的 memSeries 是那些“孤立的”——它们之前收到过样本，但现在不是了。&lt;/p&gt;
&lt;h2 id=&quot;heading-5&quot;&gt;这是什么意思呢？&lt;/h2&gt;
&lt;p&gt;Prometheus 中使用的 TSDB 是一种特殊的数据库，针对非常特定的工作负载进行了高度优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从应用程序中抓取的时间序列保存在内存中。&lt;/li&gt;
&lt;li&gt;如果有连续更新，样本将使用最有效的编码进行压缩。&lt;/li&gt;
&lt;li&gt;几个小时前的块被写入磁盘并从内存中删除。&lt;/li&gt;
&lt;li&gt;当时间序列从应用程序中消失并且不再被抓取时，它们仍然保留在内存中，直到所有块都写入磁盘并且垃圾收集将它们删除。&lt;br/&gt;
这意味着 Prometheus 在一遍又一遍地连续抓取相同的时间序列时效率最高。当它只抓取时间序列一次而不再抓取时，效率最低——与使用该内存存储的信息量相比，这样做会带来显着的内存使用开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们试着想象一下普罗米修斯是如何设计完美的数据类型的，我们最终会得到这样的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvtcxhQhh.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一些连续的线条描述了一些观察到的特性。&lt;/p&gt;
&lt;p&gt;另一方面，如果我们想可视化 Prometheus 在处理时效率最低的数据类型，我们将以这样的方式结束：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvuNXZzhC.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们有单个数据点，每个数据点代表我们测量的不同属性。&lt;/p&gt;
&lt;p&gt;尽管您可以调整 Prometheus 的一些行为，并通过传递其中一个隐藏的标志来调整它以用于短暂的时间序列，但通常不鼓励这样做。这些标志仅用于测试，可能会对 Prometheus 服务器的其他部分产生负面影响。&lt;/p&gt;
&lt;p&gt;为了更好地理解短暂时间序列对内存使用的影响，让我们看另一个例子。&lt;/p&gt;
&lt;p&gt;让我们看看如果我们在 00:25 启动我们的应用程序会发生什么，允许 Prometheus 在它导出时抓取它一次：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.42.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在第一次抓取之后立即将我们的应用程序升级到新版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.43.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 00:25 Prometheus 将创建我们的 memSeries，但我们必须等到 Prometheus 写入一个包含 00:00-01:59 数据的块并运行垃圾收集，然后 memSeries 从内存中删除，这将在 03 发生： 00。&lt;/p&gt;
&lt;p&gt;这个单个样本（数据点）将创建一个时间序列实例，该实例将使用资源在内存中保留超过两个半小时，这样我们就有了一个时间戳和值对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvzPWb7Vo.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们要连续抓取大量仅存在很短时间的时间序列，那么我们将在内存中慢慢积累大量 memSeries，直到下一次垃圾回收。&lt;/p&gt;
&lt;p&gt;查看此类 Prometheus 服务器的内存使用情况，我们会看到这种模式随时间重复出现：&lt;br/&gt;
&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvBuZp6WG.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的重要信息是短暂的时间序列很昂贵。只被抓取一次的时间序列保证在 Prometheus 中存活一到三个小时，具体取决于抓取的确切时间。&lt;/p&gt;
&lt;h2 id=&quot;heading-6&quot;&gt;基数的代价&lt;/h2&gt;
&lt;p&gt;至此我们应该知道一些关于 Prometheus 的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们知道什么是指标、样本和时间序列。&lt;/li&gt;
&lt;li&gt;我们知道，指标上的标签越多，它可以创建的时间序列就越多。&lt;/li&gt;
&lt;li&gt;我们知道每个时间序列都会保存在内存中。&lt;/li&gt;
&lt;li&gt;我们知道时间序列会在内存中保留一段时间，即使它们只被刮掉一次。&lt;br/&gt;
考虑到所有这些，我们现在可以看到问题 - 一个具有高基数的指标，尤其是具有来自外部世界的标签值的指标，很容易在很短的时间内创建大量时间序列，导致基数爆炸。这会增加 Prometheus 的内存使用量，如果它使用了所有可用的物理内存，这可能会导致 Prometheus 服务器崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更好地了解这个问题，让我们调整示例指标以跟踪 HTTP 请求。&lt;/p&gt;
&lt;p&gt;我们的指标将有一个存储请求路径的标签。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(http_requests_total, &#x27;The total number of HTTP requests.&#x27;, [&#x27;path&#x27;])

# HTTP request handler our web server will call
def handle_request(path):
  c.labels(path).inc()
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们使用 curl 命令发出单个请求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl https://app.example.com/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们应该在我们的应用程序中看到这些时间序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{path=&quot;/index.html&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果一个邪恶的黑客决定向我们的应用程序发送一堆随机请求会发生什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl https://app.example.com/jdfhd5343
&amp;gt; curl https://app.example.com/3434jf833
&amp;gt; curl https://app.example.com/1333ds5
&amp;gt; curl https://app.example.com/aaaa43321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将创建额外的时间序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{path=&quot;/index.html&quot;} 1
http_requests_total{path=&quot;/jdfhd5343&quot;} 1
http_requests_total{path=&quot;/3434jf833&quot;} 1
http_requests_total{path=&quot;/1333ds5&quot;} 1
http_requests_total{path=&quot;/aaaa43321&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有 1,000 个随机请求，我们最终会在 Prometheus 中得到 1,000 个时间序列。如果我们的指标有更多标签，并且所有标签都是根据请求负载（HTTP 方法名称、IP、标头等）设置的，我们很容易得到数百万个时间序列。&lt;/p&gt;
&lt;p&gt;通常它不需要任何恶意行为者来引起与基数相关的问题。一类常见的错误是在指标上贴上错误标签并将原始错误对象作为值传递。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(errors_total, &#x27;The total number of errors.&#x27;, [error])

def my_func:
  try:
    ...
  except Exception as err:
    c.labels(err).inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要处理的错误是一般性的，例如“权限被拒绝”，这很有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;errors_total{error=&quot;Permission Denied&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果错误字符串包含一些特定于任务的信息，例如我们的应用程序无法访问的文件的名称，或者 TCP 连接错误，那么我们可能很容易以这种方式得到高基数指标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;errors_total{error=&quot;file not found: /myfile.txt&quot;} 1
errors_total{error=&quot;file not found: /other/file.txt&quot;} 1
errors_total{error=&quot;read udp 127.0.0.1:12421-&amp;gt;127.0.0.2:443: i/o timeout&quot;} 1
errors_total{error=&quot;read udp 127.0.0.1:14743-&amp;gt;127.0.0.2:443: i/o timeout&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦被抓取，所有这些时间序列将在内存中保留至少一小时。在 Prometheus 中持续累积时间序列非常容易，直到内存不足。即使是 Prometheus 自己的客户端库也有可能使您面临此类问题的错误。&lt;/p&gt;
&lt;h2 id=&quot;heading-7&quot;&gt;时间序列需要多少内存？&lt;/h2&gt;
&lt;p&gt;Prometheus 中存储的每个时间序列（作为 memSeries 实例）包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有标签的副本。&lt;/li&gt;
&lt;li&gt;包含样本的块。&lt;/li&gt;
&lt;li&gt;Prometheus 内部所需的额外字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标签所需的内存量将取决于这些标签的数量和长度。您拥有的标签越多，或者名称和值越长，使用的内存就越多。&lt;/p&gt;
&lt;p&gt;Prometheus 内部存储标签的方式也很重要，但这是用户无法控制的。有一个开放的拉取请求，它通过将所有标签存储为单个字符串来改进标签的内存使用。&lt;/p&gt;
&lt;p&gt;块将消耗更多内存，因为它们在每次抓取之后慢慢填充更多样本，因此这里的内存使用将遵循一个循环 - 我们从附加第一个样本时的低内存使用开始，然后内存使用缓慢上升直到新的块被创建，我们重新开始。&lt;/p&gt;
&lt;p&gt;您可以通过在 Prometheus 服务器上运行此查询来计算您的时间序列需要多少内存：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go_memstats_alloc_bytes / prometheus_tsdb_head_series&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;请注意，您的 Prometheus 服务器必须配置为自行抓取才能正常工作。&lt;/p&gt;
&lt;p&gt;其次这个计算是基于 Prometheus 使用的所有内存，而不仅仅是时间序列数据，所以它只是一个近似值。使用它来粗略了解每个时间序列使用了多少内存，不要假设它是那个确切的数字。&lt;/p&gt;
&lt;p&gt;第三，Prometheus 是用Golang编写的，这是一种具有垃圾收集功能的语言。因此，Prometheus 所需的实际物理内存量通常会更高，因为它将包括需要由 Go 运行时释放的未使用（垃圾）内存。&lt;/p&gt;
&lt;h2 id=&quot;prometheus&quot;&gt;保护普罗米修斯免受基数爆炸Prometheus&lt;/h2&gt;
&lt;p&gt;确实提供了一些选项来处理高基数问题。您可以在抓取配置块中设置许多选项。以下是 Prometheus 文档中相关选项的摘录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# An uncompressed response body larger than this many bytes will cause the
# scrape to fail. 0 means no limit. Example: 100MB.
# This is an experimental feature, this behaviour could
# change or be removed in the future.
[ body_size_limit: &amp;lt;size&amp;gt; | default = 0 ]
# Per-scrape limit on number of scraped samples that will be accepted.
# If more than this number of samples are present after metric relabeling
# the entire scrape will be treated as failed. 0 means no limit.
[ sample_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on number of labels that will be accepted for a sample. If
# more than this number of labels are present post metric-relabeling, the
# entire scrape will be treated as failed. 0 means no limit.
[ label_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on length of labels name that will be accepted for a sample.
# If a label name is longer than this number post metric-relabeling, the entire
# scrape will be treated as failed. 0 means no limit.
[ label_name_length_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on length of labels value that will be accepted for a sample.
# If a label value is longer than this number post metric-relabeling, the
# entire scrape will be treated as failed. 0 means no limit.
[ label_value_length_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape config limit on number of unique targets that will be
# accepted. If more than this number of targets are present after target
# relabeling, Prometheus will mark the targets as failed without scraping them.
# 0 means no limit. This is an experimental feature, this behaviour could
# change in the future.
[ target_limit: &amp;lt;int&amp;gt; | default = 0 ]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置所有与标签长度相关的限制可以避免极长的标签名称或值最终占用过多内存的情况。&lt;/p&gt;
&lt;p&gt;回到我们带有错误标签的指标，我们可以想象这样一种场景，其中某些操作返回一条巨大的错误消息，甚至是包含数百行的堆栈跟踪。如果这样的堆栈跟踪最终作为标签值，它将比其他时间序列占用更多的内存，甚至可能是兆字节。由于标签在 Prometheus 处理查询时被复制，这可能会导致内存使用量显着增加。&lt;/p&gt;
&lt;p&gt;设置 label_limit 提供了一些基数保护，但即使只有一个标签名称和大量值，我们也可以看到高基数。通过 sample_limit 是避免高基数的最终保护。它使我们能够对可以从每个应用程序实例中抓取的时间序列数量实施硬性限制。所有这些限制的不利之处在于，违反其中任何一个都会导致整个抓取错误。&lt;/p&gt;
&lt;p&gt;如果我们将 sample_limit 配置为 100 并且我们的指标响应包含 101 个样本，那么 Prometheus根本不会抓取任何内容。这是 Prometheus 开发人员经过深思熟虑做出的设计决定。&lt;/p&gt;
&lt;p&gt;主要动机似乎是处理部分抓取的指标很困难，最好将失败的抓取视为事件。&lt;/p&gt;
&lt;h2 id=&quot;cloudflare-&quot;&gt;Cloudflare 如何处理高基数？&lt;/h2&gt;
&lt;p&gt;我们在世界各地拥有数百个数据中心，每个数据中心都有专门的 Prometheus 服务器负责抓取所有指标。每个 Prometheus 都在抓取数百个不同的应用程序，每个应用程序都运行在数百台服务器上。结合起来有很多不同的指标。意外导致基数问题并不难，过去我们已经处理过很多与之相关的问题。&lt;/p&gt;
&lt;h2 id=&quot;heading-8&quot;&gt;基本限制&lt;/h2&gt;
&lt;p&gt;我们部署的最基本的保护层是抓取限制，我们对所有配置的抓取实施。这些是 99% 的应用程序导出指标永远不会超过的合理默认值。&lt;/p&gt;
&lt;p&gt;默认情况下，每个时间序列最多允许 64 个标签，这比大多数指标使用的要多得多。我们还将标签名称和值的长度限制为 128 和 512 个字符，这对于绝大多数刮擦来说也绰绰有余。&lt;/p&gt;
&lt;p&gt;最后，我们默认将 sample_limit 设置为 200 - 因此每个应用程序最多可以导出 200 个时间序列而无需任何操作。&lt;/p&gt;
&lt;p&gt;当有人想要导出更多时间序列或使用更长的标签时会发生什么？他们所要做的就是在他们的抓取配置中明确设置它。&lt;/p&gt;
&lt;p&gt;这些限制是为了防止意外发生，并确保如果任何应用程序正在导出大量时间序列（超过 200 个），负责它的团队就会知道这一点。这有助于我们避免应用程序导出实际上不需要的数千个时间序列的情况。一旦超过 200 个时间序列标记，您应该开始更多地考虑您的指标。&lt;/p&gt;
&lt;h2 id=&quot;ci-&quot;&gt;CI 验证&lt;/h2&gt;
&lt;p&gt;下一层保护是在有人发出拉取请求以为其应用程序添加新的或修改现有的抓取配置时在 CI（持续集成）中运行的检查。&lt;/p&gt;
&lt;p&gt;这些检查旨在确保我们在所有 Prometheus 服务器上都有足够的容量来容纳额外的时间序列，如果该更改会导致收集额外的时间序列。&lt;/p&gt;
&lt;p&gt;例如，如果有人想修改 sample_limit，假设通过将现有限制 500 更改为 2,000，对于具有 10 个目标的抓取，每个目标增加 1,500，有 10 个目标即 10*1,500=15,000 个额外的时间序列可能被刮掉。在允许合并拉取请求之前，我们的 CI 将检查所有 Prometheus 服务器是否有至少 15,000 个时间序列的备用容量。&lt;/p&gt;
&lt;p&gt;这让我们有信心在应用更改后不会使任何 Prometheus 服务器过载。&lt;/p&gt;
&lt;h2 id=&quot;heading-9&quot;&gt;我们的自定义补丁&lt;/h2&gt;
&lt;p&gt;最重要的保护层之一是我们在 Prometheus 之上维护的一组补丁。Prometheus 存储库上有一个开放的拉取请求。该补丁集由两个主要元素组成。首先是允许我们对 TSDB 随时可以存储的时间序列总数实施限制的补丁。在普罗米修斯的标准构建中没有等效的功能，如果任何刮擦产生一些样本，它们将被附加到 TSDB 内的时间序列，如果需要创建新的时间序列。这是带有未设置任何 sample_limit 的抓取的标准流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-10.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过我们的补丁，我们告诉 TSDB 允许在任何时间存储来自所有擦除的总共 N 个时间序列。因此，当 TSDB 被要求追加新样本时，它会首先检查已经存在多少时间序列。&lt;/p&gt;
&lt;p&gt;如果存储的时间序列总数低于配置的限制，那么我们将像往常一样附加样本。与标准 Prometheus 的不同之处在于，当要附加新样本时，TSDB 已经存储了它允许拥有的最大时间序列数。&lt;/p&gt;
&lt;p&gt;然后，我们的修补逻辑将检查我们要追加的样本是否属于已经存储在 TSDB 中的时间序列，或者它是否是需要创建的新时间序列。如果时间序列已经存在于 TSDB 中，那么我们允许继续追加。如果时间序列尚不存在，而我们的追加将创建它（将创建一个新的 memSeries 实例），那么我们将跳过此示例。我们还将向抓取逻辑发信号通知一些样本已被跳过。这是我们的补丁修改后的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvVhYyFb1.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行“go_memstats_alloc_bytes / prometheus_tsdb_head_series”查询，我们知道每个时间序列需要多少内存（平均），我们也知道每个服务器上有多少物理内存可供 Prometheus 使用，这意味着我们可以轻松计算粗略数量我们可以将时间序列存储在 Prometheus 中，考虑到由于 Prometheus 是用 Go 编写的，因此存在垃圾收集开销：&lt;/p&gt;
&lt;p&gt;Prometheus 可用的内存/每个时间序列的字节数 = 我们的容量&lt;/p&gt;
&lt;p&gt;这并没有捕捉到普罗米修斯的所有复杂性，但给了我们一个粗略的估计，即我们可以期望有多少时间序列的容量。&lt;/p&gt;
&lt;p&gt;通过在我们所有的普罗米修斯服务器上设置这个限制，我们知道它永远不会抓取比我们的内存更多的时间序列。这是我们避免 Prometheus 服务器因内存不足而崩溃的风险的最后一道防线。&lt;/p&gt;
&lt;p&gt;第二个补丁修改了 Prometheus 处理 sample_limit 的方式 - 使用我们的补丁而不是让整个抓取失败，它只是忽略多余的时间序列。如果我们有一个 sample_limit 设置为 200 的抓取，并且应用程序公开了 201 个时间序列，那么除了最后一个时间序列之外的所有时间序列都将被接受。这是具有 sample_limit 选项集的抓取的标准 Prometheus 流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-9.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个抓取要么成功要么失败。Prometheus 简单地计算一次抓取中有多少样本，如果超过 sample_limit 允许的数量，则抓取失败。&lt;/p&gt;
&lt;p&gt;使用我们的自定义补丁，我们不关心刮擦中有多少样本。&lt;/p&gt;
&lt;p&gt;相反，我们在将时间序列附加到 TSDB 时计算时间序列。一旦我们附加了 sample_limit 个样本，我们就开始有选择性了。仅当它们属于已存储在 TSDB 中的时间序列时，才会附加任何多余的样本（达到 sample_limit 之后）。即使在我们超过 sample_limit 之后我们仍然允许追加一些样本的原因是将样本追加到现有时间序列很便宜，它只是添加一个额外的时间戳和值对。&lt;/p&gt;
&lt;p&gt;另一方面，创建新的时间序列要昂贵得多——我们需要分配新的 memSeries 实例和所有标签的副本，并将其保存在内存中至少一个小时。&lt;/p&gt;
&lt;p&gt;这是我们修改后的流程的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-12.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个补丁都为我们提供了两个级别的保护。&lt;/p&gt;
&lt;p&gt;TSDB 限制补丁保护整个 Prometheus 不被太多的时间序列过载。这是因为阻止时间序列吃内存的唯一方法是防止它们被附加到 TSDB。一旦他们进入 TSDB 就已经太晚了。&lt;/p&gt;
&lt;p&gt;虽然 sample_limit 补丁阻止了单个抓取使用过多的 Prometheus 容量，这可能导致创建太多的时间序列并耗尽 Prometheus 的总容量（由第一个补丁强制执行），这反过来会影响所有其他抓取，因为某个新的时间系列将不得不被忽略。&lt;/p&gt;
&lt;p&gt;同时，我们的补丁通过将每次抓取的时间序列限制在某个级别，而不是硬性失败并从受影响的抓取中删除所有时间序列，这将意味着失去受影响应用程序的所有可观察性，从而为我们提供优雅的降级。&lt;/p&gt;
&lt;p&gt;还值得一提的是，如果没有我们的 TSDB 总限制补丁，我们可以继续向 Prometheus 添加新的抓取，仅此一项就可能导致耗尽所有可用容量，即使每个抓取都设置了 sample_limit 并且抓取的时间序列少于此限制允许的数量。&lt;/p&gt;
&lt;p&gt;Prometheus 本身导出的额外指标会告诉我们是否有任何抓取超出限制，如果发生这种情况，我们会提醒负责它的团队。&lt;/p&gt;
&lt;p&gt;这也有利于我们进行自助容量管理——不需要团队签署您的分配，如果 CI 检查通过，那么我们就有您的应用程序所需的容量。我们更喜欢优雅降级的主要原因是我们希望我们的工程师能够自信地部署应用程序及其指标，而无需成为 Prometheus 的主题专家。&lt;/p&gt;
&lt;p&gt;这样，即使是最没有经验的工程师也可以开始导出指标，而不必不断地想“这会导致事故吗？” &lt;/p&gt;
&lt;p&gt;另一个原因是试图掌握您的使用情况可能是一项具有挑战性的任务。&lt;br/&gt;
表面上看起来很简单，毕竟您只需要阻止自己创建太多指标、添加太多标签或设置来自不受信任来源的标签值即可。&lt;/p&gt;
&lt;p&gt;实际上，这就像尝试确保您的应用程序不使用太多资源（如 CPU 或内存）一样简单 - 您可以通过简单地分配更少的内存和进行更少的计算来实现这一点。没有比这更容易的了，直到你真正尝试去做。&lt;/p&gt;
&lt;p&gt;任何应用程序为您做的越多，它就越有用，它可能需要的资源就越多。您的需求或客户的需求会随着时间的推移而变化，因此您不能只对它可以消耗多少字节或 CPU 周期划一条线。如果你这样做，这条线最终会被重新绘制，多次。通常，在指标上添加更多标签可以让您获得更多洞察力，因此您尝试监控的应用程序越复杂，就越需要额外的标签。&lt;/p&gt;
&lt;p&gt;除此之外，在大多数情况下我们不会同时看到所有可能的标签值，它通常是所有可能组合的一小部分。&lt;/p&gt;
&lt;p&gt;例如，我们之前在示例中使用的 errors_total 指标可能根本不存在，直到我们开始看到一些错误，即使这样，也可能只会记录一两个错误。&lt;/p&gt;
&lt;p&gt;这适用于我们看到工程师正在使用的许多标签。这意味着查看一个应用程序可能导出多少个时间序列，以及它实际导出多少个，会给我们两个完全不同的数字，这使得容量规划变得更加困难。&lt;/p&gt;
&lt;p&gt;尤其是在处理部分由多个不同团队维护的大型应用程序时，每个团队都从他们的堆栈部分导出一些指标。出于这个原因，我们确实容忍了一定比例的短暂时间序列，即使它们不是普罗米修斯的完美选择并且会消耗我们更多的内存。&lt;/p&gt;
&lt;p&gt;文档最后，我们维护了一组内部文档页面，这些页面试图指导工程师完成抓取和使用指标的过程，其中包含大量特定于我们环境的信息。Prometheus 和 PromQL（普罗米修斯查询语言）在概念上非常简单，但这意味着所有复杂性都隐藏在整个指标管道的不同元素之间的交互中。&lt;/p&gt;
&lt;p&gt;从工程角度管理指标的整个生命周期是一个复杂的过程。您必须在您的应用程序中定义您的指标，使用名称和标签，以便您轻松处理生成的时间序列。&lt;/p&gt;
&lt;p&gt;然后，您必须以正确的方式配置 Prometheus 抓取并将其部署到正确的 Prometheus 服务器。接下来，您可能需要创建记录和/或警报规则以利用您的时间序列。&lt;/p&gt;
&lt;p&gt;最后，您需要创建一个仪表板来可视化所有指标并能够发现趋势。在这个过程的各个阶段都会有陷阱和犯错的余地。我们在之前关于 Prometheus 的博文中介绍了一些最基本的陷阱 -监控我们的监控。在同一篇博客文章中，我们还提到了我们用来帮助​​我们的工程师编写有效的 Prometheus 警报规则的工具之一。&lt;/p&gt;
&lt;p&gt;拥有涵盖所有特定于我们环境和最常见任务的基础知识的良好内部文档非常重要。能够回答“如何做 IX？” 无需等待主题专家，让每个人都更有效率，行动更快，同时也避免普罗米修斯专家一遍又一遍地回答相同的问题。&lt;/p&gt;
&lt;h2 id=&quot;heading-10&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;Prometheus 是一个出色且可靠的工具，但处理高基数问题可能具有挑战性，尤其是在许多不同的应用程序被同一个 Prometheus 服务器抓取的环境中。过去，我们在 Prometheus 实例过载方面遇到过很多问题，并开发了许多工具来帮助我们处理这些问题，包括自定义补丁。但解决高基数问题的关键是更好地理解 Prometheus 的工作原理以及哪种使用模式会出现问题。更好地了解 Prometheus 内部结构使我们能够维护一个快速可靠的可观察性平台，而无需过多的繁文缛节，而我们围绕它开发的工具（其中一些是开源的）可帮助我们的工程师避免最常见的陷阱并自信地进行部署.&lt;/p&gt;

        &lt;/article&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>072c53f8a083042f8f5a4368c1109b29</guid>
<title>2 万多行MyBatis源码，你知道里面用了多少种设计模式吗？</title>
<link>https://toutiao.io/k/k0nr4fi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;在MyBatis的两万多行的框架源码中，使用了大量的设计模式对工程架构中的复杂场景进行解耦，这些设计模式的巧妙使用是整个框架的精华。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过整理，大概有以下设计模式，如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30866425992779783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPiaEqmgIIcViaM4eYMkOt9WnRzRXs01d1kmrUofo9QWC3WNhzx3Y4Qwicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：创建型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;工厂模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SqlSessionFactory 的结构如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6263537906137184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtiaJWAlfP62qh4yxDuicXwMG2EVEk7j1ibICSwFicOJ893or1ZbKlu2U7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工厂模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;简单工厂是一种创建型模式，在父类中提供一个创建对象的方法，允许子类决定实例对象的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory 是获取会话的工厂，每次使用MyBatis 操作数据库时， 都会开启一个新的会话。在会话工厂的实现中，SqlSessionFactory 负责获取数据源环境配置信息、构建事务工厂和创建操作SQL 的执行器，最终返回会话实现类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类设计：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory、ObjectFactory、MapperProxyFactory 和DataSourceFactory。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Configuration 单例配置类的结构如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6967509025270758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPDiaQUbbXnHeQgH1Iia8sR2nhwlWgpRIBHVp8hpkTkPwnmAMr9dV606dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种创建型模式，能够保证一个类只有一个实例，并且提供一个访问该实例的全局节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Configuration 是一个大单例，贯穿整个会话周期，所有的配置对象（如映射、缓存、入参、出参、拦截器、注册机和对象工厂等）都在Configuration 配置项中初始化， 并且随着SqlSessionFactoryBuilder 构建阶段完成实例化操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;ErrorContext、LogFactory 和Configuration。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ResultMap 建造者模式的结构如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41155234657039713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPKDXYD8OEicS83k3dPIkxUI9fKrcZDwQSd81u8QyGRaDRIpYYqLO3ZUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;建造者模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;使用多个简单的对象一步一步地构建成一个复杂的对象，提供了一种创建对象的最佳方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;建造者模式在MyBatis 中使用了大量的XxxxBuilder，将XML 文件解析到各类对象的封装中，使用建造者及建造者助手完成对象的封装。它的核心目的是不希望把过多的关于对象的属性设置写到其他业务流程中，而是用建造者方式提供最佳的边界隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XML StatementBuilder 和CacheBuilder。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：结构型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;适配器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;日志实现类的结构如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7942238267148014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROP5r6icibZlCbnVlnVlHrFicypRCF1icicW8CrQQHOKNxxmNVECfzUiavHJnqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;适配器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能使接口不兼容的对象也可以相互合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;正是因为有太多的日志框架，包括Log4j、Log4j2 和Slf4J 等，而这些日志框架的使用接口又各有差异，为了统一这些日志框架的接口，MyBatis 定义了一套统一的接口，为所有的其他日志框架的接口做相应的适配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要集中在对Log 日志的适配上。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;代理模式的实现结构如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4747292418772563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPknMgl3bia1npjZwlyeiaFGnPDLcOhR8jicZYvU5e1YiaAOpiaRMD8U9jOTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代理模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能够提供对象的替代品或占位符。代理控制元对象的访问，并且允许在将请求提交给对象前进行一些处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;没有代理模式就不存在各类框架。就像MyBatis 中的MapperProxy 实现类， 代理工厂实现的功能就是完成DAO 接口的具体实现类的方法，配置的任何一个DAO 接口调用的CRUD 方法，都会被MapperProxy 接管，调用到方法执行器等，并返回最终的数据库执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;DriverProxy、Plugin、Invoker 和MapperProxy。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;组合模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;解析节点类的结构如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8971119133574007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPqPgVVfn9s5K9fVN8zR9WKLyoYrZSibrkZMaSGd6p3uW40QYIPcs2KBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;组合模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，可以将对象组合成树形结构以表示“部分—整体” 的层次结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis XML 动态的SQL 配置中，共提供了9 种标签（trim、where、set、foreach、if、choose、when、otherwise 和bind），使用者可以组合出各类场景的SQL 语句。而SqlNode 接口的实现就是每个组合结构中的规则节点，通过规则节点的组装，完成规则树组合模式的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要体现在对各类SQL 标签的解析上，以实现SqlNode 接口的各个子类为主。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;装饰器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;二级缓存装饰器的实现结构如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5451263537906137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtAiafB9fJsu1icgOrb2mUgkh6JTG9ibUXvjOzGNL9OLN3rSUqZLQmmUibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;装饰器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型设计模式，允许将对象放入包含行为的特殊封装对象中， 为元对象绑定新的行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;MyBatis 的所有SQL 操作都是经过SqlSession 调用SimpleExecutor 完成的， 而一级缓存的操作也是在简单执行器中处理的。这里的二级缓存因为是基于一级缓存刷新的，所以在实现上，通过创建一个缓存执行器，包装简单执行器的处理逻辑，实现二级缓&lt;/span&gt;&lt;span&gt;存操作。这里用到的就是装饰器模式，也叫俄罗斯套娃模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：行为型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;模板模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SQL 执行模板模式如图9所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7003610108303249&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPFQ2KK6dSZ7pdrzxuG5picTMrwJB8ZFlICSibwQpSfs3HtAcEpnNoibpCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模板模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。场景介绍：存在一系列可被标准定义的流程，并且流程的步骤大部分采用通用逻辑，只有一小部分是需要子类实现的，通常采用模板模式来定义这个标准的流程。就像MyBatis 的BaseExecutor 就是一个用于定义模板模式的抽象类，在这个类中把查询、修改的操作都定义为一套标准的流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;BaseExecutor、SimpleExecutor 和BaseTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;策略模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;多类型处理器策略模式的结构如图10所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.023465703971119&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPdWHmfGsN5DOnkMY7K89WKp0E0Otoqf3rSR2eZRnG5pGcXKicaUlegUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;策略模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能定义一系列算法，并将每种算法分别放入独立的类中，从而使算法的对象能够互相替换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis 处理JDBC 执行后返回的结果时，需要按照不同的类型获取对应的值，这样就可以避免大量的if 判断。所以，这里基于TypeHandler 接口对每个参数类型分别做了自己的策略实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PooledDataSource、UnpooledDataSource、BatchExecutor、ResuseExecutor、SimpleExector、CachingExecutor、LongTypeHandler、StringTypeHandler 和DateTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;迭代器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;拆解字段解析实现的结构如图11所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8194945848375451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPicHzHb7tXEM5PnZcyJXOYNiaM6CzDLqkOraWNzL5srByZ91Sibr0tCVlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;迭代器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能在不暴露集合底层表现形式的情况下遍历集合中的所有元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer 用于MyBatis 的MetaObject 反射工具包下，用来解析对象关系的迭代操作。这个类在MyBatis 中使用得非常频繁，包括解析数据源配置信息并填充到数据源类上，同时参数的解析、对象的设置都会使用这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过梳理，MyBatis大约运用了10种左右设计模式。可以说，复杂且优秀的ORM 框架源码在设计和实现的过程中都会使用大量的设计模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在解决复杂场景的问题时，需要采用分治、抽象的方法，运用设计模式和设计原则等相关知识，把问题合理切割为若干子问题，以便加以理解和解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习源码远不是只是为了应付面试，更重要的是学习优秀框架在复杂场景下的解决方案。通过学习这些优秀的方案技术，可以提高对技术设计和实现的理解，扩展编码思维，积累落地经验。只有经过这样长期的积累，我们才更有可能成为优秀的高级工程师和架构师。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot;&gt;本文节选自《手写MyBatis：渐进式源码实践》一书，欢迎阅读本书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;4.75503355704698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0nk2GSKyCib2Rk8UcW0bPHQLgcy4eEYr5Dg6G9zwumjfHFZTow1HudAXRubX7MJelvOwFP11zGEMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0413793103448277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0nk2GSKyCib2Rk8UcW0bPHQeSWslibqiatCG7JGq2qTuyoIiaNKyhQNGmRZGQ9eLCYQJxQOiaxTMO2ZdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;限时五折优惠，快快扫码抢购吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本次继续送书3本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;评论区留言，点赞最高者分别赠送一本，为了给其他同学更多机会，上一次留言中奖者本次不做统计。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTMNtGy7KWfCrdJibAYY6HtIGhhtVOFQXzkE5GcmZIhTLgxggMlCe3oMwqKNesBDoU7kfgzFHuxyeA/640?wx_fmt=gif&quot; data-w=&quot;160&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文，查看本书详情！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b61eaba73f1f28545189c1cfd6d8d6cb</guid>
<title>实战，一个高扩展、可视化低代码前端，详实、完整</title>
<link>https://toutiao.io/k/acf822h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RxEditor是一款开源企业级可视化低代码前端，目标是可以编辑所有 HTML 基础的组件。比如支持 React、VUE、小程序等，目前仅实现了 React 版。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RxEditor运行快照： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5002613695765813&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicI1xQ2HojgFfmH260ovc2KT9FvdFRQ81C5DJiaibckwx77N6UwXjyPehw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1913&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：&lt;span&gt;github.com/rxdrag/rxed…&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示地址（ Vercel 部署，需要科学的方法才能访问）：&lt;span&gt;rxeditor.vercel.app/&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍RxEditor 设计实现方法，尽可能包括技术选型、软件架构、具体实现中碰到的各种小坑、预览渲染、物料热加载、前端逻辑编排等内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注：为了方便理解，文中引用的代码滤除了细节，是实际实现代码的简化版&lt;/em&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计原则&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尽量减少对组件的入侵，最大程度使用已有组件资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置优先，脚本辅助。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础功能原子化，组合式设计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物料插件化、逻辑组件化，尽可能动态插入系统。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目的设计目标，是能够通过拖拽的方式操作基于 HTML 制作的组件，如：调整这些组件的包含关系，并设置组件属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是 React、Vue、Angluar、小程序，还是别的类似前端框架，最终都是要把 JS 组件，以DOM节点的形式渲染出来。 &lt;img data-ratio=&quot;0.6015625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicSP3PqBdrBx5sB31CUtx3l7b8Mro5g6onOjlM7oPOMNqt22Frd5QQeQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;384&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器（RxEditor）要维护一个树形模型，这个模型描述的是组件的隶属关系，以及 props。同时还能跟 dom 树交互，通过各种 dom 事件，操作组件模型树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里关键的一个点是，编辑器需要知道 dom 节点跟组件节点之间的对应关系。在不侵入组件的前提下，并且还要忽略前端库的差异，比较理想的方法是给 dom 节点赋一个特殊属性，并跟模型中组件的 id 对应，在 RxEditor 中，这个属性是rx-id，比如在dom节点中这样表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;div rx-id=&quot;one-uuid&quot;&amp;gt;  &lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器监听 dom 事件，通过事件的 target 的 rx-id 属性，就可以识别其在模型中对应组件节点。也可以通过 &lt;code&gt;document.querySelector([rx-id=&quot;${id}&quot;])&lt;/code&gt;方法，查找组件对应的 dom 节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还加了 rx-node-type 跟 rx-status 这两个辅助属性。rx-node-type 属性主要用来识别是工具箱的Resource、画布内的普通节点还是编辑器辅助组件，rx-status 计划是多模块编辑使用，不过目前该功能尚未实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rx-id 算是设计器的基础性原理，它给设计器内核抹平了前端框架的差异，几乎贯穿设计器的所有部分。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Schema 定义&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器操作的是JSON格式的组件树，设计时，设计引擎根据这个组件树渲染画布；预览时，执行引擎根据这个组件树渲染实际页面；代码生成时，可以把这个组件树生成代码；保存时，直接把它序列化存储到数据库或者文件。这个组件树是设计器的数据模型，通常会被叫做 Schema。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像阿里的 formily，它的Schema 依据的是JSON Schema 规范，并在上面做了一些扩展，他在描述父子关系的时候，用的是properties键值对：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{ &amp;lt;---- RecursionField(条件：&lt;span&gt;object&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;object&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;properties&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;username&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;phone&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-validator&quot;&lt;/span&gt;:&lt;span&gt;&quot;phone&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;email&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-validator&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    ......&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用键值对的方式存子组件（children）有几个明显的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用这样的方式渲染预览界面时，一个字段只能绑定一个控件，无法绑定多个，因为key值唯一。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;键值对不携带顺序信息，存储到数据库JSON类型的字段时，具体的后端实现语言要进行序列化与反序列化的操作，不能保证顺序，为了避免出问题，不得不加一个类似index的字段来记录顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计器引擎内部操作时，用的是数组的方式记录数据，传输到后端存储时，不得不进行转换。 鉴于上述问题，RxEditor采用了数组的形式来记录Children，与React跟Vue控件比较接近的方式：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeMeta&amp;lt;IField = any, IReactions = any&amp;gt; {&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  props?: {&lt;br/&gt;    [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;?: IField,&lt;br/&gt;  &lt;span&gt;&quot;x-reactions&quot;&lt;/span&gt;?: IReactions,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeSchema&amp;lt;IField = any, IReactions = any&amp;gt; &lt;br/&gt;  &lt;span&gt;extends&lt;/span&gt; INodeMeta&amp;lt;IField, IReactions&amp;gt; {&lt;br/&gt;  children?: INodeSchema[]&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: INodeSchema | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面formily的例子，相应转换成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{ &lt;br/&gt;  &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Profile&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;object&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;user&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;chilren&quot;&lt;/span&gt;:[&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;username&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;phone&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;rule&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 x-field 是表单数据的定义，x-reactions 是组件控制逻辑，通过前端编排来实现，这两个后面会详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是卡槽（slots），这个是 RxEditor 的原创设计，原生 Schema 直接支持卡槽，可以很大程度上支持现有组件，比如很多 React antd 组件，不需要封装就可以直接拉到设计器里来用，关于卡槽后面还会有更详细的介绍。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组件形态&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中的前端组件，要在两个地方渲染，一是设计引擎的画布，另一处是预览页面。这两处使用的是不同渲染引擎，对组件的要求也不一样，所以把组件分定义为两个形态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计形态，在设计器画布内渲染，需要提供ref或者转发rx-id，有能力跟设计引擎交互。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预览形态，预览引擎使用，渲染机制跟运行时渲染一样。相当于普通的前端组件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计形态的组件跟预览形态的组件，对应的是同一份schema，只是在渲染时，使用不同的组件实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，以React为例，详细介绍组件设计形态与预览形态之间的区别与联系，同时也介绍了如何制作设计形态的组件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有 React ref 的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分组件是最简单的，直接拿过来使用就好，这些组件的设计形态跟预览形态是一样的，在设计引擎这样渲染：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentDesignerView = memo(&lt;span&gt;(&lt;span&gt;props: { nodeId: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { nodeId } = props;&lt;br/&gt;  &lt;span&gt;//获取数据模型树中对应的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; node = useTreeNode(nodeId);&lt;br/&gt;  &lt;span&gt;//通过ref，给 dom 赋值rx-id&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handleRef = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;undefined&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    element?.setAttribute(&lt;span&gt;&quot;rx-id&quot;&lt;/span&gt;, node.id)&lt;br/&gt;  }, [node.id])&lt;br/&gt;  &lt;span&gt;//拿到设计形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = useDesignComponent(node?.meta?.componentName);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&amp;lt;Component ref={handleRef} {...realProps} &amp;gt;&lt;br/&gt;  &amp;lt;&lt;span&gt;/Component&amp;gt;)&lt;br/&gt;}))&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要 rx-id 被添加到 dom 节点上，就建立了 dom 与设计器内部数据模型的联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预览引擎的渲染相对更简单直接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ComponentViewProps = {&lt;br/&gt;  node: IComponentRenderSchema,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentView = memo((&lt;br/&gt;  props: ComponentViewProps&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { node, ...other } = props&lt;br/&gt;  &lt;span&gt;//拿到预览形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = usePreviewComponent(node.componentName)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Component {...node.props} {...other}&amp;gt;&lt;br/&gt;      {&lt;br/&gt;        node.children?.map(&lt;span&gt;&lt;span&gt;child&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (&amp;lt;ComponentView key={child.id} node={child} /&amp;gt;)&lt;br/&gt;         })&lt;br/&gt;      }&lt;br/&gt;    &amp;lt;&lt;span&gt;/Component&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无ref，但可以把未知属性转发到合适的dom节点上&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个React组件，实现方式是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentA = &lt;span&gt;(&lt;span&gt;props&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {propA, propB, ...rest} = props&lt;br/&gt;    ...&lt;br/&gt;    return(&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; {&lt;span&gt;...rest&lt;/span&gt;}&amp;gt;&lt;/span&gt;&lt;br/&gt;            ...&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;    &lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 propA 跟 propB，其它的属性被原封不动的转发到了根div上，这样的组件在设计引擎里面可这样渲染：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentDesignerView = memo(&lt;span&gt;(&lt;span&gt;props: { nodeId: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { nodeId } = props;&lt;br/&gt;  &lt;span&gt;//获取数据模型树中对应的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; node = useTreeNode(nodeId);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//拿到设计形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = useDesignComponent(node?.meta?.componentName);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&amp;lt;Component rx-id={node.id} {...node?.meta?.props} &amp;gt;&lt;br/&gt;  &amp;lt;&lt;span&gt;/Component&amp;gt;)&lt;br/&gt;}))&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样的方式，rx-id 被同样添加到 dom 节点上，从而建立了数据模型与 dom之间的关联。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过组件 id 拿到 ref&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的组件，既不能提供合适的ref，也不能转发rx-id，但是这个组件有id属性，可以通过唯一的id，来获得对应 dom 的 ref：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export const WrappedComponentA = forwardRef((props, ref)=&amp;gt;{&lt;br/&gt;    const node = useNode()&lt;br/&gt;    useLayoutEffect(() =&amp;gt; {&lt;br/&gt;      const element = node?.id ? document.getElementById(node?.id) : null&lt;br/&gt;      if (isFunction(ref)) {&lt;br/&gt;        ref(element)&lt;br/&gt;      }&lt;br/&gt;    }, [node?.id, ref])&lt;br/&gt;    return(&lt;br/&gt;       &amp;lt;ComponentA id={node?.id} {...props}/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取成高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;forwardRefById&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLInputElement&amp;gt;&lt;span&gt;(&lt;span&gt;(props: any, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; node = useNode()&lt;br/&gt;    useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; element = node?.id ? &lt;span&gt;document&lt;/span&gt;.getElementById(node?.id) : &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isFunction(ref)) {&lt;br/&gt;        ref(element)&lt;br/&gt;      }&lt;br/&gt;    }, [node?.id, ref])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;WrappedComponent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{node?.id}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;} /&amp;gt;&lt;/span&gt;&lt;br/&gt;  }))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRefById(ComponentA)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这种方式时，要确保组件的id没有其它用途。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;嵌入隐藏元素&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个组件，通过上述方式安插 rx-id 都不合适，这个组件恰好有 children 的话，可以在 children 里面插入一个隐藏元素，通过隐藏元素 dom 的parentElement 获取 ref，直接上高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; HiddenElement = styled.div&lt;span&gt;`&lt;br/&gt;  display: none;&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;forwardRefByChildren&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMElement&amp;gt;&lt;span&gt;(&lt;span&gt;(props: any, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { children, ...rest } = props&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handleRefChange = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isFunction(ref)) {&lt;br/&gt;        ref(element?.parentElement)&lt;br/&gt;      }&lt;br/&gt;    }, [ref])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;WrappedComponent&lt;/span&gt; {&lt;span&gt;...rest&lt;/span&gt;}&amp;gt;&lt;/span&gt;&lt;br/&gt;      {children}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;HiddenElement&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{handleRefChange}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;WrappedComponent&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  }))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRefByChildren(ComponentA)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;调整 ref 位置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的组件，提供了 ref，但是 ref 位置并不合适，基于 ref 指示的 dom 节点画编辑时的轮廓线的话，会显的别扭，有个这样实现的组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentA = forwardRef&amp;lt;HTMElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&amp;lt;div style={padding:16}&amp;gt;&lt;br/&gt;        &amp;lt;div ref={ref}&amp;gt;&lt;br/&gt;            ...&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;)&lt;br/&gt;}&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑时这个组件的轮廓线，会显示在内层 div，距离外层 div 差了16个像素。为了把rx-id插入到外层 div， 加入一个转换 ref 的高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 传出真实ref用的回调&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Callback = &lt;span&gt;(&lt;span&gt;element?: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; HTMLElement | &lt;span&gt;undefined&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; defaultCallback = &lt;span&gt;(&lt;span&gt;element?: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; element;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;switchRef&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent, callback: Callback = defaultCallback&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLInputElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handleRefChange = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isFunction(&lt;span&gt;ref&lt;/span&gt;)&lt;/span&gt;) {&lt;br/&gt;        ref(&lt;span&gt;callback(&lt;span&gt;element&lt;/span&gt;)&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    }, [ref]&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;WrappedComponent ref={handleRefChange} {...props} /&amp;gt;&lt;br/&gt;  }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;WrappedComponentA&lt;/span&gt; = &lt;span&gt;forwardRefByChildren&lt;/span&gt;(&lt;span&gt;ComponentA, element=&amp;gt;element?.parentElement&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组件外层包一个 div&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个组件，既不能提供合适的ref，不能转发rx-id，没有id属性，也没有children， 可以在组件外层直接包一个 div，使用div 的 ref ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRef(&lt;span&gt;(&lt;span&gt;props, ref&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{ref}&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;ComponentA&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;}/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;           &lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取成高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ReactComponent = React.FC&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | React.ComponentClass&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;wrapWithRef&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;):&lt;span&gt;ReactComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLDivElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &amp;lt;div ref = {ref}&amp;gt;&lt;br/&gt;         &amp;lt;WrappedComponent {...props} /&amp;gt;&lt;br/&gt;        &amp;lt;/div&lt;br/&gt;    }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;WrappedComponentA&lt;/span&gt; = &lt;span&gt;wrapWithRef&lt;/span&gt;(&lt;span&gt;ComponentA&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个实现方式有个明显的问题，凭空添加了一个div，隔离了 css 上下文，为了保证设计器的显示效果跟预览时一样，所见即所得，需要在组件的预览形态上也加一个div，就是说直接修改原生组件，设计形态跟预览形态都使用转换后的组件。即便是这样，也像做不可描述的事情时带T一样，有些许不爽。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;带卡槽（slots）的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 中有卡槽，分为具名卡槽跟不具名卡槽，不具名卡槽就是 children。React 中没有明确的卡槽概念，但是React.ReactNode 类型的 props 就相当于具名卡槽了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在可视化设计器中，是需要卡槽的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡槽可以非常清晰的区分组建的各个区域，并且能很好地复用逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可视化编辑器中的拖拽，是把组件拖入（拖出）children（非具名卡槽），对于具名卡槽，这种普通拖放是无能无力的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果schema不支持卡槽，通常会特殊处理一下组件，就是在组件外封装一层，并且还用不了高阶组件。比如 antd 的 List 组件，它有 header 跟 footer 两个 React.ReactNode 类型的属性，这就是两个卡槽。要想在设计器中使用这两个卡槽，设计形态的组件一般会这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { List &lt;span&gt;as&lt;/span&gt; AntdList, ListProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;antd&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ListAddonProps = {&lt;br/&gt;    hasHeader?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;    hasFooter?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; List = memo(forwardRef&amp;lt;HTMLDivElement&amp;gt;((&lt;br/&gt;    props: ListProps&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; &amp;amp; ListAddonProps, ref) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {hasHeader, hasFooter, children, ...rest} = props&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; footer = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//这里根据Schema树和children构造footer卡槽&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;    }, [children, hasFooter])&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; header = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//这里根据Schema树和children构造header卡槽&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;    }, [children, hasHeader])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&amp;lt;AntdList header = {header} header={footer} {...rest}}/&amp;gt;)&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件的设计形态也需要类似的封装，这里就不详细展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方式，相当于把所有的具名卡槽转换成非具名卡槽，然后在渲染的时候，再根据配置把非具名卡槽解析成具名卡槽。hasHeader这类属性不设置，也能解析，只是换了种实现方式，并无本质区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥有具名卡槽的前端库太多了，每一种组件都这样处理，复杂而繁琐，并且违背了设计原则：“尽量减少对组件的入侵，最大程度使用已有组件资源”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个因素，把卡槽（slots）放入了 schema，只需要在渲染的时候跟非具名卡槽稍微做一下区别，就可以插入插槽：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ComponentViewProps = {&lt;br/&gt;  node: IComponentRenderSchema,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentView = memo((&lt;br/&gt;  props: ComponentViewProps&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { node, ...other } = props&lt;br/&gt;  &lt;span&gt;//拿到预览形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = usePreviewComponent(node.componentName)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;//渲染卡槽&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; slots = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; slts: { [key: &lt;span&gt;string&lt;/span&gt;]: React.ReactElement } = {}&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; name of &lt;span&gt;Object&lt;/span&gt;.keys(node?.slots || {})) {&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; slot = node?.slots?.[name]&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (slot) {&lt;br/&gt;              slts[name] = &amp;lt;ComponentView node={slot} /&amp;gt;&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; slts&lt;br/&gt;  }, [node?.slots])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Component {...node.props} {...slots} {...other}&amp;gt;&lt;br/&gt;      {&lt;br/&gt;        node.children?.map(&lt;span&gt;&lt;span&gt;child&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (&amp;lt;ComponentView key={child.id} node={child} /&amp;gt;)&lt;br/&gt;         })&lt;br/&gt;      }&lt;br/&gt;    &amp;lt;&lt;span&gt;/Component&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是预览形态的渲染代码，设计形态类似，此处不详细展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用这样的方式处理卡槽，卡槽是不能被拖入的，只能通过属性面板的配置打开或者关闭卡槽： &lt;img data-ratio=&quot;0.7617328519855595&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicBhIuWJD1Qiblf0icIib7VrMHAUur7fXT9Q6moRzSHnXcicMhu9pAM8CpZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;277&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，卡槽只能是一个独立节点，不能是节点数组，相当于把React.ReactNode转换成了React.ReactElement，不过这个转换对用户体验的影响并不大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要独立制作设计形态的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述各种高阶组件、schema原生支持的slots，已有的组件，基本上不需要修改就可以纳入可视化设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，也有例外。有些组件，还是需要独立制作设计形态。需要独立制作设计形态的组件，一般基于两个方面的考虑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户体验；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务逻辑复杂。 在用户体验方面，看一个例子，antd 的 Button 组件。Button的使用代码：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&quot;&lt;span&gt;primary&lt;/span&gt;&quot;&amp;gt;&lt;br/&gt;    &lt;span&gt;Primary&lt;/span&gt; &lt;span&gt;Button&lt;/span&gt;&lt;br/&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件的children可以是 text 文本，text 文本不是一个组件，在编辑器中式很难被拖入的，要想拖入的话，可以加一个文本类型的组件 Text：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;Primary Button&lt;span&gt;&amp;lt;/&lt;span&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就解决了拖放问题，并且Text组件可以在很多地方被使用，也不算增加实体。但是这样每个Button 嵌套一个 Text方式，会大量增加设计器画布中控件的数量，用户体验并不好。这种情况，最好重写Buton组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; {Button &lt;span&gt;as&lt;/span&gt; AntdButton, ButtonProps} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;antd&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; Button = memo(forwardRef&amp;lt;HTMLElement&amp;gt;(&lt;br/&gt;    &lt;span&gt;(&lt;span&gt;props: ButtonProps&amp;amp;{title?:&lt;span&gt;string&lt;/span&gt;}}, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {title, ...rest} = props&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;  (&amp;lt;AntdButton {...rest}&amp;gt;&lt;br/&gt;        {title}&lt;br/&gt;    &amp;lt;&lt;span&gt;/AntdButton&amp;gt;)&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步提取为高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;mapComponent&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent, maps: { [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; mapedProps = useMemo(&lt;span&gt;() =&amp;gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; newProps = {} &lt;span&gt;as&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;&lt;span&gt;const&lt;/span&gt; key of &lt;span&gt;Object&lt;/span&gt;.keys(&lt;span&gt;props || {}&lt;/span&gt;)&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;maps[key]&lt;/span&gt;) {&lt;br/&gt;          newProps[maps[key]] = props?.[key]&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          newProps[key] = props?.[key]&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; newProps&lt;br/&gt;    }, [props]&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&lt;br/&gt;      &amp;lt;WrappedComponent ref={ref} {...mapedProps} /&amp;gt;&lt;br/&gt;    &lt;/span&gt;)&lt;br/&gt;  }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;Button&lt;/span&gt; = &lt;span&gt;mapComponent&lt;/span&gt;(&lt;span&gt;AntdButton, { title: &#x27;children&#x27; }&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑复杂的例子，典型的是table，设计形态跟预览形态的区别：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计形态&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3277693474962064&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicmYRmJ3XicWDCu3cIvib2Gjts1VLpphaibMgFexXJGGnesxaX9McExltOg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;659&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预览形态&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4746268656716418&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpic2icdQp0DrWBIStc4w1dT6rbpG1ib57fmkjH6zaaPdia9Rxcj1HfkMjgJA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种组件，是需要特殊制作的，没有什么简单的办法，具体实现请参考源码。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Material，物料的定义&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Schema，只是用来描述一个组件，这个组件相关的配置，比如多语言信息、在工具箱中的图标、编辑规则（比如：它可以被放置在哪些组件下，不能被放在什么组件下）等等这些信息，需要一个配置来描述，这个就是物料的定义。具体定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IBehaviorRule {&lt;br/&gt;  disabled?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//默认false&lt;/span&gt;&lt;br/&gt;  selectable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可选中，默认为true&lt;/span&gt;&lt;br/&gt;  droppable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction&lt;span&gt;//是否可作为拖拽容器，默认为false&lt;/span&gt;&lt;br/&gt;  draggable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可拖拽，默认为true&lt;/span&gt;&lt;br/&gt;  deletable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可删除，默认为true&lt;/span&gt;&lt;br/&gt;  cloneable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可拷贝，默认为true&lt;/span&gt;&lt;br/&gt;  resizable?: IResizable | &lt;span&gt;(&lt;span&gt;(&lt;span&gt;engine?: IDesignerEngine&lt;/span&gt;) =&amp;gt; IResizable&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;moveable&lt;/span&gt;?: &lt;span&gt;IMoveable&lt;/span&gt; | (&lt;span&gt;(&lt;span&gt;engine?: IDesignerEngine&lt;/span&gt;) =&amp;gt; IMoveable&lt;/span&gt;)  // 可用于自由布局&lt;br/&gt;  &lt;span&gt;allowChild&lt;/span&gt;?: (&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  allowAppendTo?: &lt;span&gt;(&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  allowSiblingsTo?: &lt;span&gt;(&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  noPlaceholder?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  noRef?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  lockable?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IComponentConfig&amp;lt;ComponentType = any&amp;gt; {&lt;br/&gt;  &lt;span&gt;//npm包名 生成代码用&lt;/span&gt;&lt;br/&gt;  packageName?: &lt;span&gt;string&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;//组件名称，要唯一，可以加点号：.&lt;/span&gt;&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//组件的预览形态&lt;/span&gt;&lt;br/&gt;  component: ComponentType,&lt;br/&gt;  &lt;span&gt;//组件的设计形态&lt;/span&gt;&lt;br/&gt;  designer: ComponentType,&lt;br/&gt;  &lt;span&gt;//组件编辑规则，比如是否能作为另外组件的children&lt;/span&gt;&lt;br/&gt;  behaviorRule?: IBehaviorRule&lt;br/&gt;  &lt;span&gt;//右侧属性面板的配置Schema&lt;/span&gt;&lt;br/&gt;  designerSchema?: INodeSchema&lt;br/&gt;  &lt;span&gt;//组件的多语言资源&lt;/span&gt;&lt;br/&gt;  designerLocales?: ILocales&lt;br/&gt;  &lt;span&gt;//组件设计时的特殊props配置，比如Input组件的readOnly属性&lt;/span&gt;&lt;br/&gt;  designerProps?: IDesignerProps&lt;br/&gt;  &lt;span&gt;//组件在工具箱中的配置&lt;/span&gt;&lt;br/&gt;  resource?: IResource&lt;br/&gt;  &lt;span&gt;//卡槽slots用到的组件，值为true时，用缺省组件DefaultSlot, &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// string时，存的是已经注册过的component resource名字&lt;/span&gt;&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: IComponentConfig | &lt;span&gt;true&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;//右侧属性面板用的多语言资源&lt;/span&gt;&lt;br/&gt;  toolsLocales?: ILocales，&lt;br/&gt;  &lt;span&gt;//右侧属性面板用到的扩展组件。是的，组合式设计，都可以配置&lt;/span&gt;&lt;br/&gt;  tools?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: ComponentType | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IBehaviorRule接口定义组建的编辑规则，随着项目的逐步完善，这个接口大概率会变化，这里也没必要在意这么细节的东西，要重点关注的是IComponentConfig接口，这就是一个物料的定义，泛型使用的ComponetType是为了区别前端差异，比如React的物料定义是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ReactComponent = React.FC&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; &lt;br/&gt;    | React.ComponentClass&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IComponentMaterial &lt;br/&gt;    &lt;span&gt;extends&lt;/span&gt; IComponentConfig&amp;lt;ReactComponent&amp;gt; {&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物料如何使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物料定义，包含了一个组件的所有内容，直接注册进设计器，就可以使用。后面会有相关讲述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物料的热加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个不想热加载的低代码平台，不是一个有出息的平台。但是，这个版本并没有来得及做热加载，后续版本会补上。这里简单分享前几个版本的热加载经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个物料的定义是一个js对象，只要能拿到这个队形，就可以直接使用。热加载要解决的问题式拿到，具体拿到的方式可能有这么几种：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;import&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;js 原生import可以引入远程定义的物料，但是这个方式有个明显的缺点，就是不能跨域。如果没有跨域需求，可以用这种方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;webpack组件联邦&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看网上介绍，这种方式似乎可行，但并没有尝试过，有类似尝试的朋友，欢迎留言。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;src引入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式可行的，并且以前的版本中已经成功实现，具体做法是在编译的物料库里，把物料的定义挂载到全局window对象上，在编辑器里动态创建一个 script 元素，在load事件中，从全局window对象上拿到定义，具体实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadJS&lt;/span&gt;(&lt;span&gt;src: string, clearCache = false&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;HTMLScriptElement&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;HTMLScriptElement&amp;gt;&lt;span&gt;(&lt;span&gt;(resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;script&quot;&lt;/span&gt;, {});&lt;br/&gt;    script.type = &lt;span&gt;&quot;text/JavaScript&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (clearCache) {&lt;br/&gt;      script.src = src + &lt;span&gt;&quot;?t=&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().getTime();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      script.src = src;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (script.addEventListener) {&lt;br/&gt;      script.addEventListener(&lt;span&gt;&quot;load&quot;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        resolve(script)&lt;br/&gt;      });&lt;br/&gt;      script.addEventListener(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Script错误&quot;&lt;/span&gt;, e)&lt;br/&gt;        reject(e)&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.head.appendChild(script);&lt;br/&gt;&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadPlugin&lt;/span&gt;(&lt;span&gt;url: string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;IPlugin&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; path = trimUrl(url);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; indexJs = path + &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;IPlugin&amp;gt;&lt;span&gt;(&lt;span&gt;(resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    loadJS(indexJs, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;      .then(&lt;span&gt;(&lt;span&gt;script&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//从全局window上拿到物料的定义&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; rxPlugin = &lt;span&gt;window&lt;/span&gt;.rxPlugin&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;加载结果&quot;&lt;/span&gt;, &lt;span&gt;window&lt;/span&gt;.rxPlugin)&lt;br/&gt;        &lt;span&gt;window&lt;/span&gt;.rxPlugin = &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;        rxPlugin &amp;amp;&amp;amp; resolve(rxPlugin);&lt;br/&gt;        script?.remove();&lt;br/&gt;      })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        reject(err);&lt;br/&gt;      })&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物料的单独打包使用webpack，这个工具不是很熟练，勉强能用。有熟悉的大佬欢迎留言指导一下，不胜感激。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器的画布目前使用的iframe，选择iframe的原因，后面会有详细介绍。使用iframe时，相当于一个应用启动了两套React，如果从设计器通过window对象，把物料传给iframe画布，react会报错。所以需要在iframe内部单独热加载物料，切记！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;状态管理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不考虑其它前端库，只考虑React的话，状态管理肯定会选择recoil。如果要考虑vue、angular等其它前端，就只能放弃recoil，从知道的其它库里选：redux、mobx、rxjs。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rxjs虽然看起来不错，但是没有使用经验，暂时放弃了。mobx，个人不喜欢，与上面的设计原则“尽量减少对组件的入侵，最大程度使用已有组件资源”相悖，也只能放弃。最后，选择了Redux。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Redux的代码看起来会繁琐一些，好在这种可视化项目本身的状态并不多，这种繁琐度是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用过程中发现，Redux做低代码状态管理，有很多不错的优势。足够轻量，数据的流向清晰明了，可以精确控制订阅。并且，Redux对配置是友好的，在可视化业务编排里，配置订阅其状态数据非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年少无知的的时候，曾经诋毁过Reudx。不管以前说过多少Redux坏话，它还是优雅地在那里，任你随时取用，不介曾经意被你误解过，不在意是否被你咒骂过。或许，这就是开源世界的包容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前项目里，有三个地方用到了Redux，这三处位置以后会独立成三个npm包，所以各自维护自己的状态树的Root 节点，也就是分别维护自己的状态树。这三个状态树分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计器状态树&lt;/strong&gt; 设计器引擎逻辑上维护一棵节点树，节点树跟带 rx-id 的 dom 节点一一对应。前面定义的schema，是协议性质，用于传输、存储。设设计引擎会把schema转换成节点树，然后展平存储在Redux里面。节点树的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//这个INodeMeta跟上面Schema定义部分提到的，是一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeMeta&amp;lt;IField = any, IReactions = any&amp;gt; {&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  props?: {&lt;br/&gt;    [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;?: IField,&lt;br/&gt;  &lt;span&gt;&quot;x-reactions&quot;&lt;/span&gt;?: IReactions,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//节点经由Schema转换而成&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ITreeNode {&lt;br/&gt;  &lt;span&gt;//节点唯一ID，对应dom节点上的rx-id&lt;/span&gt;&lt;br/&gt;  id: ID&lt;br/&gt;  &lt;span&gt;//组件标题&lt;/span&gt;&lt;br/&gt;  title?: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//组件描述&lt;/span&gt;&lt;br/&gt;  description?: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//组件Schema&lt;/span&gt;&lt;br/&gt;  meta: INodeMeta&lt;br/&gt;  &lt;span&gt;//父节点Id&lt;/span&gt;&lt;br/&gt;  parentId?: ID&lt;br/&gt;  &lt;span&gt;//子节点Id&lt;/span&gt;&lt;br/&gt;  children: ID[]&lt;br/&gt;  是否是卡槽节点&lt;br/&gt;  isSlot: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//卡槽节点id键值对&lt;/span&gt;&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: ID&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//文档id，设计器底层模型支持多文档&lt;/span&gt;&lt;br/&gt;  documentId: ID&lt;br/&gt;  &lt;span&gt;//标识专用属性，不通过外部传入，系统自动构建&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//包含rx-id，rx-node-type，rx-status三个属性&lt;/span&gt;&lt;br/&gt;  rxProps?: RxProps&lt;br/&gt;  &lt;span&gt;//设计时的属性，比如readOnly， open等&lt;/span&gt;&lt;br/&gt;  designerProps?: IDesignerProps&lt;br/&gt;  &lt;span&gt;//用来编辑属性的schema&lt;/span&gt;&lt;br/&gt;  designerSchema?: INodeSchema&lt;br/&gt;  &lt;span&gt;//设计器专用属性，比如是否锁定&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//designerParams?: IDesignerParams&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;展平到Redux里面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//多文档模型，一个文档的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; DocumentState = {&lt;br/&gt;  &lt;span&gt;//知否被修改过&lt;/span&gt;&lt;br/&gt;  changed: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//被选中的节点&lt;/span&gt;&lt;br/&gt;  selectedIds: ID[] | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//操作快照&lt;/span&gt;&lt;br/&gt;  history: ISnapshot[]&lt;br/&gt;  &lt;span&gt;//根节点Id&lt;/span&gt;&lt;br/&gt;  rootId?: ID&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; DocumentByIdState = {&lt;br/&gt;  [key: &lt;span&gt;string&lt;/span&gt;]: DocumentState | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; NodesById = {&lt;br/&gt;  [id: ID]: ITreeNode&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; State = {&lt;br/&gt;  &lt;span&gt;//状态id&lt;/span&gt;&lt;br/&gt;  stateId: StateIdState&lt;br/&gt;  &lt;span&gt;//所有的文档模型&lt;/span&gt;&lt;br/&gt;  documentsById: DocumentByIdState&lt;br/&gt;  &lt;span&gt;//当前激活文档的id&lt;/span&gt;&lt;br/&gt;  activedDocumentId: ID | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//所有文档的节点，为了以后支持跨文档拖放，全部节点放在根下&lt;/span&gt;&lt;br/&gt;  nodesById: NodesById&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据模型状态树&lt;/strong&gt; fieldy模块的数据模型主要用来管理页面的数据模型，树状结构，Immutble的。数据模型中的数据，通过 schema 的 x-field 属性绑定到具体组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预览页面、右侧属性面板都是用这个模型（右侧属性面板就是一个运行时模块，根页面预览使用相同的渲染引擎，就是说右侧属性面板是基于低代码配置来实现的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//字段状态&lt;br/&gt;export type FieldState = {&lt;br/&gt;  //自动生成id，用于组件key值&lt;br/&gt;  id: string;&lt;br/&gt;  //字段名&lt;br/&gt;  name?: string;&lt;br/&gt;  //基础路径&lt;br/&gt;  basePath?: string;&lt;br/&gt;  //路径，path=basePath + &quot;.&quot; + name&lt;br/&gt;  path: string;&lt;br/&gt;  //字段是否已被初始化&lt;br/&gt;  initialized?: boolean;&lt;br/&gt;  //字段是否已挂载&lt;br/&gt;  mounted?: boolean; &lt;br/&gt;  //字段是否已卸载&lt;br/&gt;  unmounted?: boolean; &lt;br/&gt;  //触发 onFocus 为 true，触发 onBlur 为 false&lt;br/&gt;  active?: boolean; &lt;br/&gt;  //触发过 onFocus 则永远为 true&lt;br/&gt;  visited?: boolean; &lt;br/&gt;  display?: FieldDisplayTypes;&lt;br/&gt;  pattern?: FieldPatternTypes;&lt;br/&gt;  loading?: boolean;&lt;br/&gt;  validating?: boolean;&lt;br/&gt;  modified?: boolean;&lt;br/&gt;  required?: boolean;&lt;br/&gt;  value?: any;&lt;br/&gt;  defaultValue?: any;&lt;br/&gt;  initialValue?: any;&lt;br/&gt;  errors?: IFieldFeedback[];&lt;br/&gt;  validateStatus?: FieldValidateStatus;&lt;br/&gt;  meta: IFieldMeta&lt;br/&gt;}&lt;br/&gt;export type FieldsState = {&lt;br/&gt;  [path: string]: FieldState | undefined&lt;br/&gt;}&lt;br/&gt;export type FormState = {&lt;br/&gt;  //字段是否已挂载&lt;br/&gt;  mounted?: boolean; &lt;br/&gt;  //字段是否已卸载&lt;br/&gt;  unmounted?: boolean; &lt;br/&gt;  initialized?: boolean;&lt;br/&gt;  pattern?: FieldPatternTypes;&lt;br/&gt;  loading?: boolean;&lt;br/&gt;  validating?: boolean;&lt;br/&gt;  modified?: boolean;&lt;br/&gt;  fields: FieldsState;&lt;br/&gt;  fieldSchemas: IFieldSchema[];&lt;br/&gt;  initialValue?: any;&lt;br/&gt;  value?: any;&lt;br/&gt;}&lt;br/&gt;export type FormsState = {&lt;br/&gt;  [name: string]: FormState | undefined&lt;br/&gt;}&lt;br/&gt;export type State = {&lt;br/&gt;  forms: FormsState&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉formily的朋友，会发现这个结构定义跟fomily很像。没错，就是这个接口的定义就是借鉴（抄）了formily。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑编排设计器状态树&lt;/strong&gt; 这个有机会再单独成文介绍吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;软件架构&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件被划分为两个比较独立的部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计器，用于设计页面，消费的是设计形态的组件。生成页面Schema。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时，把设计器生成的页面Schema，渲染为正常运行的页面，消费的是预览形态的组件。 采用分层设计架构，上层依赖下层。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计器架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器的最底层是core包，在它之上是react-core、vue-core，再往上就是shell层，比如Antd shell、Mui shell等。下图是架构图，图中虚线表示只是规划尚未实现的部分，实线是已经实现的部分。后面的介绍，也是以已经实现的 React 为主。 &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6037735849056604&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicibN3nXNWDIiaHY5icgialQibMIpKZyKNHSkVCmQk6dTZ6icblqA2KM3QkC4A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;core包是整个设计器的基础，包含了 Redux 状态树、页面互动逻辑，编辑器的各种状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-core 包定义了 react 相关的基础组件，把 core 包功能封装为hooks。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-shells 包，针对不同组件库的具体实现，比如 antd 或者 mui 等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时包含三个包：ComponentRender、fieldy跟minions，前者依赖后两者。 &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpichQiaibCxc5C1sSQZrAH5qls5vENBicPQaMib31yup36AicIlfukagW4PcqQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fieldy 是数据模型，用于组织页面数据，比如表单、字段等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;minions（小黄人）是控制器部分，用于控制页面的业务逻辑以及组件间的联动关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ComponertRender 负责把Schema 渲染为正常运行的页面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;core包的设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Core包是基于接口的设计，这样的设计方式有个明显的优点，就是清晰模块间的依赖关系，封装了具体的实现细节，能方便的单独替换某个模块。Core 包含的模块： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6485943775100401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicBsib5zKWeKG6ibq1As2gGibiajy8jnC8QR1IVAcicRUsIeX41CFuibIhErVw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器引擎是 IDesignerEngine 接口的具体实现，也是 Core 包入口，通过 IDesignerEngine 可以访问包内的其它模块。接口定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDesignerEngine&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//获取设计器当前语言代码，比如：zh-CN, en-US...&lt;/span&gt;&lt;br/&gt;    getLanguage(): string&lt;br/&gt;    &lt;span&gt;//设置设计设计语言代码&lt;/span&gt;&lt;br/&gt;    setLanguage(lang: string): void&lt;br/&gt;    &lt;span&gt;//中创建一个文档模型，注：设计器是多文档模型，core支持同时编辑多个文档&lt;/span&gt;&lt;br/&gt;    createDocument(schema: INodeSchema): IDocument&lt;br/&gt;    &lt;span&gt;//通过 id 获取文档模型&lt;/span&gt;&lt;br/&gt;    getDocument(id: ID): IDocument | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//通过节点 id 获取节点所属文档模型&lt;/span&gt;&lt;br/&gt;    getNodeDocument(nodeId: ID): IDocument | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取所有文档模型&lt;/span&gt;&lt;br/&gt;    getAllDocuments(): IDocument[] | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取监视器 monitor，监视器用于传递Redux store的状态数据&lt;/span&gt;&lt;br/&gt;    getMonitor(): IMonitor&lt;br/&gt;    &lt;span&gt;//获取Shell模块，shell用与获取设计器的事件，比如鼠标移动等&lt;/span&gt;&lt;br/&gt;    getShell(): IDesignerShell&lt;br/&gt;    &lt;span&gt;//获取组件管理器，组件管理器管理组件物料&lt;/span&gt;&lt;br/&gt;    getComponentManager(): IComponentManager&lt;br/&gt;    &lt;span&gt;//获取资源管理器，资源是指左侧工具箱上的资源，一个资源对应一个组件或者一段组件模板&lt;/span&gt;&lt;br/&gt;    getResourceManager(): IResourceManager&lt;br/&gt;    &lt;span&gt;//获取国语言资源管理器&lt;/span&gt;&lt;br/&gt;    getLoacalesManager(): ILocalesManager&lt;br/&gt;    &lt;span&gt;//获取装饰器管理器，装饰器是设计器的辅助工具，主要用于给画布内的节点添加附加dom属性，比如outline，辅助边距，数据绑定提示等&lt;/span&gt;&lt;br/&gt;    getDecoratorManager(): IDecoratorManager&lt;br/&gt;    &lt;span&gt;//获取设计动作，动作的实现方法，大部分会转换成redux的action&lt;/span&gt;&lt;br/&gt;    getActions(): IActions&lt;br/&gt;    &lt;span&gt;//注册插件，rxeditor是组合式设计，插件没有功能性接口，只是为了统一销毁被组合的对象，提供了简单的销毁接口&lt;/span&gt;&lt;br/&gt;    registerPlugin(pluginFactory: IPluginFactory): void&lt;br/&gt;    &lt;span&gt;//获取插件&lt;/span&gt;&lt;br/&gt;    getPlugin(name: string): IPlugin | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//发送 redux action&lt;/span&gt;&lt;br/&gt;    dispatch(action: IAction&amp;lt;any&amp;gt;): void&lt;br/&gt;    &lt;span&gt;//销毁设计器&lt;/span&gt;&lt;br/&gt;    destory(): void&lt;br/&gt;    &lt;span&gt;//获取一个节点的行为规则，比如是否可拖放等&lt;/span&gt;&lt;br/&gt;    getNodeBehavior(nodeId: ID): NodeBehavior&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redux store 是设计其引擎的状态管理模块，通过Monitor模块跟文档模型，把最新的状态传递出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;监视器（IMonitor）模块&lt;/strong&gt;，提供订阅接口，发布设计器状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动作管理（IActions）模块&lt;/strong&gt;，把部分常用的Redux actions 封装成通用接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文档模型（IDocument）&lt;/strong&gt;，Redux store存储了文档的状态数据，文档模型直接使用Redux store，并将其分装为更直观的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDocument&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//唯一标识&lt;/span&gt;&lt;br/&gt;    id: ID&lt;br/&gt;    &lt;span&gt;//销毁文档&lt;/span&gt;&lt;br/&gt;    destory(): void&lt;br/&gt;    &lt;span&gt;//初始化&lt;/span&gt;&lt;br/&gt;    initialize(rootSchema: INodeSchema, documentId: ID): void&lt;br/&gt;    &lt;span&gt;//把一个节点移动到树形结构的指定位置&lt;/span&gt;&lt;br/&gt;    moveTo(sourceId: ID, targetId: ID, pos: NodeRelativePosition): void&lt;br/&gt;    &lt;span&gt;//把多个节点移动到树形结构的指定位置&lt;/span&gt;&lt;br/&gt;    multiMoveTo(sourceIds: ID[], targetId: ID, pos: NodeRelativePosition): void&lt;br/&gt;    &lt;span&gt;//添加新节点，把组件从工具箱拖入画布，会调用这个方法&lt;/span&gt;&lt;br/&gt;    addNewNodes(elements: INodeSchema | INodeSchema[], targetId: ID, pos: NodeRelativePosition): NodeChunk&lt;br/&gt;    &lt;span&gt;//删除一个节点&lt;/span&gt;&lt;br/&gt;    remove(sourceId: ID): void&lt;br/&gt;    &lt;span&gt;//克隆一个节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;clone&lt;/span&gt;(sourceId: ID): void&lt;br/&gt;    &lt;span&gt;//修改节点meta数据，右侧属性面板调用这个方法修改数据&lt;/span&gt;&lt;br/&gt;    changeNodeMeta(id: ID, newMeta: INodeMeta): void&lt;br/&gt;    &lt;span&gt;//删除组件卡槽位的组件&lt;/span&gt;&lt;br/&gt;    removeSlot(id: ID, name: string): void&lt;br/&gt;    &lt;span&gt;//给一个组件卡槽插入默认组件&lt;/span&gt;&lt;br/&gt;    addSlot(id: ID, name: string): void&lt;br/&gt;    &lt;span&gt;//发送一个redux action&lt;/span&gt;&lt;br/&gt;    dispatch(action: IDocumentAction&amp;lt;any&amp;gt;): void&lt;br/&gt;    &lt;span&gt;//把当前文档状态备份为一个快照&lt;/span&gt;&lt;br/&gt;    backup(actionType: HistoryableActionType): void&lt;br/&gt;    &lt;span&gt;//撤销时调用&lt;/span&gt;&lt;br/&gt;    undo(): void&lt;br/&gt;    &lt;span&gt;//重做是调用&lt;/span&gt;&lt;br/&gt;    redo(): void&lt;br/&gt;    &lt;span&gt;//定位到某个操作快照，撤销、重做的补充&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;goto&lt;/span&gt;(index: number): void&lt;br/&gt;    &lt;span&gt;//获取文档根节点&lt;/span&gt;&lt;br/&gt;    getRootNode(): ITreeNode | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//通过id获取文档节点&lt;/span&gt;&lt;br/&gt;    getNode(id: ID): ITreeNode | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取节点schema，相当于把ItreeNode树转换成 schema 树&lt;/span&gt;&lt;br/&gt;    getSchemaTree(): INodeSchema | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;组件管理器（IComponentManager）&lt;/strong&gt;，管理组件信息（组件注册、获取等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;资源管理器（IResourceManager）&lt;/strong&gt;，管理工具箱的组件、模板资源（资源注册、资源获取等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多语言管理器（ILocalesManager）&lt;/strong&gt;，管理多语言资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Shell管理（IDesignerShell）&lt;/strong&gt;，与界面交互的通用逻辑，基于事件模型实现，类图： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6869436201780416&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicO4Sh21PJqiaJK57sbMsU4UCrysSb3QQhtq4NLFnRGriaKFsicZQWNXkrQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;674&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DesignerShell类聚合了多个驱动（IDriver），驱动通过IDispatchable接口（DesignerShell就实现了这个接口，代码中使用的就是DesignerShell）把事件发送给 DesignerShell，再由 DesignerShell 把事件分发给其它订阅者。驱动的种类有很多，比如键盘事件驱动、鼠标事件驱动、dom事件驱动等。不同的shell实现，需要的驱动也不一样，比如画布用div实现跟iframe实现，需要的驱动会略有差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着后续的进展，可以有更多的驱动被组合进项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件（IPlugin），RxEditor组合式的编辑器，只要拿到 IDesignerEngine 实例，就可以扩展编辑器的功能。只是有的时候需要在编辑器退出的时候，需要统一销毁某些资源，故而加入了一个简单的IPlugin接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IPlugin {&lt;br/&gt;  &lt;span&gt;//唯一名称，可用于覆盖默认值&lt;/span&gt;&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  destory(): &lt;span&gt;void&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中的 core/auxwidgets 跟 core/controllers 都是 IPlugin 的实现，查看这些代码，就可以明白具体功能是怎么被组合进设计器的。实际代码中，为了更好的组合，还定义了一个工厂接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; IPluginFactory = (&lt;br/&gt;  engine: IDesignerEngine,&lt;br/&gt;) =&amp;gt; IPlugin&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 IDesignerEngine 的时候直接传入不同的 Plugin 工厂就可以：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createEngine&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  plugins: IPluginFactory[],&lt;br/&gt;  options: {&lt;br/&gt;    languange?: string,&lt;br/&gt;    debugMode: boolean,&lt;br/&gt;  }&lt;br/&gt;)&lt;/span&gt;: &lt;span&gt;IDesignerEngine&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//构建IDesignerEngine&lt;/span&gt;&lt;br/&gt;    ....&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;&lt;span&gt;const&lt;/span&gt; eng = createEngine(&lt;br/&gt;      [&lt;br/&gt;        StartDragController,&lt;br/&gt;        SelectionController,&lt;br/&gt;        DragStopController,&lt;br/&gt;        DragOverController,&lt;br/&gt;        ActiveController,&lt;br/&gt;        ActivedOutline,&lt;br/&gt;        SelectedOutline,&lt;br/&gt;        GhostWidget,&lt;br/&gt;        DraggedAttenuator,&lt;br/&gt;        InsertionCursor,&lt;br/&gt;        Toolbar,&lt;br/&gt;      ],&lt;br/&gt;      {&lt;br/&gt;        debugMode: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    )&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器管理（IDecoratorManager），装饰器用于给画布内的节点，插入html标签或者属性。这些插入的元素不依赖于节点的编辑状态（依赖于编辑状态的，通过插件插入，比如轮廓线），比如给所有的节点加入辅助的outline，或者标识出已经绑定了后端数据的节点。可以自定义多种类型的装饰器，动态插入编辑器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器的接口定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//唯一名称&lt;/span&gt;&lt;br/&gt;  name: string&lt;br/&gt;  &lt;span&gt;//附加装饰器到dom节点&lt;/span&gt;&lt;br/&gt;  decorate(el: HTMLElement, node: ITreeNode): void;&lt;br/&gt;  &lt;span&gt;//从dom节点，卸载装饰器&lt;/span&gt;&lt;br/&gt;  unDecorate(el: HTMLElement): void;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDecoratorManager&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  addDecorator(decorator: IDecorator, documentId: string): void&lt;br/&gt;  removeDecorator(name: string, documentId: string): void&lt;br/&gt;  getDecorator(name: string, documentId: string): IDecorator | undefined&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个辅助轮廓线的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;const&lt;/span&gt; LINE_DECORTOR_NAME = &lt;span&gt;&quot;lineDecorator&quot;&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LineDecorator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  name: string = LINE_DECORTOR_NAME;&lt;br/&gt;&lt;br/&gt;  decorate(el: HTMLElement, node: ITreeNode): void {&lt;br/&gt;    el.classList.add(&lt;span&gt;&quot;rx-node-outlined&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  unDecorate(el: HTMLElement): void {&lt;br/&gt;    el.classList.remove(&lt;span&gt;&quot;rx-node-outlined&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//css&lt;/span&gt;&lt;br/&gt;.rx-node-outlined{&lt;br/&gt;  outline: dashed grey &lt;span&gt;1&lt;/span&gt;px;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;react-core 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个包是使用 React 对 core 进行的封装，并且提供一些通用 React 组件，不依赖具体的组件库（类似antd，mui等）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上下文（Contexts）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DesignerEngineContext&lt;/strong&gt; 设计引擎上下文，用于下发 IDesignerEngine 实例，包裹在设计器最顶层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DesignComponentsContext&lt;/strong&gt; 设计形态组件上下文，注册进设计器的组件，它们的设计形态通过这个上下文下发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PreviewComponentsContext&lt;/strong&gt; 预览形态组件上下文，注册进设计器的组件，他们的预览形态通过这个上下文下发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DocumentContext&lt;/strong&gt; 文档上下文，下发一个文档模型（IDocument），包裹在文档视图的顶层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NodeContext&lt;/strong&gt; 节点上下文，下发 ITreeNode，每个节点包裹一个这样的上下文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通用组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Designer&lt;/strong&gt; 设计器根组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DocumentRoot&lt;/strong&gt; 文档视图根组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ComponentTreeWidget&lt;/strong&gt; 在画布上渲染节点树，调用 ComponentDesignerView 递归实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;画布（Canvas）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现不依赖具体画布。使用 ComponentTreeWidget 组件实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;core 包定义了画布接口 IShellPane，和不同的画布实现逻辑（headless的）：IFrameCanvasImpl（把画布包放入iframe的实现逻辑），ShadowCanvasImpl（把画布放入Web component的实现逻辑）。如果需要，可以做一个div的画布实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在react-core包，把画布的实现逻辑跟具体界面组件挂接到一起，具体可以阅读相关代码，有问题欢迎留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画布的实现方式大概有三种方式，都有各自的优缺点，下面分别说说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;div实现方式&lt;/strong&gt;，把设计器组件树渲染在一个div内，跟设计器没有隔离，这中实现方式比较简单，性能也好。缺点就是js上下文跟css样式没有隔离机制，被设计页面的样式不够独立。类似 position:fixed 的样式需要在画布最外层加一个隔离，比如：transform:scale(1) 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应式布局，是指随着浏览器的大小改变，会呈现不同的样式，css中使用的是 @media 查询，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@media (min-width: 1200){ //&amp;gt;=1200的设备 }&lt;br/&gt;@media (min-width: 992px){ //&amp;gt;=992的设备 }&lt;br/&gt;@media (min-width: 768px){ //&amp;gt;=768的设备 }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个设计器中，如果能通过调整画布的大小来触发@media的选择，就可以直观的看到被设计的内容在不同设备上的外观。div作为画布，是模拟不了浏览器大小的，无法触发@media 查询，对响应式页面的设计并不十分友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;web component沙箱方式&lt;/strong&gt;，用 shadow dom 作为画布，把设计器组件树渲染在 shadow dom 内。这样的实现方式，性能跟div方式差不多，还可以有效隔离js上下文跟css样式，比div的实现方式稍微好一些，类似 position:fixed 的样式还是需要在画布最外层加一个隔离，比如：transform:scale(1) 。并且 shadow dom 不能模拟浏览器大小，它的大小改变也不能触发无法触发@media 查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;iframe实现方式&lt;/strong&gt;，把设计器组件树渲染在 iframe 内，iframe会隔离js跟css，并且iframe尺寸的变化也会触发 @media 查询，是非常理想的实现方式，RxEditor 最终也锁定在了这种实现方式上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往iframe内部渲染组件，也有不同的渲染方式。在 RxEditor 项目中，尝试过两种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReactDOM.Root.render渲染，这种方式需要拿到iframe里面第一个div的dom，然后传入ReactDOM.createRoot。相当于在主程序渲染画布组件，这种实现方式性能还是不错的，画面没有闪烁感。但是，组件用的css样式跟js链接，需要从外部传入iframe内部。很多组件库的不兼容这样实现方式，比如 antd 的 popup 系列组件，在这种方式下很难正常工作，要实现类似功能，不得不重写组件，与设计原则 “尽量减少对组件的入侵，最大程度使用已有组件资源” 相悖。 iframe.src方式渲染，定义一个画布渲染组件，并配置路由，把路由地址传入iframe.src：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;Routes&amp;gt;&lt;br/&gt;    ...&lt;br/&gt;    &amp;lt;Route &lt;br/&gt;        path={&#x27;/canvas-render&#x27;} &lt;br/&gt;        element={&amp;lt;IFrameCanvasRender designers={designers} /&amp;gt;}&lt;br/&gt;    &amp;gt;&lt;br/&gt;    &amp;lt;/Route&amp;gt;&lt;br/&gt;    ...&lt;br/&gt;&amp;lt;/Routes&amp;gt;&lt;br/&gt;&lt;br/&gt;//iframe渲染&lt;br/&gt;&amp;lt;iframe&lt;br/&gt;    ref={ref}&lt;br/&gt;    src={&#x27;/canvas-render&#x27;}&lt;br/&gt;    onLoad={handleLoaded}&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;lt;/iframe&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的渲染方式，完美解决了上述各种问题，就是渲染画布的时候，需要一段时间初始化React，性能上比上述方式略差。另外，热加载进来的组件不能通过window全局对象的形式传入iframe，热加载需要在iframe内部完成，否则React会报冲突警告。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;react-shells 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖于组件库部分的实现，目前只是先了 antd 版本。代码就是普通react组件跟钩子，直接翻阅一下源码就好，有问题欢迎留言。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;runner 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个包是运行时，以正常运行的方式渲染设计器生产的页面，消费的是预览形态的组件。设计器右侧的属性面板也是基于低代码实现，使用的是这个包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runner 包能渲染一个完整的前端应用，包含表单数据绑定，组件的联动。采用模型数据、行为、UI界面三者分离的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据模型在 fieldy 模块定义，基于Redux实现，前面已经介绍过其接口。这个模块，在逻辑上管理一棵数据树，组件可以绑定树的具体节点，一个节点可以绑定多个组件。绑定方式，在 schema 的 x-field 字段定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的开始的设计原则中说过，尽量减少对组件的入侵，最大程度使用已有组件资源。这就意味着，控制组件的时候，不要重写组件或者侵入其内部，而是通过组件对外的接口props来控制。在组件外层，包装一个控制器，来实现对组件的控制。比如一个组件ComponentA，控制器代码可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ControllerA{&lt;br/&gt;    setProp(name: &lt;span&gt;string&lt;/span&gt;, value: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;    subscribeToPropsChange(listener: PropsListener): UnListener&lt;br/&gt;    destory(): &lt;span&gt;void&lt;/span&gt;,&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentAController = memo(&lt;span&gt;(&lt;span&gt;props&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; [changedProps, setChangeProps] = useState&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;()&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handlePropsChange = useCallback(&lt;span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, value: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      setChangeProps(&lt;span&gt;(&lt;span&gt;changedProps: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ({ ...changedProps, [name]: value })&lt;br/&gt;      })&lt;br/&gt;    }, [])&lt;br/&gt;    &lt;br/&gt;    useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; ctrl = &lt;span&gt;new&lt;/span&gt; ControllerA()&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; unlistener = ctrl?.subscribeToPropsChange(handlePropsChange)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          ctrl.destory()&lt;br/&gt;          unlistener?.()&lt;br/&gt;        }&lt;br/&gt;    }, [])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newProps = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; { ...props, ...controller?.events, ...changedProps }&lt;br/&gt;    }, [changedProps, controller?.events, props])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&lt;br/&gt;        &amp;lt;Component {...newProps}&amp;gt;    &lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码，相当于把组件的控制逻辑抽象到ControllerA内部，通过 props 更改 ComponentA 的状态。ControllerA 的实例可以注册到全局或者通过Context下发到子组件（上面算是伪代码，未展示这部分），其它组件可以通过ControllerA 的实例，传递联动控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RxEditor中，控制器实例是通过Context逐级下发的，子组件可以调用所有父组件的控制器，因为控制器本身是个类，所以可以通过属性变量传递数据，实际的控制器定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//变量控制器，用于组件间共享数据&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IVariableController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  setVariable(name: string, value: any): void,&lt;br/&gt;  getVariable(name: string): any,&lt;br/&gt;  subscribeToVariableChange(name: string, listener: VariableListener): void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//属性控制器，用于设置组件属性&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPropController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  setProp(name: string, value: any): void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//组件控制器接口&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IComponentController&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;IVariableController&lt;/span&gt;, &lt;span&gt;IPropController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//唯一Id&lt;/span&gt;&lt;br/&gt;  id: string,&lt;br/&gt;  &lt;span&gt;//并称，编排时作为标识&lt;/span&gt;&lt;br/&gt;  name?: string,&lt;br/&gt;  &lt;span&gt;//逻辑编排的meta数据&lt;/span&gt;&lt;br/&gt;  meta: IControllerMeta,&lt;br/&gt;  subscribeToPropsChange(listener: PropsListener): UnListener&lt;br/&gt;  destory(): void,&lt;br/&gt;  &lt;span&gt;//其它&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runner 渲染跟设计器一样，是通过 ComponentView 组件递归完成的。所以 ComponentAController 可以提取为一个高阶组件 withController（具体实现请阅读代码），ComponentView 渲染组件时，根据schema配置，如果配置了 x-reactions，就给组件包裹高阶组件withController，实现组件控制器的绑定。如果配置了x-field，就给组件包裹一个数据绑定的高阶组件 withBind。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ComponentRender 调用 ComponentView， 通过递归机制把schema树渲染为真实页面。渲染时，会根据x-field的配置渲染fieldy模块的一些组件，完成数据模型的建立。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，IComponentController 的具体实现，依赖逻辑编排，逻辑编排的实现原理在下一节介绍。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逻辑编排&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一直对逻辑编排不是很感兴趣，觉得用图形化的形式实现代码逻辑，不会有什么优势。直到看到 mybricks 的逻辑编排，才发现换个思路，可以把业务逻辑组件化，逻辑编排其实大有可为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，以打地鼠逻辑为例，说一下逻辑编排的实现思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打地鼠的界面：&lt;/strong&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23577235772357724&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpiczze4dD415smbXvfOMpa5W3M1fFY1iaRIM7XBMIKe1j9gwwqmAciaat4g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左侧9个按钮是地鼠，每隔1秒会随机活动一只（变为蓝色），鼠标点击活动地鼠为击中（变为红色，并且积分器上记1分），右侧上方的输入框为计分器，下面是两个按钮用来开始或者结束游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲过，RxEditor 组件控制器是通过Context下发到子组件的，就是是说只有子组件能访问父组件的控制器，父组件访问不了子组件的控制器，兄弟组件之间也不能相互访问控制器。如果通过全局注册控制器的方式，组件之间就可以随意访问控制器，实现这种地鼠逻辑会简单些。但是，如果全局的方式注册控制器，会带来一个新的问题，就是动态表格的控制器不好注册，表格内的控件是动态生成的，他的控制器不好在设计时绑定，所以目前只考虑Context的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;游戏主控制器&lt;/strong&gt; 在最顶层的组件 antd Row 上加一个一个游戏控制，控制器取名“游戏容器”： &lt;img data-ratio=&quot;0.24483406386975579&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicCPF9fEPic9BzTLjGUNmUAcuXrUL2GRskqpPFlUNdicM6RTpeFSD61Xjg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1597&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个控制器的可视化配置： &lt;img data-ratio=&quot;0.40935297885970534&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicJU8ErT8Q8km7NmxJbUJsV3Lp2RJf6qTslrib6rNcdGhLPjHsAESqw9A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1561&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可视化配置的实现原理，改天再写吧，这里只介绍如何用它实现逻辑编排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个基于数据流的逻辑编排引擎，数据从节点的输入端口（左侧端口）流入，经过处理以后，再从输出端口（右侧端口）流出。流入与流出是基于回调的方式实现（类似Promise），并且每个节点可以有自己的状态，所以上图跟流程图有个本质的不同，流程图是单线脚本，而上图每一个节点是一个对象，有点像电影《超级奶爸》里面的小黄人，所以我给这个逻辑编排功能起名叫minions（小黄人），不同的是，这里的小黄人可以组合成另外一个小黄人，可以任意嵌套、任意组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的实现机制相当于把业务逻辑组件化了，然后再把业务逻辑组件可视化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制器的事件组件内置的，antd 的 Row 内置了三个事件：初始化、销毁、点击。可以在这些事件里实现具体的业务逻辑。本例中的初始化事件中，实现了打地鼠的主逻辑： &lt;img data-ratio=&quot;0.24338085539714868&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicfwVI8GJ8cEAZpa8FzKOkx0T1xMYabkDzROiargRdFGTmrD81QsHIyew/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监听“运行”变量，如果为true，启动一个信号发生器，信号发生器每1000毫秒产生一个信号，游戏开始；如果为false，则停止信号发生器，游戏结束。信号发生器产生信号以后，传递给一个随机数生成器，用于生成一个代表地鼠编号的随机数，这个随机数赋值给变量”活跃地鼠“，地鼠组件会订阅变量”活跃地鼠“，如果变量值跟自己的编号一致，就把自己变为激活状态&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交互相当于类的方法（实际上用一个类来实现），是自定义的。这里定义了三个交互：开始、结束、计分，一个交互就是一个类，可以通过Context下发到子组件，子组件可以实例化并用它们来组合自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始，就是把变量”运行“赋值为true，用于启动游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结束，就是把变量”运行“赋值为false，用于结束游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计分，就是把成绩+1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量相当于组件控制器类的属性，外部可以通过 subscribeToVariableChange 方法订阅变量的变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;地鼠控制器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在初始化事件中，地鼠订阅父组件”游戏容器“的活跃地鼠变量，通过条件判断节点判断是否跟自己编号一致，如果一致，把按钮的disabled属性设置为常量false，并启动延时器，延时2000毫秒以后，设置disabled为常量true，并重置按钮颜色（danger属性设置为false）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击事件的编排逻辑： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3339449541284404&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicRnX4E36cfjTHDC7EV90Ol8xnQJeibFDuAuleZIoQTsw6SQqAshP78rw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给danger属性赋值常量true（按钮变红），调用游戏容器的计分方法，增加积分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它组件也是类似的实现方式，这里就不展开了。具体的实现例子，请参考在线演示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只是初步介绍了逻辑编排的大概原理，详细实现有机会再起一篇专门文章来写吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了一个可视化前端的实现原理，包括可视化编辑、运行时渲染等方面内容，所涵盖内容，可以构建一个完整低代码前端，只是限于精力有限、篇幅有限，很多东西没有展开，详细的可以翻阅一下实现代码。有问题，欢迎留言&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>711b63cc398fb47516ebdcdcd7d21411</guid>
<title>美团自动量化工具 MTPQ 首次发布，最高加速 94%</title>
<link>https://toutiao.io/k/lroh3ln</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;nextStep-modal-body&quot;&gt;
&lt;p&gt;验证码将拨打您的电话告知，您可能会接到&lt;/p&gt;
&lt;p&gt;010、024、029、0551等开头的来电，请放&lt;/p&gt;
&lt;p&gt;心接听&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>95fbf1599bac6b8755a097bd2555a933</guid>
<title>超越10倍开发者</title>
<link>https://toutiao.io/k/456q0mo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;软件开发领域素来有10倍开发者的说法，但对于有理想的开发人员来说，在提升开发、架构能力的基础上，训练自己站在产品的角度考虑问题，将产品打造得更为符合客户和运维的需求，可能比10倍效能的个人开发者能够产生的价值更大。原文: &lt;span&gt;How to Outperform a 10x Developer&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46980676328502413&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOicM8wsoSRqaqcWxx5DNvdrRMc9rCXeVvzNLOshNXd4ZBMBMRdsBtxCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;从软件开发人员角度来看，产品系统的复杂性使其变得抽象和不可捉摸，因此开发人员倾向于将其排除在外，专注于编写代码这样直接的工作。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;10倍开发者&quot;这一说法起源于&lt;span&gt;Jeff Foster&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;写的一篇&lt;span&gt;文章&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，他在文章中对比了&lt;span&gt;超强代码能力和专注于产品的价值&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在DevOps(覆盖了从开发到运维的全方位协作)的角度来看，专注于产品要胜过编码技能，因为有时候不写新代码是对产品最好的决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文提供了具体例子，能够更好理解生产系统如何改变软件开发人员的角色，并显著改善设计系统和编写代码的方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;当质量不够时&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，高质量的代码和对技能的磨练仍然非常重要。软件开发人员应该&lt;span&gt;遵守良好的实践&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，例如自动静态检查、代码审查、单元测试以及许多其他方法。尽管如此，快速编写高质量代码只是将系统投入生产并保持其活力所需的所有任务的一小部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个意义上说，组织不应该花费太多资源来寻找和培养10倍开发者。首先，他们&lt;span&gt;可能不是真正的10倍开发者&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;。其次，持续的软件开发必须包括支撑工具，如设计文档和运维程序，这些文档必须与使用它们的人一起合作不断被审查和更新。我们可以简化协调活动，但基本的人际交互和工作流几乎不会以10倍的速度发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9月22日更新:&lt;/strong&gt; &lt;span&gt;Hajime Vukelic&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;在这篇文章中添加了一条评论，指出我的说法听起来像是说优秀的个人表现是不可能或不受欢迎的。我仍然认为这在DevOps实践中是困难的，但他深思熟虑的文章我认为是对这一主题的极好的补充，文章题为&quot;&lt;span&gt;What’s a high-differential developer&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你希望开发人员能够达到更高的水平(比如1.2倍开发者?)，以便其他团队成员能够理解和吸收更高效的技术和行为。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOibx3vBibxW7w953o3u72k97icAzOVb1DicfzaZp7nacNEAByHbgfYgDibgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;培养人才是提高生产力的更好途径，右边的角色过于独特和罕见，无法在多个团队中产生重大影响。&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一课 — 优秀需要花27倍甚至更多的时间&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我指的&quot;时间&quot;不是指&quot;几十年经验&quot;(当然这也有帮助)，而是指做伟大工作所需的实际时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使是最有才华的开发人员，也会对从原型发展到可持续的生产系统所需的时间做出糟糕的估计。我必须强调&quot;可持续的&quot;这个词，即随叫随到的轮班工人也可以产出成果，[即使不懂代码的人也可以解决问题](http://sourcepatch.blogspot.com/2021/09/asking-wrong-question-should-developers.html?view=magazine &quot;Should (only &quot;即使不懂代码的人也可以解决问题&quot;) developers be on-call?&quot;)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我最喜欢的估算产品特性总成本的方法是创建工作原型，然后将原型所花费的时间乘以27。这是对的，因为如果我需要两天时间来开发一个原型，那么整个团队可能需要将近3个月(2x27=54个工作日)的共同努力才能将其投入生产。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9月22日更新:&lt;/strong&gt; 用户&lt;span&gt;Liquid Analytics&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;在评论区提出了一个很好的观点，即27倍乘数可能成为有意义的进展的阻碍因素。我应该提到，这个想法是使用现代&quot;test in production&quot;方法来部署原型，比如利用&lt;span&gt;暗启动&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;或&lt;span&gt;特性开关&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt;进行&lt;span&gt;基于主干的开发&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么是27倍?&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Frederick Brooks Jr.在《&lt;span&gt;人月神话&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;》中解释了第一个9倍，这是他以书籍形式发表的关于软件开发的一系列具有里程碑意义的文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个3倍乘数是从可运行的代码(书中使用术语&quot;program&quot;，这是当时的特点)到可靠的应用程序(书中使用术语&quot;program product&quot;)的成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个3倍乘数来自将可靠的应用程序转换为系统(&quot;system product&quot;)所需的额外测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Brooks介绍了创建交付给客户进行内部部署的软件的各个方面(这是当时IBM业务模型的特点)，因此排除了与运营方面相关的成本，为此我添加了最后一个3倍因子(这是基于我在运维工程方面的经验，有可能你的乘数会有所不同)，以将系统转变为可运维的基于云的服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8405797101449275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOsbIaq8MEllyicoyS6AbiceWhQ6CywzsYA6HafibrZhOTBV5BV7l3iaib34w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;Brooks解释了为什么准备在客户站点部署的东西需要9倍于创建原型的工作，我增加了额外的3倍工作用来部署和维护系统。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一项乘数包括下列开发活动:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测量系统的可观测性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据系统设计编制运维规则&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持续部署流水线的开发和维护&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与其他云提供商服务的集成测试&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合所有乘数(3x3x3)，我们将原型投入生产的成本增加了27倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重要原因:&lt;/strong&gt; 虽然经验丰富的开发人员可能不会低估新功能的规模，但任何超出&lt;span&gt;2倍或3倍的因素&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;都肯定会在整个团队中产生难以处理的意外，更重要的是，会浪费我们验证新功能所需的时间，从而给运维团队带来噩梦。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二课 — 运维是一项工程而不是艺术&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，艺术都有其位置，系统的某些角落可能看起来即聪明又精致，但最终&lt;span&gt;形式服从功能&lt;/span&gt;&lt;sup&gt;[15]&lt;/sup&gt;，生产系统的功能是运行满足需求和成本目标的软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节将介绍在运维中获得的经验教训，以及如何影响设计和编码活动，这部分工作占了27倍倍数的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节没有涵盖代码开发之外的所有范围，从而避免文章过于冗长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更多的组件，更多的成本，检查每个人的预算。&lt;/strong&gt; 在设计和架构时需要考虑运维成本是我在运维期间学到的最重要一课。系统中的任何新组件都会改变运维该系统的成本结构，因此问问自己，该组件是否减少了比增加的成本更多的成本，并准备好放弃在系统中添加一些看起来非常有趣的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕竟，在同一个世界里，首席财务官们(正确的)告诉你，&lt;span&gt;增加收入比削减开支更重要&lt;/span&gt;&lt;sup&gt;[16]&lt;/sup&gt;，开发人员将其诠释为将一个50毫秒的SQL查询抽象为微服务包装的一系列分页RESTful调用(真实故事)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我并不是说要采取相反的方式来改变，但这是一个需要找到合作方式的领域，或者至少要与运维团队进行协商。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全局状态和健康检查点。&lt;/strong&gt; 如果发生停机事件，没人能够在缺乏系统状态的情况下做任何事情，特别是在具有数百个组件的微服务架构中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产系统需要总体运行状况检查点，该点聚集了来自各种依赖项的运行状况。其思想是运维人员可以快速评估(1)系统的哪些部分不起作用(2)哪些依赖项不起作用。后面会提到&quot;为什么&quot;需要这样的检查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在关于Kubernetes容器的&lt;span&gt;readiness和liveness的文章&lt;/span&gt;&lt;sup&gt;[17]&lt;/sup&gt;中列出了关于设计健康检查点的建议，那篇文章中的大多数建议也适用于非Kubernetes系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从读者的角度记录错误。&lt;/strong&gt; 一旦运维人员意识到系统不完全健康，下一步就是了解是什么原因，以及如何修复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些事情应该会发生，但却没有发生。从阅读日志消息的人的角度来看，最有用的日志消息遵循如下模板:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[ERROR|WARNING|INFO]: [Component X] attempted to [take action Y], &lt;span&gt;which&lt;/span&gt; returned [response Z].&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种格式乍一看似乎很明显，看起来像常规的主谓宾结构，但最重要的是术语:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;Component X&lt;/em&gt;&quot;是否存在于系统文档中?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;action Y&lt;/em&gt;&quot;对读者来说容易理解吗?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;&lt;em&gt;response Z&lt;/em&gt;&quot;是否在故障排除手册的某个地方提到?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.038860103626943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOQ6iczyUSnuQOJtDz3t6uickkyFLibRNDMX9044zLZDkT4PxIhwRhHHibxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;386&quot;/&gt;&lt;figcaption&gt;日志消息可以帮助解释系统行为，但前提是消息内容与官方文档的内容相匹配，或者至少通过与产品无关的论坛填补一些空白。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我读过很多错误消息，很感激有人花时间把它们添加到代码中，但我对其中引用的只对代码作者有意义的文件名和库调用犹豫不决。这些内部引用应该放在专用的跟踪文件中，或者添加&quot;debug&quot;前缀标记，以便于过滤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终，每条日志消息都必须导致一个明确的解析步骤，该步骤不涉及联系消息的作者或阅读源代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;编写系统文档:&lt;/strong&gt; 编写文档迫使我们将对系统的理解构建为一种新的媒介。除了必须告诉人们如何安装、监控、保护或排除系统故障之外，该活动还为系统带来了许多好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写作行为要求作者&lt;em&gt;对系统中难以解释的方面进行思考&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，这种困难可能表明潜在的设计缺陷，例如难以解释所有组件的正确安装顺序。其他时候，这种困难可能是由于产品的&quot;待开发&quot;区域需要为读者提供一大堆伪代码指令(&quot;&lt;em&gt;…然后点击这里，键入这个，等待几秒钟，然后一个面板将弹出，找到一个名为…的按钮&lt;/em&gt;&quot;)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果处理得当，文档还可以作为合作者的聚集点，这些合作者可能愿意贡献他们的知识，但没有时间去弄清楚如何做到这一点。这些类型的贡献对于整个生态系统(开发人员和用户)来说是巨大的生产力提升，如果不加以记录的话，往往会丢失在团组和私人对话中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;时间框调用远程组件。&lt;/strong&gt; 在分布式系统中，我们比依赖远程代理更了解如何快速可靠的响应。尽管如此，我们经常在客户端库和实用程序中使用默认的超时设置，而不加考虑，因为我们认为开发人员已经找到了适用于每个人的神奇设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个常见疏忽，因为库和实用程序都带有合理的默认值，系统采用了最新的设计和运维技术，以获得最大的可用性。对系统结果的错误信任一直持续到其中一个系统发生故障，导致组件无条件等待TCP超时达&lt;span&gt;2小时&lt;/span&gt;&lt;sup&gt;[18]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总是在代码中寻找远程调用，并确保知道它们的限制，以及代码如何处理这些限制:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6996336996336996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOGTwBrCa5LicteCUQViaxvLpaPJsb2b0poeyJHPml76YobgYJ699HKWYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;546&quot;/&gt;&lt;figcaption&gt;远程系统或系统与远程系统之间的网络路径可能非常可靠，以至于我们开始将它们视为本地内存中的函数调用。仔细检查所有库和网络堆栈，以发现它们对连接性问题和错误代码的容忍度。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对任何系统来说，为远程调用创建有效的重试策略都是一项受欢迎的改进。尽管如此，仍有可能掩盖对迫在眉睫的问题的可见性，例如掩盖响应时间的持续恶化，直到它们最终超过最大限制，这将我引向下一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;遥测、可观察性和分布式跟踪:&lt;/strong&gt; 处理停机比查看系统状态和日志条目要复杂得多。除了处理中断之外，还有更多的操作，例如主动查看系统对内部度量、跟踪和日志条目的遥测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;许多平台已经在源代码中&lt;span&gt;使用最少的指令&lt;/span&gt;&lt;sup&gt;[19]&lt;/sup&gt;生成了大量遥测数据。然而，仍然需要将大量特定于遥测的代码与源代码混合在一起，尤其对于度量(metrics)来说。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3973429951690821&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszOyFFQnkpR03Llx7C1Ce50UfKEr1sWiaOFIyJq8rqOjFVZ5SSeQ5R1vGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;可能不会每个系统组件都告诉你它是否达到了目标。让代码生成指标需要额外的努力，从而才能将它们聚合到运维团队可操作的仪表板中。&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，确保你(和其他开发人员)能够定期访问系统操作中使用的遥测框架的本地设置。许多框架支持在工作站或免费试用的基于云的帐户中本地执行，从本地环境无缝过渡到远程环境的统一设置需要开发、验证、文档编制和维护。创造这样的环境非常有趣，但也需要花费时间和金钱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再怎么强调也不为过，&lt;em&gt;即使是最有经验和自信的开发人员，在查看他们的代码遥测时，也总会学到一些新的或令人惊讶的东西。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更进一步，&lt;em&gt;与运维团队合作，确保与运维团队共享数据&lt;/em&gt;，特别关注数据匿名化和访问等方面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关注队列系统。&lt;/strong&gt; 编写队列系统很有趣，设计架构图是令人兴奋(和诱人的)，但是大多数人严重错误的判断了在系统中添加队列模式的成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我知道队列系统有一些合适用例，比如大量事务(例如每天有数百万条消息)，其中调用组件不能等待响应，而只关心事务最终在合理的时间内得到处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果不处理这些用例，可能需要认真考虑是否需要将异步消息处理包含到系统中。这种通信模式增加的成本贯穿消息生产者&quot;A&quot;和消息消费者&quot;B&quot;之间的整个业务事务。以下是关于这种额外复杂性的几个例子:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;系统管理员用于处理队列大小超过某些限制的运维流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理过期消息的额外设计和代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理过期后发送到死信队列的消息的操作过程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展系统以管理死信队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理跨消息传递的业务事务的&lt;span&gt;分布式跟踪&lt;/span&gt;&lt;sup&gt;[20]&lt;/sup&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三课 — 大杀四方:编码、构建、支持、运维&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然长期职业生涯可能会逐渐教会你DevOps实践的不同领域，但你可以通过有意的在开发、集成、支持和运维之间轮换来加快成长。我们的想法是学习事物是如何工作的，以及如何构建在工程周期的每个重要领域都能很好工作的软件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦你了解了这些领域的人员和工作流程，就更容易在核心专业知识之外做出贡献，减少技术和社交摩擦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;处于职业生涯中期和高级的开发人员可能不倾向于改变工作角色，但经验使他们能够更快学习。几个星期的临时轮岗、共享项目，甚至是处理客户支持和事件报告都可以起到同样的作用。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7958937198067633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszO0L7NMqMm2fXWpkEbZneYBKNLC2KdFNKC2qTVw4qiaibY3psVicWIjJYbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;figcaption&gt;DevOps实践鼓励更多访问和洞察不同领域。更进一步，甚至简单的在这些领域轮岗，以了解各种软件特性如何影响他们的工作。&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案例研究1(构建)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前项目中，我们有一个团队主要负责演进和维护构建系统。在本地工作站上构建(编译和打包)整个代码库大约需要两分钟。相比之下，在构建周期中，相同的操作花费了看似永恒的15分钟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建团队之外的一名开发人员花了一个下午的时间将各种日志条目添加到构建脚本中，以隔离问题，将可能的原因缩小到构建将已编译二进制文件写入磁盘的步骤。在构建系统中，磁盘写操作似乎比在本地工作站中花费的时间要长几个数量级(是的，构建机器有SDD存储:-)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建团队分析了这些发现，并尝试了不同的替代方案(其中一些方案超出了原始开发人员的Unix技能集)，最终的解决方案是增加虚拟机上的内存分配，并将每个构建的临时目录移动到内存文件系统(&lt;span&gt;tmpfs&lt;/span&gt;&lt;sup&gt;[21]&lt;/sup&gt;)。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案例研究2(运维)&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我曾经持续几个月管理整个组织(几百人)的PagerDuty升级策略和警报规则。有时，由于假期安排，当收到紧急消息时，需要越过我的直接处理范围触发警报。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在按下按钮之前，我总是会问几个问题，比如:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&quot;这些产生新警报的组件是什么时候部署的?&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;我在描述中没有看到剧本链接，运维团队知道去哪里找吗?&quot;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在不涉及偶尔混淆的令人困惑的答案的情况下，这个(兼职)任务教会了我宝贵的经验，包括管理系统中警报类型总数的重要性，向生产系统添加新组件的成本效益，以及让运维团队参与架构决策的绝对必要性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第四课 — 有意识的学习:在每一项任务中学习&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这一点上，你需要知道如何确保时间来编写用于生产的代码，以及需要在代码中包含的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个很长的清单，尽管有[&quot;1万小时&quot;规则](https://www.edsurge.com/news/2020-05-05-researcher-behind-10-000-hour-rule-says-good-teaching-matters-not-just-practice &quot;&quot;1万小时&quot;规则&quot; &quot;&quot;1万小时&quot;规则&quot;)，但你不会想要等上几十年才能自然而然获得这些技能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们总是在执行任务的过程中学习一些东西，但&lt;span&gt;刻意学习&lt;/span&gt;&lt;sup&gt;[22]&lt;/sup&gt;意味着不仅要完成工作，还要弄清楚为什么某些事情会起作用，以及如何改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索网络可能会给你某个特定问题的精确答案，人们可以通过这种方式学到很多东西，但通过有意识的学习，我们想要的是超越现成的解决方案:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;浏览。&lt;/strong&gt; 如果解决方案涉及框架的模式化解决方案，例如Terraform的一组特定资源，请返回&lt;span&gt;浏览这些资源的完整定义&lt;/span&gt;&lt;sup&gt;[23]&lt;/sup&gt;，并可能浏览来自同一提供者的邻近资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果解决方案涉及具有特定参数的实用程序，请返回实用程序手册研究这些参数，并浏览其他参数。我们的想法不是记住它们，而是&lt;strong&gt;在脑海中索引&lt;/strong&gt;它们，特别是对于&quot;&lt;span&gt;awk&lt;/span&gt;&lt;sup&gt;[24]&lt;/sup&gt;&quot;这样的工具，其手册可以是一整本书。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;解释&lt;/strong&gt;你学到了什么。对于源代码，请拿出&quot;&lt;span&gt;橡皮鸭&lt;/span&gt;&lt;sup&gt;[25]&lt;/sup&gt;&quot;，并向一个无生命的物体解释源代码。对于概念，你甚至可以不去找别人，而是使用&lt;span&gt;费曼技巧&lt;/span&gt;&lt;sup&gt;[26]&lt;/sup&gt;，假装你是在向一个孩子介绍这个概念。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;写作&lt;/strong&gt;关于主题的文章。写作是一种更有意识的学习形式，帮助你巩固和扩展对一个概念(可能是写一篇文章)、相关概念(使用技术论文之类的东西)或整个领域(例如写一本书)的知识。写作远远超越了学习，可能更有助于在头脑中组织相邻的知识。如果你决定从事这项令人兴奋的活动，一定要阅读海因里希·哈特曼(Heinrich Hartmann)的《&lt;span&gt;为工程师写作&lt;/span&gt;&lt;sup&gt;[27]&lt;/sup&gt;》。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2159090909090908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9utHkjMdE0WA52IQMacOSbiaDVgEDNszO8sic2uOqSeMUibxWqysgYOFNaJe1Ou51lkSBft062uvbHP4V5DZ7IY9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;176&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&quot;阅读产品指南?谁有时间读?&quot;&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我意识到这是一个用谷歌搜索&quot;如何让这个错误信息消失&quot;的时代，这在时间紧迫的时候很有意义。不过，你从这些捷径中学不到多少东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，我必须引用史提芬·金的话，他是有史以来最成功的小说作家之一，他给&lt;span&gt;有抱负的作家&lt;/span&gt;&lt;sup&gt;[28]&lt;/sup&gt;提供了这样一条严厉的爱的建议:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;&quot;如果你没有时间阅读，你就没有时间(或工具)写作。就是这么简单。&quot;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你没有从时间表中抽出时间来探索项目中使用的技术，并对其进行扩展，你就会限制自己只学习足够完成当前任务的技术。当你周围的人认为你只能胜任同样的任务时，这种动力就会自我强化。用不了多久，这些假设就会被证明是正确的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据不同情况，&quot;挤出&quot;时间或多或少具有挑战性，但意识到这一点是一个起点。有时你可能会不断加倍承担重复性(但有价值)的任务，因为这样更舒服。在其他时候，组织可能会对某人比其他人更有效的做重复的工作感到满意。无论情况如何，首选需要认识到你无法从每项任务中学习新东西。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DevOps实践涵盖了许多不同且广泛的流程，使得人们专注于特定领域，如软件开发、持续交付或运维。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，在人们有机会探索其他领域之前，兴趣和目标就会缩小，所以要抵制在职业生涯早期专攻的冲动和压力。作为组织，在员工可能长期呆在一个职位上所带来的生产力与&lt;span&gt;日本式的年度轮换方法&lt;/span&gt;&lt;sup&gt;[29]&lt;/sup&gt;(也许不是固定的时间表)的好处之间取得平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在职业生涯早期，与管理团队一起在编码、交付和运维方面进行&quot;实习&quot;。这种全面的经验是非常珍贵和罕见的，无论是作为程序员、系统架构师、用户体验设计师、技术客户经理、基础设施工程师，或任何其他你可能喜欢的角色，都将帮助你在任何你选择贡献的领域倍增你的潜力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿意从不同角度理解是什么让产品变得更好，并将这些经验教训融入日常生活中，这是一种超级力量，远远超过了一个实际的10倍开发人员在利基领域所能聚集的力量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归根结底，这些教训来自个人经验，每条道路都是不同的，欢迎提供反馈。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;How to Outperform a 10x Developer: &lt;em&gt;https://betterprogramming.pub/how-to-outperform-a-10x-developer-fa1132807934&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Jeff Foster&#x27;s Medium: &lt;em&gt;https://medium.com/@jeff-foster&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;The origins of the 10x developer: &lt;em&gt;https://medium.com/ingeniouslysimple/the-origins-of-the-10x-developer-2e0177ecef60&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Project vs. Product Thinking: &lt;em&gt;https://medium.com/ingeniouslysimple/project-vs-product-thinking-b4971163f3dd&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;30 best practices for software development and testing: &lt;em&gt;https://opensource.com/article/17/5/30-best-practices-software-development-and-testing&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;The 10x Programmer Myth: &lt;em&gt;https://www.simplethread.com/the-10x-programmer-myth&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;Hajime Vukelic&#x27;s Medium: &lt;em&gt;https://medium.com/@hayavuk&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;What’s a high-differential developer: &lt;em&gt;https://medium.com/@hayavuk/whats-a-high-differential-developer-2fc42e2ee6a3&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Liquid Analytics&#x27; Medium: &lt;em&gt;https://medium.com/@liquidanalytics&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;暗启动: &lt;em&gt;https://www.split.io/glossary/dark-launch&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;特性开关: &lt;em&gt;https://www.atlassian.com/continuous-delivery/principles/feature-flags&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;基于主干的开发: &lt;em&gt;https://trunkbaseddevelopment.com&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;人月神话: &lt;em&gt;https://archive.org/details/MythicalManMonth&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;2x: Simple rule for software development time estimation: &lt;em&gt;https://fibery.io/blog/software-development-time-estimation&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[15]&lt;/span&gt;&lt;p&gt;形式服从功能: &lt;em&gt;https://en.wikipedia.org/wiki/Form_follows_function&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[16]&lt;/span&gt;&lt;p&gt;增加收入比削减开支更重要: &lt;em&gt;https://twitter.com/KurtisHanni/status/1560986912613072899&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[17]&lt;/span&gt;&lt;p&gt;The ART and Science of probing a Kubernetes Container: &lt;em&gt;https://dnastacio.medium.com/the-art-and-science-of-probing-a-kubernetes-container-db1f16539080&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[18]&lt;/span&gt;&lt;p&gt;TCP man page: &lt;em&gt;https://man7.org/linux/man-pages/man7/tcp.7.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[19]&lt;/span&gt;&lt;p&gt;OpenTelemetry Instrumentation: &lt;em&gt;https://opentelemetry.io/docs/instrumentation&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[20]&lt;/span&gt;&lt;p&gt;分布式跟踪: &lt;em&gt;https://microservices.io/patterns/observability/distributed-tracing.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[21]&lt;/span&gt;&lt;p&gt;tmpfs: &lt;em&gt;https://en.wikipedia.org/wiki/Tmpfs&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[22]&lt;/span&gt;&lt;p&gt;What is intentional learning &amp;amp; what does it mean for the global reskilling emergency?: &lt;em&gt;https://learntechasia.com/intentional-learning-global-reskilling-emergency&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[23]&lt;/span&gt;&lt;p&gt;浏览这些资源的完整定义: &lt;em&gt;https://registry.terraform.io/browse/providers&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[24]&lt;/span&gt;&lt;p&gt;awk: &lt;em&gt;https://www.gnu.org/software/gawk/manual/gawk.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[25]&lt;/span&gt;&lt;p&gt;橡皮鸭: &lt;em&gt;https://en.wikipedia.org/wiki/Rubber_duck_debugging&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[26]&lt;/span&gt;&lt;p&gt;费曼技巧: &lt;em&gt;https://en.wikipedia.org/wiki/Learning_by_teaching&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[27]&lt;/span&gt;&lt;p&gt;为工程师写作: &lt;em&gt;https://www.heinrichhartmann.com/posts/writing&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[28]&lt;/span&gt;&lt;p&gt;On Writing: A Memoir of the Craft: &lt;em&gt;https://stephenking.com/works/nonfiction/on-writing-a-memoir-of-the-craft.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[29]&lt;/span&gt;&lt;p&gt;Jinji Ido: the notorious system of annual rotations: &lt;em&gt;https://wa-shoku.info/jinji-ido-the-notorious-system-of-annual-rotations&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>