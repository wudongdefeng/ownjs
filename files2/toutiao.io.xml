<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6de3366a21616cd9b1935a8f00e0ba1a</guid>
<title>浅谈 Kafka</title>
<link>https://toutiao.io/k/rxrrgf3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东科技 徐拥&lt;/p&gt;

&lt;h1&gt;入门&lt;/h1&gt;

&lt;h2&gt;1、什么是kafka?&lt;/h2&gt;

&lt;p&gt;apache Kafka is a distributed streaming platform. What exactly dose that mean?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-22Jtx0VcbUpPmiWcU.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Apache Kafka 是消息引擎系统，也是一个分布式流处理平台（Distributed Streaming Platform）&lt;/p&gt;

&lt;h2&gt;2、kafka全景图：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-23l6EiUjbO7wefuNY.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、Kafka的版本演进：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-23NQEfKZPj7Z9ZIIr.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-26ANbXnBrbO6hP10eR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4、kafka选型:&lt;/h2&gt;

&lt;p&gt;Apache Kafka：也称社区版 Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。（如果你仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么我推荐你使用 Apache Kafka）&lt;/p&gt;

&lt;p&gt;Confluent Kafka ：Confluent 公司提供的 Kafka。优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。（如果你需要用到 Kafka 的一些高级特性，那么推荐你使用 Confluent Kafka。）&lt;/p&gt;

&lt;p&gt;CDH/HDP Kafka：大数据云公司提供的 Kafka，内嵌 Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。（如果你需要快速地搭建消息引擎系统，或者你需要搭建的是多框架构成的数据平台且 Kafka 只是其中一个组件，那么我推荐你使用这些大数据云公司提供的 Kafka）&lt;/p&gt;

&lt;h2&gt;5、Kafka的基本概念：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-2710okuwPbjRFpspd10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6、Kafka的基本结构：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-27vXrCxEsmw9ULaPY.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;7、Kafka的集群结构：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-28AObChdjhewcHqNI.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;8、kafka的应用场景(用户注册/异步)：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-28TWOlj8JVcyqqXhu.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;9、kafka队列模式---点对点：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-29CSi3YckohCdK63X.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;10、kafka队列模式---发布/订阅：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-29jHAMnKmnRDqNWif.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;11、kafka构成角色：&lt;/h2&gt;

&lt;h3&gt;1、broker：&lt;/h3&gt;

&lt;p&gt;消息格式: 主题 - 分区 - 消息 、主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份&lt;/p&gt;

&lt;p&gt;这样设计的原因是：不使用多topic做负载均衡，意义在于对业务屏蔽该逻辑。业务只需要对topic进行发送，指定负载均衡策略即可 同时 topic分区是实现负载均衡以及高吞吐量的关键&lt;/p&gt;

&lt;p&gt;Topic的创建流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-31gSYeRvLtLrYRtRe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、Producer：&lt;/h3&gt;

&lt;p&gt;发送消息流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-35RQDxubChniY6eMg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、Consumer：&lt;/h3&gt;

&lt;p&gt;Kafka消费者对象订阅主题并接收Kafka的消息，然后验证消息并保存结果。Kafka消费者是消费者组的一部分。一个消费者组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。消费者组的设计是对消费者进行的一个横向伸缩，用于解决消费者消费数据的速度跟不上生产者生产数据的速度的问题，通过增加消费者，让它们分担负载，分别处理部分分区的消息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-35t33lQyxQsMO3hQha.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、Consumer Group：&lt;/h3&gt;

&lt;p&gt;它是kafka提供的具有可扩展且可容错的消费者机制&lt;/p&gt;

&lt;p&gt;特性：&lt;/p&gt;

&lt;p&gt;1、 Consumer Group下可以有一个或多个 Consumer实例；&lt;/p&gt;

&lt;p&gt;2、在一个Katka集群中，Group ID标识唯一的一个Consumer Group;&lt;/p&gt;

&lt;p&gt;3、 Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的 某个Consumer实例消费。&lt;/p&gt;

&lt;p&gt;Consumer Group 两大模型：&lt;/p&gt;

&lt;p&gt;1、如果所有实例都属于同一个Group，那么它实现的是消息队列模型；&lt;/p&gt;

&lt;p&gt;2、如果所有实例分别属于不同的GrouD，那么它实现的就是发布/订阅模型。&lt;/p&gt;

&lt;h2&gt;12、Kafka的工作流程：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-36WpTSBX3aWjhpeln.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;13、Kafka常用命令：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-38dx10vVjFaJlOaM10F.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;进阶&lt;/h1&gt;

&lt;h2&gt;14、Kafka的文件存储机制—log：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-38nCwbM52rJw52c6b38r.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;15、Kafka的文件存储机制—分片/索引：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-11-15CEalWwbhc3VYeJi.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;16、Kafka的文件存储机制—index/log：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-396xy107lRrw10w3IG6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;17、kafka 如何支持百万QPS？&lt;/h2&gt;

&lt;h4&gt;顺序读写 :&lt;/h4&gt;

&lt;p&gt;生产者写入数据和消费者读取数据都是顺序读写的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-39kKaWvi639vyFQdK8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;Batch Data（数据批量处理）：&lt;/h4&gt;

&lt;p&gt;当消费者（consumer）需要消费数据时，首先想到的是消费者需要一条，kafka发送一条，消费者再要一条kafka再发送一条。但实际上 Kafka 不是这样做的，Kafka 耍小聪明了。Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者。比如说100万条消息放在一个文件中可能是10M的数据量，如果消费者和Kafka之间网络良好，10MB大概1秒就能发送完，既100万TPS，Kafka每秒处理了10万条消息。&lt;/p&gt;

&lt;h4&gt;MMAP（内存映射文件）：&lt;/h4&gt;

&lt;p&gt;MMAP也就是内存映射文件，在64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射之后对物理内存的操作会被同步到硬盘上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-41oY6b4110scQ9qlsRo.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过MMAP技术进程可以像读写硬盘一样读写内存（逻辑内存），不必关心内存的大小，因为有虚拟内存兜底。这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。也有一个很明显的缺陷，写到MMAP中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。&lt;/p&gt;

&lt;h4&gt;Zero Copy（零拷贝）：&lt;/h4&gt;

&lt;p&gt;如果不使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44nWpVwp6BRWIn6R9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：从硬盘上将数据读到操作系统内核的缓冲区里，这个传输是通过 DMA 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：从内核缓冲区里面的数据复制到分配的内存里面，这个传输是通过 CPU 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三次传输&lt;/strong&gt;：从分配的内存里面再写到操作系统的 Socket 的缓冲区里面去，这个传输是由 CPU 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四次传输&lt;/strong&gt;：从 Socket 的缓冲区里面写到网卡的缓冲区里面去，这个传输是通过 DMA 搬运的。&lt;/p&gt;

&lt;p&gt;实际上在kafka中只进行了两次数据传输，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44Q19s6oNOoiEaZr6z.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：通过 DMA从硬盘直接读到操作系统内核的读缓冲区里面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：根据 Socket 的描述符信息直接从读缓冲区里面写入到网卡的缓冲区里面。&lt;/p&gt;

&lt;p&gt;我们可以看到同一份数据的传输次数从四次变成了两次，并且没有通过 CPU 来进行数据搬运，所有的数据都是通过 DMA 来进行传输的。没有在内存层面去复制（Copy）数据，这个方法称之为零拷贝（Zero-Copy）。&lt;/p&gt;

&lt;p&gt;无论传输数据量的大小，传输同样的数据使用了零拷贝能够缩短 65%的时间，大幅度提升了机器传输数据的吞吐量，这也是Kafka能够支持百万TPS的一个重要原因&lt;/p&gt;

&lt;h2&gt;18、压缩：&lt;/h2&gt;

&lt;h3&gt;特性：&lt;/h3&gt;

&lt;p&gt;节省网络传输带宽以及 Kafka Broker 端的磁盘占用。&lt;/p&gt;

&lt;h4&gt;生产者配置 ：&lt;/h4&gt;

&lt;p&gt;compression.type&lt;/p&gt;

&lt;p&gt;Properties props = new Properties();&lt;/p&gt;

&lt;p&gt;props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;acks&quot;, &quot;all&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);&lt;/p&gt;

&lt;p&gt;// 开启GZIP压缩&lt;/p&gt;

&lt;p&gt;props.put(&quot;compression.type&quot;, &quot;gzip&quot;);&lt;/p&gt;

&lt;p&gt;Producerproducer = new KafkaProducer&amp;lt;&amp;gt;(props)&lt;/p&gt;

&lt;h4&gt;broker开启压缩：&lt;/h4&gt;

&lt;p&gt;Broker 端也有一个参数叫 compression.type 默认值为none，这意味着发送的消息是未压缩的。否则，您指定支持的类​​型：gzip、snappy、lz4或zstd。 Producer 端压缩、Broker 端保持、Consumer 端解压缩。&lt;/p&gt;

&lt;h4&gt;broker何时压缩：&lt;/h4&gt;

&lt;p&gt;情况一：Broker 端指定了和 Producer 端不同的压缩算法。（风险：可能会发生预料之外的压缩 / 解压缩操作，表现为 Broker 端 CPU 使用率飙升）&lt;/p&gt;

&lt;p&gt;想象一个对话：&lt;/p&gt;

&lt;p&gt;Producer 说：“我要使用 GZIP 进行压缩。&lt;/p&gt;

&lt;p&gt;Broker 说：“不要，我这边接收的消息必须使用配置的 lz4 进行压缩&lt;/p&gt;

&lt;p&gt;情况二： Broker 端发生了消息格式转换 （风险：涉及额外压缩/解压缩，且 Kafka 丧失 Zero Copy 特性）&lt;/p&gt;

&lt;p&gt;Kafka 共有两大类消息格式，社区分别称之为 V1 版本和 V2 版本&lt;/p&gt;

&lt;p&gt;为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩&lt;/p&gt;

&lt;h4&gt;消息何时解压缩：&lt;/h4&gt;

&lt;p&gt;Consumer：收到到压缩过的消息会解压缩还原成之前的消息。&lt;/p&gt;

&lt;p&gt;broker：收到producer的消息 压缩算法和自己的不一致/兼容新老版本的消息格式&lt;/p&gt;

&lt;h4&gt;压缩算法对比：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44mofpyPt8XdgDacc.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以 Kafka 为例,吞吐量方面：LZ4 &amp;gt; Snappy &amp;gt; zstd 和 GZIP；压缩比方面，zstd &amp;gt; LZ4 &amp;gt; GZIP &amp;gt; Snappy；&lt;/p&gt;

&lt;p&gt;具体到物理资源，使用 Snappy 算法占用的网络带宽最多，zstd 最少，这是合理的，毕竟 zstd 就是要提供超高的压缩比；&lt;/p&gt;

&lt;p&gt;在 CPU 使用率方面，各个算法表现得差不多，只是在压缩时 Snappy 算法使用的 CPU 较多一些，而在解压缩时 GZIP 算法则可能使用更多的 CPU；&lt;/p&gt;

&lt;h2&gt;19、Exactly-Once（ACK应答机制）：&lt;/h2&gt;

&lt;h4&gt;1、At Least Once&lt;/h4&gt;

&lt;p&gt;最少发送一次，Ack级别为-1，保证数据不丢失&lt;/p&gt;

&lt;h4&gt;2、At Most Once&lt;/h4&gt;

&lt;p&gt;最多发送一次，Ack级别为1，保证数据不重复&lt;/p&gt;

&lt;h4&gt;3、幂等性&lt;/h4&gt;

&lt;p&gt;保证producer发送的数据在broker只持久化一条&lt;/p&gt;

&lt;h4&gt;4、Exactly Once（0.11版本）&lt;/h4&gt;

&lt;p&gt;At Least Once + 幂等性 = Exactly Once&lt;/p&gt;

&lt;p&gt;要启用幂等性，只需要将Producer的参数中 enable.idompotence设置为 true即可。 Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。&lt;/p&gt;

&lt;h2&gt;20、producer如何获取metadata：&lt;/h2&gt;

&lt;p&gt;1：在创建KafkaProducer实例时 第一步：生产者应用会在后台创建并启动一个名为Sender的线程，&lt;/p&gt;

&lt;p&gt;2：该Sender线程开始运行时，首先会创建与Broker的连接。 第二步：此时不知道要连接哪个Broker，kafka会通过METADATA请求获取集群的元数据，连接所有的Broker。&lt;/p&gt;

&lt;p&gt;3：Producer 通过 metadata.max.age.ms定期更新元数据，在连接多个broker的情况下，producer的InFlightsRequests中维护着每个broker的等待回复消息的队列，等待数量越少说明broker处理速度越快，负载越小，就会发到哪个broker上&lt;/p&gt;

&lt;h2&gt;21、kafka真的会丢消息吗？&lt;/h2&gt;

&lt;h3&gt;kafka最优配置：&lt;/h3&gt;

&lt;h4&gt;Producer：&lt;/h4&gt;

&lt;p&gt;如果是Java客户端 建议使用 producer.send(msg, callback) ，callback（回调）它能准确地告诉你消息是否真的提交成功了。&lt;/p&gt;

&lt;p&gt;设置 acks = all。acks 是 Producer 的参数，如果设置成 all，需要所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。&lt;/p&gt;

&lt;p&gt;设置 retries 为一个较大的值。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &amp;gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。&lt;/p&gt;

&lt;h4&gt;Consumer：&lt;/h4&gt;

&lt;p&gt;消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。&lt;/p&gt;

&lt;h4&gt;broker ：&lt;/h4&gt;

&lt;p&gt;设置 unclean.leader.election.enable = false。它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。&lt;/p&gt;

&lt;p&gt;设置 replication.factor &amp;gt;= 3,目前防止消息丢失的主要机制就是冗余。&lt;/p&gt;

&lt;p&gt;设置 min.insync.replicas &amp;gt; 1,控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。 确保 replication.factor &amp;gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。&lt;/p&gt;

&lt;h2&gt;22、kafka Replica：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-45j45rFFVXnQKGPe6q.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本质就是一个只能追加写消息的提交日志。根据 Kafka 副本机制的定义，同一个分区下的所有副本保存有相同的消息序列，这些副本分散保存在不同的 Broker 上，从而能够对抗部分 Broker 宕机带来的数据不可用&lt;/p&gt;

&lt;h4&gt;3个特性：&lt;/h4&gt;

&lt;p&gt;第一，在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。&lt;/p&gt;

&lt;p&gt;第二，Kafka 的副本机制比其他分布式系统要更严格一些。在 Kafka 中，追随者副本是不对外提供服务的。这就是说，任何一个追随者副本都不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理，或者说，所有的读写请求都必须发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。&lt;/p&gt;

&lt;p&gt;第三，当领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。&lt;/p&gt;

&lt;h4&gt;意义： 方便实现“Read-your-writes”&lt;/h4&gt;

&lt;p&gt;（1）含义：当使用生产者API向Kafka成功写入消息后，马上使用消息者API去读取刚才生产的消息。 （2）如果允许追随者副本对外提供服务，由于副本同步是异步的，就可能因为数据同步时间差，从而使客户端看不到最新写入的消息。 B ：方便实现单调读（Monotonic Reads） （1）单调读：对于一个消费者用户而言，在多处消息消息时，他不会看到某条消息一会存在，一会不存在。 （2）如果允许追随者副本提供读服务，由于消息是异步的，则多个追随者副本的状态可能不一致。若客户端每次命中的副本不同，就可能出现一条消息一会看到，一会看不到&lt;/p&gt;

&lt;h2&gt;23、ISR（In-Sync Replica Set）LEO&amp;amp;HW 机制：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-466NUv9odkxoJwRBE.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HW(High Watermark)是所有副本中最小的LEO。&lt;/p&gt;

&lt;p&gt;比如： 一个分区有3个副本，一个leader，2个follower。producer向leader写了10条消息，follower1从leader处拷贝了5条消息，follower2从leader处拷贝了3条消息，那么leader副本的LEO就是10，HW=3；follower1副本的LEO就是5&lt;/p&gt;

&lt;p&gt;HW作用：保证消费数据的一致性和副本数据的一致性 通过HW机制。leader处的HW要等所有follower LEO都越过了才会前移&lt;/p&gt;

&lt;p&gt;ISR： 所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas）&lt;/p&gt;

&lt;h4&gt;1、Follower故障：&lt;/h4&gt;

&lt;p&gt;当follower挂掉之后，会被踢出ISR；&lt;/p&gt;

&lt;p&gt;当follower恢复后，会读取本地磁盘记录的HW，然后截掉HW之后的部分，从HW开始从leader继续同步数据，当该follower的LEO大于等于该partition的HW的时候，就是它追上leader的时候，会被重新加入到ISR中&lt;/p&gt;

&lt;h4&gt;2、Leader故障：&lt;/h4&gt;

&lt;p&gt;当leader故障之后，会从follower中选出新的leader，为保证多个副本之间的数据一致性，其余的follower会将各自HW之后的部分截掉（新leader如果没有那部分数据 follower就会截掉造成数据丢失），重新从leader开始同步数据，但是只能保证副本之间的数据一致性，并不能保证数据不重复或丢失。&lt;/p&gt;

&lt;h2&gt;24、Consumer分区分配策略：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-46tJNocSIO10PCpGU6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;自定义分区策略：&lt;/h4&gt;

&lt;p&gt;你需要显式地配置生产者端的参数partitioner.class。这个参数该怎么设定呢？方法很简单，在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口。这个接口也很简单，只定义了两个方法：partition()和close()，通常你只需要实现最重要的 partition 方法&lt;/p&gt;

&lt;p&gt;int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster){&lt;/p&gt;

&lt;p&gt;List&lt;partitioninfo&gt; partitions = cluster.partitionsForTopic(topic);&lt;/partitioninfo&gt;&lt;/p&gt;

&lt;p&gt;//随机&lt;/p&gt;

&lt;p&gt;//return ThreadLocalRandom.current().nextInt(partitions.size());&lt;/p&gt;

&lt;p&gt;//按消息键保序策略&lt;/p&gt;

&lt;p&gt;//return Math.abs(key.hashCode()) % partitions.size();&lt;/p&gt;

&lt;p&gt;//指定条件&lt;/p&gt;

&lt;p&gt;return partitions.stream().filter(Predicate(指定条件))).map(PartitionInfo::partition).findAny().get();&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h2&gt;25、kafka中一个不为人知的topic：&lt;/h2&gt;

&lt;h4&gt;consumer_offsets：&lt;/h4&gt;

&lt;p&gt;老版本的Kafka会把位移信息保存在Zk中 ，但zk不适用于高频的写操作，这令zk集群性能严重下降，在新版本中将位移数据作为一条条普通的Kafka消息，提交至内部主题（_consumer_offsets）中保存，实现高持久性和高频写操作。&lt;/p&gt;

&lt;p&gt;位移主题每条消息内容格式：Group ID，主题名，分区号&lt;/p&gt;

&lt;p&gt;当Kafka集群中的第一个Consumer程序启动时，Kafka会自动创建位移主题。也可以手动创建 分区数依赖于Broker端的offsets.topic.num.partitions的取值，默认为50 副本数依赖于Broker端的offsets.topic.replication.factor的取值，默认为3&lt;/p&gt;

&lt;h4&gt;思考：&lt;/h4&gt;

&lt;p&gt;只要 Consumer 一直启动着，它就会无限期地向位移主题写入消息，就算没有新消息进来 也会通过定时任务重复写相同位移 最终撑爆磁盘？&lt;/p&gt;

&lt;p&gt;Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据，这个后台线程叫 Log Cleaner，对相同的key只保留最新的一条消息。&lt;/p&gt;

&lt;h2&gt;26、Consumer Group Rebalance：&lt;/h2&gt;

&lt;h4&gt;术语简介：&lt;/h4&gt;

&lt;p&gt;Rebalance ：就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程。&lt;/p&gt;

&lt;p&gt;Coordinator：它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。&lt;/p&gt;

&lt;p&gt;Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。&lt;/p&gt;

&lt;p&gt;如何确定Coordinator位置 ：partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount) 比如（abs(627841412 % 50)=12 Coordinator就在 partitionId=12的Leader 副本所在的 Broker）。&lt;/p&gt;

&lt;h4&gt;Rebalance的危害：&lt;/h4&gt;

&lt;p&gt;Rebalance 影响 Consumer 端 TPS 这期间不会工作&lt;/p&gt;

&lt;p&gt;Rebalance 很慢 Consumer越多 Rebalance时间越长&lt;/p&gt;

&lt;p&gt;Rebalance 效率不高 需要所有成员参与&lt;/p&gt;

&lt;h4&gt;触发 Rebalance场景：&lt;/h4&gt;

&lt;p&gt;组成员数量发生变化&lt;/p&gt;

&lt;p&gt;订阅主题数量发生变化&lt;/p&gt;

&lt;p&gt;订阅主题的分区数发生变化&lt;/p&gt;

&lt;h4&gt;如何避免 Rebalance：&lt;/h4&gt;

&lt;p&gt;设置 session.timeout.ms = 15s （session连接时间 默认10）&lt;/p&gt;

&lt;p&gt;设置 heartbeat.interval.ms = 2s（心跳时间）&lt;/p&gt;

&lt;p&gt;max.poll.interval.ms （取决你一批消息处理时长 默认5分钟）&lt;/p&gt;

&lt;p&gt;要保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求，即 session.timeout.ms &amp;gt;= 3 * heartbeat.interval.ms。&lt;/p&gt;

&lt;h2&gt;27、Kafka 拦截器：&lt;/h2&gt;

&lt;p&gt;Kafka 拦截器分为生产者拦截器和消费者拦截器，可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景。&lt;/p&gt;

&lt;p&gt;例：生产者Interceptor&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-47HQ1010RnGZGRYiXPx.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;部分图文资料地址&lt;/p&gt;

&lt;p&gt;-- 极客时间 Kafka 核心技术与实战&lt;/p&gt;

&lt;p&gt;--google&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>770313a345ab45d13e84b1e582fde733</guid>
<title>网易二面：CPU 狂飙 900%，该怎么处理？</title>
<link>https://toutiao.io/k/uazuhjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是不才陈某~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;星球&lt;/a&gt;&lt;span&gt;一位小伙伴面试了 网易，遇到了一个 性能类的面试题：CPU飙升900%，该怎么处理？&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;星球&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可惜的是，以上的问题，这个小伙没有回答理想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终，导致他网易之路，终止在二面，非常可惜&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;首先，说明一下问题：CPU飙升200% 以上是生产容易发生的场景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景:1：MySQL进程飙升900%&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在使用MySQL过程，想必都有遇到过CPU突然过高，或者达到200%以上的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库执行查询或数据修改操作时，系统需要消耗大量的CPU资源维护从存储系统、内存数据中的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量大并且大量SQL性能低的情况下，比如字段是没有建立索引，则会导致快速CPU飙升，如果还开启了慢日志记录，会导致性能更加恶化。生产上有MYSQL 飙升900% 的恶劣情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景2：Java进程飙升900%&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说Java 进程不做大量 CPU 运算，正常情况下，CPU 应该在 100~200% 之间，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，一旦高并发场景，要么走到了死循环，要么就是在做大量的 GC,  容易出现这种 CPU 飙升的情况，CPU飙升900%，是完全有可能的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他场景：其他的类似进程飙升900%的场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Redis、Nginx等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陈某提示：大家介绍场景的时候，就说自己主要涉及了两个场景， Java进程飙升900%、MySQL进程飙升900%两种场景，其实，这两个场景就足够讲半天了， 其他的，使用规避技巧规避一下就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景一：MySQL进程CPU飙升到900%，怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定位过程：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用top 命令观察，确定是mysqld导致还是其他原因。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;处理过程：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;kill 掉这些线程(同时观察 cpu 使用率是否下降)， 一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;进行相应的调整(比如说加索引、改 sql、改内存参数)&lt;/p&gt;&lt;p&gt;index 是否缺失，如果是，则  建立索引。也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等；关注公z号：码猿技术专栏，回复关键词：1111 获取阿里内部Java性能调优手册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优化的过程，往往不是一步完成的，而是一步一步，执行一项优化措辞，再观察，再优化。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景1的真实案例：MySQL数据库优化的真实案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;陈某提示：以下案例，来自互联网。大家参考一下，准备一个自己的案例。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本问题亲身经历过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前开发同事编写的SQL语句，就导致过线上CPU过高，MySQL的CPU使用率达到900%+，通过优化最后降低到70%~80%。下面说说个人在这个过程中的排查思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们要对问题定位而不是盲目的开启什么 慢日志，在并发量大并且大量SQL性能低的情况下，开启慢日志无意是将MySQL推向崩溃的边缘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时遇到这个情况，分析了当前的数据量、索引情况、缓存使用情况。目测数据量不大，也就几百万条而已。接下来就去定位索引、缓存问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;经过询问，发现很多查询都是走MySQL，没有用到缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;既然没有用到缓存，则是大量请求全部查询MySQL导致。通过下面的命令查看:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;processlist&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现类似很多相同的SQL语句，一直处于query状态中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;form&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; user_code = &lt;span&gt;&#x27;xxxxx&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步分析可能是 user_code 字段没有索引导致。接着查询user表的索引情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;form&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现这个字段是没有建立索引。增加索引之后，该条SQL查询能够正常执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、没隔一会，又发生大量的请求超时问题。接着进行分析，发现是开启了 慢日志查询。大量的SQL查询语句超过慢日志设置的阀值，于是将慢日志关闭之后，速度瞬间提升。CPU的使用率基本保持在300%左右。但还不是理想状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、紧接着将部分实时查询数据的SQL语句，都通过缓存(redis)读写实现。观察一段时间后，基本维持在了70%~80%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：其实本次事故的解决很简单，就是添加索引与缓存结合使用。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不推荐在这种CPU使用过高的情况下进行慢日志的开启。因为大量的请求，如果真是慢日志问题会发生日志磁盘写入，性能贼低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接通过MySQL show processlist命令查看，基本能清晰的定位出部分查询问题严重的SQL语句，在针对该SQL语句进行分析。一般可能就是索引、锁、查询大量字段、大表等问题导致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再则一定要使用缓存系统，降低对MySQL的查询频次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于内存调优，也是一种解决方案。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景2展开：Java进程CPU飙升到900%，怎么处理？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定位过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU飙升问题定位的一般步骤是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先通过top指令查看当前占用CPU较高的进程PID；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看当前进程消耗资源的线程PID：top -Hp PID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过print命令将线程PID转为16进制，根据该16进制值去打印的堆栈日志内查询，查看该线程所驻留的方法位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过jstack命令，查看栈信息，定位到线程对应的具体代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析代码解决问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;处理过程：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果是空循环，或者空自旋。&lt;/p&gt;&lt;p&gt;处理方式：可以使用Thread.sleep或者加锁，让线程适当的阻塞。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在循环的代码逻辑中，创建大量的新对象导致频繁GC。比如，从mysql查出了大量的数据，比如100W以上等等。&lt;/p&gt;&lt;p&gt;处理方式：可以减少对象的创建数量，或者，可以考虑使用 对象池。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他的一些造成CPU飙升的场景，比如  selector空轮训导致CPU飙升 。&lt;/p&gt;&lt;p&gt;处理方式：参考Netty源码，无效的事件查询到了一定的次数，进行 selector 重建。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java的CPU 飙升700%优化的真实案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;陈某提示：以下案例，来自互联网。大家参考一下，准备一个自己的案例。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近负责的一个项目上线，运行一段时间后发现对应的进程竟然占用了700%的CPU，导致公司的物理服务器都不堪重负，频繁宕机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么,针对这类java进程CPU飙升的问题，我们一般要怎么去定位解决呢？、&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;采用top命令定位进程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录服务器，执行top命令，查看CPU占用情况，找到进程的pid&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;top&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2898148148148148&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsU2tVM8dOsJibl2SCB7OHhpMXGPKsUsR5ZZNaSxKtVBGhzSaJibD8lYicQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很容易发现，PID为29706的java进程的CPU飙升到700%多，且一直降不下来，很显然出现了问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用top -Hp命令定位线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 top -Hp命令（为Java进程的id号）查看该Java进程内所有线程的资源占用情况（按shft+p按照cpu占用进行排序，按shift+m按照内存占用进行排序）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处按照cpu排序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;top -Hp 23602&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26481481481481484&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsq1qkRyxmOLicmKvSImHqqJD49yKIGxHY7p1ANhUuILpR1kRgFbGUgvw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很容易发现，多个线程的CPU占用达到了90%多。我们挑选线程号为30309的线程继续分析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用jstack命令定位代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.线程号转换5为16进制&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;printf “%x\n” 命令（tid指线程的id号）将以上10进制的线程号转换为16进制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;printf &quot;%x\n&quot;  30309&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09907407407407408&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHs1fDmlmNLgGNEu6uX4Mq7gpXQvLCo4AsAHiaV1jGHAe2e3WXMK4qpxkQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换后的结果分别为7665，由于导出的线程快照中线程的nid是16进制的，而16进制以0x开头，所以对应的16进制的线程号nid为0x7665&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.采用jstack命令导出线程快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用dk自带命令jstack获取该java进程的线程快照并输入到文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; jstack -l 进程ID &amp;gt; ./jstack_result.txt &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令（为Java进程的id号）来获取线程快照结果并输入到指定文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstack -l 29706 &amp;gt; ./jstack_result.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.根据线程号定位具体代码&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jstack_result.txt 文件中根据线程好nid搜索对应的线程描述&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat jstack_result.txt |grep -A 100  7665&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18703703703703703&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHskfKlGEOf6lL1ZMF0yEiapmNg4QLMOTsAc3DqKlMkcfBibUUgKhLLOGIg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据搜索结果，判断应该是ImageConverter.run()方法中的代码出现问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这里也可以直接采用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstack &amp;lt;pid&amp;gt; |grep -A 200 &amp;lt;nid&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定位具体代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$jstack &lt;span&gt;44529&lt;/span&gt; |grep -A &lt;span&gt;200&lt;/span&gt; ae24&lt;br/&gt;&lt;span&gt;&quot;System Clock&quot;&lt;/span&gt; #&lt;span&gt;28&lt;/span&gt; daemon prio=&lt;span&gt;5&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007efc19e8e800&lt;/span&gt; nid=&lt;span&gt;0xae24&lt;/span&gt; waiting on condition [&lt;span&gt;0x00007efbe0d91000&lt;/span&gt;]&lt;br/&gt;   java.lang.Thread.State: TIMED_WAITING (sleeping)&lt;br/&gt;    at java.lang.Thread.sleep(Native Method)&lt;br/&gt;    at java.lang.Thread.sleep(Thread.java:&lt;span&gt;340&lt;/span&gt;)&lt;br/&gt;    at java.util.concurrentC.TimeUnit.sleep(TimeUnit.java:&lt;span&gt;386&lt;/span&gt;)&lt;br/&gt;    at com.*.order.Controller.OrderController.detail(OrderController.java:&lt;span&gt;37&lt;/span&gt;)  &lt;span&gt;//业务代码阻塞点&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析代码解决问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是ImageConverter.run()方法中的部分核心代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/存储minicap的socket连接返回的数据   (改用消息队列存储读到的流数据) ，设置阻塞队列长度，防止出现内存溢出&lt;br/&gt;&lt;span&gt;//全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; dataQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;(&lt;span&gt;100000&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//消费线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//long start = System.currentTimeMillis();&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (isRunning) {&lt;br/&gt;        &lt;span&gt;//分析这里从LinkedBlockingQueue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (dataQueue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buffer = device.getMinicap().dataQueue.poll();&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; len = buffer.length;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在while循环中，不断读取堵塞队列dataQueue中的数据，如果数据为空，则执行continue进行下一次循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不为空，则通过poll()方法读取数据，做相关逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初看这段代码好像每什么问题，但是如果dataQueue对象长期为空的话，这里就会一直空循环，导致CPU飙升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析LinkedBlockingQueue阻塞队列的API发现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//取出队列中的头部元素，如果队列为空则调用此方法的线程被阻塞等待，直到有元素能被取出，如果等待过程被中断则抛出InterruptedException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;E &lt;span&gt;take&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//取出队列中的头部元素，如果队列为空返回null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;E &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种取值的API，显然take方法更时候这里的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码修改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; (isRunning) {&lt;br/&gt;   &lt;span&gt;/* if (device.getMinicap().dataQueue.isEmpty()) {&lt;br/&gt;        continue;&lt;br/&gt;    }*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        buffer = device.getMinicap().dataQueue.take();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;……&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启项目后，测试发现项目运行稳定，对应项目进程的CPU消耗占比不到10%。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.287962962962963&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsuQUr7MK2zNausticsJ4V54NvKj4UqxgJysRZFUA12ntrh7Otoib8P3bQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：技术自由圈&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后说一句（别白嫖，求关注）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陈某每一篇文章都是精心输出，如果这篇文章对你有所帮助，或者有所启发的话，帮忙&lt;span&gt;点赞&lt;/span&gt;、&lt;span&gt;在看&lt;/span&gt;、&lt;span&gt;转发&lt;/span&gt;、&lt;span&gt;收藏&lt;/span&gt;，你的支持就是我坚持下去的最大动力！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外陈某的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;知识星球&lt;/a&gt;开通了，公众号回复关键词：&lt;span&gt;知识星球&lt;/span&gt; 获取限量&lt;span&gt;30元&lt;/span&gt;优惠券加入只需&lt;span&gt;89&lt;/span&gt;元，一顿饭钱，但是星球回馈的价值却是巨大，目前更新了&lt;span&gt;Spring全家桶实战系列&lt;/span&gt;、&lt;span&gt;亿级数据分库分表实战&lt;/span&gt;、&lt;span&gt;DDD微服务实战专栏&lt;/span&gt;、&lt;span&gt;我要进大厂、Spring，Mybatis等框架源码、架构实战22讲&lt;/span&gt;等....每增加一个专栏价格将上涨20元&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0398148148148147&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rBvqdy8J18dlib7KepGcvuW08g7COtYpQvVoZzRtQFLgaW1GxibV1vsWMQ27S4wsOlt1ySoh3uEAeIw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f9d20e6d53dabd706cd18c91aacf6609</guid>
<title>ChatGPT 真的可以让流浪地球的丫丫 “复活”</title>
<link>https://toutiao.io/k/29qnui2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-10 col-sm-12&quot;&gt;
            &lt;h1&gt; ChatGPT 真的可以让流浪地球的丫丫 “复活”&lt;/h1&gt;
            &lt;hr/&gt;
            &lt;p&gt;作者: 康凯森&lt;/p&gt;
            &lt;p&gt;日期: 2023-03-12&lt;/p&gt;
            &lt;p&gt;分类: &lt;a href=&quot;../tag/chatgpt.html&quot; target=&quot;_blank&quot;&gt;chatgpt&lt;/a&gt;&lt;/p&gt;
            &lt;hr/&gt;
            


&lt;h2 id=&quot;一-流浪地球2中的yy&quot;&gt;一 流浪地球2中的YY&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/yaya.png&quot; alt=&quot;yaya&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流浪地球2中图恒宇利用超级计算机制造了数字生命丫丫，并最终拯救了整个人类，看这部影片时，还感觉数字生命可能离我们还比较遥远，可能需要很多年才能变成现实，但是最近随着对一些 ChatGPT 应用的粗浅思考，感觉数字生命已经离我们人类不是很遥远，至少初级版的丫丫现在就可以制造出原型。&lt;/p&gt;
&lt;h2 id=&quot;二-如何利用-chatgpt-和-ai-工具“复活”丫丫&quot;&gt;二 如何利用 ChatGPT 和 AI 工具“复活”丫丫&lt;/h2&gt;
&lt;h3 id=&quot;21-chatgpt-赋予丫丫思想，性格，说话风格，记忆&quot;&gt;2.1 ChatGPT 赋予丫丫思想，性格，说话风格，记忆&lt;/h3&gt;
&lt;p&gt;现在公开版的 ChatGPT 是基于大规模数据集预先训练好的模型，所以还不够个性化，但是 ChatGPT 是可以利用额外输入进行训练的，让其足够个性化。 原理可以参考：&lt;a href=&quot;https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_embeddings.ipynb&quot;&gt;Question_answering_using_embeddings&lt;/a&gt;, 通俗版解释可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s/EYGnSBPmVNzY2_KTSlubZQ&quot;&gt;ChatGPT：未来，你会被淘汰吗？&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;大家只需要理解，你给 ChatGPT 一个 PDF 文件，一个网页链接，ChatGPT 就可以理解输入的内容，对输入的内容进行总结，解释你的疑问，和你进行对话。&lt;/p&gt;
&lt;p&gt;进一步，我们如果把一个人在社交媒体上所有的聊天记录，他创作过的所有文章，图片，视频输入给 ChatGPT，ChatGPT 基本就可以学习到这个人的性格，说话风格，思考问题的方式。&lt;/p&gt;
&lt;p&gt;如果这样还不够准确，我们还可以把这个人看过的书籍，电影，成长经历等也输入给 ChatGPT，也就是说，让 ChatGPT 经历一遍这个人的教育，成长过程，让 ChatGPT 更懂这个人。&lt;/p&gt;
&lt;p&gt;如果这样还不够准确呢？你还可以像教育孩子一样，在和 ChatGPT 不断交流互动的过程中，不断训练他，告诉它什么是对的，什么是错的。&lt;/p&gt;
&lt;h3 id=&quot;22-whisper-让丫丫理解语音&quot;&gt;2.2 Whisper 让丫丫理解语音&lt;/h3&gt;
&lt;p&gt;Whisper 将语音转换给文本， 输入给 ChatGPT，语音识别技术已经很成熟了，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;23-elevenlabs-赋予丫丫语言能力&quot;&gt;2.3 ElevenLabs 赋予丫丫语言能力&lt;/h3&gt;
&lt;p&gt;ElevenLabs 可以生成语音，关键是可以定制化语音，也就是说你想要谁的语音，都可以定制，这个技术也比较成熟了，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;24-midjourney-赋予丫丫形象&quot;&gt;2.4 Midjourney 赋予丫丫形象&lt;/h3&gt;
&lt;p&gt;Midjourney 等AI 绘画工具的绘画能力已经超过人类, 效果十分逆天, 大家可以自行体验。 &lt;/p&gt;
&lt;h2 id=&quot;三-丫丫-demo-show&quot;&gt;三 丫丫 Demo Show&lt;/h2&gt;
&lt;p&gt;目前我们只需要几百行代码，就可以构建出一个极简的 Demo 原型，接收人类的语音输入，ChatGPT 进行处理，并最终语音进行输出。我用网上的开源代码简单改了改，试了下。 这个应用的代码本身也是用 ChatGPT 写出来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-1.png&quot; alt=&quot;12-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-2.png&quot; alt=&quot;12-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-3.png&quot; alt=&quot;12-3&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四-丫丫类应用畅想&quot;&gt;四 丫丫类应用畅想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;寄托对逝者的思念：这也是丫丫在流浪地球电影中的本来作用&lt;/li&gt;
&lt;li&gt;私密倾诉：你可以制造一个你期望的人物和形象，然后和其进行私密聊天&lt;/li&gt;
&lt;li&gt;完美代替 Siri, 小冰，小度，小艺等语音助手&lt;/li&gt;
&lt;li&gt;在电影，电视剧，综艺节目等中引入一个有性格，有思想的虚拟人物&lt;/li&gt;
&lt;li&gt;游戏中的 NPC：玩家可以和 NPC 进行真实的互动，真正可以左右游戏的剧情&lt;/li&gt;
&lt;li&gt;成人应用和产业的全面升级&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;五-总结&quot;&gt;五 总结&lt;/h2&gt;
&lt;p&gt;目前这类个性化数字生命产品的大规模应用，我理解最大的障碍可能有两点：一个是成本，就是目前个性化训练的成本还是偏高；另一个就是数据隐私和安全，我们如何确保在网络世界里面我们的数据隐私不被泄露，甚至反过来伤害我们。&lt;/p&gt;

            &lt;hr/&gt;
            &lt;h3&gt;欢迎体验 免费 极速 无需翻墙的 ChatGPT&lt;/h3&gt;
            &lt;p&gt;&lt;a href=&quot;https://chat.bcmeng.com/&quot; target=&quot;_blank&quot;&gt;chat.bcmeng.com&lt;/a&gt;&lt;/p&gt;
            &lt;h3&gt;欢迎来知识星球和我交流&lt;/h3&gt;
            
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>111dff82948fad9553b49d2eac9008ef</guid>
<title>解析 Golang 网络 IO 模型之 EPOLL</title>
<link>https://toutiao.io/k/zoeot30</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 data-first-child=&quot;&quot;&gt;0 前言&lt;/h2&gt;&lt;p data-pid=&quot;JvTC15iY&quot;&gt;前一篇文章和大家聊了 Golang HTTP 标准库的底层实现，本篇尝试向下深挖，和大家一起聊聊 Golang 底层 IO 模型中使用到的 epoll 机制.&lt;/p&gt;&lt;p data-pid=&quot;zL3J22DA&quot;&gt;本文大抵分为两部分：第一部分聊 epoll 的实现原理（第一、二章）；第二部分串联 Golang 底层 IO 模型实现链路（第三章），观察其中对 epoll 技术的应用.&lt;/p&gt;&lt;p data-pid=&quot;EAF3yooZ&quot;&gt;本文走读的 Golang 源码版本为 1.19，全文目录树如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4aa89bc0443544bcbdeaa706086d0f37_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1705&quot; data-rawheight=&quot;6115&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4aa89bc0443544bcbdeaa706086d0f37_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1705&quot; data-rawheight=&quot;6115&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4aa89bc0443544bcbdeaa706086d0f37_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4aa89bc0443544bcbdeaa706086d0f37_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;1 IO 多路复用&lt;/h2&gt;&lt;h2&gt;1.1 何为 IO 多路复用&lt;/h2&gt;&lt;p data-pid=&quot;mi0bWeBy&quot;&gt;首先拆解多路复用一词：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;u6sZfCBB&quot;&gt;多路：存在多个待服务的对象&lt;/li&gt;&lt;li data-pid=&quot;-EbV39mR&quot;&gt;复用：只由一个执行单元提供服务&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;gbZCJPkr&quot;&gt;串联上述要点，多路复用指的是，由一个执行单元，同时对多个对象提供服务，形成一对多的服务关系.&lt;/p&gt;&lt;p data-pid=&quot;JiNgqrxy&quot;&gt;打个比方：多名顾客在餐厅内用餐，考虑到经营成本，很难做到为每名顾客单独提供一名招待员作一对一服务，因此餐厅经理安排每名服务生固定负责几个餐桌，服务生在几个桌次间来回辗转提供服务，这个过程本质上就是一种多路复用.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2aa62270af998273ec31ad446485b9b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1623&quot; data-rawheight=&quot;1274&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2aa62270af998273ec31ad446485b9b8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1623&quot; data-rawheight=&quot;1274&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2aa62270af998273ec31ad446485b9b8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2aa62270af998273ec31ad446485b9b8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;9Kp0QJSu&quot;&gt;下面回到计算机领域，在 linux 操作系统中，对 IO 多路复用的概念有着更加明确的定义：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;9x0clKTm&quot;&gt;多路：存在多个需要处理 io event 的 fd（linux 中，一切皆文件，所有事务均可抽象为一个文件句柄 file descriptor，简称 fd）&lt;/li&gt;&lt;li data-pid=&quot;pp1TKGO0&quot;&gt;复用：复用一个 loop thread 同时为多个 fd 提供处理服务（线程 thread 是内核视角下的最小调度单位；多路复用通常为循环模型 loop model，因此称为 loop thread）&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;lCeGEH7G&quot;&gt;解释了概念，下面再对 IO 多路复用附加一些约定俗称的要求：&lt;/p&gt;&lt;p data-pid=&quot;cHd4UIkN&quot;&gt;IO 多路复用中，loop thread 是提供服务的乙方；待处理 io event 的 fd 们是甲方. 本着顾客是上帝的原则，乙方有义务为甲方提供更优质的服务，这里的服务质量就体现在一句话：”随叫随到，别让老板等久了”.&lt;/p&gt;&lt;p data-pid=&quot;euD6VOtX&quot;&gt;在餐厅顾客没有需求的时候，服务生趁着闲工夫摸个鱼打个盹也尚无不可. 当时一旦顾客招呼时，服务生需要第一时间赶到对需求作出响应.&lt;/p&gt;&lt;p data-pid=&quot;O5SHCLGW&quot;&gt;此外，由于服务生和顾客之间的服务关系是一对多，所以还要考虑到有多名顾客同时招呼时，服务生如何作兼容处理，让每名顾客都不至于产生被冷落的感觉. 这是一门学问，也同样是计算机领域 IO 多路复用场景下需要解决的问题.&lt;/p&gt;&lt;h2&gt;1.2 IO 多路复用的简单实现&lt;/h2&gt;&lt;h3&gt;（1）阻塞 IO&lt;/h3&gt;&lt;p data-pid=&quot;vBqJSrW7&quot;&gt;下面通过一段伪代码，来尝试让 IO 多路复用这个概念看起来更加具体一些：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 多个待服务的 fd 
    fds = [fd1,fd2,fd3,...]
    // 遍历 fd 列表，末尾和首部相连，形成循环
    i = 0
    for {
       // 获取本轮待处理的 fd
       fd = fds[i]        
       // 从 fd 中读数据
       data = read(fd)  
       // 处理数据 
       handle(data)             
       // 推进遍历
       i++
       if i == len(fds){
         i = 0
       }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;OwSzT2XG&quot;&gt;上述搭了个架子，核心分为几步：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;MaQZ41Rl&quot;&gt;定义了待处理的 fds 列表（多路）&lt;/li&gt;&lt;li data-pid=&quot;9OgNYQ1u&quot;&gt;循环遍历 fds 列表，每轮负责读一个 fd（复用）&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;5MYLVCXa&quot;&gt;这是个乞丐版的 IO 多路复用模型看起来似乎有那么点意思了. 然而其本质上是一种阻塞 IO 模型（Blocking IO，简称 BIO）. 事实上，上述实现存在一个致命的问题，那就是句柄 fd 默认的 io 操作是阻塞型的，因此倘若在读 fd1 的时候，io event 没到达，那么 loop thread 就会陷入阻塞，后续 fd2、fd3 哪怕有 io event 到达，也无法得到执行.&lt;/p&gt;&lt;p data-pid=&quot;w-wsSSVt&quot;&gt;上述问题翻译成更形象的场景，大概就是：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;3TfU80kI&quot;&gt;A桌顾客对服务生说，你先搁这候着，我看会儿菜单，一会点菜&lt;/li&gt;&lt;li data-pid=&quot;iaKTofhq&quot;&gt;服务生于是站定A桌，打定主意在A桌点完菜之后再离开&lt;/li&gt;&lt;li data-pid=&quot;vFU4yC44&quot;&gt;在此期间，服务生辖区内的B桌、C桌招呼有事，服务生也充耳不闻，只等A桌事情完结才肯挪动步子&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;99cYQG3I&quot;&gt;这样的服务显然不够到位，倘若人人如此，餐厅必然面临倒闭.&lt;/p&gt;&lt;h3&gt;（2）非阻塞 IO&lt;/h3&gt;&lt;p data-pid=&quot;Ulahfnoi&quot;&gt;基于 BIO 存在的问题，我们进行一轮改进，核心是将 read 操作由同步阻塞操作改为带有尝试性的非阻塞操作. 在读一个 fd 的时候，倘若 io event 已就绪就正常读取，否则就即时返回并抛出一个特定类型的错误，让 loop thread 能够正常执行下去，为其他 fd 提供服务.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 多个待服务的 fd 
    fds = [fd1,fd2,fd3,...]
    // 遍历 fd 列表，末尾和首部相连，形成循环
    i = 0
    for {
       // 获取本轮待处理的 fd
       fd = fds[i]        
       // 尝试从 fd 中读数据，失败时不阻塞，而是抛出错误
       data,err = tryRead(fd)  
       // 读取数据成功，处理数据
       if err == nil{
          handle(data) 
       } 
       // 小睡一秒后再推进流程
       sleep(1 second)
       // 推进遍历
       i++
       if i == len(fds){
         i = 0
       }
    }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;4waH22ur&quot;&gt;上述伪代码核心步骤如下：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;545K-YrE&quot;&gt;定义了待处理的 fds 列表&lt;/li&gt;&lt;li data-pid=&quot;OBlYc_zv&quot;&gt;遍历 fds 列表，每轮尝试从一个 fd 中读数据&lt;/li&gt;&lt;li data-pid=&quot;nYjXFGCE&quot;&gt;倘若 io event 已就绪，则正常处理结果&lt;/li&gt;&lt;li data-pid=&quot;4mNV9k0l&quot;&gt;倘若 io event 未就绪，只抛出错误，同样不阻塞流程&lt;/li&gt;&lt;li data-pid=&quot;OpwSJnQb&quot;&gt;小睡一会儿，然后继续推进流程&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;dDMlDwIm&quot;&gt;这里确实解决阻塞 IO 中的问题，其本质上是一种非阻塞 IO 模型（Nonblocking IO，简称 NIO）. 但这里仍然存在问题，就是每轮处理之间的休眠时间. 倘若在休眠期间，fd 中有 io event 到达，就无法被正常处理，这同样是一种不好的体验.&lt;/p&gt;&lt;p data-pid=&quot;xiLGBJQ9&quot;&gt;这一问题翻译成餐厅的场景，指的就是服务生每次主动问询或者为一名客人提供服务后，就要大喘气休息几分钟，期间对客人不管不顾，这样的服务态度客人同样不会买账.&lt;/p&gt;&lt;p data-pid=&quot;mQI6Ukp0&quot;&gt;那大家可能会问了，倘若把此处的休眠操作去除了如何？&lt;/p&gt;&lt;p data-pid=&quot;XFfcGmgO&quot;&gt;答案是同样有问题. 倘若不限制轮询的执行频率，那么不轮 fd 中是否有 io event，程序都会一直高强度运行，这会导致 CPU 空转，造成很大程度的资源浪费.&lt;/p&gt;&lt;p data-pid=&quot;IXkYZiBh&quot;&gt;用餐厅的场景来聊，指的是餐厅招了个视听都不好的服务生，他感应不到客人的召唤，需要时时刻刻奔走在各个餐桌之间主动去询问客人们是否需要服务. 这种情况下，哪怕客人们性子好不嫌烦，服务生自己也被这种高强度的反复横跳动作给累坏了.&lt;/p&gt;&lt;p data-pid=&quot;sjpBC7dJ&quot;&gt;那大家可能又问了. 餐厅就不能招个正常的服务生吗，让他在听到客人的招呼时就去提供服务，否则就在一边老实歇着.&lt;/p&gt;&lt;p data-pid=&quot;SbMNd89U&quot;&gt;没错，这就是正解，设计程序的码农们也是这么想的. 然而实际情况很悲催，在用户态视角下的程序正是哪一个耳目昏聩的服务生，对于 io event 的到达并没有能力做到准确地把握.&lt;/p&gt;&lt;p data-pid=&quot;a-uJmyLZ&quot;&gt;于是，这就需要引入操作系统内核的帮助，通过几个内核对外暴露的接口，来进行 IO 多路复用的优雅实现，做到真正意义上的“随叫随到”.&lt;/p&gt;&lt;h2&gt;1.3 IO 多路复用的优雅实现&lt;/h2&gt;&lt;p data-pid=&quot;rjKh9q3D&quot;&gt;linux 内核提供了三种经典的多路复用技术：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9cdc3e0d1e5f30ae71bc154ecda17504_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1168&quot; data-rawheight=&quot;254&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9cdc3e0d1e5f30ae71bc154ecda17504_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1168&quot; data-rawheight=&quot;254&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9cdc3e0d1e5f30ae71bc154ecda17504_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9cdc3e0d1e5f30ae71bc154ecda17504_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;kLGT0bIU&quot;&gt;从上图中可以看到，各个技术之间通过单向箭头连接，因此是一个持续演化改进的过程，select 最通用，但是相对粗糙；而 epoll 则最精致，在性能上也有着最优越的表现.&lt;/p&gt;&lt;p data-pid=&quot;2T5oItr4&quot;&gt;poll 在 select 的基础之上做了改进，但治标不治本，优化得不够彻底. 我们核心还是来对比看看 select 和 epoll 之间的共性和差异：&lt;/p&gt;&lt;h3&gt;（1）select&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;-7_fKP4y&quot;&gt;一次可以处理多个 fd，体现多路. 但 fd 数量有限，最多 1024 个&lt;/li&gt;&lt;li data-pid=&quot;OHGmG1E5&quot;&gt;loop thread 通过 select 将一组 fd 提交到内核做监听&lt;/li&gt;&lt;li data-pid=&quot;2lruK3eo&quot;&gt;当 fd 中无 io event 就绪时，loop thread 会陷入阻塞&lt;/li&gt;&lt;li data-pid=&quot;FEDZnECF&quot;&gt;每当这组 fd 中有 io event 到达时，内核会唤醒 loop thread&lt;/li&gt;&lt;li data-pid=&quot;tI5k6MbO&quot;&gt;loop thread 无法精准感知到哪些 fd 就绪，需要遍历一轮 fd 列表，时间复杂度 O(N)&lt;/li&gt;&lt;li data-pid=&quot;_BJFWNlh&quot;&gt;托付给内核的 fd 列表只具有一轮交互的时效. 新的轮次中，loop thread 需要重新将监听的 fd 列表再传递给内核一次&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;（2）epoll&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;QYtccQ28&quot;&gt;每次处理的 fd 数量无上限&lt;/li&gt;&lt;li data-pid=&quot;Z8J_zOV0&quot;&gt;loop thread 通过 epoll_create 操作创建一个 epoll 池子&lt;/li&gt;&lt;li data-pid=&quot;Vn3-wx7Q&quot;&gt;loop thread 通过 epoll_ctl 每次将一个待监听的 fd 添加到 epoll 池中&lt;/li&gt;&lt;li data-pid=&quot;JTERQSUL&quot;&gt;每当 fd 列表中有 fd 就绪事件到达时，会唤醒 loop threa. 同时内核会将处于就绪态的 fd 直接告知 loop thread，无需额外遍历&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;3i-JoSCY&quot;&gt;综上所述，select 和 epoll 等多路复用操作利用了内核的能力，能在待监听 fd 中有 io event 到达时，将 loop thread 唤醒，避免无意义的主动轮询操作.&lt;/p&gt;&lt;p data-pid=&quot;s2GNldsr&quot;&gt;其中，epoll 相比于 select 的核心性能优势在于：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ayVZAbhL&quot;&gt;loop thread 被唤醒时，能明确知道哪些 fd 需要处理，减少了一次额外遍历的操作，时间复杂度由 O(N) 优化到 O(1)&lt;/li&gt;&lt;li data-pid=&quot;d2mhN2ys&quot;&gt;epoll 通过将创建池子和添加 fd两个操作解耦，实现了池中 fd 数据的复用，减少了用户态与内核态间的数据拷贝成本&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2 EventPoll 原理&lt;/h2&gt;&lt;h2&gt;2.1 核心指令&lt;/h2&gt;&lt;p data-pid=&quot;VoTtpnW0&quot;&gt;epoll 又称 EventPoll，使用很简单，包含三个指令“&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;m5ftYbDl&quot;&gt;epoll_create&lt;/li&gt;&lt;li data-pid=&quot;pnJMgD5T&quot;&gt;epoll_ctl&lt;/li&gt;&lt;li data-pid=&quot;HlZGMdRs&quot;&gt;epoll_wait&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;XNdtFv0i&quot;&gt;下面我们逐一展开聊聊：&lt;/p&gt;&lt;h3&gt;（1）epoll_create&lt;/h3&gt;&lt;p data-pid=&quot;OUYDc8G2&quot;&gt;在内核开辟空间，创建一个 epoll 池子用于批量存储管理 fd，后续可以通过 epoll_ctl 往池子中增删改 fd.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func epollcreate1(flags int32) int32&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（2）epoll_ctl&lt;/h3&gt;&lt;p data-pid=&quot;o1CPpXxO&quot;&gt;在某个 epoll 池子中进行一个 fd 的增删改操作.&lt;/p&gt;&lt;p data-pid=&quot;OAfAecrM&quot;&gt;正是由于 epoll 中将 epoll_ctl 与 epoll_create 操作进行了解耦，才实现了对 epoll_create 时传递的 fd 数据的复用，减少了用户态和内核台之间对 fd 数据的重复传递&lt;/p&gt;&lt;p data-pid=&quot;YRvBupTj&quot;&gt;此外，在 epoll_ctl 实现时，也需要通过 epollevent 设置好回调事件，当 fd 有指定事件到达时，会被添加到就绪队列中，最终将 loop thread 唤醒.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func epollctl(epfd, op, fd int32, ev *epollevent) int32


type epollevent struct {
    events uint32
    data   [8]byte // unaligned uintptr
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（3）epoll_wait&lt;/h3&gt;&lt;p data-pid=&quot;jdgrgC2K&quot;&gt;从对应 epoll 池子中获取就绪的 epollevent，从中可以关联到对应的 fd 和 loop thread 信息.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func epollwait(epfd int32, ev *epollevent, nev, timeout int32) int32&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;2.2 核心数据结构&lt;/h2&gt;&lt;h3&gt;（1）epoll 池红黑树&lt;/h3&gt;&lt;p data-pid=&quot;I43Qiwqp&quot;&gt;一个 epoll 池子中管理的 fd 数量理论上上不封顶. 同时后续可能存在对 fd 的增删改操作，因此需要使用合适的数据结构加以管理，从而降低后续操作的时间复杂度.&lt;/p&gt;&lt;p data-pid=&quot;q-TUu24N&quot;&gt;linux 内核中，实现 epoll 池的数据结构采用的是红黑树（Red-Black Tree，一种自平衡二叉查找树，这里不作展开，感兴趣自行了解）实现，保证了所有增、删、改操作的平均时间复杂度维持在 O(logN) 的对数级水平.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ec0e8a3a83196a07c9b550a745c1984b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1087&quot; data-rawheight=&quot;895&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ec0e8a3a83196a07c9b550a745c1984b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1087&quot; data-rawheight=&quot;895&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ec0e8a3a83196a07c9b550a745c1984b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ec0e8a3a83196a07c9b550a745c1984b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;（2）就绪事件队列&lt;/h3&gt;&lt;p data-pid=&quot;EkGdAlTh&quot;&gt;针对于 fd 的就绪 io event，由于通常数量有限，且每个事件都需要逐一处理，没有优先级之分，因此采用简单的双向链表实现即可.&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4398e12ae764308c5300c33b240f427f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2063&quot; data-rawheight=&quot;978&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4398e12ae764308c5300c33b240f427f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2063&quot; data-rawheight=&quot;978&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4398e12ae764308c5300c33b240f427f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4398e12ae764308c5300c33b240f427f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;2.3 事件回调机制&lt;/h2&gt;&lt;p data-pid=&quot;mtP32qve&quot;&gt;epoll 高效的核心建立在精准的事件回调机制之上.&lt;/p&gt;&lt;p data-pid=&quot;oBz1vWXN&quot;&gt;首先，通过内核感知到 io event 事件的动态，令 loop thread 在合适的时机阻塞，避免浪费 CPU；在合适的时机执行，及时处理 io event.&lt;/p&gt;&lt;p data-pid=&quot;eLCDGuSS&quot;&gt;其次，在 io event 就绪时，会精准地将真正就绪的 fd 传递到 loop thread 手中，减少了一次无意义的遍历查询动作.&lt;/p&gt;&lt;p data-pid=&quot;f9P4EFWV&quot;&gt;事件回调的注册是在调用 epoll_ctl 添加 fd 时，此时会提前设置好对这个 fd 关心的事件类型，当对应的 io event 真的发生时，内核会将该 fd 和对应的 loop thread 封装到 epollevent 中，添加到就绪队列 ready list 当中.&lt;/p&gt;&lt;p data-pid=&quot;f7G6aGMA&quot;&gt;之后当用户调用 epoll_wait 时，能够准确地获取到这部分就绪的 epollevent，进而能够将对应的 loop thread 唤醒.&lt;/p&gt;&lt;h2&gt;3 Golang 网络 IO 源码走读&lt;/h2&gt;&lt;p data-pid=&quot;aNKJ4kpV&quot;&gt;聊完了理论，下面看看 epoll 技术在 Golang 中的应用.&lt;/p&gt;&lt;h2&gt;3.1 启动 TCP 服务器&lt;/h2&gt;&lt;p data-pid=&quot;HVhbQKCk&quot;&gt;首先给出一个启动 tcp 服务的代码框架，伪代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 启动一个 tcp 服务端代码示例
func main(){
   // 创建一个 tcp 端口监听器
   l,_ := net.Listen(&quot;tcp&quot;,&quot;:8080&quot;)
   // 主动轮询模型
   for{
       // 等待 tcp 连接到达
       conn,_ := l.Accept()     
       // 开启一个 goroutine 负责一笔客户端请求的处理
       go serve(conn)
   }
}


// 处理一笔 tcp 连接
func serve(conn net.Conn){
    defer conn.Close()
    var buf []byte
    // 读取连接中的数据
    _,_ = conn.Read(buf)    
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;FG6pql2a&quot;&gt;方法核心步骤都展示于 main 函数中了：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;SVR1q4y2&quot;&gt;创建了一个 tcp 端口监听器 listener&lt;/li&gt;&lt;li data-pid=&quot;Do_4y99o&quot;&gt;通过 for 循环建立主动轮询模型&lt;/li&gt;&lt;li data-pid=&quot;2vQabxHy&quot;&gt;每轮尝试从 listener 中获取到达的 tcp 连接&lt;/li&gt;&lt;li data-pid=&quot;hnWYK-kw&quot;&gt;倘若成功取到连接，则 1:1启动一个 goroutine 异步处理连接的请求&lt;/li&gt;&lt;li data-pid=&quot;lLB_y-gI&quot;&gt;倘若无连接到达，则阻塞主流程&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;bLYzRYtv&quot;&gt;其中，有两个方法是核心入口：一个是创建 Listener 的 net.Listen；另一个是从 Listener 获取连接的 Listener.Accept 方法.&lt;/p&gt;&lt;h2&gt;3.2 创建 TCP 端口监听器&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5ef2ecf6e4da4ac3c0d47ab6505b4ecd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2195&quot; data-rawheight=&quot;2315&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-5ef2ecf6e4da4ac3c0d47ab6505b4ecd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2195&quot; data-rawheight=&quot;2315&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-5ef2ecf6e4da4ac3c0d47ab6505b4ecd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5ef2ecf6e4da4ac3c0d47ab6505b4ecd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;（1）创建 Listener 前处理&lt;/h3&gt;&lt;p data-pid=&quot;nXleMJDJ&quot;&gt;在创建 TCP 端口 Listener 时，首先历经 Listen -&amp;gt; ListenerConfig.Listen -&amp;gt; sysListener.listenTCP -&amp;gt; internetSocket -&amp;gt; socket 方法的辗转，最终来到位于 runtime/sock_posix.go 的 socket 方法中，开始执行套接字 socket 的创建和初始化.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func Listen(network, address string) (Listener, error) {
    var lc ListenConfig
    return lc.Listen(context.Background(), network, address)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) {
    // ...
    var l Listener
    la := addrs.first(isIPv4)
    switch la := la.(type) {
    case *TCPAddr:
        l, err = sl.listenTCP(ctx, la)
    // ...
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (sl *sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (*TCPListener, error) {
    fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, &quot;listen&quot;, sl.ListenConfig.Control)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func internetSocket(ctx context.Context, net string, laddr, raddr sockaddr, sotype, proto int, mode string, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
    // ...
    return socket(ctx, net, family, sotype, proto, ipv6only, laddr, raddr, ctrlFn)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（2）创建 socket&lt;/h3&gt;&lt;p data-pid=&quot;dPV-XqhY&quot;&gt;在 socket 方法中首先，在 sysSocket 方法中，发起两次系统调用：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;IiYr_IMx&quot;&gt;syscall.Socket 创建套接字&lt;/li&gt;&lt;li data-pid=&quot;6daIA222&quot;&gt;syscall.SetNonblock 将 socket 设置为非阻塞模式&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;uDhhIGhF&quot;&gt;然后步入 netFD.listenStream 方法，将 socket fd 和端口进行绑定和监听，然后调用 epoll 指令设定 io 多路复用模式.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
    // 创建一个 socket 套接字
    s, err := sysSocket(family, sotype, proto)   
    // ...
    // 绑定、监听端口，并对 socket fd 进行初始化. epoll_create 和 epoll_ctl 执行的执行正是在初始化的流程中.
    fd.listenStream(laddr, listenerBacklog(), ctrlFn)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// socketFunc 宏指令，关联执行系统调用 syscall.Socket 创建套接字
var socketFunc        func(int, int, int) (int, error)  = syscall.Socket


func sysSocket(family, sotype, proto int) (int, error) {
    // 通过系统调用创建一个 socket
    s, err = socketFunc(family, sotype, proto)
    // 通过系统调用将 socket 设置为非阻塞模式
    syscall.SetNonblock(s, true)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（3）绑定、监听端口&lt;/h3&gt;&lt;p data-pid=&quot;T3rSmUSn&quot;&gt;在 netFD.listenStream 方法中&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;GLYG21r8&quot;&gt;发起系统调用 syscall.Bind 实现 socket fd 和端口的绑定&lt;/li&gt;&lt;li data-pid=&quot;XdnnwwFF&quot;&gt;发起系统调用，实现对 fd 的监听&lt;/li&gt;&lt;li data-pid=&quot;ZUm4dvma&quot;&gt;调用 netFD.init 方法对 socket fd 进行初始化&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// listenFunc 宏指令，关联执行系统调用 syscall.Listen 监听端口
var listenFunc        func(int, int) error              = syscall.Listen


func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
    // ...
    // 调用 bind 系统调用，将 socket fd 和端口进行绑定
    syscall.Bind(fd.pfd.Sysfd, lsa)
    // 通过宏指令调用 listen 系统调
    listenFunc(fd.pfd.Sysfd, backlog)
    // 初始化 socket fd，在其中执行了 epoll 操作
    fd.init()
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) init() error {
    return fd.pfd.Init(fd.net, true)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *FD) Init(net string, pollable bool) error {
    // ...
    fd.pd.init(fd)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（4）创建 epoll 池&lt;/h3&gt;&lt;p data-pid=&quot;TaOctLXt&quot;&gt;从 netFD.init 方法出发，历经 netFD.init -&amp;gt; FD.Init -&amp;gt; pollDesc.init 的链路，最终在 pollDesc.init 方法中，通过 sync.Once 保证全局只执行一次 runtime_pollServerInit 方法作 epoll 池的初始化.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var serverInit sync.Once


func (pd *pollDesc) init(fd *FD) error {
    serverInit.Do(runtime_pollServerInit)
    ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;f92iaIRN&quot;&gt;runtime_pollServerInit 方法最终会编译关联到位于 runtime/netpoll_epoll.go 文件的 netpollinit 方法，可以看到在方法中，通过调用 epollcreate1 方法，执行了 epoll 指令完成了 epoll 池的创建.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollinit() {
    // 执行 epoll_create 执行，开辟一块 epoll 池
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（5）socket fd 入池&lt;/h3&gt;&lt;p data-pid=&quot;0PcmGuEc&quot;&gt;在 pollDesc.init 方法确保全局完成一次 epoll 池的创建后，会调用 runtime_pollOpen 方法将当前 fd 添加到 epoll 池中.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var serverInit sync.Once


func (pd *pollDesc) init(fd *FD) error {
    serverInit.Do(runtime_pollServerInit)
    ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;F84aUedW&quot;&gt;runtime_pollOpen 方法最终会编译关联到位于 runtime/netpoll_epoll.go 文件的 netpollopen 方法，其中会调用 epollctl 指令，完成 socket fd 的入池操作.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollopen(fd uintptr, pd *pollDesc) int32 {
    // 将待监听的 socket fd 添加到 epoll 池中，并注册好回调路径
    var ev epollevent
    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
    *(**pollDesc)(unsafe.Pointer(&amp;amp;ev.data)) = pd    
    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;amp;ev)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;3.3 获取 TCP 连接&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bef94875f2c66183f634f57fa8e61b2f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;921&quot; data-rawheight=&quot;2677&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-bef94875f2c66183f634f57fa8e61b2f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;921&quot; data-rawheight=&quot;2677&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-bef94875f2c66183f634f57fa8e61b2f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bef94875f2c66183f634f57fa8e61b2f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;YEo9viZ8&quot;&gt;下面聊聊通过 Listener 获取 tcp 连接的方法链路.&lt;/p&gt;&lt;h3&gt;（1）获取 tcp 连接前处理&lt;/h3&gt;&lt;p data-pid=&quot;AoUGzYzb&quot;&gt;在创建好 Listener 后，接下来调用 Listener.Accept 方法，可以实现有 tcp 连接就绪时会取得连接；无 tcp 连接时令当前 goroutine 陷入阻塞的效果.&lt;/p&gt;&lt;p data-pid=&quot;eTbiERWI&quot;&gt;历经 TCPListener.Accept -&amp;gt; TCPListener.accept -&amp;gt; netFD.accept -&amp;gt; FD.Accept 的辗转，最终获取 tcp 连接及阻塞处理的核心逻辑实现于 internal/poll/fd_unix.go 的 FD.Accept 方法.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (l *TCPListener) Accept() (Conn, error) {
    // ...
    c, err := l.accept()
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (ln *TCPListener) accept() (*TCPConn, error) {
    fd, err := ln.fd.accept()
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) accept() (netfd *netFD, err error) {
    // 倘若有 tcp 连接到达，则成功取出并返回
    // 倘若没有 tcp 连接到达，会 gopark 进入被动阻塞，等待被唤醒
    d, rsa, errcall, err := fd.pfd.Accept()
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（2）尝试获取 tcp 连接&lt;/h3&gt;&lt;p data-pid=&quot;Y80G07fI&quot;&gt;在 FD.Accept 方法中：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;TTF6Luuu&quot;&gt;首先调用 accept 方法，会通过系统调用 syscall.Accept 以非阻塞模式尝试获取一次对应 socket fd 下到达的 tcp 连接&lt;/li&gt;&lt;li data-pid=&quot;7saO7tD-&quot;&gt;倘若没有就绪的 tcp 连接，会抛出 syscall.EAGAIN 错误，此时会走入 pollDesc.waitRead 分支，最终通过 gopark 操作令当前 goroutine 陷入被动阻塞状态&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {
    // ...
    for {
        // 通过 accept 系统调用，尝试接收一个连接
        s, rsa, errcall, err := accept(fd.Sysfd)
        // ...
        switch err {    
        case syscall.EAGAIN:
            if fd.pd.pollable() {
                if err = fd.pd.waitRead(fd.isFile); err == nil {
                    continue
                }
            }
        // ...
        }
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var AcceptFunc func(int) (int, syscall.Sockaddr, error) = syscall.Accept


func accept(s int) (int, syscall.Sockaddr, string, error) {
    // ...
    ns, sa, err = AcceptFunc(s)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) waitRead(isFile bool) error {
    return pd.wait(&#x27;r&#x27;, isFile)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) wait(mode int, isFile bool) error {
    // ...
    res := runtime_pollWait(pd.runtimeCtx, mode)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（3）被动阻塞 goroutine&lt;/h3&gt;&lt;p data-pid=&quot;UIrv7xUo&quot;&gt;历经 pollDesc.waitRead -&amp;gt; pollDesc.wait -&amp;gt; poll_runtime_pollWait 的链路，最终会在 netpollblock 方法中，通过 gopark 操作，令求 tcp 连接而不得的 loop goroutine 陷入被动阻塞状态.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func poll_runtime_pollWait(pd *pollDesc, mode int) int {
    // ...
    for !netpollblock(pd, int32(mode), false) {
        // ...
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
    // ...
    if waitio || netpollcheckerr(pd, mode) == pollNoError {
        // 调用 gopark 被动阻塞挂起
        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;3.4 TCP 连接读数据&lt;/h2&gt;&lt;p data-pid=&quot;1qknZLdM&quot;&gt;最后聊聊当 loop goroutine 获取到 tcp 连接时的代码分支.&lt;/p&gt;&lt;h3&gt;（1）conn fd 入池&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2571a096cc3058fff94f1477486a9746_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;733&quot; data-rawheight=&quot;2608&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2571a096cc3058fff94f1477486a9746_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;733&quot; data-rawheight=&quot;2608&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2571a096cc3058fff94f1477486a9746_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2571a096cc3058fff94f1477486a9746_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;s1wCJQv4&quot;&gt;在位于 internal/poll/sock_cloexec.go 的 netFD.accept 方法中，倘若通过系统调用 syscall.Accept 成功获取到了到达的 tcp 连接，则会将其封装为一个 netFD，并通过 epoll_ctl 指令将该 fd 添加到 epoll 池中，实现对 read 事件的监听.&lt;/p&gt;&lt;p data-pid=&quot;v_Gvwogl&quot;&gt;方法链路与 3.2 小节的第（5）部分类似，不再赘述.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) accept() (netfd *netFD, err error) {
    // 调用 accept 系统调用，接收 tcp 连接
    d, rsa, errcall, err := fd.pfd.Accept()
    // 将 connet fd 封装成 netfd
    netfd, err = newFD(d, fd.family, fd.sotype, fd.net)
    // 对 netfd 进行初始化，底层会调用 epoll_ctl 将其注册到 listener 对应的 epoll 池中 
    netfd.init()
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) init() error {
    return fd.pfd.Init(fd.net, true)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *FD) Init(net string, pollable bool) error {
   // ...
    err := fd.pd.init(fd)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) init(fd *FD) error {
    serverInit.Do(runtime_pollServerInit)
    ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（2）读 tcp 连接数据&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;946&quot; data-rawheight=&quot;2566&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;946&quot; data-rawheight=&quot;2566&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;-6dCdgBw&quot;&gt;获取到 tcp 连接后，在缓存区数据未就绪时，用户执行 read 操作同样会陷入阻塞，对应的方法链路如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (c *conn) Read(b []byte) (int, error) {
    // ...
    n, err := c.fd.Read(b)
    // ...
    return n, err
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) Read(p []byte) (n int, err error) {
    n, err = fd.pfd.Read(p)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;VeI_A3zm&quot;&gt;在位于 internal/poll/fd_unix.go 的 FD.Read 方法中，会执行 syscall.Read 尝试从 conn fd 中读取数据，倘若数据未就绪，则会抛出 EAGAIN error，此时会调用 pollDesc.waitRead 方法将当前的 loop read goroutine 挂起，链路同 3.3 小节第（2）部分，不再赘述.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *FD) Read(p []byte) (int, error) {
    // ...
    for {
        n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p)
        
        if err == syscall.EAGAIN &amp;amp;&amp;amp; fd.pd.pollable() {
            fd.pd.waitRead(fd.isFile)
            // ...
        }
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) waitRead(isFile bool) error {
    return pd.wait(&#x27;r&#x27;, isFile)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) wait(mode int, isFile bool) error {
    // ...
    res := runtime_pollWait(pd.runtimeCtx, mode)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func poll_runtime_pollWait(pd *pollDesc, mode int) int {
    // ...
    for !netpollblock(pd, int32(mode), false) {
        // ...
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
    // ...
    if waitio || netpollcheckerr(pd, mode) == pollNoError {
        // 调用 gopark 被动阻塞挂起
        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;3.5 TCP 连接写入数据&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;946&quot; data-rawheight=&quot;2566&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;946&quot; data-rawheight=&quot;2566&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1da5866dcf2291939267a22db20b8ab6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;yCs1qX6l&quot;&gt;向 tcp 连接中写入数据的流程基本和 3.4 小节第（2）部分从 tcp 连接读取数据的链路形成对仗.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (c *conn) Write(b []byte) (int, error) {
    // ...
    n, err := c.fd.Write(b)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *netFD) Write(p []byte) (nn int, err error) {
    nn, err = fd.pfd.Write(p)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;4Hv8NqhG&quot;&gt;在位于 internal/poll/fd_unix.go 的 FD.Write 方法，会执行系统调用 syscall.Write，尝试将数据写入 tcp 连接的缓冲区. 倘若当前缓冲区已经没有剩余的空间，则会抛出 EAGAIN 错误，然后执行 pollDesc.waitWrite，最终执行 gopark 操作将当前 loop write goroutine 挂起.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (fd *FD) Write(p []byte) (int, error) {
    // ...
    var nn int
    for {
        max := len(p)
        // ...
        n, err := ignoringEINTRIO(syscall.Write, fd.Sysfd, p[nn:max])
        // ...
        if err == syscall.EAGAIN &amp;amp;&amp;amp; fd.pd.pollable() {
            fd.pd.waitWrite(fd.isFile);
        }
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) waitWrite(isFile bool) error {
    return pd.wait(&#x27;w&#x27;, isFile)
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func (pd *pollDesc) wait(mode int, isFile bool) error {
    // ...
    res := runtime_pollWait(pd.runtimeCtx, mode)
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
    // ...
    if waitio || netpollcheckerr(pd, mode) == pollNoError {
        // 调用 gopark 被动阻塞挂起
        gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;3.6 唤醒 IO 阻塞协程&lt;/h2&gt;&lt;p data-pid=&quot;5he18JcL&quot;&gt;3.3-3.5 小节中我们聊到，当 io event 未就绪时，会在位于 runtime/netpoll.go 的 poll_runtime_pollWait 方法中执行 gopark 操作，令当前的 loop goroutine 陷入被动阻塞状态.&lt;/p&gt;&lt;p data-pid=&quot;6HQ1_6ds&quot;&gt;本小节我们就来看看，这些 goroutine 将会在什么时机得到唤醒的机会.&lt;/p&gt;&lt;h3&gt;（1）全局监控任务 sysmon&lt;/h3&gt;&lt;p data-pid=&quot;pjuHG255&quot;&gt;在位于 runtime/proc.go 的 main 函数中，会单独启动一个 m（GMP中对线程的抽象 M），用于执行 sysmon 监控任务.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func main() {
    // ...
    systemstack(func() {
        newm(sysmon, nil, -1)
    })  
    // ... 
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;MF75uFKr&quot;&gt;在 sysmon 函数中，会每隔 10ms 调用 netpoll 函数，尝试取出 io event 已到达的 loop goroutine，进行唤醒操作.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func sysmon() {
    // ...
    for {        
        // 每 10 ms 周期性执行一次
        lastpoll := int64(atomic.Load64(&amp;amp;sched.lastpoll))
        if netpollinited() &amp;amp;&amp;amp; lastpoll != 0 &amp;amp;&amp;amp; lastpoll+10*1000*1000 &amp;lt; now {
            atomic.Cas64(&amp;amp;sched.lastpoll, uint64(lastpoll), uint64(now))
            // 取出就绪的 loop goroutine
            list := netpoll(0) 
            // ...
            // 唤醒 list 中的 goruotine
            injectglist(&amp;amp;list)
        }
        // ...
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Ke924AIn&quot;&gt;netpoll 方法位于 runtime/net_epoll.go 文件，方法中会基于非阻塞模式调用 epollwait 方法，获取到就绪事件队列 events，然后遍历事件队列，调用 netpollready 方法将对应的 loop goroutine 添加到 gList 中返回给上层用于执行唤醒操作.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpoll(delay int64) gList {
    // ...
    var events [128]epollevent
retry:
    // 非阻塞调用 epoll_wait，接收到就绪的事件列表
    n := epollwait(epfd, &amp;amp;events[0], int32(len(events)), waitms)
    // ...
    var toRun gList
    for i := int32(0); i &amp;lt; n; i++ {
        ev := &amp;amp;events[i]
        // 添加关心的事件模式
        var mode int32
        if ev.events&amp;amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += &#x27;r&#x27;
        }
        if ev.events&amp;amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += &#x27;w&#x27;
        }
        // 从 event 中获取已就绪的 fd，调用 netpollready 方法将 fd 添加到 gList 中用于返回，在上层进行唤醒和执行
        if mode != 0 {
            pd := *(**pollDesc)(unsafe.Pointer(&amp;amp;ev.data))
            pd.setEventErr(ev.events == _EPOLLERR)
            netpollready(&amp;amp;toRun, pd, mode)
        }
    }
    return toRun
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func netpollready(toRun *gList, pd *pollDesc, mode int32) {
    var rg, wg *g
    if mode == &#x27;r&#x27; || mode == &#x27;r&#x27;+&#x27;w&#x27; {
        rg = netpollunblock(pd, &#x27;r&#x27;, true)
    }
    if mode == &#x27;w&#x27; || mode == &#x27;r&#x27;+&#x27;w&#x27; {
        wg = netpollunblock(pd, &#x27;w&#x27;, true)
    }
    // 将 read、write 的就绪 fd 对应的 goroutine 中，添加到 toRun 链表中
    if rg != nil {
        toRun.push(rg)
    }
    if wg != nil {
        toRun.push(wg)
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（2）GMP 调度主流程&lt;/h3&gt;&lt;p data-pid=&quot;-p80cdHZ&quot;&gt;在 GMP 主流程方法 schedule 中，在每轮调度中，g0 都会调用 findrunnable 为当前 P 寻找下一个可执行的 goroutine. 此时当 P 本地队列和全局队列都没有待执行的 goroutine 时，则会尝试获取就绪的 loop goroutine 用于执行.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func findrunnable() (gp *g, inheritTime bool) {
    // ...
    if netpollinited() &amp;amp;&amp;amp; atomic.Load(&amp;amp;netpollWaiters) &amp;gt; 0 &amp;amp;&amp;amp; atomic.Load64(&amp;amp;sched.lastpoll) != 0 {
        if list := netpoll(0); !list.empty() { // non-blocking
            gp := list.pop()
            injectglist(&amp;amp;list)
            casgstatus(gp, _Gwaiting, _Grunnable)
            //... 
            return gp, false
        }
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;（3）GC start the world&lt;/h3&gt;&lt;p data-pid=&quot;faSY31G-&quot;&gt;在 GC 过程中，每次调用完 stop the world 之后，都会对仗调用 start the world 重启世界，此时也会对就绪的 loop goroutine 执行唤醒操作.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;func startTheWorldWithSema(emitTraceEvent bool) int64 {
   // ...
    if netpollinited() {
        list := netpoll(0) // non-blocking
        // 唤醒 list 中的 goruotine
        injectglist(&amp;amp;list)
    }
    // ...
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;4 总结&lt;/h2&gt;&lt;ul&gt;&lt;li data-pid=&quot;xHlwsZEE&quot;&gt;基于伪代码推演了 IO 多路复用的实现思路，核心是基于主动轮询+非阻塞 IO 模式实现，但真正的优雅实现需要依赖于内核，这是因为用户态始终无法准确感知到 io event 的情报&lt;/li&gt;&lt;li data-pid=&quot;sRpz9Nxj&quot;&gt;聊了 epoll 技术的实现原理：（1）拆解建池接口 epoll_create 和入池接口 epoll_ctl，实现 fd 一次拷贝多次复用；（2）通过红黑树维护池中的 fd 数据，增删改平均复杂度 O(logN)；（3）精准事件回调，准确告知 loop thread 具体哪些 fd 已就绪&lt;/li&gt;&lt;li data-pid=&quot;-f9ngRMs&quot;&gt;走读了 Golang 底层 IO 模型的代码链路，Golang 在创建 Listener、获取 conn、读 conn 和 写 conn 时都涉及到对 epoll 技术的应用.&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;NH9bM7Ak&quot;&gt;本文至此结束，未来两周，我们向上扩展，聊聊 Golang 开源 web 框架 gin 的实现原理.&lt;/p&gt;&lt;p data-pid=&quot;cnyAlLaM&quot;&gt;gin：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/gin-gonic/gin&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/gin-gonic/gi&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;KALiduPA&quot;&gt;文末小广告：&lt;/p&gt;&lt;p data-pid=&quot;XgpxgtyL&quot;&gt;欢迎老板们关注我的个人公众号：小徐先生的编程世界&lt;/p&gt;&lt;p data-pid=&quot;3O9KTEAd&quot;&gt;我会不定期更新个人纯原创的&lt;a href=&quot;https://www.zhihu.com/search?q=%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2846169717%7D&quot; class=&quot;internal&quot;&gt;编程技术&lt;/a&gt;博客，技术栈以 go 语言为主，让我们一起点亮更多的编程技能树吧！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ebec780de6e814cc6e82382060761bb7</guid>
<title>工作十年，在腾讯沉淀的高可用系统架构设计经验</title>
<link>https://toutiao.io/k/b0wt5fx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;239&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4250681198910082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95sINOI2rjxOTmQzicLicmcnECB5EcCnQjgqnBHnibricriapzfGv3PbyFSQ4pblMjjwBt8wG1E4kRuMHg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;54&quot; data-backw=&quot;534&quot; data-ratio=&quot;0.1008174386920981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe96srmm5CxquJGSP4BbZA8IDLUj8l7F3tzrm8VuILsgUPDciaDLtvQx78DbkrhAqOJicxze5ZUO5ZLNg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-rows=&quot;1&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👉腾小云导读&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在系统的开发过程中，很多开发者都为了实现系统的高可用性而发愁。本文从研发规范层面、应用服务层面、存储层面、产品层面、运维部署层面、异常应急层面这六大层面去剖析一个高可用系统的架构设计需要有哪些关键的设计和考虑。希望腾讯的经验方法，能够给广大开发者提供参考。内容较长，您可以收藏后持续阅读。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👉&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;看目&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;录&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点收藏，随时涨技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1 高可用系统的架构设计思想&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    1.1 可用性和高可用概念&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    1.2 高可用系统设计思想&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2 研发规范层面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.1 方案设计和编码规范&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.2 容量规划和评估&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    2.3 QPS 预估（漏斗型）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 应用服务层面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.1 无状态和负载均衡设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.2 弹性扩缩容设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.3 异步解耦和削峰设计（消息队列）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.4 故障和容错设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    3.5 过载保护设计（限流、熔断、降级）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4 存储层面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    4.1 集群存储（集中式存储）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    4.2 分布式存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5 产品层面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6 运维部署层面&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.1 开发阶段-灰度发布、接口测试设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.2 开发阶段-监控告警设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.3 开发阶段-安全性、防攻击设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.4 部署阶段-多机房部署（容灾设计）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.5 线上运行阶段-故障演练（混沌实验）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    6.6 线上运行阶段-接口拨测系列设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7 异常应急层面&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5738304093567251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94A1nPxrhKRfHPEzlH6viavKNiaGIVqDWqhvq9n7kzAFHbicaeiackt4vibqfF2GToF8ztRlxLTrzgSeAg/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;1368&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;01&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;高可用系统的架构设计思想&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 1.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;可用性和高可用概念&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可用性是一个可以量化的指标，&lt;span&gt;是指在某个考察时间，系统能够正常运行的概率或时间占有率期望值。行&lt;/span&gt;业内一般用几个 9 表示可用性指标，对应用的可用性程度一般衡量标准有三个 9 到五个 9。&lt;/span&gt;&lt;span&gt;&lt;span&gt;一般我们的系统至少要到 4 个 9&lt;/span&gt;&lt;span&gt;（99.99%）&lt;/span&gt;&lt;span&gt;的可用性才能谈得上高可用。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;高可用 High Availability 的定义&lt;/span&gt;&lt;span&gt;（From 维基百科）&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;高可用是 IT 术语，指系统无中断地执行其功能的能力，代表系统的可用性程度，是进行系统设计时的准则之一。服务不可能 100% 可用，因此要提高我们的高可用，就要尽最大可能的去增加我们服务的可用性，提高可用性指标。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一句话来表述就是：高可用就是让我们的服务在任何情况下，都尽最大可能地能够对外提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;高可用系统设计思想&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;高可用系统的架构设计，需要有一套比较科学的工程管理套路。要从产品、开发、运维、基建等全方位去考量和设计。&lt;strong&gt;高可用系统的架构设计思想包括但不限于&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好研发规范。系统都是研发人员设计和编码写出来的，因此首先要对研发层面有一个规范和标准。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好容量规划和评估。主要是让开发人员对系统要抗住的量级有一个基本认知，方便进行合理的架构设计和演进。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好服务层面的高可用。主要是负载均衡、弹性扩缩容、异步解耦、故障容错、过载保护等。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好存储层面的高可用。主要是冗余备份&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;（热备，冷备）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;、失效转移&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;（确认，转移，恢复）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;等。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好运维层面的高可用。主要是发布测试、监控告警、容灾、故障演练等。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好产品层面的高可用。主要是兜底策略等。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;做好应急预案。主要是要思考在出现问题后怎样快速恢复，不至于让我们的异常事态扩大。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;02&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;研发规范层面&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;方案设计和编码规范&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研发规范层面是大家容易忽视的一个点。但是我们所有的设计，都是研发人员来完成的，包括从设计文档到编码再到发布上线。因此，研发层面也要有一个规范流程和套路，以让我们更好地去研发和维护一个高可用的系统：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;table interlaced=&quot;disabled&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阶段&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;事项&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;设计&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;阶段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;规范好相关方案设计文档的模板和提纲，让团队内部保持统一。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;方案设计后一定要进行评审。在团队中，新项目一定要评审，重构项目一定要评审，大的系统优化或者升级一定要评审，其他的一般研发工作量超过一周的建议也要评审。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;编码阶段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;执行代码规范：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;工程的 layout 目录需结构规范，团队内部保持统一，尽量简洁；&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;遵循团队内部的代码规范。一般公司都有对应语言的规范，如果没有则参考官方的规范，代码规范可以大大减少 bug 并且提高可用性。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单测覆盖率：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;代码编写完需要有一定的单测能力来保证代码的健壮性，同时也能保障我们后续调整逻辑或者优化的时候可以保证代码的稳定。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;包括：增量覆盖率、全量覆盖率。具体的覆盖率要达到多少，可以根据团队内部的实际情况来定，一般定的规则是 50% 的覆盖率。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;日志规范&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不要随便打日志、要接入远程日志、要能够分布式链路追踪。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;发布上线阶段&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;section&gt;&lt;span&gt;参考下面运维部署层面章节的灰度发布和接口测试相关说明&lt;/span&gt;&lt;span&gt;（即6.1）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;容量规划和评估&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;是指需要评估好在做的这个系统是为了应对一个什么体量的业务、这个业务请求量的平均值、高峰的峰值大概都在一个什么级别。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果是新系统，那么就需要先搜集产品和运营同事对业务的大体预估，开发者根据他们给的数据再进行详细评估。如果是老系统，那么就可以根据历史数据来评估。评估的时候，要从一个整体角度来看全局的量级，然后再细化到每个子业务模块要承载的量级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;是指系统在设计的时候，就要能够初步规划好系统大致能够维持的量级，比如是十万级还是百万级别的请求量，或者更多。不同量级对应的系统架构设计完全不一样。尤其到了千万、亿级别的量级的时候，架构设计会有更多的考量。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里值得注意的是，不需要在一开始就设计出远超当前业务真实流量的系统，要根据业务实际情况来设计。同时，容量规划还涉及到：系统上下游的各个模块、依赖的存储、依赖的三方服务分别需要多少资源，需要有一个相对可量化的数据。容量规划阶段更多是要依靠自身和团队的经验，比如要了解系统的 log 的性能、redis 的性能、rpc 接口的性能、服务化框架的性能等等，然后根据各种组件的性能来综合评估已经设计的系统的整体性能情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容量评估和容量规划之后，还需要做就是性能压测。最好是能够做到全链路压测。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;性能压测的目的是确保系统的容量规划是否准确。假设设计的这个系统，规划的是能够抗千万级别的请求。那么实际上，真的能够抗住吗 ？在上线之前首先要根据经验来判断，其次是一定要经过性能压测得出准确结论。&lt;/span&gt;&lt;strong&gt;性能压测要关注的指标很多，但是重点要关注的是两个指标：一个是 QPS，一个是响应耗时要确保压测的结果符合预期&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;压测的步骤：可以先分模块单独压测。最后如果情况允许，那么最好执行全链路压测。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 2.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;QPS 预估（漏斗型）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QPS 预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;（漏斗型）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;指的是：一个真实的请求过来后，从接入层开始分别经过了整个系统的哪些层级、哪些模块，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;每一个层级的 QPS 的量级分别有多少。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从请求链路上来看，层级越往下，下游层级的量级就会越少。因为每经过一个层级，都有可能会被各种条件过滤掉一部分请求。例如进入活动页后查看商品详情然后下单这个例子，首先进入活动页，所有的请求都会进入访问。然后只会有部分用户查询商品详情。最后查看商品详情的这些用户又只会有部分用户会下单。这里就会有一个漏斗，所以从上层模块到下层模块的量级一定是逐步减少的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;QPS 预估&lt;/span&gt;&lt;span&gt;（漏斗型）&lt;/span&gt;&lt;span&gt;需要开发者按照请求的层面和模块，来构建预估漏斗模型，然后预估好每一个层级的量级。包括但不限于从服务、接口、分布式缓存等各个层面来预估，最后构成完整的 QPS 漏斗模型。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;03&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;应用服务层面&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 3.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;无状态和负载均衡设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要做到系统的高可用，一般应用服务的常规设计都是无状态的。这也就意味着，开发者可以部署多个实例来提高系统的可用性。而这多个实例之间的流量分配，就需要依赖系统的负载均衡能力。&lt;strong&gt;「无状态 + 负载均衡」既可以让系统提高并发能力，也可以提高系统的可用性。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果开发者的业务服务使用的是各种微服务框架，那么大概率在这个微服务框架里面就包含了服务发现和负载均衡的能力。这一整套流程包括：服务注册和发现、负载均衡、健康状态检查和自动剔除。当系统的任何一个服务实例出现故障后，它会被自动剔除掉。当系统有新增一个服务实例后，它会被会自动添加进来提供服务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果大家不是使用的微服务框架来开发的，那么就需要依赖负载均衡的代理服务，例如 LVS、Nginx 来帮系统实现负载均衡&lt;/span&gt;&lt;span&gt;。当然，腾讯云的 CLB 负载均衡也支持亿级连接和千万级并发，各位感兴趣的话可自行搜索了解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 3.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;弹性扩缩容设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;弹性扩缩容设计是应对突峰流量的非常有效的手段之一，同时也是保障系统服务可用性的必要手段。弹性扩缩容针对的是系统无状态的应用服务而言的。服务是无状态的，因此可以随时根据请求量的大小来进行扩缩容，流量大就扩容来应对大量请求，流量小的时候就缩容减少资源占用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;怎么实现弹性扩缩容呢？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;现阶段都是云原生时代，大部分的公司都是采用容器化&lt;/span&gt;&lt;span&gt;（K8s）&lt;/span&gt;&lt;span&gt;部署，那么基于这个情况的话，弹性扩缩容就非常容易了，只需要配置好 K8s 的弹性条件就能自动根据 CPU 的使用率来实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果不是容器化部署，是物理机部署的方式，那么要做到弹性扩缩容，必须要有一个公司内部的基础建设能力、能够在运营平台上针对服务的 CPU 或者 QPS 进行监控。如果超过一定的比例就自动扩缩容，就和 K8s 的弹性原理是一样的，只是需要自行实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 3.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;异步解耦和削峰设计（消息队列）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;要想系统能够高可用？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;从架构层面来说，要做到分层、分模块来设计。而分层分模块之后各个模块之间，还可以进行异步处理、解耦处理。目的是为了不相互影响，通过异步和解耦可以使系统的架构大大的提升可用性。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;架构层面的异步解耦方式就是采用消息队列&lt;/span&gt;&lt;span&gt;（比如常见的 Kafka）&lt;/span&gt;&lt;span&gt;，并且同时消息队列还有削峰的作用，这两者都可以提高系统的架构可用性：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;采用消息队列之后，可以把同步的流程转换为异步的流程，消息生成者和消费者都只需要和消息队列进行交互。这样不仅做了异步处理，还将消息生成者和消费者进行了隔离。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;table align=&quot;center&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;方式&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异步&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;异步处理的优势在于，不管消息的后续处理的业务服务是否完成，只要消息队列还没满，那么就可以执行对外提供服务。而消费方则可以根据自身处理能力来消费消息，再进行处理。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;解耦&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;解耦的优势在于如果消费方异常，并不影响生产方，依然可以对外提供服务。&lt;/span&gt;&lt;span&gt;消息消费者恢复后可以继续从消息队列里面，获取消费数据后执行业务逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;削峰&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;采用消息队列之后，还可以做到削峰的作用，当并发较高的时候甚至是流量突发的时候，只要消息生产者能够将消息写入到消息队列中，那么这个消息就不会丢。后续处理逻辑会慢慢的去消息队列里面消费这些突发的流量数据。这样就不会因为有突发流量而把整个系统打垮。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr/&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 3.4 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;故障和容错设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;任何服务，一定会存在失败的情况，不可能有 100% 的可用性。服务在线上运行过程中，总会遇到各种各样意想不到的问题会让服务出现状况，因此业界来评价可用性 SLA 都是说多少个 9，例如 4 个 9&lt;/span&gt;&lt;span&gt;(99.99%)&lt;/span&gt;&lt;span&gt;的可用性。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为此，一般设计建议遵循「design for failure」的设计原则，设计出一套可容错的系统。需要做到尽早返回、自动修复，细节如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;要点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;p&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;遵循 fail fast 原则&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Fail fast 原则是说，当系统的主流程的任何一步出现问题的时候，应该快速合理地结束整个流程，尽快返回错误，而不是等到出现负面影响才处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具备自我保护的能力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;当系统依赖的其他服务出现问题的时候，要尽快的进行降级、兜底等各种异常保护措施，避免出现连锁反应导致整个服务完全不可用。例如当系统依赖的数据存储出现问题，不能一直重试从而导致数据完全不可用。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr/&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 3.5 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;过载保护设计（限流、熔断、降级）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;系统无法高可用的一个重要原因就在于：系统经常会有突发的流量到来，导致服务超载运行。这个时候首先要做的是快速扩容，并且开发者事先就要预留好一定的冗余。另外一个情况下，就算扩容了，但是还是会超载。例如超过了下游依赖的存储的最大容量、或者超过了下游依赖的三方服务的最大容量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么这个时候，系统就需要执行过载保护策略了，主要包括限流、熔断、降级，过载保护是为了保证服务部分可用，不至于导致整个服务完全不可用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;过载保护手段&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;限流&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;限流是指对进入系统的请求进行限流处理，如果请求量超过了系统最大处理能力或者超过了开发者指定的处理能力，那么直接拒绝请求，通过这种丢弃部分请求的方式可以保证整个系统有一定的可用性，不至于让整个系统完全不可用。那么怎样判别超过最大处理能力呢？一般就是利用 QPS 来判别，如果 QPS 超过阈值，那么就直接拒绝请求。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限流有很多细节的策略，例如针对接口限流、针对服务限流、针对用户限流。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;熔&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;断&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;熔断，断路（开路）的价值在于限制故障影响范围。一般希望控制、减少或中断和故障系统之间的通信，从而降低故障系统的负载，这有利于系统的恢复。一般系统的服务都会有很多下游依赖，如果下游依赖的服务出现问题，例如开始就超时甚至响应非常慢的话，如果不做任何处理，那么会导致整个请求都被卡住造成超时，那么系统的业务服务对外就无法提供任何正常的功能&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为此，熔断策略就可以解决这个问题，熔断就是当系统依赖的下游服务出现问题时，可以快速对其进行熔断（不发起请求），这样系统的业务服务至少可以提供部分功能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熔断的设计至少需要包括：熔断请求判断机制算法、熔断恢复、熔断告警三部分。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr/&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;降级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;降级是指开发者划分好系统的核心功能和非核心功能，然后当系统超过最大处理能力之后，直接关闭掉非核心的功能，从而保证核心功能的可用。关闭非核心的功能后可以使系统释放部分资源，从而可以有资源来处理核心功能。&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;熔断和降级这两个策略虽有些相似，字面的意思都是要快速拒绝请求。但是却是两个维度的设计：降级的目的是应对系统自身的故障，而熔断的目的是应对系统依赖的外部服务故障。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;04&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;存储层面&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当前的互联网时代，应用服务基本都是无状态的。因此应用服务的高可用相对来说会比较简单。但是数据存储的高可用相对来说，会复杂很多。因为数据是有状态的，那具体开发者要怎样保障数据存储的高可用。下文一起来分析下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储层面的高可用方案本质是通过数据的冗余来实现，将数据复制到多个存储介质里面，可以有效的避免数据丢失，同时还可以提高并发能力。因为数据是有状态的，这里会比服务的高可用要复杂很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;常见的解决存储高可用的方案有两种：&lt;strong&gt;集群存储和分布式存储&lt;/strong&gt;。业界大多是围绕这些来构建，或者是做相关衍生和扩展。下面展开讲解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 4.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;集群存储（集中式存储）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集群存储&lt;/span&gt;&lt;span&gt;是指由若干个「通用存储设备」组成的用于存储的集群。组成集群存储的每个存储系统的性能和容量均可通过「集群」的方式得以叠加和扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集群存储适合业务存储量规模一般的场景，常规的业务数据存储一般都是集群存储方式就足够了。现在一般业务数据存储的使用默认都是集群方式。比如 Redis、MySQL 等存储类型。一般中大型互联网公司默认是集群存储的方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集群存储就是常说的「 1 主多备」或者「 1 主多从」的架构。写数据通过主机，读数据一般通过从机。集群存储主要需要考虑如下几个问题：&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;主机如何将数据复制给备机&lt;/span&gt;&lt;span&gt;（从机）？数据的写入都是通过主机，因此数据同步到备机（从机），就是要通过主机进行数据复制到备机（从机）。还需要考虑主备同步的时间延迟问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;备机（从机）如何检测主机状态？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;主机故障后，备机&lt;/span&gt;&lt;span&gt;（从机）怎么切换为主机？主从架构中，如果主机发生故障，可直接将备机（从机）切换为主机。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 4.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;分布式存储&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式是指将不同的业务分布在不同的节点。分布式中的每一个节点，都可以做集群。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「分布式存储系统」是将数据分散存储在多台独立的设备上。传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式网络存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息。它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式存储适合非常大规模的数据存储，业务数据量巨大的场景可以采用这种方式。常见的分布式存储&lt;/span&gt;&lt;span&gt;比如 COS、GooseFS、Had&lt;/span&gt;&lt;span&gt;oop(HDFS)、HBase、Elasticsearch 等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;05&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;产品层面&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;产品层面的高可用架构解决方案，基本上就是指兜底产品策略。降级/限流的策略，更多的是从后端的业务服务和架构上的设计来考虑相关解决方案。这里说的兜底策略也可叫做「柔性降级策略」，更多的则是通过产品层面上来考虑。下面举几个例子：&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当系统的页面获取不到数据时，或者无法访问时，要如何友好的告知用户。如「稍后重试」之类的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当系统的真实的页面无法访问的时候，就需要产品提供一个默认页面，如果后端无法获取真实数据，那么直接渲染默认页面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器需要停机维护，那么产品层面就会显示一个停机页面，所有用户只会弹出这个停机页面，不会请求后端服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抽奖商品显示一个默认兜底商品等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;06&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;运维部署层面&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.1 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开发阶段-灰度发布、接口测试设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;灰度发布、接口测试、接口拨测系列设计包括但不限于：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务发布上线的时候，要有一个灰度的过程。先灰度 1-2 个服务实例，然后逐步放量观察。如果一切 ok，再逐步灰度，直到所有实例发布完毕。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;每次服务发布上线的时候，服务提供的各种接口，都要有接口测试用例。接口测试用例测试通过后，服务才能发布上线。这样目的是为了查看系统对外提供的接口是否能够正常运行，避免服务发布后才发现有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;灰度发布和接口测试，一般在大公司里面会有相关的 DevOps 流程来保证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;开发阶段-监控告警设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;监控告警的设计，对部分大公司来说不是问题。因为一定会有&lt;span&gt;一些&lt;/span&gt;比较专门的人去做这种基础能力的建设，会有对应的配套系统，业务开发者只需要配置或使用即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那如果公司内部没有相关基础建设，就需要开发者分别来接入对应的系统，或者直接接入一些指标、链路、日志、事件等多数据支持、更加一体化的监控平台，比如腾讯云可观测平台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;系统&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;建设要求&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;监控系统&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一般在监控系统这方面的开源解决方案包括但不限于这些：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ELK (Elasticsearch、Logstash、Kibana) 日志收集和分析：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们的日志记录不能都本地存储，因为微服务化后，日志散落在很多机器上，因此必须要有一个远程日志记录的系统，ELK 是不二人选。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Prometheus 监控收集：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以监控各种系统层面的指标，包括自定义的一些业务指标&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;OpenTracing 分布式全链路追踪：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;一个请求的上下游这么多服务，怎么能够把一个请求的上下游全部串起来，那么就要依靠 OpenTracing，可以把一个请求下的所有链路都串起来并且有详细的记录。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;OpenTelemetry 可观测系统标准：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最新的标准，大一统，集合了跟踪数据（Traces），指标数据（Metrics），日志数据（Logs）来观测分布式系统状态的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我们会依托开源系统进行自建或者扩展，甚至直接使用都行，然后我们的监控的指标一般会包括：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;基础设施层的监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要是针对网络、交换机、路由器等低层基础设备，这些设备如果出现问题，那么依托其运行的业务服务肯定就无法稳定的提供服务，我们常见的核心监控指标包括网络流量(入和出)、网络丢包情况、网络连接数等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;操作系统层的监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这里需要包含物理机和容器。常见的核心指标监控包括 CPU 使用率、内存占用率、磁盘 IO 和网络带宽等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;应用服务层的监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这里的指标会比较多，核心的比如主调请求量、被调请求量、接口成功率、接口失败率、响应时间（平均值、P99、P95 等）等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;业务内部的自定义监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：每个业务服务自己的一些自定义的监控指标。比如电商系统这里的：浏览、支付、发货等各种情况的业务指标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;端用户层的监控&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：前面的监控更多的都是内部系统层面的，但是用户真正访问到页面，中间还有外网的情况，用户真正获取到数据的耗时、打开页面的耗时等这些信息也是非常重要的，但是这个一般就是需要客户端或者前端去进行统计了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;告警系统&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;3&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;这些系统接入完，还只是做到监控和统计，当出现问题时，还需要进行实时告警，因此要有一个实时告警系统，如果没有实时报警，系统运行异常后就无法快速感知，这样就无法快速处理，就会给使用者的业务带来重大故障和灾难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;告警设计需要包括：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实时性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：实现秒级监控。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;全&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;面性&lt;/strong&gt;：覆盖所有系统业务。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实用性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：预警分为多个级别。监控人员可以方便、实用地根据预警严重程度做出精确的决策。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;多样性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：预警方式提供推拉模式。包括短信，邮件，可视化界面，方便监控人员及时发现问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr/&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;开发阶段-安全性、防攻击设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;321bd073b3529290d190fd9819022c852&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;安全性、防攻击设计的目的是为了防刷、防黑产、防黑客，避免被外部恶意攻击。一般有两个策略：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在公司级别的流量入口做好统一的防刷和鉴权的能力，例如在统一接入层做好封装。&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在业务服务内部，做好相关的业务鉴权，比如登录态信息、例如增加业务鉴权的逻辑。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.4 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;部署阶段-多机房部署（容灾设计）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1eaa5fa898be48f0186e99407453049c1&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般的高可用策略，都是针对一个机房内的服务层面来设计的，但是如果整个机房都不可用了，例如地震、火灾、光纤挖断等情况怎么办？这就需要系统的服务和存储能够进行容灾了。容灾的常见方案就是多机房部署。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;服务的多机房部署&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot; rowspan=&quot;2&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;服务的多机房部署比较容易。因为我们的服务都是无状态的，因此只要名字服务能够发现不同机房的服务，就可以实现调用。这里需要注意的是名字服务（或者说负载均衡服务）要能够有就近访问的能力。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr/&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;存储的多机房部署&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; rowspan=&quot;1&quot; colspan=&quot;1&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;存储的多机房部署，这个会比较难搞一点，因为存储是有状态的，部署在不同的机房就涉及到存储的同步和复制问题。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;条件不允许的情况下，保证多机房部署业务服务就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.5 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;线上运行阶段-故障演练（混沌实验）&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;a518b5a7c72fff6c4bf4005e3c67828c1&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故障演练在大公司是一个常见的手段。在业界，Netflix 早在 2010 年就构建了混沌实验工具 Chaos Monkey。混沌实验工程对于提升复杂分布式系统的健壮性和可靠性发挥了重要作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单的故障演练就是模拟机房断电、断网、服务挂掉等场景，然后看整个系统运行是否正常。系统就要参考混沌实验工程来进行详细的规划和设计，这个是一个相对较大的工程、效果较好，但是需要有大量人力去开发这种基础建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt; 6.6 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;线上运行阶段-接口拨测系列设计&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;接口拨测和巡检类似，就是服务上线后，每隔一个固定时间&lt;/span&gt;&lt;span&gt;（比如 5s）&lt;/span&gt;&lt;span&gt;调用后端的各种接口，如果接口异常则进行告警。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;针对接口拨测，一般也会有相关配套设施来提供相关的能力去实现。如果没有提供，那么开发者可以写一个接口拨测&lt;/span&gt;&lt;span&gt;（巡检）&lt;/span&gt;&lt;span&gt;的服务，定期去调用重要的接口。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;07&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;异常应急层面&lt;/span&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;22c42a3e001995a5fe055b1f9da620561&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;即使前面做了很多保障，也不一定招架住线上的各种异常情况。如果真出问题让系统的服务异常、无法提供服务，开发者还有最后一根救命稻草——那就是应急预案，将服务异常的损失降低到最小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;应急预案是需要开发者事先规划好，业务系统在各个层级出现问题后第一时间怎么恢复，并制定好相关规则和流程。当出现异常状况后可以按照既有的流程去执行。这样避免出现问题后手忙脚乱导致事态扩大。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5738304093567251&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94A1nPxrhKRfHPEzlH6viavKNiaGIVqDWqhvq9n7kzAFHbicaeiackt4vibqfF2GToF8ztRlxLTrzgSeAg/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;1368&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，我们整理出本文的思维导图如上，供各位参考。总体来说，我们从研发规范层面、应用服务层面、存储层面、产品层面、运维部署层面、异常应急层面这六大层面，剖析了一个高可用系统的架构设计需要有哪些关键的设计和考虑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上便是本次分享的全部内容，如果您觉得内容有用，欢迎点赞、收藏，把内容分享给更多开发者。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;-End-&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原创作者｜吴德宝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;技术责编｜吴德宝&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;腾小云福利来也&lt;/span&gt;&lt;span&gt;&lt;strong&gt;💐&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt; 扫码一键领取&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「腾讯云开发者-&lt;span&gt;春季限定红包封面」&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.894134477825465&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95sINOI2rjxOTmQzicLicmcnEIfJRWQ0IhtNDehLxC9wevtKbqlcMAoEPpCAvoyzTUfWX9Ugox3dlwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;最近微信改版啦，有粉丝反馈收不到小云的文章🥹。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;请关注「腾讯云开发者」并&lt;/span&gt;&lt;strong&gt;&lt;span&gt;点亮星标&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;周一三晚8点 和小云一起&lt;/span&gt;&lt;strong&gt;&lt;span&gt;涨(领)技(福)术(利)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6267029972752044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95sINOI2rjxOTmQzicLicmcnEyqWGx2ibs6ibGQslRkKl5PJibrPmbsYicLYZHRh3uSGGg5YYrQ1RAwkVXw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97ibOIthe2pvwt1H0HqX0HVJVFK9WPNQKNsibXynR5yT5S7b45uIpzN7xeZdeJIfOibPjOflZ35rKZyw/0?wx_fmt=png&quot; data-nickname=&quot;腾讯云开发者&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能感兴趣的腾讯工程师作品&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247590528&amp;amp;idx=1&amp;amp;sn=2cf6bbdb2d5a0f41810b63ece41ee667&amp;amp;chksm=eaa978d0dddef1c6fe009f3c890feec575c31782f11c313760f6f1ba7e78ef857b7625ed629e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;编程语言70年：谁是世界上最好的编程语言？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;编程语言70年：谁是世界上最好的编程语言？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247588095&amp;amp;idx=1&amp;amp;sn=4e68b4a7e5e719dc4c28396feca08f4c&amp;amp;chksm=eaa982afddde0bb92d5bffa73bce37fec0e64e4c79c3e4a46dd013bc3efe36f9de32d00e2db8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;腾讯工程师聊 ChatGPT 技术「文集」&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;腾讯工程师聊 ChatGPT 技术「文集」&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247591274&amp;amp;idx=1&amp;amp;sn=2b9cac5339190ffcc8e97cd135266d2e&amp;amp;chksm=eaa97f3adddef62c519b0589b69fadab26af560848cfdb289d93e805381be938bc1042040342&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一文揭秘微信游戏推荐系统&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一文揭秘微信游戏推荐系统&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247582311&amp;amp;idx=1&amp;amp;sn=33949a7d43a4b6c088f5c506222112fe&amp;amp;chksm=eaa99837ddde11214ec7e7c4ccfcb73435317dfda22702931ad946d185e44cc891414e8a71e5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信全文搜索耗时降94%？我们用了这种方案&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信全文搜索耗时降94%？我们用了这种方案&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247583332&amp;amp;idx=1&amp;amp;sn=646f9423bed5990f75c0d99e618c0fa6&amp;amp;chksm=eaa99c34ddde15228c45f00fa6e8d07de8097dfa4c0fb2ba448288748dec534165ac6538168e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10w单元格滚动卡顿如何解决？腾讯文档的7个秘笈&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;技术盲盒：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568617&amp;amp;idx=1&amp;amp;sn=d3409583764c4877964765a6b774b1de&amp;amp;chksm=eaa9d6b9ddde5faff511c416033948f76b056b209df76c6eb12adfea3f618422297b9b11895b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;前端&lt;/a&gt;&lt;span&gt;&lt;span&gt;｜&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568512&amp;amp;idx=1&amp;amp;sn=5a2e887c0ac511e9a4fe5cd68a388e48&amp;amp;chksm=eaa9d6d0ddde5fc6376f1ffcc6e7b050fefded23d5b24c5f7b801885f509df06cd53d99f0a45&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;后端&lt;/a&gt;&lt;span&gt;｜&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568656&amp;amp;idx=1&amp;amp;sn=98f7033418fc1fd7d019eeb18008b616&amp;amp;chksm=eaa9d740ddde5e56aa0b7df55dc2f70c65f329d37246453c2b3316356f3f84cc9f87eb6b8db4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AI与算法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;AI与算法&lt;/a&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568672&amp;amp;idx=1&amp;amp;sn=85e4b3e1c46289058398b216edb40941&amp;amp;chksm=eaa9d770ddde5e669cfaa25c37887ae058c433e4296ca04f8ff5373184bc76d4420f1d2049a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运维｜&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;运维&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568677&amp;amp;idx=1&amp;amp;sn=e95255553777c53d38cb1e64c1c16432&amp;amp;chksm=eaa9d775ddde5e633a75d20eb484181c0e03cb6f8237a4141c599e4f13ad3af6748c5e8d1a9a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;工程师文化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;工程师文化&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;57&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.1008174386920981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95sINOI2rjxOTmQzicLicmcnES7iaAAJVrAictePXDMc5vDBkhwdyzr0vGZkksm34icNiaQX3acwMyrsPLg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>