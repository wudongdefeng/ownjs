<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c26a8d7d3f39de00e119ac939641d26d</guid>
<title>7000 字 + 24 张图带你彻底弄懂线程池</title>
<link>https://toutiao.io/k/wci1eno</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今&lt;/span&gt;&lt;span&gt;天跟大家聊一聊无论是在工作中常用还是在面试中常问的线程池，通过画图的方式来彻底弄懂线程池的工作原理，以及在实际项目中该如何自定义适合业务的线程池。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KiaAtXn4qlrHpniaygT6eSzmXbyDLH618nCsALDrrDTgygrLDSbjQbX7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、什么是线程池&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池其实是一种池化的技术的实现，池化技术的核心思想其实就是实现资源的一个复用，避免资源的重复创建和销毁带来的性能开销。在线程池中，线程池可以管理一堆线程，让线程执行完任务之后不会进行销毁，而是继续去处理其它线程已经提交的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;线程池的好处:&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统 的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、线程池的构造&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中主要是通过构建ThreadPoolExecutor来创建线程池的，接下来我们看一下线程池是如何构造出来的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K3onOh1g6FAymrIxPmic6CBAvIpvO55lmkS22pVib2ZpwXLeqOcrxQqjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;线程池构造参数&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;corePoolSize：线程池中用来工作的核心的线程数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;maximumPoolSize：最大线程数，线程池允许创建的最大线程数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;keepAliveTime：超出 corePoolSize 后创建的线程存活时间或者是所有线程最大存活时间，取决于配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unit：keepAliveTime 的时间单位。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue：任务队列，是一个阻塞队列，当线程数已达到核心线程数，会将任务存储在阻塞队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadFactory ：线程池内部创建线程所用的工厂。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;handler：拒绝策略；当队列已满并且线程数量达到最大线程数量时，会调用该方法处理该任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的构造其实很简单，就是传入一堆参数，然后进行简单的赋值操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、线程池的运行原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完线程池的核心构造参数的意思，接下来就来画图讲解这些参数在线程池中是如何工作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池刚创建出来是什么样子呢，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81Kb9vibvUDicXicWcrp2bHSSf2ABL9icP5RwXOo1ZEHvOrQiaRmxviaoY2gmaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不错，刚创建出来的线程池中只有一个构造时传入的阻塞队列而已，此时里面并没有的任何线程，但是如果你想要在执行之前已经创建好核心线程数，可以调用prestartAllCoreThreads方法来实现，默认是没有线程的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有线程通过execute方法提交了一个任务，会发生什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提交任务的时候，其实会去进行任务的处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先会去判断当前线程池的线程数是否小于核心线程数，也就是线程池构造时传入的参数corePoolSize。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小于，那么就直接通过ThreadFactory创建一个线程来执行这个任务，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KHrALayTL6iaRic5VDzQqR49MiajicxyObRRlUNaQrSibicEodOLz71y38xEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当任务执行完之后，线程不会退出，而是会去从阻塞队列中获取任务，如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KRPQfiaggkqd0kdK03lSicSORDZGicucSHTia6C2ERicpjs1ZMc44sk6Ria5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来如果又提交了一个任务，也会按照上述的步骤，去判断是否小于核心线程数，如果小于，还是会创建线程来执行任务，执行完之后也会从阻塞队列中获取任务。这里有个细节，就是提交任务的时候，就算有线程池里的线程从阻塞队列中获取不到任务，如果线程池里的线程数还是小于核心线程数，那么依然会继续创建线程，而不是复用已有的线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程池里的线程数不再小于核心线程数呢？那么此时就会尝试将任务放入阻塞队列中，入队成功之后，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K2VHgKPbCle00a5Rtd1YQO0F91zfMObqDlwtEichdMke0h5vcypfibt7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在阻塞的线程就可以获取到任务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，随着任务越来越多，队列已经满了，任务放入失败了，那怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会判断当前线程池里的线程数是否小于最大线程数，也就是入参时的maximumPoolSize参数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小于最大线程数，那么也会创建非核心线程来执行提交的任务，如图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KXzMC4icCxL1el2BACmZjaczviblw14e8nqst7bNgwWHrBmj8iaIvibmwzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，从这里可以发现，就算队列中有任务，新创建的线程还是优先处理这个提交的任务，而不是从队列中获取已有的任务执行，从这可以看出，先提交的任务不一定先执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不幸的事发生了，线程数已经达到了最大线程数量，那么此时会怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会执行拒绝策略，也就是构造线程池的时候，传入的RejectedExecutionHandler对象，来处理这个任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KYGsUbGUZAgddrd1tIJBuqVk5R01Hj9me9DicRiczvIZATdg6eSL00Kng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RejectedExecutionHandler的实现JDK自带的默认有4种&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AbortPolicy：丢弃任务，抛出运行时异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CallerRunsPolicy：由提交任务的线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardPolicy：丢弃这个任务，但是不抛异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DiscardOldestPolicy：从队列中剔除最先进入队列的任务，然后再次提交任务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池创建的时候，如果不指定拒绝策略就默认是AbortPolicy策略。当然，你也可以自己实现RejectedExecutionHandler接口，比如将任务存在数据库或者缓存中，这样就数据库或者缓存中获取到被拒绝掉的任务了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，我们发现，线程池构造的几个参数corePoolSize、maximumPoolSize、workQueue、threadFactory、handler我们都在上述的执行过程中讲到了，那么还差两个参数keepAliveTime和unit(unit是keepAliveTime的时间单位)没讲到，所以keepAliveTime是如何起到作用的呢，这个问题留到后面分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完整个执行的流程，接下来看看execute方法代码是如何实现的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6929637526652452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81K4evIFBoAWppW6IWCzicaXyWoHqIK1FzFJrj0omxAeqoDeOocC9BMcBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;figcaption&gt;execute方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;workerCountOf(c)&amp;lt;corePoolSize:这行代码就是判断是否小于核心线程数，是的话就通过addWorker方法，addWorker就是添加线程来执行任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;workQueue.offer(command)：这行代码就表示尝试往阻塞队列中添加任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加失败之后就会再次调用addWorker方法尝试添加非核心线程来执行任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果还是添加非核心线程失败了，那么就会调用reject(command)来拒绝这个任务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后再来另画一张图总结execute执行流程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44260599793174765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KCk0zdyVzdeP0pJjbpfibx3SA62GGvKia9nENGK6hvemYicxE85ia23bESw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1934&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、线程池中线程实现复用的原理&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的核心功能就是实现了线程的重复利用，那么线程池是如何实现线程的复用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在线程池内部其实是被封装成一个Worker对象&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3087431693989071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KdmccmWh5wSdVEkbA88GH17YLpwdGkh7FOibxicTSib3Q4A34tuZsTbNEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker继承了AQS，也就是有一定锁的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建线程来执行任务的方法上面提到是通过addWorker方法创建的。在创建Worker对象的时候，会把线程和任务一起封装到Worker内部，然后调用runWorker方法来让线程执行任务，接下来我们就来看一下runWorker方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KiapoGLicgicX4QQJA0eoEkS9S0ibFL72HvvVx6koZruGYRoT5TwlVNErWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;启动线程处理任务&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这张图可以看出线程执行完任务不会退出的原因，runWorker内部使用了while死循环，当第一个任务执行完之后，会不断地通过getTask方法获取任务，只要能获取到任务，就会调用run方法，继续执行任务，这就是线程能够复用的主要原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果从getTask获取不到方法的时候，最后就会调用finally中的processWorkerExit方法，来将线程退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个一个细节就是，因为Worker继承了AQS，每次在执行任务之前都会调用Worker的lock方法，执行完任务之后，会调用unlock方法，这样做的目的就可以通过Woker的加锁状态就能判断出当前线程是否正在运行任务。如果想知道线程是否正在运行任务，只需要调用Woker的tryLock方法，根据是否加锁成功就能判断，加锁成功说明当前线程没有加锁，也就没有执行任务了，在调用shutdown方法关闭线程池的时候，就用这种方式来判断线程有没有在执行任务，如果没有的话，来尝试打断没有执行任务的线程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、线程是如何获取任务的以及如何实现超时的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一节我们说到，线程在执行完任务之后，会继续从getTask方法中获取任务，获取不到就会退出。接下来我们就来看一看getTask方法的实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3657407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KTrAJwcbAkdFbibMJhC8yvxFkib7HSnF9QYsGXH1fjevhMHDY7SnbhBHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;getTask方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;getTask方法，前面就是线程池的一些状态的判断，这里有一行代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;boolean&lt;/span&gt; timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这行代码是判断，当前过来获取任务的线程是否可以超时退出。如果allowCoreThreadTimeOut设置为true或者线程池当前的线程数大于核心线程数，也就是corePoolSize，那么该获取任务的线程就可以超时退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那是怎么做到超时退出呢，就是这行核心代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runnable r = timed ?&lt;br/&gt;                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :&lt;br/&gt;                    workQueue.take();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会根据是否允许超时来选择调用阻塞队列workQueue的poll方法或者take方法。如果允许超时，则会调用poll方法，传入keepAliveTime，也就是构造线程池时传入的空闲时间，这个方法的意思就是从队列中阻塞keepAliveTime时间来获取任务，获取不到就会返回null；如果不允许超时，就会调用take方法，这个方法会一直阻塞获取任务，直到从队列中获取到任务位置。从这里可以看到keepAliveTime是如何使用的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以到这里应该就知道线程池中的线程为什么可以做到空闲一定时间就退出了吧。其实最主要的是利用了阻塞队列的poll方法的实现，这个方法可以指定超时时间，一旦线程达到了keepAliveTime还没有获取到任务，那么就会返回null，上一小节提到，getTask方法返回null，线程就会退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里也有一个细节，就是判断当前获取任务的线程是否可以超时退出的时候，如果将allowCoreThreadTimeOut设置为true，那么所有线程走到这个timed都是true，那么所有的线程，包括核心线程都可以做到超时退出。如果你的线程池需要将核心线程超时退出，那么可以通过allowCoreThreadTimeOut方法将allowCoreThreadTimeOut变量设置为true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个getTask方法以及线程超时退出的机制如图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35648148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KIblH3TF7bj9zMNUAFY5jGqFAsicicqywJWoLv3IcwghnXEBKyRW26pibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、线程池的5种状态&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池内部有5个常量来代表线程池的五种状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3170731707317073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KW510Iw1rnDHl1jYqPDSMpgHEoLNJC7d5hSTn9WVJo7nibHuFSGqCvFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RUNNING：线程池创建时就是这个状态，能够接收新任务，以及对已添加的任务进行处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SHUTDOWN：调用shutdown方法线程池就会转换成SHUTDOWN状态，此时线程池不再接收新任务，但能继续处理已添加的任务到队列中任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STOP：调用shutdownNow方法线程池就会转换成STOP状态，不接收新任务，也不能继续处理已添加的任务到队列中任务，并且会尝试中断正在处理的任务的线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TIDYING：SHUTDOWN 状态下，任务数为 0， 其他所有任务已终止，线程池会变为 TIDYING 状态。线程池在 SHUTDOWN 状态，任务队列为空且执行中任务为空，线程池会变为 TIDYING 状态。线程池在 STOP 状态，线程池中执行中任务为空时，线程池会变为 TIDYING 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TERMINATED：线程池彻底终止。线程池在 TIDYING 状态执行完 terminated() 方法就会转变为 TERMINATED 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池状态具体是存在ctl成员变量中，ctl中不仅存储了线程池的状态还存储了当前线程池中线程数的大小&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; AtomicInteger ctl = &lt;span&gt;new&lt;/span&gt; AtomicInteger(ctlOf(RUNNING, &lt;span&gt;0&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后画个图来总结一下这5种状态的流转&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2722222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KgibgzrJZtkLialiafKje4N0dOtgmp1AtLsnicE90uH7ic7UfLDiawrhYcy8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在线程池运行过程中，绝大多数操作执行前都得判断当前线程池处于哪种状态，再来决定是否继续执行该操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、线程池的关闭&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池提供了shutdown和shutdownNow两个方法来关闭线程池。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KqCo9wXsHWt0CIDvNIpXzBwUzHQrohec7ADVrGpKbgBq7lXnh0k4JGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;shutdown方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是将线程池的状态修改为SHUTDOWN，然后尝试打断空闲的线程（如何判断空闲，上面在说Worker继承AQS的时候说过），也就是在阻塞等待任务的线程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7700892857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KBCDvL1HiaLoQ1ZE8jM8HicTMxlSo8noCXSulOt0QEQMXFMzDneDOmtfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;896&quot;/&gt;&lt;figcaption&gt;shutdownNow方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是将线程池的状态修改为STOP，然后尝试打断所有的线程，从阻塞队列中移除剩余的任务，这也是为什么shutdownNow不能执行剩余任务的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以也可以看出shutdown方法和shutdownNow方法的主要区别就是，shutdown之后还能处理在队列中的任务，shutdownNow直接就将任务从队列中移除，线程池里的线程就不再处理了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、线程池的监控&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中使用线程池的时候，一般需要对线程池进行监控，方便出问题的时候进行查看。线程池本身提供了一些方法来获取线程池的运行状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;getCompletedTaskCount：已经执行完成的任务数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getLargestPoolSize：线程池里曾经创建过的最大的线程数量。这个主要是用来判断线程是否满过。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getActiveCount：获取正在执行任务的线程数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getPoolSize：获取当前线程池中线程数量的大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了线程池提供的上述已经实现的方法，同时线程池也预留了很多扩展方法。比如在runWorker方法里面，在执行任务之前会回调beforeExecute方法，执行任务之后会回调afterExecute方法，而这些方法默认都是空实现，你可以自己继承ThreadPoolExecutor来扩展重写这些方法，来实现自己想要的功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;九、Executors构建线程池以及问题分析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK内部提供了Executors这个工具类，来快速的创建线程池。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;固定线程数量的线程池：核心线程数与最大线程数相等&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KdCSrsBY12gD3eyZhJ0g8OAoAkhSMNLJT4RicxqQGUADmUXDhEYCMgGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;单个线程数量的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24259259259259258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KXa0d9f7aLOCUOeGvzvl4ZpBxpMyVPC4jcGic6U7hcoKnzhQTgfyLN8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接近无限大线程数量的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KqicV1fPTzz7sjCczxe6yOCaxx2yg5k0Jsw5c3zaIFIZMj6mmXA3moBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带定时调度功能的线程池&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14351851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/B279WL06QYx1otOsqTzCrXnesWzhE81KFRVMcibq0n9OqlGBYp5CqKxEibeynbZIG1lFLe6QNyQE882NtNOibYbIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然JDK提供了快速创建线程池的方法，但是其实不推荐使用Executors来创建线程池，因为从上面构造线程池可以看出，newFixedThreadPool线程池，由于使用了LinkedBlockingQueue，队列的容量默认是无限大，实际使用中出现任务过多时会导致内存溢出；newCachedThreadPool线程池由于核心线程数无限大，当任务过多的时候，会导致创建大量的线程，可能机器负载过高，可能会导致服务宕机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十、线程池的使用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java程序中，其实经常需要用到多线程来处理一些业务，但是不建议单纯使用继承Thread或者实现Runnable接口的方式来创建线程，那样就会导致频繁创建及销毁线程，同时创建过多的线程也可能引发资源耗尽的风险。所以在这种情况下，使用线程池是一种更合理的选择，方便管理任务，实现了线程的重复利用。所以线程池一般适合那种需要异步或者多线程处理任务的场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;十一、实际项目中如何合理的自定义线程池&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面分析提到，通过Executors这个工具类来创建的线程池其实都无法满足实际的使用场景，那么在实际的项目中，到底该如何构造线程池呢，该如何合理的设置参数？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）线程数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程数的设置主要取决于业务是IO密集型还是CPU密集型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU密集型指的是任务主要使用来进行大量的计算，没有什么导致线程阻塞。一般这种场景的线程数设置为CPU核心数+1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IO密集型：当执行任务需要大量的io，比如磁盘io，网络io，可能会存在大量的阻塞，所以在IO密集型任务中使用多线程可以大大地加速任务的处理。一般线程数设置为 2*CPU核心数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java中用来获取CPU核心数的方法是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）线程工厂&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般建议自定义线程工厂，构建线程的时候设置线程的名称，这样就在查日志的时候就方便知道是哪个线程执行的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）有界队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般需要设置有界队列的大小，比如LinkedBlockingQueue在构造的时候就可以传入参数，来限制队列中任务数据的大小，这样就不会因为无限往队列中扔任务导致系统的oom。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&amp;amp;mid=2247489003&amp;amp;idx=1&amp;amp;sn=69bf19d900079e204e36df58525654bf&amp;amp;chksm=e80da39ddf7a2a8bf0765f9b95f359a3944fc40c4a192bb3fe9adedfbcd0070cd27234bcf6b3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java面试题宝典&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java面试题宝典&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&amp;amp;mid=2247520066&amp;amp;idx=2&amp;amp;sn=93829640d3c1f3d4cfbd484992acaa7f&amp;amp;chksm=ebd5b06edca23978edf99b195b0435573a32a10bd05bd3466d040e8a391c8dc5a908786199ef&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术内卷群，一起来学习！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;技术内卷群，一起来学习！！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;205&quot; data-backw=&quot;562&quot; data-fileid=&quot;100031039&quot; data-ratio=&quot;0.3648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufRcZPYBUx7WxAoIjibsF645yGLZqfGCEn9x73bnkBLibx6TAGMpmMyib0aXeRHZsJoHBmwVQ6YIVGtw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PS：因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“在看”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“星标”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持我们吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/eQPyBffYbueDSXLVgW7uSn469hPOKJnGTmQmtLKG8keHicav0sXf33ZCoJicbyug9QIUBwL2ayokpGRy7FvuIMPA/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbb8d4eff7b7c37548ca758e17ced27c</guid>
<title>Paxos 为什么可以保证整体一致性？</title>
<link>https://toutiao.io/k/2uyzcee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;微信公众号：&lt;strong&gt;并发笔记&lt;/strong&gt;&lt;br/&gt;关注可了解更多的共识算法相关内容。如有问题或建议，请公众号留言;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31322207958921694&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxt327ybUOVMLP1nP3Znl3NL4Fv62PTDFYQQAL1T2YIkHaicymHQJLooUl7UrFCbibgibO5Flsl94amr8SCzHAujg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/p&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;GiJA10yu&quot;&gt;&lt;/p&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;GiJA10yu&quot;&gt;要回答这个问题，先要了解以下几个问题&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;共识和一致性有什么区别？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;怎么理解多数派？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么只需要多数派支持，就算达成共识？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Paxos如何处理读请求？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;纠正题目中的歧义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;共识和一致性有什么区别？&lt;/h2&gt;&lt;p data-pid=&quot;GR1UEqml&quot;&gt;Paxos是一个Consensus Algorithm。国内很多文章将Consensus翻译为“一致性”，从中文理解上没有什么问题，口语中，我们也会常把“共识”和“一致性”交替使用。例如，“去云南旅游达成共识了”和“去云南旅游达成一致了”，这两句表达的是同一个意思。但是在计算机的分布式环境中，这两个词略有差别。&lt;/p&gt;&lt;p data-pid=&quot;ooq5fc1q&quot;&gt;一致，是指各个副本之间的数据100%保持相同的状态，例如CAP中的C，就是指100%的一致性，CA之间权衡，指每个成员的数据都是一致的。C和A之间权衡，就是一个调节（0~100%）强度的哲学问题。详细可以参考：&lt;/p&gt;&lt;p data-pid=&quot;ooq5fc1q&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MDE2NDkwMQ==&amp;amp;mid=2247483938&amp;amp;idx=1&amp;amp;sn=923bb563090e275e5465e1aca459e373&amp;amp;chksm=ce2bc468f95c4d7ee018b356b3da1298d0ab1570a003ffd4279486687605ae3a7379f1e704b3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全网对CAP最深层的思考&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全网对CAP最深层的思考&lt;/a&gt;&lt;/p&gt;&lt;p data-pid=&quot;bKIQIfht&quot;&gt;共识，是指从外部观察者（客户端）看来，系统内部的数据是保持一致的，无论访问哪个副本都能获得相同的数据，而系统内部的真实情况，可能不是100%保持一致的。所以Paxos算法翻译为“共识算法”更为合适。&lt;/p&gt;&lt;h2&gt;怎么多数派的理解？&lt;/h2&gt;&lt;p data-pid=&quot;gCsJ2vVX&quot;&gt;一个共识算法，除了保证算法的正确性之外，容错性也是必不可少的，Paxos同样也不例外。为了实现高容错性，Paxos允许少数的成员发生故障，在抉择一个提案是否达成共识时，只需要多数派成员支持即可。&lt;/p&gt;&lt;h2&gt;为什么只需要多数派支持，就算达成共识？&lt;/h2&gt;&lt;p data-pid=&quot;PXmpbNDO&quot;&gt;Paxos算法分为两个阶段，Prepare阶段和Accept阶段。，Prepare阶段用于争取本轮发起协商的所有权，和获取上一轮协商可能达成共识的提案。所以我们也可以认为Prepare阶段认为是读阶段，Accept阶段认为是写阶段。&lt;/p&gt;&lt;p data-pid=&quot;ktWFg1OF&quot;&gt;为了保证已达成共识的提案不再改变，当读阶段获取到有可能达成共识的提案后，写阶段只能用该提案发起协商。而两个互不相干的阶段，能够交换信息，必须要有通信的媒介，这个通信的媒介源于“多数派”。因为“多数派思想”能够保证任何两个多数派集合相交，那么这个相交的副本就是通信的媒介，我们只需要控制相交的副本所以支持提案的规则（当然，所有副本都可能是相交的副本），就能让读阶段获取到上一轮写阶段可能达成共识的提案，延续这个可能达成共识的提案，在本轮也只能提出该提案，那么就能保证已达成共识的提案不再改变。&lt;/p&gt;&lt;h2&gt;Paxos如何处理读请求？&lt;/h2&gt;&lt;p data-pid=&quot;BAJzyfee&quot;&gt;Paxos只需要多数派支持即可，因此每个成员之间的数据是不一致的，但一定存在一个多数派拥有一致的数据。&lt;/p&gt;&lt;p data-pid=&quot;gUksvtJB&quot;&gt;因此Paxos处理读请求，通常需要再运行一轮Paxos，通过Prepare阶段获取是否有多数派对某个提案达成共识了。&lt;/p&gt;&lt;p data-pid=&quot;gLhsbdPb&quot;&gt;当然每次读请求都运行一轮Paxos，这个效率是非常慢的，所以在行业内也有一个优化方案，例如增加一轮confirm请求，为已达成共识的提案记录confirm日志。&lt;/p&gt;&lt;h2&gt;纠正题目中的歧义&lt;/h2&gt;&lt;p data-pid=&quot;QgP8D3O_&quot;&gt;Leaner如何获取达成共识的提案？通常有两个方案，最常用的是第2种，第1种效率不高，且Learner要求一定的计算能力。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Acceptor收到Accept请求后，接受该请求后，将Accept请求转发给所有的Learner，Learner需要自己判断某个提案是否有多数派支持该提案。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Proposer收到多数派Acceptor支持Accept请求后，则知道该提案已经达成共识了，那么将该提案发送给Learner。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da3dc74dc89f09d9c604bf374602cbea</guid>
<title>从 0 到 1 智能风控决策引擎构建</title>
<link>https://toutiao.io/k/z948l4u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;h2&gt;引言&lt;/h2&gt;&lt;p&gt;互联网时代，万物互联，网络安全形势越来越严峻，安全是企业的基石，风控在企业中扮演着“警察”角色，运用各种技术和手段，保护企业内的用户利益不受侵害。&lt;/p&gt;&lt;p&gt;风控决策引是风控中台的入口，提供业务风险场景事件接入，可视化编排复杂决策，丰富的特征变量与场景识别服务等功能。相较于需要开发背景及算法背景才能使用的传统风控引擎，本文介绍的决策引擎构建完成后无需开发背景甚至无需算法建模背景，作为纯正的策略运营即可配置应用到业务的决策中，实时对抗黑产。&lt;/p&gt;&lt;h2&gt;决策引擎分解&lt;/h2&gt;&lt;h3&gt;风险事件&lt;/h3&gt;&lt;p&gt;风险事件对应一个风险领域，是针对特定业务事件领域的具体抽象，以方便策略运营人员管理领域下对抗规则使用的。&lt;/p&gt;&lt;p&gt;举例：假设要对裂变类营销场景防控，如分享当前内容到朋友圈即可获得 88 元精美礼品一份，那么风险领域可以大致划分为发起分享（发起频率/作弊）、接受分享（同人/群组/频率）、分享后领奖（频率/群组/归因群组），每一步对应的被风险特征不同，需要专有的策略部署防控。&lt;/p&gt;&lt;h3&gt;决策流&lt;/h3&gt;&lt;p&gt;如上，风控团队人员和业务团队人员充分沟通后，大致已经知道了业务玩法的风险点，即可以明确划分出“风险事件”。那么如何高效且稳定的去管理当前领域下的风险对抗策略，是对风控研发的一大挑战。&lt;/p&gt;&lt;p&gt;策略运营人员为了对抗黑产，每时每刻都需要变更防控手段，且时效性要高，即期望立即生效。那如何能够让生产改动安全且高效的部署到线上？早期团队为了快速迭代，使用 XML 模式更改，好处是扩展性高，坏处显而易见：只能研发代替策略人员修改决策流配置，策略人员不理解或者根本不太敢动 XML “代码”。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; encoding&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt; standalone&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;no&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;process&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;p001&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;×××&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;start&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;condition&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;split01&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/start&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;split&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;split01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;×××&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;condition&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;0&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;REJECT&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;expr&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;1 != 1&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;end01&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;&amp;lt;condition&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;10&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;ACCEPT&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;split02&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;/split&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&amp;lt;end&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;end01&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;desc&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;×××&quot;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;assemble&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;×××&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/process&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;随着团队的扩大，有了专业的 UED 和前端开发小伙伴加入，可以支撑我们在视觉和操作上下功夫，参照业内的 BPMN 2.0 工作流设计规范，将枯燥复杂的 XML 代码 转换为&lt;strong&gt;决策流编排&lt;/strong&gt;配置模式，大大增加了策略运营人员的对抗效率，也解放了后端研发人员，不用再去抠 XML 代码了而担心出错了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQo69IZ2Or8icrPfttkGHic6hqh6iaLYUVRyQMqHZ8gChrkOTlFDG3wG4PxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;1.策略组&lt;/h4&gt;&lt;p&gt;“&lt;strong&gt;策略节点&lt;/strong&gt;”是决策流程上最重要的一个节点，内部关联了大量的对抗黑产的规则，其中涉及了各个规则如何协作，决策结果如何输出等职责。在和黑产的对抗过程中，先辈们总结出了一套模式来快速部署规则，效果最大化的对抗黑产，同时也不会“误杀”好的用户。&lt;/p&gt;&lt;h4&gt;1.1.策略模式&lt;/h4&gt;&lt;p&gt;策略总共分成两种模式：评分卡、最坏匹配，如下我将详细为你介绍各个模式如何运作以及适合的场景。&lt;/p&gt;&lt;h4&gt;评分卡&lt;/h4&gt;&lt;p&gt;此处的评分卡并非指数据模型评分卡，而是&lt;strong&gt;专家评分卡&lt;/strong&gt;，通俗一点讲就是依据专家经验，对命中不同规则加权得分，如果最终得分命中了拒绝区间分段，则需要拒绝。此类模式，对于早期缺少用户“黑标”，直接依赖专家经验，是一个不错的选择。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16355653128430298&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQoGtwc4Tgz4I8EiasB5R8uxibOvF8Th6Df4xqLDX9mGwqCSYdWO9FL2RicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;评分卡是一个概率学问题，越黑的用户会命中越多的规则，所得的分就越多，即表明风险越高。举例：黑产为了对抗风控，会找大量的代理 IP 或者修改 GPS 定位来扰乱风控系统检测，同时也有“猫池”等设备提供海量手就号。但是当下有不少正常用户都有 2 台手机，且因为工作原因，频繁多地飞行，即&lt;strong&gt;地理位置不停地变换&lt;/strong&gt;，那么策略人员制定好的评分规则如下：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;序号&lt;/td&gt;&lt;td&gt;规则&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;是否异地&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;是否多设备登录&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;所有登录设备去重数大于等于 4&lt;/td&gt;&lt;td&gt;20&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;切换不同登录设备速度过快&lt;/td&gt;&lt;td&gt;30&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;账户提现异动&lt;/td&gt;&lt;td&gt;40&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;评分区间如下&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;通过&lt;/td&gt;&lt;td&gt;人审&lt;/td&gt;&lt;td&gt;拒绝&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;[0, 20]&lt;/td&gt;&lt;td&gt;(20, 40]&lt;/td&gt;&lt;td&gt;(40,∞]&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，正常的用户只会命中 0，有多个设备的用户（2 到 3 个）基本上得分在 20，也不会造成打扰。切正常的用户就算频繁的出行各城市直接，也不会说上一秒在上海，下一秒在广州了，对抗黑产还是有迹可寻的！&lt;/p&gt;&lt;h4&gt;最坏匹配&lt;/h4&gt;&lt;p&gt;“最坏匹配”有点类似于流处理概念中的 &lt;code&gt;anyMatch&lt;/code&gt;，即只要有任何规则命中，则立即拒绝。此种模式内包含的规则属于非常确定，一定是可解释的，如果命中，基本可以断定拒绝本次请求的。如：同一设备既发起邀请又接受邀请，属于同人诈骗，明显不符合活动规则，则可立即拒绝的。&lt;/p&gt;&lt;p&gt;选择最坏匹配模式要慎重，它是专家经验的凝聚，一定是在生产环境多次验证，召回和准确率较高，不会出现“误杀”的情况，否则会遭遇大量被误拒的客户客诉，严重甚至阻碍业务发展，品牌价值极大损坏。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQozlicWcuwllnnHaa5oRdKPC1yEoLVMVwFghJ9nibbP8svddxpZNEhBK4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;1.2.策略装配&lt;/h4&gt;&lt;p&gt;策略是当前风险场景下某个风险点的抽象，举例：在邀请风险场景下，可以有设备策略、手机号策略、群组策略等，策略包下是一个个规则，负责管理规则的生命周期。&lt;/p&gt;&lt;h4&gt;规则&lt;/h4&gt;&lt;p&gt;规则是风控决策流中最小“原子”单位，规则的构成如下：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;左值&lt;/td&gt;&lt;td&gt;比较符&lt;/td&gt;&lt;td&gt;右值&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;变量（又叫特征，指标等）&lt;/td&gt;&lt;td&gt;&amp;gt;, &amp;lt;, =, &amp;gt;=, &amp;lt;=, 包含, 属于...&lt;/td&gt;&lt;td&gt;常量/变量&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;举例：在设备策略包中包含如下规则：所有登录设备去重数大于等于 4，则对照如下&lt;/p&gt;&lt;h4&gt;规则组&lt;/h4&gt;&lt;p&gt;单一的规则命中可能对用户的干扰度比较大，此时需要联合规则判定，即规则组，规则组可以编排&lt;strong&gt;与或计算&lt;/strong&gt;逻辑：满足所有、满足一条、自定义，其中自定义支持复杂的条件表达式 &lt;code&gt;1 || (2 &amp;amp;&amp;amp; 3) || 4&lt;/code&gt;，满足不同规则组合需求。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4312393887945671&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQofb7rDOVoryOyKB2Dpo6YKvo1Fs4F0oJ4vlJ2PiauWIyGPkN7I3pLHNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;589&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;2.名单&lt;/h4&gt;&lt;p&gt;“名单节点”是决策流内一大重要功能，同时也是最危险的防御动作之一。&lt;/p&gt;&lt;p&gt;为什么需要名单？假设你是一个黑户，如果没有名单，每次都需要执行一遍决策流，这是对计算和成本的极大浪费，那么此时为了提升性能及成本考虑，直接将你打标拉黑，此时在决策流入口编排新增一个名单节点，你可简单理解为这是一个超大的“缓存”模块，那么加黑的用户会直接拒绝，而不需要再往下跑决策流，同理，判定为高价值低风险好的用户，也可直接加白，立即通过，无需等待，只有真正的纯新用户或“摇摆”的客户，才需要跑决策流判断风险。&lt;/p&gt;&lt;p&gt;黑白名单简单粗暴很好用，简单粗暴意味着容易出现问题，一不留神就会把自己“坑死”，一次随意添加黑名单数据可能会直接侵害大部分的正常用户，同样的，白名单的随意添加直接可能为恶意用户打开便捷之门。&lt;/p&gt;&lt;p&gt;那么这些名单是如何产生的？&lt;/p&gt;&lt;h4&gt;黑名单&lt;/h4&gt;&lt;p&gt;从历史的恶意数据中提取，设备、手机号、IP 等。同时结合第三方合作伙伴，共建黑名单库（毕竟人家已经沉淀很久了）。&lt;/p&gt;&lt;h4&gt;白名单&lt;/h4&gt;&lt;p&gt;最简单粗暴的手段就是看价值和风险四象限，高价值低风险的用户一定是我们的目标客户（非绝对，也可伪装），此时可以给这部分用户直接加白。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6971677559912854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQogR41gr6GbiafDR90T1aJHCOHH7jNTkYOLfduHibEq3eOcxkcnVy5TT2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;名单一定是有时效的，且名单内部一定是有壁垒的，可以理解为领域隔离，如何理解？即这个用户在当前场景是坏得，但是在别的场景又是好的，那么此时只需要在当前的细分领域隔离拉黑即可。时效性是为了解决那种懂得养号黑产，或者一开始伪装成高价值的黑产用户，风控程序需要定时去梳理重新计算哪些用户是可以加白加黑的，做到赏罚分明，尽量&lt;/span&gt;&lt;strong&gt;不冤枉&lt;/strong&gt;&lt;span&gt;、&lt;/span&gt;&lt;strong&gt;不溺爱&lt;/strong&gt;&lt;span&gt;任何人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;3.分支&lt;/h4&gt;&lt;p&gt;决策流图需要“分支节点”来导流，数据节点（开始、名单、策略节点都算是数据节点）负责吐出计算后的数据，分支节点拿到数据后，依据条件表达式，导流到相应的后续节点。&lt;/p&gt;&lt;p&gt;决策流在走到分支节点后，依据分支上的条件排序，分别执行条件表达式，只要有一条满足条件，则往下执行。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7753623188405797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQo6QLuTjIsGwp0JqV0QP61fkPE8Xic0SdvfClGTRdRNx4tI54rzicz9nOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h4&gt;4.Fork/Join&lt;/h4&gt;&lt;p&gt;Fork &amp;amp; Join 是决策流编排中的高级概念节点，决策流实际上就是一个庞大的 DAG（有向无环图），如果每个路径都同步去执行一遍，太耗费时间，业务方留给风控决策的时间不会超过 200ms，但风控有涉及到大量的计算和 I/O 操作，此时可以配置 Fork/Join 节点并发执行流程再聚和，缩短路径时间。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39672003123779775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VaAN3q859ykI7m34EYakGv7WRYWq4wQoicO50Fxz23gYwMtLJlMsp45BumTZrUrOBrvSxy3ACz8bSft6GTk2bDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2561&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;决策流性能优化非常有挑战，这只是一个小的优化点，限于篇幅，后续会专门开一篇性能优化具体介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;稳定性&lt;/h2&gt;&lt;p&gt;稳定性老生常谈了，何况是能掌握“&lt;strong&gt;生杀&lt;/strong&gt;”大全的风控系统。风控对系统的稳定性建设高于策略的执行，即兜底策略是通过，在不影响正常用户体验的情况下，允许漏过一部分黑的用户进去，我们可以有多种手段在事后将黑户捞出来封禁（前提是离线响应足够快，各系统配合足够好，本身黑产是非常高效的）。&lt;/p&gt;&lt;h3&gt;极致性能&lt;/h3&gt;&lt;p&gt;业务留给风控策略执行的时间不会超过 200 ms，在短短的 200 ms 内风控要处理大量的计算逻辑，这是相悖的。&lt;/p&gt;&lt;p&gt;风控是我见过为数不多真正将并发实际用“飞起来”的系统，为了节省时间，大量的并行计算带超时设计，&lt;strong&gt;以空间换时间思想运用到了极致&lt;/strong&gt;，提前算好放在那，等待决策的时候直接内存计算即可。对于风控研发来说最难的就是要考虑当前的实现是否能不高于超时时间，有较大的技术挑战。&lt;/p&gt;&lt;h3&gt;灰度支持：策略运营友好&lt;/h3&gt;&lt;p&gt;策略的上线是一个“高危”动作，如果运营在线下分析出错，那么可能导致生产大量好的用户被拦截，造成大量的客诉，这损失是惨重的，所以决策流在设计之初就应该要考虑新版本灰度上线等功能的支持，可以按照 0-100 流量逐步放量，将损失降至最小。&lt;/p&gt;&lt;h3&gt;回滚降级&lt;/h3&gt;&lt;p&gt;在出现生产问题时，优先观测当前有哪些生产变更，如果是决策流变更，需要支持&lt;strong&gt;版本回滚&lt;/strong&gt;功能，确保第一时间能恢复问题。&lt;/p&gt;&lt;p&gt;针对大促或者大流量突刺进来时，需要依据特定的风险场景进行&lt;strong&gt;限流/熔断&lt;/strong&gt;功能，参照业内开源的 sentinel 制定一整套防崩模式，确保系统稳定。&lt;/p&gt;&lt;h3&gt;异动监控&lt;/h3&gt;&lt;p&gt;监控是老生常谈了，但是真的很重要！试想如果不对某个场景下决策的拒绝结果做监控，万一线上因为某个改动导致大量拒绝，用户无法正常往下走，想想都很可怕！&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;决策引擎是风控的大脑，风控能够高效的和黑产对抗，决策引擎是门面担当。&lt;/p&gt;&lt;p&gt;目前决策引擎是配置化编排，正在想智能、自动化的方向构建，帮助业务人员更好的部署规则和提效。同时我们也在思考，如何让业务能够快速，“无感知”的，或者尽量少侵入（低成本）的接入风控，也是一个挑战。黑产也是人，他们也在对抗中进化，会有越来越多的新式手段来挑战风控安全的壁垒，任重而道远！&lt;/p&gt;&lt;h3&gt;往期精彩&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTIwNjY3MA==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=857c2fa9e3514e2da0d0a7298dfa7f7a&amp;amp;scene=21#wechat_redirect&quot; title=&quot;性能优化必备——火焰图&quot; data-linktype=&quot;2&quot;&gt;性能优化必备——火焰图&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTIwNjY3MA==&amp;amp;mid=2247483745&amp;amp;idx=1&amp;amp;sn=e10bec68e51a8dca226cacce9a5258d5&amp;amp;scene=21#wechat_redirect&quot; title=&quot;我是怎么入行做风控的&quot; data-linktype=&quot;2&quot;&gt;我是怎么入行做风控的&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Flink 在风控场景实时特征落地实战&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;欢迎关注公众号：咕咕鸡技术专栏&lt;/p&gt;&lt;p&gt;个人技术博客：https://jifuwei.github.io/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; Flink 在风控场景实时特征落地实战: &lt;em&gt;https://jifuwei.github.io/yuque/Flink%20%E5%9C%A8%E9%A3%8E%E6%8E%A7%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%97%B6%E7%89%B9%E5%BE%81%E8%90%BD%E5%9C%B0%E5%AE%9E%E6%88%98.html&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>08b2c80709b740722b8f9d1705753582</guid>
<title>聊聊如何度过寒冬（公司篇）</title>
<link>https://toutiao.io/k/hqw8tto</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;G哥要给winter is coming找证据的话，实在太多了。&lt;/p&gt;&lt;p&gt;从任正非先生的“把寒气传递给每一个人”，到&lt;span&gt;Shopee前一段的招聘毁约事件。（&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxMzEzMjM5NQ==&amp;amp;mid=2651066443&amp;amp;idx=1&amp;amp;sn=7a34d8bb7bb42e6eae6d8281ec561a20&amp;amp;chksm=8c4bc54fbb3c4c59515ce330c55c624829270d4208c9519cd9f23e35df6818f2794162c64c8c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;把寒气传递给每个人，网传某皮大面积毁offer&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;把寒气传递给每个人，网传某皮大面积毁offer&lt;/a&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从大部分中概股跌至高峰期的10-20%，到&lt;/span&gt;&lt;span&gt;有消息爆料称“东南亚跨境电商平台&lt;/span&gt;&lt;span&gt;Shopee&lt;/span&gt;&lt;span&gt;正在进行大幅度的裁员” 的后续。&lt;/span&gt;&lt;span&gt;裁员据说根据部门比例来定，基本上大部分部门裁员30%-60%，有的部门裁员90%，这个夸张的比例，基本上就是干掉了整个部门，留几个人维护一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;前一段Google  CEO&lt;span&gt;劈柴&lt;/span&gt;表示&lt;span&gt;他的目标是让公司的效率end to end 提高20%。&lt;/span&gt;&lt;span&gt;劈柴在采访中还表示，提高效率的办法有很多。&lt;/span&gt;&lt;span&gt;比如说，他举例，他把YouTube Music和Google Play Music两个产品合并成为一个产品。&lt;/span&gt;&lt;span&gt;这样一来，人员需要的量就减少了，提高了效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;类似的合并同类项很多，比如某行业2家公司合并。第一波是宣布各自经营，不受影响。第二波是“提效”10%-15%左右喜提N+2。第三波据知情人士说，合并同类项快来了，动作不小。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;脉脉上“不做小卷王”的说法未必代表大多数情况，但也非常有代表性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.0277777777777777&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWE6XiacwKVCaeicY0aWpbKs3qBaR5c2no5ibqm1RYvqbL8WBy01vj6jXkTep54DgiaEtmSl8LHHibbq93g/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结合G哥的观察和思考对于“如何度过寒冬”，几个建议。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公司篇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发展势头还不错的企业，在做大规模的基础上，重点要关注业务的可持续、人均产出价值、利润和现金流。&lt;/span&gt;&lt;span&gt;《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIxMzEzMjM5NQ==&amp;amp;mid=2651063395&amp;amp;idx=1&amp;amp;sn=322dd6f287ccda04af565ba48492adf1&amp;amp;chksm=8c4bd167bb3c587164474ad0a7758fa6648b82c398491e1b67ab48a85412fd6d846531491331&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;用规模掩饰无力，做大估值的方法行不通了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;用规模掩饰无力，做大估值的方法行不通了&lt;/a&gt;》这篇谈了，纯做大估值的方法maybe行不通了。既然是过冬，一要有健康的身板，二要防范于未然。有赞是一家不错的公司，疫情期间经历过高速发展，但成本也居高。&lt;/span&gt;&lt;span&gt;有赞CEO白鸦在3月29日晚发布了内部邮件，大概表达了几个意思。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2021年，公司的价值创造（GMV）和我们的价值回报（收入）都没有增长，而我们的成本和费用投入却保持着线性增长；从内部组织来看，我们的人均产出不到40万/年，中后台、行政、研发等相关较大的投入带来了过多的角色和流程，在业务增速不够迅速的时候这反倒增加了协作成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从开始做SaaS业务，我们就坚信这是个不断积累能力的慢活，通常保持年复合增长&lt;/span&gt;&lt;span&gt;30%&lt;/span&gt;&lt;span&gt;左右是最好的节奏。但疫情给我们带来了两个额外的需求让2020年意外获得了接近&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;的增长......我和管理团队开始压制不住快速增长的&lt;/span&gt;&lt;span&gt;欲望&lt;/span&gt;&lt;span&gt;，认为一定要抓住机会快速做出一个世界级的企业服务公司，并且在2020年第四季度给团队明确了大家后来都知道的“五年十倍，万亿交易额”的高速增长目标。为了这个五年十倍的高速增长目标，我们搭建了非常多的产品、技术、风控、生态中台，成本和费用投入从2020年第四季度开始急剧增加。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2022年我们有一个重要的关于组织的OKR（目标与关键结果），在这里部分引用分享一下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;O：基于客户需求理解和业务认知出发，通过提升全员业务能力和关键协作机制来提高协作效率，提高人均产出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中部分KR如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;KR1：显著提升整体人均产出，到50万/年。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;KR2：直营一线销售之外的整体人数全年减少一定比例，优化目标管理和迭代机制把精力保证在核心目标上，减少协作链条和职能模块，保证行动力和协作效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;一些遭遇较大挑战的公司，可能要有壮士断腕的决心了&lt;/span&gt;&lt;span&gt;。关明生刚到阿里时，整个账面上只剩下700万美元。阿里的业务仍在亏钱的状态，只好通过大规模的裁员来减缓收支。关明生就带着蔡崇信到全球阿里办事处，开除了将近200名员工，把300多人的阿里精简成100多人。关明生的雷厉风行让同行的蔡崇信刮目相看。特别是在美国的办事处，开掉了40多名工程师，剩余的人砍掉一半的工资。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;G哥的朋友中，不少是中型公司技术负责人或者创业公司一把手。撸串间离不开的就是如何过冬、突围。一家北京/成都2地的企业在裁撤30%之后，近期可能还要30%，同时也想去折腾折腾新的东西。不容乐观，整体战略不清晰，再折腾可能就是一个过程了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外一位创业公司的CEO就比较清醒。他说我的现金流能支持1.5年。我下来做三件事：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、进一步筛选团队成员，留下每一位都是“能打”的人。他们团队人不到20人，还要精简，为什么？CEO进一步介绍道，我选择人不只看当下的能力，而是看是否具备和我们团队一起走更长时间的那种味道。如果不是，我宁愿按劳动法赔偿，请他离开。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、加强商业化，客户上万，之前付过费或者说有付费意愿的有一些。曾经的计划是想今年不做市场，继续打磨产品，但不得不提前考虑商业化的部分了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、考虑融资。账面上的钱能支持18个月，我们前面拿钱还比较顺，创始团队和产品也比较受认可。但现在局面下，这事得加速，未雨绸缪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一位工业4.0方向的老板也在经历不一样的2022。高举高打，1年收入增长1倍，2年增长3倍。言犹在耳，但面临的问题很具体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1、前期销售吹的牛，后面大部分都没有如期交付。或者交付了，客户不满意。讲的，和实现2张皮，脱节。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2、看到单子很多，签约收入增加，但利润没有增加。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3、想做的事情多，研发和交付团队承接不住，效率没有明显提升。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;再说，也是一些to B的老毛病了，有做产品的心，但还是在做项目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;磨刀不误砍柴工，在活下去的前提下，内部理顺，人均产值提升是重点。不然要不在冬天挨冻。即使挨到春暖花开，也没有为飞升做好准备。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;百年未遇之变局和疫情等因素的叠加，亦蕴含着新的机遇。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《2022年IAA行业品类发展洞察系列报告》指出：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1、运动健身类app：线上运动常态化、使用场景丰富化，带动粘性稳中有升。2022年以来，运动健身APP的人均单日使用时长稳定在20分钟以上；人均单日启动次数超过5次且仍在上升。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2、&lt;span&gt;在游戏领域中，合成、模拟经营、消除三大品类排名居高，作为经典玩法表现出更强的抗周期性，值得开发者关注。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;曾几何时，国产基础软件长期在国外竞品的挤压下踽踽前行。但2018年，一个不可忽视的转折恰好发生——当“卡脖子”现象率先出现在芯片领域，国内创投风向陡然转硬，基础软件自此也迎来新的创投热潮。中间件软件开源也形成了一股新的浪潮，包括相关公司的发展。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;传统企业数字化转型，不得不说在神州大地上炙手可热。好像Gartner还评论到数据中台概念已经快炒糊了。虽然关于数字化说啥的都有，但降本、增效、业务创新是核心诉求。子弹继续飞起来，不少人用具体的技术名词比如大数据、AI和区块链来代替对于新时代的定义，无异于投机取巧。工具不能代替目标。但无论如何，这是一个大方向。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;下次，G哥再聊聊如何度过寒冬，个人篇。欢迎大家文末留言。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107447&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;218:358&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;144&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWH0hficYGBZI8qZSNxI5FiadxVSicSfvTZSNbNJGbX8d3bNJbTg1HfvOEIbM2rVa8I078ibV7wcKys75w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;长按二维码关注&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a6f33157cc8e578ae02d76c52de8cae1</guid>
<title>【前端】localStorage 用法及使用注意事项</title>
<link>https://toutiao.io/k/qz3nx8m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
                &lt;div id=&quot;content_views&quot; class=&quot;htmledit_views&quot;&gt;
                    &lt;p&gt;localStorage 用法及使用注意事项&lt;br/&gt; localStorage 介绍&lt;br/&gt; 在HTML5中，为了解决cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，增加了一个 localStorage，主要是用来作为本地存储的；localStorage 中一般浏览器支持的容量大小是5M，针对不同的浏览器，localStorage容量大小会有所不同。&lt;/p&gt; 
&lt;p&gt;localStorage 使用&lt;br/&gt; 一、 localStorage的浏览器支持情况：&lt;br/&gt;&lt;img alt=&quot;localStorage用法&quot; src=&quot;https://img-blog.csdnimg.cn/20190517095158943.jpg&quot;/&gt;&lt;/p&gt; 
&lt;p/&gt; 
&lt;p&gt;二、localStorage 代码中的使用：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;在项目中，使用localStorage首先需要做的先判断浏览器是否支持;&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if(!window.localStorage){
 alert(&quot;浏览器不支持localstorage&quot;);
}else{
    //主逻辑业务
    console.log(&#x27;Hello world!&#x27;);
}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;localStorage 设置语法&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;if(!window.localStorage){
    alert(&quot;浏览器支持localstorage&quot;);
}else{
    var storage=window.localStorage;
    //第一种设置方式：
    storage[&quot;a&quot;]=1;
    //第二种设置方式：
    storage.b=1;
    //第三种设置方式：
    storage.setItem(&quot;c&quot;,3);
    
    console.log(typeof storage[&quot;a&quot;]);  //打印出结果：String
    console.log(typeof storage[&quot;b&quot;]);  //打印出结果：String
    console.log(typeof storage[&quot;c&quot;]);  //打印出结果：String
}
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;在浏览器中查看结果：&lt;img alt=&quot;localStorage如何使用&quot; src=&quot;https://img-blog.csdnimg.cn/20190517101442591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzQ0MTMz,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt; &lt;p&gt;localStorage 获取&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;//第一种方法读取
var a=storage.a;
console.log(a);

//第二种方法读取
var b=storage[&quot;b&quot;];
console.log(b);

//第三种方法读取
var c=storage.getItem(&quot;c&quot;);
console.log(c);
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt; &lt;strong&gt;注意：localStorage的设置和读取方式，官方推荐使用 setItem / getItem；&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt;
&lt;p&gt;localStorage 修改&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var getVal = localStorage.getItem(&#x27;myStorage&#x27;);
if( getVal  != null ){
localStorage.setItem(&#x27;myStorage&#x27;,&#x27;setOk&#x27;);
console.log(&#x27;修改成功&#x27;);
}else{
console.log(&#x27;未找到myStorage, getVal返回值为 null&#x27;);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p/&gt; 
&lt;p&gt;localStorage删除&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var getVal = localStorage.getItem(&#x27;myStorage&#x27;);
if( getVal  != null ){
localStorage.removeItem(&#x27;myStorage&#x27;);
console.log(&#x27;删除成功&#x27;);
}else{
console.log(&#x27;未找到myStorage，getVal返回值为 null&#x27;);
}
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt; &lt;strong&gt;localStorage 清除当前域名下所有内容&lt;/strong&gt;&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;localStorage.clear();
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;localStorage中存入 JSON 对象，需先转换成 JSON 字符串，再写入，在读取时再转换成 JSON 对象：（否则会报错）&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var storage=window.localStorage;
var data={
     name:&#x27;zhangSan&#x27;,
     sex:&#x27;1&#x27;
 };
 //将对象转换为 String ,如果不转，在存入localStorage后，读取出来转换 json对象会报错
 var setData=JSON.stringify(data); 
 storage.setItem(&quot;data&quot;,setData);
 
 //将JSON字符串转换成为JSON对象输出
 var jsonString=storage.getItem(&quot;data&quot;);
 console.log(typeof jsonString); //打印出 String;
 var jsonObj=JSON.parse(jsonString);
 console.log(typeof jsonObj); //打印出 Object;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;localStorage 注意事项：&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;浏览器的大小不统一，并且在IE8以上的IE版本才支持localStorage这个属性&lt;/li&gt;&lt;li&gt;目前所有的浏览器中都会把localStorage的值类型限定为string类型，这个在对我们日常比较常见的JSON对象类型需要一些转换&lt;/li&gt;&lt;li&gt;localStorage在浏览器的隐私模式下面是不可读取的&lt;/li&gt;&lt;li&gt;localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡&lt;/li&gt;&lt;li&gt;localStorage不能被爬虫抓取到&lt;/li&gt;&lt;/ol&gt;
                &lt;/div&gt;
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>