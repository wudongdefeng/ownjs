<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7896c8afe07a3202e77aa103c3e3fb03</guid>
<title>使用 Remix Analyzer 发现 Solidity 潜在问题</title>
<link>https://toutiao.io/k/6dyvjdy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;使用 Remix Analyzer 发现 Solidity 潜在问题&lt;/h1&gt;
&lt;p class=&quot;meta&quot;&gt;胡键 Posted at — Jan 10, 2023
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;markdown&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ethereum/remix-project/tree/master/libs/remix-analyzer&quot;&gt;Remix Analyzer&lt;/a&gt; 是 Remix IDE Solidity 静态分析插件的底层支撑库。这意味着它不仅可以用于 Remix IDE 同时也能用于其他项目。&lt;/p&gt;
&lt;p&gt;既然 Hardhat 是现在流行的合约开发工具，如果能够跟它结合话，那当然再好不过了。在 Remix 的代码仓库中，&lt;a href=&quot;https://github.com/ethereum/remix-project/blob/master/libs/remix-analyzer/test/analysis/staticAnalysisIssues-test-0.5.0.ts&quot;&gt;这个测试文件&lt;/a&gt;显示了它的基本使用，关键代码摘录如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;res&lt;/span&gt;: &lt;span&gt;CompilationResult&lt;/span&gt; = &lt;span&gt;compile&lt;/span&gt;(&lt;span&gt;&#x27;functionParameters.sol&#x27;&lt;/span&gt;)
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;Module&lt;/span&gt;: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;checksEffectsInteraction&lt;/span&gt;
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;statRunner&lt;/span&gt;: &lt;span&gt;StatRunner&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StatRunner&lt;/span&gt;()
...
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;reports&lt;/span&gt; = &lt;span&gt;statRunner&lt;/span&gt;.&lt;span&gt;runWithModuleList&lt;/span&gt;(&lt;span&gt;res&lt;/span&gt;, [{ &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Module&lt;/span&gt;().&lt;span&gt;name&lt;/span&gt;, &lt;span&gt;mod&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Module&lt;/span&gt;() }])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码逻辑一目了然：编译代码 &amp;gt; 应用规则 &amp;gt; 输出报告。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;上面代码中的 Module 对应 Remix Analyzer 的检查规则，目前支持的所有规则可以在：&lt;a href=&quot;https://github.com/ethereum/remix-project/blob/master/libs/remix-analyzer/src/solidity-analyzer/modules/index.ts&quot;&gt;这个文件&lt;/a&gt;中找见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于 &lt;code&gt;runWithModuleList&lt;/code&gt; 中可以接收多个 Module 对象，如果想应用多个规则的话，只需要初始化多个 Module 实例就行了。&lt;/p&gt;
&lt;h2 id=&quot;封装成-hardhat-任务&quot;&gt;封装成 Hardhat 任务&lt;/h2&gt;
&lt;p&gt;在 Hardhat 中使用 Remix Analyzer 的办法很简单：将上面的那段脚本封装成一个 Task 就行了。但直接照搬的话有个问题。如果仔细看上面的测试代码，你会发现它会先去下载一个 Solidity 的编译器，然后使用它来完成编译。在测试准备阶段有类似下面的代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;test&lt;/span&gt;(&lt;span&gt;&#x27;setup&#x27;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;t&lt;/span&gt;) {
  &lt;span&gt;solc&lt;/span&gt;.&lt;span&gt;loadRemoteVersion&lt;/span&gt;(&lt;span&gt;&#x27;v0.5.0+commit.1d4f565a&#x27;&lt;/span&gt;, (&lt;span&gt;error&lt;/span&gt;, &lt;span&gt;compiler&lt;/span&gt;) =&amp;gt; {
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，直接闷头照抄并非不行，但整个过程不太美观：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hardhat 本身就自带了编译功能，应该尽可能的去利用它，而不是另起炉灶。&lt;/li&gt;
&lt;li&gt;基于上一步，如果能直接从编译结果中得到符合 &lt;code&gt;CompilationResult&lt;/code&gt; 类型的数据就更完美了。这样避免了手工适配的过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 &lt;code&gt;1&lt;/code&gt;，好办，Hardhat 直接支持在任务中调用任务，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;await&lt;/span&gt; &lt;span&gt;hre&lt;/span&gt;.&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;TASK_COMPILE&lt;/span&gt;, { &lt;span&gt;quiet&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 &lt;code&gt;2&lt;/code&gt;，也不复杂。Hardhat 暴露了属性可以方便的让开发者访问其内部各种制品(Artifact)，当然也包括编译后的产物。只是这里有一点需要注意，语法分析用的并不是最终制品，而是编译后的制品。即它需要的是 &lt;code&gt;artifacts/build-info&lt;/code&gt; 而不是 &lt;code&gt;artifacts/contracts&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且，&lt;code&gt;artifacts/build-info&lt;/code&gt; 下的 json 文件不能直接被 Remix Analyzer 所用，只是其中的一部分。通过对比 &lt;code&gt;CompilationResult&lt;/code&gt; 类型和 json 的内容很容易发现其中关联：&lt;code&gt;output&lt;/code&gt; 属性。因此，整个任务的逻辑框架代码如下：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;runner&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;staticAnalysisRunner&lt;/span&gt;();

&lt;span&gt;await&lt;/span&gt; &lt;span&gt;hre&lt;/span&gt;.&lt;span&gt;run&lt;/span&gt;(&lt;span&gt;TASK_COMPILE&lt;/span&gt;, { &lt;span&gt;quiet&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });
&lt;span&gt;console&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;(&lt;span&gt;&quot;√ compiled contracts.\n&quot;&lt;/span&gt;);

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;compileResults&lt;/span&gt; = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;hre&lt;/span&gt;.&lt;span&gt;artifacts&lt;/span&gt;.&lt;span&gt;getBuildInfoPaths&lt;/span&gt;();
&lt;span&gt;compileResults&lt;/span&gt;.&lt;span&gt;forEach&lt;/span&gt;((&lt;span&gt;result&lt;/span&gt;) =&amp;gt; {
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;compiled&lt;/span&gt; = &lt;span&gt;JSON&lt;/span&gt;.&lt;span&gt;parse&lt;/span&gt;(&lt;span&gt;fs&lt;/span&gt;.&lt;span&gt;readFileSync&lt;/span&gt;(&lt;span&gt;result&lt;/span&gt;).&lt;span&gt;toString&lt;/span&gt;());
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;source&lt;/span&gt; = &lt;span&gt;Object&lt;/span&gt;.&lt;span&gt;keys&lt;/span&gt;(&lt;span&gt;compiled&lt;/span&gt;.&lt;span&gt;input&lt;/span&gt;.&lt;span&gt;sources&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;];
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;module&lt;/span&gt;&lt;span&gt;s&lt;/span&gt; = &lt;span&gt;calculateRules&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt;, &lt;span&gt;rulesConfig&lt;/span&gt;).&lt;span&gt;map&lt;/span&gt;((&lt;span&gt;Module&lt;/span&gt;: &lt;span&gt;any&lt;/span&gt;) =&amp;gt; {
    &lt;span&gt;return&lt;/span&gt; { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Module&lt;/span&gt;().&lt;span&gt;name&lt;/span&gt;, &lt;span&gt;mod&lt;/span&gt;: &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Module&lt;/span&gt;() };
  });
  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;reports&lt;/span&gt; = &lt;span&gt;runner&lt;/span&gt;.&lt;span&gt;runWithModuleList&lt;/span&gt;(&lt;span&gt;compiled&lt;/span&gt;.&lt;span&gt;output&lt;/span&gt;, &lt;span&gt;module&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;);
  ...
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;即：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译&lt;/li&gt;
&lt;li&gt;针对每个编译后的文件生成报告：解析 json &amp;gt; 计算规则 &amp;gt; 应用规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;封装成-hardhat-插件&quot;&gt;封装成 Hardhat 插件&lt;/h2&gt;
&lt;p&gt;语法分析是一个高度可复用的任务，没有理由不进一步将其封装成一个插件。&lt;/p&gt;
&lt;p&gt;身为 dapp 开发，如果还不清楚 Hardhat 插件为何物，那真应该好好读读&lt;a href=&quot;https://hardhat.org/hardhat-runner/docs/advanced/building-plugins&quot;&gt;文档&lt;/a&gt;了。利用插件，你可以方便地在项目间共享配置，当然也包括自定义的 task。&lt;/p&gt;
&lt;p&gt;按照文档推荐的步骤：先在 Hardhat 工程中测试完任务的逻辑；再将其挪到插件工程封装成插件。现在，我们已经完成了第一步。&lt;/p&gt;
&lt;p&gt;关于如何构建插件的过程，文档中已经说的很清楚，这里不再赘述：基于&lt;a href=&quot;https://github.com/NomicFoundation/hardhat-ts-plugin-boilerplate/&quot;&gt;插件模板&lt;/a&gt;工程进行改造就行了。在实际开发过程中，个人发现有两点需要强调一下。&lt;/p&gt;
&lt;h3 id=&quot;依赖&quot;&gt;依赖&lt;/h3&gt;
&lt;p&gt;按照&lt;a href=&quot;https://hardhat.org/hardhat-runner/docs/advanced/building-plugins#notes-on-dependencies&quot;&gt;文档中总结的几条规则&lt;/a&gt;操作就行了。&lt;/p&gt;
&lt;h3 id=&quot;扩展配置&quot;&gt;扩展配置&lt;/h3&gt;
&lt;p&gt;在文档中并没有特别说明，而只是给出了一个示例文件的链接，但我发现需要搭配&lt;a href=&quot;https://github.com/NomicFoundation/hardhat-ts-plugin-boilerplate/blob/master/src/type-extensions.ts&quot;&gt;这个文件&lt;/a&gt;一起看才能明白其中的逻辑。读完代码，规则总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同时扩展 XxxUserConfiguration 和 XxxConfig，其中：
&lt;ul&gt;
&lt;li&gt;前者新增的配置字段为可选，后者为必填。&lt;/li&gt;
&lt;li&gt;在初始化的时候基于前者生成后者，若前者没有，则考虑一个默认值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果要扩展 Hardhat 现有的配置项，如例子代码所做的给 paths 新添加一个属性，则需使用对应的 ProjectPathsUserConfig 和 ProjectPathsConfig 。&lt;/li&gt;
&lt;li&gt;如果要给 Hardhat 新增一个顶层配置项，则用 HardhatUserConfig 和 HardhatConfig，如下例：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-ts&quot; data-lang=&quot;ts&quot;&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;module&lt;/span&gt; &lt;span&gt;&quot;hardhat/types/config&quot;&lt;/span&gt; {
  &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;HardhatUserConfig&lt;/span&gt; {
    &lt;span&gt;analyzerRules?&lt;/span&gt;: &lt;span&gt;AnalyzerConfiguration&lt;/span&gt;;
  }

  &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;HardhatConfig&lt;/span&gt; {
    &lt;span&gt;analyzerRules&lt;/span&gt;: &lt;span&gt;AnalyzerConfiguration&lt;/span&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至于其余的，没啥可说的了，照着模板工程来就行了。有兴趣的话可以访问 &lt;a href=&quot;https://github.com/DTeam-Top/hardhat-remix-analyzer&quot;&gt;hardhat-remix-analyzer 的代码仓库&lt;/a&gt;了解详情。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;除了 Remix Analyzer，还有其他两个类似工具可以关注：&lt;a href=&quot;https://github.com/crytic/slither/tree/master/slither&quot;&gt;slither&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/protofire/solhint&quot;&gt;solhint&lt;/a&gt;。对比之后，个人建议关注后面两个，原因在于后者提供了更多的规则，而且更新更频繁，并且 Hardhat 也提供了针对 solhint 的插件。&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fba2ccd428a83cb3d38b5cab15cf3af9</guid>
<title>面试官：为什么数据库连接池不采用 IO 多路复用？</title>
<link>https://toutiao.io/k/mngnzrc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天我们聊一个不常见的 Java 面试题：&lt;strong&gt;为什么数据库连接池不采用 IO 多路复用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个非常好的问题。&lt;/span&gt;&lt;code&gt;&lt;span&gt;IO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;多路复用被视为是非常好的性能助力器。但是一般我们在使用 DB 时，还是经常性采用&lt;/span&gt;&lt;code&gt;&lt;span&gt;c3p0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;tomcat connection pool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;等技术来与 DB 连接，哪怕整个程序已经变成以&lt;/span&gt;&lt;code&gt;&lt;span&gt;Netty&lt;/span&gt;&lt;/code&gt;&lt;span&gt;为核心。这到底是为什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先纠正一个常见的误解。IO 多路复用听上去好像是多个数据可以共享一个 IO（socket 连接），实际上并非如此。&lt;strong&gt;IO 多路复用不是指多个服务共享一个连接，而仅仅是指多个连接的管理可以在同一进程&lt;/strong&gt;。在网络服务中，IO 多路复用起的作用是&lt;strong&gt;一次性把多个连接的事件通知业务代码处理&lt;/strong&gt;。至于这些事件的处理方式，到底是业务代码循环着处理、丢到队列里，还是交给线程池处理，由业务代码决定。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/x0kXIOa6owVZykXdDBlnLSuplRes26TA5ZnSSdh4ketJHZ5iaoWia5OyiaK7Fk5kUhhvuTqxWp4MqIgQlATpYXr2Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于使用 DB 的程序来讲，不管使用多路复用，还是连接池，都要维护一组网络连接，支持并发的查询。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么并发查询一定要使用多个连接才能完成呢？因为 DB 一般是使用连接作为 Session 管理的基本单元。在一个连接中，SQL 语句的执行必须是串行、同步的。这是由于对于每一个 Session，DB 都要维护一组状态来支持查询，比如事务隔离级别，当前 Session 的变量等。只有单 Session 内串行执行，才能维护查询的正确性（试想一下一组 sql 在不断的增减变量，然后这组 sql 乱序执行会发生什么）。维护这些状态需要耗费内存，同时也会消耗 CPU 和磁盘 IO。这样，限制对 DB 的连接数，就是在限制对 DB 资源的消耗。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，对 DB 来说，关键是要限制连接的数目。这个要求无论是 DB 连接池还是 NIO 的连接管理都能做到。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.74625&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/x0kXIOa6owVZykXdDBlnLSuplRes26TAg4hsWQJ8Dg0PY6Wt2pCy2J1LqiaGrcM0e0VcGo95cZLoJFLGFrptdqQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样问题就绕回来了，为什么 DB 连接不能放到 IO 多路复用里一并执行吗？为啥大家都用连接池？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案是，可以用 IO 多路复用——但是&lt;strong&gt;使用 JDBC 不行&lt;/strong&gt;。JDBC 是一个出现了近 20 年的标准，它的设计核心是 BIO（因为 199X 年时还没有别的 IO 可以用）：调用者在通过 JDBC 时执行比如&lt;/span&gt;&lt;code&gt;&lt;span&gt;query&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这样的&lt;/span&gt;&lt;code&gt;&lt;span&gt;API&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在没有执行完成之前，整个调用线程被卡住。而类似于&lt;/span&gt;&lt;code&gt;&lt;span&gt;Mysql Connector/J&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这样的&lt;/span&gt;&lt;code&gt;&lt;span&gt;driver&lt;/span&gt;&lt;/code&gt;&lt;span&gt;完备的实现了这套语义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然如果 DB Client 的协议的连接处理和解析稍微改一下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将 IO 模式调整为 Non-Blocking，这样就可以挂到 IO 多路复用的内核上（select、epoll、kqueue……）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Non-Blocking 实现的基础之上实现数据库协议的编码和解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;就可以实现用 IO 多路复用来访问 DB。实际上很多其他语言/框架里都是这么干的。比如 Nodejs，see &lt;/span&gt;&lt;code&gt;&lt;span&gt;https://github.com/sidorares/node-mysql2&lt;/span&gt;&lt;/code&gt;&lt;span&gt;；或者 Vert.X 的 db 客户端&lt;/span&gt;&lt;code&gt;&lt;span&gt;https://github.com/mauricio/postgresql-async&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，不要在意这个名字，它实际上同时支持 mysql 和 postgres）。只不过对于 IO 多路复用，数据库官方似乎都没做这种支持——他们只支持 JDBC、ODBC 等等这些标准协议。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么为什么基于 IO 多路复用的实现不能成为默认的，官方的，而要成为偏门呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于数据库开发者来说。这种用法在整体的用户里占有量非常小，所以也许不值当的花大力气。只需要把协议写清楚（比如&lt;/span&gt;&lt;code&gt;&lt;span&gt;https://dev.mysql.com/doc/internals/en/client-server-protocol.html&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），就可以做实现。那么社区的有兴趣的人自然就可以去做。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外一个原因是体系的支持。简单来讲，如果没有一个大的 Reactive 的运行环境，IO 多路复用的使用会非常受限。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IO 多路复用之所以能成立，是需要&lt;strong&gt;整个程序要有一个 IO 多路复用的驱动代码&lt;/strong&gt;——就是 select 那句调用——等待事件来临，一个 blocking 的 API。整个程序必须以这个驱动代码为核心。这样就对整个代码的结构产生重大的影响。这种影响是没法用简单的接口抽象的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java Web 容器之所以可以使用 NIO 是因为 NIO 可以被封装到容器内部。Web 容器对外暴露的还是传统的多线程形式的&lt;/span&gt;&lt;code&gt;&lt;span&gt;Java EE&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 DB 和 Web 容器同时使用 NIO，那么调用的 DB 连接库与必须与容器有一个约定描述&lt;strong&gt;DB 的连接管理如何接入 Web 容器的 NIO 的驱动代码&lt;/strong&gt;。在 Java 这个大环境下，不同人，不同的容器写的代码不同；又或者，不使用任何常见的容器，而是自己用 NIO 去封装一个。这样是无法形成代码上的约定的。那么多个独立的组件就不能很好的共享 NIO 的驱动代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面这个用法假设整个程序应该共享一个 NIO 驱动代码。那么 Web 和 DB 可不可以各用各的呢？也是可以的，但是为了保证这两个 NIO 驱动代码不会相互 block，最好要分开两个线程。这样一来就会打破一般 Web 服务一个请求处理用一个线程的一般做法，会让程序边的更复杂——你的业务代码和 DB 查询之间必须做跨线程数据交换。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，连接池的实现就相对独立的多，也简单的多。外界只要配好 DB URL，用户名密码和连接池的容量参数，就可以做到自行管理连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而&lt;/span&gt;&lt;code&gt;&lt;span&gt;Nodejs&lt;/span&gt;&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;&lt;span&gt;Vert.X&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是完全不同的。他们本质就是&lt;/span&gt;&lt;code&gt;&lt;span&gt;Reactive&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的。他们的&lt;/span&gt;&lt;code&gt;&lt;span&gt;NIO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的驱动方式是其运行时的基础——所有要在这个基础上开发的代码都必须遵守同样的&lt;/span&gt;&lt;code&gt;&lt;span&gt;NIO+&lt;/span&gt;&lt;/code&gt;&lt;span&gt;异步开发规范，使用同一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;NIO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的驱动。这样&lt;/span&gt;&lt;code&gt;&lt;span&gt;DB&lt;/span&gt;&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;&lt;span&gt;NIO&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的协作就不成问题了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，&lt;strong&gt;有大量场景是需要 BIO 的 DB 查询支持的&lt;/strong&gt;。批处理数据分析代码都是这样的场景。这样的程序写成 NIO 就会得不偿失——代码不容易懂，也没有任何效率上的优势。类似于&lt;/span&gt;&lt;code&gt;&lt;span&gt;Nodejs&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这样的运行时在此场景下，反而要利用&lt;/span&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt;&lt;/code&gt;&lt;span&gt;或等价的语法来让代码看起来是同步的，这样才容易写。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结一下。DB 访问一般采用连接池这种现象是生态造成的。历史上的 BIO + 连接池的做法经过多年的发展，已经解决了主要的问题。在 Java 的大环境下，这个方案是非常靠谱的，成熟的。而基于 IO 多路复用的方式尽管在性能上可能有优势，但是其对整个程序的代码结构要求过多，过于复杂。当然，如果有特定的需要，希望使用 IO 多路复用管理 DB 连接，是完全可行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651521950&amp;amp;idx=1&amp;amp;sn=52b646818a30a7aed0e5950a4d490f55&amp;amp;chksm=bd246fe18a53e6f78233a97243f6332ad5f3950069b932832e9b887887635bd116fcd6c5203d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;读懂HikariCP一百行代码，多线程就是个孙子！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;读懂HikariCP一百行代码，多线程就是个孙子！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651519942&amp;amp;idx=1&amp;amp;sn=b3e71aa689fab99470b176c9e35ad6db&amp;amp;chksm=bd2597b98a521eafe1e1496a131b403b5d81ccc0ac26987eb7f0974da2436d3f8116d96f52aa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java 多线程永动任务设计与实现&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;Java 多线程永动任务设计与实现&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651522514&amp;amp;idx=1&amp;amp;sn=020bfdf5bba2ed63b4be187af6959e1c&amp;amp;chksm=bd2469ad8a53e0bb7a9b02c2c6a63a9c3685a7ba7103bbf9bafb0ae3982a93cb76dd199a282b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;让人恶心的多线程代码，性能怎么优化！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;让人恶心的多线程代码，性能怎么优化！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee3ef9e01e84c5d98f88ff4bf734659b</guid>
<title>关于性能测试需要知道的</title>
<link>https://toutiao.io/k/07n66qf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;随着各企业的业务发展、用户量以及数据量的不断增加，系统承载的压力也会随之增加，服务系统的性能好坏又严重影响企业的利益。因此，性能测试重要性与需求越来越强烈。&lt;/p&gt;
&lt;h2&gt;常见的性能测试目的&lt;/h2&gt;
&lt;p&gt;性能测试是确定系统在特定工作负载下的稳定性和响应能力。在进行性能测试之前，首先是要明确性能测试的目的，目的不同，对应的解决方案会有很大差异，最常见的性能测试目的（或契机）有三种：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/unnamed.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/unnamed.png&quot; alt=&quot;性能测试的三种目的&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;评测当前系统性能&lt;/strong&gt;&lt;br/&gt;
通过性能测试了解系统当前的性能是否达到预期。例如：新系统上线前、技术升级后，都会进行性能测试，确保系统在线上稳定可靠地运行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寻找瓶颈，优化性能&lt;/strong&gt;&lt;br/&gt;
系统已知有性能问题，进行测试寻找瓶颈，以便优化其性能。例如：用户提出业务操作响应时间长，需要定位问题，调整性能；系统运行一段时间后，速度变慢，寻找瓶颈，进而优化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预测系统未来的性能、可扩展性&lt;/strong&gt;&lt;br/&gt;
通过性能测试预测系统在未来达到一定负载量的情况下，系统的性能表现。为的是提前预防并降低风险。扩展能力非常好的系统，性能是随资源扩展呈线性或接近线性提升。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;性能测试的不同类型&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/image007.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/image007.png&quot; alt=&quot;性能测试的不同类型&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;基准测试&lt;/strong&gt;&lt;br/&gt;
基准测试：系统较低压力时，查看系统的运行状况并记录相关数作为基础参考。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;负载测试&lt;/strong&gt;&lt;br/&gt;
负载测试是通过逐渐增加系统负载，测试系统性能的变化，并最终确定在满足性能指标的情况下，系统能承受的最大负载量的测试。目标：确定系统的性能容量（如系统在保证一定响应时间情况下能够允许多少并发用户的访问），系统各项指标，如吞吐量、响应时间、CPU负载、内存使用等如何决定系统的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;压力测试&lt;/strong&gt;&lt;br/&gt;
压力测试通过确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。目标：压力测试是为了发现在什么条件下您的应用程序的性能会变得不可接受。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;并发性能测试&lt;/strong&gt;&lt;br/&gt;
负载测试和压力测试通常被合称为并发性能测试。即大并发场景下的系统性能，多用户同时访问时，检测系统是否能够稳定运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;平均并发用户数C=nL/T

n：平均每天访问用户数（login session的数量）；

L：一天内用户从登录到退出的平均时间（login session的平均长度）；

T：考察的时间段长度（一天内多长时间有用户使用系统）；

并发用户数峰值：C&#x27;≈C+3*根号C&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大数据量测试&lt;/strong&gt;&lt;br/&gt;
大数据量测试包括独立的数据量测试和综合数据量测试。独立的数据量测试指针对某些系统存储、传输、统计、查询等业务进行的大数据量测试。综合数据量测试指系统在具备一定数据量时，在负载压力测试下，考察业务是否能够正常运行的测试。目标：测试数据量较大时系统的性能状况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;容量测试&lt;/strong&gt;&lt;br/&gt;
容量测试的目的是通过测试预先分析出反映软件系统应用特征的某项指标的极限值（如最大并发用户数），系统在其极限状态下没有出现任何软件故障且能正常运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置测试&lt;/strong&gt;&lt;br/&gt;
通过对被测系统软硬环境的调整，了解各种不同环境对系统性能的影响程度，从而找到系统各项资源的最优分配原则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;稳定性测试&lt;/strong&gt;&lt;br/&gt;
稳定性是通过给系统加载一定的压力，让系统持续运行一段时间（通常为7x24小时），检测系统是否能够稳定运行。稳定性测试也称为疲劳强度测试，属于可靠性测试的范畴。目标：测试系统长时间无故障稳定运行的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;失效恢复测试&lt;/strong&gt;&lt;br/&gt;
失效恢复测试是针对有冗余备份或负载均衡的系统来说，检验如果系统局部发生故障，系统灾备措施是否可以正常启动，用户是否可以继续使用。（如：集群、热备等） 目标：通过实施失效恢复测试，评估系统的健壮性和可恢复性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实际项目当中，可根据不同的性能测试目的，选相对应的性能测试方式。&lt;/p&gt;
&lt;h2&gt;性能测试的监控指标&lt;/h2&gt;
&lt;p&gt;在进行各类性能测试时，需要同步检测系统各项性能指标，从而分析系统的实际的响应能力与稳定性等。常用的性能监测指标有四类：&lt;strong&gt;业务性能指标、资源性能指标、中间件监测指标、数据库&lt;/strong&gt;监测指标。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-3.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-3-300x293.png&quot; alt=&quot;四种性能监测指标&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;业务性能指标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;每秒交易数（TPS）&lt;/strong&gt;：每秒钟系统能够处理的交易或事务的数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;响应时间&lt;/strong&gt;：从请求端发起请求开始，到请求端接收到服务器端的返回结束，这个过程所耗费的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发用户数&lt;/strong&gt;：指系统可以同时承载的正常使用系统功能的用户的数量，即在给定的时间段内正在使用系统的用户数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在线用户数&lt;/strong&gt;：没有提交请求，会话状态在线的用户数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：指系统在单位时间内处理请求的数量。即在给定时间段内系统完成的交易数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;响应时间行业标准&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;互联网企业：500毫秒以下，例如淘宝业务10毫秒左右。&lt;/li&gt;
&lt;li&gt;金融企业：1秒以下为佳，部分复杂业务3秒以下。&lt;/li&gt;
&lt;li&gt;保险企业：3秒以下为佳。&lt;/li&gt;
&lt;li&gt;制造业：5秒以下为佳。&lt;/li&gt;
&lt;li&gt;时间窗口：不同数据量结果是不一样的，大数据量的情况下，2小时内完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;TPS行业标准&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;互联网企业：500毫秒以下，如某宝业务10毫秒左右。&lt;/li&gt;
&lt;li&gt;金融行业：1000TPS~50000TPS，不包括互联网化的活动&lt;/li&gt;
&lt;li&gt;保险行业：100TPS~100000TPS，不包括互联网化的活动&lt;/li&gt;
&lt;li&gt;制造行业：10TPS~5000TPS&lt;/li&gt;
&lt;li&gt;互联网电子商务：10000TPS~1000000TPS&lt;/li&gt;
&lt;li&gt;互联网中型网站：1000TPS~50000TPS&lt;/li&gt;
&lt;li&gt;互联网小型网站: 500TPS~10000TPS&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;资源性能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU指标&lt;/strong&gt;：主要指的CPU使用率、利用率，包括用户态（user）、系统态（sys）、等待态（wait）、空闲态（idle）。一般情况下，CPU使用率、利用率要低于警戒值范围75%。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存/SWAP&lt;/strong&gt;：内存利用率100%并不代表内存有瓶颈，衡量系统内有瓶颈主要靠SWAP（与虚拟内存交换）交换空间利用率，一般情况下，SWAP交换空间利用率要低于70%，太多的交换将会引起系统性能低下。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;磁盘吞吐量&lt;/strong&gt;：磁盘吞吐量是指在无磁盘故障的情况下单位时间内通过磁盘的数据量。磁盘繁忙率，磁盘队列数，平均服务时间，平均等待时间，空间利用率。其中磁盘繁忙率是直接反映磁盘是否有瓶颈的重要依据，一般情况下，磁盘繁忙率要低于70%。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络吞吐量&lt;/strong&gt;：网络吞吐量是指在无网络故障的情况下单位时间内通过的网络的数据数量。一般情况下不能超过设备或链路最大传输能力的70%。&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-4.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-4-300x113.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-5.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-5-300x83.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;资源性能（CPU、内存、磁盘）行业标准：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CPU 利用率要低于业界警戒值范围之内，即小于或者等于75%;&lt;/li&gt;
&lt;li&gt;CPU sys%小于或者等于30%;&lt;/li&gt;
&lt;li&gt;CPU wait%小于或者等于5%&lt;/li&gt;
&lt;li&gt;SWAP交换空间利用率低于70%&lt;/li&gt;
&lt;li&gt;磁盘繁忙率低于70%&lt;/li&gt;
&lt;li&gt;网络吞吐不能超过最大传输能力70%&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;中间件指标&lt;/h3&gt;
&lt;p&gt;中间件监测指标主要包括JVM、线程池、JDBC连接池，常用的中间件如：Tomcat、Weblogic等。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-6.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-6-300x140.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;中间件监控内容及行业标准：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程数最小设置50和最大设置200比较合适。&lt;/li&gt;
&lt;li&gt;JDBC最小设置50和最大设置200比较合适。&lt;/li&gt;
&lt;li&gt;JVM最小堆大小和最大堆大小分别设置1024M比较合适。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;数据库性能指标&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SQL：执行SQL耗时&lt;/li&gt;
&lt;li&gt;吞吐量：每秒事务次数（TPS），每秒查询次数（QPS）&lt;/li&gt;
&lt;li&gt;锁：锁等待次数和锁等待时间&lt;/li&gt;
&lt;li&gt;命中率：索引缓冲区命中率、线程缓存命中率、表缓存命中率、查询缓存命中率等。&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-7.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-7-300x114.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;数据库监控内容及行业标准:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;SQL耗时越小越好，一般情况下微秒级别。&lt;/li&gt;
&lt;li&gt;命中率越高越好，一般情况下不能低于95%。&lt;/li&gt;
&lt;li&gt;锁等待次数越低越好，等待时间越短越好。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;操作系统内核参数&lt;/code&gt;主要包括信号量、进程、文件句柄。&lt;/p&gt;
&lt;h2&gt;性能测试流程&lt;/h2&gt;
&lt;p&gt;首先要制定测试计划，明确目的、策略等。以测试计划为依据，逐步开展性能测试工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-8.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-8-300x114.png&quot; alt=&quot;性能测试流程&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;明确性能测试目标&lt;/h3&gt;
&lt;p&gt;确定本次性能测试的目标，包括性能测试对象、需求范围，以及性能指标达标要求，即测试退出条件。&lt;/p&gt;
&lt;h3&gt;制定性能测试计划&lt;/h3&gt;
&lt;p&gt;确定了测试对象和测试需求之后，需要制定一份性能测试计划，指导性能测试工作的进行。包括：简介、测试环境、测试场景、测试数据、测试策略、测试时间与人员安排。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;&lt;br/&gt;
描述性能测试环境的物理架构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试场景&lt;/strong&gt;&lt;br/&gt;
针对各业务功能模块，设计不同测试类型（稳定性测试、负载测试、压力测试）等的单场景、组合场景测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试数据&lt;/strong&gt;&lt;br/&gt;
描述各性能测试场景下的数据量要求，加压多大数据量需要提前与业务侧对齐目标，系统现存数据体量以及每年增长幅度也可以通过与业务人员（产品经理)确定，当然也可以一些经验方法或公式来估算。比如：有并发用户数与峰值公式，以及二八原理估算方法。&lt;br/&gt;
【并发用户数公式】：C = nL/T。C：平均的并发用户数；n：平均每天访问用户数（login session的数量）；L：一天内用户从登录到退出的平均时间（login session的平均长度）；T：考察的时间段长度（一天内多长时间有用户使用系统）；&lt;br/&gt;
【并发用户数峰值公式】：C&#x27;≈C+3*根号C。其中：C：公式1中的平均并发用户数；&lt;br/&gt;
【二八原理估算测试强度】：每个工作日中80%的业务在20%的时间内完成。例如：每年业务集中在8个月，每个月20个工作日，每个工作日8小时，即每天80%的业务的在1.6小时完成。去年全年处理业务约100万笔，其中15%的业务处理中每笔业务需对应用服务器提交7次请求；其中70%的业务处理中每笔业务需对服务器提交5次请求；其余15%的业务处理中每笔业务需对应用服务器提交3次请求。（根据以往统计结果，每年的业务增量为15%，考虑到今后3年业务发展的需要，测试需按现有业务量的两倍进行。）&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-9.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-9-300x58.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;性能测试策略&lt;/strong&gt;&lt;br/&gt;
描述性能测试方法和流程与工具等。需要进行哪几种类型的测试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;测试时间与人员安排&lt;/strong&gt;&lt;br/&gt;
描述参与性能测试的人员，以及性能测试时间计划。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;执行性能测试&lt;/h3&gt;
&lt;p&gt;依据性能测试计划进行实施测试，准备测试环境、构造测试数据 、执行测试用例 、记录测试结果。在此过程中，如发现性能问题，提交Bug，修正Bug。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-10.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-10-300x58.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;性能测试报告&lt;/h3&gt;
&lt;p&gt;完成性能测试之后，编写性能测试报告，整理总结本次性能测试的背景、目的、测试范围、测试指标需求、测试环境与工具、测试内容、测试结果与分析等。&lt;/p&gt;
&lt;p&gt;其中测试结果与分析主要是罗列测试指标结果数据及图表，并且对测试的结果及发现的性能问题进行总结、分析。性能测试报告样例参见下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-11.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-11-166x300.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;性能测试工具&lt;/h2&gt;
&lt;p&gt;为了更高效的进行性能测试，选用适合的测试工具非常关键，下面列举了一些常用的性能测试工具供参考。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-12.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2023/01/guide-for-performance-testing-12-300x167.png&quot; alt=&quot;常用的性能测试工具&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20390c81cb59f8fe48c26d17bb328104</guid>
<title>PyTorch统治学术论文，TensorFlow只占4%，LeCun：还能为啥？</title>
<link>https://toutiao.io/k/zn02mnx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h5&gt;萧箫 发自 凹非寺&lt;br/&gt;量子位 | 公众号 QbitAI&lt;/h5&gt;&lt;p&gt;“对于Python而言，为什么TensorFlow正在慢慢死去？”&lt;/p&gt;&lt;p&gt;这篇观点尖锐的文章一出，就被LeCun的转发推向风口浪尖：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;还能为啥，当然是因为PyTorch啊。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8127147766323024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRWX0E4bDtIfW1vFwPSWicRIzdOxKJEAJibMOkibG4msricA5yPU1ic4rgibpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/p&gt;&lt;p&gt;紧接着“PyTorch和TensorFlow谁更好？”这个经久不息的论战再次被掀起，网友们也纷纷开始从文章中找到共鸣、或予以反驳。&lt;/p&gt;&lt;p&gt;有TensorFlow深度使用者现身说法：现在我改用PyTorch了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2586427656850192&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRjYycGWawMHgwicbIBsdzH4JB9vnSGGQoibibMbaFctt2wicibEpgnzeUsZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/p&gt;&lt;p&gt;但也有尝试过好几种框架的网友表示：TensorFlow和Keras做快速实验更方便，而且TensorFlow看起来对Apple M1 GPU支持更好。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2591145833333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRfJmoy8P3HIdcxCSIIIEZbapsugBGQelpZicOqW1LOCdm8JiaLyZy3icLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1536&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然，在这里面也出现了一些独特的声音：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;JAX不比这两个框架好多了？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13753213367609254&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRgVAuZqxubgRqZic7qFgiasGG1E3TR5uu0Vp3SKEib1XpjEoCMyyBJxfNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1556&quot;/&gt;&lt;/p&gt;&lt;p&gt;所以，文章作者究竟是如何得出这一结论的？&lt;/p&gt;&lt;h2&gt;“PyTorch统治学术论文”&lt;/h2&gt;&lt;p&gt;这篇文章的作者&lt;strong&gt;Ari Joury&lt;/strong&gt;，是法国索邦大学的粒子物理学博士生，但对将AI和机器学习方法应用在粒子物理学探索上很感兴趣。&lt;/p&gt;&lt;p&gt;作为一个Python爱好者，她在接触两种框架时察觉到了二者的区别。&lt;/p&gt;&lt;p&gt;好奇哪种框架目前关注度更高，她便对Stack Overflow上3种主流框架Keras、TensorFlow和PyTorch进行了一个统计：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6409921671018277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRuRKEDv5OaicA5pdjcSZK88oRuyibOP0hDnRiahCNt3MDb3zpicng8XTgLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1532&quot;/&gt;&lt;/p&gt;&lt;p&gt;简单来说，就是TensorFlow关注度更高，Keras陷入停滞甚至下降，而PyTorch虽然起步较晚，但这两年一直呈现关注度稳定上升的趋势。&lt;/p&gt;&lt;p&gt;&lt;span&gt;（不过，也有网友认为文章中用Stack Overflow数据做论据，根本不能算是统计框架的“受欢迎度”，反而只能证明这些框架“让人困惑的程度”）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23076923076923078&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRnEfibJXYs9YChzLqQhr9XEW1sYeVnLfqsecNnBic414ibHapeKBZ5NhaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么，为什么会得出“对Python爱好者来说，TensorFlow关注度会继续下降”这一结论？&lt;/p&gt;&lt;p&gt;Ari Joury给出了几大理由。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;其一，PyTorch用起来“更Python”。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Ari Joury表示，她使用Python编写TensorFlow框架的工作量，可能是PyTorch的两倍，此外后者编写代码的感受比TensorFlow更自然。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;其二，PyTorch可用模型更多，且更适合学生和研究者使用。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;据统计，在HuggingFace中，85%的大模型框架是用PyTorch实现的。&lt;/p&gt;&lt;p&gt;剩余的框架中，除了多个框架实现以外，只有8%的大模型框架是通过TensorFlow实现的。&lt;/p&gt;&lt;p&gt;这意味着PyTorch在AI大模型研究者中受欢迎程度更高。&lt;/p&gt;&lt;p&gt;不止大模型，使用PyTorch实现论文研究框架的人，变得越来越多。&lt;/p&gt;&lt;p&gt;这一观点也在Papers with Code网站统计上得到了印证。&lt;/p&gt;&lt;p&gt;在代码开源的那些&lt;strong&gt;论文研究&lt;/strong&gt;中，单从框架使用率来看，这4年来PyTorch占比正急剧上升。&lt;/p&gt;&lt;p&gt;PyTorch从最初和TensorFlow持平，到如今远超TensorFlow、稳定成为使用率第一&lt;span&gt;（占比62%）&lt;/span&gt;的框架，相比之下&lt;strong&gt;TensorFlow占比只有4%&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5154185022026432&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRIbCKTO3S5M0MwcLM5Tnia0KDOE2vklulcgtA61HTrR6GkC8eZsv166g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;其三，PyTorch的生态发展更快。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然目前TensorFlow在生态体系上发展比PyTorch更好，但从PyTorch使用增长情况来看，这一趋势将在不久的将来得到逆转。&lt;/p&gt;&lt;p&gt;当然，TensorFlow自身也有一些不可取代的优势，例如部署更方便&lt;span&gt;（类似TensorFlow Serving和TensorFlow Lite的工具很多）&lt;/span&gt;、以及对其他语言的支持更好等。&lt;/p&gt;&lt;p&gt;毕竟目前对于JavaScript、Java、C++、Julia和Rust等语言来说，TensorFlow还是更好的选择。&lt;/p&gt;&lt;p&gt;PyTorch则基本以Python为中心，即使有个C++ API，但其他语言的整体支持仍然比不上TensorFlow。&lt;/p&gt;&lt;p&gt;因此Ari Joury最终认为，这两个框架的选择，很大程度上取决于用户对Python的喜爱程度。&lt;/p&gt;&lt;p&gt;所以，那些AI大牛们又是怎么站队的呢？&lt;/p&gt;&lt;h2&gt;AI大牛们选择哪些框架？&lt;/h2&gt;&lt;p&gt;除了&lt;strong&gt;Yann LeCun&lt;/strong&gt;一直是PyTorch的深度支持者以外&lt;span&gt;（毕竟是Meta的人）&lt;/span&gt;，不少AI大牛也都表态过自己更看好的框架。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5895424836601307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRelOia4knia6Lqwr2uKGK5gTSBQne7raZMClq5GXBP8gPAsXtTD4N4nYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;/p&gt;&lt;p&gt;至少在几年前TensorFlow推出2.0的时候，“TF2.0和PyTorch谁更好”这个话题就已经开始了。&lt;/p&gt;&lt;p&gt;当时，前Kaggle总裁兼首席科学家、fast.ai创始人&lt;strong&gt;Jeremy Howard&lt;/strong&gt;，更看好PyTorch框架。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5616083009079118&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sR1yxy64iaPAiaBeMYGNHTrYovs5x475icGLVxCTJjP07DlX65JhkbHDCBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot;/&gt;&lt;/p&gt;&lt;p&gt;Keras创始人&lt;strong&gt;François Chollet&lt;/strong&gt;，则在这个话题中投了TensorFlow一票，当时他认为PyTorch会走向下坡路。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRTHhsY5DNV7fs7BBNdMYAiaXaV3BQfANfJtTSozn0rFzD34H1RR0NBSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;566&quot;/&gt;&lt;/p&gt;&lt;p&gt;至少在2020年的时候，他的观点依旧如此：“如果你是PyTorch粉丝，我的工作与你无关。”&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5490956072351422&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEnK6mfBVyQk6HLk25b0sRbI0ECr1wks61oNGzBCFLab5lVxoC8KUaOSwIcGOFqONwLDiav9FXahQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1548&quot;/&gt;&lt;/p&gt;&lt;p&gt;但如今来看，PyTorch依旧保持一个活跃的状态。&lt;/p&gt;&lt;p&gt;你更看好哪个深度学习框架呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考链接：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]https://twitter.com/ylecun/status/1614186881171742720&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[2]https://levelup.gitconnected.com/why-tensorflow-for-python-is-dying-a-slow-death-ba4dafcb37e6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[3]https://paperswithcode.com/trends&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;— &lt;strong&gt;完&lt;/strong&gt; —&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「人工智能」、「智能汽车」微信社群邀你加入！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;欢迎关注人工智能、智能汽车的小伙伴们加入交流群，与AI从业者交流、切磋，不错过最新行业发展&amp;amp;技术进展。&lt;/p&gt;&lt;p&gt;PS. 加好友请务必备注您的姓名-公司-职位噢 ~&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YicUhk5aAGtBIYHY6XEtEedPhTUYAdKev9WH0ibWHOr4IYOvI1T6MNuV9yicoJffRAe0KhiaNwJXX4lhKJNaq8C01g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;点这里&lt;span&gt;👇&lt;/span&gt;关注我，记得标星哦～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzIzNjc1NzUzMw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtCEFSVW5ubo08Zfv1qB5iapricibTBdETkBNtolJxnSUib6UXhjWWz3aib8vETY00P2lKR1uG3qLHicSoWg/0?wx_fmt=png&quot; data-nickname=&quot;量子位&quot; data-alias=&quot;QbitAI&quot; data-signature=&quot;追踪人工智能新趋势，报道科技行业新突破&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;一键三连「分享」、「点赞」和「在看」&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;科技前沿进展日日相见 ~ &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7009346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/g9RQicMD01M0tYoRQT2cMQRmPS5ZDyrrfzeksiay90KaDzlGBH61icqHxmgFKfvfXtVuwTHV740CDLAaXU1LIfZyoJEpYKcRIiaE/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;214&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3c65205b38160304eaaff01a0fc54719</guid>
<title>一个优雅的研发小抄</title>
<link>https://toutiao.io/k/fnnxu2v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100000417&quot; data-ratio=&quot;0.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Tk2JNicusBX7vwHpNW5EYLgrWZ6Z8Y2iapIA3DSocuHkwKqdBMF0pjkf75MomcD5m1Mcp1a7evNHM9jJ7YASdaPQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot; title=&quot;兔子红箭头引导关注&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;开源小分队&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;设为&lt;/span&gt;&lt;span&gt;星标 &lt;/span&gt;&lt;span&gt;精品文章第一时间读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是爱撸码的大叔&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近发现一个很优雅的研发资料搜索项目，可以很方便的找到我们需要的命令及代码的详解 -- &lt;strong&gt;cheat.sh&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9083665338645418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiaATRHOgOIh2QS1VrEf8Pfz3tztoPhoX0f8ZQgydbR6fiaK89sWMAmbCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot;/&gt;&lt;strong&gt;cheat.sh&lt;/strong&gt; 是一个优雅的研发搜索工具，可以在不同平台上使用它，只需要一行命令即可查询到想要的代码或者命令的详解，也可以理解为是我们研发人员的小抄，给我们大脑减减负。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用方法&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以无需安装直接使用，支持浏览器、linux命令行、本地客户端等多种形式。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9001536098310292&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiayNOoNnVECSKQYxTRSK4X5QavyfKr6oFy8RQrCLDia2InaMG5jJpz0fQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;安装&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PATH_DIR=&lt;span&gt;&quot;&lt;span&gt;$HOME&lt;/span&gt;/bin&quot;&lt;/span&gt;  &lt;span&gt;# or another directory on your $PATH&lt;/span&gt;&lt;br/&gt;mkdir -p &lt;span&gt;&quot;&lt;span&gt;$PATH_DIR&lt;/span&gt;&quot;&lt;/span&gt;&lt;br/&gt;curl https://cht.sh/:cht.sh &amp;gt; &lt;span&gt;&quot;&lt;span&gt;$PATH_DIR&lt;/span&gt;/cht.sh&quot;&lt;/span&gt;&lt;br/&gt;chmod +x &lt;span&gt;&quot;&lt;span&gt;$PATH_DIR&lt;/span&gt;/cht.sh&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -s https://cht.sh/:cht.sh | sudo tee /usr/&lt;span&gt;local&lt;/span&gt;/bin/cht.sh &amp;amp;&amp;amp; sudo chmod +x /usr/&lt;span&gt;local&lt;/span&gt;/bin/cht.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意安装需要依赖 rlwrap 模块，可以执行&lt;code&gt;sudo apt install rlwrap&lt;/code&gt;补充即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还支持各种编译器工具，具体安装方法可以去项目中找下，或者直接编译器下搜索相关插件&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5990491283676703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiaVVnfNuXYAWVz8lFMeGy6SZprkwibAEp3gvicaV20W7s0ia95vHMTCMumQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐直接使用官方提供的链接最为简单，可用浏览器或者命令模式下用 &lt;code&gt;curl&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在链接后面可以直接指定语言，问题及相关参数，返回结果中可能会包含命令的使用方法及相关的作者来源等。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiaAFRJtQpyCxEvyxibSFbtldBt3sIAxOqhpfAg1BCiaia3IQDlSNuiaGonTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还支持多款编译器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;vscode&lt;/code&gt; 中用 &lt;code&gt;vscode-snippet&lt;/code&gt; 插件&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6895368782161235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiazvSJrvYD7aIuD79Q1hJQN6BfUo1PdWLWVFvY74WRV15nsBrmKvY0Xw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sublime&lt;/code&gt; 编译器中用 &lt;code&gt;cheat.sh-sublime-plugin&lt;/code&gt; 插件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个小抄工具的搜索结果，可以媲美 Stack Overflow ，查询速度也很快通常也在100ms 以内，而且使用很方便，一行命令即可找到想要的代码或者命令，是我们开发的好帮手。如果看完上面的介绍觉得不错，可以访问下面的项目地址了解更多信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/chubin/cheat.sh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加入开源小分队读者交流群，聊天学习摸鱼为主，不定时会分享一些技术要点和优质学习资源，有一群有趣有料的小伙伴在等你哦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进群方式：&lt;/span&gt;&lt;span data-raw-text=&quot;开&quot; data-textnode-index-1672572993325=&quot;55&quot; data-index-1672572993325=&quot;1164&quot; data-textnode-notemoji-index-1672572993325=&quot;1164&quot; class=&quot;character&quot;&gt;开&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index-1672572993325=&quot;55&quot; data-index-1672572993325=&quot;1165&quot; data-textnode-notemoji-index-1672572993325=&quot;1165&quot; class=&quot;character&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;小&quot; data-textnode-index-1672572993325=&quot;55&quot; data-index-1672572993325=&quot;1166&quot; data-textnode-notemoji-index-1672572993325=&quot;1166&quot; class=&quot;character&quot;&gt;小&lt;/span&gt;&lt;span data-raw-text=&quot;分&quot; data-textnode-index-1672572993325=&quot;55&quot; data-index-1672572993325=&quot;1167&quot; data-textnode-notemoji-index-1672572993325=&quot;1167&quot; class=&quot;character&quot;&gt;分&lt;/span&gt;&lt;span data-raw-text=&quot;队&quot; data-textnode-index-1672572993325=&quot;55&quot; data-index-1672572993325=&quot;1168&quot; data-textnode-notemoji-index-1672572993325=&quot;1168&quot; class=&quot;character&quot;&gt;队&lt;/span&gt;&lt;span&gt; 公众号后台回复&lt;/span&gt;&lt;span data-raw-text=&quot;8&quot; data-textnode-index-1672572993325=&quot;57&quot; data-index-1672572993325=&quot;1177&quot; data-textnode-notemoji-index-1672572993325=&quot;1177&quot; class=&quot;character&quot;&gt;8&lt;/span&gt;&lt;span data-raw-text=&quot;8&quot; data-textnode-index-1672572993325=&quot;57&quot; data-index-1672572993325=&quot;1178&quot; data-textnode-notemoji-index-1672572993325=&quot;1178&quot; class=&quot;character&quot;&gt;8&lt;/span&gt;&lt;span data-raw-text=&quot;8&quot; data-textnode-index-1672572993325=&quot;57&quot; data-index-1672572993325=&quot;1179&quot; data-textnode-notemoji-index-1672572993325=&quot;1179&quot; class=&quot;character&quot;&gt;8&lt;/span&gt;&lt;span&gt;，按提示操作即可进群。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3MjY5MjM2MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoEnsDRy3RmqFUWjwr9otOUrYB8WwPe52P6YoO5re58jyTfiaIXEqBa6VDWewpSic3Y0FX9NSLXiaJwTQ/0?wx_fmt=png&quot; data-nickname=&quot;开源小分队&quot; data-alias=&quot;sourceteam&quot; data-signature=&quot;专注分享 Github、Gitee上最酷、最有趣的开源项目！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XgGs2SeJoGUf1znjxe3hOWK73m0dVibiae6N3qDeicJQ9G4NOkfHjNNQyjHiaoUNXic87NBBOkFg0eQtT3DjLGPU6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;问君能有几多愁，开源项目解千愁，我们下期再见！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;大家的点赞、收藏和评论对大叔非常重要，如文章对你有帮助还请转发支持下，谢谢！&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>