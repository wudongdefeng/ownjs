<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e2437de811620049013bfb0665bb6fea</guid>
<title>推荐 4 个开源工具</title>
<link>https://toutiao.io/k/g30nqhu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;Hi，艾瑞巴蒂，晚上好！今天推荐 4 个登上 GitHub 热搜的开源项目，它们分别是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;1. 炫酷的 UI 工具：glslViewer&lt;/section&gt;&lt;p&gt;2. Textual&lt;/p&gt;&lt;p&gt;3. ToolJet：开源的低代码开发框架&lt;/p&gt;&lt;p&gt;4.  Linux 命令大全搜索工具&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;炫酷的 UI 工具：glslViewer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;glslViewer 是由 @patriciogonzalezvivo 发布的，无需 UI 就能够显示 2D/3D GLSL 着色器，目前在 Github 上已经获得了 3.6k 的 stars。&lt;/p&gt;&lt;p&gt;可以使用 Python 或者任何可以和 glslViewer back/forth communication 的工具来定制喜欢的 UI。接下来，让我们一起欣赏炫酷画面~~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.85875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IaF1PDquP4c4k3IHpbgEkbN8epYUhSqYTYRLm1bE8yYNnTZckND3ghw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/patriciogonzalezvivo/glslViewer&lt;/p&gt;&lt;h1&gt;02&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Textual&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Textual 是由 @Textualize 开源基于 Python 框架搭建，可以创建能够在终端运行的交互式应用程序，作者的设计灵感来源于现代的 Web 开发，目前在 Github 上已经获得了 15.2k 的 stars。&lt;/p&gt;&lt;p&gt;Textual  使用 Rich 来渲染富文本，所以 Rich 可以渲染的任何东西都可以在 Textual 中使用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IBxx8icd0Sd6UE3ianVRBOhJOFDpttQcXeq2d4TqahHCBJJKhrpSFu9nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1879629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IsriaxiaEB2CKwYXUIT7t9CyuJc2LC47G94PHl3TwytgONSCwclTpAopQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/Textualize/textual&lt;/p&gt;&lt;h1&gt;03&lt;/h1&gt;&lt;p&gt;&lt;span&gt;ToolJet：开源的低代码开发框架&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ToolJet 是一个开源的低代码开发框架，拥有丰富的可视化工具，仅需要几步就可以快速构建和部署企业级工具，目前在 Github 已经获得了 14.5k 的 stars。&lt;/p&gt;&lt;p&gt;ToolJet 支持连接多种数据源，包括数据库、云平台、第三方服务接口等 40 多种数据源。在应用层可以发布到 APP、制作数据面板、表单等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5488888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IOa1Yz6lDZOrLLN9aVeyFicafqqujHmgbdbWmibpviaMzbNG9tQsTwzr8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481481481482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3InibyS8fu4ZmeWVXGsx1cuuNLKYT6x6ez3zV4BjYGZjxk1hwNJGKRa2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3IKib0Exr4PZicK7Osgia1DPxJNWmXB4iaia87xIKJ62IeoMiadAr5PZZdsuZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3I6Ly4xecOPqwDblHKT5yK2R2BichG11hULAcpsVwSuR5pJBYM8cgHMzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://github.com/ToolJet/ToolJet&lt;/p&gt;&lt;h1&gt;04&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Linux 命令大全搜索工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Linux Command 是 Linux 命令大全搜索工具，该工具当前搜集了 570 多个 Linux 命令，主要内容包含：Linux 基础命令、Linux 学习资源整理，例如社区网站、相关知识、软件工具、开源镜像站点等，目前在 Github 已经获得 20.8k 的 stars。&lt;/p&gt;&lt;p&gt;该工具支持移动端和 Web 搜索，默认从 A-Z 排序，每条命令都会有注释说明，带有语法、参数及命令示例~逛姐觉得非常贴心，墙裂推荐！！！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35600425079702447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruw9icwlLVIghYgr2ia8bZLP3I3QyHhWaJw8WvcBMWfjViaibVJLsUJE2egib8qFfECBzAfovjTupDHU4Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;p&gt;开源地址：https://wangchujiang.com/linux-command/&lt;/p&gt;&lt;p&gt;&lt;span&gt;历史盘点&lt;/span&gt;&lt;/p&gt;&lt;section&gt;逛逛 GitHub 每天推荐一个好玩有趣的开源项目。历史推荐的开源项目已经收录到 GitHub 项目，欢迎 Star：&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;https:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8091503267973856&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruzicgHPfCeAsrkT2JZwiaOF05zRiaXr2dUukXKGk8CJwfrXALKJ5l0fLpV2abibCYKb7d8B7vNp2u3iccg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1530&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;hr/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;1. &lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498662&amp;amp;idx=1&amp;amp;sn=0087c4f3b79ba3420e917e9b42d45eda&amp;amp;chksm=f9a2286fced5a1794eb9a73d0be7c2e16eaceabf3a0420647c40cb4202bd116d9a15dd57c008&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;GitHub 上有什么好玩的项目？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/em&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247507541&amp;amp;idx=1&amp;amp;sn=79edebda20ac94221aa641090fc9878e&amp;amp;chksm=f9a20d9cced5848a5ba699a819f52907f537e557c10c7bb24bf87b2e0212feecfb06419b2feb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐一款高颜值网易云播放器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;推荐一款高颜值网易云播放器&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;3. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247500031&amp;amp;idx=1&amp;amp;sn=b4349fc85264c255bf9a22e1f25b035a&amp;amp;chksm=f9a21336ced59a20518444a3e2bddb584f6d02266e831546ee5c00935d01d5bd61ed86ab606f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;基于 Spring Boot 的百度云高仿项目&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;4. &lt;/span&gt;&lt;/em&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;盘点百度 4 个牛逼哄哄的开源项目&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxNjg4NDEzNA==&amp;amp;mid=2247498464&amp;amp;idx=1&amp;amp;sn=4f85123d6ca67578ca7bad8f7dc71453&amp;amp;chksm=f9a22929ced5a03ffded2c41fd257d3eb96be02195de3ca66a083177bf5f73e2f418728f7f06&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;172&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;1.005449591280654&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ePw3ZeGRruxW7LMX2Iz5DfjRIbFTS7UROhxibBmicicT0HpjIh1yniaJJibSnLFuicMHRx5NEdiaOh2OOACfr6MvR38ibQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2638db18b14d1c0f423ceab33671904d</guid>
<title>认识区块链，认知区块链——Web3</title>
<link>https://toutiao.io/k/78f76n5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;MavenTalk&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;mavenTalk&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;创业者，关注人与自然的和谐成长.&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4c63ce98ede1e65dc758eb187e32beb</guid>
<title>无 Sidecar 又成为新的趋势了？</title>
<link>https://toutiao.io/k/bg297mu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Istio的实验性环境网格（Ambient Mesh）号称能大大降低运营复杂性，但Linkerd的拥护者们则认为Sidecar本身并不是问题的关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种新的Istio服务网格架构抛弃了Sidecar代理，凭借显著降低运营复杂性的承诺引得企业IT专业人士纷纷侧目。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但竞争对手Linkerd项目的支持者则认为，导致复杂性难题的核心并不是Sidecar架构——而是Envoy代理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分布式应用程序环境中的服务网格网络方法最早出现在2016年，源自专为虚拟机环境设计的Linkerd 1.0版本。由谷歌、IBM和Lyft支持的Istio则于2017年发布，主要面向的是Kubernetes容器编排环境。Linkerd 2.0紧随其后发布，也开始重点关注Kubernetes。从那时起，容器编排器的日益普及扩大了服务网格的应用范围，着力将应用层和开发者从复杂的微服务网络负担当中解放出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直到今年，这些服务网格的基本架构设计都是相同的——两者都使用一种称为Sidecar代理的特殊容器来将网络管理从应用程序当中剥离出来。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这些Sidecar代理与应用程序密切相关，作为各个Kubernetes Pod的组成部分。与传统网络相比，这种紧密性也让我们能对应用程序路由和监控进行更细粒度的控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但随着服务网格在大规模环境中得到广泛应用，Sidecar代理的局限性也凸显了出来。&lt;/span&gt;&lt;span&gt;在对性能高度敏感的环境中，将容器绑定到每个应用程序可能会产生难以承受的开销。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因为期间需要重新启动所有Sidecar，这会使服务网格的升级困难重重，可能严重影响应用程序的可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;应用程序容器也可能与Sidecar容器不同步，这会产生更多潜在的可靠性问题。&lt;/span&gt;&lt;span&gt;在应用程序可能需要服务网格的某些功能的环境中，管理庞大的Sidecar可能产生难以承受的负担。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;以双向TLS认证（简称mTLS）为例，这些功能发生在开放系统互连模型的较低层——特别是L4层——但并不需要L7层上的完整应用级精细过滤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Istio Ambient Mesh项目目前处于实验性阶段，由Google和Solo.io的工程师在今年9月份开源。其中包含了一个新的架构，维护人员称它通过服务网格Sidecar回避了这些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Ambient Mesh不会将服务网格的所有功能捆绑到随每个应用程序一起部署的Sidecar中，而是将代理分解为一组两个共享资源，称为DaemonSet，分别部署在每个Kubernetes集群上。IT管理员可以使用相同类型的现有Istio配置文件和Kubernetes应用程序文件，来指示应用程序是否需要L4层或L7层路由功能。&lt;/span&gt;&lt;span&gt;Ambient Mesh中的整合代理将据此执行流量路由，而不需要为每个Pod配备一个Sidecar。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vHicVZXtcAzBfgThmkl68angq1vwxZdMyfJY7soV7ibV3hIWPibIKICAWLqgIPxZ339l7kKzns084QZKZtibl8Msgw/640?wx_fmt=jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这种新方法才刚刚起步，但已经有一些Istio用户表示很想一探究竟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“这太棒了，我们将尽快采用，”Constant Contact公司首席软件工程师David Ortiz在本周的一次在线采访中说。“&lt;/span&gt;&lt;span&gt;它大大简化了Istio的操作，特别是在升级方面。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一位KubeCon与会者表示，他计划在Ambient Mesh成熟时对其进行仔细评估，并表达了浓厚的兴趣。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有线电视提供商Comcast云服务执行总监Greg Otto本周在接受采访时说：“Sidecar确实发挥过重要的作用，但我们也很希望能以不同的思路服务和扩展L7层和L4层。在边缘场景中，我们非常关注L7层[过滤]，但并不想因此影响到整个[网络]，单独交给L4层[路由]明显更适合。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Otto说，虽然Sidecar代理出于安全目的提供了最严格的服务分离，但Istio的Envoy代理中的大多数关键常见漏洞披露（CVE）都源自L7层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“在不需要[L7层过滤]的地方，最好能先把它放一放，”他说。“这样即使存在CVE，我们的攻击面也会小得多。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linkerd主动对线：问题不在于Sidecar，而在于Envoy&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;根据Linkerd缔造者兼Buoyant.io首席执行官William Morgan的说法，还有另一种方法可以减少L7层的关键漏洞以及与Sidecar相关的大部分资源开销：直接弃用Envoy。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“归根结底，Sidecar实际上非常简单——它们在操作上非常简单，不难理解，而且故障和安全域非常清楚，”Morgan说。“&lt;/span&gt;&lt;span&gt;问题不在于Sidecar——而是由于Enovy的存在，我们不得不面对一个巨大、多用途、资源匮乏且难以操作的代理。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;过去，对Envoy的支持是Istio相对于Linkerd的一个独特卖点，这也使其成为广受欢迎的云原生计算基金会毕业项目。但由Morgan领导的Linkerd维护者则坚持使用他们自己的代理，该代理专为服务网格而设计，代码库规模和资源需求都比Envoy更小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，一位企业Linkerd用户表示，他认为问题的关键不是打造出无Sidecar服务网格，毕竟Sidecar本身跟简单和透明并不矛盾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;丹麦数字金融服务公司Lunar首席平台架构师Kasper Nissen本周接受采访时表示：“从我们的角度来看，Sidecar既简单又易于理解——它与我们使用的其他容器技术没什么区别。一年半前，我们默认使用全服务网格，相应的资源消耗可能也就增加了10%。跟我们获得的mTLS和详尽可见性效果相比，这并不算多。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Nissen说，他也遇到过Sidecar代理和Lunar使用的Humio日志分析应用程序间不同步的问题。如果Sidecar重新启动，该服务没有时间转移其本地数据，于是Nissen团队只能“设置超时、听天由命”，坐视部分数据因此丢失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然而，Morgan和Nissen坚持认为，&lt;/span&gt;&lt;span&gt;Sidecar同步问题的根源在于Kubernetes网络的一个更深层次的问题，这个问题在开源社区三年来一直没有解决。&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;默认情况下，没有办法确保各种容器（无论是由Linkerd等服务使用的短期init容器还是常规应用程序容器）按特定顺序启动和停止。2019年曾有一项Kubernetes增强提案尝试解决这个问题，但被拒绝了；社区中的讨论仍在继续，但情况并没有改变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“如今一切服务都在作为Sidecare进行交付，所以这个问题应该由Kubernetes方面负责解决。”Nissen说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Morgan也认为，在Kubernetes中解决这个问题才是根治Sidecar同步性挑战的最佳方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;“云原生世界向来以探索新功能（而非修复旧设计）为先，所以大家对这类提议的兴趣相对不大。&lt;/span&gt;&lt;span&gt;但Sidecar将继续成为服务网格的未来&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，”Morgan说。“我们当然知道Sidecar有缺陷，可正确答案应该是最终通过Kubernetes的调整来解决，而不是大幅改变架构、向基础设施操作中引入更复杂的机制。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cfe674fdf8551e91f7b0755ad8fd5a2d</guid>
<title>Go try 新提案靠谱吗？想简化错误处理了</title>
<link>https://toutiao.io/k/db1nkru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在近日新的 try 提案《&lt;span&gt;proposal: Go 2: error handling: try statement with handler&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;》在社区引发了热议，再战社区！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天煎鱼和大家一起打开来看看，这能把 Go 错误处理机制给掀开重整不。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来自 PingCAP 的提案作者 @Greg Weber 会干这事基于两个因素，一个是在《&lt;span&gt;Go Developer Survey 2022 Q2 Results&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;》中明确提到。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7097591888466414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4gcm1jvybZFOaG3fAVrVL9nBB80HwohTT9zwgq2oqbZ0BVNE69b1IwjpGTroo8G4PRO5RqIxXZluQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1578&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 Go1.18 泛型的发布，原先矛盾最深的泛型已经得到一个初步的解决方案。在社区调研上，开发者在使用 Go 时面临的最大挑战已经转移到了错误处理上，需要投入精力去 “解决” 它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个因素就是众所皆知的，Go 错误处理代码比较繁琐，常被工程师们戏称一个 Go 工程里有 30% 都 if err = nil。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;_, err := f()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;_, err = r()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;_, err = w()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望让其更优雅。也有许多小伙伴认同这个设计，确实是简单、直观的处理，在社区形成了角力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;try-handler 提案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次提案中所提到的解决方案，是增加一个新语句 try ，以此达到简洁的错误处理的作用，让 if err != nil 的处理丝滑起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try err, handler&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; handler(err)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数中可以如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(args...)&lt;/span&gt; &lt;span&gt;(rtype1, rtypes..., rtypeN, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    try err, handler&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(args...)&lt;/span&gt; &lt;span&gt;(rtype1, rtypes..., rtypeN, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Zero(rtype1), Zeros(rtypes...)..., Zero(rtypeN), handler(err)&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以只针对 if err != nil 处理。如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;try err&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译后生成的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不会调用不存在的 handler 进行处理，将会直接返回。三行（if err != nil 的逻辑）直接变 3 个单词（try）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不想写函数，也可以直接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;x, err := f()&lt;br/&gt;try err, fmt.Errorf(&lt;span&gt;&quot;f fail: %w&quot;&lt;/span&gt;, err)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 defer+try 的场景可以如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CopyFile&lt;/span&gt;&lt;span&gt;(src, dst &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; try &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;copy %s %s: %w&quot;&lt;/span&gt;, src, dst, err)&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参是比较灵活的，作者希望它是泛型，这样能够适配各种场景的要求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;示例和实践&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对本提案，原作者给出了各类使用场景的示例。如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// This helper should be defined in the fmt package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handlew&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, args ...any)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  args = &lt;span&gt;append&lt;/span&gt;(args, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fmt.Errorf(format+&lt;span&gt;&quot;: %w&quot;&lt;/span&gt;, args...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// This helper should be defined in the fmt package&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handlef&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, args ...any)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  args = &lt;span&gt;append&lt;/span&gt;(args, err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; fmt.Errorf(format+&lt;span&gt;&quot;: %v&quot;&lt;/span&gt;, args...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;valAndError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;, fmt.Errorf(&lt;span&gt;&quot;make error&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newGo&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    x, err := valAndError()&lt;br/&gt;    try err&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Common formatting functions will already be provided&lt;/span&gt;&lt;br/&gt;    i := &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;    x, err = valAndError()&lt;br/&gt;    try err, Handlew(&lt;span&gt;&quot;custom Error %d&quot;&lt;/span&gt;, i)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Using a custom error type&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// For convenience the error type can expose a method to set the error&lt;/span&gt;&lt;br/&gt;    x, err = valAndError()&lt;br/&gt;    try err, TheErrorAsHandler(i)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; TheError &lt;span&gt;struct&lt;/span&gt;{&lt;br/&gt;    num &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    err error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t TheError)&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fmt.Sprintf(&lt;span&gt;&quot;theError %d %v&quot;&lt;/span&gt;, t.num, t.err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TheErrorAsHandler&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err)&lt;/span&gt; &lt;span&gt;TheError&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;TheError&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; theError{ num: i, err: err }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在日常的 Go 工程中，提案作者认为 CopyFile 函数是新提案语句的一种很好的实践。为此基于 try-handler 进行了一版改造和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// This helper can be used with defer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(err *error, handler &lt;span&gt;func&lt;/span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    *err = handler(err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;CopyFile&lt;/span&gt;&lt;span&gt;(src, dst &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; handle(&amp;amp;err, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;copy %s %s: %w&quot;&lt;/span&gt;, src, dst, err)&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    r, err := os.Open(src)&lt;br/&gt;    try err&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; r.Close()&lt;br/&gt;&lt;br/&gt;    w, err := os.Create(dst)&lt;br/&gt;    try err, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(err error)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            os.Remove(dst) &lt;span&gt;// only if Create fails&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; fmt.Errorf(&lt;span&gt;&quot;dir %s: %w&quot;&lt;/span&gt;, dst, err)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; w.Close()&lt;br/&gt;&lt;br/&gt;    err = io.Copy(w, r)&lt;br/&gt;    try err&lt;br/&gt;    err = w.Close()&lt;br/&gt;    try err&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入 try-hanlder 后，能够做到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;插入错误的返回语句，进行机制预设。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在返回错误之前将错误处理函数组合在一起，便于后续的处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个新提案中，一旦实施，就可以减少如下代码的编写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码编写上会节省一些行数，且可以为错误处理机制引入一些新的 ”操作“，这是该提案的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是从 Go 开发者的角度而言，会引入一些新的副作用，例如：初学者的学习成本、Go 工具链的改造、程序理解的复杂度增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外新的语句，似乎比较难与 Go1.13 引入的 error.Is 和 As 有较好的相关联性。如果是做一个第三方用户库引入倒可以，但若是作为标准进入 Go 源代码中，似乎又有些格格不入（提案作者希望进入）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了那么多提案，Go 错误处理机制的 ”升级“，似乎陷入了手心手背都是肉的阶段...&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;proposal: Go 2: error handling: try statement with handler: &lt;em&gt;https://github.com/golang/go/issues/56165&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Go Developer Survey 2022 Q2 Results: &lt;em&gt;https://go.dev/blog/survey2022-q2-results&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>912e60a13dffef733e08bffd6fa38523</guid>
<title>Flink 反压原理深入浅出及解决思路</title>
<link>https://toutiao.io/k/cnvz5r1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. 前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Flink 是一个分布式大数据处理引擎，可对有限数据流和无限数据流进行有状态或无状态的计算，能够部署在各种集群环境，对各种规模大小的数据进行快速计算。既然是对流式数据进行处理，那么就要面临数据在流动计算时，上下游数据通信以及数据处理速度不一致所带来的问题。&lt;br/&gt;本文先从「生产者-消费者模式」的角度介绍了Flink中的数据传输，从而引出了「反压」的概念。接着介绍了Flink在V1.5前「基于TCP的反压机制」以及V1.5后「基于Credit的反压机制」分别如何实现网络流控。最后针对一个反压案例进行分析，介绍了如何进行反压定位和资源调优，并展示了调优结果。&lt;br/&gt;希望在阅读完本文后，读者可以深入理解Flink节点反压的概念以及背后的原理，在遇到反压场景时，能够快速定位瓶颈点，并拥有一套基本的调优思路。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2. 从Flink数据传输看「反压」&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 生产者-消费者模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flink作业在运行状态时，数据会在各个TaskManager（TM）之间流动交换，上游TM到下游TM的数据传输，可以简单看作是生产者&amp;amp;消费者模式。&lt;br/&gt;下面将会介绍 Producer 和 Consumer 在吞吐率&lt;strong&gt;不同&lt;/strong&gt;时，导致的普遍性问题。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.759656652360515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybwtm3boGkxFwnF811Jz3tzophIYg1n06lNfcOYlFiaFugJKkxGxS7jK1QRTdxq0iax9phYIIlLe7G8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;932&quot;/&gt;&lt;br/&gt;假设 Producer的吞吐率为 2 MB/s，Consumer是 1 MB/s ，此时上游产生数据的速度 大于 下游处理数据的速度，且假设两端都存在Buffer，用来暂时存放数据，再假设底层网络传输速度为 2 MB/s。&lt;br/&gt;若Buffer有界，经过5s后，Consumer 端的 Receive Buffer 会被打满，后面新到达的数据就只能被丢弃掉；但在实际场景中，通常生产者在发送数据前会检查 buffer 的可用状态，若 buffer 处于不可用状态，则不会发送新的数据。&lt;br/&gt;面对上述问题，需要有一种动态反馈的机制，根据数据实时传输的情况，动态调整数据的发送速率和接收速率，从而更好的进行网络传输。&lt;br/&gt;动态反馈可以分为以下两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;正向反馈：当Producer的发送速率 小于 Consumer的接受速率时，需要通知 Producer可以&lt;strong&gt;提高&lt;/strong&gt;发送速率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负向反馈：当Producer的发送速率 大于 Consumer的接受速率时，需要通知 Producer可以&lt;strong&gt;降低&lt;/strong&gt;发送速率&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 何为「反压」&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上小节的介绍，我们了解到，当上游生产数据和下游消费数据速率不一致时，会导致一些问题，这时候需要一种「动态反馈」机制，下面引入「反压」的概念&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;「反压」是流式系统中关于数据处理能力的动态反馈机制，并且是从下游到上游的反馈，一般发生在实时数据处理的过程中，上游节点的生产速度大于下游节点的消费速度的情况下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将会介绍在Flink中，TaskManager之间如何传输数据，看看 Flink 中数据传输的生产者-消费者模式的具体形式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 TaskManager之间的数据传输&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;下图来源于Apache Flink (http://flink.apache.org) 图中相关概念： ResultPartition（RP） ResultSubPartition（RS） InputChannel（IC） InputGate（IG）&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzo2X9JBhLLAwNoxo5K21IibdMIzkZEk709qichxEj7ibYKmKQVeDHqR1Mcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;MapDriver 将数据传递给 RecordWriter，之后经由 ChannelSelector 做数据分发，将数据传递到一个或多个 RecordSerializer 做序列化操作，转换为二进制流。ChannelSelector 的分发有两种模式，一种是广播模式，会将数据发送到每个序列化器进行处理，另一种是按某种逻辑进行选择，比如计算数据的hash，然后路由到命中的序列化器。&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * The {&lt;span&gt;@link&lt;/span&gt; ChannelSelector} determines to which logical channels a record should be written to.&lt;br/&gt; *&lt;br/&gt; * &lt;span&gt;@param&lt;/span&gt; &amp;lt;T&amp;gt; the type of record which is sent through the attached output gate&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ChannelSelector&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;IOReadableWritable&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Initializes the channel selector with the number of output channels.&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; numberOfChannels the total number of output channels which are attached to respective&lt;br/&gt;     *     output gate.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;setup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; numberOfChannels)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Returns the logical channel index, to which the given record should be written. It is illegal&lt;br/&gt;     * to call this method for broadcast channel selectors and this method can remain not&lt;br/&gt;     * implemented in that case (for example by throwing {&lt;span&gt;@link&lt;/span&gt; UnsupportedOperationException}).&lt;br/&gt;     * &lt;br/&gt;     * 选择模式&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; record the record to determine the output channels for.&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; an integer number which indicates the index of the output channel through which the&lt;br/&gt;     *     record shall be forwarded.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;selectChannel&lt;/span&gt;&lt;span&gt;(T record)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Returns whether the channel selector always selects all the output channels.&lt;br/&gt;     * 广播模式&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true if the selector is for broadcast mode.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isBroadcast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;序列化输出的二进制流数据会被存放在buffer块中，之后 BufferWriter 会将这些buffer块写入到指定的ResultPartition（RP）中。RP中又包含多个子分区（ResultSubpartitions，如RS1，RS2），每个子分区只会存放特定消费者需要的数据。由图可见，一个 buffer 已经被 BufferWriter 放入了 RS2 中，这时 RS2 这个子分区已经变成了可被消费状态，接下来会通知 JobManager。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ResultPartition&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ResultPartitionWriter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionID partitionId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 该分区的类型，定义要使用的具体子分区实现 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionType partitionType;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionManager partitionManager;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** Subpartition 的个数 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numSubpartitions;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// - Runtime state --------------------------------------------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** ResultPartition 中的缓冲区 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; BufferPool bufferPool;&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;JobManager 会寻找 RS2 的消费者，通知TaskManager2，该数据块可以消费了。接着InputChannel会接收到该消息（图中是 IC1，用于接收上一步中存放到 RS2 中的 buffer，且 InputChannel 和 ResultSubpartition 是1-1对应的，一个 InputChannel 接收一个 ResultSubpartition 的输出），并通知 RS2 初始化网络连接，可以开始传输数据了。然后 RS2 通过 TaskManager1 的网络栈基于 Netty 进行数据传输，该网络连接是在各个TaskManager 之间长期存在的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * An input channel consumes a single {&lt;span&gt;@link&lt;/span&gt; ResultSubpartitionView}.&lt;br/&gt; *&lt;br/&gt; * &amp;lt;p&amp;gt;For each channel, the consumption life cycle is as follows:&lt;br/&gt; *&lt;br/&gt; * &amp;lt;ol&amp;gt;&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #requestSubpartition()}&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #getNextBuffer()}&lt;br/&gt; *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #releaseAllResources()}&lt;br/&gt; * &amp;lt;/ol&amp;gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InputChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/** 输入通道的信息，以便在任务中全局识别它. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; InputChannelInfo channelInfo;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 此通道消费接收的RP编号. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ResultPartitionID partitionId;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/** 此通道使用的子分区的索引. */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; consumedSubpartitionIndex;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SingleInputGate inputGate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 Netty 的网络传输，buffer块被传递到 TaskManager2 网络栈，之后由 ConnectionManager 来控制将 buffer数据传递到指定的 InputChannel 中，并进入InputGate，最终进入反序列化器 （RecordDeserializer）将buffer中的数据还原成制定类型的对象，最后传递给接收数据的task。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这是典型的生产者-消费者模式，上游生产数据到 &lt;strong&gt;ResultPartition&lt;/strong&gt;（由&lt;strong&gt;ResultSubpartition&lt;/strong&gt;构成） 中，下游通过 &lt;strong&gt;InputGate&lt;/strong&gt; （由&lt;strong&gt;InputChannel&lt;/strong&gt;构成）消费数据。不同的 task 可能在同一个 TaskManager 中运行，此时这些task可以看做是同一个 TaskManager进程中的不同线程，可以在本地进行数据交换；不同的 task 也可能在不同的 TaskManger 中运行，此时就要通过TaskManager 间的网络通信进行数据交换。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Flink网络流控&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍了 Flink 基于生产者-消费者模式的数据传输方式，且我们了解到，流式系统在处理数据时，如果上下游处理速度不一致，会出现数据堵塞等问题。这时候需要一种动态反馈的机制，根据数据实时传输的情况，动态调整数据的发送速率和接受速率，从而更好的进行网络传输，即「网络流控」。&lt;br/&gt;本章将会介绍 Flink 在V1.5前后进行网络流控的两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 TCP 的反压机制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 Credit 的反压机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 基于TCP的反压机制&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们先来看看Flink在V1.5前是如何做动态反馈，进而实现网络流控的。 基于TCP的反压机制底层依赖于「&lt;strong&gt;TCP的滑动窗口算法&lt;/strong&gt;」，本章不会赘述，而会重点描述反压现象的传递过程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5675487465181058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoZVcXz9n4ribelbIS5wMVQJgDs6fLdJMmfQ6PnnFGO6htRDfGkaTY7mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2872&quot;/&gt;&lt;br/&gt;由上图可见，每个TaskManager中都会有个被内部所有task共享的 Network Buffer Pool，它从堆外内存申请内存资源，之后可以为每个 ResultSubpartition 创建 Local Buffer Pool。&lt;br/&gt;假设生产者的速率是 2 MB/S，消费者的速率是 1 MB/S。下面会描述，由于速度不匹配，各层buffer被打满，从而引起反压的过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1 InputChannel Buffer 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一段时间后，会达到下图的状态，此时 InputChannel 暂时被打满，需要向 Local Buffer Pool 申请新的 buffer，此时 Local Buffer Pool 里的一个 buffer 被标记为 Used。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5657407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoZNxk2NTfpPAb0xvk5waLUuyDHMS0wPEOxwNuGdgbiagkkRA6aNx2qcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.2 Consumer Local Buffer Pool 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上下游处理速率不一致，一段时间过后，InputChannel 将 Local Buffer Pool 的内存申请完了，此时 Local Buffer Pool 的所有 buffer 都被标记为 Used，但还可以向 Network Buffer Pool 继续申请 buffer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzorQHpEQY8elAH6iaI8EFxv3zrFbZgHftiaQkfxOEnzCnQLajXn0VNZdNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.3 Consumer Network Buffer Pool 打满&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渐渐 Network Buffer Pool 也没有可用 buffer 了，全都变成了 Used，此时消费者无法再读取数据了，Netty也不会接收Socket的数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5638002773925104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzojwfU3NoaqdZS74b8PHg6VAOYNm2cB817iaFPAkkLcanocdNtZVuAqoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2884&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.4 socket停止数据传输&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者的 socket 被用尽，此时会将 windows=0 发送给生产者的发送端（TCP滑动窗口），此时socket会停止发送数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5615120274914089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoTqIl1xcGl3u5Wsva2j325fMnoahkgDaXr51MIBIyURPL7Cdbb8SAVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2910&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.5 Netty不可写&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久socket buffer用尽，Netty检测到后会停止向socket发送数据，之后由于 RecordWriter 还在发送数据，这些数据会堆积在Netty Buffer中，到一定程度后，Netty会变为不可写状态，ResultSubpartition 发送数据前都会检测 Netty是否可写，此时 ResultSubpartition 会停止向 Netty 中写数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzomVvyrm8NmAHPhia3k22ylb3pT6ib6fuS0iaqLsniaEpAg3siaicYgkNDswJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.5 RecordWriter 停止写数据&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ResultSubpartition 的空间很快被用尽，直到 Local Buffer Pool 和 Network Buffer Pool 的 buffer都被打满后，RecordWriter 就会停止写数据，至此，完成了跨TaskManager的反压。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5775862068965517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzoORyE3LJliavljibAhXU1FYYv29a8jicjnXPc3jXwB0ic19fAEibCkUWaEaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2784&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.6 TCP反压机制的问题&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个 Task 的缓冲池用尽之后，网络连接就处于阻塞状态，上游 Task 无法产出数据，下游 Task 无法接收数据，也就是我们所说的「反压」状态。&lt;br/&gt;但是基于TCP的反压机制有以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个 TaskManager 内通常会有多个Task，它们底层会复用同一个Socket，一旦某个Task反压导致Socket阻塞不可用，即便其它 Task 关联的缓冲池仍然存在空余，但也都无法向 TCP 连接中写入数据或者从中读取数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于底层TCP流控的反压机制，从 ResultPartition 到 Netty 到 Socket整条链路较长，会导致反压行为不够灵敏，动态反馈过程比较迟钝。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 基于Credit的反压机制&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.1 算法介绍&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，Flink 1.5 重构了网络栈，引入了“基于信用值的流量控制算法”（Credit-based Flow Control），即在Flink层实现网络流控，缩短反压链路，且确保 TaskManager 之间的网络连接始终不会处于阻塞状态。&lt;br/&gt;Credit-based Flow Control 的思路其实很简单，它在接收端和发送端之间建立一种类似“信用评级”的机制，发送端向接收端发送的数据永远不会超过接收端的信用值的大小。对于 Flink来说，信用值就是接收端TaskManager 可用的 Buffer 的数量，这样就可以保证发送端 TaskManager 不会向 TCP 连接中发送超出接收端缓冲区可用容量的数据。&lt;br/&gt;基于Credit 实现流量控制 的具体机制为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当发送端发送 buffer 的时候，它把当前堆积数据的 buffer 数量（backlog size）告知接收端；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收端将根据发送端堆积的数量来申请 buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一个 credit）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当接收端分配了 N 点 Credit 给发送端，表明它有 N 个空闲的 buffer 可以接收数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当发送端获得了 N 点 Credit，表明它可以向网络中发送 N 个 buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有在 Credit &amp;gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.2 反压过程&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如图所示，当前 ResultPartition 已经堆积了两个 Buffer 的数据，所以在底层网络传输会将 要传输的数据以及backlog size = 2 发送至接收端；下游收到了之后，会计算获得credit信用值，此时接收端共剩下 6 个buffer， 接收速率是 1 个buffer，backlog size 为2个buffer， credit 为 3 个buffer（6-1-2 = 3）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzozXDYvIgXxiaVP60TgL4299NSj81vJJcUxsjdAZsCQ4uS6Hmtiauwt7ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;下图中，发送端发送的 backlog size = 2，但接收端的各级Buffer已经打满，所以下游向上游返回的 credit 为0，说明由于上下游处理速率不一致，导致了下游暂时无法处理数据；此时 ResultPartition 就不会向 Netty 传输数据，数据很快就会积压打满，从而达到反压的效果；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5556309362279511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybwtm3boGkxFwnF811Jz3tzo7qaODsoAg3gfBhVCa5Tm2Q54CgvZpHoDAbBQ7dgDQJF9BZ1DGPNS7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2948&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3.2.3 优化点&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于Credit算法的反压机制，解决了两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以直接在 ResultPartition 层实现反压，而不用将压力流经过多层传递，层层反馈。提高了反压效率，降低了延迟；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不会把底层socket打满，从而阻碍网络数据传输，不会让单个 Task 的瓶颈成为整个TaskManager 的瓶颈；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. 小结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文首先介绍了Flink中跨TaskManager的数据传输，引出了「生产者-消费者模式」在吞吐率&lt;strong&gt;不同&lt;/strong&gt;时，导致的普遍性问题，以及「&lt;strong&gt;动态反馈&lt;/strong&gt;」机制的必要性，并明确了「&lt;strong&gt;反压&lt;/strong&gt;」的概念，「&lt;strong&gt;反压&lt;/strong&gt;」是流式系统中关于处理能力的动态反馈机制，并且是从下游到上游的反馈。&lt;br/&gt;接着介绍了Flink的网络流控机制，Flink在V1.5前，「&lt;strong&gt;基于TCP的滑动窗口机制&lt;/strong&gt;」实现反压，但是存在单个Task反压会导致整个TaskManager共享的Socket不可用，而且反压链路较长，动态反馈机制较为迟钝等缺点。Flink在V1.5后，采用「&lt;strong&gt;基于Credit算法的反压机制&lt;/strong&gt;」，在ResultPartition层实现反压，提高了反压效率。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;5. 参考资料&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks&lt;br/&gt;https://www.ververica.com/blog/how-flink-handles-backpressure&lt;br/&gt;https://docs.google.com/document/d/1chTOuOqe0sBsjldA_r-wXYeSIhU2zRGpUaTaik7QZ84/edit#heading=h.pjh6mv7m2hjn&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>