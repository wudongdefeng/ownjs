<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fc5fa1483c73677482f107eb3de933c2</guid>
<title>面试必备：kafka夺命连环11问</title>
<link>https://toutiao.io/k/5bs6dks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;大家好，我是田螺。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;年后应该很多小伙伴找工作，所以给大家来个kafka的11连问，加油~&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;说说你对kafka的理解&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka是一个流式数据处理平台，他具有消息系统的能力，也有实时流式数据处理分析能力，只是我们更多的偏向于把他当做消息队列系统来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说按照容易理解来分层的话，大致可以分为3层：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一层是&lt;span&gt;Zookeeper&lt;/span&gt;，相当于注册中心，他负责kafka集群元数据的管理，以及集群的协调工作，在每个kafka服务器启动的时候去连接到Zookeeper，把自己注册到Zookeeper当中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二层里是kafka的核心层，这里就会包含很多kafka的基本概念在内：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;record&lt;/span&gt;：代表消息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;topic&lt;/span&gt;：主题，消息都会由一个主题方式来组织，可以理解为对于消息的一个分类&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;producer&lt;/span&gt;：生产者，负责发送消息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;consumer&lt;/span&gt;：消费者，负责消费消息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;broker&lt;/span&gt;：kafka服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;partition&lt;/span&gt;：分区，主题会由多个分区组成，通常每个分区的消息都是按照顺序读取的，不同的分区无法保证顺序性，分区也就是我们常说的数据分片sharding机制，主要目的就是为了提高系统的伸缩能力，通过分区，消息的读写可以负载均衡到多个不同的节点上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Leader/Follower&lt;/span&gt;：分区的副本。为了保证高可用，分区都会有一些副本，每个分区都会有一个Leader主副本负责读写数据，Follower从副本只负责和Leader副本保持数据同步，不对外提供任何服务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;offset&lt;/span&gt;：偏移量，分区中的每一条消息都会根据时间先后顺序有一个递增的序号，这个序号就是offset偏移量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Consumer group&lt;/span&gt;：消费者组，由多个消费者组成，一个组内只会由一个消费者去消费一个分区的消息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Coordinator&lt;/span&gt;：协调者，主要是为消费者组分配分区以及重平衡Rebalance操作&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Controller&lt;/span&gt;：控制器，其实就是一个broker而已，用于协调和管理整个Kafka集群，他会负责分区Leader选举、主题管理等工作，在Zookeeper第一个创建临时节点/controller的就会成为控制器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三层则是存储层，用来保存kafka的核心数据，他们都会以日志的形式最终写入磁盘中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012195&quot; data-ratio=&quot;0.3265799818566677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9uI83AibbE0k5icKprnWKsAicyJ5gUGPSVoK4WXAT808pKOlc5a2RT7fhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3307&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列模型知道吗？kafka是怎么做到支持这两种模型的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于传统的消息队列系统支持两个模型：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;点对点：也就是消息只能被一个消费者消费，消费完后消息删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布订阅：相当于广播模式，消息可以被所有消费者消费&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也说到过，kafka其实就是通过Consumer Group同时支持了这两个模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说所有消费者都属于一个Group，消息只能被同一个Group内的一个消费者消费，那就是点对点模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每个消费者都是一个单独的Group，那么就是发布订阅模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，Kafka通过消费者分组的方式灵活的支持了这两个模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;能说说kafka通信过程原理吗？&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先kafka broker启动的时候，会去向Zookeeper注册自己的ID（创建临时节点），这个ID可以配置也可以自动生成，同时会去订阅Zookeeper的&lt;code&gt;brokers/ids&lt;/code&gt;路径，当有新的broker加入或者退出时，可以得到当前所有broker信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者启动的时候会指定&lt;code&gt;bootstrap.servers&lt;/code&gt;，通过指定的broker地址，Kafka就会和这些broker创建TCP连接（通常我们不用配置所有的broker服务器地址，否则kafka会和配置的所有broker都建立TCP连接）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随便连接到任何一台broker之后，然后再发送请求获取元数据信息（包含有哪些主题、主题都有哪些分区、分区有哪些副本，分区的Leader副本等信息）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着就会创建和所有broker的TCP连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后就是发送消息的过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者和生产者一样，也会指定&lt;code&gt;bootstrap.servers&lt;/code&gt;属性，然后选择一台broker创建TCP连接，发送请求找到&lt;span&gt;协调者&lt;/span&gt;所在的broker&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后再和协调者broker创建TCP连接，获取元数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据分区Leader节点所在的broker节点，和这些broker分别创建连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后开始消费消息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012194&quot; data-ratio=&quot;0.4699738903394256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9fHysciaghG1XMyfNwGTfRD3zxEW8QSglZtc5jz6tU85Ge7pD3b8M1aA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2298&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那么发送消息时如何选择分区的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有两种方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;轮询，按照顺序消息依次发送到不同的分区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随机，随机发送到某个分区&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果消息指定key，那么会根据消息的key进行hash，然后对partition分区数量取模，决定落在哪个分区上，所以，对于相同key的消息来说，总是会发送到同一个分区上，也是我们常说的消息分区有序性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很常见的场景就是我们希望下单、支付消息有顺序，这样以订单ID作为key发送消息就达到了分区有序性的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有指定key，会执行默认的轮询负载均衡策略，比如第一条消息落在P0，第二条消息落在P1，然后第三条又在P1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，对于一些特定的业务场景和需求，还可以通过实现&lt;code&gt;Partitioner&lt;/code&gt;接口，重写&lt;code&gt;configure&lt;/code&gt;和&lt;code&gt;partition&lt;/code&gt;方法来达到自定义分区的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;好，那你觉得为什么需要分区？有什么好处？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题很简单，如果说不分区的话，我们发消息写数据都只能保存到一个节点上，这样的话就算这个服务器节点性能再好最终也支撑不住。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上分布式系统都面临这个问题，要么收到消息之后进行数据切分，要么提前切分，kafka正是选择了前者，通过分区可以把数据均匀地分布到不同的节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区带来了负载均衡和横向扩展的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送消息时可以根据分区的数量落在不同的Kafka服务器节点上，提升了并发写消息的性能，消费消息的时候又和消费者绑定了关系，可以从不同节点的不同分区消费消息，提高了读消息的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个就是分区又引入了副本，冗余的副本保证了Kafka的高可用和高持久性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;详细说说消费者组和消费者重平衡？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka中的消费者组订阅topic主题的消息，一般来说消费者的数量最好要和所有主题分区的数量保持一致最好（举例子用一个主题，实际上当然是可以订阅多个主题）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消费者数量小于分区数量的时候，那么必然会有一个消费者消费多个分区的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而消费者数量超过分区的数量的时候，那么必然会有消费者没有分区可以消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，消费者组的好处一方面在上面说到过，可以支持多种消息模型，另外的话根据消费者和分区的消费关系，支撑横向扩容伸缩。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012196&quot; data-ratio=&quot;0.25489733301864526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9JC57jxiaNZG9VMQ59HvibXrtLzOEtWkz06QZAHzRRicqCe2OfFN0fc2Dg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;4237&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们知道消费者如何消费分区的时候，就显然会有一个问题出现了，消费者消费的分区是怎么分配的，有先加入的消费者时候怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;旧版本的重平衡过程主要通过ZK监听器的方式来触发，每个消费者客户端自己去执行分区分配算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本则是通过协调者来完成，每一次新的消费者加入都会发送请求给&lt;span&gt;协调者&lt;/span&gt;去获取分区的分配，这个分区分配的算法逻辑由协调者来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而重平衡Rebalance就是指的有新消费者加入的情况，比如刚开始我们只有消费者A在消费消息，过了一段时间消费者B和C加入了，这时候分区就需要重新分配，这就是重平衡，也可以叫做再平衡，但是重平衡的过程和我们的GC时候STW很像，会导致整个消费群组停止工作，重平衡期间都无法消息消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，发生重平衡并不是只有这一种情况，因为消费者和分区总数是存在绑定关系的，上面也说了，消费者数量最好和所有主题的分区总数一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那只要&lt;span&gt;消费者数量&lt;/span&gt;、&lt;span&gt;主题数量&lt;/span&gt;（比如用的正则订阅的主题）、&lt;span&gt;分区数量&lt;/span&gt;任何一个发生改变，都会触发重平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面说说重平衡的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重平衡的机制依赖消费者和协调者之间的心跳来维持，消费者会有一个独立的线程去定时发送心跳给协调者，这个可以通过参数&lt;code&gt;heartbeat.interval.ms&lt;/code&gt;来控制发送心跳的间隔时间。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个消费者第一次加入组的时候都会向协调者发送&lt;code&gt;JoinGroup&lt;/code&gt;请求，第一个发送这个请求的消费者会成为“群主”，协调者会返回组成员列表给群主&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;群主执行分区分配策略，然后把分配结果通过&lt;code&gt;SyncGroup&lt;/code&gt;请求发送给协调者，协调者收到分区分配结果&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他组内成员也向协调者发送&lt;code&gt;SyncGroup&lt;/code&gt;，协调者把每个消费者的分区分配分别响应给他们&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012193&quot; data-ratio=&quot;0.6683168316831684&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9Uv4dntafaiaoibem9iatx3l08cdfsryrpDwaw9wAsg0ictJqAm9GuiaxerQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1616&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;那你跟我再具体讲讲分区分配策略？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有3种分配策略：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Range&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道咋翻译，这个是默认的策略。大概意思就是对分区进行排序，排序越靠前的分区能够分配到更多的分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有3个分区，消费者A排序更靠前，所以能够分配到P0\P1两个分区，消费者B就只能分配到一个P2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是4个分区的话，那么他们会刚好都是分配到2个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012192&quot; data-ratio=&quot;0.5584281282316442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9ZdWWibaACiaW3vgID1UwSpgkVKxRQiatEmA3moEc0hGGgjgeCSOjNYaSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1934&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个分配策略会有点小问题，他是根据主题进行分配，所以如果消费者组订阅了多个主题，那就有可能导致分区分配不均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下图中两个主题的P0\P1都被分配给了A，这样A有4个分区，而B只有2个，如果这样的主题数量越多，那么不均衡就越严重。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012201&quot; data-ratio=&quot;1.0787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9X81Cqviag3zbqyz9Agtqiacyyw71qg3QhV7ocn3bnFYD87sLiaaRmdPHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RoundRobin&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是我们常说的轮询了，这个就比较简单了，不画图你也能很容易理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个会根据所有的主题进行轮询分配，不会出现Range那种主题越多可能导致分区分配不均衡的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;P0-&amp;gt;A，P1-&amp;gt;B，P1-&amp;gt;A。。。以此类推&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012200&quot; data-ratio=&quot;1.0787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9jzL1SstoAmIlRU2tMrtpTYaK9jYgqXqwNfyxdQuDKmQ6gPPibSdTgfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Sticky&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个从字面看来意思就是粘性策略，大概是这个意思。主要考虑的是在分配均衡的前提下，让分区的分配更小的改动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如之前P0\P1分配给消费者A，那么下一次尽量还是分配给A。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的好处就是连接可以复用，要消费消息总是要和broker去连接的，如果能够保持上一次分配的分区的话，那么就不用频繁的销毁创建连接了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;来吧！如何保证消息可靠性？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息可靠性的保证基本上我们都要从3个方面来阐述（这样才比较全面，无懈可击）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;生产者发送消息丢失&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka支持3种方式发送消息，这也是常规的3种方式，发送后不管结果、同步发送、异步发送，基本上所有的消息队列都是这样玩的。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发送并忘记，直接调用发送send方法，不管结果，虽然可以开启自动重试，但是肯定会有消息丢失的可能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同步发送，同步发送返回Future对象，我们可以知道发送结果，然后进行处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步发送，发送消息，同时指定一个回调函数，根据结果进行相应的处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保险起见，一般我们都会使用异步发送带有回调的方式进行发送消息，再设置参数为发送消息失败不停地重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;acks=all&lt;/code&gt;，这个参数有可以配置0|1|all。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;0表示生产者写入消息不管服务器的响应，可能消息还在网络缓冲区，服务器根本没有收到消息，当然会丢失消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1表示至少有一个副本收到消息才认为成功，一个副本那肯定就是集群的Leader副本了，但是如果刚好Leader副本所在的节点挂了，Follower没有同步这条消息，消息仍然丢失了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置all的话表示所有ISR都写入成功才算成功，那除非所有ISR里的副本全挂了，消息才会丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;retries=N&lt;/code&gt;，设置一个非常大的值，可以让生产者发送消息失败后不停重试&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;kafka自身消息丢失&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka因为消息写入是通过PageCache异步写入磁盘的，因此仍然存在丢失消息的可能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此针对kafka自身丢失的可能设置参数：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;replication.factor=N&lt;/code&gt;，设置一个比较大的值，保证至少有2个或者以上的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;min.insync.replicas=N&lt;/code&gt;，代表消息如何才能被认为是写入成功，设置大于1的数，保证至少写入1个或者以上的副本才算写入消息成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;unclean.leader.election.enable=false&lt;/code&gt;，这个设置意味着没有完全同步的分区副本不能成为Leader副本，如果是&lt;code&gt;true&lt;/code&gt;的话，那些没有完全同步Leader的副本成为Leader之后，就会有消息丢失的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;消费者消息丢失&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者丢失的可能就比较简单，关闭自动提交位移即可，改为业务处理成功手动提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为重平衡发生的时候，消费者会去读取上一次提交的偏移量，自动提交默认是每5秒一次，这会导致重复消费或者丢失消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;enable.auto.commit=false&lt;/code&gt;，设置为手动提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个参数我们可能也需要考虑进去的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;auto.offset.reset=earliest&lt;/code&gt;，这个参数代表没有偏移量可以提交或者broker上不存在偏移量的时候，消费者如何处理。&lt;code&gt;earliest&lt;/code&gt;代表从分区的开始位置读取，可能会重复读取消息，但是不会丢失，消费方一般我们肯定要自己保证幂等，另外一种&lt;code&gt;latest&lt;/code&gt;表示从分区末尾读取，那就会有概率丢失消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合这几个参数设置，我们就能保证消息不会丢失，保证了可靠性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;OK，聊聊副本和它的同步原理吧？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka副本的之前提到过，分为Leader副本和Follower副本，也就是主副本和从副本，和其他的比如Mysql不一样的是，Kafka中只有Leader副本会对外提供服务，Follower副本只是单纯地和Leader保持数据同步，作为数据冗余容灾的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kafka中我们把所有副本的集合统称为&lt;span&gt;AR（Assigned Replicas）&lt;/span&gt;，和Leader副本保持同步的副本集合称为&lt;span&gt;ISR（InSyncReplicas）&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ISR是一个动态的集合，维持这个集合会通过&lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;参数来控制，这个代表落后Leader副本的最长时间，默认值10秒，所以只要Follower副本没有落后Leader副本超过10秒以上，就可以认为是和Leader同步的（简单可以认为就是同步时间差）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有两个关键的概念用于副本之间的同步：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HW（High Watermark）&lt;/span&gt;：高水位，也叫做复制点，表示副本间同步的位置。如下图所示，0~4绿色表示已经提交的消息，这些消息已经在副本之间进行同步，消费者可以看见这些消息并且进行消费，4~6黄色的则是表示未提交的消息，可能还没有在副本间同步，这些消息对于消费者是不可见的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LEO（Log End Offset）&lt;/span&gt;：下一条待写入消息的位移&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012199&quot; data-ratio=&quot;0.35584843492586493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr95iaoKUpicib7RGiaw1xqo6ibuBkZyKiaVnqAicyuibiajIic3oVia69aQX6KygrKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;3035&quot;/&gt;&lt;figcaption&gt;hw&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副本间同步的过程依赖的就是HW和LEO的更新，以他们的值变化来演示副本同步消息的过程，绿色表示Leader副本，黄色表示Follower副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，生产者不停地向Leader写入数据，这时候Leader的LEO可能已经达到了10，但是HW依然是0，两个Follower向Leader请求同步数据，他们的值都是0。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012197&quot; data-ratio=&quot;0.6413301662707839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9YhnaYNGQSr13OPGYe3rDHQiakdfQN1ibWDuAtH8oTJpJDsqCTUuU3Ybw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，消息还在继续写入，Leader的LEO值又发生了变化，两个Follower也各自拉取到了自己的消息，于是更新自己的LEO值，但是这时候Leader的HW依然没有改变。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012198&quot; data-ratio=&quot;0.6413301662707839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9GtpBhOCUQ9OzJ0DSXfyyXzY5tBtenuVSmEblgFJdIoicGFbT5Oia5jSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，Follower再次向Leader拉取数据，这时候Leader会更新自己的HW值，取Follower中的最小的LEO值来更新。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012203&quot; data-ratio=&quot;0.6413301662707839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9D1cCNFhWBluQfZCJZC2R8lsxdwC89rEfLdnOlt1KyH2VIBN0T4ibbzA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1684&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，Leader响应自己的HW给Follower，Follower更新自己的HW值，因为又拉取到了消息，所以再次更新LEO，流程以此类推。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100012202&quot; data-ratio=&quot;0.6413301662707839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUkGTrS4o7dp9ONqkuQQ6Kr9RibIVwKRtUvDmSw4iaicBu8h6Zibsfo3vd2OVorXCUwwbhxF3iaZ4bfbHicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1684&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你知道新版本Kafka为什么抛弃了Zookeeper吗？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为可以从两个个方面来回答这个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，从运维的复杂度来看，Kafka本身是一个分布式系统，他的运维就已经很复杂了，那除此之外，还需要重度依赖另外一个ZK，这对成本和复杂度来说都是一个很大的工作量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，应该是考虑到性能方面的问题，比如之前的提交位移的操作都是保存在ZK里面的，但是ZK实际上不适合这种高频的读写更新操作，这样的话会严重影响ZK集群的性能，这一方面后来新版本中Kafka也把提交和保存位移用消息的方式来处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外Kafka严重依赖ZK来实现元数据的管理和集群的协调工作，如果集群规模庞大，主题和分区数量很多，会导致ZK集群的元数据过多，集群压力过大，直接影响到很多Watch的延时或者丢失。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;OK，最后一个大家都问的问题，Kafka为什么快？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嘿，这个我费，我背过好多次了！主要是3个方面：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;顺序IO&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka写消息到分区采用追加的方式，也就是顺序写入磁盘，不是随机写入，这个速度比普通的随机IO快非常多，几乎可以和网络IO的速度相媲美。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page Cache和零拷贝&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka在写入消息数据的时候通过mmap内存映射的方式，不是真正立刻写入磁盘，而是利用操作系统的文件缓存PageCache异步写入，提高了写入消息的性能，另外在消费消息的时候又通过&lt;code&gt;sendfile&lt;/code&gt;实现了零拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于mmap和sendfile零拷贝我都专门写过，可以看这里：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&amp;amp;mid=2247491660&amp;amp;idx=1&amp;amp;sn=a7d79ec4cc3f40e7b9a9018436a7377a&amp;amp;chksm=c2b1a8b1f5c621a7268ca298598a15c4ac575790628651e5651925b5efd96ebc0046796ef5b1&amp;amp;token=931654098&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;阿里二面：什么是mmap？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;批量处理和压缩&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka在发送消息的时候不是一条条的发送的，而是会把多条消息合并成一个批次进行处理发送，消费消息也是一个道理，一次拉取一批次的消息进行消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且Producer、Broker、Consumer都使用了优化后的压缩算法，发送和消息消息使用压缩节省了网络传输的开销，Broker存储使用压缩则降低了磁盘存储的空间。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;       &lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f60e782d9061ecd2a4ec7c9539efcb5</guid>
<title>【深入浅出SpringCloud原理及实战】「Netflix系列之Fegin」从源码层面让你认识Feign工作流程和运作机制_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/ei8uuqn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;Feign_0&quot;/&gt;Feign工作流程源码解析&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;什么是feign：一款基于注解和动态代理的声明式restful http客户端。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_4&quot;/&gt;原理&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;Feign_6&quot;/&gt;Feign发送请求实现原理&lt;/h4&gt; 
 
&lt;h5&gt;&lt;a id=&quot;FeignClientMethodHandler_13&quot;/&gt;解析@FeignClient注解，生成MethodHandler&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;具体的解析类是ParseHandlerByName。这个类是ReflectiveFeign的内部类。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;MethodMetadata&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; metadata &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;contract&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;parseAndValidateMetadata&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;拿到注解元数据以后，循环处理注解元数据，创建每个方法对应的MethodHandler，这个MethodHandler最终会被代理对象调用。最终MethodHandler都会保存到下面这个集合中，然后返回。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token class-name&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MethodHandler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;LinkedHashMap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;ReflectiveFeignnewInstance_28&quot;/&gt;解析完成以后，调用ReflectiveFeign.newInstance()生成代理类。&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;MethodHandler是feign的一个接口，这个接口的invoke方法，是动态代理调用者InvocationHandler的invoke()方法最终调用的方法。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;重新表述一遍：InvocationHandler的invoke()方法最终回调MethodHandler的invoke()来发送http请求。这就是Feign动态代理的具体实现。&lt;/strong&gt;&lt;/p&gt; 
&lt;h6&gt;&lt;a id=&quot;ReflectiveFeignnewInstance57_34&quot;/&gt;ReflectiveFeign类的newInstance()方法的第57行：&lt;/h6&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token class-name&quot;&gt;InvocationHandler&lt;/span&gt; handler &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;factory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;target&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; methodToHandler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; proxy &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Proxy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;newProxyInstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;加载器&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 接口数组&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; handler&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;InvocationHandler.invoke()的具体实现在FeignInvocationHandler.invoke()，FeignInvocationHandler也是ReflectiveFeign的一个内部类。里面有很多细节处理这里不再赘述，我们直接进入核心那一行代码，以免影响思路，我们是理Feign的实现原理的！不要在意这些细节！&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;// InvocationHandler的invoke()方法最终回调MethodHandler的invoke()来发送http请求&lt;/p&gt; 
&lt;h6&gt;&lt;a id=&quot;ReflectiveFeigninvoke323_47&quot;/&gt;ReflectiveFeign类的invoke()方法，第323行，代码的后半段，如下：&lt;/h6&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;MethodHandler&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dispatch&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;method&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;this.dispatch：这是一个map，就是保存所有的MethodHandler的集合。参考创建InvocationHandler的位置：ReflectiveFeign类的newInstance()方法的第57行。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;this.dispatch.get(method)：这里的method就是我们开发者写的feign接口中定义的方法的方法名！这段代码的意思就是从MethodHandler集合中拿到我们需要调用的那个方法。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;this.dispatch.get(method). invoke(args)：这里的invoke就是调用的MethodHandler.invoke()！动态代理回调代理类，就这样完成了，oh my god，多么伟大的创举！&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;MethodHandlerinvokeSynchronousMethodHandlerinvoke_61&quot;/&gt;MethodHandler.invoke()的具体实现：SynchronousMethodHandler.invoke()&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;到了这里，就是发送请求的逻辑了。发送请求前，首先要创建请求模板，然后调用请求拦截器RequestInterceptor进行请求处理。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token class-name&quot;&gt;RequestTemplate&lt;/span&gt; template &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;buildTemlpateFromArgs&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;argv&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Retryer&lt;/span&gt; retryer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;retryer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;clone&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;executeAndDecode&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;template&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RetryableException&lt;/span&gt; var5&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        retryer&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;continueOrPropagate&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h5&gt;&lt;a id=&quot;RequestTemplate_81&quot;/&gt;RequestTemplate处理&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;RequestTemplate模板需要经过一系列拦截器的处理，主要有以下拦截器：&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;BasicAuthRequestInterceptor：授权拦截器，主要是设置请求头的Authorization信息，这里是base64转码后的用户名和密码。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;FeignAcceptGzipEncodingInterceptor：编码类型拦截器，主要是设置请求头的Accept-Encoding信息，默认值{gzip, deflate}。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;FeignContextGzipEncodingInterceptor：压缩格式拦截器，该拦截器会判断请求头中Context-Length属性的值，是否大于请求内容的最大长度，如果超过最大长度2048，则设置请求头的Context-Encoding信息，默认值{gzip, deflate}。注意，这里的2048是可以设置的，可以在配置文件中进行配置：&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;feign&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;compression&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;enabled&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;
feign&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;compression&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;min&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;request&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;size&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2048&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;min-request-size是通过FeignClientEncodingProperties来解析的，默认值是2048。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;我们还可以自定义请求拦截器，我们自定义的拦截器，也会在此时进行调用，所有实现了RequestTemplate接口的类，都会在这里被调用。比如我们可以自定义拦截器把全局事务id放在请求头里。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h5&gt;&lt;a id=&quot;feignRequestRequestTemplatefeignRequest_100&quot;/&gt;使用feign.Request把RequestTemplate包装成feign.Request&lt;/h5&gt; 
&lt;p&gt;feign.Request由5部分组成：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;method&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;url&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;headers&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;body&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;charset&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h6&gt;&lt;a id=&quot;http_114&quot;/&gt;http请求客户端&lt;/h6&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;Feign发送http请求支持下面几种http客户端：&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;JDK自带的HttpUrlConnection&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Apache HttpClient&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OkHttpClient&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;

response &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;Client&lt;/span&gt;接口定义了&lt;span class=&quot;token function&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;的接口，并且通过接口内部类实现了&lt;span class=&quot;token class-name&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;。

&lt;span class=&quot;token class-name&quot;&gt;HttpURLConnection&lt;/span&gt; connection &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;convertAndSend&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; options&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;convertResponse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;connection&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toBuilder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt; 
 
&lt;p&gt;这种方式是最简单的实现，但是不支持负载均衡，Spring Cloud整合了Feign和Ribbon，所以自然会把Feign和Ribbon结合起来使用。也就是说，Feign发送请求前，会先把请求再经过一层包装，包装成RibbonRequest。&lt;/p&gt; 
&lt;p&gt;也就是发送请求的另一种实现LoadBalancerFeignClient。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token class-name&quot;&gt;RibbonRequest&lt;/span&gt; ribbonRequest &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt;   &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;delegate&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; uriWithoutHost&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;IClientConfig&lt;/span&gt; requestConfig &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getClientConfig&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;options&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; clientName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RibbonResponse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;&lt;span class=&quot;token namespace&quot;&gt;this&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/span&gt;IbClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;clientName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;executeWithLoadBalancer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ribbonRequest&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; requestConfig&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toResponse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h6&gt;&lt;a id=&quot;_156&quot;/&gt;以负载均衡的方式发送请求&lt;/h6&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;this.IbClient(clientName).executeWithLoadBalancer(ribbonRequest, requestConfig))的具体实现在AbstractLoadBalancerAwareClient类中。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;executeWithLoaderBalancer()方法的实现也参考了响应式编程，通过LoadBalancerCommand提交请求，然后使用Observable接收响应信息。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;AbstractLoadBalancerAwareClient类的executeWithLoadBalancer()方法的第54行：&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;AbstractLoadBalancerAwareClient&lt;/strong&gt;实现了IClient接口，该接口定义了execute()方法，&lt;/p&gt; 
 
&lt;p&gt;我们以RibbonLoadBalancingHttpClient为例来说明，RibbonLoadBalancingHttpClient.execute()&lt;/p&gt; 
&lt;p&gt;第62行代码：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;

&lt;span class=&quot;token class-name&quot;&gt;HttpUriRequest&lt;/span&gt; httpUriRequest &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toRequest&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;requestConfig&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;



&lt;span class=&quot;token class-name&quot;&gt;HttpResponse&lt;/span&gt; httpResponse &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;delegate&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;execute&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;httpUriRequest&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;



&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;RibbonApacheHttpResponse&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;httpResponse&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; httpUriRequest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getURI&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token class-name&quot;&gt;RibbonApacheHttpResponse&lt;/span&gt;由&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;部分组成：

httpResponse

uri

&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;http_204&quot;/&gt;处理http相应&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;http请求经过上面一系列的转发以后，最终还会回到SynchronousMethodHandler，然后SynchronousMethodHandler会进行一系列的处理，然后响应到浏览器。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
 
&lt;h3&gt;&lt;a id=&quot;Feign_212&quot;/&gt;Feign架构图&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/de760443e727864d2ec2e2f65814b03b.bmp&quot; alt=&quot;&quot;/&gt;&lt;br/&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;第一步：基于JDK动态代理生成代理类。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第二步：根据接口类的注解声明规则，解析出底层MethodHandler&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第三步：基于RequestBean动态生成request。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第四步：Encoder将bean包装成请求。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第五步：拦截器负责对请求和返回进行装饰处理。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第六步：日志记录。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第七步：基于重试器发送http请求，支持不同的http框架，默认使用的是HttpUrlConnection。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0795a34acaff894874d5152a19344c90</guid>
<title>一招让你的程序避免被OOM杀掉</title>
<link>https://toutiao.io/k/x47rf4f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;div data-md-url=&quot;https://mp.weixin.qq.com/cgi-bin/appmsg?t=media/appmsg_edit&amp;amp;action=edit&amp;amp;type=77&amp;amp;appmsgid=308288701&amp;amp;token=1698285484&amp;amp;lang=zh_CN&quot; markdown-here-wrapper-content-modified=&quot;true&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzAwOTU4NzM5Ng==&quot; data-alias=&quot;yudadanwx&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5Wib5Wh04ugwID68icb2oFcuc8rPmySWAHaWnQsQD8ax6PxocJ6nruWaMfxoarXh1eicga9ENlQrUPFTh8LFeEX7w/0?wx_fmt=png&quot; data-nickname=&quot;虞大胆的叽叽喳喳&quot; data-signature=&quot;《深入浅出HTTPS：从原理到实战》作者。&quot; data-weuitheme=&quot;light&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;最近一段时间一个核心服务总是因为OOM被kill，在没有找到问题之前，核心服务如何避免被kill呢？本文从宏观的角度理解内存使用情况，以及了解OOM背后的一些知识。&lt;/p&gt;&lt;p&gt;看看当时的dmesg日志：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ dmesg  -T | grep rec-server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[] Killed process 30488 (rec-server) total-vm:27462244kB, anon-rss:26069112kB, file-rss:84kB, shmem-rss:0kB
[] Out of memory: Kill process 4500 (rec-server) score 796 or sacrifice child&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述的输出有两个可观察点，首先这个进程的虚拟内存达到了27G，且常驻物理内存和虚拟内存差不多了，所以这个程序肯定被kill了。其次score是796，这个是今天的主题。&lt;/p&gt;&lt;p&gt;使用sar看看事故发生时刻内存的使用情况：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ sar -r -f /var/log/sa/sa01&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关注几个指标，kbmemused表示目前已经的使用内存，已经99%了，kbcommit指标表示根据目前负载的情况，大概需要的内存（包括RAM/swap）是32G，kbactive表示活跃的内存（不能被回收的）已经27G了， 在这样的情况下，内存已经严重不足了。&lt;/p&gt;&lt;p&gt;蹲点看free指标，available和sar的kbmemused指标计算出是一致的。&lt;/p&gt;&lt;p&gt;在对该程序不熟悉的前提下，如何避免这个程序尽量不被kill呢（如果内存足够的话）？&lt;/p&gt;&lt;p&gt;操作系统会对每个进程内存使用进行oom_score打分（在本文就是dmesg输出的796），如果它越大，就约被容易被kill，如何看进程的score打分呢？输入如下命令：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ cat /proc/$(pidof rec-server)/oom_score&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以给每个进程的oom_adj设置，该值越小，就不容易被kill：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;echo -16 &amp;gt; /proc/$(pidof rec-server)/oom_adj&lt;/code&gt;&lt;/pre&gt;&lt;p title=&quot;MDH:PHA+5pyA6L+R5LiA5q615pe26Ze05LiA5Liq5qC45b+D5pyN5Yqh5oC75piv5Zug5Li6T09N6KKr&amp;#10;a2lsbO+8jOWcqOayoeacieaJvuWIsOmXrumimOS5i+WJje+8jOaguOW/g+acjeWKoeWmguS9lemB&amp;#10;v+WFjeiiq2tpbGzlkaLvvJ/mnKzmlofku47lro/op4LnmoTop5LluqbnkIbop6PlhoXlrZjkvb/n&amp;#10;lKjmg4XlhrXvvIzku6Xlj4rkuobop6NPT03og4zlkI7nmoTkuIDkupvnn6Xor4bjgII8L3A+PHA+&amp;#10;PGJyPjwvcD48cD7nnIvnnIvlvZPml7bnmoRkbWVzZ+aXpeW/l++8mjwvcD48cD48YnI+PC9wPjxw&amp;#10;PmBgYDwvcD48cD4kIGRtZXNnJm5ic3A7IC1UIHwgZ3JlcCByZWMtc2VydmVyPC9wPjxwPmBgYDwv&amp;#10;cD48cD48YnI+PC9wPjxwPui+k+WHuu+8mjwvcD48cD48YnI+PC9wPjxwPmBgYDwvcD48cD5bXSBL&amp;#10;aWxsZWQgcHJvY2VzcyAzMDQ4OCAocmVjLXNlcnZlcikgdG90YWwtdm06Mjc0NjIyNDRrQiwgYW5v&amp;#10;bi1yc3M6MjYwNjkxMTJrQiwgZmlsZS1yc3M6ODRrQiwgc2htZW0tcnNzOjBrQjwvcD48cD5bXSBP&amp;#10;dXQgb2YgbWVtb3J5OiBLaWxsIHByb2Nlc3MgNDUwMCAocmVjLXNlcnZlcikgc2NvcmUgNzk2IG9y&amp;#10;IHNhY3JpZmljZSBjaGlsZDwvcD48cD5gYGA8L3A+PHA+PGJyPjwvcD48cD7kuIrov7DnmoTovpPl&amp;#10;h7rmnInkuKTkuKrlj6/op4Llr5/ngrnvvIzpppblhYjov5nkuKrov5vnqIvnmoTomZrmi5/lhoXl&amp;#10;rZjovr7liLDkuoYyN0fvvIzkuJTluLjpqbvniannkIblhoXlrZjlkozomZrmi5/lhoXlrZjlt67k&amp;#10;uI3lpJrkuobvvIzmiYDku6Xov5nkuKrnqIvluo/ogq/lrprooqtraWxs5LqG44CC5YW25qyhc2Nv&amp;#10;cmXmmK83OTbvvIzov5nkuKrmmK/ku4rlpKnnmoTkuLvpopjjgII8L3A+PHA+PGJyPjwvcD48cD7k&amp;#10;vb/nlKhzYXLnnIvnnIvkuovmlYXlj5HnlJ/ml7bliLvlhoXlrZjnmoTkvb/nlKjmg4XlhrXvvJo8&amp;#10;L3A+PHA+PGJyPjwvcD48cD5gYGA8L3A+PHA+JCBzYXIgLXIgLWYgL3Zhci9sb2cvc2Evc2EwMSZu&amp;#10;YnNwOzwvcD48cD5gYGA8L3A+PHA+PGJyPjwvcD48cD7lhbPms6jlh6DkuKrmjIfmoIfvvIxrYm1l&amp;#10;bXVzZWTooajnpLrnm67liY3lt7Lnu4/nmoTkvb/nlKjlhoXlrZjvvIzlt7Lnu485OSXkuobvvIxr&amp;#10;YmNvbW1pdOaMh+agh+ihqOekuuagueaNruebruWJjei0n+i9veeahOaDheWGte+8jOWkp+amgumc&amp;#10;gOimgeeahOWGheWtmO+8iOWMheaLrFJBTS9zd2Fw77yJ5pivMzJH77yMa2JhY3RpdmXooajnpLrm&amp;#10;tLvot4PnmoTlhoXlrZjvvIjkuI3og73ooqvlm57mlLbnmoTvvInlt7Lnu48yN0fkuobvvIwg5Zyo&amp;#10;6L+Z5qC355qE5oOF5Ya15LiL77yM5YaF5a2Y5bey57uP5Lil6YeN5LiN6Laz5LqG44CCPC9wPjxw&amp;#10;Pjxicj48L3A+PHA+6Lmy54K555yLZnJlZeaMh+agh++8jGF2YWlsYWJsZeWSjHNhcueahGtibWVt&amp;#10;dXNlZOaMh+agh+iuoeeul+WHuuaYr+S4gOiHtOeahOOAgjwvcD48cD48YnI+PC9wPjxwPuWcqOWv&amp;#10;ueivpeeoi+W6j+S4jeeGn+aCieeahOWJjeaPkOS4i++8jOWmguS9lemBv+WFjei/meS4queoi+W6&amp;#10;j+WwvemHj+S4jeiiq2tpbGzlkaLvvIjlpoLmnpzlhoXlrZjotrPlpJ/nmoTor53vvInvvJ88L3A+&amp;#10;PHA+PGJyPjwvcD48cD7mk43kvZzns7vnu5/kvJrlr7nmr4/kuKrov5vnqIvlhoXlrZjkvb/nlKjo&amp;#10;v5vooYxvb21fc2NvcmXmiZPliIbvvIjlnKjmnKzmloflsLHmmK9kbWVzZ+i+k+WHuueahDc5Nu+8&amp;#10;ie+8jOWmguaenOWug+i2iuWkp++8jOWwsee6puiiq+WuueaYk+iiq2tpbGzvvIzlpoLkvZXnnIvo&amp;#10;v5vnqIvnmoRzY29yZeaJk+WIhuWRou+8n+i+k+WFpeWmguS4i+WRveS7pO+8mjwvcD48cD48YnI+&amp;#10;PC9wPjxwPmBgYDwvcD48cD4kIGNhdCAvcHJvYy8kKHBpZG9mIHJlYy1zZXJ2ZXIpL29vbV9zY29y&amp;#10;ZTwvcD48cD5gYGA8L3A+PHA+PGJyPjwvcD48cD7lj6/ku6Xnu5nmr4/kuKrov5vnqIvnmoRvb21f&amp;#10;YWRq6K6+572u77yM6K+l5YC86LaK5bCP77yM5bCx5LiN5a655piT6KKra2lsbO+8mjwvcD48cD48&amp;#10;YnI+PC9wPjxwPmBgYDwvcD48cD5lY2hvIC0xNiAmZ3Q7IC9wcm9jLyQocGlkb2YgcmVjLXNlcnZl&amp;#10;cikvb29tX2FkajwvcD48cD5gYGA8c3BhbiBjbGFzcz0ianNfcGFzdGV3b3JkIj48L3NwYW4+PC9w&amp;#10;PjxwPjxicj48L3A+&quot;/&gt;&lt;/div&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8d9f0094388ea689438b6e3f9d54800</guid>
<title>B站微服务API管理</title>
<link>https://toutiao.io/k/7xl4fij</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;本期作者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOMc5P9PEbEDicMdG5T6UV3cQaibzAvTH7xrAzg2Bqx1WHzm9de642ruOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;陈雨润&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;哔哩哔哩开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;API 管理是应用开发中不可或缺的一部分。在早期服务数量不多的情况下，团队可以自行负责 API 管理。但随着公司规模逐渐扩张，业务接口数量爆炸式增长，此时 API 管理的任务应由统一的接口管理平台来承担，结束各自为政的局面。统一管理能够最大程度地发挥 API 的价值，减少跨部门沟通与协作的成本。本期文章将带领大家一窥 B 站在 API 管理方面所作的设计与思考，重点介绍我们是如何收集 API 元信息并对其进行井井有条的管理，又是如何配置这些庞大 API 资源来减轻业务管理负担，粘合跨部门间合作。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6018519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpORVOG09XNnFfLndCQeib4Ssl8byjV2YLtfMohiaKiaHKSIkQrzHFICtmBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;管理现状&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前，我们的元信息统一管理平台线上接口数达到12w+，应用（含测试应用）总数近2w。如此庞大规模的接口由平台统一收集并管理，可节约大量人力维护与沟通成本，契合当前“降本增效”的主基调。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01 &lt;/strong&gt;&lt;strong&gt;服务上线流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个服务的上线过程通常分为这样几个阶段：&lt;/p&gt;&lt;p&gt;1. 需求评审与分析&lt;/p&gt;&lt;p&gt;PM 输出需求，PMO 组织需求评审会，业务线开发评估需求的开发方案与所需工时，从而确定迭代周期。&lt;/p&gt;&lt;p&gt;2. 撰写与维护 API 文档&lt;/p&gt;&lt;p&gt;在项目开发中，Web 项目的前后端分离开发，需要由前后端开发共同定义接口，编写接口文档，之后大家都根据这个接口文档进行开发，一直维护到项目结束。API 文档在后端技术方案确定后即可编写。尽可能早地提供给对接方，有助于对接方提前思考实现方式和规避隐患。&lt;/p&gt;&lt;p&gt;3. 前后端联调与测试&lt;/p&gt;&lt;p&gt;前端根据 API 文档初步实现功能，后端在开发完成后发布至测试环境提供给前端联调。&lt;/p&gt;&lt;p&gt;4. 发布上线&lt;/p&gt;&lt;p&gt;当一切就绪后，服务被发布至线上，API 开始对外提供服务，需求上线。&lt;/p&gt;&lt;p&gt;上述整个过程中都离不开对接口文档的管理，一个优秀的接口文档能够让前端与后端开发人员更好地配合，提高工作效率，方便新加入的成员查看和维护接口、测试人员进行接口测试。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOOicTWMc0nde40JwO1XnRFVfZfDxDKfy0u6apFu16bkq2oVEBBA6Nkwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02 &lt;/strong&gt;&lt;strong&gt;API管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOBwaia5SybOQdXR3GuD9eTMmOAP2ia1gia3sLRFXD1HPmzV8ibsIiaWeF3bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 2.1 为什么需要对API进行统一管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在过去没有统一管理的模式下，虽说每个团队每个项目都有编写 API 文档的意识，但免不了出现各种管理模式的差异，例如 A 团队习惯将文档编写在知识库中，B 团队习惯将文档用 swagger 生成并托管至版本管理系统等等。这种管理模式上的差异会直接导致对接沟通上的低效，无法及时得发现API的异常，难以管理接口的版本迭代。因此我们始终推荐对 API 进行统一管理，降低对接时的沟通成本，并在接口出现变更时及时同步调用方，减少信息 gap，通过标准化的中心收集模式敏锐地捕捉到每一次接口调整。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 2.2 API元信息的收集与更新&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在整个 API 管理过程中，首先需要保证接口元信息完备性和准确性，管理平台需要充分收集接口信息。B 站的接口元信息的收集之路：手动维护 -&amp;gt; 自动生成。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2.2.1 手动维护&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;过去，我们在内网私有化部署过一套 YAPI，通过部门、业务域、应用的三级划分的粒度管理着各个服务的接口。研发通过在 YAPI 的可视化界面上手动录入应用的详细接口信息。接口发布后，前后端的研发根据文档着手进行编码，测试同学则根据文档上的接口逐个进行测试，负责人对该文档进行审批。总之，项目干系方始终都会围绕着这份文档来推进项目。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOhTVVgJiaNgeKcJ29T2uO3S14ba2oicKCyiaf0HOoA4IU01VAScTp9YtMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;手动维护的缺点：&lt;/p&gt;&lt;p&gt;市面上有很多的五花八门的 API 信息管理平台，如知名的 Eolink、YAPI、Apifox、Postman，但无论部署哪个平台都无法解决一个非常核心的问题：&lt;strong&gt;数据的来源始终是“人”，需要人工去操作与更新。&lt;/strong&gt; 尤其在项目的开发阶段，接口文档的改动频次实际上是很高的，需要开发同学多次到平台上调整接口文档，保证接口数据始终正确。&lt;/p&gt;&lt;p&gt;手工模式下，开发同学每次完成接口的增改都需要及时到平台上同步最新的改动并通知具体的订阅方。若某次变更未被及时同步，造成调用方与被调方之间信息不对齐，很容易造成故障。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;2.2.2 自动生成&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;接口管理平台的作用是自动采集应用 API 并生成一份详细且准确的接口文档，使开发将精力全部集中在 API 本身的设计上，无需额外关注接口文档的撰写与维护，从而解放研发同学的双手，提高开发效率。&lt;/p&gt;&lt;p&gt;为此，我们设计了如下架构，研发同学遵循统一的 API 标准定义接口，走完正常应用打包上线流程，接口采集自动完成。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.362037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOshAKYbGiacfJ2QMvKMbJvjQn2VLW1muNhMycljxo8xuArGWpM1EBowQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;代码中定义接口&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对于习惯使用 Golang 进行开发的同学：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;service DemoService {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  option (google.api.default_host) = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;api.example.com&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;rpc &lt;span class=&quot;code-snippet__title&quot;&gt;DemoBody&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(SimpleMessage)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;returns&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(SimpleMessage)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    option (google.api.http) = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      post: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/poc/probe/demo_body&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      body: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message SimpleMessage {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  int32 id = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; [(google.api.field_behavior) = REQUIRED];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Embedded embedded = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;message Embedded {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  int64 int64_val = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; [(gogoproto.moretags) = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;default:&quot;1&quot;&#x27;&lt;/span&gt;];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; string_val = &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  repeated &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt; repeated_string_val = &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&amp;gt; map_string_val = &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述 Proto 片段中定义了一个名称为 DemoService 的 RPC 服务，该服务包含一个简单的 RPC方法 DemoBody，并且引入 Google 官方提供的 annotations.proto 对该 gRPC API 增加 HTTP Post 方法的拓展定义。这种使用 Protobuf IDL 定义对应的 REST API 和 gRPC API的方式是Google API 指南中所推荐的最佳实践，也是B站在 Kratos V2框架中定义 API 的方式。对于框架是如何注册 HTTP 与 gRPC 服务感兴趣的同学欢迎体验 Kratos 框架，这里先不详细展开。DemoService 中除了对 HTTP 方法的定义，还包括服务概要，默认域名等标记。在 Message 中除了字段类型的定义，某些字段还带有属性行为的标记。我们支持用户使用 gogoproto 以及 google.api.field_behavior 中定义的消息对字段进行一些特殊标记，如定义字段默认值，是否必填，示例用法等参数相关的属性。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;info:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    title: DemoService API&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    description: Demo service responds to incoming requests.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;paths:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /bilibili.api.probe.v1.DemoService/DemoBody:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...(同/poc/probe/demo_body)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /poc/probe/demo_body:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        post:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tags:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                - DemoService&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            description: DemoBody method receives a simple message &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; returns it.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            operationId: DemoService_DemoBody&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            requestBody:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                content:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    application/json:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        schema:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            $ref: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;#/components/schemas/bilibili.api.probe.v1.SimpleMessage&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                required: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            responses:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;200&quot;&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    description: OK&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    content:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        application/json:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            schema:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                $ref: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;#/components/schemas/bilibili.api.probe.v1.SimpleMessage&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;components:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    schemas:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bilibili.api.probe.v1.Embedded:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            type: object&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            properties:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                stringVal:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    type: &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;: hello&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                repeatedStringVal:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    type: &lt;span class=&quot;code-snippet__built_in&quot;&gt;array&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    items:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        type: &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    description: 一个字符串列表&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                mapStringVal:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    type: object&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    additionalProperties:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        type: &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    description: 一个字符串Map&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bilibili.api.probe.v1.SimpleMessage:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            required:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                - id&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            type: object&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            properties:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                id:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    type: integer&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    format: int32&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                embedded:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    $ref: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;#/components/schemas/bilibili.api.probe.v1.Embedded&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            description: 请求、回复消息&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tags:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    - name: DemoService&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最终通过工具生成上述对应 OpenAPI 文档，为 Proto 中对 HTTP 方法的定义提供标准 OpenAPI 格式的接口信息，将 gRPC Method 视为 POST 方法，生成一条类似的接口信息。&lt;/p&gt;&lt;p&gt;对于习惯使用JAVA进行开发的同学而言，同样地：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;c&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@GetMapping(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/demo&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Operation(summary = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;用户接口 - debug&quot;&lt;/span&gt;,description = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;示例&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Parameter(name = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;count&quot;&lt;/span&gt;, required = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;code-snippet__title&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(@RequestParam(defaultValue = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;128&quot;&lt;/span&gt;, required = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; count)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String randomString = RandomStringUtils.randomAlphabetic(count);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LOGGER.debug(randomString);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; randomString;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述代码引入io.swagger.v3包，定义了一个path为 &#x27;/demo&#x27; 的接口，使用 swagger 注解对 controller 类中的map方法进行修饰。暴露生成接口文档方式十分简单，在 B 站自研的JAVA web框架 Pleidaes/ Kraten下开发，应用启动后直接调用 /api-docs 的接口就可以轻易拿到。这种利用 swagger 注解提供的来声明和操作输出，为 JAVA 应用实时生成接口文档是JAVA同学熟知的一种方式，对平台来说，要做的只是调用接口拿到 JAVA 应用的文档即可。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文档收集&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们的终极目标是做到全公司研发同学使用统一的框架，使用统一的 API 的定义和生成方式，管理平台就可以采集的标准且权威的API元信息，即实现公司API标准化。但这个目标不是一蹴而就的，在研发开发流程尚不&quot;标准&quot;时，我们通过多种渠道尽可能得获取到应用的接口信息，保证平台接口数据的完备性。&lt;/p&gt;&lt;p&gt;a. CI 时生成（最佳实践）&lt;/p&gt;&lt;p&gt;对于采用 gRPC 协议的接口来说，B 站采用的是单仓库管理模型管理协议文件：将协议原始文件 Proto 集中放到一个仓库中，根据内部服务治理的标准将文件划分至独立的命名空间进行细粒度管理，对外提供根据 Proto生成的目标语言仓库，例如 go 语言 proto-gen-go 仓库, JAVA语言 proto-gen-java 仓库，依赖某服务时直接 import 该仓库即可。&lt;/p&gt;&lt;p&gt;接口管理平台作为 Proto 以及 stub 的管理员，肩负着管理内部统一 Proto仓库的责任。但不论是协议文件还是存根代码，只是接口的定义，包括版本、命令定义、资源定义和错误码定义等等，不适宜直接作为接口文档展示给调用方。我们在推动内部 API 标准化的过程中，对定义 Proto 文件中接口的参数、默认行为、属性、必要注释等行为给出统一的规范，在通过在CI Pipeline 中安装 protoc-gen-bilibili-openapi 插件，该插件负责解析代码中的 Proto 文件，并对应生成一份标准 OpenAPI 文档。当用户请求合并代码到主分支时，自动触发流水线中接口平台的埋入的任务：扫描代码中的 Proto，提取出接口信息，生成对应文档后导入接口管理平台，完成对该应用接口文档的自动刷新。用户只是完成了一次基本的 Proto 的书写，就不再需要考虑后续其他的协作方面的事宜，接口文档，测试，桩代码，一切交给管理平台进行打理。&lt;/p&gt;&lt;p&gt;b. 在线服务采集&lt;/p&gt;&lt;p&gt;对于 Java 语言应用而言，应用部署后通过注册中心暴露服务地址，接口管理平台到指定环境中调用该地址下 /api-docs 接口获取到应用的接口文档，并与历史接口版本进行比对与更新，实现对 Java 应用接口文档的自动更新，整个过程对于开发者来说没有额外维护文档的负担，也不再需要关心自己的接口数据如何去暴露和分享给调用方。&lt;/p&gt;&lt;p&gt;在API标准化尚未推广之前，公司内的 go 服务可能使用的是 Kratos 早期定义接口的方式，这部分应用通过 /metadata 接口对外暴露 path 信息。平台通过该接口采集到所有的接口路径后，由用户对接口的文档进行手动补全，等应用实现API标准化后再逐步由半自动进入全自动收集的模式。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03 &lt;/strong&gt;&lt;strong&gt;版本管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;API 是用户与应用之间的约定，包括 URI 模式，有效负载结构，字段和参数名称，预期行为以及其他内容。在应用迭代的过程中，不可避免需要添加新的资源、修改资源或调整接口参数，随之会带来的接口变更管理的问题。例如，某个应用新加的 feature 改动了接口，但此时改动没经过测试，相当于只是草稿版本。开发希望能将草稿版本的接口分享给联调的人员，又不想影响正式版本，这在过去其实是一件比较棘手的事情。接口管理平台要做的就是通过版本管理区分好接口不同状态、不同来源、不同时期的信息。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.1 接口版本控制&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;接口参数的每一点变更一定都源于代码的变动，代码的提交才可能会导致接口版本的升级。服务本身没有变更，开发者代码没有产生过提交，是不会导致接口凭空变化的。基于此点共识，我们将应用&lt;strong&gt;代码的提交 (Commit ID) 与管理平台上的接口版本 (API Version) &lt;/strong&gt;关联。&lt;/p&gt;&lt;p&gt;接口管理平台对接口的正式版本及测试版本进行区分。测试版本的来源是测试环境中的应用，与 dev 代码分支的某次 commit 记录相关联；正式版本的来源是生产环境中的应用，与主分支代码的某个 tag 相关联。&lt;/p&gt;&lt;p&gt;研发每次提交代码，不管是用于测试发布还是正式发布，接口管理平台都会为接口生成相应新版本，对比新版本与历史版本的差异，这在多人协作开发的项目中非常受用。研发同学将某一次实验性版本的应用部署到测试环境后，就可以在接口平台上直接对刚刚提交的接口进行初步验证，或者由自动化测试又或是 QA 进行系统的测试；而正式版本经过完整的流水线测试、全链路灰度验证、部署在生产环境后，可直接被分享给调用方。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4939627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOIA402LtYCib5v3ibKuYlAcurxaFqiagmkcCeu4iaMFQWuhNgk4jiaJrmHkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.2 应用版本管理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于接口的调用方来说，大多只会关心接口功能及使用参数。比如说调用方需要接入某个应用时，他想知道应用当前 V2 版本使用哪些接口可以满足他的需求，而不会关心这些接口有哪些版本。或者说，调用方接入的是历史版本 V1，暂时还不想升级到 V2，他想知道 V1 版本使用的接口是哪些参数。这种场景下，直接将V1版本的接口文档发给调用方即可。&lt;/p&gt;&lt;p&gt;应用是接口的集合，应用版本是接口版本的集合。有了接口的版本控制之后，再进行应用的版本管理就变得很容易了。接口管理平台可以为一组接口版本创建一个快照，这个快照就是应用版本。当应用每次正式上线后，我们可以通为应用创建一个该版本的接口快照，通过这样的管理方式，我们可以观察每个接口在各个应用版本下的变更情况，并追踪接口在应用中的生命周期变化。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6506024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOicd9VrYIu1xiacR51pgAiaQY5ZmCXaOV9Nyj2OiasuFrMTSwvtauaYt2EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;04 &lt;/strong&gt;&lt;strong&gt;接口协作、分享、调试&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;API 管理平台不仅是对接口元信息进行管理，打通数据、提升研发效率以及发掘元数据本身的价值同样是 API 管理平台的使命。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;联动接口周边服务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;例如我们将 API 管理平台与 API Gateway 打通，对于需要集成服务网关功能的接口，只需要在API 管理平台就上可以方便得跳转到对应地方进行配置，其他与接口有关的配置同样如此， 用户可以将接口管理平台作为入口，跳转至其他基础平台，提高用户效率的同时更好得与其他平台进行配合。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;文档导出、分享&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们对这些接口信息以不同的格式进行展示，支持导出标准的 OpenAPI 格式的 json 文件。对于那些习惯使用第三方工具查看接口数据的研发同学来说，可通过工具导入 OpenAPI 文件或直接订阅平台，在本地客户端实时查看自己关注的接口。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接口调试、运行&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接口调试可以简单分为两种：&lt;/p&gt;&lt;p&gt;API 管理平台对这种两种接口的请求方式的进行了统一，用户不需要关心自己的接口是哪种协议，就可以直接点击调试。平台管理本身管理着 Proto 仓库，拥有全部内部协作的 Proto 元信息，即使需要客户端 Token 的 RPC 也可轻松发起，帮助用户进行初步的接口调试。并且在平台调试时也无需像普通调试工具一样指定域名、IP 后才可调试。平台侧打通注册中心，获取服务的信息，自动为用户键入目标地址。用户对于调试这件事仅仅需关注两点：接口及返回结果， 其他均由接口管理平台包办。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;05 &lt;/strong&gt;&lt;strong&gt;接口Mock&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.1 为什么需要对测试对象的依赖进行&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Mock？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Mock 的本质是在调试期间构造出一些虚拟的返回对象。一个常见的场景：前后端分离，前端开发某个页面，需要后端先完成 API 的开发工作，两者进度不一致，出现前端等待后端的情况。如果使用 Mock 就可以减小这种影响，通过 Mock API 事先编写好 API 的数据生成规则，请求接口平台动态生成 API 的返回数据。前端开发可以通过访问 Mock API 来获得页面所需要的数据，继续开展工作。&lt;/p&gt;&lt;p&gt;Mock的好处：&lt;/p&gt;&lt;p&gt;通过 Mock 构造各种正常和异常的返回结果，更充分地测试目标对象&lt;/p&gt;&lt;p&gt;依赖的真实行为可能延时高，资源消耗大，而模拟是一种非常快的行为，能  加快整个测试流程。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 5.2 服务级Mock架构设计&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Mock 粒度由细到粗分为方法级、类级别、接口级、服务级。大多 API-test 工具由于无法覆盖全部接口，只做到接口级别 Mock，但对于拥有全部接口元信息的接口管理平台来说，做到服务级别的 Mock 是顺水推舟的事情。&lt;/p&gt;&lt;p&gt;狭隘的理解服务端 Mock 是将服务的所有的接口无差别地全部 Mock，相当于是接口级别的极端做法。例如，某次在测试环境中进行服务联调时，对于某些尚未开发完成的接口或者不能在测试环境中被调用的接口，可采用 Mock 进行过渡；但对于已经上线的接口来说，流量应直接透传至真实服务，待拿到真实的响应数据后再返回给上游。这样不管是对减轻测试用例管理的负担还是提高测试的准确性都有很大的增益。&lt;/p&gt;&lt;p&gt;基于上述思想，我们设计了如下图所示的架构：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9232996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOTLwyzUjbiaUEhoByYwjOfFfAvOW1wHBsb3CaHUJSSMwPic8ZG1LsyIyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于需要进行被 Mock 的服务，接口管理平台会在注册中心为该服务的注册出一个染色实例，并与注册中心维持心跳，在测试环境中部署的真实服务则作为兜底用的基准版本。收到流量时，匹配指定染色成功的请求会被注册中心转发至 Mock 实例，该实例实际是接口管理平台在提供服务。Mock 实例判断流量是否命中事先配置好的规则，若命中成功，则直接返回 规则中的响应; 若未能命中规则或未配置规则，则将流量原封不动地转发给基准版本的实例，由基准返回。我们的做法实际上是通过修改注册中心上服务与服务地址的映射关系，将依赖服务地址改成 Mock 地址实现 Mock 注入。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpOhTUkfzHe5RCNJWBn7Jm2WvcFCu37qujicv282s3DgDfN4je103fGIlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;06 微服务标准化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们一直致力于实现公司内部的微服务的标准化，包括接口规范化、接口标准化、数据格式统一化，这些标准是明确、可行且统一的，以保证各个微服务之间的可互操作性。B 站内部使用 Go 语言开发同学多数是在 Kratos 框架下进行开发的，使用 JAVA 语言开发的同学使用自研的 Pleiades/ Kraten 框架，这两种框架都为平台能顺利采集到接口信息提供了极大的便利。我们借助框架的力量，将 OpenAPI 格式 API 的标准集成在框架中，编译时期或 CI 阶段产生接口文档，开发各种配套的 Swagger、OpenAPI 的工具用来充分提取文档的接口信息。&lt;/p&gt;&lt;p&gt;API 元信息的管理是 API 标准化中的一环，我们希望利用标准的力量来做更多的事情，如监控、自动生成代码...探索更多的玩法，成为强有力的生产力工具。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5033113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754R8YgBNkvUicfsYnUUQicqrpON3PRHM4dWxCoKZ2aJvvuOxUAhcUYecFN75XMfeKbgJU89uu8CabOkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;参考文献：&lt;/p&gt;&lt;p&gt;[1]API 定义 | &lt;span&gt;Kratos：https://go-kratos.dev/docs/component/api/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[2]自定义方法 - API Design Guide：&lt;span&gt;https://google-cloud.gitbook.io/api-design-guide/custom_methods&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[3]对API进行版本控制的重要性和实现方式 - EOLINEKR BLOG：&lt;span&gt;http://blog.eolinker.com/?p=2644&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[4]干货！用大白话告诉你什么是Mock测试-51CTO.COM：&lt;span&gt;https://www.51cto.com/article/647732.html&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;以上是今天的分享内容，如果你有什么想法或疑问，欢迎大家在留言区与我们互动，如果喜欢本期内容的话，欢迎点个“在看”吧！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>acbdc628a7cfd406621571e9a4b36264</guid>
<title>Cloudflare弃用NGINX，改用Rust编写的Pingora，你怎么看？ - 知乎</title>
<link>https://toutiao.io/k/9qve2pu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;l-QNWFmt&quot;&gt;  大家看下原文呀，几个原因都有说的。&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//blog.cloudflare.com/how-we-built-pingora-the-proxy-that-connects-cloudflare-to-the-internet/&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-d52ebf214b9cce20c88a0bb3aed8b18f_180x120.jpg&quot; data-image-width=&quot;1636&quot; data-image-height=&quot;695&quot; data-text=&quot;How we built Pingora, the proxy that connects Cloudflare to the Internet&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p data-pid=&quot;0vI07agJ&quot;&gt;原文有说，主要为了解决 nginx下每个worker有一组连接池，连接不能很好的复用，每次连接会带来 TTFB 的首包开销。pingora 其他的优化是附带的，另外 nginx 官方社区一直都比较孤僻，不太接受他人的pr。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-6b8fe2a917736a48da746b46f7f84300_720w.jpg?source=1940ef5c&quot; data-rawwidth=&quot;1982&quot; data-rawheight=&quot;1434&quot; data-size=&quot;normal&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-95fda595be971ddbd8d6d4e462355c47_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6b8fe2a917736a48da746b46f7f84300_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-rawwidth=&quot;1982&quot; data-rawheight=&quot;1434&quot; data-size=&quot;normal&quot; data-default-watermark-src=&quot;https://picx.zhimg.com/50/v2-95fda595be971ddbd8d6d4e462355c47_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6b8fe2a917736a48da746b46f7f84300_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-6b8fe2a917736a48da746b46f7f84300_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QXAWZYhn&quot;&gt;据我所知，cloudflare 那边 openresty 方面的几个大佬都走了，既然大佬们都走了，后面的人估计想用新的语言玩玩吧 。个人猜测。 &lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>