<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0aaec14b3cf29e4d3d553c495f662dfb</guid>
<title>Linux 主机性能测试方法</title>
<link>https://toutiao.io/k/z0e7y3o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-linux tag-raspberry-pi no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;最近打算用躺家吃灰的树莓派4B搭一个NAS，用来快捷方便地访问和备份一些资源。由于备选的硬件（芯片、硬盘、网线、路由器等）和软件（内网穿透技术）的技术选型比较多，这时候就需要有一个能简单评估服务性能的方法。因此简单搜寻了一下常见方案，方便在技术选型时有个统一的对比标准，并且对一些常见指标能在数量级上有一些感性的理解。&lt;/p&gt;&lt;h2 id=&quot;%E7%A1%AC%E7%9B%98&quot;&gt;硬盘&lt;/h2&gt;&lt;p&gt;对于硬盘的读写速度测试，首先我们需要注意根据读写的实现细节不同，测试出的结果会有很大的差别。例如对于读来说，是否走缓存读、缓存的大小如何；对于写来说，是否只写缓存、是否同步等待刷盘、刷盘的时机如何，等等。&lt;/p&gt;&lt;p&gt;在实际测试的时候一定要明确自己使用的是哪种IO模式，否则就会得到一些似是而非的结论。&lt;/p&gt;&lt;h3 id=&quot;%E8%AE%BE%E5%A4%87%E6%9F%A5%E8%AF%A2&quot;&gt;设备查询&lt;/h3&gt;&lt;p&gt;在测试硬盘前，我们首先得知道我们有哪些硬盘、分别对应哪些分区。用 &lt;code&gt;lsblk&lt;/code&gt; （list block）命令可以查看当前机器下挂载的块设备：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda           8:0    1 29.3G  0 disk
└─sda1        8:1    1 29.3G  0 part /media/pi/5615-BDE2
mmcblk0     179:0    0 59.5G  0 disk
├─mmcblk0p1 179:1    0  256M  0 part /boot
└─mmcblk0p2 179:2    0 59.2G  0 part /&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，这里的 sda (SATA device a) 表示我外部插入的一个U盘；mmcblk0 (Multimedia card block 0) 表示树莓派自带的一张 SD 卡。这两个类型是 disk，也就是实体磁盘。&lt;/p&gt;&lt;p&gt;每个 disk 会被分成多个 partition，也就是这里的 sda1 和 mmcblk0p1、mmcblk0p2。每个 partition 又会 mount 到不同的文件夹下，用于在文件系统中进行访问。因此对于文件系统本身来说，我们只会关心到 partition 层面。&lt;/p&gt;&lt;p&gt;通过 &lt;code&gt;df&lt;/code&gt; 命令我们也能直接观察到所有分区的挂载情况：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/root        59G   11G   46G  19% /
devtmpfs        3.5G     0  3.5G   0% /dev
tmpfs           3.7G     0  3.7G   0% /dev/shm
tmpfs           3.7G   65M  3.6G   2% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           3.7G     0  3.7G   0% /sys/fs/cgroup
/dev/mmcblk0p1  253M   32M  221M  13% /boot
tmpfs           738M  4.0K  738M   1% /run/user/1000
/dev/sda1        30G   23M   30G   1% /media/pi/5615-BDE2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时，disk 和 partition 的详细信息也可以通过 &lt;code&gt;fdisk&lt;/code&gt; 命令查看：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo fdisk -l
Disk /dev/mmcblk0: 59.5 GiB, 63864569856 bytes, 124735488 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x140cee6b

Device         Boot  Start       End   Sectors  Size Id Type
/dev/mmcblk0p1        8192    532479    524288  256M  c W95 FAT32 (LBA)
/dev/mmcblk0p2      532480 124735487 124203008 59.2G 83 Linux


Disk /dev/sda: 29.3 GiB, 31457280000 bytes, 61440000 sectors
Disk model: ProductCode
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xf3203eea

Device     Boot Start      End  Sectors  Size Id Type
/dev/sda1        2048 61439999 61437952 29.3G  7 HPFS/NTFS/exFAT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总之，在这里我们只需要搞清楚我们想测试的磁盘和分区分别是哪个即可。&lt;/p&gt;&lt;h3 id=&quot;hdparm&quot;&gt;hdparm&lt;/h3&gt;&lt;p&gt;对于读性能测试，我们一般可以用 &lt;a href=&quot;https://sourceforge.net/projects/hdparm/&quot;&gt;hdparm&lt;/a&gt; 工具（hard disk parameter? hardware device parameter?）。Debian下直接 apt 安装即可：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install hdparm -y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hdparm目前只支持磁盘读性能测试，提供了三种方式进行测试：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;直接读内存： &lt;code&gt;sudo hdparm -T [device]&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;带buffer读磁盘： &lt;code&gt;sudo hdparm -t [device]&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;不带buffer读磁盘: &lt;code&gt;sudo hdparm -t --direct [device]&lt;/code&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以我的 mmcblk0 设备为例，跑出来结果分别如下（当然，每次测试建议跑多次取平均值，这里偷个懒）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo hdparm -T /dev/mmcblk0

/dev/mmcblk0:
 Timing cached reads:   1840 MB in  2.00 seconds = 921.43 MB/sec
 
$ sudo hdparm -t /dev/mmcblk0

/dev/mmcblk0:
 Timing buffered disk reads: 130 MB in  3.04 seconds =  42.74 MB/sec
 
$ sudo hdparm -t --direct /dev/mmcblk0

/dev/mmcblk0:
 Timing O_DIRECT disk reads: 124 MB in  3.01 seconds =  41.17 MB/sec
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然，走内存读是飞快，不过对于测试磁盘性能来说没有任何意义；不带buffer看起来比带buffer要慢一点点，差别不太大；考虑到现实场景中大多数都是带buffer的读，因此我们在比较时用带buffer读的结果来进行参考即可。&lt;/p&gt;&lt;h3 id=&quot;dd&quot;&gt;dd&lt;/h3&gt;&lt;p&gt;dd (data definition? data duplicator?) 是进行磁盘操作、文件生成之类的常用工具。在 gnu 的 coreutils 下，类 Unix 发行版几乎都自带。&lt;/p&gt;&lt;h4 id=&quot;%E5%86%99%E6%80%A7%E8%83%BD&quot;&gt;写性能&lt;/h4&gt;&lt;p&gt;一般我们会用 dd 来进行磁盘写性能测试，一般来说也有三种方式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;直接写内存： &lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;使用内存做缓存写完后一次性刷盘：&lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;使用内存做缓存，每写完一部分就刷一次盘：&lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test oflag=dsync&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;还是以我的 mmcblk0 设备为例（当前目录即挂载的 mmcblk0 设备），跑出来结果分别如下（当然，每次测试建议跑多次取平均值，这里还是偷个懒）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dd bs=1M count=256 if=/dev/zero of=test
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 1.39574 s, 192 MB/s

$ dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 31.739 s, 8.5 MB/s

$ dd bs=1M count=256 if=/dev/zero of=test oflag=dsync
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 39.694 s, 6.8 MB/s

$ rm test&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见写内存不sync的确还是快，不过还是没啥参考意义。考虑到实际情况下大部分程序都是采用 fdatasync 的模式来写，因此我们在比较时用这个数据即可。&lt;/p&gt;&lt;h4 id=&quot;%E8%AF%BB%E6%80%A7%E8%83%BD&quot;&gt;读性能&lt;/h4&gt;&lt;p&gt;当然，有人也会利用 dd 进行读性能测试，比如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo dd bs=1M count=256 if=/dev/mmcblk0 of=/dev/null
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 6.03649 s, 44.5 MB/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来很美好，结果也和 hdparm 差不多。但是当你第二次再跑这个命令的时候，由于写缓存的存在，结果会快特别多：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo dd bs=1M count=256 if=/dev/mmcblk0 of=/dev/null
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 0.267236 s, 1.0 GB/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然这样的测试是没有意义的。考虑到这种测试方法甚至很难做到幂等，这里还是不建议用 dd 来测试读性能。&lt;/p&gt;&lt;h3 id=&quot;%E5%B0%8F%E7%BB%93&quot;&gt;小结&lt;/h3&gt;&lt;p&gt;对于磁盘读性能测试，建议使用 &lt;code&gt;sudo hdparm -t [device]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于磁盘写性能测试，建议使用 &lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&quot;%E7%BD%91%E7%BB%9C&quot;&gt;网络&lt;/h2&gt;&lt;p&gt;网速测试一般分两种，一种是测试当前设备对普通公网设备的读写速度；另一种是点对点测试两个服务器之间的速度。&lt;/p&gt;&lt;h3 id=&quot;speedtest&quot;&gt;speedtest&lt;/h3&gt;&lt;p&gt;speedtest 工具在各地都有测速服务器，通过命令行（speedtest-cli）或者网页（https://speedtest.cn，https://speedtest.net）都可以进行网速上下行的测试。这里以命令行为例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install speedtest-cli -y

$ speedtest-cli
Retrieving speedtest.net configuration...
Testing from China Mobile (183.192.82.69)...
Retrieving speedtest.net server list...
Selecting best server based on ping...
Hosted by Chinamobile-5G (Shanghai) [8.49 km]: 6.054 ms
Testing download speed................................................................................
Download: 128.24 Mbit/s
Testing upload speed......................................................................................................
Upload: 22.88 Mbit/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然多次测试可能会访问到不同的测试点、导致结果有区别，不过其实也大差不差了。&lt;/p&gt;&lt;p&gt;在使用时偶尔会遇到返403，不要慌，多试几下一般就好了 。&lt;/p&gt;&lt;h3 id=&quot;iperf3&quot;&gt;iperf3&lt;/h3&gt;&lt;p&gt;如果我们并不是想测试公网网速，而是测试两个服务器之间点对点的网速。这时用 &lt;a href=&quot;https://iperf.fr/iperf-doc.php#doc&quot;&gt;iperf3&lt;/a&gt; 工具就好。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install iperf3 -y # Debian 下
$ brew install iperf3        # MacOS 下&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意，除了 iperf3 之外，还有一个 iperf。这两个版本分别由不同组织开发，前后也不兼容。虽然似乎 iperf3 有坑，不过似乎功能多一点，尤其是支持了下行带宽测试（iperf 只支持上行带宽测试），所以这里还是用 iperf3。&lt;/p&gt;&lt;p&gt;iperf3 是 C/S 架构，服务端开启 server ，客户端开启 client，然后互相通信进行测速。以我在家的树莓派和一个在 HK 的 Azure 主机为例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -s -p 5555                   # azure 主机上开启 server

$ iperf3 -c 104.208.65.181 -p 5555    # pi 上开启 client 并连接 server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，client 上会有报告：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -c 104.208.65.181 -p 5555
Connecting to host 104.208.65.181, port 5555
[  5] local 192.168.1.2 port 35994 connected to 104.208.65.181 port 5555
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  8.68 MBytes  72.8 Mbits/sec    0   2.95 MBytes
[  5]   1.00-2.00   sec  1.25 MBytes  10.5 Mbits/sec  2018    252 KBytes
[  5]   2.00-3.00   sec  2.50 MBytes  21.0 Mbits/sec  1076    286 KBytes
[  5]   3.00-4.00   sec  3.75 MBytes  31.5 Mbits/sec  861    237 KBytes
[  5]   4.00-5.00   sec  2.50 MBytes  21.0 Mbits/sec   99    187 KBytes
[  5]   5.00-6.00   sec  1.25 MBytes  10.5 Mbits/sec    0    206 KBytes
[  5]   6.00-7.00   sec  2.50 MBytes  21.0 Mbits/sec    0    215 KBytes
[  5]   7.00-8.00   sec  2.50 MBytes  21.0 Mbits/sec    0    218 KBytes
[  5]   8.00-9.00   sec  2.50 MBytes  21.0 Mbits/sec    0    218 KBytes
[  5]   9.00-10.00  sec  2.50 MBytes  21.0 Mbits/sec    0    220 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  29.9 MBytes  25.1 Mbits/sec  4054             sender
[  5]   0.00-10.09  sec  26.5 MBytes  22.1 Mbits/sec                  receiver

iperf Done.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看出 client 对 server 的上行带宽大约是 22Mbit/sec。&lt;/p&gt;&lt;p&gt;类似的，server配置不变，client加上 -R 参数后可以测试出 server 对 client 的下行带宽：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -c 104.208.65.181 -p 5555 -R
Connecting to host 104.208.65.181, port 5555
Reverse mode, remote host 104.208.65.181 is sending
[  5] local 192.168.1.2 port 36000 connected to 104.208.65.181 port 5555
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-1.00   sec  6.47 MBytes  54.3 Mbits/sec
[  5]   1.00-2.00   sec  25.7 MBytes   216 Mbits/sec
[  5]   2.00-3.00   sec  13.2 MBytes   111 Mbits/sec
[  5]   3.00-4.00   sec  16.3 MBytes   137 Mbits/sec
[  5]   4.00-5.00   sec  12.4 MBytes   104 Mbits/sec
[  5]   5.00-6.00   sec  14.4 MBytes   121 Mbits/sec
[  5]   6.00-7.00   sec  14.0 MBytes   117 Mbits/sec
[  5]   7.00-8.00   sec  13.9 MBytes   116 Mbits/sec
[  5]   8.00-9.00   sec  11.5 MBytes  96.7 Mbits/sec
[  5]   9.00-10.00  sec  11.3 MBytes  95.2 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.09  sec   142 MBytes   118 Mbits/sec  2560             sender
[  5]   0.00-10.00  sec   139 MBytes   117 Mbits/sec                  receiver

iperf Done.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看出 server 对 client 的下行带宽大约是 117Mbit/sec。&lt;/p&gt;&lt;h2 id=&quot;cpu%E5%86%85%E5%AD%98&quot;&gt;CPU&amp;amp;内存&lt;/h2&gt;&lt;h3 id=&quot;sysbench&quot;&gt;sysbench&lt;/h3&gt;&lt;p&gt;对于CPU和内存的性能测试，可以使用 &lt;a href=&quot;https://github.com/akopytov/sysbench&quot;&gt;sysbench&lt;/a&gt; 工具。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install sysbench -y # Debian 下
$ brew install sysbench        # MacOS 下&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于我的树莓派测试如下：&lt;/p&gt;&lt;p&gt;CPU单线程测试，可以看出单核每秒操作数大约1483：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sysbench cpu --threads=1 run
sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Prime numbers limit: 10000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:  1483.17

General statistics:
    total time:                          10.0002s
    total number of events:              14839

Latency (ms):
         min:                                    0.67
         avg:                                    0.67
         max:                                    1.88
         95th percentile:                        0.68
         sum:                                 9992.91

Threads fairness:
    events (avg/stddev):           14839.0000/0.00
    execution time (avg/stddev):   9.9929/0.00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内存读写测试，可以看出读写速度约是 1814MiB 每秒：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sysbench memory run
sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Running memory speed test with the following options:
  block size: 1KiB
  total size: 102400MiB
  operation: write
  scope: global

Initializing worker threads...

Threads started!

Total operations: 18590983 (1858174.07 per second)

18155.26 MiB transferred (1814.62 MiB/sec)


General statistics:
    total time:                          10.0001s
    total number of events:              18590983

Latency (ms):
         min:                                    0.00
         avg:                                    0.00
         max:                                    0.20
         95th percentile:                        0.00
         sum:                                 4463.57

Threads fairness:
    events (avg/stddev):           18590983.0000/0.00
    execution time (avg/stddev):   4.4636/0.00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，对 MacOS 的 CPU benchmark 似乎有坑，测试出来的结果异常的大，不具有参考价值。&lt;/p&gt;&lt;h3 id=&quot;md5sum&quot;&gt;md5sum&lt;/h3&gt;&lt;p&gt;虽然 sysbench 的基准测试看起来比较靠谱，但是实际环境下，真正的执行效率还跟执行的指令啥的都有挺大关系。比如，我们以执行 md5 的速度来对比 CPU 的执行效率：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dd if=/dev/zero bs=1M count=1024 | md5sum
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 5.81996 s, 184 MB/s
cd573cfaace07e7949bc0c46028904ff  -&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;code&gt;dd&lt;/code&gt; 命令向 &lt;code&gt;md5sum&lt;/code&gt; 持续发送 1GB 的数据进行计算，计算的速度也可以看成是 CPU 单核性能的一种指标。（考虑到管道操作是单线程，这个指令其实也只能用到一个核）&lt;/p&gt;&lt;p&gt;然后，如果我们多找几个 CPU 进行以下对比，我们就会发现一些神奇的现象：&lt;/p&gt;&lt;h4 id=&quot;cortex-a72%EF%BC%88arm%EF%BC%89&quot;&gt;Cortex-A72（ARM）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：1479.99 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：184 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;neoverse-n1%EF%BC%88arm%EF%BC%89&quot;&gt;Neoverse-N1（ARM）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：3497.70 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：424 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-platinum-8171m-cpu-260ghz%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：820.19 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：409 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-cpu-e5-26xx-v4%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) CPU E5-26xx v4（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：927.74 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：459 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-platinum-8255c-cpu-250ghz%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：1054.30 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：515 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以发现 ARM 架构的机器在 sysbench 上表现几乎都比 X86_64 的机器好很多，但是实际跑 md5sum 却相差不大甚至差不少。&lt;/p&gt;&lt;p&gt;可见不同架构间二者的指标并不完全正相关；不过相同架构间二者的指标还是基本正相关的。&lt;/p&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://romanrm.net/dd-benchmark&quot;&gt;dd-benchmark&lt;/a&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man8/hdparm.8.html&quot;&gt; &lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man8/hdparm.8.html&quot;&gt;man-hdparm&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://iperf.fr/iperf-doc.php#doc&quot;&gt;iperf&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edde4724c4d4e9762ce0d3515a394cc5</guid>
<title>用 Charles 断点调试 HTTPS 请求，原理揭秘</title>
<link>https://toutiao.io/k/hnbu55g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的网站基本都是 https 的，而 charles 是常用的 http 抓包工具，所以用 charles 调试 https 请求是常见的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就分享下如何用 charles 调试 https 请求，如何打断点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装 charles，点击 start recording：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31950207468879666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JxXywNZ7nbTYk2ibzkXOdPJiat1CSGawdGPQAWr2QSkXRiaOXhTqbd836A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器访问一些页面，这时候左侧就会展示出抓到的 http/https 请求：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6199701937406855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JER0xZ22YzWia4DJYt36zAOUNkhhxLGoITBt1Po7qTBESOnhH7VcTyTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这时候抓到的是加密过后的内容，这是 https 的机制导致的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34175334323922735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J7yLeKvKzZTHzLPbTOw6FsY6PjdKWVlWqbbucR4rQCT7T21jW5gTGmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端会下发被 CA 认证过的证书，里面包含了公钥，而服务器自己保留私钥，通过这种机制完成对称密钥的传输和身份的认证，之后加密传输数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间人拿到的数据自然都是被加密过的，也就是上图的那些乱码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37830319888734354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JZ5ic56kK1ibbcp8OZZIXTp2rCJfyZR0xdb6WfehiangakDTdziamXgQbnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那抓包工具怎么能拿到明文的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己用服务端的证书和服务端对接不就行了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24619289340101522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Jj4Q3dwPGUq5nn9dMPhZFfqLTWZoic7vShfNXGvdGeT4hFfRvVITPhYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Charles 自己用服务端的证书来和服务端通信，然后给浏览器一个自己的证书，这样就能解密传输的内容，拿到明文数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 Proxy 的 SSL Proxy Setting：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7525773195876289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JnLh1oZhPalibFgtk6VLSDzgA3iaAqhMicJRcdOwKM8u5XBGlQVbEnSK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加一条对 juejin 的 https 代理：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8082901554404145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Jj8nAiaeldzJuHib1QGL6RJDH70ibicjn5hvicYG79tfZwuzDyRhlsm1TKMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 juejin 之前的证书：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6383442265795207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JoibRMYepyoRbyHwF59B3HOlh3iccqTGJNLhGJqlk9VyWrY2UVT5LEtzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1836&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理之后就换成了 Charles 的证书，但是会提示不安全：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6749760306807286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Ja089OYYrthv1DHzibobb0APccNMtqpQfLhPC2Skgo8m7TOY53L6tUhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2086&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5479009687836384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J6emLXtspicPgAWNib3OlnpKOfgxzWFnHKiaOicF0om8iciazG7NyKqs0J1Pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1858&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为系统有一个存放所有根证书的地方，要那里存在并且被信任的证书才是安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 help &amp;gt; SSL Proxying &amp;gt; Install Charles Root Certificate，安装到系统的钥匙串中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40544871794871795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JNDialia8g3HMMuddvmYzq5B1Pmwp8FFt6TEIjudOPoVPkooAvcseXsNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1248&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改为始终信任：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0803858520900322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JWviaIab5CEkAjqmX4Kd5lWOIib36IiaicnJqbyWgmjvNudhUfmXnVRAib0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候浏览器里就会标记安全了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43333333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JStw9cFCYwxWhJgvLn7R7hE0vSAZ0pcmibibrjHttS8G9Zhnia7mL7fSpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且在 charles 里就会看到明文的 http 请求和响应内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8584779706275033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JnEetIJiavgrVJZzJczMFovxG90Lbx4VibvHN0oMXALysibs9SFXFx3VjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程的原理就是这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24619289340101522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JibeRtscaHrn6dtsJSSLsw5kRHYG9I0L2f2GtcibSicXaGAmic6AhCYfXVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在能够抓 https 包了，但是还不够，现在只能看，很多情况下我们是希望能修改一下请求和响应内容的，这时候就要用断点功能了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键请求，勾选 breakpoints：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.260180995475113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JT5DVkKKXFcRf5OaibfhPsH4NGQSLw3pljibDVpS61ljicpmVpPwZltJhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后开启断点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3169877408056042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JiaMNzsSDNOMYZhpZd5FaibNEg7zj6ExHvwV2fEZTSnQibiaEOicPNiaQnVKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷新页面你会发现它断住了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6733333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JFWTXwibgfA6S16wov5vBbhz2aLf138wfjeMsOWFFHYD98bHN9vF61Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面三个按钮分别是取消、终止、执行修改后的请求的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面可以改 url，添加 header，还可以改请求内容和 cookie：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7567567567567568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JTqsORTXqrjibicrD0qN2AaDsZHYKlZVxricRAs1Ut4mibKQUnNqaPRX6pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 execute 之后就会发送请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后响应的时候还会断住，这时候就可以用同样的方式修改响应了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7451487710219923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JsCE8NjnVLiciczLFeOh3NjQgkica10qmB7qn8XxjEH25qmoOibZJ3MFPfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我把 title 修改了一下，点击 execute 之后，看到的网页就是修改过后的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6155988857938719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JbqCbRGBAeENX3lAg0B6LZd56958qWCeY3GU56mS0Zmb4FkKh5icNR8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就可以断点调试 https 请求了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么可以实现断点功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个很容易想明白，怎么请求、怎么响应都是 Charles 控制的，那想实现一个断点和编辑的功能，岂不是很容易么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学可能会问，移动端怎么调试呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实是一样的，只不过移动端也要把 Charles 证书安装到自己的系统中，需要点击安装 charles 证书到移动设备：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3909313725490196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JYBib58sp9zfickKX5IeYsuNDKOAfdgY54UosWIicfo55olSlFaRdPnFOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他会提示你在手机设置代理服务器，然后下载 Charles 证书：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1206896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J8AGeA8RV6juqyWMlfGibOdq7iapP69GYLibNz186I54PhXzv3OPYKTGRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理和我们在 PC 端下载 Charles 证书是一样的，后续流程也一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此以外，chrome 还有一个浏览器插件可以更细粒度的控制代理，叫做 SwitchyOmega：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8913934426229508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JwibnHjeun0zlTRsaSbzLFhk1nWOQgs9klH1iarulka6eDUPLA2vYlwyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以配置若干个代理服务器，比如 charles 的代理服务器：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3214936247723133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JAcFWgia64CmMdz4OUrOS7nRpXvgGnr5z6teLicIxmkwtLgEq7tCglY5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可以在 Charles 的 Proxy &amp;gt; Proxy Setting 里配置：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8825561312607945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JPdAxpcWGZoqhdnI8bFuiaibuTRg9IhoIO7M9eKWuZzRzyD7rVSDYBJDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就可以配置什么 url 用什么代理，或者不用代理直接连接：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33678756476683935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JqPe7pvI9A5mCsht1ba5P891OqK7ypJF3c6KP9dGDU69zyIj7wYfx1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2316&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你有多个代理服务器，或者想控制有的页面走代理有的不走的时候，就可以用这个插件来控制了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Charles 调试 https 请求是常见的需求，它需要安装 Charles 的证书到本地系统，然后信任，之后就可以抓到明文数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理就是 Charles 会使用服务器的证书来和服务器通信，然后发一个自己的证书给浏览器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Charles 还有断点调试功能，可以修改请求和响应的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;移动端 https 调试也是同样的原理，只不过需要配置下代理和证书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想切换代理服务器或者设置有的页面不走代理，可以用 Chrome 插件 SwitchyOmega 来控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会断点调试 https 请求还是很有意义的，比如改改 header、改改 body，看看会有啥效果，使用场景有很多。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>baf3b3d298b5c2e9fe845ea3dccab33f</guid>
<title>Spring 事务的这 10 种坑使得事务失效了</title>
<link>https://toutiao.io/k/c5l12vd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92275&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。在某些业务场景下，如果同时有多张表的写入操作，为了保证操作的原子性（要么同时成功，要么同时失败）避免数据不一致的情况，我们一般都会使用spring事务。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;没错，spring事务大多数情况下，可以满足我们的业务需求。但是今天我要告诉大家的是，它有很多坑，稍不注意事务就会失效。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;不信，我们一起看看。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1.错误的访问权限&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须是public的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，如果目标方法不是public，则TransactionAttribute返回null，即不支持事务。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute computeTransactionAttribute(Method method, @Nullable &lt;span&gt;&lt;span&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; &lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// The method may be on an interface, but we need attributes from the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// If the target class is null, the method will be unchanged.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// First try is the method in the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// Second try is the transaction attribute on the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (specificMethod != method) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// Fallback is to look at the original method.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      txAttr = findTransactionAttribute(method);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// Last fallback is the class of the original method.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      txAttr = findTransactionAttribute(method.getDeclaringClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.方法被定义成final的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法被定义成了final的，这样会导致spring aop生成的代理对象不能复写该方法，而让事务失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.方法内部调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        updateStatus(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateStatus&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;// doSameThing();&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4.当前实体没有被spring管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以看到UserService类没有定义@Service注解，即没有交给spring管理bean实例，所以它的add方法也不会生成事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5.错误的spring事务传播特性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NEVER)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。只有这三种传播特性才会创建新事务：PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;6.数据库不支持事务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;msql8以前的版本数据库引擎是支持myslam和innerdb的。我以前也用过，对应查多写少的单表操作，可能会把表的数据库引擎定义成myslam，这样可以提升查询效率。但是，要千万记得一件事情，myslam只支持表锁，并且不支持事务。所以，对这类表的写入操作事务会失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;7.自己吞掉了异常&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种情况下事务不会回滚，因为开发者自己捕获了异常，又没有抛出。事务的AOP无法捕获异常，导致即使出现了异常，事务也不会回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;8.抛出的异常不正确&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) throws Exception {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt;(e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种情况下，开发人员自己捕获了异常，又抛出了异常：Exception，事务也不会回滚。因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），不会回滚Exception。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;9.多线程调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            roleService.doOtherThing();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }).start();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的，这样会导致两个事务方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final ThreadLocal&amp;lt;Map&amp;lt;&lt;span&gt;Object&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; resources =&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;10.嵌套事务多回滚了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        roleService.doOtherThing();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NESTED)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;why?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么样才能只回滚保存点呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) throws Exception {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;roleService&lt;/span&gt;&lt;span&gt;.doOtherThing&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在代码中手动把内部嵌套事务放在try/catch中，并且不继续往抛异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;介绍到这里，你会发现spring事务的坑还是挺多的~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;来源：苏三说技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;链接：https://juejin.cn/post/6863796940069568520&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a96e940245270912c9ae5195aa767c3</guid>
<title>关于AspectJ，你知道多少？</title>
<link>https://toutiao.io/k/e7r4jd1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从学习spring起，&lt;code&gt;AOP&lt;/code&gt;这个词几乎是天天挂在嘴边，好像一切都是天经地义的。尤其在springboot里面，经常见到的&lt;code&gt;@Before&lt;/code&gt; &lt;code&gt;@After&lt;/code&gt;等之类的内容，一般更是没有多少解释，通常被告知&quot;这是aop的用法&quot;。能有人特别说明一下下面这点信息就算不错的了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Before&lt;/code&gt; &lt;code&gt;@After&lt;/code&gt;等这些的实现，底层是 &lt;code&gt;aspectj&lt;/code&gt; 。官网地址：aspectJ官网&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;aspectj&lt;/code&gt;并不天然是&lt;code&gt;spring framework&lt;/code&gt;的一部分，人家本是一个独立项目，以优秀的方式实现了aop；还有一些其他的aop实现，如&lt;code&gt;Jboss Aop&lt;/code&gt;什么的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;spring framework&lt;/code&gt;有自己的aop实现，但难用，麻烦；后来spring官方索性将 优秀的&lt;code&gt;aspectj&lt;/code&gt; 集成到了&lt;code&gt;spring framework&lt;/code&gt;源码中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从此以后就成了现在我们看到的&lt;code&gt;spring framework&lt;/code&gt;的aop似乎天然就是&lt;code&gt;aspectj&lt;/code&gt;的样子。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我总觉得不对劲，距离透彻的理解，似乎总差着一段距离。于是今天势必追查清楚，求个究竟。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引出具体问题&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，明确一个基本事实，就是 ：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;aspectj&lt;/code&gt;并不天然是&lt;code&gt;spring framework&lt;/code&gt;的一部分，它本是一个独立项目，它以自己的方式实现了aop；&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们就不仅仅是一定要把它用在spring项目中；比如我想把它用在我的一个简单的控制台项目中，该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然地，网上的文章一大抄，基本上一搜都是教你什么是 pointcut，什么是 joinpoint等等，然后如何用在&lt;code&gt;springboot&lt;/code&gt;项目中。这个太简单，太程式化，已经麻木了，不值一提。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现步骤&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过一些搜索、尝试，起初我的项目并没有如预期一样执行，输出的指定的 before after之类的内容。经过更多的搜索和思考，想明白了原理之后，一切都变得水到渠成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，在外网搜到一个有用的文章，给了我很多启发。How to create a Hello World with IntelliJ and Aspect J里面的步骤也挺详细的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;正式进入实现步骤&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 安装编译器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要正常使用aspectj将自己写好的pointcut等内容织入到对应的class文件，这是一个类似于编译的过程。就像编译C语言需要gcc编译器，编译java需要javac编译器一样(当然也可能是别的编译器)。我们需要下载&lt;code&gt;aspectj&lt;/code&gt;，并安装在我们的电脑中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载和安装步骤依次如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载地址:https://www.eclipse.org/aspectj/downloads.php&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4661582459485224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QwEovU8rw8bOqicsKrg9Fsu1icRiceVyVpJujJAQTXiaOtpFboetibn0dOfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1049&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6049382716049383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QOibibEl1O6iaXFicaibiaQI2LSyel8Zj4gnJbpu92Lh0YfMnrPtQYRYFib47g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3923076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QD6D1gotNf8eriamR1B54ajvUvwPUJtibWAbH3D6KsKHKiakYiaxnCPcQFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;390&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QuZibtibvE3DjOp05HMzMLzwhIfib5lqibuDDvX8qlJHQZY3KjKX2YdMtzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QqEBedGkRol4SfMRGHgqX3hUz6yYGkX3U5S1J2aktmK4LsyPoEU1icxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QiaUGgHKGKaKdhzwZ7RLbiaa7xQ1W1Bic1ARlpUZVuVAuuAOgD4ribO2tzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QlngZZaIPMDhhaA7shKqkNCJcemKguRBFPc0wBgz9l11XM6Mt460l9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;截至此处，已经下载并安装了 aspectj到本地。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.配置环境变量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地，类似我们安装了jdk到本地，但cmd命令行里并不能直接使用&lt;code&gt;javac xxx.java&lt;/code&gt;命令，就是因为我们没有把&lt;code&gt;javac&lt;/code&gt;可执行文件配置到我们的&lt;code&gt;path&lt;/code&gt;环境变量里。&lt;br/&gt;这个aspect编译器也一样，同样需要配置环境变量。如下图：我只配置了&lt;code&gt;CLASSPATH&lt;/code&gt;，并且只把&lt;code&gt;C:\aspectj1.9\lib\aspectjrt.jar&lt;/code&gt;配置进去就最终成功了。&lt;img data-ratio=&quot;0.6382978723404256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qiaq0PSv1k8DyrGw2zwDO1DBsadriaNL3mufMZUt9qNyLpA5p6D4gia5FQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 验证一下&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随便试了一下，&lt;code&gt;ajc xxx&lt;/code&gt;，别管它报错不报错，有反应就行。说明这个ajc编译器已经成功地配置并且可用了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.693089430894309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QMKpObMkNhfFzSlQ65fdhls56J2qIe3BaLoTTPNyQ1PHAIA7ES1TX6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;至此，系统级环境配置结束。开始设法将&lt;code&gt;aspectj&lt;/code&gt;用在常规项目中。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IDEA新建一个最简单的项目&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 新建一个空maven项目&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3529962546816479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QzOhpSzI6F21WjV4m571LvENaibib2Y2iaHxGrzJpt73LaNFwg4k6WLLmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 添加&lt;code&gt;aspectj&lt;/code&gt;依赖&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4955947136563877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qzdy2ZtADI0RvMSNZ5qWGN22co31cjSFdYbyNg9UHFO1hxtVAEfVbSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 随便写个mai方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24836601307189543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qgc30T49zCGUzG1QKpcNYjnzLMot3NbzgFBNcuAXCq0rFux19j75oHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.新增一个&lt;code&gt;AspectJ&lt;/code&gt;文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21074380165289255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QYFGlGWr4TfG7pn9N8I7vKnlvmr7DqR5JHZcDANu6RJFhIAruf4dOUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;我猜测这里之所以能这么新增，是因为我的IDEA已经安装了aspectj插件。来看一下。&lt;img data-ratio=&quot;0.5073170731707317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QrULsF0LsO4qJXHMYoFOD6SeaiapOJO1FUoldngudyPyuXKbxw2ibPZ8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;应该是上图两个插件中的第一个，不去验证了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. &lt;code&gt;aspectj&lt;/code&gt;文件里添加&lt;code&gt;pointcut&lt;/code&gt;等内容&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就可以在其他网页里随便抄一段了。如&lt;img data-ratio=&quot;0.29054726368159206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QoMGIiaib3mMUAoMVeXq1zYWViaIhSbPxjvzOUs2f8KicTmd8jKF9mrG1Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;显然，这里我是试图在 main方法调用之前拦截到的。如果能拦截到，则控制台会输出绿色字的内容。下面直接启动一下main方法，看效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27419354838709675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qg9b3PG4mDhW0a9MJgsTLwRGXk5lOSricPiccx9KhoAamRBIEpY8siaWOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;然而并没有。不管你再怎么clean，clean install，rebuild，等等等等，都一样，不用再试了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开始思考和解决&lt;code&gt;aspectj&lt;/code&gt;为什么不生效&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码居然有了个&lt;code&gt;aspectj&lt;/code&gt;关键字，居然编译没报错，已经很让我惊讶了。难道jdk编译的时候认识它？或者是由于插件的原因，使它显示为蓝色？但编译为什么没报错呢？既然没报错那为什么又不生效呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过网上搜索查资料和思考，我悟了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原因其实也很简单，就是这段代码不应该由jdk来编译，因为jdk又不知道遇到aspect该怎么办；而应该由 &lt;code&gt;aspectj&lt;/code&gt;提供的编译功能来编译，也即&lt;code&gt;ajc&lt;/code&gt;。(但我也没弄明白为什么有aspect字，jdk编译却不报错)&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 下面开始给IDEA配置&lt;code&gt;ajc&lt;/code&gt;编译器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5913461538461539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Q0mSMJSAkb02WrsMGNibDVM4VzoDrSyl8tDrzLEGkG6dYdzzbgyBuCCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5379939209726444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QnqAdw6MAAiaiblO2K2HS2iazFR2cTP449PRXFlC8ZZQ9D15iaiaAuZsDImA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;img data-ratio=&quot;0.3282336578581363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QQibrUPrkNRnJngjVucr0SyGELEAAl7q97tUWuwKO2MVwJc4kYnkO6sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;给&lt;code&gt;Path to aspectjtools.jar&lt;/code&gt;配置路径，测试一下，如下图。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18115055079559364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qwmss3ocPkqVA2WZ3ngCcMhyXnZiak5eyKkthJwiaqkwBzFkKFiaLkos1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 此时让我们再编译一下项目&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果配置正确的话，现在我们就是用&lt;code&gt;ajc&lt;/code&gt;编译的了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 然后运行：&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5649779735682819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QJrXCd84FbTzrKDiaOXuia8m7l1NE22OeMlAwjsOaFQb8FCOCsWzgqibtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;立竿见影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此完整演示成功。基本原理，总结起来就是&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;安装aspectj，也就有了aspectj编译器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目中配置编译器，使用ajc编译器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目中新增aspect文件，指定各种切点等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ajc编译项目，生成符合预期的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几行 的demo，地址如下：aspectj-demo.zip&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此文真的给你解惑了，或者起到了帮助，可考虑打赏。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;后记补充&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写完之后，我以为就完了，但是后来马上又发现了问题。就是在前面引入的两个maven依赖，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &amp;lt;dependencies&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;aspectjrt&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;1.8.7&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;1.8.7&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;/dependencies&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它为什么要是两个依赖呢？我偶然地发现，一个依赖也能正常执行。更奇怪的是，这两个依赖，只依赖任何一个就可以正常执行了。已经亲测@2021年8月23日23点04分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这里又引出了下一个问题&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;aspectjrt&lt;/code&gt;和&lt;code&gt;aspectjweaver&lt;/code&gt;是什么关系，各自有什么作用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在来看一下&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4088541666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QNuFpbOPibVic6HNialOd9RZBQ2MVc3EEIPZ3ywTFbCUCWmvC0rTOSBjKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;由图可知，这是很明显的，&lt;code&gt;aspectjweaver&lt;/code&gt; 包含了&lt;code&gt;aspectjrt&lt;/code&gt;全部的内容。另外主要多出来的内容，以我的经验，我一眼就看出了重点：（以下是猜测，但我感觉是对的）
后者比前者多出的内容，主要是 &lt;code&gt;asm&lt;/code&gt; 和 &lt;code&gt;weaver&lt;/code&gt;。那么，&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;asm是什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ASM 是一个 Java 字节码操控框架。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;weaver是什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;weaver这个词，就是“织入”的意思啊，字面意思不解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，很明显，weaver + asm，实现了可以动态织入 pointcut等内容到字节码中去的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，下一步再可以得出推论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推论&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;aspectjrt&lt;/code&gt; 功能单纯一些，应该是提供一个&lt;code&gt;编译过后的已经织入了pointcut等内容的java字节码的程序的运行环境&lt;/code&gt;。关键词：&lt;code&gt;rt&lt;/code&gt;，也就是 &lt;code&gt;runtime&lt;/code&gt;。这个概念我们已经比较熟悉了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;aspectjweaver&lt;/code&gt; 包含了&lt;code&gt;aspectjrt&lt;/code&gt;全部内容，另外多出了 &lt;code&gt;动态织入的能力&lt;/code&gt;，主要是&lt;code&gt;asm + weaver&lt;/code&gt;部分的代码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例中，之所以需要配置ajc编译器，要编译之后才能正常执行，正是因为推论1的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而推论2
我猜测多出来的这部分能力，就是让java项目可以不用再专门指定ajc编译器，而是使用&lt;code&gt;asm + weaver&lt;/code&gt;可以对java代码进行动态编译和织入内容，这样的话直接使用通用的javac编译器就可以了。当然，还看得出来，也支持了注解的用法。顺便多说一句，&lt;strong&gt;这个情况我已经用代码验证了，符合猜想，大概是对的无疑了&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ps: spring项目应用三步曲:  &lt;code&gt;aspect&lt;/code&gt;(需要标记为@Component) --&amp;gt; &lt;code&gt;pointcut&lt;/code&gt; --&amp;gt; &lt;code&gt;advice&lt;/code&gt;看似不起眼，其实ps:这句话很精髓，懂的自然懂。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以&lt;/strong&gt;，项目里，想要使用aspectj注解的写法，需要引入 &lt;code&gt;aspectjweaver&lt;/code&gt; 而不是&lt;code&gt;aspectjrt&lt;/code&gt; ，比如&lt;code&gt;spring&lt;/code&gt;里的aop相关的用法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果愿意自己指定ajc编译器，则可只引入体积较小的&lt;code&gt;aspectjrt&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我忽然觉得自己理解得更通透了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>84dcb0f6d57420efbc438349abba9a77</guid>
<title>深入浅出音视频与 WebRTC</title>
<link>https://toutiao.io/k/79lidh8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1642080622978=&quot;0&quot; data-index-1642080622978=&quot;0&quot;&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index-1646223552202=&quot;0&quot; data-index-1646223552202=&quot;0&quot;&gt;大&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;0&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1642080622978=&quot;1&quot; data-index-1642080622978=&quot;1&quot;&gt;&lt;span data-raw-text=&quot;厂&quot; data-textnode-index-1646223552202=&quot;1&quot; data-index-1646223552202=&quot;1&quot;&gt;厂&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;0&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1642080622978=&quot;2&quot; data-index-1642080622978=&quot;2&quot;&gt;&lt;span data-raw-text=&quot;技&quot; data-textnode-index-1646223552202=&quot;2&quot; data-index-1646223552202=&quot;2&quot;&gt;技&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;0&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1642080622978=&quot;3&quot; data-index-1642080622978=&quot;3&quot;&gt;&lt;span data-raw-text=&quot;术&quot; data-textnode-index-1646223552202=&quot;3&quot; data-index-1646223552202=&quot;3&quot;&gt;术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;4&quot; data-index-1642080622978=&quot;4&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;4&quot; data-index-1646223552202=&quot;4&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;1&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;5&quot; data-index-1642080622978=&quot;5&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;5&quot; data-index-1646223552202=&quot;5&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;2&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1642080622978=&quot;6&quot; data-index-1642080622978=&quot;6&quot;&gt;&lt;span data-raw-text=&quot;坚&quot; data-textnode-index-1646223552202=&quot;6&quot; data-index-1646223552202=&quot;6&quot;&gt;坚&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;2&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1642080622978=&quot;7&quot; data-index-1642080622978=&quot;7&quot;&gt;&lt;span data-raw-text=&quot;持&quot; data-textnode-index-1646223552202=&quot;7&quot; data-index-1646223552202=&quot;7&quot;&gt;持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;2&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1642080622978=&quot;8&quot; data-index-1642080622978=&quot;8&quot;&gt;&lt;span data-raw-text=&quot;周&quot; data-textnode-index-1646223552202=&quot;8&quot; data-index-1646223552202=&quot;8&quot;&gt;周&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;2&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1642080622978=&quot;9&quot; data-index-1642080622978=&quot;9&quot;&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index-1646223552202=&quot;9&quot; data-index-1646223552202=&quot;9&quot;&gt;更&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;10&quot; data-index-1642080622978=&quot;10&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;10&quot; data-index-1646223552202=&quot;10&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;3&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1642080622978=&quot;11&quot; data-index-1642080622978=&quot;11&quot;&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index-1646223552202=&quot;11&quot; data-index-1646223552202=&quot;11&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;4&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1642080622978=&quot;12&quot; data-index-1642080622978=&quot;12&quot;&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index-1646223552202=&quot;12&quot; data-index-1646223552202=&quot;12&quot;&gt;精&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;4&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1642080622978=&quot;13&quot; data-index-1642080622978=&quot;13&quot;&gt;&lt;span data-raw-text=&quot;选&quot; data-textnode-index-1646223552202=&quot;13&quot; data-index-1646223552202=&quot;13&quot;&gt;选&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;4&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1642080622978=&quot;14&quot; data-index-1642080622978=&quot;14&quot;&gt;&lt;span data-raw-text=&quot;好&quot; data-textnode-index-1646223552202=&quot;14&quot; data-index-1646223552202=&quot;14&quot;&gt;好&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;4&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1642080622978=&quot;15&quot; data-index-1642080622978=&quot;15&quot;&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index-1646223552202=&quot;15&quot; data-index-1646223552202=&quot;15&quot;&gt;文&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文为来自 &lt;strong&gt;教育-成人与创新-前端团队&lt;/strong&gt; 成员的文章，已授权 ELab 发布。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;常见的音视频网络通信协议&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;普通直播协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类直播对实时性要求不那么高，使用CDN进行内容分发，会有几秒甚至十几秒的延时，主要关注画面质量、音视频是卡顿等问题，一般选用 RTMP 和 HLS 协议&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本概念&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RTMP&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RTMP （Real Time Messaging Protocol），即“实时消息传输协议”， 它实际上并不能做到真正的实时，一般情况最少都会有几秒到几十秒的延迟，是 Adobe 公司开发的音视频数据传输的实时消息传送协议，RTMP 协议基于 TCP，包括 RTMP 基本协议及 RTMPT/RTMPS/RTMPE 等多种变种，RTMP 是目前主流的流媒体传输协议之一，对CDN支持良好，实现难度较低，是大多数直播平台的选择，不过RTMP有一个最大的不足 —— 不支持浏览器，且苹果 ios 不支持，Adobe 已停止对其更新&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RTMP目前在 PC 上的使用仍然比较广泛&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;HLS&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HLS （Http Live Streaming）是由苹果公司定义的基于 HTTP 的流媒体实时传输协议，被广泛的应用于视频点播和直播领域，HLS 规范规定播放器至少下载一个 ts 切片才能播放，所以 HLS 理论上至少会有一个切片的延迟&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HLS 在移动端兼容性比较好，ios就不用说了，Android现在也基本都支持 HLS 协议了，pc端如果要使用可以使用 hls.js 适配器&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HLS 的原理是将整个流分为多个小的文件来下载，每次只下载若干个，服务器端会将最新的直播数据生成新的小文件，当客户端获取直播时，它通过获取最新的视频文件片段来播放，从而保证用户在任何时候连接进来时都会看到较新的内容，实现近似直播的体验；HLS 的延迟一般会高于普通的流媒体直播协议，传输内容包括两部分：一部分 M3U8 是索引文件，另一部分是 TS 文件，用来存储音视频的媒体信息&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RTMP 和 HLS 如何选择&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;流媒体推流，一般使用 RTMP 协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移动端的网页播放器最好使用 HLS 协议，RTMP 不支持浏览器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;iOS 要使用 HLS 协议，因为不支持 RTMP 协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;点播系统最好使用 HLS 协议，因为点播没有实时互动需求，延迟大一些是可以接受的，并且可以在浏览器上直接观看&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;普通直播基本架构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由&lt;strong&gt;直播&lt;/strong&gt; &lt;strong&gt;客户端&lt;/strong&gt; &lt;strong&gt;、&lt;/strong&gt; &lt;strong&gt;信令&lt;/strong&gt; &lt;strong&gt;服务器和&lt;/strong&gt; &lt;strong&gt;CDN&lt;/strong&gt; &lt;strong&gt;网络&lt;/strong&gt;这三部分组成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;直播&lt;/strong&gt; &lt;strong&gt;客户端&lt;/strong&gt;主要包括音视频数据的采集、编码、推流、拉流、解码与播放功能，但实际上这些功能并不是在同一个客户端中实现的，为什么呢？因为作为主播来说，他不需要看到观众的视频或听到观众的声音，而作为观众来讲，他们与主播之间是通过文字进行交流的，不需要向主播分享自己的音视频信息&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于主播客户端来说，它可以设备的摄像头、麦克风采集数据，然后对采集到的音视频数据进行编码，最后将编码后的音视频数据推送给 CDN&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于观众客户端来说，它首先需要获取到主播房间的流媒体地址，观众进入房间后从 CDN 拉取音视频数据，并对获取到的音视频数据进行解码，最后进行音视频的渲染与播放&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;信令&lt;/strong&gt; &lt;strong&gt;服务器&lt;/strong&gt;，主要用于接收信令，并根据信令处理一些和业务相关的逻辑，如创建房间、加入房间、离开房间、文字聊天等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CDN&lt;/strong&gt; &lt;strong&gt;网络&lt;/strong&gt;，主要用于媒体数据的分发，传给它的媒体数据可以很快传送给各地的用户&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实时直播协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着人们对实时性、互动性的要求越来越高，传统直播技术越来越满足不了人们的需求，WebRTC 技术正是为了解决人们对实时性、互动性需求而提出的新技术&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;WebRTC&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebRTC（Web Real-Time Communication），即“网页即时通信”，WebRTC 是一个支持浏览器进行实时语音、视频对话的开源协议，目前主流浏览器都支持WebRTC，即便在网络信号一般的情况下也具备较好的稳定性，WebRTC 可以实现点对点通信，通信双方延时低，使用户无需下载安装任何插件就可以进行实时通信&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在WebRTC发布之前，开发实时音视频交互应用的成本很高，需要考虑的技术问题很多，如音视频的编解码问题，数据传输问题，延时、丢包、抖动、回音的处理和消除等，如果要兼容浏览器端的实时音视频通信，还需要额外安装插件， WebRTC 大大降低了音视频开发的门槛，开发者只需要调用 WebRTC API 即可快速构建出音视频应用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面主要通过 WebRTC 的实时通信过程来对 WebRTC 有一个大概的了解&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;WebRTC&lt;/strong&gt; &lt;strong&gt;音视频通信的大体过程&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2464589235127477&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIp8RGogPtdFUjhpuwZLrE69uhF9m3sSBV7vz42u0iaBR9rACia6poLguVQp2nmwtiaibgUN4BnrAZUiaJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;353&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;音视频设备检测&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设备的基本原理&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;音频设备&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;音频输入设备的主要工作是采集音频数据，而采集音频数据的本质就是模数转换（A/D），即将模似信号转换成数字信号，采集到的数据再经过&lt;strong&gt;量化、编码&lt;/strong&gt;，最终形成&lt;strong&gt;数字信号&lt;/strong&gt;，这就是音频设备所要完成的工作&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;视频设备&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频设备，与音频输入设备很类似，视频设备的模数转换（A/D）模块即光学传感器， 将光转换成数字信号，即 RGB（Red、Green、Blue）数据，获得 RGB 数据后，还要通过 DSP（Digital Signal Processer）进行优化处理，如自动增强、色彩饱和等都属于这一阶段要做的事情，通过 DSP 优化处理后获得 RGB 图像，然后进行压缩、传输，而编码器一般使用的输入格式为 YUV，所以在摄像头内部还有一个专门的模块用于将 RGB 图像转为 YUV 格式的图像&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那什么是 YUV 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;YUV 也是一种色彩编码方法，它将亮度信息（Y）与色彩信息（UV）分离，即使没有 UV 信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题（这也是 YUV 设计的初衷）相对于 RGB 颜色空间，YUV 的目的是为了编码、传输的方便，减少带宽占用和信息出错，人眼的视觉特点是对亮度更敏感，对位置、色彩相对来说不敏感，在视频编码系统中为了降低带宽，可以保存更多的亮度信息，保存较少的色差信息&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;获取音视频设备列表&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MediaDevices.enumerateDevices()&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方法返回一个可用的媒体输入和输出设备的列表，例如麦克风，摄像机，耳机设备等&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;navigator.mediaDevices.enumerateDevices().&lt;span&gt;then&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;(deviceInfos) {&lt;br/&gt;  deviceInfos.forEach(&lt;span&gt;function&lt;/span&gt;(deviceInfo) {&lt;br/&gt;    console.log(deviceInfo);&lt;br/&gt;  });&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回的 deviceInfo 信息格式如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48264984227129337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIp8RGogPtdFUjhpuwZLrE693sPpm15YEwBYXAjWKDP6jQ0bIHuFv8U07l4ze62d8WlvUcjib66l5xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;出于安全原因，除非用户已被授予访问媒体设备的权限（要想授予权限需要使用 HTTPS 请求），否则 label 字段始终为空&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设备检测方法&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;返回信息 deviceInfo 中的 kind 字段可以区分出设备是音频设备还是视频设备，同时音频设备能区分出是输入设备和输出设备，我们平时使用的耳机它是一个音频设备，但它同时兼有音频输入设备和音频输出设备的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于音频设备和视频设备会设置各自的&lt;strong&gt;默认设备，&lt;/strong&gt; 还是以耳机这个音频设备为例，将耳机插入电脑后，耳机就变成了音频的默认设备，将耳机拔出后，默认设备又切换成了系统的音频设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在获取到所有的设备列表后，如果我们不指定某个具体设备，采集音视频数据时，就会从设备列表中的默认设备上采集数据，如果能从指定的设备上采集到音视频数据，那说明这个设备就是有效的设备，这样我们就可以对音视频设备进行一项一项检测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;strong&gt;调用 getUserMedia&lt;/strong&gt; 方法 &lt;strong&gt;（下面音视频采集的时候会讲到） 进行设备检测&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;视频设备检测：调用 getUserMedia API 采集视频数据并将其展示出来，如果用户能看到自己的视频，说明视频设备是有效的，否则，设备无效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;音频设备检测：调用 getUserMedia API 采集音频数据，由于音频数据不能直接展示，所以需要使用 JavaScript 将其处理后展示到页面上，这样当用户看到音频数值的变化后，说明音频设备也是有效的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;&lt;strong&gt;音视频采集&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本概念&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;帧率表示1秒钟视频内图像的数量，一般帧率达到 10～12fps 人眼就会觉得是连贯的，帧率越高，代表着每秒钟处理的图像数量越高，因此流量会越大，对设备的性能要求也越高，所以在直播系统中一般不会设置太高的帧率，高的帧率可以得到更流畅、更逼真的动画，一般来说 30fps 就是可以接受的，但是将性能提升至 60fps 则可以明显提升交互感和逼真感，但是一般来说超过 75fps 一般就不容易察觉到有明显的流畅度提升了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebRTC 中的“轨”借鉴了多媒体的概念，两条轨永远不会相交，“轨”在多媒体中表达的就是每条轨数据都是独立的，不会与其他轨相交，如 MP4 中的音频轨、视频轨，它们在 MP4 文件中是被分别存储的&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;音视频采集接口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;mediaDevices.getUserMedia&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const mediaStreamContrains = {&lt;br/&gt;    video: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    audio: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;const promise = navigator.mediaDevices.getUserMedia(mediaStreamContrains).&lt;span&gt;then&lt;/span&gt;(&lt;br/&gt;    gotLocalMediaStream&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;const &lt;span&gt;$video&lt;/span&gt; = document.querySelector(&lt;span&gt;&#x27;video&#x27;&lt;/span&gt;);&lt;br/&gt; &lt;br/&gt;&lt;span&gt;function&lt;/span&gt; gotLocalMediaStream(mediaStream){&lt;br/&gt;    &lt;span&gt;$video&lt;/span&gt;.srcObject = mediaStream;&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;&lt;span&gt;function&lt;/span&gt; handleLocalMediaStreamError(error){&lt;br/&gt;    console.log(&lt;span&gt;&#x27;getUserMedia 接口调用出错: &#x27;&lt;/span&gt;, error);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**&lt;span&gt;srcObject&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;**：属性设定或返回一个对象，这个对象提供了一个与 HTMLMediaElement 关联的媒体源，这个对象通常是 MediaStream，根据规范也可以是 MediaSource, Blob 或者 File，但对于 MediaSource, Blob 和File类型目前浏览器的兼容性不太好，所以对于这几种类型可以通过 URL.createObjectURL() 创建 URL，并将其赋值给 HTMLMediaElement.src&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MediaStreamConstraints&lt;/strong&gt; 参数，可以指定MediaStream中包含哪些类型的媒体轨（音频轨、视频轨），并且可为这些媒体轨设置一些限制&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const mediaStreamContrains = {&lt;br/&gt;    video: {&lt;br/&gt;       frameRate: {min: 15}, // 视频的帧率最小 15 帧每秒&lt;br/&gt;       width: {min: 320, ideal: 640}, // 宽度最小是 320，理想的宽度是 640&lt;br/&gt;       height: {min: 480, ideal: 720}，// 高度最小是 480，最理想高度是 720&lt;br/&gt;       facingMode: &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;， // 优先使用前置摄像头&lt;br/&gt;       deviceId: &lt;span&gt;&#x27;&#x27;&lt;/span&gt; // 指定使用哪个设备&lt;br/&gt;    },&lt;br/&gt;    audio: {&lt;br/&gt;       echoCancellation: &lt;span&gt;true&lt;/span&gt;, // 对音频开启回音消除功能&lt;br/&gt;       noiseSuppression: &lt;span&gt;true&lt;/span&gt; // 对音频开启降噪功能&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;浏览器实现自拍&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道视频是由一幅幅帧图像和一组音频构成的，所以拍照的过程其实是从连续播放的视频流（一幅幅画面）中抽取正在显示的那张画面，上面我们讲过可以通过 getUserMedia 获取到视频流，那如何从视频流中获取到正在显示的图片呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就要用到 canvas 的 &lt;span&gt;drawImage&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const ctx = document.querySelector(&lt;span&gt;&#x27;canvas&#x27;&lt;/span&gt;);&lt;br/&gt;// 需要拍照时执行此代码，完成拍照&lt;br/&gt;ctx.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;).drawImage(&lt;span&gt;$video&lt;/span&gt;, 0, 0);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; downLoad(url){&lt;br/&gt;    const &lt;span&gt;$a&lt;/span&gt; = document.createElement(&lt;span&gt;&quot;a&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;$a&lt;/span&gt;.download = &lt;span&gt;&#x27;photo&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;$a&lt;/span&gt;.href = url;&lt;br/&gt;    document.body.appendChild(&lt;span&gt;$a&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;$a&lt;/span&gt;.click();&lt;br/&gt;    &lt;span&gt;$a&lt;/span&gt;.remove();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 调用 download 函数进行图片下载&lt;br/&gt;downLoad(ctx.toDataURL(&lt;span&gt;&quot;image/jpeg&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;drawImage 的第一个参数支持 &lt;code&gt;HTMLVideoElement&lt;/code&gt; 类型，所以可以直接将 $video 作为第一个参数传入，这样就通过 canvas 获取到照片了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 a 标签的 download 将照片下载下来保存到本地&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过 canvas 的 toDataURL 方法获得图片的 URL 地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用 a 标签的 downLoad 属性来实现图片的下载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;音视频录制&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本概念&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ArrayBuffer 对象表示通用的、固定长度的二进制数据缓冲区，可以使用它存储图片、视频等内容，但ArrayBuffer 对象不能直接进行访问，ArrayBuffer 只是描述有这样一块空间可以用来存放二进制数据，但在计算机的内存中并没有真正地为其分配空间，只有当具体类型化后，它才真正地存在于内存中&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; buffer = new ArrayBuffer(16); // 创建一个长度为 16 的 buffer&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; view = new Uint32Array(buffer);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是Int32Array、Uint8Array、DataView等类型的总称，这些类型都是使用 ArrayBuffer 类实现的，因此才统称他们为 ArrayBufferView&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（Binary Large Object）是 JavaScript 的大型二进制对象类型，WebRTC 最终就是使用它将录制好的音视频流保存成多媒体文件的，而它的底层是由上面所讲的 ArrayBuffer 对象的封装类实现的，即 Int8Array、Uint8Array 等类型&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;音频录制接口&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const mediaRecorder = new MediaRecorder(stream[, options]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stream参数是将要录制的流，它可以是来自于使用 &lt;code&gt;navigator.mediaDevices.getUserMedia&lt;/code&gt; 创建的流或者来自于 audio，video 以及 canvas DOM 元素&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MediaRecorder.ondataavailable&lt;/code&gt;事件可用于获取录制的媒体资源 (在事件的 &lt;code&gt;data&lt;/code&gt; 属性中会提供一个可用的 Blob 对象)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;录制的流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 getUserMedia 接口获取视频流数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 MediaRecorder 接口进行录制（视频流数据来源上一步获取的数据）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 MediaRecorder 的 ondataavailable 事件获取录制的 buffer 数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 buffer 数据转成 Blob 类型，然后使用 createObjectURL 生成可访问的视频地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用 a 标签的 download 属性进行视频下载&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;video autoplay playsinline controls id=&lt;span&gt;&quot;video-show&quot;&lt;/span&gt;&amp;gt;&amp;lt;/video&amp;gt;&lt;br/&gt;&amp;lt;video id=&lt;span&gt;&quot;video-replay&quot;&lt;/span&gt;&amp;gt;&amp;lt;/video&amp;gt;&lt;br/&gt;&amp;lt;button id=&lt;span&gt;&quot;record&quot;&lt;/span&gt;&amp;gt;开始录制&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;button id=&lt;span&gt;&quot;stop&quot;&lt;/span&gt;&amp;gt;停止录制&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;button id=&lt;span&gt;&quot;recplay&quot;&lt;/span&gt;&amp;gt;录制播放&amp;lt;/button&amp;gt;&lt;br/&gt;&amp;lt;button id=&lt;span&gt;&quot;download&quot;&lt;/span&gt;&amp;gt;录制视频下载&amp;lt;/button&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; buffer;&lt;br/&gt;const &lt;span&gt;$videoshow&lt;/span&gt; = document.getElementById(&lt;span&gt;&#x27;video-show&#x27;&lt;/span&gt;);&lt;br/&gt;const promise = navigator.mediaDevices.getUserMedia({&lt;br/&gt;  video: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}).&lt;span&gt;then&lt;/span&gt;(&lt;br/&gt;  stream =&amp;gt; {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;stream&#x27;&lt;/span&gt;, stream);&lt;br/&gt;  window.stream = stream;&lt;br/&gt;  &lt;span&gt;$videoshow&lt;/span&gt;.srcObject = stream;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;startRecord&lt;/span&gt;&lt;/span&gt;(){     &lt;br/&gt;  buffer = [];     &lt;br/&gt;  // 设置录制下来的多媒体格式 &lt;br/&gt;  const options = {&lt;br/&gt;    mimeType: &lt;span&gt;&#x27;video/webm;codecs=vp8&#x27;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 判断浏览器是否支持录制&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(!MediaRecorder.isTypeSupported(options.mimeType)){&lt;br/&gt;    console.error(`&lt;span&gt;${options.mimeType}&lt;/span&gt; is not supported!`);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  try{&lt;br/&gt;    // 创建录制对象&lt;br/&gt;    mediaRecorder = new MediaRecorder(window.stream, options);&lt;br/&gt;    console.log(&lt;span&gt;&#x27;mediaRecorder&#x27;&lt;/span&gt;, mediaRecorder);&lt;br/&gt;  }catch(e){&lt;br/&gt;    console.error(&lt;span&gt;&#x27;Failed to create MediaRecorder:&#x27;&lt;/span&gt;, e);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  // 当有音视频数据来了之后触发该事件&lt;br/&gt;  mediaRecorder.ondataavailable = handleDataAvailable;&lt;br/&gt;  // 开始录制&lt;br/&gt;  mediaRecorder.start(2000); // 若设置了 timeslice 这个毫秒值，那么录制的数据会按照设定的值分割成一个个单独的区块&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 当该函数被触发后，将数据压入到 blob 中&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; handleDataAvailable(e){&lt;br/&gt;  console.log(&lt;span&gt;&#x27;e&#x27;&lt;/span&gt;, e.data);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(e &amp;amp;&amp;amp; e.data &amp;amp;&amp;amp; e.data.size &amp;gt; 0){&lt;br/&gt;    buffer.push(e.data);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;document.getElementById(&lt;span&gt;&#x27;record&#x27;&lt;/span&gt;).onclick = () =&amp;gt; {&lt;br/&gt;  startRecord();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;document.getElementById(&lt;span&gt;&#x27;stop&#x27;&lt;/span&gt;).onclick = () =&amp;gt; {&lt;br/&gt;  mediaRecorder.stop();&lt;br/&gt;  console.log(&lt;span&gt;&quot;recorder stopped, data available&quot;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;// 回放录制文件&lt;br/&gt;const &lt;span&gt;$video&lt;/span&gt; = document.getElementById(&lt;span&gt;&#x27;video-replay&#x27;&lt;/span&gt;);&lt;br/&gt;document.getElementById(&lt;span&gt;&#x27;recplay&#x27;&lt;/span&gt;).onclick = () =&amp;gt; {&lt;br/&gt;  const blob = new Blob(buffer, {&lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;video/webm&#x27;&lt;/span&gt;});&lt;br/&gt;  &lt;span&gt;$video&lt;/span&gt;.src = window.URL.createObjectURL(blob);&lt;br/&gt;  &lt;span&gt;$video&lt;/span&gt;.srcObject = null;&lt;br/&gt;  &lt;span&gt;$video&lt;/span&gt;.controls = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;$video&lt;/span&gt;.play();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;// 下载录制文件&lt;br/&gt;document.getElementById(&lt;span&gt;&#x27;download&#x27;&lt;/span&gt;).onclick = () =&amp;gt; {&lt;br/&gt;  const blob = new Blob(buffer, {&lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;video/webm&#x27;&lt;/span&gt;});&lt;br/&gt;  const url = window.URL.createObjectURL(blob);&lt;br/&gt;  const a = document.createElement(&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  a.href = url;&lt;br/&gt;  a.style.display = &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;;&lt;br/&gt;  a.download = &lt;span&gt;&#x27;video.webm&#x27;&lt;/span&gt;;&lt;br/&gt;  a.click();&lt;br/&gt;}; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;创建连接&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据采集完成，接下来就要开始建立连接，然后进行数据通信了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现一套 1 对 1 的通话系统，通常我们的思路会是在每一端创建一个 socket，然后通过该 socket 与对端相连，当 socket 连接成功之后，就可以通过 socket 向对端发送数据或者接收对端的数据了，WebRTC 中提供了 RTCPeerConnection 类，其工作原理和 socket 基本一样，不过它的功能更强大，实现也更为复杂，下面就来讲讲 WebRTC 中的 RTCPeerConnection&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RTCPeerConnection&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在音视频通信中，每一方只需要有一个 RTCPeerConnection 对象，用它来接收或发送音视频数据，然而在真实的场景中，为了实现端与端之间的通话，还需要利用信令服务器交换一些信息，比如交换双方的 IP 和 port 地址，这样通信的双方才能彼此建立连接&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebRTC 规范对 WebRTC 要实现的功能、API 等相关信息做了大量的约束，比如规范中定义了如何采集音视频数据、如何录制以及如何传输等，甚至更细的，还定义了都有哪些 API，以及这些 API 的作用是什么，但这些约束只针对于客户端，并没有对服务端做任何限制，这就导致了我们在使用 WebRTC 的时候，必须&lt;strong&gt;自己去实现&lt;/strong&gt; &lt;strong&gt;信令&lt;/strong&gt; &lt;strong&gt;服务，&lt;/strong&gt; 这里就不专门研究怎么实现信令服务器了，我们只来看看 RTCPeerConnection 是如何实现一对一通信的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RTCPeerConnection 如何工作呢？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取本地音视频流&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为连接的每个端创建一个 RTCPeerConnection 对象，并且给 RTCPeerConnection 对象添加一个本地流，该流是从 getUserMedia 获取的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 调用 getUserMedia API 获取音视频流&lt;br/&gt;navigator.mediaDevices.getUserMedia(mediaStreamConstraints).&lt;br/&gt;  &lt;span&gt;then&lt;/span&gt;(gotLocalMediaStream)&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;function&lt;/span&gt; gotLocalMediaStream(mediaStream) {&lt;br/&gt;  window.stream = mediaStream;&lt;br/&gt;}&lt;br/&gt; &lt;br/&gt;// 创建 RTCPeerConnection 对象&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; localPeerConnection = new RTCPeerConnection();&lt;br/&gt; &lt;br/&gt;// 将音视频流添加到 RTCPeerConnection 对象中&lt;br/&gt;localPeerConnection.addStream(stream);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;交换媒体描述信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获得音视频流后，就可以开始与对端进行媒体协商了（媒体协商就是看看你的设备都支持哪些编解码器，我的设备是否也支持？如果我的设备也支持，那么咱们双方就算协商成功了），这个过程需要通过信令服务器完成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设 A 和 B 需要通讯&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;A 通过 &lt;span&gt;createOffer&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 方法启动创建一个 SDP offer，即得到 A 的本地会话描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A 通过 setLocalDescription ****方法保存本地会话描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A 通过信令服务器发送信令给 B&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;localPeerConnection.createOffer([options])&lt;br/&gt;  .&lt;span&gt;then&lt;/span&gt;((description) =&amp;gt; {&lt;br/&gt;        // 将 offer 保存到本地&lt;br/&gt;      localPeerConnection.setLocalDescription(description)&lt;br/&gt;        .&lt;span&gt;then&lt;/span&gt;(() =&amp;gt; {&lt;br/&gt;          setLocalDescriptionSuccess(localPeerConnection);&lt;br/&gt;        });&lt;br/&gt;   })&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B 接收到带有 A offer 的信令，调用 setRemoteDescription，设置远程会话描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B 通过 createAnswer 方法将本地会话描述成功回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B 调用 setLocalDescription 设置他自己的本地局部描述回调函数中保存本地会话描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B 通过信令服务器发送信令给 A&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// B 设置远程会话描述&lt;br/&gt;remotePeerConnection.setRemoteDescription(description)&lt;br/&gt;.&lt;span&gt;then&lt;/span&gt;(() =&amp;gt; {&lt;br/&gt;  setRemoteDescriptionSuccess(remotePeerConnection);&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;remotePeerConnection.createAnswer()&lt;br/&gt;.&lt;span&gt;then&lt;/span&gt;((description)=&amp;gt; {&lt;br/&gt;  // B 保存本地会话描述&lt;br/&gt;  remotePeerConnection.setLocalDescription(description)&lt;br/&gt;    .&lt;span&gt;then&lt;/span&gt;(() =&amp;gt; {&lt;br/&gt;      setLocalDescriptionSuccess(remotePeerConnection);&lt;br/&gt;    });&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;A 通过 setRemoteDescription 将 B 的应答 answer 保存为远程会话描述&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// A 保存 B 的 应答 answer 为远程会话描述&lt;br/&gt;  localPeerConnection.setRemoteDescription(description)&lt;br/&gt;    .&lt;span&gt;then&lt;/span&gt;(() =&amp;gt; {&lt;br/&gt;      setRemoteDescriptionSuccess(localPeerConnection);&lt;br/&gt;    });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此就完成了媒体信息交换和协商&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;端与端建立连接&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当 A 调用 setLocalDescription 函数成功后，会触发 icecandidate 事件（在建立通讯之前，我们需要获得双方的网络信息，例如 IP、端口等，candidate 便是用于保存这些东西的）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;localPeerConnection.onicecandidate= &lt;span&gt;function&lt;/span&gt;(event) {&lt;br/&gt;  // 获取到触发 icecandidate 事件的 RTCPeerConnection 对象&lt;br/&gt;  const peerConnection = event.target;&lt;br/&gt;  // 获取到具体的 candidate&lt;br/&gt;  const iceCandidate = event.candidate;&lt;br/&gt;  // 将 candidate 包装成需要的格式，然后通过信令服务器发送给B&lt;br/&gt;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B 接收到信令服务器传递过来的 A 的关于 candidate 的信息，把消息包装成 RTCIceCandidate 对象，然后调用 addIceCandidate 保存起来&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 创建 RTCIceCandidate 对象 &lt;br/&gt;const newIceCandidate = new RTCIceCandidate(iceCandidate);&lt;br/&gt;remotePeerConnection.addIceCandidate(newIceCandidate);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就收集到了一个新的 Candidate，在真实的场景中，每当获得一个新的 Candidate 后，就会通过信令服务器交换给对端，对端再调用 RTCPeerConnection 对象的 addIceCandidate() 方法将收到的 Candidate 保存起来，然后按照 Candidate 的优先级进行连通性检测，如果 Candidate 连通性检测完成，那么端与端之间就建立了连接，这时媒体数据就可以通过这个连接进行传输了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;音视频编解码&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频是连续的图像序列，由连续的帧构成，一帧即为一幅图像，由于人眼的视觉暂留效应，当帧序列以一定的速率播放时，我们看到的就是动作连续的视频，由于连续的帧之间相似性极高，为便于储存传输，我们需要对原始的视频进行编码压缩，以去除空间、时间维度的冗余&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频编解码是采用算法将视频数据的冗余信息去除，对图像进行压缩、存储及传输， 再将视频进行解码及格式转换， 追求在可用的计算资源内，尽可能高的视频重建质量和尽可能高的压缩比，以达到带宽和存储容量要求的视频处理技术&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视频流传输中最为重要的编解码标准有H.26X系列（H.261、H.263、H.264），MPEG系列，Apple公司的 QuickTime 等&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;显示远端媒体流&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 RTCPeerConnection 对象 A 与 B 双方建立连接后，本地的多媒体数据经过编码以后就可以被传送到远端了，远端收到了媒体数据解码后，怎么显示出来呢，下面以 video 为例，看看怎么让 RTCPeerConnection 获得的媒体数据与 video 标签结合起来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当远端有数据流到来的时候，浏览器会回调 onaddstream 函数，在回调函数中将得到的 stream 赋值给 video 标签的 srcObject 对象，这样 video 就与 RTCPeerConnection 进行了绑定，video 就能从 RTCPeerConnection 获取到视频数据，并最终将其显示出来了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;localPeerConnection.onaddstream = &lt;span&gt;function&lt;/span&gt;(event) {&lt;br/&gt;  &lt;span&gt;$remoteVideo&lt;/span&gt;.srcObject = event.stream;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebRTC 相关的东西非常非常多，这里只是很浅显地串讲了一下利用 WebRTC 实现实时通信的大体过程，如果感兴趣可以详细研究里面的细节&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;srcObject: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLMediaElement/srcObject#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;drawImage: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;createOffer: &lt;em&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/RTCPeerConnection/createOffer&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>