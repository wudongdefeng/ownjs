<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1c22add75b0a22ea45854c9ff0193706</guid>
<title>蚂蚁测试用例自动生成工具正式开源，带你一键玩转测试用例自动生成！</title>
<link>https://toutiao.io/k/2fq1e2n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PlCuiaEuibibE7gfUdu129cIY6lUdcTEzgRvibmkHcgnboUmaqH2SzLRUyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;测试用例自动生成是近年来质量与效能的研究热点方向，无论是学术界的相关研究还是工业界的探索实践，我们都可以看到大家对于通过用例自动生成来进行研发提效的期许与探索。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;蚂蚁测试用例自动生成&lt;/span&gt;&lt;/strong&gt;（Auto-Unit-Test-Case-Generator）是由蚂蚁集团技术风险部质量技术团队研发的一款单元测试用例自动生成产品。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于学术界现有科研成果，针对实际业务中落地所面临的难点与挑战，Auto-Unit-Test-Case-Generator提出了一系列创新性算法，最终实现了&lt;strong&gt;&lt;span&gt;单测覆盖率&amp;gt;60%&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;稳定性&amp;gt;99%&lt;/span&gt;&lt;/strong&gt;的高效自动生成能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前&lt;span&gt;Auto-Unit-Test-Case-Generator&lt;/span&gt;&lt;strong&gt;&lt;span&gt;已开源至Github，期待大家的使用和共建！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;（👉复制链接到浏览器访问：&lt;/p&gt;&lt;p&gt;https://github.com/TRaaSStack/auto-unit-test-case-generator）&lt;/p&gt;&lt;p&gt;&lt;span&gt;*点击文末&lt;/span&gt;&lt;span&gt;阅读原文&lt;/span&gt;&lt;span&gt;即可直接跳转&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PMkeSwSsibibbAeSKraSrUOZUr3osEpwl0UkJLKwBp9Gxuca6dLh7Tapw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;Auto-Unit-Test-Case-Generator 核心能力&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用Auto-Unit-Test-Case-Generator，能够在无人介入的情况下自动生成&lt;span&gt;&lt;strong&gt;高覆盖率、高有效性&lt;/strong&gt;&lt;/span&gt;的单元测试用例集，&lt;span&gt;&lt;strong&gt;智能化提升质量水位、提高研发效能&lt;/strong&gt;&lt;/span&gt;。相较于已有的测试用例生成工具，Auto-Unit-Test-Case-Generator生成的测试用例在覆盖率、有效性、可读性都有提升。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Auto-Unit-Test-Case-Generator的核心能力包括：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;1&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;适配Spring框架&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;目前业界大量的JAVA工程使用Spring框架，Auto-Unit-Test-Case-Generator能够&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自动适配Spring工程的结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，对需要隔离的服务进行提前mock，确保生成的用例可以正常运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;2&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;复杂业务场景生成&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在业界的实际系统中，往往需要自动生成的用例能够覆盖复杂业务场景。Auto-Unit-Test-Case-Generator对用例数据生成的算法进行了优化，使得相较于传统的随机搜索算法(Random Search Algorithm)&lt;span&gt;&lt;strong&gt;能够达到更高的分支命中能力&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;3&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;高可读的用例结构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们推荐将自动生成的单测用例合入工程代码库中进行持续CI，因此要求自动生成的用例具备高可读性。Auto-Unit-Test-Case-Generator在进行用例生成过程中结合了最优调用序列算法，使得自动生成的&lt;span&gt;&lt;strong&gt;用例结构合理、语义可读&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，我们在蚂蚁内部同时也在探索实践&lt;span&gt;&lt;strong&gt;自动生成单测用例的问题发现能力&lt;/strong&gt;&lt;/span&gt;，通过生成异常场景用例发现NPE等严重的代码问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;内部孵化完成后，后续也会及时开源至Github，欢迎大家关注我们的Github项目！🧐&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;蚂蚁内部实践效果&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前，在蚂蚁内部已经有&lt;span&gt;&lt;strong&gt;超过1000个工程&lt;/strong&gt;&lt;/span&gt;在使用Auto-Unit-Test-Case-Generator进行用例生成。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下通过某个域的14个系统行覆盖率对比情况，来说明Auto-Unit-Test-Case-Generator生成用例的效果。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5054705&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9P0fNA56OpWXmpk6nMOuOxb0ljscCAOb4JNxt250NdUibxBT5RicaicANbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;其中，历史存量手写的覆盖率（橙色）平均覆盖率54%，Auto-Unit-Test-Case-Generator自动生成覆盖率（绿色）平均覆盖率为65%，与历史存量手写用例合并汇总覆盖率（蓝色）达到81%；经过自动生成的单测补充，&lt;strong&gt;&lt;span&gt;覆盖率提升了25%+&lt;/span&gt;&lt;/strong&gt;，提升效果显著。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;带你一键玩转用例自动生成&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;了解测试用例自动生成的效果后，您是不是也想在自己的工程上尝试一把呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里我们提供了IDEA插件的使用方式，&lt;strong&gt;&lt;span&gt;带您在五分钟内完成一次用例生成，体验用例生成带来的效能提升！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;构建Auto-Unit-Test-Case-Generator&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在进行IDEA插件操作之前，我们首先需要构建出最新版本的Auto-Unit-Test-Case-Generator。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;构建过程如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;构建完成后，在您本地的mvn仓库内即可发现构建好的用例生成jar包，用例生成jar包的默认路径：${user.home}/.m2/repository/org/smartut/smartut-master/1.1.0/smartut-master-1.1.0.jar。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;安装IDEA插件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;构建完成Auto-Unit-Test-Case-Generator后，我们接下来进行IDEA插件的安装。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装过程如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;下载IDEA插件安装包，安装包地址：https://github.com/TRaaSStack/auto-unit-test-case-generator/blob/main/tools/smart_ut_intellij_plugin.zip（如下载失败可通过clone代码仓获取）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;本地解压缩smart_ut_intellij_plugin.zip后得到IDEA插件jar包：smart_ut_intellij.jar&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;打开IntelliJ IDEA -&amp;gt; Preferences -&amp;gt; Plugins -&amp;gt; Install Plugin from Disk。在弹出的选择框中，选择smart_ut_intellij.jar。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5537037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9P6sKJmsxcLn8ZV4Law49T9wa4zwpW20JYuBIoFicCjTclxat4TxqZicIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;重启IDEA插件。重启后打开您希望进行用例生成的Java项目，右键单击任意java文件，即可看到用例生成的入口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PdibibAMd4IjYj9fCtTUicuOdjYibw5ib3yicokgv6Hd9vvDiaH7ogNlLqbdug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;一键生成用例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;IDEA插件安装完成后，您就可以在您的本地工程中尽情使用用例生成了。在任意待生成的java文件上右键选择&quot;SmartUT用例生成&quot;，即可看到如下图所示的用例生成页面。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5537037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PEPPBJg3LYh6BVKHjMHbtWOPYhTf8aBTJCNWrFNWfLsMK3oy7Fw2uyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用例生成页面中，只需要填写三项：&lt;span&gt;&lt;strong&gt;用例生成jar包路径、生成结果存放路径、生成时间&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;填写完成后点击开始，即可开始用例生成！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5537037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PqYJBfhbx6Urdj2zwSGxMVNK6JHZS8iaiaB4dqXmNiaCVJt2evDB3HiaGxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用例生成完成后，在对应目录下可以找到生成的测试用例文件。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5537037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PkhC23Pk6sSN1hO8derJ7crwg8p9dNSFKIRRKqEeY94TKjlMuaVyUnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;联系我们&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;如果您对测试用例自动生成感兴趣&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;或者在使用插件进行用例自动生成时遇到了任何问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;都欢迎随时联系我们~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;钉钉群号：44961098&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可通过扫下方二维码扫码加入&lt;/span&gt;&lt;strong&gt;&lt;span&gt;微信/钉钉群&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;期待您的意见和建议！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;👇👇👇&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9PkdE9wWqbcfZYo76LDQQRgYlmRvMNruZGcGjJhyGhNWkO7UibiaoeUDKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;320&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;微信群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2890625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hUw7zHOGfWaTCP1MApOPw9Po7QtP6b42LEIR9Bb1uvC6IGQmayCUds2Nu7ekAvdj35NbXQD7pUBsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;钉钉群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br/&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU3NzczMDI4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/I8SfHxT94hU6P7Y4EMhbdHr7WDSMZt9wjEZfR28HDTcOac5u4A8ibiaIR2Miad2cCILq1FCH6NHZesEoOXLeuBopA/0?wx_fmt=png&quot; data-nickname=&quot;蚂蚁研发效能&quot; data-alias=&quot;AntLinkE&quot; data-signature=&quot;蚂蚁集团研发效能部有业界领先的工程和学术造诣，致力于为蚂蚁和多家金融企业提供核电级的全生命周期研发产品。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7c8244ae22e9b1a6cd6b2de63f3fb16d</guid>
<title>大文件上传：秒传、断点续传、分片上传</title>
<link>https://toutiao.io/k/wqkt3ly</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件上传是一个老生常谈的话题了，在文件相对比较小的情况下，可以直接把文件转化为字节流上传到服务器，但在文件比较大的情况下，用普通的方式进行上传，这可不是一个好的办法，毕竟很少有人会忍受，当文件上传到一半中断后，继续上传却只能重头开始上传，这种让人不爽的体验。那有没有比较好的上传体验呢，答案有的，就是下边要介绍的几种上传方式&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是秒传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通俗的说，你把要上传的东西上传，服务器会先做MD5校验，如果服务器上有一样的东西，它就直接给你个新地址，其实你下载的都是服务器上的同一个文件，想要不秒传，其实只要让MD5改变，就是对文件本身做一下修改（改名字不行），例如一个文本文件，你多加几个字，MD5就变了，就不会秒传了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、本文实现的秒传核心逻辑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、利用redis的set方法存放文件上传状态，其中key为文件上传的md5，value为是否上传完成的标志位，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、当标志位true为上传已经完成，此时如果有相同文件上传，则进入秒传逻辑。如果标志位为false，则说明还没上传完成，此时需要在调用set的方法，保存块号文件记录的路径，其中key为上传文件md5加一个固定前缀，value为块号文件记录路径&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片上传&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是分片上传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分片上传，就是将所要上传的文件，按照一定的大小，将整个文件分隔成多个数据块（我们称之为Part）来进行分别上传，上传完之后再由服务端对所有上传的文件进行汇总整合成原始的文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、分片上传的场景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、大文件上传&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、网络环境环境不好，存在需要重传风险的场景&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;断点续传&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、什么是断点续传&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&amp;amp;mid=2247500365&amp;amp;idx=1&amp;amp;sn=7abfd8b30427d4ac15bb351c3dbb640c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;断点续传是在下载或上传时，将下载或上传任务（一个文件或一个压缩包）人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传或者下载未完成的部分，而没有必要从头开始上传或者下载。本文的断点续传主要是针对断点上传场景。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、应用场景&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断点续传可以看成是分片上传的一个衍生，因此可以使用分片上传的场景，都可以使用断点续传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、实现断点续传的核心逻辑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分片上传的过程中，如果因为系统崩溃或者网络中断等异常因素导致上传中断，这时候客户端需要记录上传的进度。在之后支持再次上传时，可以继续从上次上传中断的地方进行继续上传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免客户端在上传之后的进度数据被删除而导致重新开始从头上传的问题，服务端也可以提供相应的接口便于客户端对已经上传的分片数据进行查询，从而使客户端知道已经上传的分片数据，从而从下一个分片数据开始继续上传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、实现流程步骤&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&amp;amp;mid=2247500365&amp;amp;idx=1&amp;amp;sn=7abfd8b30427d4ac15bb351c3dbb640c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;a、方案一，常规步骤将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；初始化一个分片上传任务，返回本次分片上传唯一标识；按照一定的策略（串行或并行）发送各个分片数据块；发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。b、方案二、本文实现的步骤前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;a、方案一，常规步骤&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&amp;amp;mid=2247500365&amp;amp;idx=1&amp;amp;sn=7abfd8b30427d4ac15bb351c3dbb640c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;a、方案一，常规步骤将需要上传的文件按照一定的分割规则，分割成相同大小的数据块；初始化一个分片上传任务，返回本次分片上传唯一标识；按照一定的策略（串行或并行）发送各个分片数据块；发送完成后，服务端根据判断数据上传是否完整，如果完整，则进行数据块合成得到原始文件。b、方案二、本文实现的步骤前端（客户端）需要根据固定大小对文件进行分片，请求后端（服务端）时要带上分片序号和大小服务端创建conf文件用来记录分块位置，conf文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认的0,已上传的就是Byte.MAX_VALUE 127（这步是实现断点续传和秒传的核心步骤）服务器按照请求数据中给的分片序号和每片分块大小（分片大小是固定且一样的）算出开始位置，与读取到的文件片段数据，写入文件。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;b、方案二、本文实现的步骤&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、分片上传/断点上传代码实现&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、前端采用百度提供的webuploader的插件，进行分片。因本文主要介绍服务端代码实现，webuploader如何进行分片，具体实现可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;http://fex.baidu.com/webuploader/getting-started.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、后端用两种方式实现文件写入，一种是用RandomAccessFile，如果对RandomAccessFile不熟悉的朋友，可以查看如下链接:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://blog.csdn.net/dimudan2015/article/details/81910690&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种是使用MappedByteBuffer，对MappedByteBuffer不熟悉的朋友，可以查看如下链接进行了解:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://www.jianshu.com/p/f90866dcbffc&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后端进行写入操作的核心代码&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a、RandomAccessFile实现方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@UploadMode(mode = UploadModeEnum.RANDOM_ACCESS)  &lt;br/&gt;@Slf4j  &lt;br/&gt;public class RandomAccessUploadStrategy extends SliceUploadTemplate {  &lt;br/&gt;  &lt;br/&gt;  @Autowired  &lt;br/&gt;  private FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  @Value(&lt;span&gt;&quot;&lt;span&gt;${upload.chunkSize}&lt;/span&gt;&quot;&lt;/span&gt;)  &lt;br/&gt;  private long defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  @Override  &lt;br/&gt;  public boolean upload(FileUploadRequestDTO param) {  &lt;br/&gt;    RandomAccessFile accessTmpFile = null;  &lt;br/&gt;    try {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = super.createTmpFile(param);  &lt;br/&gt;      accessTmpFile = new RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      //这个必须与前端设定的值一致  &lt;br/&gt;      long chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * 1024 * 1024  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      long offset = chunkSize * param.getChunk();  &lt;br/&gt;      //定位到该分片的偏移量  &lt;br/&gt;      accessTmpFile.seek(offset);  &lt;br/&gt;      //写入该分片数据  &lt;br/&gt;      accessTmpFile.write(param.getFile().getBytes());  &lt;br/&gt;      boolean isOk = super.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;    } catch (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } finally {  &lt;br/&gt;      FileUtil.close(accessTmpFile);  &lt;br/&gt;    }  &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b、MappedByteBuffer实现方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@UploadMode(mode = UploadModeEnum.MAPPED_BYTEBUFFER)  &lt;br/&gt;@Slf4j  &lt;br/&gt;public class MappedByteBufferUploadStrategy extends SliceUploadTemplate {  &lt;br/&gt;  &lt;br/&gt;  @Autowired  &lt;br/&gt;  private FilePathUtil filePathUtil;  &lt;br/&gt;  &lt;br/&gt;  @Value(&lt;span&gt;&quot;&lt;span&gt;${upload.chunkSize}&lt;/span&gt;&quot;&lt;/span&gt;)  &lt;br/&gt;  private long defaultChunkSize;  &lt;br/&gt;  &lt;br/&gt;  @Override  &lt;br/&gt;  public boolean upload(FileUploadRequestDTO param) {  &lt;br/&gt;  &lt;br/&gt;    RandomAccessFile tempRaf = null;  &lt;br/&gt;    FileChannel fileChannel = null;  &lt;br/&gt;    MappedByteBuffer mappedByteBuffer = null;  &lt;br/&gt;    try {  &lt;br/&gt;      String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;      File tmpFile = super.createTmpFile(param);  &lt;br/&gt;      tempRaf = new RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      fileChannel = tempRaf.getChannel();  &lt;br/&gt;  &lt;br/&gt;      long chunkSize = Objects.isNull(param.getChunkSize()) ? defaultChunkSize * 1024 * 1024  &lt;br/&gt;          : param.getChunkSize();  &lt;br/&gt;      //写入该分片数据  &lt;br/&gt;      long offset = chunkSize * param.getChunk();  &lt;br/&gt;      byte[] fileData = param.getFile().getBytes();  &lt;br/&gt;      mappedByteBuffer = fileChannel  &lt;br/&gt;.map(FileChannel.MapMode.READ_WRITE, offset, fileData.length);  &lt;br/&gt;      mappedByteBuffer.put(fileData);  &lt;br/&gt;      boolean isOk = super.checkAndSetUploadProgress(param, uploadDirPath);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  &lt;br/&gt;    } catch (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } finally {  &lt;br/&gt;  &lt;br/&gt;      FileUtil.freedMappedByteBuffer(mappedByteBuffer);  &lt;br/&gt;      FileUtil.close(fileChannel);  &lt;br/&gt;      FileUtil.close(tempRaf);  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c、文件操作核心模板类代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Slf4j  &lt;br/&gt;public abstract class SliceUploadTemplate implements SliceUploadStrategy {  &lt;br/&gt;  &lt;br/&gt;  public abstract boolean upload(FileUploadRequestDTO param);  &lt;br/&gt;  &lt;br/&gt;  protected File createTmpFile(FileUploadRequestDTO param) {  &lt;br/&gt;  &lt;br/&gt;    FilePathUtil filePathUtil = SpringContextHolder.getBean(FilePathUtil.class);  &lt;br/&gt;    param.setPath(FileUtil.withoutHeadAndTailDiagonal(param.getPath()));  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    String uploadDirPath = filePathUtil.getPath(param);  &lt;br/&gt;    String tempFileName = fileName + &lt;span&gt;&quot;_tmp&quot;&lt;/span&gt;;  &lt;br/&gt;    File tmpDir = new File(uploadDirPath);  &lt;br/&gt;    File tmpFile = new File(uploadDirPath, tempFileName);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tmpDir.exists()) {  &lt;br/&gt;      tmpDir.mkdirs();  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; tmpFile;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  @Override  &lt;br/&gt;  public FileUploadDTO sliceUpload(FileUploadRequestDTO param) {  &lt;br/&gt;  &lt;br/&gt;    boolean isOk = this.upload(param);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isOk) {  &lt;br/&gt;      File tmpFile = this.createTmpFile(param);  &lt;br/&gt;      FileUploadDTO fileUploadDTO = this.saveAndFileUploadDTO(param.getFile().getOriginalFilename(), tmpFile);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String md5 = FileMD5Util.getFileMD5(param.getFile());  &lt;br/&gt;  &lt;br/&gt;    Map&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;    map.put(param.getChunk(), md5);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; FileUploadDTO.builder().chunkMd5Info(map).build();  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  /**  &lt;br/&gt;   * 检查并修改文件上传进度  &lt;br/&gt;   */  &lt;br/&gt;  public boolean checkAndSetUploadProgress(FileUploadRequestDTO param, String uploadDirPath) {  &lt;br/&gt;  &lt;br/&gt;    String fileName = param.getFile().getOriginalFilename();  &lt;br/&gt;    File confFile = new File(uploadDirPath, fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;    byte isComplete = 0;  &lt;br/&gt;    RandomAccessFile accessConfFile = null;  &lt;br/&gt;    try {  &lt;br/&gt;      accessConfFile = new RandomAccessFile(confFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);  &lt;br/&gt;      //把该分段标记为 &lt;span&gt;true&lt;/span&gt; 表示完成  &lt;br/&gt;      System.out.println(&lt;span&gt;&quot;set part &quot;&lt;/span&gt; + param.getChunk() + &lt;span&gt;&quot; complete&quot;&lt;/span&gt;);  &lt;br/&gt;      //创建conf文件文件长度为总分片数，每上传一个分块即向conf文件中写入一个127，那么没上传的位置就是默认0,已上传的就是Byte.MAX_VALUE 127  &lt;br/&gt;      accessConfFile.setLength(param.getChunks());  &lt;br/&gt;      accessConfFile.seek(param.getChunk());  &lt;br/&gt;      accessConfFile.write(Byte.MAX_VALUE);  &lt;br/&gt;  &lt;br/&gt;      //completeList 检查是否全部完成,如果数组里是否全部都是127(全部分片都成功上传)  &lt;br/&gt;      byte[] completeList = FileUtils.readFileToByteArray(confFile);  &lt;br/&gt;      isComplete = Byte.MAX_VALUE;  &lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; completeList.length &amp;amp;&amp;amp; isComplete == Byte.MAX_VALUE; i++) {  &lt;br/&gt;        //与运算, 如果有部分没有完成则 isComplete 不是 Byte.MAX_VALUE  &lt;br/&gt;        isComplete = (byte) (isComplete &amp;amp; completeList[i]);  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;check part &quot;&lt;/span&gt; + i + &lt;span&gt;&quot; complete?:&quot;&lt;/span&gt; + completeList[i]);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } catch (IOException e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } finally {  &lt;br/&gt;      FileUtil.close(accessConfFile);  &lt;br/&gt;    }  &lt;br/&gt; boolean isOk = setUploadProgress2Redis(param, uploadDirPath, fileName, confFile, isComplete);  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; isOk;  &lt;br/&gt;  }  &lt;br/&gt;  &lt;br/&gt;  /**  &lt;br/&gt;   * 把上传进度信息存进redis  &lt;br/&gt;   */  &lt;br/&gt;  private boolean setUploadProgress2Redis(FileUploadRequestDTO param, String uploadDirPath,  &lt;br/&gt;      String fileName, File confFile, byte isComplete) {  &lt;br/&gt;  &lt;br/&gt;    RedisUtil redisUtil = SpringContextHolder.getBean(RedisUtil.class);  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isComplete == Byte.MAX_VALUE) {  &lt;br/&gt;      redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;true&quot;&lt;/span&gt;);  &lt;br/&gt;      redisUtil.del(FileConstant.FILE_MD5_KEY + param.getMd5());  &lt;br/&gt;      confFile.delete();  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;  &lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!redisUtil.hHasKey(FileConstant.FILE_UPLOAD_STATUS, param.getMd5())) {  &lt;br/&gt;        redisUtil.hset(FileConstant.FILE_UPLOAD_STATUS, param.getMd5(), &lt;span&gt;&quot;false&quot;&lt;/span&gt;);  &lt;br/&gt;        redisUtil.set(FileConstant.FILE_MD5_KEY + param.getMd5(),  &lt;br/&gt;            uploadDirPath + FileConstant.FILE_SEPARATORCHAR + fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;    }  &lt;br/&gt;  }  &lt;br/&gt;/**  &lt;br/&gt;   * 保存文件操作  &lt;br/&gt;   */  &lt;br/&gt;  public FileUploadDTO saveAndFileUploadDTO(String fileName, File tmpFile) {  &lt;br/&gt;  &lt;br/&gt;    FileUploadDTO fileUploadDTO = null;  &lt;br/&gt;  &lt;br/&gt;    try {  &lt;br/&gt;  &lt;br/&gt;      fileUploadDTO = renameFile(tmpFile, fileName);  &lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (fileUploadDTO.isUploadComplete()) {  &lt;br/&gt;        System.out  &lt;br/&gt;            .println(&lt;span&gt;&quot;upload complete !!&quot;&lt;/span&gt; + fileUploadDTO.isUploadComplete() + &lt;span&gt;&quot; name=&quot;&lt;/span&gt; + fileName);  &lt;br/&gt;        //TODO 保存文件信息到数据库  &lt;br/&gt;  &lt;br/&gt;      }  &lt;br/&gt;  &lt;br/&gt;    } catch (Exception e) {  &lt;br/&gt;      log.error(e.getMessage(), e);  &lt;br/&gt;    } finally {  &lt;br/&gt;  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;/**  &lt;br/&gt;   * 文件重命名  &lt;br/&gt;   *  &lt;br/&gt;   * @param toBeRenamed 将要修改名字的文件  &lt;br/&gt;   * @param toFileNewName 新的名字  &lt;br/&gt;   */  &lt;br/&gt;  private FileUploadDTO renameFile(File toBeRenamed, String toFileNewName) {  &lt;br/&gt;    //检查要重命名的文件是否存在，是否是文件  &lt;br/&gt;    FileUploadDTO fileUploadDTO = new FileUploadDTO();  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!toBeRenamed.exists() || toBeRenamed.isDirectory()) {  &lt;br/&gt;      log.info(&lt;span&gt;&quot;File does not exist: {}&quot;&lt;/span&gt;, toBeRenamed.getName());  &lt;br/&gt;      fileUploadDTO.setUploadComplete(&lt;span&gt;false&lt;/span&gt;);  &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;    }  &lt;br/&gt;    String ext = FileUtil.getExtension(toFileNewName);  &lt;br/&gt;    String p = toBeRenamed.getParent();  &lt;br/&gt;    String filePath = p + FileConstant.FILE_SEPARATORCHAR + toFileNewName;  &lt;br/&gt;    File newFile = new File(filePath);  &lt;br/&gt;    //修改文件名  &lt;br/&gt;    boolean uploadFlag = toBeRenamed.renameTo(newFile);  &lt;br/&gt;  &lt;br/&gt;    fileUploadDTO.setMtime(DateUtil.getCurrentTimeStamp());  &lt;br/&gt;    fileUploadDTO.setUploadComplete(uploadFlag);  &lt;br/&gt;    fileUploadDTO.setPath(filePath);  &lt;br/&gt;    fileUploadDTO.setSize(newFile.length());  &lt;br/&gt;    fileUploadDTO.setFileExt(ext);  &lt;br/&gt;    fileUploadDTO.setFileId(toFileNewName);  &lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fileUploadDTO;  &lt;br/&gt;  }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&amp;amp;mid=2247500365&amp;amp;idx=1&amp;amp;sn=7abfd8b30427d4ac15bb351c3dbb640c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在实现分片上传的过程，需要前端和后端配合，比如前后端的上传块号的文件大小，前后端必须得要一致，否则上传就会有问题。其次文件相关操作正常都是要搭建一个文件服务器的，比如使用fastdfs、hdfs等。本示例代码在电脑配置为4核内存8G情况下，上传24G大小的文件，上传时间需要30多分钟，主要时间耗费在前端的md5值计算，后端写入的速度还是比较快。如果项目组觉得自建文件服务器太花费时间，且项目的需求仅仅只是上传下载，那么推荐使用阿里的oss服务器，其介绍可以查看官网:&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;在实现分片上传的过程，需要前端和后端配合，比如前后端的上传块号的文件大小，前后端必须得要一致，否则上传就会有问题。其次文件相关操作正常都是要搭建一个文件服务器的，比如使用fastdfs、hdfs等。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NTM1NDgwNw==&amp;amp;mid=2247500365&amp;amp;idx=1&amp;amp;sn=7abfd8b30427d4ac15bb351c3dbb640c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在实现分片上传的过程，需要前端和后端配合，比如前后端的上传块号的文件大小，前后端必须得要一致，否则上传就会有问题。其次文件相关操作正常都是要搭建一个文件服务器的，比如使用fastdfs、hdfs等。本示例代码在电脑配置为4核内存8G情况下，上传24G大小的文件，上传时间需要30多分钟，主要时间耗费在前端的md5值计算，后端写入的速度还是比较快。如果项目组觉得自建文件服务器太花费时间，且项目的需求仅仅只是上传下载，那么推荐使用阿里的oss服务器，其介绍可以查看官网:&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;本示例代码在电脑配置为4核内存8G情况下，上传24G大小的文件，上传时间需要30多分钟，主要时间耗费在前端的md5值计算，后端写入的速度还是比较快。如果项目组觉得自建文件服务器太花费时间，且项目的需求仅仅只是上传下载，那么推荐使用阿里的oss服务器，其介绍可以查看官网:&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://help.aliyun.com/product/31815.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里的oss它本质是一个对象存储服务器，而非文件服务器，因此如果有涉及到大量删除或者修改文件的需求，oss可能就不是一个好的选择。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02ef0f16d1276ebcc5d3eded4d3227da</guid>
<title>喜报: 凹语言获InfoQ 2022开发者最喜爱十大开源项目</title>
<link>https://toutiao.io/k/8diunca</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;一、&lt;span&gt;InfoQ 中国技术力量榜单&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38179519595448796&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72XFKeicaBu6OkzOBR0RobVIWgPRnNJJ45eHSdkURTvHD9tY5X81eVmmMg/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651147301&amp;amp;idx=4&amp;amp;sn=04f2380a15be166d873cd275acdba3cf&amp;amp;chksm=bdb8b4768acf3d604ac3f0a7c8d1c438dce8505d81419b4a174543e865c8726dd6db58ab61c4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;InfoQ 2022 中国技术力量榜单&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;em&gt;InfoQ 2022 中国技术力量榜单&lt;/em&gt;&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span/&gt;国内InfoQ平台发起的评选活动&lt;span&gt;。在半个月的时间内，开源新锐项目、&lt;/span&gt;高价值技术团队&lt;span&gt;以及云原生创新技术方案三大榜单共征集了 160+项目。其中，开源新锐项目共收到 60+项目方的信息。从12月初开始至 12 月 14 日，开源新锐项目正式进入投票阶段，各位开发者可共同抉择出在研发、治理、生态层面都足以称为标杆的开源项目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、&lt;/span&gt;&lt;span&gt;开源新锐项目&lt;/span&gt;&lt;span&gt;评选规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38882921589688507&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72Xoj4fTRASnkhibMVHJSARdVhJl9Dpy459Lyxd2KQoQmaFEdKFMlftMEw/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;931&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本次榜单评选过程中，开源新锐项目最终得分由专家团打分（40%），用户投票 （30%）及 InfoQ 主编团（30%）构成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面是专家评审团：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1781701444622792&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72XuDecDcaRl6lTounNXuzpVcSAdlNbjJ6Rewq4hpZ5rrJjYZmiaoDr4Mw/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;623&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、开源新锐项网友投票结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源新锐项目有60+个，截止 12 月 14 日共获得4500+个投票（每个用户最多投5票，网友投票只占最终结果的30%）。前10名的投票结果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.660427807486631&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72Xp4ySRgQ2dVgfaGRWmkgDfSDKUV1wSQRoK8icCMP9sks68lHn2NrxwoA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;374&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户投票结果：&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://www.infoq.cn/talk/xz7094aiX2K8CgARemC8&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Apache Doris 是一个基于 MPP 的现代化、高性能、实时的分析型数据库，以极速易用的特点被人们所熟知，仅需亚秒级响应时间即可返回海量数据下的查询结果，可支持高并发、高吞吐的查询分析场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SREWorks 是来自阿里的云原生数智运维平台，助力企业快速实现云原生应用全生命周期管理平台。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LinkWeChat 是基于企业微信的开源 SCRM 系统，采用主流的 Java 微服务架构，是企业私域流量管理与营销的综合解决方案，助力企业提高客户运营效率，强化营销能力，拓展盈利空间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;openGemini是来自华为的一款开源的分布式时序数据库，可广泛应用于物联网、车联网、运维监控、工业互联网等业务场景，具备卓越的读写性能和高效的数据分析能力，是国内开源的首款存储-分析一站式时序数据库系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;凹语言是来自草根团队的&lt;span&gt;国产通用编程语言，国内第一个实现纯浏览器环境编译执行全链路的静态类型的通用编译型语言。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;FlyFish 中文名飞鱼，是云智慧公司自主设计、研发的一款低门槛、高拓展性的低代码应用开发平台，为数据可视化开发场景提供了高效的一站式解决方案。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LowCodeEngine 来自阿里的一款面向扩展设计的企业级低代码技术体系，是钉钉宜搭的底层引擎。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;KubeVela 是来自阿里的一个现代化的软件交付平台，起源于 OAM 应用模型，它可以让你的应用交付在当今流行的混合、多云环境中变得更加简单、高效、可靠。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MindSpore是华为开源的新一代全场景AI框架，支持端、边、云全场景灵活部署，开创全新的AI编程范式，降低AI开发门槛，旨在实现开发友好、运行高效、部署灵活三大目标，同时着力构筑面向全球的人工智能开源社区，推动人工智能软硬件应用生态繁荣发展。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Apache DevLake (Incubating) 是一款开源的研发效能数据平台。Apache DevLake 提供自动化、一站式的数据归集、分析以及可视化能力，帮助研发团队更好地理解开发过程，挖掘关键瓶颈与提效机会。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;四、十大开源新锐项目结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;开源新锐项目最终得分由专家团打分（40%），用户投票 （30%）及 InfoQ 主编团（30%）构成。&lt;/span&gt;网友投票结束之后，结合专家和InfoQ主编团的投票结果，评出下图&lt;/span&gt;&lt;span&gt;十大开源新锐项目：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5202702702702703&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72XC9Z1L2X1ibpQe6sgiclFOoxugEYzsVVPG6Z97onuDibOTDhpRAxR0MzXg/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出其中MindSpore、Apache Doris、KubeVela等4个项目也是网友投票热爱的项目，可见专家和网友的观点重复度还是比较高的。其中大部分项目都有公司背景、并已经经过多年的发展，有较大的社区影响力。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而网友投票的结果中有一些今年刚刚开源的项目，项目成熟度和社区影响力都还在快速成长过程中，暂时无缘今年的开源新锐项目奖项。希望这些新项目能够继续努力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整的结果：&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;https://www.infoq.cn/zones/chinatechawards2022/&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、凹语言荣获开发者喜爱奖项&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为刚刚开源半年的&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0ODQyOTE1NQ==&amp;amp;mid=2247483667&amp;amp;idx=1&amp;amp;sn=5db6b88c0c2f913a18445940a61a03cb&amp;amp;chksm=c366891ff4110009a521653f6a516bba8fa4a1c020fb312b522b193cf98d56f334be2831a60f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;凹语言&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;凹语言&lt;/a&gt;参与了其中开源新锐项目评选。&lt;/span&gt;&lt;span&gt;凹语言是国内 Gopher 发起的纯社区构建的开源国产编程语言项目。&lt;/span&gt;&lt;span&gt;同时凹语言也是国内第一个实现纯浏览器内编译、执行全链路的自研静态类型的编译型通用编程语言。&lt;/span&gt;&lt;span&gt;不仅仅&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0ODQyOTE1NQ==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=bfa813b9ac6693836aa2f201b5e17eff&amp;amp;chksm=c3668911f41100078576a08175a9ec61e8dfa3c806970e5cc0a2731f1d873a8ab52e23a2454c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点亮了Arduino Nano 33开发板&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点亮了Arduino Nano 33开发板&lt;/a&gt;，同时也通过实现了&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzk0ODQyOTE1NQ==&amp;amp;mid=2247483679&amp;amp;idx=1&amp;amp;sn=f435ea6b5742efb96523844337400510&amp;amp;chksm=c3668913f4110005894835bbbafcc46f92e7b75da7cdaa1358d0c907727fd01e59ea29659bbf&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;BrainFuck虚拟机&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;BrainFuck虚拟机&lt;/a&gt;证明了其图灵完备的能力，最近小伙伴们验证了通过凹语言开发Web版本贪吃蛇的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感谢InfoQ平台给凹语言颁发了开发者最喜爱的十大开源项目奖项：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QAncwTWS4Gop94f9xXrzIUgOIp7dx72XjoAZEiaRzoUiaiaEZT2gK7wk8dYaIbvXy5ea5icic3ursEJUQOYS9eWh1ibQ/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;凹语言作为唯一一个参与评选的国产编程语言开源项目，荣获开发者最喜爱十大开源项目称号，是社区小伙伴对这个项目方向的认可和鼓励。感谢大家的支持🙏&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QAncwTWS4GoROF9U9uuibsPByH1AYvk61pjsHNUNXdQdhpUupxiad7y0PXdibspZpCobBCkqtpHAzR4icFhwicWPajg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7dd289d971985b9530ffc235a0c8c5c5</guid>
<title>网络编程与通信原理</title>
<link>https://toutiao.io/k/2y1a1gm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;总感觉这个概念，和研发有点脱节；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、基础概念&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;不同设备之间通过网络进行数据传输，并且基于通用的网络协议作为多种设备的兼容标准，称为网络通信；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.365625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYTgklC6mWwbFicwUGiaTfPyx6Riab7HFe3spkwhx5TdvScchD2jicVQyNYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;以C/S架构来看，在一次请求当中，客户端和服务端进行数据传输的交互时，在不同阶段和层次中需要遵守的网络通信协议也不一样；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.29765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYGVV0UX36r9hytECm3b2y8TJtMJqszXu1MRpNF4Ysh0eRIiauUJxm5TQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;应用层：HTTP超文本传输协议，基于TCP/IP通信协议来传递数据；&lt;/p&gt;&lt;p&gt;传输层：TCP传输控制协议，采用三次握手的方式建立连接，形成数据传输通道；&lt;/p&gt;&lt;p&gt;网络层：IP协议，作用是把各种传输的数据包发送给请求的接收方；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYc92b765SFrTeU4yaAgZpibeRnpBySJlGwfC8f4bzf7v9D0d97cTF0rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通信双方进行交互时，发送方数据在各层传输时，每通过一层就会添加该层的首部信息；接收方与之相反，每通过一次就会删除该层的首部信息；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、JDK源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在&lt;code&gt;java.net&lt;/code&gt;源码包中，提供了与网络编程相关的基础API；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、InetAddress&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;封装了对IP地址的相关操作，在使用该API之前可以先查看本机的&lt;code&gt;hosts&lt;/code&gt;的映射，Linux系统中在&lt;code&gt;/etc/hosts&lt;/code&gt;路径下；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.net.InetAddress;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInet&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 获取本机 InetAddress 对象&lt;/span&gt;&lt;br/&gt;        InetAddress localHost = InetAddress.getLocalHost();&lt;br/&gt;        printInetAddress(localHost);&lt;br/&gt;        &lt;span&gt;// 获取指定域名 InetAddress 对象&lt;/span&gt;&lt;br/&gt;        InetAddress inetAddress = InetAddress.getByName(&lt;span&gt;&quot;www.baidu.com&quot;&lt;/span&gt;);&lt;br/&gt;        printInetAddress(inetAddress);&lt;br/&gt;        &lt;span&gt;// 获取本机配置 InetAddress 对象&lt;/span&gt;&lt;br/&gt;        InetAddress confAddress = InetAddress.getByName(&lt;span&gt;&quot;nacos-service&quot;&lt;/span&gt;);&lt;br/&gt;        printInetAddress(confAddress);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printInetAddress&lt;/span&gt; &lt;span&gt;(InetAddress inetAddress)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;InetAddress：&quot;&lt;/span&gt;+inetAddress);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;主机名：&quot;&lt;/span&gt;+inetAddress.getHostName());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;IP地址：&quot;&lt;/span&gt;+inetAddress.getHostAddress());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、URL&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;统一资源定位符，URL一般包括：协议、主机名、端口、路径、查询参数、锚点等，路径+查询参数，也被称为文件；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGY2an414JAktNEsKx8QVoCWmvaxMKA1yA0koA1bficAlY39iaaKr79ycKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.net.URL;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestURL&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        URL url = &lt;span&gt;new&lt;/span&gt; URL(&lt;span&gt;&quot;https://www.baidu.com:80/s?wd=Java#bd&quot;&lt;/span&gt;) ;&lt;br/&gt;        printURL(url);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printURL&lt;/span&gt; &lt;span&gt;(URL url)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;协议：&quot;&lt;/span&gt; + url.getProtocol());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;域名：&quot;&lt;/span&gt; + url.getHost());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;端口：&quot;&lt;/span&gt; + url.getPort());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;路径：&quot;&lt;/span&gt; + url.getPath());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;参数：&quot;&lt;/span&gt; + url.getQuery());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;文件：&quot;&lt;/span&gt; + url.getFile());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;锚点：&quot;&lt;/span&gt; + url.getRef());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、HttpURLConnection&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;作为URLConnection的抽象子类，用来处理针对Http协议的请求，可以设置连接超时、读取超时、以及请求的其他属性，是服务间通信的常用方式；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestHttp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 访问 网址 内容&lt;/span&gt;&lt;br/&gt;        URL url = &lt;span&gt;new&lt;/span&gt; URL(&lt;span&gt;&quot;https://www.jd.com&quot;&lt;/span&gt;);&lt;br/&gt;        HttpURLConnection httpUrlConnection = (HttpURLConnection) url.openConnection();&lt;br/&gt;        printHttp(httpUrlConnection);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 请求 服务 接口&lt;/span&gt;&lt;br/&gt;        URL api = &lt;span&gt;new&lt;/span&gt; URL(&lt;span&gt;&quot;http://localhost:8082/info/99&quot;&lt;/span&gt;);&lt;br/&gt;        HttpURLConnection apiConnection = (HttpURLConnection) api.openConnection();&lt;br/&gt;        apiConnection.setRequestMethod(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;);&lt;br/&gt;        apiConnection.setConnectTimeout(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;        printHttp(apiConnection);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printHttp&lt;/span&gt; &lt;span&gt;(HttpURLConnection httpUrlConnection)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; (InputStream inputStream = httpUrlConnection.getInputStream()) {&lt;br/&gt;            BufferedReader bufferedReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inputStream, StandardCharsets.UTF_8));&lt;br/&gt;            String line ;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((line = bufferedReader.readLine()) != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                System.out.println(line);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;三、通信编程&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Socket&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Socket也被称为套接字，是两台设备之间通信的端点，会把网络连接当成流处理，则数据以IO形式传输，这种方式在当前被普遍采用；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYhBPGmCLA4HRAqqv7UJpFE7a1UAAQUicAybvASN8FqC2DYbaczgSc6xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从网络编程直接跳到Socket套接字，概念上确实有较大跨度，概念过度抽象时，可以看看源码的核心结构，在理解时会轻松很多，在JDK中重点看SocketImpl抽象类；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SocketImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SocketOptions&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Socket对象，客户端和服务端&lt;/span&gt;&lt;br/&gt;    Socket socket = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 套接字的文件描述对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; FileDescriptor fd;&lt;br/&gt;    &lt;span&gt;// 套接字的路由IP地址&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; InetAddress address;&lt;br/&gt;    &lt;span&gt;// 套接字连接到的远程主机上的端口号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port;&lt;br/&gt;    &lt;span&gt;// 套接字连接到的本地端口号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; localport;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;套接字的抽象实现类，是实现套接字的所有类的公共超类，可以用于创建客户端和服务器套接字；&lt;/p&gt;&lt;p&gt;所以到底如何理解Socket概念？从抽象类中来看，套接字就是指代网络通讯中系统资源的核心标识，比如通讯方IP地址、端口、状态等；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、SocketServer&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;创建Socket服务端，并且在8989端口监听，接收客户端的连接请求和相关信息，并且响应客户端，发送指定的数据；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SocketServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、创建Socket服务端&lt;/span&gt;&lt;br/&gt;        ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(&lt;span&gt;8989&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;socket-server:8989，waiting connect...&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 2、方法阻塞等待，直到有客户端连接&lt;/span&gt;&lt;br/&gt;        Socket socket = serverSocket.accept();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;socket-server:8989，get connect:&quot;&lt;/span&gt;+socket.getPort());&lt;br/&gt;        &lt;span&gt;// 3、输入流，输出流&lt;/span&gt;&lt;br/&gt;        InputStream inStream = socket.getInputStream();&lt;br/&gt;        OutputStream outStream = socket.getOutputStream();&lt;br/&gt;        &lt;span&gt;// 4、数据接收和响应&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; readLen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((readLen=inStream.read(buf)) != -&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;// 接收数据&lt;/span&gt;&lt;br/&gt;            String readVar = &lt;span&gt;new&lt;/span&gt; String(buf, &lt;span&gt;0&lt;/span&gt;, readLen) ;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;exit&quot;&lt;/span&gt;.equals(readVar)){&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt; ;&lt;br/&gt;            }&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;recv：&quot;&lt;/span&gt;+readVar+&lt;span&gt;&quot;；time：&quot;&lt;/span&gt;+DateTime.now().toString(DatePattern.NORM_DATETIME_PATTERN));&lt;br/&gt;            &lt;span&gt;// 响应数据&lt;/span&gt;&lt;br/&gt;            outStream.write((&lt;span&gt;&quot;resp-time：&quot;&lt;/span&gt;+DateTime.now().toString(DatePattern.NORM_DATETIME_PATTERN)).getBytes());&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 5、资源关闭&lt;/span&gt;&lt;br/&gt;        outStream.close();&lt;br/&gt;        inStream.close();&lt;br/&gt;        socket.close();&lt;br/&gt;        serverSocket.close();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;socket-server:8989，exit...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是步骤2输出的端口号是随机不确定的，结合&lt;code&gt;jps&lt;/code&gt;和&lt;code&gt;lsof -i tcp:port&lt;/code&gt;命令查看进程和端口号的占用情况；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、SocketClient&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;创建Socket客户端，并且连接到服务端，读取命令行输入的内容并发送到服务端，并且输出服务端的响应数据；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SocketClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、创建Socket客户端&lt;/span&gt;&lt;br/&gt;        Socket socket = &lt;span&gt;new&lt;/span&gt; Socket(InetAddress.getLocalHost(), &lt;span&gt;8989&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;server-client，connect to:8989&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 2、输入流，输出流&lt;/span&gt;&lt;br/&gt;        OutputStream outStream = socket.getOutputStream();&lt;br/&gt;        InputStream inStream = socket.getInputStream();&lt;br/&gt;        &lt;span&gt;// 3、数据发送和响应接收&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; readLen = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;){&lt;br/&gt;            &lt;span&gt;// 读取命令行输入&lt;/span&gt;&lt;br/&gt;            BufferedReader bufReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(System.in));&lt;br/&gt;            String iptLine = bufReader.readLine();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;exit&quot;&lt;/span&gt;.equals(iptLine)){&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 发送数据&lt;/span&gt;&lt;br/&gt;            outStream.write(iptLine.getBytes());&lt;br/&gt;            &lt;span&gt;// 接收数据&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readLen = inStream.read(buf)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                System.out.println(&lt;span&gt;new&lt;/span&gt; String(buf, &lt;span&gt;0&lt;/span&gt;, readLen));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 4、资源关闭&lt;/span&gt;&lt;br/&gt;        inStream.close();&lt;br/&gt;        outStream.close();&lt;br/&gt;        socket.close();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;socket-client，get exit command&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试结果：整个流程在没有收到客户端的&lt;code&gt;exit&lt;/code&gt;退出指令前，会保持连接的状态，并且可以基于字节流模式，进行持续的数据传输；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYHumg6u4icE7haqLiauHFenaqHYfbeR4aVXbAxu0BG4oyBroJHxia5ObQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、字符流使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;基于上述的基础案例，采用字符流的方式进行数据传输，客户端和服务端只进行一次简单的交互；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-- &lt;span&gt;1&lt;/span&gt;、客户端&lt;br/&gt;BufferedReader bufReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inStream));&lt;br/&gt;BufferedWriter bufWriter = &lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(outStream));&lt;br/&gt;&lt;span&gt;// 客户端发送数据&lt;/span&gt;&lt;br/&gt;bufWriter.write(&lt;span&gt;&quot;hello,server&quot;&lt;/span&gt;);&lt;br/&gt;bufWriter.newLine();&lt;br/&gt;bufWriter.flush();&lt;br/&gt;&lt;span&gt;// 客户端接收数据&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;client-read：&quot;&lt;/span&gt;+bufReader.readLine());&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;2&lt;/span&gt;、服务端&lt;br/&gt;BufferedReader bufReader = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(inStream));&lt;br/&gt;BufferedWriter bufWriter = &lt;span&gt;new&lt;/span&gt; BufferedWriter(&lt;span&gt;new&lt;/span&gt; OutputStreamWriter(outStream));&lt;br/&gt;&lt;span&gt;// 服务端接收数据&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;server-read：&quot;&lt;/span&gt;+bufReader.readLine());&lt;br/&gt;&lt;span&gt;// 服务端响应数据&lt;/span&gt;&lt;br/&gt;bufWriter.write(&lt;span&gt;&quot;hello,client&quot;&lt;/span&gt;);&lt;br/&gt;bufWriter.newLine();&lt;br/&gt;bufWriter.flush();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;5、文件传输&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;基于上述的基础案例，客户端向服务端发送图片文件，服务端完成文件的读取和保存，在处理完成后给客户端发送结果描述；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;-- &lt;span&gt;1&lt;/span&gt;、客户端&lt;br/&gt;&lt;span&gt;// 客户端发送图片&lt;/span&gt;&lt;br/&gt;FileInputStream fileStream = &lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;Local_File_Path/jvm.png&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; ((i = fileStream.read(bytes)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    outStream.write(bytes);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 写入结束标记，禁用此套接字的输出流，之后再使用输出流会抛异常&lt;/span&gt;&lt;br/&gt;socket.shutdownOutput();&lt;br/&gt;&lt;span&gt;// 接收服务端响应结果&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;server-resp：&quot;&lt;/span&gt;+&lt;span&gt;new&lt;/span&gt; String(bytes,&lt;span&gt;0&lt;/span&gt;,readLen));&lt;br/&gt;&lt;br/&gt;-- &lt;span&gt;2&lt;/span&gt;、服务端&lt;br/&gt;&lt;span&gt;// 接收客户端图片&lt;/span&gt;&lt;br/&gt;FileOutputStream fileOutputStream = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;&quot;Local_File_Path/new_jvm.png&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; ((i = inStream.read(bytes)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    fileOutputStream.write(bytes, &lt;span&gt;0&lt;/span&gt;, i);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 响应客户端文件处理结果&lt;/span&gt;&lt;br/&gt;outStream.write(&lt;span&gt;&quot;file-save-success&quot;&lt;/span&gt;.getBytes());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;6、TCP协议&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Socket网络编程是基于TCP协议的，TCP传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，在上述案例中侧重基于流的数据传输，其中关于连接还涉及两个核心概念：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvAoib7m7G4GlDclV9PadtLGYN1bbEmrHvpgKHknVEC9q849ic45NA3uH74MTCVZVObgEYkwAf0Hd2UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三次握手&lt;/strong&gt;：建立连接的过程，在这个过程中进行了三次网络通信，当连接处于建立的状态，就可以进行正常的通信，即数据传输；&lt;strong&gt;四次挥手&lt;/strong&gt;：关闭连接的过程，调用&lt;code&gt;close&lt;/code&gt;方法，即连接使用结束，在这个过程中进行了四次网络通信；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、Http组件&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在服务通信时依赖网络，而对于编程来说，更常见的是的Http的组件，在微服务架构中，涉及到Http组件工具有很多，例如Spring框架中的RestTemplate，Feign框架支持ApacheHttp和OkHttp；下面围绕几个常用的组件编写测试案例；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1、基础接口&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BizWeb&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/getApi/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Rep&amp;lt;Integer&amp;gt; &lt;span&gt;getApi&lt;/span&gt;&lt;span&gt;(@PathVariable Integer id)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;id={}&quot;&lt;/span&gt;,id);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Rep.ok(id) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/getApi_v2/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Rep&amp;lt;Integer&amp;gt; &lt;span&gt;getApiV2&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,&lt;br/&gt;                                 @PathVariable Integer id,&lt;br/&gt;                                 @RequestParam(&lt;span&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt; String name)&lt;/span&gt;{&lt;br/&gt;        String token = request.getHeader(&lt;span&gt;&quot;Token&quot;&lt;/span&gt;);&lt;br/&gt;        log.info(&lt;span&gt;&quot;token={},id={},name={}&quot;&lt;/span&gt;,token,id,name);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Rep.ok(id) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/postApi&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Rep&amp;lt;IdKey&amp;gt; &lt;span&gt;postApi&lt;/span&gt;&lt;span&gt;(HttpServletRequest request,@RequestBody IdKey idKey)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        String token = request.getHeader(&lt;span&gt;&quot;Token&quot;&lt;/span&gt;);&lt;br/&gt;        log.info(&lt;span&gt;&quot;token={},idKey={}&quot;&lt;/span&gt;, token,JSONUtil.toJsonStr(idKey));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Rep.ok(idKey) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PutMapping&lt;/span&gt;(&lt;span&gt;&quot;/putApi&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Rep&amp;lt;IdKey&amp;gt; &lt;span&gt;putApi&lt;/span&gt;&lt;span&gt;(@RequestBody IdKey idKey)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;idKey={}&quot;&lt;/span&gt;, JSONUtil.toJsonStr(idKey));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Rep.ok(idKey) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@DeleteMapping&lt;/span&gt;(&lt;span&gt;&quot;/delApi/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Rep&amp;lt;Integer&amp;gt; &lt;span&gt;delApi&lt;/span&gt;&lt;span&gt;(@PathVariable Integer id)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;id={}&quot;&lt;/span&gt;,id);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Rep.ok(id) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、ApacheHttp&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestApacheHttp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String BASE_URL = &lt;span&gt;&quot;http://localhost:8083&quot;&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        BasicHeader header = &lt;span&gt;new&lt;/span&gt; BasicHeader(&lt;span&gt;&quot;Token&quot;&lt;/span&gt;,&lt;span&gt;&quot;ApacheSup&quot;&lt;/span&gt;) ;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 1、发送Get请求&lt;/span&gt;&lt;br/&gt;        Map&amp;lt;String,String&amp;gt; param = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;() ;&lt;br/&gt;        param.put(&lt;span&gt;&quot;name&quot;&lt;/span&gt;,&lt;span&gt;&quot;cicada&quot;&lt;/span&gt;) ;&lt;br/&gt;        Rep getRep = doGet(BASE_URL+&lt;span&gt;&quot;/getApi_v2/3&quot;&lt;/span&gt;,header,param, Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;get：&quot;&lt;/span&gt;+getRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、发送Post请求&lt;/span&gt;&lt;br/&gt;        IdKey postBody = &lt;span&gt;new&lt;/span&gt; IdKey(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;id-key-我&quot;&lt;/span&gt;) ;&lt;br/&gt;        Rep postRep = doPost (BASE_URL+&lt;span&gt;&quot;/postApi&quot;&lt;/span&gt;, header, postBody, Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;post：&quot;&lt;/span&gt;+postRep);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 构建HttpClient对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; CloseableHttpClient &lt;span&gt;buildHttpClient&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 请求配置&lt;/span&gt;&lt;br/&gt;        RequestConfig reqConfig = RequestConfig.custom().setConnectTimeout(&lt;span&gt;6000&lt;/span&gt;).build();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; HttpClients.custom()&lt;br/&gt;                .setDefaultRequestConfig(reqConfig).build();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行Get请求&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;doGet&lt;/span&gt; &lt;span&gt;(String url, Header header, Map&amp;lt;String,String&amp;gt; param,&lt;br/&gt;                               Class&amp;lt;T&amp;gt; repClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 创建Get请求&lt;/span&gt;&lt;br/&gt;        CloseableHttpClient httpClient = buildHttpClient();&lt;br/&gt;        HttpGet httpGet = &lt;span&gt;new&lt;/span&gt; HttpGet();&lt;br/&gt;        httpGet.addHeader(header);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            URIBuilder builder = &lt;span&gt;new&lt;/span&gt; URIBuilder(url);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (param != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (String key : param.keySet()) {&lt;br/&gt;                    builder.addParameter(key, param.get(key));&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            httpGet.setURI(builder.build());&lt;br/&gt;            &lt;span&gt;// 请求执行&lt;/span&gt;&lt;br/&gt;            HttpResponse httpResponse = httpClient.execute(httpGet);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (httpResponse.getStatusLine().getStatusCode() == &lt;span&gt;200&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 结果转换&lt;/span&gt;&lt;br/&gt;                String resp = EntityUtils.toString(httpResponse.getEntity());&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; JSONUtil.toBean(resp, repClass);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            IoUtil.close(httpClient);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行Post请求&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;doPost&lt;/span&gt; &lt;span&gt;(String url, Header header, Object body,Class&amp;lt;T&amp;gt; repClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 创建Post请求&lt;/span&gt;&lt;br/&gt;        CloseableHttpClient httpClient = buildHttpClient();&lt;br/&gt;        HttpPost httpPost = &lt;span&gt;new&lt;/span&gt; HttpPost(url);&lt;br/&gt;        httpPost.addHeader(header);&lt;br/&gt;        StringEntity conBody = &lt;span&gt;new&lt;/span&gt; StringEntity(JSONUtil.toJsonStr(body),ContentType.APPLICATION_JSON);&lt;br/&gt;        httpPost.setEntity(conBody);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 请求执行&lt;/span&gt;&lt;br/&gt;            HttpResponse httpResponse = httpClient.execute(httpPost);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (httpResponse.getStatusLine().getStatusCode() == &lt;span&gt;200&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 结果转换&lt;/span&gt;&lt;br/&gt;                String resp = EntityUtils.toString(httpResponse.getEntity());&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; JSONUtil.toBean(resp, repClass);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            IoUtil.close(httpClient);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、OkHttp&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestOkHttp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String BASE_URL = &lt;span&gt;&quot;http://localhost:8083&quot;&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Headers headers = &lt;span&gt;new&lt;/span&gt; Headers.Builder().add(&lt;span&gt;&quot;Token&quot;&lt;/span&gt;,&lt;span&gt;&quot;OkHttpSup&quot;&lt;/span&gt;).build() ;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 1、发送Get请求&lt;/span&gt;&lt;br/&gt;        Rep getRep = execute(BASE_URL+&lt;span&gt;&quot;/getApi/1&quot;&lt;/span&gt;, Method.GET.name(), headers, &lt;span&gt;null&lt;/span&gt;, Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;get：&quot;&lt;/span&gt;+getRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、发送Post请求&lt;/span&gt;&lt;br/&gt;        IdKey postBody = &lt;span&gt;new&lt;/span&gt; IdKey(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;id-key&quot;&lt;/span&gt;) ;&lt;br/&gt;        Rep postRep = execute(BASE_URL+&lt;span&gt;&quot;/postApi&quot;&lt;/span&gt;, Method.POST.name(), headers, buildBody(postBody), Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;post：&quot;&lt;/span&gt;+postRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、发送Put请求&lt;/span&gt;&lt;br/&gt;        IdKey putBody = &lt;span&gt;new&lt;/span&gt; IdKey(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;key-id&quot;&lt;/span&gt;) ;&lt;br/&gt;        Rep putRep = execute(BASE_URL+&lt;span&gt;&quot;/putApi&quot;&lt;/span&gt;, Method.PUT.name(), headers, buildBody(putBody), Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;put：&quot;&lt;/span&gt;+putRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、发送Delete请求&lt;/span&gt;&lt;br/&gt;        Rep delRep = execute(BASE_URL+&lt;span&gt;&quot;/delApi/2&quot;&lt;/span&gt;, Method.DELETE.name(), headers, &lt;span&gt;null&lt;/span&gt;, Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;del：&quot;&lt;/span&gt;+delRep);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 构建JSON请求体&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RequestBody &lt;span&gt;buildBody&lt;/span&gt; &lt;span&gt;(Object body)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        MediaType mediaType = MediaType.parse(&lt;span&gt;&quot;application/json; charset=utf-8&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; RequestBody.create(mediaType, JSONUtil.toJsonStr(body)) ;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 构建OkHttpClient对象&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OkHttpClient &lt;span&gt;buildOkHttp&lt;/span&gt; &lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; OkHttpClient.Builder()&lt;br/&gt;                .readTimeout(&lt;span&gt;10&lt;/span&gt;, TimeUnit.SECONDS).connectTimeout(&lt;span&gt;6&lt;/span&gt;, TimeUnit.SECONDS)&lt;br/&gt;                .connectionPool(&lt;span&gt;new&lt;/span&gt; ConnectionPool(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, TimeUnit.SECONDS))&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行请求&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;execute&lt;/span&gt; &lt;span&gt;(String url, String method,&lt;br/&gt;                                 Headers headers, RequestBody body,&lt;br/&gt;                                 Class&amp;lt;T&amp;gt; repClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 请求创建&lt;/span&gt;&lt;br/&gt;        OkHttpClient httpClient = buildOkHttp() ;&lt;br/&gt;        Request.Builder requestBuild = &lt;span&gt;new&lt;/span&gt; Request.Builder()&lt;br/&gt;                .url(url).method(method, body);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (headers != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            requestBuild.headers(headers);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;  {&lt;br/&gt;            &lt;span&gt;// 请求执行&lt;/span&gt;&lt;br/&gt;            Response response = httpClient.newCall(requestBuild.build()).execute();&lt;br/&gt;            &lt;span&gt;// 结果转换&lt;/span&gt;&lt;br/&gt;            InputStream inStream = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (response.isSuccessful()) {&lt;br/&gt;                ResponseBody responseBody = response.body();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (responseBody != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    inStream = responseBody.byteStream();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inStream != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;byte&lt;/span&gt;[] respByte = IoUtil.readBytes(inStream);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (respByte != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; JSONUtil.toBean(&lt;span&gt;new&lt;/span&gt; String(respByte, Charset.defaultCharset()), repClass);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    IoUtil.close(inStream);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、RestTemplate&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRestTemplate&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String BASE_URL = &lt;span&gt;&quot;http://localhost:8083&quot;&lt;/span&gt; ;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        RestTemplate restTemplate = buildRestTemplate() ;&lt;br/&gt;        &lt;span&gt;// 1、发送Get请求&lt;/span&gt;&lt;br/&gt;        Map&amp;lt;String,String&amp;gt; paramMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;() ;&lt;br/&gt;        Rep getRep = restTemplate.getForObject(BASE_URL+&lt;span&gt;&quot;/getApi/1&quot;&lt;/span&gt;,Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;paramMap&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;get：&quot;&lt;/span&gt;+getRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 2、发送Post请求&lt;/span&gt;&lt;br/&gt;        IdKey idKey = &lt;span&gt;new&lt;/span&gt; IdKey(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;id-key&quot;&lt;/span&gt;) ;&lt;br/&gt;        Rep postRep = restTemplate.postForObject(BASE_URL+&lt;span&gt;&quot;/postApi&quot;&lt;/span&gt;,idKey,Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;post：&quot;&lt;/span&gt;+postRep);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 3、发送Put请求&lt;/span&gt;&lt;br/&gt;        IdKey idKey2 = &lt;span&gt;new&lt;/span&gt; IdKey(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;&quot;key-id&quot;&lt;/span&gt;) ;&lt;br/&gt;        restTemplate.put(BASE_URL+&lt;span&gt;&quot;/putApi&quot;&lt;/span&gt;,idKey2,paramMap);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 4、发送Delete请求&lt;/span&gt;&lt;br/&gt;        restTemplate.delete(BASE_URL+&lt;span&gt;&quot;/delApi/2&quot;&lt;/span&gt;,paramMap);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 5、自定义Header请求&lt;/span&gt;&lt;br/&gt;        HttpHeaders headers = &lt;span&gt;new&lt;/span&gt; HttpHeaders();&lt;br/&gt;        headers.add(&lt;span&gt;&quot;Token&quot;&lt;/span&gt;,&lt;span&gt;&quot;AdminSup&quot;&lt;/span&gt;);&lt;br/&gt;        HttpEntity&amp;lt;IdKey&amp;gt; requestEntity = &lt;span&gt;new&lt;/span&gt; HttpEntity&amp;lt;&amp;gt;(idKey, headers);&lt;br/&gt;        ResponseEntity&amp;lt;Rep&amp;gt; respEntity = restTemplate.exchange(BASE_URL+&lt;span&gt;&quot;/postApi&quot;&lt;/span&gt;,&lt;br/&gt;                                            HttpMethod.POST, requestEntity, Rep&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;post-header：&quot;&lt;/span&gt;+respEntity.getBody());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RestTemplate &lt;span&gt;buildRestTemplate&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1、参数配置&lt;/span&gt;&lt;br/&gt;        SimpleClientHttpRequestFactory factory = &lt;span&gt;new&lt;/span&gt; SimpleClientHttpRequestFactory();&lt;br/&gt;        factory.setReadTimeout(&lt;span&gt;3000&lt;/span&gt;);&lt;br/&gt;        factory.setConnectTimeout(&lt;span&gt;6000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 2、创建对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RestTemplate(factory) ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>776ca226f994938b80c46df102e2448e</guid>
<title>Maven-Assembly 插件实现自定义打包</title>
<link>https://toutiao.io/k/qwmecke</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
        
                &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;前提概要&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;最近我们项目越来越多了，然后我就在想如何才能把基础服务的打包方式统一起来，并且可以实现按照我们的要求来生成，通过研究，我们通过使用maven的assembly插件完美的实现了该需求，爽爆了有木有。本文分享该插件的配置以及微服务的统一打包方式。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;mavenassemblyplugin_4&quot;/&gt;maven-assembly-plugin打包插件&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;_6&quot;/&gt;配置步骤及其他事项&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;首先我们需要在pom.xml中配置maven的assembly插件&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;executions&amp;gt;
&amp;lt;!-- 配置执行器 --&amp;gt;
          &amp;lt;execution&amp;gt;
            &amp;lt;id&amp;gt;make-assembly&amp;lt;/id&amp;gt;
&amp;lt;!-- 绑定到package生命周期阶段上 --&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
  &amp;lt;!-- 只运行一次 --&amp;gt;
              &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
              &amp;lt;!--生成包的末尾添加assembly id，一般关闭 --&amp;gt;
              &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt;
              &amp;lt;finalName&amp;gt;${project.artifactId}-${project.version}&amp;lt;/finalName&amp;gt;
              &amp;lt;!--加载指定的配置文件--&amp;gt;
              &amp;lt;descriptors&amp;gt;
              &amp;lt;descriptor&amp;gt;src/main/assembly/assembly.xml&amp;lt;/descriptor&amp;gt;
              &amp;lt;/descriptors&amp;gt;
            &amp;lt;/configuration&amp;gt;
          &amp;lt;/execution&amp;gt;
        &amp;lt;/executions&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
 &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;_41&quot;/&gt;配置参数介绍说明&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt;execution：配置执行器 
  &lt;ul&gt;&lt;li&gt;phase：绑定到package生命周期阶段上&lt;/li&gt;&lt;li&gt;goal：{single}：只运行一次&lt;/li&gt;&lt;li&gt;configuration-&amp;gt;appendAssemblyId：生成包的末尾添加assembly id，一般关闭&lt;/li&gt;&lt;li&gt;descriptor：src/main/assembly/assembly.xml：后续会讲解，主要用于描述如何进行打包的规则。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;assemblyxml_49&quot;/&gt;自定义格式包assembly.xml&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;接着我们在src/main/assembly文件中配置assembly.xml文件&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;pre&gt;&lt;code&gt;  &amp;lt;assembly&amp;gt;
      &amp;lt;id&amp;gt;唯一编号&amp;lt;/id&amp;gt;
      &amp;lt;formats&amp;gt;
      &amp;lt;!--打包的文件格式,也可以有：war zip--&amp;gt;
          &amp;lt;format&amp;gt;tar.gz&amp;lt;/format&amp;gt;
      &amp;lt;/formats&amp;gt;
      &amp;lt;!--tar.gz压缩包下是否生成和项目名相同的根目录--&amp;gt;
      &amp;lt;includeBaseDirectory&amp;gt;true&amp;lt;/includeBaseDirectory&amp;gt;
     &amp;lt;fileSets&amp;gt;
         &amp;lt;fileSet&amp;gt;
             &amp;lt;directory&amp;gt;src/main/bin&amp;lt;/directory&amp;gt;
             &amp;lt;outputDirectory&amp;gt;/&amp;lt;/outputDirectory&amp;gt;
 &amp;lt;!-- Linux权限 --&amp;gt;
             &amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
         &amp;lt;/fileSet&amp;gt;
         &amp;lt;fileSet&amp;gt;
&amp;lt;directory&amp;gt;target/classes/META-INF/conf&amp;lt;/directory&amp;gt;
            &amp;lt;outputDirectory&amp;gt;conf/META-INF/conf&amp;lt;/outputDirectory&amp;gt;
&amp;lt;!-- Linux权限 --&amp;gt;
&amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
        &amp;lt;/fileSet&amp;gt;
&amp;lt;fileSet&amp;gt;
&amp;lt;directory&amp;gt;target/classes&amp;lt;/directory&amp;gt;
&amp;lt;outputDirectory&amp;gt;conf&amp;lt;/outputDirectory&amp;gt;
&amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
&amp;lt;includes&amp;gt;&amp;lt;!-- 只负责这些目标文件--&amp;gt;
&amp;lt;include&amp;gt;*.properties&amp;lt;/include&amp;gt;
&amp;lt;include&amp;gt;*.xml&amp;lt;/include&amp;gt;
&amp;lt;/includes&amp;gt;
&amp;lt;/fileSet&amp;gt;
     &amp;lt;/fileSets&amp;gt;
     &amp;lt;!-- 输出到lib路径 --&amp;gt;
     &amp;lt;dependencySets&amp;gt;
          &amp;lt;dependencySet&amp;gt;
             &amp;lt;!--是否在最外层套一个本项目的名称的文件目录--&amp;gt;
             &amp;lt;useProjectArtifact&amp;gt;true&amp;lt;/useProjectArtifact&amp;gt;
             &amp;lt;!-- 输出到这个路径下 --&amp;gt;
             &amp;lt;outputDirectory&amp;gt;lib&amp;lt;/outputDirectory&amp;gt;
             &amp;lt;!--将scope为runtime的依赖包打包--&amp;gt;
             &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
         &amp;lt;/dependencySet&amp;gt;
     &amp;lt;/dependencySets&amp;gt;
 &amp;lt;/assembly&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
 
&lt;p&gt;&lt;a href=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly.html&quot;&gt;assembly的具体语法，请参见官网：&lt;/a&gt;&lt;/p&gt; 
 
&lt;pre&gt;&lt;code&gt;&amp;lt;assembly
xmlns=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd&quot;&amp;gt;
&amp;lt;id&amp;gt;my-assembly&amp;lt;/id&amp;gt;
&amp;lt;formats&amp;gt;
          &amp;lt;!--打包生成后的格式 --&amp;gt;
&amp;lt;format&amp;gt;zip&amp;lt;/format&amp;gt;
&amp;lt;/formats&amp;gt;
     &amp;lt;!-- --&amp;gt;
&amp;lt;includeBaseDirectory&amp;gt;false&amp;lt;/includeBaseDirectory&amp;gt;
&amp;lt;fileSets&amp;gt;
&amp;lt;fileSet&amp;gt;
               &amp;lt;!--脚本所在的文件夹，以及打包后将脚本输出到哪个文件夹中 --&amp;gt;
&amp;lt;directory&amp;gt;src/scripts&amp;lt;/directory&amp;gt;
&amp;lt;outputDirectory&amp;gt;alarm/bin&amp;lt;/outputDirectory&amp;gt;
               &amp;lt;!-- 哪些文件会被提取 --&amp;gt;
&amp;lt;includes&amp;gt;
&amp;lt;include&amp;gt;*.sh&amp;lt;/include&amp;gt;
&amp;lt;/includes&amp;gt;
               &amp;lt;!-- 文件权限及编码 --&amp;gt;
&amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt;
&amp;lt;lineEnding&amp;gt;unix&amp;lt;/lineEnding&amp;gt;
&amp;lt;/fileSet&amp;gt;
&amp;lt;fileSet&amp;gt;
               &amp;lt;!--同上，这里配置的是配置文件所在的文件夹 --&amp;gt;
&amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
&amp;lt;outputDirectory&amp;gt;alarm/conf&amp;lt;/outputDirectory&amp;gt;
&amp;lt;includes&amp;gt;
&amp;lt;include&amp;gt;*.yml&amp;lt;/include&amp;gt;
&amp;lt;/includes&amp;gt;
&amp;lt;lineEnding&amp;gt;unix&amp;lt;/lineEnding&amp;gt;
&amp;lt;/fileSet&amp;gt;
&amp;lt;!--artifact --&amp;gt;
&amp;lt;fileSet&amp;gt;
               &amp;lt;!--这里的target是maven-compiler-plugin生成该项目的jar包的位置 --&amp;gt;
&amp;lt;directory&amp;gt;target&amp;lt;/directory&amp;gt;
&amp;lt;outputDirectory&amp;gt;alarm/lib&amp;lt;/outputDirectory&amp;gt;
&amp;lt;includes&amp;gt;
&amp;lt;include&amp;gt;*.jar&amp;lt;/include&amp;gt;
&amp;lt;/includes&amp;gt;
&amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt;
&amp;lt;/fileSet&amp;gt;
&amp;lt;/fileSets&amp;gt;
&amp;lt;dependencySets&amp;gt;
&amp;lt;dependencySet&amp;gt;
               &amp;lt;!--这里是将该项目依赖的所有jar包存入lib文件夹中 --&amp;gt;
&amp;lt;outputDirectory&amp;gt;alarm/lib&amp;lt;/outputDirectory&amp;gt;
&amp;lt;useProjectArtifact&amp;gt;false&amp;lt;/useProjectArtifact&amp;gt;
&amp;lt;useProjectAttachments&amp;gt;true&amp;lt;/useProjectAttachments&amp;gt;
&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependencySet&amp;gt;
&amp;lt;/dependencySets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h3&gt;&lt;a id=&quot;_166&quot;/&gt;启动脚本&lt;/h3&gt; 
&lt;p&gt;在完成以上配置后，只需在指定的位置建立scripts/start.sh和stop.sh两个脚本即可完成。具体启动脚本如下：&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;startsh_170&quot;/&gt;start.sh启动文件脚本&lt;/h4&gt; 
&lt;pre&gt;&lt;code&gt;#!/bin/sh
basepath=$(cd `dirname $0`;cd &#x27;../&#x27;; pwd)
echo &quot;path:&quot;$basepath
jarHome=&#x27;/my.jar&#x27;
echo &quot;Starting my service&quot;
ls_date=`date +%Y%m%d`
if [ ! -d &quot;${basepath}/log&quot; ]; then
  mkdir ${basepath}/log
fi
if [ ! -d &quot;$basepath/log/${ls_date}&quot; ]; then
  mkdir $basepath/log/${ls_date}
fi
nohup java -jar $basepath$jarHome --spring.config.location=$basepath/conf/server-attach.yml,$basepath/conf/server-shared.yml&amp;gt; $basepath/log/${ls_date}/${ls_date}.log &amp;amp;
#####
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;主要命令是获取当天日期，然后在log文件夹下建立指定日期的文件夹，并将日志存放进去。其中–spring.config.location用于加载指定的配置文件，多个配置文件用逗号分割。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;stopsh_192&quot;/&gt;stop.sh停止文件脚本&lt;/h4&gt; 
&lt;p&gt;停止脚本通过ps -ef获取进程id然后kill，如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;#!/bin/sh
my=`ps -ef |grep my.jar | grep -v grep | awk &#x27;{print $2}&#x27;`
kill -9 $my
&lt;/code&gt;&lt;/pre&gt; 
&lt;h2&gt;&lt;a id=&quot;_202&quot;/&gt;结语&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;以上配置完成后使用mvn package命令即可自动打成一个zip压缩包，包内包含bin、conf、lib文件夹，可用启动脚本一键启动。实际上这里能修改的地方还有很多，包括启动脚本也可以用其他方式如java -classpath方式启动等等，具体的可以根据自身需求进行相应修改。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>