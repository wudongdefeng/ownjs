<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5ef4ded54591476d99b8ec96ba1b4c7a</guid>
<title>31个！Golang常用工具来啦（建议收藏）</title>
<link>https://toutiao.io/k/amn3bs7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.13125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94xFM2RX1fYJ1Tz9VEicAPCrbntSm88RQq2s6XBuWbyBeSleAfrPAoQvytBh3Wdiagz6sY4AHHzricYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;本文主要分享Golang相关的一些使用工具，简单介绍工具作用和使用场景，不会详细介绍其使用，列举的工具也不是最全的，具体可以参考链接或自行搜索学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go官方的工具可以使用go help xxx命令查看帮助文档，比如查看go get的参数标记和使用文档：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;help&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以参考Golang官方的文档：&lt;/span&gt;&lt;span&gt;https://golang.google.cn/cmd/go/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、G0官方工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;8c2011fe7977c79c57258f08c7c970ac1&quot;&gt;&lt;/p&gt;&lt;h2 name=&quot;1.1%C2%A0go-get&quot;&gt;&lt;span&gt;（一）go get&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以根据要求和实际情况从互联网上下载或更新指定的代码包及其依赖包，下载后自动编译，一般引用依赖用go get就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; -u &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/VictoriaMetrics/fastcache&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261349&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.2%C2%A0go-build&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.2%C2%A0go-build&quot;&gt;&lt;span&gt;（二）go build&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令用于编译我们指定的源码文件或代码包以及它们的依赖包。命令的常用标记说明如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6343085106382979&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96fsTy9sN5GgRfjUtXDe4pslnCOKZ2K9iczT2R5Nsc86f35FFoqSqvwC8TWVEhLCGj5F5EI2WfAicYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1504&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编译过程输出到文件：go build -x &amp;gt; result 2&amp;gt;&amp;amp;1，因为go build -x 最终是将日志写到标准错误流当中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果只在编译特定包时需要指定参数，可以参考包名=参数列表的格式，比如go build -gcflags=&#x27;log=-N -l&#x27; main.go&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;s://www.kancloud.cn/cattong/go_command_tutorial/261347&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.3%C2%A0go-install&quot;&gt;&lt;span&gt;（三）go install&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令用于编译并安装指定的代码包及它们的依赖包。当指定的代码包的依赖包还没有被编译和安装时，该命令会先去处理依赖包。与go build命令一样，传给go install命令的代码包参数应该以导入路径的形式提供。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并且，go build命令的绝大多数标记也都可以用于go install命令。实际上，go install命令只比go build命令多做了一件事，即：安装编译后的结果文件到指定目录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.c&lt;/span&gt;&lt;span&gt;n/cattong/go_command_tutorial/261348&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.4-go-fmt%E5%92%8Cgofmt&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.4-go-fmt%E5%92%8Cgofmt&quot;&gt;&lt;span&gt;（四）go fmt和gofmt&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Golang的开发团队制定了统一的官方代码风格，并且推出了gofmt工具（gofmt或go fmt）来帮助开发者格式化他们的代码到统一的风格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gofmt是一个cli程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有.go文件，如果不传参数，会格式化当前目录下的所有.go文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gofmt默认不对代码进行简化，使用-s参数可以开启简化代码功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gofmt是一个独立的cli程序，而go中还有一个go fmt命令，go fmt命令是gofmt的简单封装。go fmt在调用gofmt时添加了-l -w参数，相当于执行了gofmt -l -w&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/whatday/article/details/97682094&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.5-go-env&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.5-go-env&quot;&gt;&lt;span&gt;（五）go env&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令用于打印Go语言的环境信息，常见的通用环境信息如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.96953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96fsTy9sN5GgRfjUtXDe4psaSfgrEgT4HTDvkp0RgT8QXHs4LghVZH2SMNUayKyclnHeNYPVCJL4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置或修改环境变量值：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; env -w GOPROXY=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://goproxy.com,direct&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261359&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.6-go-run&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.6-go-run&quot;&gt;&lt;span&gt;（六）go run &lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以运行命令源码文件，只能接受一个命令源码文件以及若干个库源码文件（必须同属于main包）作为文件参数，且不能接受测试源码文件。它在执行时会检查源码文件的类型。如果参数中有多个或者没有命令源码文件，那么go run命令就只会打印错误提示信息并退出，而不会继续执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在通过参数检查后，go run命令会将编译参数中的命令源码文件，并把编译后的可执行文件存放到临时工作目录中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kan&lt;/span&gt;&lt;span&gt;cloud.cn/cattong/go_command_tutorial/261352&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.7-go-test&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.7-go-test&quot;&gt;&lt;span&gt;（七）go test&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令用于对Go语言编写的程序进行测试，这种测试是以代码包为单位的，命令会自动测试每一个指定的代码包。当然，前提是指定的代码包中存在测试源码文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261353&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.8-go-clean&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.8-go-clean&quot;&gt;&lt;span&gt;（八）go clean&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令会删除掉执行其它命令时产生的一些文件和目录。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/g&lt;/span&gt;&lt;span&gt;o_command_tutorial/261350&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.9-go-list&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.9-go-list&quot;&gt;&lt;span&gt;（九）go list&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令的作用是列出指定的代码包的信息。与其他命令相同，我们需要以代码包导入路径的方式给定代码包。被给定的代码包可以有多个。这些代码包对应的目录中必须直接保存有Go语言源码文件，其子目录中的文件不算在内。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记-e的作用是以容错模式加载和分析指定的代码包。在这种情况下，命令程序如果在加载或分析的过程中遇到错误只会在内部记录一下，而不会直接把错误信息打印出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了看到错误信息可以使用-json标记。这个标记的作用是把代码包的结构体实例用JSON的样式打印出来。-m标记可以打印出modules而不是package。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Path&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/Project/test&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Main&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__keyword&quot;&gt;true&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Dir&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/data/test&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;GoMod&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/data/test/go.mod&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;GoVersion&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1.15&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt; -m -json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https:&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;/www.kancloud.cn/cattong/go_command_tutorial/261354&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.10-go-mod-xxx&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.10-go-mod-xxx&quot;&gt;&lt;span&gt;（十）go mod xxx&lt;/span&gt;&lt;/h2&gt;&lt;h3 name=&quot;1.10.1-go-mod-init&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令初始化并写入一个新的go.mod至当前目录中，实际上是创建一个以当前目录为根的新模块。文件go.mod必须不存在。如果可能，init会从import注释（参阅“go help importpath”）或从版本控制配置猜测模块路径。要覆盖此猜测，提供模块路径作为参数 module为当前项目名。比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; mod init demo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.10.2-go-mod-tidy&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令确保go.mod与模块中的源代码一致。它添加构建当前模块的包和依赖所必须的任何缺少的模块，删除不提供任何有价值的包的未使用的模块。它也会添加任何缺少的条目至go.mod并删除任何不需要的条目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.10.3-go-mod-vendor&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令重置主模块的vendor目录，使其包含构建和测试所有主模块的包所需要的所有包。不包括vendor中的包的测试代码。即将GOPATH或GOROOT下载的包拷贝到项目下的vendor目录，如果不使用vendor隔离项目的依赖，则不需要使用该命令拷贝依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.10.4-go-mod-download&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令下载指定名字的模块，可为选择主模块依赖的模块匹配模式，或path@version形式的模块查询。如果download不带参数则代表是主模块的所有依赖。download的只会下载依赖，不会编译依赖，和get是有区别的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令提供一个编辑go.mod的命令行接口，主要提供给工具或脚本使用。它只读取go.mod；不查找涉及模块的信息。默认情况下，edit读写主模块的go.mod文件，但也可以在标志后指定不同的目标文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参&lt;/span&gt;&lt;span&gt;考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 name=&quot;1.10.6-go-mod-graph&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令以文本形式打印模块间的依赖关系图。输出的每一行行有两个字段（通过空格分割）；模块和其所有依赖中的一个。每个模块都被标记为path@version形式的字符串（除了主模块，因其没有@version后缀）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令查存储在本地下载源代码缓存中的当前模块的依赖，是否自从下载之后未被修改。如果所有模块都未被修改，打印“all modules verified”。否则，报告哪个模块已经被修改并令“go mod”以非0状态退出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令输出每个包或者模块的引用块，每个块以注释行“# package”或“# module”开头，给出目标包或模块。随后的行通过导入图给出路径，一个包一行。每个块之间通过一个空行分割，如果包或模块没有被主模块引用，该小节将显示单独一个带圆括号的提示信息来表明该事实。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.jianshu.com/p/f6d2d6db2bca&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;1.11-go-tool-xxx&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;1.11-go-tool-xxx&quot;&gt;&lt;span&gt;（十一）go tool xxx&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;go tool的可执行文件在GOROOT或GOPATH的pkg/tool目录。go doc cmd可以查看具体cmd的使用说明，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; doc pprof&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Golang中，可以通过pprof工具对应于程序的运行时进行性能分析，包括CPU、内存、Goroutine等实时信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cat&lt;/span&gt;&lt;span&gt;tong/go_command_tutorial/261357&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.2-go-tool-trace&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以追踪请求链路，清晰的了解整个程序的调用栈，可以通过追踪器捕获大量信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/410590497&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以编译Go文件生成汇编代码，-N参数表示禁止编译优化， -l表示禁止内联，-S表示打印汇编，比如&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 会生成&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.o&lt;/span&gt;的汇编文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tool&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;compile&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-S&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令是一个用于检查Go语言源码中静态错误的简单工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;go vet命令是go tool vet命令的简单封装。它会首先载入和分析指定的代码包，并把指定代码包中的所有Go语言源码文件和以“.s”结尾的文件的相对路径作为参数传递给go tool vet命令。其中，以“.s”结尾的文件是汇编语言的源码文件。如果go vet命令的参数是Go语言源码文件的路径，则会直接将这些参数传递给go tool vet命令。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261356&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.5-go-tool-doc%E5%92%8Cgo-doc&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以打印附于Go语言程序实体上的文档。我们可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓Go语言的程序实体，是指变量、常量、函数、结构体以及接口。而程序实体的标识符即是代表它们的名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261351&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.6-go-tool-addr2line&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以调用栈的地址转化为文件和行号。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Usage:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    go tool addr2line binary&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Addr2line reads hexadecimal addresses, one per line and &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; optional &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;x&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;prefix, &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; standard input. &lt;span class=&quot;code-snippet__keyword&quot;&gt;For&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;input&lt;/span&gt; address, addr2line prints two&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;output&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;lines&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;first&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; containing the address &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;second&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;file&lt;/span&gt;:line &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; the &lt;span class=&quot;code-snippet__keyword&quot;&gt;source&lt;/span&gt; code &lt;span class=&quot;code-snippet__keyword&quot;&gt;corresponding&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; that address.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;This tool &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; intended &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;by&lt;/span&gt; pprof; its interface may &lt;span class=&quot;code-snippet__keyword&quot;&gt;change&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt; it&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;may be deleted entirely &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; future releases.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以将汇编文件编译成一个.o文件，后续这个.o文件可以用于生成.a归档文件，命令的file参数必须是汇编文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Usage:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    go tool &lt;span class=&quot;code-snippet__keyword&quot;&gt;asm&lt;/span&gt; [flags] file&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;The specified file must be a Go assembly file. The same assembler is used&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; all target operating systems &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; architectures. The GOOS &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; GOARCH&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;environment variables &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; the desired target.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个 Go 二进制文件内&lt;/span&gt;&lt;span&gt;，都有一个独一无二的 Build ID，详情参考 &lt;/span&gt;&lt;span&gt;src/cmd/go/internal/work/buildid.go&lt;/span&gt;&lt;span&gt; 。Go Build ID 可以用以下命令来查看：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; tool buildid&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.anquanke.com/post/id/215419&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.9-go-tool-cgo&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以使我们创建能够调用C语言代码的Go语言源码文件。这使得我们可以使用Go语言代码去封装一些C语言的代码库，并提供给Go语言代码或项目使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261358&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令对单元测试过程中生成的代码覆盖率统计生成html文件，可以本地打开展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go test -coverprofile=a.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool cover -html=a.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt; -o coverage.html&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;覆盖度工具不仅可以记录分支是否被执行，还可以记录分支被执行了多少次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;go test -covermode=set|count|atomic:
-covermode：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;set: 默认模式，统计是否执行 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;count: 计数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;atomic: count的并发安全版本，仅当需要精确统计时使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过go tool cover -func=count.out查看每个函数的覆盖度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/xhdxhdxhd/article/details/120424848&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.11-go-tool-dist&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;dist工具是属于go的一个引导工具，它负责构建C程序（如Go&lt;/span&gt;&lt;span&gt;编译器&lt;/span&gt;&lt;span&gt;）和Go工具的初始引导副本。它也可以作为一个包罗万象用shell脚本替换以前完成的零工。通过“go tool dist”命令可以操作该工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool dist&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;usage: go tool dist [command]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Commands are:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;banner         print installation banner&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;bootstrap      rebuild everything&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;clean          deletes all built files&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;env [-p]       print environment (-p: include $PATH)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;install&lt;/span&gt; [dir]  &lt;span class=&quot;code-snippet__keyword&quot;&gt;install&lt;/span&gt; individual &lt;span class=&quot;code-snippet__keyword&quot;&gt;directory&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt; [-&lt;span class=&quot;code-snippet__keyword&quot;&gt;json&lt;/span&gt;]   &lt;span class=&quot;code-snippet__keyword&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;all&lt;/span&gt; supported platforms&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;test&lt;/span&gt; [-h]      run &lt;span class=&quot;code-snippet__keyword&quot;&gt;Go&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;test&lt;/span&gt;(s)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;version&lt;/span&gt;        print &lt;span class=&quot;code-snippet__keyword&quot;&gt;Go&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;version&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用go tool dist list可以输出当前安装Go版本所支持的操作系统与架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/byxiaoyuonly/article/details/112492264&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.12-go-tool-fix%E5%92%8Cgo-fix&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令会把指定代码包的所有Go语言源码文件中的旧版本代码修正为新版本的代码。这里所说的版本即Go语言的版本。代码包的所有Go语言源码文件不包括其子代码包（如果有的话）中的文件。修正操作包括把对旧程序调用的代码更换为对新程序调用的代码、把旧的语法更换为新的语法等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个工具其实非常有用。在编程语言的升级和演进的过程中，难免会对过时的和不够优秀的语法及标准库进行改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261355&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.13-go-tool-link&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令链接Go的归档文件比如静态库，以及链接其所有依赖，生成一个可执行文件（含main package）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool link [flags] main.a&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Flags:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -B note&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Add an ELF_NT_GNU_BUILD_ID note when using ELF.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        The value should &lt;span class=&quot;code-snippet__keyword&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;x &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; be an even &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;hex&lt;/span&gt; digits.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -D address&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;segment&lt;/span&gt; address.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -E entry&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; entry symbol name.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -H &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; executable &lt;span class=&quot;code-snippet__keyword&quot;&gt;format&lt;/span&gt; type.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        The &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; inferred &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; GOOS &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; GOARCH.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;On&lt;/span&gt; Windows, -H windowsgui writes a &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;GUI binary&quot;&lt;/span&gt; instead &lt;span class=&quot;code-snippet__keyword&quot;&gt;of&lt;/span&gt; a &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;console binary.&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -I interpreter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; the ELF dynamic linker &lt;span class=&quot;code-snippet__keyword&quot;&gt;to&lt;/span&gt; use.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -L dir1 -L dir2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Search&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; imported packages &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; dir1, dir2, etc,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;after&lt;/span&gt; consulting $GOROOT/pkg/$GOOS_$GOARCH.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -R quantum&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; address rounding quantum.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -T address&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;segment&lt;/span&gt; address.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -V&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Print linker &lt;span class=&quot;code-snippet__keyword&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; exit.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool compile -o calc.o -I pkg/linux_amd64 src/calc/calc.go&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool &lt;span class=&quot;code-snippet__keyword&quot;&gt;link&lt;/span&gt; -o &lt;span class=&quot;code-snippet__keyword&quot;&gt;bin&lt;/span&gt;/calc -L pkg/linux_amd64 calc.o&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://cache.baiducontent.com/&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.14-go-tool-nm&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以查看符号表的命令，等同于系统的nm命令，非常有用。在断点的时候，如果你不知道断点的函数符号，那么用这个命令查一下就知道了（命令处理的是二进制程序文件），第一列是地址，第二列是类型，第三列是符号。等同于nm命令。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://studygolang.com/articles/29906&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以反汇编二进制的工具，等同于系统objdump，命令解析的是二进制格式的程序文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool objdump example.o&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool objdump -s DoFunc example.o  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://studygolang.com/articles/29906&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.16-go-tool-pack&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令把二进制文件打包成静态库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool pack op file.a [name...]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;参数op&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c   &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt; files (from the file system) to a &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt; archive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    p   &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt; files from the archive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    r   &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt; files (from the file system) to the archive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    t   list files from the archive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    x   extract files from the archive&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool compile -o simplemath.o src/simplemath/add.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; src/simplemath/sqrt.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool pack c pkg/linux_amd64/simplemath.a simplemath.o&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://cache.baiducontent.com/&lt;/span&gt;&lt;/p&gt;&lt;h3 name=&quot;1.11.17-go-tool-test2json&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令用于把测试可执行文件转化可读的json格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt;  test string_concat_test.&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; -o string_concat.test&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tool test2json ./string_concat.test -test.v&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Action&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;output&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Output&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testing: warning: no tests to run\n&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Action&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;output&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Output&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;PASS\n&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Action&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pass&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.csdn.net/weixin_33772442/article/details/112098085&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该命令可以生成一个Go官方文档的本地http服务，可以在线查看标准库和第三方库文档，以及项目文档，但是需要按照一定的格式去写注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; -v  golang.org/x/tools/cmd/godoc&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;godoc -http=:&lt;span class=&quot;code-snippet__number&quot;&gt;6060&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;godoc -http=:&lt;span class=&quot;code-snippet__number&quot;&gt;6060&lt;/span&gt; -play&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http:&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Web页面如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1637931034482758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96fsTy9sN5GgRfjUtXDe4psYWfZfga5DVZhkK32IJhntU1XxIuRU0ibSZJ5gUiaJGQiaHEFsMwPxtWNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://www.fujieace.com/golang/godoc.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、第三方工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;14b2b77d9f8f14e8d1bd4f4aeed0ef194&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go工具和组件汇总项目：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/avelino/awesome-go&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.1%C2%A0delve&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 name=&quot;2.1%C2%A0delve&quot;&gt;&lt;span&gt;（一）delve&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地代码调试工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/go-delve/delve&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.2-goconvey&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.2-goconvey&quot;&gt;&lt;span&gt;（二）goconvey&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;goconvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多Web界面特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/smartystreets/goconvey&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.3-goleak&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.3-goleak&quot;&gt;&lt;span&gt;（三）goleak&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本地排查内存泄露的工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/uber-go/goleak&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.4-go-wrk&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.4-go-wrk&quot;&gt;&lt;span&gt;（四）go-wrk&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go接口压测工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/adjust/go-wrk&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.5%C2%A0golint&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.5%C2%A0golint&quot;&gt;&lt;span&gt;（五）golint&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码风格检查&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/golang/lint&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.6-revive&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.6-revive&quot;&gt;&lt;span&gt;（六）revive&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码风格检查，比golint速度更快&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/mgechev/revive&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.7-gocode&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.7-gocode&quot;&gt;&lt;span&gt;（七）gocode&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码自动补全工具，可以在vim中使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/nsf/gocode&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.8-godoctor&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.8-godoctor&quot;&gt;&lt;span&gt;（八）godoctor&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;代码重构工具&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/godoctor/godoctor&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.9-gops&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.9-gops&quot;&gt;&lt;span&gt;（九）gops&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;查看go进程和相关信息的工具，用于诊断线上服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/google/gops&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.10-goreplay&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.10-goreplay&quot;&gt;&lt;span&gt;（十）goreplay&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GoReplay是一个开源网络监控工具，可以将实时HTTP流量捕获并重放到测试环境。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/b&lt;/span&gt;&lt;span&gt;uger/goreplay&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://blog.51cto.com/axzxs/5102596&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.11-depth&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.11-depth&quot;&gt;&lt;span&gt;（十一）depth&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个有用的Golang工具，Depth可帮助Web开发人员检索和可视化Go源代码依赖关系树。它可以用作独立的命令行应用程序或作为项目中的特定包。你可以通过在解析之前在Tree上设置相应的标志来添加自定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/KyleBanks/depth&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.12-go-swagger&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.12-go-swagger&quot;&gt;&lt;span&gt;（十二）go-swagger&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具包包括各种功能和功能。Go-Swagger是Swagger 2.0的一个实现，可以序列化和反序列化swagger规范。它是RESTful API简约但强大的代表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过Go-Swagger，你可以swagger规范文档，验证JSON模式以及其他额外的规则。其他功能包括代码生成，基于swagger规范的API生成，基于代码的规范文档生成，扩展了的字符串格式，等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/go-swagger/go-swagger&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.13-gox&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.13-gox&quot;&gt;&lt;span&gt;（十三）gox&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;交叉编译工具，可以并行编译多个平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/mitchellh/gox&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.14-gocyclo&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.14-gocyclo&quot;&gt;&lt;span&gt;（十四）gocyclo&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gocyclo用来检查函数的复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gocyclo -over 20 &lt;span class=&quot;code-snippet__variable&quot;&gt;$(ls -d */ | grep -v vendor)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gocyclo -top 5 &lt;span class=&quot;code-snippet__variable&quot;&gt;$(ls -d */ | grep -v vendor)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/fzipp/gocyclo&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.15-deadcode&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.15-deadcode&quot;&gt;&lt;span&gt;（十五）deadcode&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;deadcode会告诉你哪些代码片段根本没用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;find . -&lt;span class=&quot;code-snippet__built_in&quot;&gt;type&lt;/span&gt; d -not -path &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;./vendor/*&quot;&lt;/span&gt; | xargs deadcode&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/tsenart/deadcode&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.16-gotype&quot;&gt;&lt;span&gt;（十六）gotype&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gotype会对go文件和包进行语义(semantic)和句法(syntactic)的分析，这是google提供的一个工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;find . -name &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;*.go&quot;&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; -path &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;./vendor/*&quot;&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;not&lt;/span&gt; -path &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.git/*&quot;&lt;/span&gt; -&lt;span class=&quot;code-snippet__keyword&quot;&gt;print&lt;/span&gt; | xargs gotype -a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://golang.org/x/tools/cmd/gotype&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.17-misspell&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.17-misspell&quot;&gt;&lt;span&gt;（十七）misspell&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;misspell用来拼写检查，对国内英语不太熟练的同学很有帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;find . -&lt;span class=&quot;code-snippet__built_in&quot;&gt;type&lt;/span&gt; f -not -path &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;./vendor/*&quot;&lt;/span&gt; -&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt; | xargs misspell&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/client9/misspell&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.18-staticcheck&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.18-staticcheck&quot;&gt;&lt;span&gt;（十八）staticcheck&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;staticcheck是一个超牛的工具，提供了巨多的静态检查，就像C#生态圈的 ReSharper一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; install honnef.co/go/tools/cmd/staticcheck&lt;span class=&quot;code-snippet__variable&quot;&gt;@latest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;staticcheck main.go&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://staticcheck.io/docs/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/dominikh/go-tools/tree/master/staticcheck&lt;/span&gt;&lt;/p&gt;&lt;h2 name=&quot;2.19-goconst&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;2.19-goconst&quot;&gt;&lt;span&gt;（十九）goconst&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;goconst会查找重复的字符串，这些字符串可以抽取成常量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;goconst&lt;/span&gt; ./… | grep -v vendor&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;span&gt;https://github.com/jgautheron/goconst&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.Go命令教程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://www.kancloud.cn/cattong/go_command_tutorial/261351&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.Golang指南：顶级Golang框架、IDE和工具列表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/30432648&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.Go代码检修工具集：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://t.zoukankan.com/binHome-p-14149941.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.0203703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96fsTy9sN5GgRfjUtXDe4ps6aC9U3h59OhcUP0hqBuCZ4PhqIiaDZRicNibEGn4JDTibd2X7BicUlpLQAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;罗元国&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，目前负责腾讯游戏广告推荐后台开发工作，在广告推荐和Golang性能优化方面有着丰富的开发经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247540886&amp;amp;idx=1&amp;amp;sn=746c125a4ae9594bb2c3b644aea9aa31&amp;amp;chksm=eaa83ac6dddfb3d074f19cbe4a71b075c7b82b0db336807b07bd9a875bc612de2891f466d61f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入浅出详解Knative云函数框架！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;深入浅出详解Knative云函数框架！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247540844&amp;amp;idx=1&amp;amp;sn=b272d55cc42244d153effddb480b2da4&amp;amp;chksm=eaa83a3cdddfb32ad8db3b3bb0fe8788c169558ebe7cd99347adb3d21cfdee0101d3b566e866&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;通俗易懂！图解Go协程原理及实战&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;通俗易懂！图解Go协程原理及实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247540772&amp;amp;idx=1&amp;amp;sn=c6ad00aa56e32e7a6add58dbdb39aabb&amp;amp;chksm=eaa83a74dddfb3627fd52fe232f7791438e9f51da54ffb1005dacb8f9d4246e592783a27a77a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;C++一行代码实现任意系统函数Hook！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;C++一行代码实现任意系统函数Hook！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247540722&amp;amp;idx=1&amp;amp;sn=ed4cf40c83db06fe1a825e1fd065bcc1&amp;amp;chksm=eaa845a2dddfccb4efc0701479809f63391bcb36ca91fdce68e81821e1d66c35c7f1f6597684&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入理解Linux的TCP三次握手！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;深入理解Linux的TCP三次握手！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96micRsO2DNDzVua8lLc5HcxgPibg1fTn5dOSNLfJpMMxbVkhOovibR4JDKdTxELmGYujyLV7308B9icg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯云开发者&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95dHSibxPPK8ic8RtyVFEXs36jmqZibzTicu5q58duJXI8k6DRJWCSrkuz4pz3867nibLLzJY3qKicHScJg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;温馨提示&lt;/span&gt;&lt;span&gt;&lt;span&gt;：因公众号平台更改了推送规则，公众号推送的文章文末需要点一下&lt;/span&gt;&lt;span&gt;“赞”&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;“在看”&lt;/span&gt;&lt;span&gt;，新的文章才会第一时间出现在你的订阅列表里噢~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e0216e79de3f0f2cf0f9075fc25ffc2f</guid>
<title>京东科技埋点数据治理和平台建设实践</title>
<link>https://toutiao.io/k/o7etxta</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;h1&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;h1&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005331&quot; data-ratio=&quot;0.6506849315068494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1UibHPAanTaZmNVW2yn5bYF7O5pGDH1QmUNa2XCUichFvjlOqV5sfnlHaKRALYlrlRCpZygon1I3PIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;146&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Tech     &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section&gt;&lt;span&gt;本文核心内容聚焦为什么要埋点治理、埋点治理的方法论和实践、奇点一站式埋点管理平台的建设和创新功能。读者可以从全局角度深入了解埋点、埋点治理的整体思路和实践方法，落地的埋点工具和创新功能都有较高的实用参考价值。遵循埋点治理的方法论，本文作者团队已在实践中取得优异成效，在同行业内有突出的创新功能，未来也将继续建设数智化经营能力，持续打造更好的服务。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;263:265&quot;&gt;&lt;strong&gt;&lt;span&gt;埋点治理背景&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在今年的敏捷团队建设中，我通过Suite执行器实现了一键自动化单元测试。Juint除了Suite执行器还有哪些执行器呢？由此我的Runner探索之旅开始了！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZib1LrmajMrqrAia2JCPUpf8MJ8tLn4Tz1VeGAzwCrbhBcVxfj80914vRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 &lt;strong&gt;埋点数据的价值&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;随着线上流量红利高峰逐渐达到瓶颈，在精细化运营、数智化运营的大背景下，越来越多的公司开始认识到数据的重要性，并将其打造成为公司的核心资产，以数据为中心驱动业务发展。而&lt;strong&gt;埋点数据&lt;/strong&gt;作为企业内部最重要的两大来源（埋点数据、业务数据）之一，其重要性不言而喻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点是一种常用的数据采集方法。基于业务需求或产品需求，在应用页面中植入数据采集代码，监听用户各种行为事件（页面浏览、关闭，元素曝光、点击等），然后将采集的数据上报至服务端，服务端分别下发到大数据平台和搜索、推荐等各业务系统。通过分析数据，追踪用户行为和应用使用情况，推动产品优化或指导运营；通过实时的获取用户点击、浏览、停留等行为作为关键特征提供给搜索、推荐、广告等系统，来提升智能分发的转化和用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点数据上能影响业务运营数据分析、智能推荐、AB实验的准确性，下能影响数据仓库结构设计和数据采集团队的维护成本。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 &lt;strong&gt;业内主流埋点方式的对比&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从技术层面上，埋点分为代码埋点、可视化埋点、无埋点/全埋点。目前国内主要的第三方数据分析服务商和大型公司内部普遍支持。代码埋点又衍生出了声明式埋点、无痕埋点、服务端埋点等丰富的埋点方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过多种埋点方式组合，可以在不同场景业务中灵活使用。比如在页面中元素或页面事件使用前端代码埋点；在Debug链路长的搜推代码中使用服务端埋点；产品运营等非研发使用可视化埋点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3864628820960699&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibZH8HuNFrjPTj60aBdPnG9Fuiag9DBt00N9noTz1oibRmJTPzic3IP4VeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3 &lt;strong&gt;为什么要治理埋点数据&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然而随着业务的迭代变更，部分埋点数据失去效用。为了确保数据的质量、效率、安全、标准及易用性，需要对埋点数据进行治理。不仅是存量数据的治理，新增数据更是要保证从源头开始就是正确的。在埋点数据的生命周期内，每个环节制定原则性的管理方法和具体的落地措施。一个稳定的治理链路是埋点治理的基石。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;从平台视角来看，埋点治理要解决的问题如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4915254237288136&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibLPVibeFNGqGOnn7BfA2Pf0724XzKtqicEKozupAdL8LSrpA0ZmCnRfdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;质量问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;最重要，大部分公司的数据部门启动数据治理的起因就是数据质量存在问题。例如数仓的及时性、准确性、规范性，以及数据应用指标的逻辑一致性等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;成本问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;互联网行业数据膨胀速度非常快，大型互联网公司在大数据基础设施上的成本投入占比非常高，而且随着数据量的增加，成本也将继续攀升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;效率问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在数据开发和数据管理过程中都会遇到一些影响效率的问题，多是靠“盲目”地推人力在做。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;安全问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;业务部门特别关注用户数据，一旦泄露，对业务的影响非常之大，甚至能左右整个业务的生死。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;标准问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;当公司业务部门比较多的时候，各业务部门、开发团队的数据标准不一致，数据打通和整合过程中存在很多问题。&lt;/span&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;从业务视角来看，埋点治理要解决的问题如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4861111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RQv8vncPm1WCYjeduyLhU4icBM97npPZibm8bqymfEqnicPQSgPrBD8qd2iaPJyqqJ799NtzMYI8w5cvnCRGZYq9lQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;埋点数据“全”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 因整体协助链条非常长，许多时候在需要做数据分析时，才发现页面有部分功能漏报埋点，产品需求未涉及等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;埋点数据“准”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;需求开发测试阶段，往往重点关注业务逻辑，对于埋点上报这些辅助异步流程，设计评估不准确。会存在因验证不充分而导致数据不准确的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;埋点数据“快”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 推荐算法主要依赖数据驱动，埋点数据需要及时上报并反馈，推荐等智能应用系统才能根据用户当前行为给出精准的策略决策。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;埋点数据“统一”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;智能场景往往要通过多个业务线交叉数据作为输入特征或算法画像，每个业务线如没有统一标准规范，数据处理计算逻辑复杂且迭代维护成本很高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;埋点数据“链路长”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;埋点数据从生产到使用，涉及运营、产品、研发、测试、数据分析师或算法工程师多个环节（如下图），问题沟通排查链路长。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;strong&gt;&lt;span&gt;埋点数据“历史长”：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;页面埋点随需求迭代更新较快，历史埋点设计文档缺少统一管理，不利于长期维护。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;&lt;strong&gt;  埋点治理实践 &lt;/strong&gt;&lt;/span&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目标页面展示到屏幕&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为解决上述问题，几经探索总结经验后，本文作者团队为埋点治理制定了全面的标准制度。遵循相应的制度，使得埋点治理工作有序有效开展。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibHyZCcbf8S4D2TB2nGZnew37xMe8QsaVl8xbh0OhRyIKXtianhkSW6jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 &lt;strong&gt;制定全链路标准&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者团队制定了一套覆盖数据生产到使用，全链路的数据标准方法，从埋点数据定义、采集、验证、指标定义到数据生命周期管理都建立了相应环节的标准化的研发规范，发布了《埋点流程规范标准》。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibDUC86RMtvSCeCkfq60VP4Pr0MhMOXm7OY462yQ13t77Bv6wicEg0FSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 &lt;strong&gt;&lt;span&gt;制定埋点流程规范&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;作者团队制定了完整的埋点上报规范规程，并邮件通知各部门产研按流程，照规范上报数据。上报流程为埋点方案设计、埋点方案配置、埋点开发/测试、数据存储/服务、数据应用五个环节，每个环节都要通过必要的步骤才可继续向下执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5359628770301624&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibWHOwbzvVVaic3eU5Z0B7KiaAosUNKXANXKiaGPxGuzmd4casTeH9tp90A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3 &lt;strong&gt;&lt;span&gt;建设一站式埋点管理平台&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;奇点埋点管理平台是科技内部统一的埋点平台，覆盖埋点数据定义、采集、生产、验证、基础指标应用、数据质量监控治理等埋点全生命周期。做到了埋点元数据统一管理，埋点信息查询简易化、埋点上报验证一键化、埋点数据质量追踪可视化。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.4 &lt;strong&gt;&lt;span&gt;成立组织保执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过和数据技术产品部门合作，在两个部门领导的支持下，作者团队成立了埋点治理盘古项目及埋点数据管理委员会。平台研发部团队是采集埋点数据工具的产研方，数据仓库体系是由数据技术部负责建设，所以以这两个团队作为核心，并由这两个团队负责联合各个业务线团队，一起完成数据治理各个环节工作和流程的保障。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;奇点团队作为埋点数据采集和管理的主力，负责数据采集SDK，数据上报、清洗、存储、查询，埋点管理平台等。&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.5 &lt;strong&gt;&lt;span&gt;宣导埋点和数据文化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;过去由于数据文化的缺失，很多业务方意识不到规范埋点的重要性。未正确录入页面埋点信息、使用低版本采集SDK，造成了大量不符合标准的数据。组织培训会和埋点规范宣讲，推动数据合理规范上报，也是埋点治理的重点工作之一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;&lt;strong&gt;  埋点治理阶段性成果 &lt;/strong&gt;&lt;/span&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;理解，首先 MCube 会依据模板缓存状态判断是否需要网络获取最新模板，当获取到模板后进行模板加载，加载阶段会将产物转换为视图树的结构，转换完成后将通过表达式引擎解析表达式并取得正确的值，通过事件解析引擎解析用户自定义事件并完成事件的绑定，完成解析赋值以及事件绑定后进行视图的渲染，最终将目标页面展示到屏幕。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者团队提供的数据采集服务范围除了京东科技下金融科技、京东云、数字城市等全部业务线外，还扩展到了京东物流等兄弟部门。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;奇点针对金融业务深耕多年，对数据的安全性、稳定性、实时性有多种保障方案，已是业务运营过程中不可或缺的重要环节。奇点管理平台现已实现埋点管理、数据分析一体化。在埋点数据上报查询、数据监控、数据计算可视化展示等各个环节都有相应的管理工具。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1 &lt;strong&gt;&lt;span&gt;埋点验证工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;过去验证上报数据是否准确，需要测试人员申请数据库表权限，然后手写SQL查询数据。为此作者团队做了埋点验证工具，既可以扫码查看本机实时数据、查看所有上报实时数据，也可以一键检测上报数据是否符合规范。该工具为测试人员节省了大量时间，也为埋点治理，推动用户规范录入起了辅助作用。奇点服务端使用Lua脚本并发处理，而不是传统的Web服务，处理请求速度更快，减少了服务器资源使用。实时数据存放在ES中，相比MYSQL数据库能容纳更多的数据量，查询速度更快。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.63984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibQsv4Hqx8zDicFvjxW4iciaic8dw0dGHsFKic6icZicL1Z37PiastQzC3lRquOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2 &lt;strong&gt;&lt;span&gt;埋点验证工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;作者团队在客户端数据上报、服务端数据转换、数据发送、落仓等每步都加入了监控，保证整条链路数据质量。监控定时检查计算数据上报的成功率、缓存率、丢失率，数据加工清洗后的留存率、落仓率等，一旦数据浮动超过设定的阈值，会自动发告警邮件给奇点研发人员。有了数据监控，能及时发现、高效处理数据量问题，降低数据损失，节省人力，极大提升了数据质量。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibejn2cphglqdovlMicVkFGiagtYDKuXiaib4y5iccqfC5A5hibjff8afPwzlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3 &lt;strong&gt;&lt;span&gt;实时数据一站式看板&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;过去作者团队只关注埋点范围的研发业务，平台升级后，用户录入埋点信息后可通过看板即时查看PV、UV、点击率等指标实时数据。对于用户来说，省去了从各种库表取数分析的步骤；对于埋点治理来说，不但降本增效，推动用户规范录入页面信息，而且指标计算结果比各个业务方自己分析更加准确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.50234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibpMqz2JHxicb5aatRcRsDkAf3aFlprqCsO1clrAKMc7bfOBw7WjdoMIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;263:265&quot;&gt;&lt;span&gt;&lt;strong&gt;奇点埋点对比行业创新功能&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 &lt;strong&gt;埋点可视化展示&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;查看某个页面的埋点信息，通常采用分页列表的方式，详细数据要跳转到看板浏览。这种方式虽然罗列出了页面所有埋点，但是每个埋点的录入人不同，埋点多了之后具体每个埋点表示什么含义其他人并不清楚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为此作者团队研发了埋点可视化工具，完美解决了上述问题。只要输入页面URL，选择合适的设备大小，页面哪些元素有埋点就呈现出来。每个坑位的埋点ID，点击曝光的数据只要点击一下浮框即可见。埋点可视化工具还支持查看实时上报的日志和汇总的实时数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.650390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibqRrqSUomf9Fo2ia8vd099dWXLwvCAyJXyibXGdk0fLnkeQcC1ZPgoFjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;埋点可视化展示通过数据采集脚本-奇点 JS SDK 自动加载可视化插件实现，使用postMessage 和addEventListener(&#x27;message&#x27;)，实现埋点可视化工具和所查看页面的数据双向发送与接收，从而实时展示埋点数据和埋点日志。为减少加载SDK的页面开销，作者团队做了优化处理，只有在可视化工具中打开页面才会加载该插件。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2 &lt;strong&gt;H5与原生App全链路数据打通&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;类似京东金融这样使用Native和WEB技术开发的混合应用，之前H5页面和原生页面的数据，使用了不同的SDK采集，用户在两端页面间跳转，数据是断裂的，只能分开统计，不能从整体上统计分析用户行为。采用归因统计的方法能关联部分两端的数据，但会导致数据统计不准确，不但增加数据分析人力、物力成本，不可靠的数据还会使运营无法精准投放广告，从而影响最终收益；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如今奇点团队实现了H5页面和原生页面数据打通，包括以下打通点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;访次打通: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;访次是指用户在当前设备中累计访问次数，在京东金融 App 中，用户每次重新打开或者切后台超过 2 分钟后，访问的次数就会加1。可以根据访次来统计用户活跃度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;访序打通: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;访序是指用户在当前访次内，页面的访问顺序，H5和原生页面打通后，页面的访序是连续的，可以更精准的查看用户访问页面路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;来源埋点: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;来源埋点是指上一个页面用户点击点最后一个埋点ID。根据来源埋点，可以精准定位上一个页面触发点。数据打通后，可以确定当前页面的热点来源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;首访埋点: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首访埋点是指用户打开App时首次点击的坑位埋点，根据首访埋点可以定位到进入某一 H5 或原生页面起始点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;上一个页面 URL 或原生页面 CTP: &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;为了精准分析用户行为轨迹，奇点会采集上一个页面 URL 或原生页面CTP，数据打通后，会形成闭环，即使是后退操作也会记录后退的前一个页面，从而可以更好的进行路径分析、页面可达分析、用户丢失率分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;其他采集字段打通:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 为了统一口径，统一指标，打通的字段还包含以下字段：设备 ID、手机品牌、手机型号、App 名称、App 版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;两端打通前：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.44148936170212766&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibkpgJ0bJ9RahCS8icwFRjWFUxQxzqnQpvxFBN1h31PH0B7hTQdjXluHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;564&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;两端打通后：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42857142857142855&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibyv9n7xfvymmyg20ZPDIyQySia2cGicKWdDIia9xxKgxF4snYQZMhxAHKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据打通的收益是巨大的，下面是一个实际使用案例-小金库页面流量来源归因分析：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1WCYjeduyLhU4icBM97npPZibTahCOBUrtqwpMHzbkicumsqqJl3LVztZadJGQlXj3OgXQrMLzG58F5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94065&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3 &lt;strong&gt;页面ID自动匹配上报&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-width=&quot;90%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;过去统计PV时，根据访问页面的URL作为唯一标识，这个URL需要在奇点管理平台录入后方可进行计算。然而这种方式存在很大的缺陷。当遇到以下场景，根据哪个URL来计算，边界并不清晰。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;URL中带参数，例如/path1/path2?param=value。不同参数可能代表同一个页面，也可能是不同的页面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;动态路由，例如/path1/path2/:path3/，某个path是动态的，如果这个path是数字ID，是无法在奇点管理平台全部录入的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Hash路由，例如/path1/path2/#/route1 / route2。如今前端单页面盛行，不同业务方做出的网站大相径庭，hash值不同，有的希望统计成一个页面，也有想统计成不同的页面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;以上场景混合的情况。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;针对此问题，作者团队提出了使用pageId代替URL的方案。即业务方在奇点管理平台录入时指定URL的哪部分是动态的还是固定的，并生成唯一页面的ID。在访问页面时，当前页面的链接与录入的动态规则做计算，找到最匹配的pageId后上报数据，最终使用pageId做数据统计，极大的提高了指标计算正确率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为保证此方案的稳健性，作者团队也做了很多细节把控。比如为防止拉取CDN pageId JSON文件失败，增加了重试机制，在未获取到文件时先将上报数据缓存在本地。比如没有匹配成功的URL另做打标处理。还有监控站点更新页面，同步生成最新的配置关系等等。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;section data-id=&quot;98782&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;263:265&quot;&gt;&lt;span&gt;&lt;strong&gt;未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h1&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在埋点数据治理方向，奇点团队联合数据团队通过一系列方案实现自动化治理埋点数据。例如对不规范数据打标，使数据不进入数据分析模型层；各端统一使用页面唯一ID的上报方式；不规范录入信息的页面自动认领到页面站点下；向未录入页面的用户定向推送邮件等方式持续提升数据质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在平台能力建设方向，首先从精细化运营角度还要持续建设可视化埋点及与页面活动搭建平台打通提供组件化埋点能力，提升埋点开发效率。其次从埋点生命周期管理角度，奇点平台提供的埋点设计管理、代码扫描、埋点验证、埋点指标看板一系列工具要更好流程化整合，提升产、运、研等各方的协同效率。最后从智能化建设角度，对于流量数据看板增加智能分析、智能预测能力，提升数据应用效率。通过埋点数据作为基石，赋能业务场景，更好地服务支撑公司整体的数智化经营能力建设。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93679&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100005308&quot; data-ratio=&quot;0.47058823529411764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1UibHPAanTaZmNVW2yn5bYF7rUiaXg1tNeElo6pVnvsQhGsVMSiaLn7bT6icNKw0caXsV9icVXUbRQ3S7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&amp;amp;mid=2247489919&amp;amp;idx=1&amp;amp;sn=3020ede8ac0ee055411cee331b8ccd78&amp;amp;chksm=fbf7a990cc802086be275e08409c50a4810706548d9fec3eb07788cf8e4f972625bb9cc8e37a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于SPI的增强式插件框架设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;基于SPI的增强式插件框架设计&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&amp;amp;mid=2247489842&amp;amp;idx=1&amp;amp;sn=2e0676d3da4fa8ea57875db333650c33&amp;amp;chksm=fbf7a9ddcc8020cbbac60b571d91abcf3847b055e74d71cac1e930895b8351e879f7ac5af3d8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;京东618广告精排百分位AUC提升技术方案&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;京东618广告精排百分位AUC提升技术方案&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&amp;amp;mid=2247489741&amp;amp;idx=1&amp;amp;sn=9994976546624dc71a539d57bcc2f3ed&amp;amp;chksm=fbf7a822cc802134765803089c534618ed515227365cf60a24ac03fb149b1ffc0280a2dc557c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;智能测试实践之路 - UI缺陷检测&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;智能测试实践之路 - UI缺陷检测&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1MzE2NzIzMg==&amp;amp;mid=2247489641&amp;amp;idx=1&amp;amp;sn=30f35b924407fcf4d6a14cbe28d3044a&amp;amp;chksm=fbf7a886cc80219088d482edbce62bb04dc67c64ab9d97bf7614d5c6004f1187292cf9570e90&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;电商库存系统的防超卖和高并发扣减方案&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;电商库存系统的防超卖和高并发扣减方案&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1MzE2NzIzMg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/RQv8vncPm1VGqxZI7ZQ51iar80MR0dNLrq51xias5Br3C9Hia2LFA0gCks5T6gMnXibHOKaoaUiasT0LTvBrwrSEC7w/0?wx_fmt=png&quot; data-nickname=&quot;京东技术&quot; data-alias=&quot;jingdongjishu&quot; data-signature=&quot;京东官方技术公众号，你想知道的京东技术前沿黑科技，全在这里。&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8808777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/RQv8vncPm1WCYjeduyLhU4icBM97npPZibu4PQ0QlneyVL3X9bmSf5PN96KcsrWicUMc4Ic2CgF2TyBujTBW0b4NQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;求分享&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8808777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/RQv8vncPm1WCYjeduyLhU4icBM97npPZibu4PQ0QlneyVL3X9bmSf5PN96KcsrWicUMc4Ic2CgF2TyBujTBW0b4NQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;求点赞&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8808777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/RQv8vncPm1WCYjeduyLhU4icBM97npPZibu4PQ0QlneyVL3X9bmSf5PN96KcsrWicUMc4Ic2CgF2TyBujTBW0b4NQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;求在看&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>804acd152fa17faeb31dee0702c9dd8c</guid>
<title>分布式消息队列平滑迁移技术实战</title>
<link>https://toutiao.io/k/0chge2h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：vivo 互联网中间件团队- Liu Runyun&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;大量业务使用消息中间件进行系统间的解耦、异步化、削峰填谷设计实现。公司内部前期基于RabbitMQ实现了一套高可用的消息中间件平台。随着业务的持续增长，消息体量随之增大，对消息中间件平台提出了更高的要求，此外在运维过程中也遇到了高可用难以保障，功能特性不足等诸多问题。基于遇到的这些问题，决定引入RocketMQ进行替换。本文将介绍基于RocketMQ建设消息中间件平台并实现在线业务无感知的平滑迁移。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景说明&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo互联网中间件团队于2016年开始基于开源RabbitMQ向业务提供高可用消息中间件平台服务。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;为解决好业务流量快速增长的问题，我们通过合理的业务集群拆分和动态调整，&lt;strong&gt;较好的交付了&lt;/strong&gt;业务对消息中间件平台的&lt;strong&gt;平台能力需求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;但是随着业务长周期的迅猛发展，消息体量也越来越大，在高并发、大流量场景下RabbitMQ的系统架构设计存在着一定的限制，主要有以下问题：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.1 高可用能力不足&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;架构设计存在脑裂风险，并且默认脑裂后无法自动恢复，人工介入恢复存在数据丢失的风险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为解决脑裂问题，可以选择将网络异常后的处理调整为pause_minority模式，但是也带来了可能微小的网络抖动也会导致集群故障无法恢复的问题。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.2. 性能不足&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;业务消息发送后通过exchange路由到对应的queue中，每一个queue由集群中的某个节点实际承载流量，高流量下集群中的某个节点可能会成为瓶颈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;queue由某个节点承载流量后无法快速迁移，强制迁移到其它低负载节点可能会导致queue不可用，这也导致了向集群中添加节点并无法快速提升集群的流量承载能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;集群性能较低，经测试使用三台机器组成集群，可承载大概数万tps左右，并且由于queue是由集群中某个节点实际承载的，也无法继续提升某个queue的性能，这样就无法支撑大流量业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息堆积到千万或更多后会导致集群性能下降，甚至海量堆积后如果消费请求tps特别高，可能会因为磁盘的性能损耗导致发送性能下降，并且在消息堆积太多时恢复时间长甚至无法恢复。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.3 功能特性不足&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;RabbitMQ 默认情况下消费异常会执行立即重新投递，少量的异常消息也可能导致业务无法消费后续消息。&lt;/p&gt;&lt;p&gt;功能特性上未支持事务消息、顺序消息功能。&lt;/p&gt;&lt;p&gt;虽可自行实现消息轨迹逻辑，但是会对集群产生非常大的性能损耗，在正式环境中实际无法基于RabbitMQ原生的能力实现消息轨迹功能。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、消息中间件平台的项目目标&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;基于以上问题，中间件团队于2020年Q4开始进行了下一代消息中间件平台方案的调研，为保证下一代消息中间件平台符合业务新的需求，我们首先明确了消息中间件平台的建设目标，主要包含两部分：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1 业务需求分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;高性能：&lt;/strong&gt;可支撑极高的tps，并且支持水平扩展，可快速满足业务的流量增长需求，消息中间件不应成为业务请求链路性能提升的瓶颈点。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;高可用：&lt;/strong&gt;极高的平台可用性(&amp;gt;99.99%)，极高的数据可靠性(&amp;gt;99.99999999%)。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;丰富的功能特性：&lt;/strong&gt;支持集群、广播消费；支持事务消息、顺序消息、延时消息、死信消息；支持消息轨迹。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 平台运维需求分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、开源组件选型调研&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于当前RabbitMQ平台的问题和对下一代消息中间件平台的项目需求，我们开展了针对当前较流行的两款消息中间件：RocketMQ、Pulsar的调研。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;调研过程中主要针对以下两方面进行对比：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 高可用能力分析对比&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 3.1.1 高可用架构与负载均衡能力对比&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.65&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhrEWzb92oAAdH10R9jUoCoibWUrk4Q71TRKbbMMjcoKPicA0OVG7ZqOFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt; Pulsar部署架构（来源：&lt;/span&gt;Pulsar社区&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.44375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlh8dO9BTzhdsGE95XmicfPBTWzVdOmxFjsuKeW7tHW8FE0ONPSKQJ5Yaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;RocketMQ部署架构（来源：&lt;/span&gt;RocketMQ社区&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;采用计算与存储分离架构设计，可以实现海量数据存储，并且支持冷热数据分离存储。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于ZK和Manager节点控制Broker的故障切换以实现高可用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;BooKeeper采用分层分片存储设计，天然支持负载均衡。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;RocketMQ：&lt;/p&gt;&lt;svg viewbox=&quot;0 0 1 1&quot; powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 3.1.2 扩缩容与故障恢复对比&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Broker与BooKeeper独立扩缩容，并且扩缩容后会完成自动负载均衡。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Broker节点无状态，故障后承载Topic会自动转移到其它Broker节点，完成故障秒级恢复。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;BooKeeper由自动恢复服务进行ledger数据对齐，并恢复到设置的QW份。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;故障期间已ack消息不会丢失，未ack消息需要客户端重发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Broker扩缩容后需要人工介入完成Topic流量均衡，可开发自动负载均衡组件结合Topic的读写权限控制自动化完成扩缩容后的负载均衡。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于主从切换实现高可用，由于客户端定期30秒从NameSrv更新路由，因此故障恢复时间在30~60秒，可以结合客户端降级策略让客户端主动剔除异常Broker节点，实现更快故障恢复。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用同步复制异步刷盘部署架构，在极端情况下会造成少量消息丢失，采用同步复制同步刷盘，已写入消息不会丢失。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 3.1.3 性能对比&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;Pulsar&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;RocketMQ&lt;/strong&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 功能特性对比&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6466753585397653&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhPvlASqRzZGeBgHtutyW96VKHOcQbXYoSfWfaLzwF6XR0W7b2AYuZicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3  总结&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;从高可用架构分析，Pulsar基于Bookeeper组件实现了架构的计算与存储分离，可以实现故障的快速恢复；RocketMQ采用了主从复制的架构，故障恢复依赖主从切换。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;从功能特性分析，Pulsar支持了丰富的过期策略，支持了消息去重，可以支持实时计算中消息只消费一次的语义；RocketMQ在事务消息、消息轨迹、消费模式等特性对在线业务有更好的支持。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;从这两方面对比，最终选择了&lt;strong&gt;RocketMQ构建我们下一代的消息中间件平台&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、平滑迁移建设&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过技术调研，确定了基于RocketMQ建设下一代消息中间件平台。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;为了实现业务从RabbitMQ平滑迁移到RocketMQ，就&lt;strong&gt;需要建设消息网关实现消息从AMQP协议转换到RocketMQ&lt;/strong&gt;；RabbitMQ与RocketMQ的元数据语义与存储存在差异，需要实现元数据语义的映射与元数据的独立存储。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;主要有以下四个事项需要完成：&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.1 消息网关独立部署与嵌入式部署差异对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.323943661971831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhKKXticOxRV5FK1RcUpLLXYztGzemoT0IZZpGQN4lJgx03Tfxrpdic1aA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.2 元数据定义映射与维护&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5760869565217391&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhibxW2g7ZdVzp1wqntS3jzaGxZua7NicvG7NvQbXXvTxHV01ygz8I8PQA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.3 互不干扰的高性能消息推送&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;RabbitMQ采用推模式进行消息消费，虽然RocketMQ也支持消息推送消费，但是因为AMQP协议中通过prefetch参数限制了客户端缓存消息数量以保证不会因缓存太多消息导致客户端内存异常，因此在消息网关实现消息推送时也需要满足AMQP协议的语义。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;同时每个消息网关都需要数千甚至数万的queue的消息推送，每个queue消息消费速率存在差异，并且每个队列可能随时有消息需要推送到客户端进行消费，要保证不同queue之间的推送互不干扰且及时。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;为了实现高效的、互不干扰的消息推送，有以下策略：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;每个queue采用独立的线程，保证互不干扰和时效性，缺点是无法支撑海量queue的消息推送。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于信号量、阻塞队列等，在感知到有可推送消息和可消费服务端时按需进行消息的推送，这样可使用少量的线程即可完成高效的消息推送。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;最终选择了第2种方案，数据流转图如下图所示：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5170454545454546&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhXiae8Brz9YiboncX9vFb6tYVWaNVnpvAGTm6OWb0xtseNbcR6JfH8lvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一个消息消费过程：客户端在启动连接到消息网关后，在消息网关中会构建RocketMQ推送消费客户端实例，并且注入自定义的ConsumeMessageService实例，同时使用一个信号量保存客户端允许推送的消息数量。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;当消息从集群侧推送到消息网关时，将消息按照推送的批次封装为一个任务保存在ConsumeMessageService实例的BlockingQueue中，同时推送线程会轮询所有的ConsumeMessageService实例，如果发现本地缓存有待消费的消息并且有可消费消息的业务客户端，将任务提交到线程池中完成消息的推送。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;为了保证不会因为少量消费速率特别高的queue导致其它queue的消息推送时效性降低，会限制每一个ConsumeMessageService只允许推送一定数量的消息即转到推送其它queue的消息，以此即可保证所有queue的消息推送的互不干扰和时效性。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;在客户端消费ack/uack后再次通过信号量通知下一次推送，这样也保证了使用少量的线程资源即可完成海量消息的推送需求。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.4 消费启停与消费限流能力实现&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于消息网关，可以在消息推送逻辑中增加消费启停和消费限流逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消费启停可以帮助业务快速实现消费的暂停或是部分异常节点停止消息消费。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消费限流可以帮助业务控制消息消费速率，避免对底层依赖产生太大压力。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.5 平台架构&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.65390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhnic7BD6A6bicuWclPtJmPFAmPFVuicUwkrwrunoJmHWIsRFmcHvT1Y4bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、平台建设进展与迁移收益&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;5.1 业务使用收益&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 5.1.1 更高、更稳定的消息发送性能&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20914285714285713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhEAmaLTFzXFFT9icWqfJlia4t9icuQ7Ez6UHxDhU77OcR9t8cKEdc2AQwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原生RabbitMQ集群业务压测性能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2112676056338028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4vdOclLiaJywqf2InBNOFlhxk01yXPt6UhcCfzR6iadoAdlqmlDic6tRYdEY9GR8yLMMzXPdBuopPHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;使用消息网关后业务压测性能&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 5.1.2 更丰富的功能特性&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;统一的消息过期时间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消费异常消息将按照梯度延时重投递&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;直接支持广播消费模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;全环境按需提供消息轨迹功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持消费重置到以前的某个位点&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt; 5.1.3 业务使用特性变化&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;消息将&lt;strong&gt;不再无限期保留&lt;/strong&gt;，默认&lt;strong&gt;保留3~7天&lt;/strong&gt;（实际保留时间根据集群配置决定）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;消费异常将不再立即重投递，将按照一定的&lt;strong&gt;梯度延时重投递&lt;/strong&gt;，多次异常后将变为死信消息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;直接支持&lt;strong&gt;广播消费&lt;/strong&gt;，注意广播消费模式消费无异常重投递，每个消息每个节点只消费一次&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务生产消费性能可支持水平扩展&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不支持&lt;strong&gt;消费优先级&lt;/strong&gt;功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;默认&lt;strong&gt;消费超时时间15分钟&lt;/strong&gt;，消费超时后消息重新投递，消费超时时间可按需调整&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持&lt;strong&gt;消费启停&lt;/strong&gt;（全局或限制部分节点消费）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持&lt;strong&gt;全局消费限流&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制消息体大小&lt;/strong&gt;，当前限制为256KB，超过将直接返回失败，后续将进行流量治理，限制发送大消息体业务流量&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;5.2 平台运维收益&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;业务从RabbitMQ迁移到RocketMQ后，可支撑业务流量从万TPS级别提升到十万TPS级别，可支撑业务容量从数亿提升至百亿级别。耗用机器资源下降50%以上，运维难度和成本均大大降低，同时可以基于消息网关实现更加丰富的功能特性。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、未来展望&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;未来，中间件团队计划在三个方面对消息中间件进行迭代演进：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;基于消息网关能力丰富现有平台功能特性，进行业务消息治理。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;过去五年中间件团队基于开源RabbitMQ进行了RabbitMQ的高可用建设，发现直接让业务方使用基于开源组件的SDK接入会带来SDK升级困难，与后端消息中间件类型绑定的问题，未来我们计划基于GPRC和消息网关，实现消息队列引擎服务化，业务无需关心底层具体使用的开源消息中间件选型。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;调研RocketMQ5.0计算与存储分离构架，进行消息中间件架构的再升级。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section data-recommend-type=&quot;list-normal&quot; data-recommend-tid=&quot;2&quot; data-mpa-template=&quot;t&quot; data-mid=&quot;&quot; data-from=&quot;yb-recommend&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501257_1&quot; data-recommend-article-time=&quot;1636251616&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/0?wx_fmt=jpeg&amp;amp;amp;random=0.27521905775014543&quot; data-recommend-article-title=&quot;强势开源一款小程序！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501257&amp;amp;idx=1&amp;amp;sn=7b4e27cdb1d3146a5e7e1951b5bdc9e8&amp;amp;chksm=c1ca33f9f6bdbaefd3874fa6313e422c8fb6b2799b40d09f36620f0ceaed4fd63c820da1f3ff&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强势开源一款小程序！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-11-07&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zc3KLDBfJlm8bD2WBlwbvnsktMdtfSudNaJWbHr1Iyr6HkwCxETHiaiceaWYLmq7tWmHV29U8Xv8UnoeCAOYNj9Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501242_1&quot; data-recommend-article-time=&quot;1634952613&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;强力推荐一个完善的物流（WMS）管理项目（附代码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501242&amp;amp;idx=1&amp;amp;sn=aa2297b69874de0993f62ea404376bab&amp;amp;chksm=c1ca338af6bdba9cf3e051ff3001e1f31f9fa97350f3851c797d6486eca360df537196dbe67b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;强力推荐一个完善的物流（WMS）管理项目（附代码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-23&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UWibGeSzVdcKHzDRdVHusb9CJicA5FdhDVPAiaicdTbibx5XoRkhKA3O7Q727cTSurBkJpciczjLrF2wkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501238_1&quot; data-recommend-article-time=&quot;1634606700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501238&amp;amp;idx=1&amp;amp;sn=d7e873d752a28b582d70bc9f7a981ddb&amp;amp;chksm=c1ca3386f6bdba9031ce115e734ce04c9b6728e8e027fbcf17d8d07f1e029ea5bea04f4a6273&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个 Spring Boot + MyBatis + Vue 音乐网站&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-10-19&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42592592592592593&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VduLA9tc9dQkaw5HWIV6pqNrOiciaE17jeIeTtoLfgLbyu67dWkRj3tjKX7AFIMrV0rKD5ic6kwicyxg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501208_1&quot; data-recommend-article-time=&quot;1632101100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;分享一套家庭理财系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501208&amp;amp;idx=1&amp;amp;sn=44fcdfe2d7f81a26845faf33750ea9bb&amp;amp;chksm=c1ca33a8f6bdbabec8ff34719f438465adf745cbef30bfb92be53897c714d8c13bdd01989d17&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;分享一套家庭理财系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-20&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42407407407407405&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VibcP3PNgQvXGZ7UJkVeu0JZsrldvF1urHlmNwhUP89IeKHz1PfJ12es2ArTwkYibAh3Y0soOib2rjA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501192_1&quot; data-recommend-article-time=&quot;1630718700&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一个互联网企业级别的开源支付系统&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501192&amp;amp;idx=1&amp;amp;sn=444404a565f02a8c532d291d99678a7b&amp;amp;chksm=c1ca33b8f6bdbaaeb7c65d9f6f0c399f609fb203f065b6e88a3ad5431473713dbb5ae3507b32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一个互联网企业级别的开源支付系统&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-09-04&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UG0pYPldneUCCVsPia3Rtr9j3hlFHakhItFlOXuwLicUqQvP1PhkTM28CUU9BpRCWfWPfHYredCBiaA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501176_1&quot; data-recommend-article-time=&quot;1629509100&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;推荐一套开源通用后台管理系统（附源码）&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501176&amp;amp;idx=1&amp;amp;sn=68e3ae7a9dc33fbbd379906ddcefdf5b&amp;amp;chksm=c1ca3348f6bdba5e1774625745f5ef40081c9b8eb0189073734b6808efb872720781d25b8dc0&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;推荐一套开源通用后台管理系统（附源码）&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-08-21&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VQRwetNLhDOB2Ej0fDZK4eRXsYlRNicgmsWwmuvlhibooic3N3su1lbMQPqWD186JiaOC5yJ9iaaic8bzw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501153_1&quot; data-recommend-article-time=&quot;1627704022&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;一款神仙接私活儿软件，吊到不行！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501153&amp;amp;idx=1&amp;amp;sn=bb29cffa56431b72a92709c0ae993af7&amp;amp;chksm=c1ca3351f6bdba4729c671cdcd0ee8b6af75c6ce8a7003e6c032942b849aab5bfedecd0f9d3b&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;一款神仙接私活儿软件，吊到不行！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-31&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4265625&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7UbyFoOMqOObokEYiahCar20LiaY8ZLGKzU7NYQQoGycgnhrmIzNJibPicGcNia3cbbXlYib6bcLJVV5aww/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501139_1&quot; data-recommend-article-time=&quot;1626571500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;基于 SpringBoot 的仿豆瓣平台【源码分享】&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501139&amp;amp;idx=1&amp;amp;sn=f133e70bda8abae27459ccc4d3d6d8fd&amp;amp;chksm=c1ca3363f6bdba75b9a4145510d9b6108c56146a3146b2e2e6d660a08221618b01c815d55642&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;基于 SpringBoot 的仿豆瓣平台【源码分享】&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-07-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42427884615384615&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VGxZrbRFy96Sm9cXQzVEhiaLibUUYhYH1SJL4HUXenau3DCeq0KEOsguY4CWjaEd1BeAicJd24qFM2w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501105_1&quot; data-recommend-article-time=&quot;1623979500&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;干掉 Wordpress！这个开源建站神器有点吊！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8#rd&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501105&amp;amp;idx=1&amp;amp;sn=caf01186b6d2e4a38e940ce07d822238&amp;amp;chksm=c1ca3301f6bdba17ba7127da24e28963ae40f944e587f14b57405e2a9ee9d8cdbcb835c880c8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;干掉 Wordpress！这个开源建站神器有点吊！&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;2021-06-18&lt;/p&gt;&lt;/section&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42578125&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7Xw68Ow8vZian4lanQFAu09f4JOZlXbC85jsByb8V6StkOpibAdgPamPWoPPY3G7S3nic50QvxxuGNrg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; data-recommend-article-type=&quot;list-normal&quot; data-recomment-template-id=&quot;2&quot; data-recommend-article-id=&quot;2247501098_2&quot; data-recommend-article-time=&quot;1623461160&quot; data-recommend-article-cover=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/0?wx_fmt=jpeg&quot; data-recommend-article-title=&quot;从朋友那里搞了 20 个实战项目，速领！&quot; data-recommend-article-content-url=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4#rd&quot;&gt;&lt;section data-recommend-content=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;p data-recommend-title=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;从朋友那里搞了 20 个实战项目，速领！&lt;/a&gt;&lt;/p&gt;&lt;p data-recommend-date=&quot;t&quot; data-mid=&quot;&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;2021-06-12&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyNTI5NTQ1NQ==&amp;amp;mid=2247501098&amp;amp;idx=2&amp;amp;sn=520b81839bb5b4f1c990278e03e1991d&amp;amp;chksm=c1ca331af6bdba0c0e3435da519fadda3be81744168e30c56a823180bd458a5ec8a6b499f2a4&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;200&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Baq5lYpIw7VzIP6xibP6U8htKa7YEad1iaTE02ZbsOfvDX1D8LoTiaNsMVgdjFOdm5LahpnNXFe3ibSp8S4FJ39KkA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Baq5lYpIw7X6YPYGQITyP8Zdk96ab7CX0Ind5E05VokoepTP9Adic0xRwiaQrAvfTeC7iafngRibhBShpVqibqNcCCA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如有收获，点个在看，诚挚感谢&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100018364&quot; data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;19&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk54JM0xl7WLNGnqqwbcXQBWIOCMuOgPHRoOjMamXzrCqMS2xgOo5ibic9icPk7u3zsVgic3s1ZUYJ4xHXg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0fd01f8e8c401b6ff8504bc6860fd41c</guid>
<title>python录制屏幕小工具，已调试成功运行！</title>
<link>https://toutiao.io/k/6uwz92e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;p&gt;&lt;span&gt;由于最近测试需要录制系统界面的操作过程，因为都是全屏的操作，所以用python做一个简单的录屏小工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx4f706964b979122a&quot; data-miniprogram-path=&quot;pages/topics/topics?group_id=48841258855188&quot; data-miniprogram-nickname=&quot;知识星球&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;span&gt;立即前往微信小程序【知识星球】提问&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现过程也是比较简单，就是通过对屏幕操作进行不断的截图，最后将截图合成一个操作视频的过程。由于我们只是做简单的截屏功能，并没有加入音频效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1958762886597938&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wzyc1ToJM6iaRic7B8L3iaerbItscvIV5vEdmS5xBVbQTwsiaUfdxyVcJFObPgBGDpAHwiaiajR0L6Cic2LvSLRf5O6nA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;873&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、准备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开始之前我们还是按照以往的方式介绍一下使用到的第三方的python模块。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt; ImageGrab&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; numpy &lt;span&gt;as&lt;/span&gt; np&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; cv2&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; datetime&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; pynput &lt;span&gt;import&lt;/span&gt; keyboard&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; threading&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; loguru &lt;span&gt;import&lt;/span&gt; logger&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;由于实现过程比较少，这里我们不再创建标准的class实现，直接在.py文件写相关的函数来实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、代码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实现过程主要是通过两个函数来实现的，一个是实现具体的屏幕截图操作，并且将其写入视频。另一个则是用来监听键盘的输入，若是按下esc键时则退出当前的录制操作。&lt;/span&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1659093573424&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1659093573424&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初始化一个变量作为停止标志。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;is_running = &lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;创建录制过程生成函数generate_video，用以生成录制视频。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;generate_video&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;    生成录制视频函数&lt;br/&gt;    :return:&lt;br/&gt;    &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    file_name = datetime.datetime.now().strftime(&lt;span&gt;&#x27;%Y-%m-%d %H-%M-%S&#x27;&lt;/span&gt;)&lt;br/&gt;    screen = ImageGrab.grab()&lt;br/&gt;    width, height = screen.size&lt;br/&gt;    fourcc = cv2.VideoWriter_fourcc(*&lt;span&gt;&#x27;XVID&#x27;&lt;/span&gt;)&lt;br/&gt;    video = cv2.VideoWriter(&lt;span&gt;&#x27;%s.avi&#x27;&lt;/span&gt; % file_name, fourcc, &lt;span&gt;20&lt;/span&gt;, (width, height))&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;3&lt;/span&gt;):&lt;br/&gt;        logger.debug(str(&lt;span&gt;3&lt;/span&gt; - n) + &lt;span&gt;&#x27;秒后开始录制！&#x27;&lt;/span&gt;)&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        im1 = ImageGrab.grab()&lt;br/&gt;        im2 = cv2.cvtColor(np.array(im1), cv2.COLOR_RGB2BGR)&lt;br/&gt;        video.write(im2)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; is_running &lt;span&gt;is&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;:&lt;br/&gt;            logger.debug(&lt;span&gt;&#x27;屏幕录制已经结束！&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    video.release()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;创建键盘监听函数press_keyboard，监听输入，若是按下esc键则改变运行状态。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;is_running=&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;press_keyboard&lt;/span&gt;&lt;span&gt;(key)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;    键盘监听函数&lt;br/&gt;    :param key:&lt;br/&gt;    :return:&lt;br/&gt;    &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;global&lt;/span&gt; is_running&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; key == keyboard.Key.esc:&lt;br/&gt;        logger.debug(&lt;span&gt;&#x27;ESC已经被按下，马上结束录制！&#x27;&lt;/span&gt;)&lt;br/&gt;        is_running = &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;执行主函数main，启动则执行屏幕录制。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    thread_ = threading.Thread(target=generate_video)&lt;br/&gt;    thread_.start()&lt;br/&gt;    logger.debug(&lt;span&gt;&#x27; 开始进入视频录制！&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;with&lt;/span&gt; keyboard.Listener(on_press=press_keyboard) &lt;span&gt;as&lt;/span&gt; listener:&lt;br/&gt;        listener.join()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;最后，使用pyinstaller将其打包成exe的可执行应用，使用时直接双击打开即可开始录制屏幕的操作过程。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;pyinstaller -i .\video.ico -Fw .\test2.py&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;至此，录制屏幕小工具就大功告成了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;「Python 集中营」&lt;/span&gt;&lt;/strong&gt;，只做知识分享 ！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3ODk1Mzg0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hibKwqc6pgs9eu9tgh5AeibzhIhhMcAiaKaoczZdvmic9lLBP6oAyjibayia3ctN1WXEFyVia1OXoD9y3ibQ/0?wx_fmt=png&quot; data-nickname=&quot;Python 集中营&quot; data-alias=&quot;python_code1024&quot; data-signature=&quot;编程技巧、实战总结，在 Python 的路上越走越宽，+关注自动领取Python 学习视频资料！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;加个鸡腿🍗&lt;/p&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c40d74e17df4614eff4b1c7254569462</guid>
<title>[推荐] 聊聊Java中代码优化的30个小技巧</title>
<link>https://toutiao.io/k/jv8g1r6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前写过两篇关于优化相关的问题：《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490473&amp;amp;idx=1&amp;amp;sn=ba07d64aa8c89054bd263efd660d3a3f&amp;amp;chksm=c0ebc341f79c4a579a6f41465df0459a696ab8ef0499a5f6fd76269af1064fde0286afdb027d&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊sql优化的15个小技巧&lt;/a&gt;》和《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490731&amp;amp;idx=1&amp;amp;sn=29ed0295c7990157a3a56ba33cf7f8be&amp;amp;chksm=c0ebc443f79c4d55a2bac81744992c96f97737e5d0717ec99231f4d08f57a7f0220eafdac9c9&amp;amp;token=660773166&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊接口性能优化的11个小技巧&lt;/a&gt;》，发表之后，在全网受到广大网友的好评。阅读量和点赞率都很高，说明了这类文章的价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天接着优化这个话题，我们一起聊聊Java中代码优化的30个小技巧，希望会对你有所帮助。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8313253012048193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSsU9ic3SneiahUCRSjva6M3gbGFxut8tpXCGkemeH8ibE42v0xwM88BcWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1660&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.用String.format拼接字符串&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有拼接过字符串，特别是那种有多个参数，字符串比较长的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在有个需求：要用get请求调用第三方接口，url后需要拼接多个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们的请求地址是这样拼接的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String url = &lt;span&gt;&quot;http://susan.sc.cn?userName=&quot;&lt;/span&gt;+userName+&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;+age+&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;+address+&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;+sex+&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;+roleId;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串使用&lt;code&gt;+&lt;/code&gt;号拼接，非常容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面优化了一下，改为使用&lt;code&gt;StringBuilder&lt;/code&gt;拼接字符串：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;StringBuilder urlBuilder = &lt;span&gt;new&lt;/span&gt; StringBuilder(&lt;span&gt;&quot;http://susan.sc.cn?&quot;&lt;/span&gt;);&lt;br/&gt;urlBuilder.append(&lt;span&gt;&quot;userName=&quot;&lt;/span&gt;)&lt;br/&gt;.append(userName)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;age=&quot;&lt;/span&gt;)&lt;br/&gt;.append(age)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;address=&quot;&lt;/span&gt;)&lt;br/&gt;.append(address)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;sex=&quot;&lt;/span&gt;)&lt;br/&gt;.append(sex)&lt;br/&gt;.append(&lt;span&gt;&quot;&amp;amp;roledId=&quot;&lt;/span&gt;)&lt;br/&gt;.append(roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化之后，稍微直观点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还是看起来比较别扭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以使用&lt;code&gt;String.format&lt;/code&gt;方法优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String requestUrl = &lt;span&gt;&quot;http://susan.sc.cn?userName=%s&amp;amp;age=%s&amp;amp;address=%s&amp;amp;sex=%s&amp;amp;roledId=%s&quot;&lt;/span&gt;;&lt;br/&gt;String url = String.format(requestUrl,userName,age,address,sex,roledId);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的可读性，一下子提升了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平常可以使用&lt;code&gt;String.format&lt;/code&gt;方法拼接url请求参数，日志打印等字符串。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;但不建议在for循环中用它拼接字符串，因为它的执行效率，比使用+号拼接字符串，或者使用StringBuilder拼接字符串都要慢一些。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.创建可缓冲的IO流&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO流&lt;/code&gt;想必大家都使用得比较多，我们经常需要把数据&lt;code&gt;写入&lt;/code&gt;某个文件，或者从某个文件中&lt;code&gt;读取&lt;/code&gt;数据到&lt;code&gt;内存&lt;/code&gt;中，甚至还有可能把文件a，从目录b，&lt;code&gt;复制&lt;/code&gt;到目录c下等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK给我们提供了非常丰富的API，可以去操作IO流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = fis.read()) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                fos.write(len);&lt;br/&gt;            }&lt;br/&gt;            fos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子主要的功能，是将1.txt文件中的内容复制到2.txt文件中。这例子使用普通的IO流从功能的角度来说，也能满足需求，但性能却不太好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个例子中，从1.txt文件中读一个字节的数据，就会马上写入2.txt文件中，需要非常频繁的读写文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IoTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        BufferedInputStream bis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        BufferedOutputStream bos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileInputStream fis = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        FileOutputStream fos = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            File srcFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/1.txt&quot;&lt;/span&gt;);&lt;br/&gt;            File destFile = &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;/Users/dv_susan/Documents/workspace/jump/src/main/java/com/sue/jump/service/test1/2.txt&quot;&lt;/span&gt;);&lt;br/&gt;            fis = &lt;span&gt;new&lt;/span&gt; FileInputStream(srcFile);&lt;br/&gt;            fos = &lt;span&gt;new&lt;/span&gt; FileOutputStream(destFile);&lt;br/&gt;            bis = &lt;span&gt;new&lt;/span&gt; BufferedInputStream(fis);&lt;br/&gt;            bos = &lt;span&gt;new&lt;/span&gt; BufferedOutputStream(fos);&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; len;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; ((len = bis.read(buffer)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                bos.write(buffer, &lt;span&gt;0&lt;/span&gt;, len);&lt;br/&gt;            }&lt;br/&gt;            bos.flush();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bos.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fos != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fos.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (bis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    bis.close();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (fis != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    fis.close();&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子使用&lt;code&gt;BufferedInputStream&lt;/code&gt;和&lt;code&gt;BufferedOutputStream&lt;/code&gt;创建了&lt;code&gt;可缓冲&lt;/code&gt;的输入输出流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的地方是定义了一个buffer字节数组，把从1.txt文件中读取的数据临时保存起来，后面再把该buffer字节数组的数据，一次性批量写入到2.txt中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，减少了读写文件的次数，而我们都知道读写文件是非常耗时的操作。也就是说使用可缓存的输入输出流，可以提升IO的性能，特别是遇到文件非常大时，效率会得到显著提升。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少循环次数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，循环遍历集合是必不可少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果循环层级比较深，循环中套循环，可能会影响代码的执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(User user: userList) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt;(Role role: roleList) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(user.getRoleId().equals(role.getId())) {&lt;br/&gt;         user.setRoleName(role.getName());&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中有两层循环，如果userList和roleList数据比较多的话，需要循环遍历很多次，才能获取我们所需要的数据，非常消耗cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;Long, List&amp;lt;Role&amp;gt;&amp;gt; roleMap = roleList.stream().collect(Collectors.groupingBy(Role::getId));&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (User user : userList) {&lt;br/&gt;    List&amp;lt;Role&amp;gt; roles = roleMap.get(user.getRoleId());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isNotEmpty(roles)) {&lt;br/&gt;        user.setRoleName(roles.get(&lt;span&gt;0&lt;/span&gt;).getName());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;减少循环次数，最简单的办法是，把第二层循环的集合变成&lt;code&gt;map&lt;/code&gt;，这样可以直接通过&lt;code&gt;key&lt;/code&gt;，获取想要的&lt;code&gt;value&lt;/code&gt;数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说map的key存在&lt;code&gt;hash冲突&lt;/code&gt;的情况，但遍历存放数据的&lt;code&gt;链表&lt;/code&gt;或者&lt;code&gt;红黑树&lt;/code&gt;的&lt;code&gt;时间复杂度&lt;/code&gt;，比遍历整个list集合要小很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.用完资源记得及时关闭&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常开发中，可能经常访问&lt;code&gt;资源&lt;/code&gt;，比如：获取数据库连接，读取文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以获取数据库连接为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;Connection connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;PreparedStatement pstmt = conn.prepareStatement(sql);&lt;br/&gt;&lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;ResultSet rs = pstmt.execteQuery();&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;   String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码可以正常运行，但却犯了一个很大的错误，即：ResultSet、PreparedStatement和Connection对象的资源，使用完之后，没有关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，数据库连接是非常宝贵的资源。我们不可能一直创建连接，并且用完之后，也不回收，白白浪费数据库资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//1. 加载驱动类&lt;/span&gt;&lt;br/&gt;Class.forName(&lt;span&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Connection connection = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;PreparedStatement pstmt = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ResultSet rs = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//2. 创建连接&lt;/span&gt;&lt;br/&gt;    connection = DriverManager.getConnection(&lt;span&gt;&quot;jdbc:mysql//localhost:3306/db?allowMultiQueries=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;&lt;/span&gt;,&lt;span&gt;&quot;root&quot;&lt;/span&gt;,&lt;span&gt;&quot;123456&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//3.编写sql&lt;/span&gt;&lt;br/&gt;    String sql =&lt;span&gt;&quot;select * from user&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//4.创建PreparedStatement&lt;/span&gt;&lt;br/&gt;    pstmt = conn.prepareStatement(sql);&lt;br/&gt;    &lt;span&gt;//5.获取查询结果&lt;/span&gt;&lt;br/&gt;    rs = pstmt.execteQuery();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(rs.next()){&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; id = rs.getInt(&lt;span&gt;&quot;id&quot;&lt;/span&gt;);&lt;br/&gt;       String name = rs.getString(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(Exception e) {&lt;br/&gt;  log.error(e.getMessage(),e);&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(rs != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      rs.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(pstmt != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      pstmt.close();&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(connection != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      connection.close();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，无论是ResultSet，或者PreparedStatement，还是Connection对象，使用完之后，都会调用&lt;code&gt;close&lt;/code&gt;方法关闭资源。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在这里温馨提醒一句：ResultSet，或者PreparedStatement，还是Connection对象，这三者关闭资源的顺序不能反了，不然可能会出现异常。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.使用池技术&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，从数据库查数据，首先要连接数据库，获取&lt;code&gt;Connection&lt;/code&gt;资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想让程序多线程执行，需要使用&lt;code&gt;Thread&lt;/code&gt;类创建线程，线程也是一种资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常一次数据库操作的过程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进行数据库操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭连接&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而创建连接和关闭连接，是非常耗时的操作，创建连接需要同时会创建一些资源，关闭连接时，需要回收那些资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户的每一次数据库请求，程序都都需要去创建连接和关闭连接的话，可能会浪费大量的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，可能会导致数据库连接过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道数据库的&lt;code&gt;最大连接数&lt;/code&gt;是有限的，以mysql为例，最大连接数是：&lt;code&gt;100&lt;/code&gt;，不过可以通过参数调整这个数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户请求的连接数超过最大连接数，就会报：&lt;code&gt;too many connections&lt;/code&gt;异常。如果有新的请求过来，会发现数据库变得不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;variables&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; max_connections&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;set GLOBAL max_connections=&lt;span&gt;1000&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动修改最大连接数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法只能暂时缓解问题，不是一个好的方案，无法从根本上解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大的问题是：数据库连接数可以无限增长，不受控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们可以使用&lt;code&gt;数据库连接池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前Java开源的数据库连接池有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DBCP：是一个依赖Jakarta commons-pool对象池机制的数据库连接池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C3P0：是一个开放源代码的JDBC连接池，它在lib目录中与Hibernate一起发布，包括了实现jdbc3和jdbc2扩展规范说明的Connection 和Statement 池的DataSources 对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Druid：阿里的Druid，不仅是一个数据库连接池，还包含一个ProxyDriver、一系列内置的JDBC组件库、一个SQL Parser。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Proxool：是一个Java SQL Driver驱动程序，它提供了对选择的其它类型的驱动程序的连接池封装，可以非常简单的移植到已有代码中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前用的最多的数据库连接池是:&lt;code&gt;Druid&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.反射时加缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道通过&lt;code&gt;反射&lt;/code&gt;创建对象实例，比使用&lt;code&gt;new&lt;/code&gt;关键字要慢很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，不太建议在用户请求过来时，每次都通过反射&lt;code&gt;实时&lt;/code&gt;创建实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，为了代码的灵活性，又不得不用反射创建实例，这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：加&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring中就使用了大量的反射，我们以支付方法为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据前端传入不同的支付code，动态找到对应的支付方法，发起支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)  &lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; PayCode {  &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所有的支付类上都加上该注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;alia&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;支付宝支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;weixin&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;微信支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;} &lt;br/&gt; &lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;京东支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后增加最关键的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; payMap = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent contextRefreshedEvent)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  &lt;br/&gt;         Map&amp;lt;String, Object&amp;gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (beansWithAnnotation != &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             payMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;             beansWithAnnotation.forEach((key, value) -&amp;gt;{  &lt;br/&gt;                 String bizType = value.getClass().getAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;value&lt;/span&gt;()&lt;/span&gt;;  &lt;br/&gt;                 payMap.put(bizType, (IPay) value);  &lt;br/&gt;             });  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        payMap.get(code).pay();  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService2类实现了&lt;code&gt;ApplicationListener&lt;/code&gt;接口，这样在&lt;code&gt;onApplicationEvent方法&lt;/code&gt;中，就可以拿到&lt;code&gt;ApplicationContext&lt;/code&gt;的实例。这一步，其实是在spring容器启动的时候，spring通过反射我们处理好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再获取打了PayCode注解的类，放到一个&lt;code&gt;map&lt;/code&gt;中，map中的&lt;code&gt;key&lt;/code&gt;就是PayCode注解中定义的value，跟code参数一致，value是支付类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，每次就可以每次直接通过code获取支付类实例，而不用if...else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种方式的code可以没有业务含义，可以是纯数字，只要不重复就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.多线程处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在某个接口中，调用其他服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有这样的业务场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.184049079754601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSegV4nBn6pQ0dYTz332ibOEmveuhTbiaDUAk72mHLVzpVz0MyvetPkGGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;调用远程接口总耗时 530ms = 200ms + 150ms + 180ms&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化远程接口性能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到，既然串行调用多个远程接口性能很差，为什么不改成并行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSSNAsEvIlgoiczQbO9k60Wz61Mp4q58OXgnEYm8aLTxgRL7wk2icFzvwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.懒加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，创建对象是一个非常耗时的操作，特别是在该对象的创建过程中，还需要创建很多其他的对象时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以单例模式为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍单例模式的时候，必须要先介绍它的两种非常著名的实现方式：&lt;code&gt;饿汉模式&lt;/code&gt; 和 &lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.1 饿汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例在初始化的时候就已经建好了，不管你有没有用到，先建好了再说。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//持有自己类的引用&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//私有的构造方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//对外提供获取实例的静态方法&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用饿汉模式的好处是：&lt;code&gt;没有线程安全的问题&lt;/code&gt;，但带来的坏处也很明显。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SimpleSingleton INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一开始就实例化对象了，如果实例化过程非常耗时，并且最后这个对象没有被使用，不是白白造成资源浪费吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真是啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候你也许会想到，不用提前实例化对象，在真正使用的时候再实例化不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我接下来要介绍的：&lt;code&gt;懒汉模式&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.2 懒汉模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义就是实例在用到的时候才去创建，“比较懒”，用的时候才去检查有没有实例，如果有则返回，没有则新建。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 INSTANCE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;SimpleSingleton2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleSingleton2 &lt;span&gt;getInstance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (INSTANCE == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            INSTANCE = &lt;span&gt;new&lt;/span&gt; SimpleSingleton2();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; INSTANCE;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的INSTANCE对象一开始是空的，在调用getInstance方法才会真正实例化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懒汉模式相对于饿汉模式，没有提前实例化对象，在真正使用的时候再实例化，在实例化对象的阶段效率更高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了单例模式之外，懒加载的思想，使用比较多的可能是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;spring的@Lazy注解。在spring容器启动的时候，不会调用其getBean方法初始化实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mybatis的懒加载。在mybatis做级联查询的时候，比如查用户的同时需要查角色信息。如果用了懒加载，先只查用户信息，真正使用到角色了，才取查角色信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.初始化集合时指定大小&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在实际项目开发中，需要经常使用集合，比如：ArrayList、HashMap等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个问题：你在初始化集合时指定了大小的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time1 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time1);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在初始化集合时指定了大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Integer&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;100000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; time2 = System.currentTimeMillis();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            list2.add(i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(System.currentTimeMillis() - time2);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们惊奇的发现，在创建集合时指定了大小，比没有指定大小，添加10万个元素的效率提升了一倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过&lt;code&gt;ArrayList&lt;/code&gt;源码，你就会发现它的默认大小是&lt;code&gt;10&lt;/code&gt;，如果添加元素超过了一定的阀值，会按&lt;code&gt;1.5&lt;/code&gt;倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想想，如果装10万条数据，需要扩容多少次呀？而每次扩容都需要不停的复制元素，从老集合复制到新集合中，需要浪费多少时间呀。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.不要满屏try...catch异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前我们在开发接口时，如果出现&lt;code&gt;异常&lt;/code&gt;，为了给用户一个更友好的提示，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不做任何处理，当我们请求add接口时，执行结果直接报错：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBS6NAiaefsh2FScQC5sFLbnUPCiaJcNuZlHHUYWiaapdBwCvTsr3ZTsN0xA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;what？用户能直接看到错误信息？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/add&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String result = &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt; / &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        result = &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来挺不错的，但是有问题。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的，这时全局异常处理就派上用场了：&lt;code&gt;RestControllerAdvice&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestControllerAdvice&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalExceptionHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@ExceptionHandler&lt;/span&gt;(Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;handleException&lt;/span&gt;(&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; ArithmeticException) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;数据异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt; Exception) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;服务器内部异常&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        retur nnull;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需在&lt;code&gt;handleException&lt;/code&gt;方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.位运算效率更高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你读过JDK的源码，比如：&lt;code&gt;ThreadLocal&lt;/code&gt;、&lt;code&gt;HashMap&lt;/code&gt;等类，你就会发现，它们的底层都用了&lt;code&gt;位运算&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么开发JDK的大神们，都喜欢用位运算？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为位运算的效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是：int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.巧用第三方工具类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：&lt;code&gt;轮子&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你引入&lt;code&gt;com.google.guava&lt;/code&gt;的pom文件，会获得很多好用的小工具。这里推荐一款&lt;code&gt;com.google.common.collect&lt;/code&gt;包下的集合工具：&lt;code&gt;Lists&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是在太好用了，让我爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将一个&lt;code&gt;大集合&lt;/code&gt;分成若干个&lt;code&gt;小集合&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;List&amp;lt;Integer&amp;gt; dataList = Lists.newArrayList();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(Integer data : list) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(size &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;      dataList = Lists.newArrayList();&lt;br/&gt;      size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;   } &lt;br/&gt;   size++;&lt;br/&gt;   dataList.add(data);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将list按size=2分成多个小集合，上面的代码看起来比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用&lt;code&gt;Lists&lt;/code&gt;的&lt;code&gt;partition&lt;/code&gt;方法，可以这样写代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.partition(list, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(partitionList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我最喜欢的方法之一，经常在项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你了解更多非常有用的第三方工具类的话，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247495296&amp;amp;idx=1&amp;amp;sn=6ff4affb2d00dce011c08d8eb5448d7a&amp;amp;chksm=c0e83668f79fbf7ead1410a998f4d4406badd65f943ca1b6833a7b1d663d5d5d0808e4c462e4&amp;amp;token=1690710950&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;吐血推荐17个提升开发效率的“轮子”&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.用同步代码块代替同步方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果锁加得不好，导致&lt;code&gt;锁的粒度太粗&lt;/code&gt;，也会非常影响接口性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中提供了&lt;code&gt;synchronized&lt;/code&gt;关键字给我们的代码加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有两种写法：&lt;code&gt;在方法上加锁&lt;/code&gt; 和 &lt;code&gt;在代码块上加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看如何在方法上加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    mkdir();&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以改成在代码块上加锁了，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;          mkdir(path);&lt;br/&gt;       }&lt;br/&gt;    }&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.不用的数据及时清理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中保证线程安全的技术有很多，可以使用&lt;code&gt;synchroized&lt;/code&gt;、&lt;code&gt;Lock&lt;/code&gt;等关键字给代码块&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它们有个共同的特点，就是加锁会对代码的性能有一定的损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在jdk中还提供了另外一种思想即：&lt;code&gt;用空间换时间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用&lt;code&gt;ThreadLocal&lt;/code&gt;类就是对这种思想的一种具体体现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal为每个使用变量的线程提供了一个独立的变量副本，这样每一个线程都能独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal的用法大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在业务代码中调用CurrentUser类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   CurrentUser.set(userInfo);&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;   UserInfo userInfo = CurrentUser.get();&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在业务代码的第一行，将userInfo对象设置到CurrentUser，这样在业务代码中，就能通过CurrentUser.get()获取到刚刚设置的userInfo对象。特别是对业务代码调用层级比较深的情况，这种用法非常有用，可以减少很多不必要传参。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景下，这段代码有问题，只往ThreadLocal存数据，数据用完之后并没有及时清理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal即使使用了&lt;code&gt;WeakReference&lt;/code&gt;（弱引用）也可能会存在&lt;code&gt;内存泄露&lt;/code&gt;问题，因为 entry对象中只把key(即threadLocal对象)设置成了弱引用，但是value值没有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15.用equals方法比较是否相等&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在项目中有没有见过，有些同事对&lt;code&gt;Integer&lt;/code&gt;类型的两个参数使用&lt;code&gt;==&lt;/code&gt;号比较是否相等？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我见过的，那么这种用法对吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的回答是看具体场景，不能说一定对，或不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些状态字段，比如：orderStatus有：-1(未下单)，0（已下单），1（已支付），2（已完成），3（取消），5种状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果用==判断是否相等：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1 == orderStatus2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：是false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学可能会反驳，Integer中不是有范围是：&lt;code&gt;-128-127&lt;/code&gt;的缓存吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是false？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看Integer的构造方法：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2754237288135593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSGoDWXuoUVJoGiayMxPSkuKayLarclUJxotziaQOBf9FLygUF9G4GBKoA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;472&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它其实并没有用到&lt;code&gt;缓存&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存是在哪里用的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案在&lt;code&gt;valueOf&lt;/code&gt;方法中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.226457399103139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSrichYZ6WD1k8jazQES87KDkhNu2wGhM526E9lqcEEbtPbticaIWXXXNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的判断改成这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String orderStatus1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;String orderStatus2 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Integer.valueOf(orderStatus1) == Integer.valueOf(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回结果会是true吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：还真是true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要养成良好编码习惯，尽量少用==判断两个Integer类型数据是否相等，只有在上述非常特殊的场景下才相等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而应该改成使用&lt;code&gt;equals&lt;/code&gt;方法判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer orderStatus1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer orderStatus2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;System.out.println(orderStatus1.equals(orderStatus2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果为true。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.避免创建大集合&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们在日常开发中，需要创建集合。比如：为了性能考虑，从数据库查询某张表的所有数据，一次性加载到内存的某个集合中，然后做业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; userList = userMapper.getAllUser();&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(User user:userList) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从数据库一次性查询出所有用户，然后在循环中，对每个用户进行业务逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;用户表&lt;/code&gt;的数据量非常多时，这样userList集合会很大，可能直接导致内存不足，而使整个应用挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，必须做&lt;code&gt;分页处理&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PAGE_SIZE = &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; currentPage = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;RequestPage page = &lt;span&gt;new&lt;/span&gt; RequestPage();&lt;br/&gt;page.setPageNo(currentPage);&lt;br/&gt;page.setPageSize(PAGE_SIZE);&lt;br/&gt;&lt;br/&gt;Page&amp;lt;User&amp;gt; pageUser = userMapper.search(page);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt;(pageUser.getPageCount() &amp;gt;= currentPage) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(User user:pageUser.getData()) {&lt;br/&gt;       doSamething();&lt;br/&gt;    }&lt;br/&gt;   page.setPageNo(++currentPage);&lt;br/&gt;   pageUser = userMapper.search(page);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的分页改造之后，每次从数据库中只查询&lt;code&gt;500&lt;/code&gt;条记录，保存到userList集合中，这样userList不会占用太多的内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里特别说明一下，如果你查询的表中的数据量本来就很少，一次性保存到内存中，也不会占用太多内存，这种情况也可以不做分页处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还有中特殊的情况，即表中的记录数并算不多，但每一条记录，都有很多字段，单条记录就占用很多内存空间，这时也需要做分页处理，不然也会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的原则是要尽量避免创建大集合，导致内存不足的问题，但是具体多大才算大集合。目前没有一个唯一的衡量标准，需要结合实际的业务场景进行单独分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.状态用枚举&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们建的表中，有很多状态字段，比如：订单状态、禁用状态、删除状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种状态都有多个值，代表不同的含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如订单状态有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有使用枚举，一般是这样做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CREATE = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_PAY = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_DONE = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ORDER_STATUS_CANCEL = &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CREATE_MESSAGE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_PAY = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_DONE = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String ORDER_STATUS_CANCEL = &lt;span&gt;&quot;下单&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要定义很多静态常量，包含不同的状态和状态的描述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;枚举&lt;/code&gt;定义之后，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; OrderStatusEnum {  &lt;br/&gt;     CREATE(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;下单&quot;&lt;/span&gt;),  &lt;br/&gt;     PAY(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;支付&quot;&lt;/span&gt;),  &lt;br/&gt;     DONE(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;完成&quot;&lt;/span&gt;),  &lt;br/&gt;     CANCEL(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;&quot;撤销&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; String message;  &lt;br/&gt;&lt;br/&gt;     OrderStatusEnum(&lt;span&gt;int&lt;/span&gt; code, String message) {  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.code = code;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.message = message;  &lt;br/&gt;     }  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.code;  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message;  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; OrderStatusEnum &lt;span&gt;getOrderStatusEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Arrays.stream(OrderStatusEnum.values()).filter(x -&amp;gt; x.code == code).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用枚举改造之后，职责更单一了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且使用枚举的好处是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码的可读性变强了，不同的状态，有不同的枚举进行统一管理和维护。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举是天然单例的，可以直接使用==号进行比较。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;code和message可以成对出现，比较容易相关转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;枚举可以消除if...else过多问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.把固定值定义成静态常量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你在实际的项目开发中，有没有使用过固定值？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; &lt;span&gt;1000L&lt;/span&gt;) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;1000L&lt;/code&gt;和&lt;code&gt;该用户不存在&lt;/code&gt;是固定值，每次都是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然是固定值，我们为什么不把它们定义成静态常量呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样语义上更直观，方便统一管理和维护，更方便代码复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码优化为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_USER_ID = &lt;span&gt;1000L&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(user.getId() &amp;lt; DEFAULT_USER_ID) {&lt;br/&gt;   doSamething();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NOT_FOUND_MESSAGE = &lt;span&gt;&quot;该用户不存在&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(NOT_FOUND_MESSAGE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;static final&lt;/code&gt;关键字修饰静态常量，&lt;code&gt;static&lt;/code&gt;表示&lt;code&gt;静态&lt;/code&gt;的意思，即类变量，而&lt;code&gt;final&lt;/code&gt;表示&lt;code&gt;不允许修改&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个关键字加在一起，告诉Java虚拟机这种变量，在内存中只有一份，在全局上是唯一的，不能修改，也就是&lt;code&gt;静态常量&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.避免大事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用&lt;code&gt;@Transactional&lt;/code&gt;注解提供事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也容易造成大事务，引发其他的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图看看大事务引发的问题。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSElRhibpG7ykB9z1QsOon7r2NqJmoShOScCwjcdd5LibPpF5iay5ZDyuvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们该如何优化大事务呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;少用@Transactional注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将查询(select)方法放到事务外&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免远程调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免一次性处理太多数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以非事务执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以异步处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于大事务问题我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490259&amp;amp;idx=1&amp;amp;sn=1dd11c5f49103ca303a61fc82ce406e0&amp;amp;chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;让人头痛的大事务问题到底要如何解决？&lt;/a&gt;》，它里面做了非常详细的介绍，如果大家感兴趣可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.消除过长的if...else&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写代码的时候，if...else的判断条件是必不可少的。不同的判断条件，走的代码逻辑通常会不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，先看看下面的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;); &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; AliaPay aliaPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; WeixinPay weixinPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; JingDongPay jingDongPay;  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;             aliaPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              weixinPay.pay();  &lt;br/&gt;         } elseif (&lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              jingDongPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;              System.out.println(&lt;span&gt;&quot;找不到支付方式&quot;&lt;/span&gt;);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService类的toPay方法主要是为了发起支付，根据不同的code，决定调用用不同的支付类（比如：aliaPay）的pay方法进行支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码有什么问题呢？也许有些人就是这么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这里违法了设计模式六大原则的：开闭原则 和 单一职责原则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化if...else判断呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用 &lt;code&gt;策略模式&lt;/code&gt;+&lt;code&gt;工厂模式&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式定义了一组算法，把它们一个个封装起来, 并且使它们可相互替换。工厂模式用于封装和管理对象的创建，是一种创建型模式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;aliaPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;weixinPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;jingDongPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayStrategyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; PAY_REGISTERS = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(String code, IPay iPay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != code &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            PAY_REGISTERS.put(code, iPay);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IPay &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; PAY_REGISTERS.get(code);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.get(code).pay();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的关键是PayStrategyFactory类，它是一个策略工厂，里面定义了一个全局的map，在所有IPay的实现类中注册当前实例到map中，然后在调用的地方通过PayStrategyFactory类根据code从map获取支付类实例即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加了一个新的支付方式，只需新加一个类实现IPay接口，定义init方法，并且重写pay方法即可，其他代码基本上可以不用动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，消除又臭又长的if...else判断，还有很多方法，比如：使用注解、动态拼接类名称、模板方法、枚举等等。由于篇幅有限，在这里我就不过多介绍了，更详细的内容可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490272&amp;amp;idx=1&amp;amp;sn=c5db63c7b52e7518b7a42e48c70927fc&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消除if...else是9条锦囊妙计&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.防止死循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴看到这个标题，可能会感到有点意外，代码中不是应该避免死循环吗？为啥还是会产生死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;殊不知有些死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了while(true)的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有另一种死循环：&lt;code&gt;无限递归&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现无限递归的情况。导致接口一直不能返回数据，最终会发生堆栈溢出。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.注意BigDecimal的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会把一些小数类型的字段（比如：金额），定义成&lt;code&gt;BigDecimal&lt;/code&gt;，而不是&lt;code&gt;Double&lt;/code&gt;，避免丢失精度问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Double时可能会有这种场景：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;double&lt;/span&gt; amount1 = &lt;span&gt;0.02&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;double&lt;/span&gt; amount2 = &lt;span&gt;0.03&lt;/span&gt;;&lt;br/&gt;System.out.println(amount2 - amount1);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下预计amount2 - amount1应该等于0.01&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是执行结果，却为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.009999999999999998&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际结果小于预计结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Double类型的两个参数相减会转换成二进制，因为Double有效位数为16位这就会出现存储小数位数不够的情况，这种情况下就会出现误差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常识告诉我们使用&lt;code&gt;BigDecimal&lt;/code&gt;能避免丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用BigDecimal能避免丢失精度吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中定义了两个BigDecimal类型参数，使用构造函数初始化数据，然后打印两个参数相减后的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;0.0099999999999999984734433411404097569175064563751220703125&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不科学呀，为啥还是丢失精度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jdk&lt;/code&gt;中&lt;code&gt;BigDecimal&lt;/code&gt;的&lt;code&gt;构造方法&lt;/code&gt;上有这样一段描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2511013215859031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gqHibQQHSJ4vj82XVnOgXBSH69HIOJwzLbx8F0uoMgeDicyDBUKjAyWDulF9OB9sx66Sds4Orre8vA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;908&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致的意思是此构造函数的结果可能不可预测，可能会出现创建时为0.1，但实际是0.1000000000000000055511151231257827021181583404541015625的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，使用BigDecimal构造函数初始化对象，也会丢失精度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能不丢失精度呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.02&lt;/span&gt;));&lt;br/&gt;BigDecimal amount2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(Double.toString(&lt;span&gt;0.03&lt;/span&gt;));&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用&lt;code&gt;Double.toString&lt;/code&gt;方法，对double类型的小数进行转换，这样能保证精度不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，还有更好的办法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal amount1 = BigDecimal.valueOf(&lt;span&gt;0.02&lt;/span&gt;);&lt;br/&gt;BigDecimal amount2 = BigDecimal.valueOf(&lt;span&gt;0.03&lt;/span&gt;);&lt;br/&gt;System.out.println(amount2.subtract(amount1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;BigDecimal.valueOf&lt;/code&gt;方法初始化BigDecimal类型参数，也能保证精度不丢失。在新版的阿里巴巴开发手册中，也推荐使用这种方式创建BigDecimal参数。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.尽可能复用代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ctrl + c&lt;/code&gt; 和 &lt;code&gt;ctrl + v&lt;/code&gt;可能是程序员使用最多的快捷键了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我们是大自然的搬运工。哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目初期，我们使用这种工作模式，确实可以提高一些工作效率，可以少写（实际上是少敲）很多代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但它带来的问题是：会出现大量的代码重复。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test2&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        addLog(&lt;span&gt;&quot;test3&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isInfoEnabled()) {&lt;br/&gt;            log.info(&lt;span&gt;&quot;info:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在TestService1、TestService2、TestService3类中，都有一个addLog方法用于添加日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来该功能用得好好的，直到有一天，线上出现了一个事故：服务器磁盘满了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因是打印的日志太多，记了很多没必要的日志，比如：查询接口的所有返回值，大对象的具体打印等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没办法，只能将addLog方法改成只记录&lt;code&gt;debug&lt;/code&gt;日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎，你需要全文搜索，addLog方法去修改，改成如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是有三个类中需要修改这段代码，但如果实际工作中有三十个、三百个类需要修改，会让你非常痛苦。改错了，或者改漏了，都会埋下隐患，把自己坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为何不把这种功能的代码提取出来，放到某个工具类中呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;LogUtil&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;初始化失败&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addLog&lt;/span&gt;&lt;span&gt;(String info)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;            log.debug(&lt;span&gt;&quot;debug:{}&quot;&lt;/span&gt;, info);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在其他的地方，只需要调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestService1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        LogUtil.addLog(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果哪天addLog的逻辑又要改了，只需要修改LogUtil类的addLog方法即可。你可以自信满满的修改，不需要再小心翼翼了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们写的代码，绝大多数是可维护性的代码，而非一次性的。所以，建议在写代码的过程中，如果出现重复的代码，尽量提取成公共方法。千万别因为项目初期一时的爽快，而给项目埋下隐患，后面的维护成本可能会非常高。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.foreach循环中不remove元素&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道在Java中，循环有很多种写法，比如：while、for、foreach等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String temp : list) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.util.ConcurrentModificationException&lt;br/&gt; at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:&lt;span&gt;901&lt;/span&gt;)&lt;br/&gt; at java.util.ArrayList$Itr.next(ArrayList.java:&lt;span&gt;851&lt;/span&gt;)&lt;br/&gt; at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种在&lt;code&gt;foreach&lt;/code&gt;循环中调用&lt;code&gt;remove&lt;/code&gt;方法删除元素，可能会报&lt;code&gt;ConcurrentModificationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想在遍历集合时，删除其中的元素，可以用for循环，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) {&lt;br/&gt;            String temp = list.get(i);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;c&quot;&lt;/span&gt;.equals(temp)) {&lt;br/&gt;                list.remove(temp);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[a, b]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.避免随意打印日志&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们写代码的时候，打印日志是必不可少的工作之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为日志可以帮我们快速定位问题，判断代码当时真正的执行逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但打印日志的时候也需要注意，不是说任何时候都要打印日志，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    log.info(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;    log.info(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有些查询接口，在日志中打印出了请求参数和接口返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋一看没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果ids中传入值非常多，比如有1000个。而该接口被调用的频次又很高，一下子就会打印大量的日志，用不了多久就可能把&lt;code&gt;磁盘空间&lt;/code&gt;打满。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真的想打印这些日志该怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/query&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(@RequestBody List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;request params:{}&quot;&lt;/span&gt;, ids);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    List&amp;lt;User&amp;gt; userList = userService.query(ids);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (log.isDebugEnabled()) {&lt;br/&gt;        log.debug(&lt;span&gt;&quot;response:{}&quot;&lt;/span&gt;, userList);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userList;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;isDebugEnabled&lt;/code&gt;判断一下，如果当前的日志级别是&lt;code&gt;debug&lt;/code&gt;才打印日志。生产环境默认日志级别是&lt;code&gt;info&lt;/code&gt;，在有些紧急情况下，把某个接口或者方法的日志级别改成debug，打印完我们需要的日志后，又调整回去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便我们定位问题，又不会产生大量的垃圾日志，一举两得。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.比较时把常量写前面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在比较两个参数值是否相等时，通常我们会使用&lt;code&gt;==&lt;/code&gt;号，或者&lt;code&gt;equals&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在第15章节中说过，使用&lt;code&gt;==&lt;/code&gt;号比较两个值是否相等时，可能会存在问题，建议使用&lt;code&gt;equals&lt;/code&gt;方法做比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt;(user.getName().equals(&lt;span&gt;&quot;苏三&quot;&lt;/span&gt;)) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面这段代码中，如果user对象，或者user.getName()方法返回值为&lt;code&gt;null&lt;/code&gt;，则都报&lt;code&gt;NullPointerException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何避免空指针异常呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String FOUND_NAME = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt; == user) {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(FOUND_NAME.equals(user.getName())) {&lt;br/&gt;   System.out.println(&lt;span&gt;&quot;找到：&quot;&lt;/span&gt;+user.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用&lt;code&gt;equals&lt;/code&gt;做比较时，尽量将&lt;code&gt;常量&lt;/code&gt;写在前面，即equals方法的左边。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样即使user.getName()返回的数据为null，equals方法会直接返回false，而不再是报空指针异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.名称要见名知意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java中没有强制规定参数、方法、类或者包名该怎么起名。但如果我们没有养成良好的起名习惯，随意起名的话，可能会出现很多奇怪的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.1 有意义的参数名&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们写代码时为了省事（可以少敲几个字母），参数名起得越简单越好。假如同事A写的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String c = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; b = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一段时间之后，同事A离职了，同事B接手了这段代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他此时一脸懵逼，a是什么意思，b又是什么意思，还有c...然后心里一万个草泥马。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给参数起一个有意义的名字，是非常重要的事情，避免给自己或者别人埋坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正解：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; purchaserCount = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;String userName = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; hasSuccess = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.2 见名知意&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光起有意义的参数名还不够，我们不能就这点追求。我们起的参数名称最好能够&lt;code&gt;见名知意&lt;/code&gt;，不然就会出现这样的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String yongHuMing = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String 用户Name = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String su3 = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String suThree = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几种参数名看起来是不是有点怪怪的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥不定义成国际上通用的（地球人都能看懂）英文单词呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String userName = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;String susan = &lt;span&gt;&quot;苏三&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这两个参数名，基本上大家都能看懂，减少了好多沟通成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议在定义不管是参数名、方法名、类名时，优先使用国际上通用的英文单词，更简单直观，减少沟通成本。少用汉子、拼音，或者数字定义名称。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;27.3 参数名风格一致&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参数名其实有多种风格，列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//字母全小写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; suppliercount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//字母全大写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIERCOUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//小写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplier_count = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//大写字母 + 下划线&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//驼峰标识&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个类中定义了多种风格的参数名称，看起来是不是有点杂乱无章？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议类的成员变量、局部变量和方法参数使用supplierCount，这种&lt;code&gt;驼峰风格&lt;/code&gt;，即：第一个字母小写，后面的每个单词首字母大写。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; supplierCount = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，为了好做区分，静态常量建议使用SUPPLIER_COUNT，即：&lt;code&gt;大写字母&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; &lt;code&gt;下划线&lt;/code&gt;分隔的参数名。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SUPPLIER_COUNT = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.SimpleDateFormat线程不安全&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前，我们对时间的格式化处理，一般都是用的&lt;code&gt;SimpleDateFormat&lt;/code&gt;类实现的。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你真的这样写，是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就怕哪天抽风，你觉得dateFormat是一段固定的代码，应该要把它抽取成常量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是把代码改成下面的这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SimpleDateFormatService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SimpleDateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(String time)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ParseException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dateFormat.parse(time);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dateFormat对象被定义成了静态常量，这样就能被所有对象共用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只有一个线程调用time方法，也不会出现问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但Serivce类的方法，往往是被Controller类调用的，而Controller类的接口方法，则会被&lt;code&gt;tomcat&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;调用。换句话说，可能会出现多个线程调用同一个Controller类的同一个方法，也就是会出现多个线程会同时调用time方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而time方法会调用&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的&lt;code&gt;parse&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Date &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(String text, ParsePosition pos)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    Date parsedDate;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        parsedDate = calb.establish(calendar).getTime();&lt;br/&gt;        ...&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IllegalArgumentException e) {&lt;br/&gt;        pos.errorIndex = start;&lt;br/&gt;        pos.index = oldStart;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; parsedDate;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法会调用&lt;code&gt;establish&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Calendar &lt;span&gt;establish&lt;/span&gt;&lt;span&gt;(Calendar cal)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;//1.清空数据&lt;/span&gt;&lt;br/&gt;    cal.clear();&lt;br/&gt;    &lt;span&gt;//2.设置时间&lt;/span&gt;&lt;br/&gt;    cal.set(...);&lt;br/&gt;    &lt;span&gt;//3.返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cal;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的步骤1、2、3是非原子操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果cal对象是局部变量还好，坏就坏在parse方法调用establish方法时，传入的calendar是&lt;code&gt;SimpleDateFormat&lt;/code&gt;类的父类&lt;code&gt;DateFormat&lt;/code&gt;的成员变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateFormat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Forma&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ....&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Calendar calendar;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就可能会出现多个线程，同时修改同一个对象即：dateFormat，它的同一个成员变量即：Calendar值的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可能会出现，某个线程设置好了时间，又被其他的线程修改了，从而出现时间错误的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;SimpleDateFormat类的对象不要定义成静态的，可以改成方法的局部变量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ThreadLocal保存SimpleDateFormat类的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用java8的DateTimeFormatter类。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.少用Executors创建线程池&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK5&lt;/code&gt;之后，提供了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，用它可以&lt;code&gt;自定义线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程池的好处有很多，下面主要说说这3个方面。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;降低资源消耗&lt;/code&gt;：避免了频繁的创建线程和销毁线程，可以直接复用已有线程。而我们都知道，创建线程是非常耗时的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提供速度&lt;/code&gt;：任务过来之后，因为线程已存在，可以拿来直接使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;提高线程的可管理性&lt;/code&gt;：线程是非常宝贵的资源，如果创建过多的线程，不仅会消耗系统资源，甚至会影响系统的稳定。使用线程池，可以非常方便的创建、管理和监控线程。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然JDK为了我们使用更便捷，专门提供了：&lt;code&gt;Executors&lt;/code&gt;类，给我们快速创建&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类中包含了很多&lt;code&gt;静态方法&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：创建一个可缓冲的线程，如果线程池大小超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：创建一个固定大小的线程池，如果任务数量超过线程池大小，则将多余的任务放到队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;：创建一个固定大小，并且能执行定时周期任务的线程池。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：创建只有一个线程的线程池，保证所有的任务安装顺序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，如果大家使用这些静态方法创建线程池，会有一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们一起看看有哪些问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newFixedThreadPool&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;：允许请求的队列长度是Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;newCachedThreadPool&lt;/code&gt;：允许创建的线程数是Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们该怎办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先推荐使用&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类，我们自定义线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ExecutorService threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;br/&gt;    &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;//corePoolSize线程池中核心线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;//maximumPoolSize 线程池中最大线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;//线程池中线程的最大空闲时间，超过这个时间空闲线程将被回收&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS,&lt;span&gt;//时间单位&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue(&lt;span&gt;500&lt;/span&gt;), &lt;span&gt;//队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy()); &lt;span&gt;//拒绝策略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，如果是一些低并发场景，使用&lt;code&gt;Executors&lt;/code&gt;类创建线程池也未尝不可，也不能完全一棍子打死。在这些低并发场景下，很难出现&lt;code&gt;OOM&lt;/code&gt;问题，所以我们需要根据实际业务场景选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.Arrays.asList转换的集合别修改&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们日常工作中，经常需要把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数组的长度是固定的，不太好扩容，而List的长度是可变的，它的长度会根据元素的数量动态扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JDK的&lt;code&gt;Arrays&lt;/code&gt;类中提供了&lt;code&gt;asList&lt;/code&gt;方法，可以把&lt;code&gt;数组&lt;/code&gt;转换成&lt;code&gt;List&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;正例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String [] array = &lt;span&gt;new&lt;/span&gt; String [] {&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，使用Arrays.asList方法将array数组，直接转换成了list。然后在for循环中遍历list，打印出它里面的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果转换后的list，只是使用，没新增或修改元素，不会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;反例&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String[] array = &lt;span&gt;new&lt;/span&gt; String[]{&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(array);&lt;br/&gt;list.add(&lt;span&gt;&quot;d&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String str : list) {&lt;br/&gt;    System.out.println(str);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.UnsupportedOperationException&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;148&lt;/span&gt;)&lt;br/&gt;at java.util.AbstractList.add(AbstractList.java:&lt;span&gt;108&lt;/span&gt;)&lt;br/&gt;at com.sue.jump.service.test1.Test2.main(Test2.java:&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会直接报&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Arrays.asList&lt;/code&gt;方法转换后的&lt;code&gt;ArrayList&lt;/code&gt;，是&lt;code&gt;Arrays&lt;/code&gt;类的内部类，并非&lt;code&gt;java.util&lt;/code&gt;包下我们常用的&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Arrays类的内部ArrayList类，它没有实现父类的add和remove方法,用的是父类AbstractList的默认实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;AbstractList&lt;/code&gt;是如何实现的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; E &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类的&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;remove&lt;/code&gt;方法直接抛异常了，因此调用Arrays类的内部ArrayList类的add和remove方法，同样会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，Java代码优化是一个比较大的话题，它里面可以优化的点非常多，我没办法一一列举完。在这里只能抛砖引玉，介绍一下比较常见的知识点，更全面的内容，需要小伙伴们自己去思考和探索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章写了很久，花了很多时间和心思，如果你看了文章有些收获，记得给我点赞鼓励一下喔。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>