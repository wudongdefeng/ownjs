<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e966677c2f9bee21e4ca708cae9da564</guid>
<title>RedisJson 横空出世，这性能杀疯了！</title>
<link>https://toutiao.io/k/y4wdv6t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近期官网给出了RedisJson（RedisSearch）的性能测试报告，可谓碾压其他NoSQL，下面是核心的报告内容，先上结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于隔离写入(isolated writes)，RedisJSON 比 MongoDB 快 5.4 倍，比 ElasticSearch 快 200 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于隔离读取(isolated reads)，RedisJSON 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在混合工作负载场景中，实时更新不会影响 RedisJSON 的搜索和读取性能，而 ElasticSearch 会受到影响。以下是具体的数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 支持的操作数/秒比 MongoDB 高约 50 倍，比 ElasticSearch 高 7 倍/秒。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON* 的延迟比 MongoDB 低约 90 倍，比 ElasticSearch 低 23.7 倍。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON 的读取、写入和负载搜索延迟在更高的百分位数中远比 ElasticSearch 和 MongoDB 稳定。当增加写入比率时，RedisJSON 还能处理越来越高的整体吞吐量，而当写入比率增加时，ElasticSearch 会降低它可以处理的整体吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、查询引擎&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如前所述，reresearch和RedisJSON的开发非常强调性能。对于每一个版本，我们都想确保开发者可以体验到稳定和产品。为此，我们我们给出了一些分析工具、探测器来进行性能分析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，我们每次发行新版本时时，也在不断的提升性能。特别是对于reresearch来说，2.2版本在加载和查询性能上都比2.0快了1.7倍，同时还改进了吞吐量和数据加载的延迟。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 加载优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的两个图显示了运行纽约市出租车基准测试的运行结果&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOouUUmLMqP94KHoG85Mpgbawqb3lXIN8UyVAfS5bJ36bRnGomLcMRTZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo2QA3eUh1wNVHB9BrptR4y68ibjYicglGW1VCLraaN1errGw3ChXDrYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这些图表中可以看出，每一个reresearch的新版本都有一个实质性的性能改进。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 全文搜索优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估搜索性能，我们索引了590万篇维基百科摘要。然后我们运行一个全文搜索查询面板，得到的结果如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.583791895947974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoQ1bib9tUV4VWib0uXLP99O5Zv0xKzCBlwVr0LM1ngpHXmibB1eMTbstOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.624312156078039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoVnXV6q7ibg0IwMR40f64ia5HsWzREt0fBjuFAejFrgFq2T7Z7N7ibz5PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1999&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图可以看出，通过从v2.0迁移到v2.2，同样的数据，在写、读、搜索(延迟图)方面都有了大幅度的改进，从而提高了运行Search和JSON的可实现吞吐量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、和其他框架的对比&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了评估RedisJSON的性能，我们决定将它与MongoDB和ElasticSearch进行比较。为了方便对比，我们会从文档存储、本地可用、云中可用、专业支持和提供可伸缩性、性能等方面进行全方位的对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用了完善的YCSB标准来进行测试对比，它能够基于常见的工作负载来评估不同的产品，测量延迟、吞吐量曲线直到饱和。除了CRUD YCSB操作之外，我们还添加了一个两个字的搜索操作，专门帮助开发人员、系统架构师和DevOps从业者找到适合他们用例的最佳搜索引擎。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 基准测试&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次测试，我们使用了如下的一些软件环境：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MongoDB v5.0.3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ElasticSearch 7.15&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RedisJSON (RediSearch 2.2+RedisJSON 2.0)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此次是在Amazon Web Services 实例上运行基准测试，这三种解决方案都是分布式数据库，并且最常用于生产中的分布式方式。这就是为什么所有产品都使用相同的通用 m5d.8xlarge VM 和本地 SSD，并且每个设置由四个 VM 组成：一个客户端 + 三个数据库服务器。基准测试客户端和数据库服务器都在处于最佳网络条件下的单独 m5d.8xlarge 实例上运行，将实例紧密地打包在一个可用区内，实现稳态分析所需的低延迟和稳定的网络性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试是在三节点集群上执行的，部署细节如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MongoDB 5.0.3&lt;/code&gt;：三成员副本集（Primary-Secondary-Secondary）。副本用于增加读取容量并允许更低的延迟读取。为了支持对字符串内容的文本搜索查询，在搜索字段上创建了一个文本索引。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ElasticSearch 7.15&lt;/code&gt;：15 个分片设置，启用查询缓存，并为 2 个基于 NVMe 的本地 SSD 提供 RAID 0 阵列，以实现更高级别的文件系统相关弹性操作性能。这 15 个分片为我们为 Elastic 所做的所有分片变体提供了可实现的最佳性能结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;RedisJSON*&lt;/code&gt;：RediSearch 2.2 and RedisJSON 2.0: OSS Redis Cluster v6.2.6，有27个分片，均匀分布在三个节点上，加载了RediSearch 2.2和RedisJSON 2.0 OSS模块。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这个主要的基准/性能分析场景之外，我们还在网络、内存、CPU 和 I/O 上运行基准基准测试，以了解底层网络和虚拟机特性。在整个基准测试集期间，网络性能保持在带宽和 PPS 的测量限制以下，以产生稳定稳定的超低延迟网络传输（每个数据包 p99 &amp;lt; 100micros）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们将从提供单独的操作性能 [100% 写入] 和 [100% 读取] 开始，并以一组混合工作负载结束以模拟现实工作中的应用程序场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 100% 写入基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，该基准测试表明，RedisJSON* 的摄取速度比 ElasticSearch 快 8.8 倍，比 MongoDB 快 1.8 倍，同时保持每个操作的亚毫秒级延迟。值得注意的是，99% 的 Redis 请求在不到 1.5 毫秒的时间内完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，RedisJSON* 是我们测试过的唯一一种在每次写入时自动更新其索引的解决方案。这意味着任何后续的搜索查询都会找到更新的文档。ElasticSearch 没有这种细粒度的容量；它将摄取的文档放在一个内部队列中，并且该队列由服务器（不受客户端控制）每 N 个文档或每 M 秒刷新一次。他们称这种方法为近实时 (NRT)。Apache Lucene 库（它实现了 ElasticSearch 的全文功能）旨在快速搜索，但索引过程复杂且繁重。如这些 WRITE 基准测试图表所示，由于这种“设计”限制，ElasticSearch 付出了巨大的代价。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合延迟和吞吐量改进，RedisJSON* 比 Mongodb 快 5.4 倍，比 ElasticSearch 快 200 倍以上，用于隔离写入。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo611nYGmaGGrcVeWIiaMTxFOhlSibia3uibp6RJzBIWhsMcJHGSHRCl5GnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoY4jdTU9WZ3ibIpicV9VothEic8RZDKh3aia9WEybIMicaI70jusuXpoMe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 100% 读取基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与写类似，我们可以观察到 Redis 在读取方面表现最佳，允许读取比 ElasticSearch 多 15.8 倍，比 MongoDB 多 2.8 倍，同时在整个延迟范围内保持亚毫秒级延迟，如下表所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在结合延迟和吞吐量改进时，RedisJSON* 比 MongoDB 快 12.7 倍，比 ElasticSearch 快 500 倍以上，用于隔离读取。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5636574074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo6TfKUcIy5oaI2pqQgoQnC0CBXDw6TukKDaBqkZBmjRAU6sFHHI1z6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.618421052631579&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOovwFn6X4ALlkicQX45iallAqcaXDV7WzEFFDWTSfN5hWQxBWSSV0Jk6oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1520&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 混合读/写/搜索基准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际应用程序工作负载几乎总是读取、写入和搜索查询的混合。因此，在接近饱和时了解由此产生的混合工作负载吞吐量曲线更为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为起点，我们考虑了 65% 搜索和 35% 读取的场景，这代表了一个常见的现实世界场景，在该场景中，我们执行的搜索/查询比直接读取更多。65% 搜索、35% 读取和 0% 更新的初始组合也导致 ElasticSearch 和 RedisJSON* 的吞吐量相等。尽管如此，YCSB 工作负载允许您指定搜索/读取/更新之间的比率以满足您的要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“搜索性能”可以指不同类型的搜索，例如“匹配查询搜索”、“分面搜索”、“模糊搜索”等等。我们所做的最初向 YCSB 增加的搜索工作负载仅专注于“匹配查询搜索”，模仿分页的两词查询匹配，按数字字段排序。“匹配查询搜索”是任何启用搜索功能的供应商进行搜索分析的起点，因此，每个支持 YCSB 的数据库/驱动程序都应该能够在其基准驱动程序上轻松启用此功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每个测试变体中，我们添加了 10% 的写入，以按相同的比例混合和减少搜索和读取百分比。这些测试变体的目标是了解每个产品如何处理数据的实时更新，我们认为这是事实上的架构目标，即写入立即提交到索引，读取始终是最新的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6423444976076556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOo0yed0ibm9bF1AplAt4TgcS42aFwUfR28C1tCuC4484bypMia942nGOTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1672&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如您在图表中所看到的，在 RedisJSON* 上不断更新数据和增加写入比例不会影响读取或搜索性能并提高整体吞吐量。对数据产生的更新越多，对 ElasticSearch 性能的影响就越大，最终导致读取和搜索速度变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ElasticSearch 可实现的 ops/sec 从 0% 更新到 50% 的演变，我们注意到它在 0% 更新基准上以 10k Ops/sec 开始，并受到严重影响，减少了 5 倍的 ops/sec，在50% 更新率基准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与我们在上述单个操作基准中观察到的类似，MongoDB 搜索性能比 RedisJSON* 和 ElasticSearch 慢两个数量级，MongoDB 的最大总吞吐量为 424 ops/sec，而 RedisJSON* 为 16K 最大 ops/sec。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，对于混合工作负载，RedisJSON* 支持的操作数/秒比 MongoDB 高 50.8 倍，比 ElasticSearch 高 7 倍。如果我们将分析集中在混合工作负载期间的每种操作类型的延迟上，与 MongoDB 相比，RedisJSON* 可将延迟降低多达 91 倍，与 ElasticSearch 相比，延迟降低 23.7 倍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5 完整延迟分析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与测量每个解决方案饱和之前产生的吞吐量曲线类似，在所有解决方案通用的可持续负载下进行完整的延迟分析也很重要。这将使您能够了解对于所有已发布操作在延迟方面最稳定的解决方案是什么，以及哪种解决方案不易受到应用程序逻辑引发的延迟峰值的影响（例如，弹性查询缓存未命中）。如果您想更深入地了解我们为什么要这样做，Gil Tene 提供了延迟测量注意事项的深入概述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看上一节的吞吐量图表，并关注 10% 更新基准以包含所有三个操作，我们做了两种不同的可持续负载变化：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;250 ops/sec&lt;/code&gt;：比较 MongoDB、ElasticSearch 和 RedisJSON*，低于 MongoDB 的压力率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;6000 ops/sec&lt;/code&gt;：比较 ElasticSearch 和 RedisJSON*，低于 ElasticSearch 压力率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.1 MongoDB 与 ElasticSearch 与 RedisJSON* 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的第一张图片中，展示了从 p0 到 p9999 的百分位数，很明显，在每次搜索时，MongoDB 的表现都远远优于 Elastic 和 RedisJSON&lt;em&gt;。此外，关注 ElasticSearch 与 RedisJSON&lt;/em&gt;，很明显，ElasticSearch 容易受到较高延迟的影响，这很可能是由垃圾收集 (GC) 触发器或搜索查询缓存未命中引起的。RedisJSON* 的 p99 低于 2.61 毫秒，而 ElasticSearch p999 搜索达到 10.28 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoSIgCOft3OEc0H9BW2zQQyF1diamfHdHXyxFxgBfIvy6lSBM6Ldhnu6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的读取和更新图表中，我们可以看到 RedisJSON* 在所有延迟范围内表现最佳，其次是 MongoDB 和 ElasticSearch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 是在所有分析的延迟百分位数上保持亚毫秒级延迟的唯一解决方案。在 p99，RedisJSON* 的延迟为 0.23 毫秒，其次是 MongoDB 的 5.01 毫秒和 ElasticSearch 的 10.49 毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoJN5FLx51FRmGNXYV4cJHPr2lHpha5T9RYtfZWjGnaXy5zmFw0D7k3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入时，MongoDB 和 RedisJSON* 即使在 p99 时也能保持亚毫秒级的延迟。另一方面，ElasticSearch 显示出高尾延迟（&amp;gt; 10 毫秒），这很可能与导致 ElasticSearch 搜索峰值的原因 (GC) 相同。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoAicsbeISKwnTjxmRicsZ6RWjcVpib7Q32nB05bhgtc1MuHGnzoUXbzA8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.5.2 ElasticSearch 与 RedisJSON 的延迟分析&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅关注 ElasticSearch 和 RedisJSON&lt;em&gt;，在保持 6K ops/sec 的可持续负载的同时，我们可以观察到 Elastic 和 RedisJSON&lt;/em&gt; 的读取和更新模式与以 250 ops/sec 进行的分析保持一致。RedisJSON* 是更稳定的解决方案，其 p99 读取时间为 3 毫秒，而 Elastic 的 p99 读取时间为 162 毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新时，RedisJSON* 保留了 3 毫秒的 p99，而 ElasticSearch 则保留了 167 毫秒的 p99。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoLoJVvKgRRI3rmCNLzUjCvpk1MA5l6Ioxqm7dPF6qf2vrqoSIQ2hgOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOohq9AdiaxdPAohSbybaM0Iwey2nQD6GEt0v1nwW8oxnhic8fzcdhBGvPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专注于搜索操作，ElasticSearch 和 RedisJSON* 以个位数 p50 延迟开始（p50 RedisJSON* 为 1.13 毫秒，而 ElasticSearch 的 p50 为 2.79 毫秒），其中 ElasticSearch 付出了 GC 触发和查询缓存未命中的代价在较高的百分位数上，在 &amp;gt;= p90 百分位数上清晰可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedisJSON* 将 p99 保持在 33 毫秒以下，而 ElasticSearch 上的 p99 百分位数为 163 毫秒，高出 5 倍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6fuT3emWI5Ipdw76Gcm7InE3HCCH8iaOoKUACUUMo6ttA42WSADP4nRFwA1PsibTDibRpwGAj7g5bnicy3BW0K56qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、如何开始&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始使用RedisJSON*，我们可以创建一个免费的数据库在所有地区的Redis云，或者使用RedisJSON docker容器。我们已经更新了redisjson的文档，以方便开发者快速的开始使用查询和搜索功能。此外，正如我们在最近的客户机库声明中提到的，以下是几种流行语言的客户机驱动程序，可以帮助您快速入门。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;RedisJSON*&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Node.js&lt;/td&gt;&lt;td&gt;node-redis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;Jedis&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;.NET&lt;/td&gt;&lt;td&gt;NRedisJSON NRediSearch&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Python&lt;/td&gt;&lt;td&gt;redis-py&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>99ca66fcc49e4d9f2325fbe3bfdec968</guid>
<title>看Go中的struct如何被优化，还有小插曲</title>
<link>https://toutiao.io/k/zv2dasc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;struct中的字段顺序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下面的结构为例，咱们看看下面的结构体：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;       &lt;span&gt;// Sizeof: 8 byte  Alignof: 8  Offsetof: 0&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 8&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 16&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;      &lt;span&gt;// Sizeof: 16 byte Alignof: 8 Offsetof: 32&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;        &lt;span&gt;// Sizeof: 1 byte  Alignof: 1  Offsetof: 48&lt;/span&gt;&lt;br/&gt;    Created     time.Time   &lt;span&gt;// Sizeof: 24 byte Alignof: 8  Offsetof: 56&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// output&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的输出可以看出打印结果为 80 字节，但是所有字段加起来是66 字节。那额外的 14 个字节是怎么来的呢？想必大部分同学也很清楚。64 位CPU处理器每次可以以 64 位（8 字节）块的形式传输数据。32 位 CPU的话则是32 位（4 字节）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个字段&lt;code&gt;ID&lt;/code&gt;占用 8 个字节，&lt;code&gt;Gender&lt;/code&gt;字段占用了1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个和第三个字段为字符串类型为16字节，接下来是&lt;code&gt;IsDeleted&lt;/code&gt;字段，它需要 1 个字节并有 7 个未使用的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好的情况是是按字段的大小从大到小对字段进行排序。对上述结构体进行排序，大小减少到 72 个字节。最后两个字段 &lt;code&gt;Gender&lt;/code&gt; 和 &lt;code&gt;IsDeleted&lt;/code&gt; 被放在同一个块中，从而将未使用的字节数从 14 (2x7) 减少到 6 (1 x 6)，在此过程中节省了 8 个字节。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; People &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    CreatedAt   time.Time &lt;span&gt;// 24 bytes&lt;/span&gt;&lt;br/&gt;    NickName    &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    Description &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;// 16 bytes&lt;/span&gt;&lt;br/&gt;    ID          &lt;span&gt;int64&lt;/span&gt;     &lt;span&gt;// 8 bytes&lt;/span&gt;&lt;br/&gt;    Gender      &lt;span&gt;int8&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;    IsDeleted   &lt;span&gt;bool&lt;/span&gt;      &lt;span&gt;// 1 byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    p := People{}&lt;br/&gt;    fmt.Println(unsafe.Sizeof(p))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面咱们看看&lt;span&gt;Go 白皮书&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;中对字节大小保证的一些说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于&lt;span&gt;数字类型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，有下面的大小保证：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;占用字节大小&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte, uint8, int8&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint16, int16&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint32, int32, float32&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;uint64, int64, float64, complex64&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;complex128&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证以下最小对齐属性：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任何类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于struct 类型的变量&lt;code&gt;x&lt;/code&gt;：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;是所有字段字节对齐的最大值&lt;code&gt;unsafe.Alignof(x.f)&lt;/code&gt;，但至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量&lt;code&gt;x&lt;/code&gt; ：&lt;code&gt;unsafe.Alignof(x)&lt;/code&gt;与数组元素类型的变量的对齐方式相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果struct或数组类型不包含大小大于零的字段（或元素），则其大小为零。两个不同的零大小变量在内存中可能具有相同的地址。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出占用小于8 字节的 Go 类型有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;bool：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int8/uint8：1 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int16/uint16：2 个字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int32/uint32/rune：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;float32：4 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte：1个字节&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么你知道了这些小于8字节的类型，要手动检查他的大小然后对其进行排序嘛，NONONO，小土下面给大家推荐一个&lt;code&gt;linter&lt;/code&gt; &lt;span&gt;fieldalignment&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;来检查并进行正确地排序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;fieldalignment 小工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里小土给大家介绍一个检测和对齐结构体字段的小工具&lt;code&gt;fieldalignment&lt;/code&gt;,顾名思义就是&lt;strong&gt;字段对齐&lt;/strong&gt;的意思。下面让我们在项目中安装和运行一下&lt;code&gt;fieldalignment&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$go&lt;/span&gt; install golang.org/x/tools/go/analysis/passes/fieldalignment/cmd/fieldalignment@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先别着急运行，咱们先来看下filedalignment的使用，fieldalignment可以找到那些可以重新排列以减少内存的结构，并提供
建议编辑最紧凑的顺序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ fieldalignment&lt;br/&gt;fieldalignment: find structs that would use less memory &lt;span&gt;if&lt;/span&gt; their fields were sorted&lt;br/&gt;&lt;br/&gt;Usage: fieldalignment [-flag] [package]&lt;br/&gt;&lt;br/&gt;This analyzer find structs that can be rearranged to use less memory, and provides&lt;br/&gt;a suggested edit with the most compact order.&lt;br/&gt;&lt;br/&gt;Note that there are two different diagnostics reported. One checks struct size,&lt;br/&gt;and the other reports &lt;span&gt;&quot;pointer bytes&quot;&lt;/span&gt; used. Pointer bytes is how many bytes of the&lt;br/&gt;object that the garbage collector has to potentially scan &lt;span&gt;for&lt;/span&gt; pointers, &lt;span&gt;for&lt;/span&gt; example:&lt;br/&gt;&lt;br/&gt;        struct { uint32; string }&lt;br/&gt;&lt;br/&gt;have 16 pointer bytes because the garbage collector has to scan up through the string&lt;span&gt;&#x27;s&lt;br/&gt;inner pointer.&lt;br/&gt;&lt;br/&gt;        struct { string; *uint32 }&lt;br/&gt;&lt;br/&gt;has 24 pointer bytes because it has to scan further through the *uint32.&lt;br/&gt;&lt;br/&gt;        struct { string; uint32 }&lt;br/&gt;&lt;br/&gt;has 8 because it can stop immediately after the string pointer.&lt;br/&gt;&lt;br/&gt;Be aware that the most compact order is not always the most efficient.&lt;br/&gt;In rare cases it may cause two variables each updated by its own goroutine&lt;br/&gt;to occupy the same CPU cache line, inducing a form of memory contention&lt;br/&gt;known as &quot;false sharing&quot; that slows down both goroutines.&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Flags:&lt;br/&gt;  -V    print version and exit&lt;br/&gt;  -all&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -c int&lt;br/&gt;        display offending line with this many lines of context (default -1)&lt;br/&gt;  -cpuprofile string&lt;br/&gt;        write CPU profile to this file&lt;br/&gt;  -debug string&lt;br/&gt;        debug flags, any subset of &quot;fpstv&quot;&lt;br/&gt;  -fix&lt;br/&gt;        apply all suggested fixes&lt;br/&gt;  -flags&lt;br/&gt;        print analyzer flags in JSON&lt;br/&gt;  -json&lt;br/&gt;        emit JSON output&lt;br/&gt;  -memprofile string&lt;br/&gt;        write memory profile to this file&lt;br/&gt;  -source&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -tags string&lt;br/&gt;        no effect (deprecated)&lt;br/&gt;  -test&lt;br/&gt;        indicates whether test files should be analyzed, too (default true)&lt;br/&gt;  -trace string&lt;br/&gt;        write trace log to this file&lt;br/&gt;  -v    no effect (deprecated)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看帮助的说明这里小土总结一下fieldalignment的介绍：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fieldalignment 会有两个不同的报告，一个是检查结构体的大小。另一个报告所使用的指针字节数(是指gc会对struct中的这些字节进行潜在的指针扫描)。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;struct { uint32; string } ：16个指针字节，gc会扫描字符串的内部指针。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; *uint32 } : 24个指针字节，gc会进一步扫描 *uint32。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;struct { string; uint32 }：8个指针字节，因为扫描到string会立马停止。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出最紧凑的顺序并不总是最有效的。在极少数情况下，它可能会导致两个变量分别被自己的goroutine更新占用同一个CPU缓存线，从而引起一种被称为 &quot;假共享 &quot;的内存争夺。这样会降低了两个goroutine的速度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;运行fieldalignment&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小土在项目中使用了&lt;code&gt;fieldalignment&lt;/code&gt;命令，可以看出检测出不少的不符合排序规则的struct，而且&lt;code&gt;fieldalignment&lt;/code&gt;将未对齐的字段进行了重新排序，再次执行可以看到就没有相关的提示了。从下面的检测信息中大家也可以看出未对齐的&lt;code&gt;struct&lt;/code&gt;中有8-64字节的空间浪费。&lt;code&gt;struct&lt;/code&gt;较多的项目，算下来也是一笔不小的开销(8B*1024=8K,觉得这些内存占用微不足道的同学也可以忽略哈)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$fieldalignment&lt;/span&gt; -fix ./...        &lt;br/&gt;... &lt;span&gt;# 前面代码就省略了&lt;/span&gt;&lt;br/&gt;struct with 2568 pointer bytes could be 2560&lt;br/&gt;struct with 56 pointer bytes could be 48&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct with 16 pointer bytes could be 8&lt;br/&gt;struct of size 80 could be 72&lt;br/&gt;struct with 200 pointer bytes could be 176&lt;br/&gt;struct with 104 pointer bytes could be 72&lt;br/&gt;struct with 80 pointer bytes could be 72&lt;br/&gt;struct with 32 pointer bytes could be 24&lt;br/&gt;struct with 40 pointer bytes could be 32&lt;br/&gt;struct with 104 pointer bytes could be 40&lt;br/&gt;struct with 72 pointer bytes could be 56&lt;br/&gt;struct of size 256 could be 248&lt;br/&gt;struct with 64 pointer bytes could be 48&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fieldalignment的小bug&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过小土前面一顿操作执行，在准备commit的时候发现之前struct中的注释居然变没了，于是小土也给Go官方提了一个小issue，&lt;span&gt;https://github.com/golang/go/issues/54333&lt;/span&gt;，都好几天了也都没给回复，sad😭，看来这问题有点微不足道。希望在大家使用&lt;code&gt;fieldalignment&lt;/code&gt;的时候注意这一点，小土是在fix之后进行了一些注释恢复。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下，小土开始对struct中的字段字节对齐做了一些分析并推荐了一个对struct中的字段顺序错乱fix的工具fieldalignment。希望今天的文章对大家有一些帮助，如有相关看法欢迎留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Go 白皮书: &lt;em&gt;https://go.dev/ref/spec#Size_and_alignment_guarantees&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;数字类型: &lt;em&gt;https://go.dev/ref/spec#Numeric_types&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;fieldalignment: &lt;em&gt;https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/fieldalignment&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03f9ddb7fd8f282f6a57ada300643fca</guid>
<title>go错误处理的一种实践</title>
<link>https://toutiao.io/k/oqb90id</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近写了个程序，因为是急活（貌似没有不急的...），所以这个程序又是我东拷一段，西粘一块拼出来的。代码写完了后，感觉这代码屎一样，都快把自己看哭了。真的是在心里边写别骂，先是骂以前做这个项目的人蠢，项目搞的跟屎一样，后来代码跑起来了，顺利交工后，变成了骂我自己蠢，这么写又不是不能用！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5616161616161616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicIFviaPQ7ACCjbrNlyFRqlKKia5fmgxWZWGWY6a17gH7RaliaSDKma7KkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;figcaption&gt;又不是不能用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在这个过程中，先不提项目里的业务逻辑、接口设计合不合理的事儿，这个我觉得在时间紧，加上人员更迭快的时候，正常人都会能粘就粘，不行了就再包一层，别改出线上问题了就行。有一点我把自己蠢哭的是，Go 的这个错误处理也太TM蠢了，一个程序我写了七八个错误判断，我给你们用伪代码描述一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;err, file :=  接收传文件(文件)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, fh :=  打开上传文件(file)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data := 把文件里的行记录解析/转换一下(row)&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data3 := 调一下第三方接口拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err, data2 := 调一下内部其他服务拿数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err := 写库&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  记日志&lt;br/&gt;  返回错误码相应&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子毫不夸张，我相信各位在自己的项目里一定见过，如果你是做业务开发的会更常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有人肯定会问，Go的错误处理就这样你难道第一天见吗，还能被蠢哭。诶，这不是降本提效后人员少了一半，我们这帮级别没混上去的虚线Leader，这不又开始自己写代码了嘛，以前蠢又蠢不到自己。再加上以前的系统、项目分层、服务隔离整的还凑活，不会像上面这样，在控制层调这么多业务对象，把蠢瓜代码集中在了一起…… 官感马上不一样了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是乎我就在思考，有没有什么设计模式什么的，能把这些东西隐藏下去，应该有吧，没有什么是包一层代码解决不了的吧，实在不行就包两层……诶，咋一不小心把设计模式的精髓给说出来了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 优雅处理错误的几种方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这几天在网上看了不少说，Go 错误处理的，但基本上都是说怎么自定义包装 error 、传递error 之类的，讲怎么在写 Go 代码时能更优雅更好看的文章比较少，写的最好的是左耳朵耗子老师在自己博客里介绍的两种方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;下面的部分代码参考自老师的博客：https://coolshell.cn/articles/21140.html&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种是用函数式编程的 Closure 把相同的 if err !=nil 之类的代码抽象出来重新定义一个函数，但是这种方式会导致新的问题--在每个函数里都需要引入内部函数和一个 error 变量，所以咱就不多说了，有兴趣的可以去原博文查看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接介绍另外一种更好的，对项目侵入不是很大的方案给大家。在 Go 语言官方库 &lt;code&gt;bufio&lt;/code&gt; 中 &lt;code&gt;Scanner&lt;/code&gt;对象的错处理的实现方式可以给我们一点启发，它大概是这么实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;scanner := bufio.NewScanner(input)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; scanner.Scan() {&lt;br/&gt;    token := scanner.Text()&lt;br/&gt;    &lt;span&gt;// process token&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err := scanner.Err(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// process the error&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码我们可以看到，&lt;code&gt;scanner&lt;/code&gt;在操作底层的I/O的时候，那个for-loop中没有任何的 &lt;code&gt;if err !=nil&lt;/code&gt; 的情况，退出循环后有一个 &lt;code&gt;scanner.Err()&lt;/code&gt; 的检查。看来使用了结构体的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下 &lt;code&gt;Scanner&lt;/code&gt;类型的定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Scanner &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; r            io.Reader&lt;br/&gt;  ...&lt;span&gt;//其他字段省略&lt;/span&gt;&lt;br/&gt; err          error    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类型内部持有一个&lt;code&gt;error&lt;/code&gt; 在迭代执行 Scan 方法时，遇到错误后会往这个 error 中记录错误。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Scan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ...&lt;span&gt;// 其余代码省略&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    s.setErr(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s *Scanner)&lt;/span&gt; &lt;span&gt;Err&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; s.err == io.EOF {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s.err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们可以参考这个思路继续搞下去。比如来一个读取业务对象的&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.0905797101449277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPiclkub7qO0hvlyqqop6sdYicVSXLY83m6F4jedVFqFuCgZUWZMuOdssqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个示例相信大家很容易看懂，不过，其使用场景也就只能在对于同一个业务对象的不断操作下可以简化错误处理，对于多个业务对象的话，还是得需要各种 &lt;code&gt;if err != nil&lt;/code&gt;的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法呢，咱们之前说过一次：没有什么是包一层代码解决不了的吧，实在不行就包两层。那么接下来我们再做一层包装，以下是我对解决这个问题的一点点理解，会借鉴一点DDD中分层的概念解决这个事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更容易落地的方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚才那个例子的问题是只适合减少单个业务对象逻辑操作中的 if err != nill 判断，那么针对这块呢，咱们可以把涉及多个业务对象的操作放在一个应用服务里，把刚才在业务对象做的错误处理判断拿到应用服务里，这样业务对象里，比如Model之类的下层模块里，就还能按照正常的流程写代码了，不用每个方法开头都要先判断一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里提前说一下，在一些架构设计里会分应用服务和领域服务，这两者的概念完全不一样，应用服务是面向产品需求的用例实现的，负责业务用例流的任务协调，就是我们实现API时，往往会控制层调应用服务，多个不同的业务对象可以放到一个应用服务里。而领域服务是专一给一个领域的，这块我就不多解释了，DDD这些我也是看了几本书，看过COLA框架的实现，还在似懂非懂的水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之记住一点，通过应用服务可以协调多个业务对象执行任务，同时我们上面业务对象加的那些错误处理抽离到应用服务层里，让业务对象更专注自己的职责。这样的话，你的服务层代码，可能就得变成了这样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7468531468531467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPicLT9DGCBN8n1SS9yt6xCe1Zkq3WafDmHws5Kx3RF1hmFO2CD22jibtww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们的控制层呢，调用应用服务层拿到结果，并且在这个时候判断整个需求任务执行的过程中有没有错误，有的话记录错误，返回错误响应给客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7300177619893428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f66PibzcbHs0m7xhJoicYzPPic8TuLH1LiaDZKvRLQJVtfTRdqsZVCzyKtfOITGkkCh3DyjhOOKiaMzG5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 错误处理的基础&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前分享过一篇文章  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247489442&amp;amp;idx=1&amp;amp;sn=1805944e5acbe8629fdfa534c53a27dd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;关于Go程序错误处理的一些建议&lt;/a&gt; 说的是我们应该怎么用好 Go 的error 接口，自定义错误，包装整个错误链等相关的技能。跟本文的内容关联起来看，可能会对错误处理有个更全局的理解，在这里也推荐给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享了一些在让Go代码的错误处理更优雅上，我学到和&lt;span data-change-font=&quot;1&quot;/&gt;想到的一些东西。其实大家可以发现，我们是把多个 if err != nil 分散到了多个方法里，这样代码最起码从感官上看起来比在一个方法里写七八个错误判断更好一点。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;分享软件开发和系统架构设计基础、Go 语言和Kubernetes。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对错误处理方面你有哪些见解呢，欢迎在评论区里积极发言，喜欢这篇文章还请帮忙来个点赞在看加分享吧，接下来内容还在向你们招手🙋‍♂️。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1667b5ea5d879639341656e1a920c1a0</guid>
<title>尤雨溪解读 2022 Web 前端生态趋势</title>
<link>https://toutiao.io/k/kublb5y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;尤大大从下面的三个前端领域的不同层次来展开了介绍：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;开发范式&amp;amp;底层框架（注：大家比较熟悉的Vue、React这些框架层面）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工具链（注：像webpack这样的构建工具）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上层框架（注：例如Next.js、Nuxt.js）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;正式分享之前，尤大大提出声明：“本分享只代表讲着个人观点，因为自己是框架和构建工具的作者，肯定会包含利益相关和个人的偏见，但是分享中会尽可能做客观的看法，大家多多多包涵”，下面就让我们饱享这顿“美味”吧！&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的内容是根据尤大大的分享进行了一定的抽离和少许的个人总结，如果内容出现歧义可以在评论区留言！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发范式&amp;amp;底层框架方面趋势&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过去几年中影响最大的开发范式层面的变化肯定就是我们的 &lt;code&gt;React Hooks&lt;/code&gt; 随着他的推出可以说是启发了很多组件逻辑表达和逻辑复用的新范式，在 &lt;code&gt;React&lt;/code&gt; 生态中彻底取代了 &lt;code&gt;Class Components&lt;/code&gt; ，包括现在其实很少能够在 &lt;code&gt;React&lt;/code&gt; 中看到 &lt;code&gt;Class Components&lt;/code&gt; 了，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，其实在其他的框架中 &lt;code&gt;React Hooks&lt;/code&gt; 也产生了很大的影响，比如说我们 &lt;code&gt;Vue&lt;/code&gt; 推出的 &lt;code&gt;Vue Composition API&lt;/code&gt; 组合式API，还包括受到 &lt;code&gt;React Hooks&lt;/code&gt; 的启发的 &lt;code&gt;Svelte3&lt;/code&gt; ，更有 &lt;code&gt;SolidJS&lt;/code&gt; 他是语法上相似于 &lt;code&gt;React Hooks&lt;/code&gt; 实现上更相似于 &lt;code&gt;Vue Composition API&lt;/code&gt; 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4015625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gq5rxbHKofP3VpvKJqL6D5yQjTG6MWo8LRrP6JtHHKJr8sLX33Xrqag/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 React Hooks 的推广和开发者对其的广泛使用，他开发中的一些体验问题也逐渐被正视，这里不可回避的一些体验问题的根本原因有以下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Hooks&lt;/code&gt; 执行原理和原生JS的心智模型的差异：因为 &lt;code&gt;React Hooks&lt;/code&gt; 是通过把组件的代码每一次更新都进行重复调用来模拟一些行为，从而导致反直觉的一些限制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可以条件式的调用 &lt;code&gt;React force&lt;/code&gt; ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Stale Closure&lt;/code&gt; 的心智负担：如果你不传正确的依赖数组，那么就会产生过期闭包；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必须手动声明 &lt;code&gt;use Effect&lt;/code&gt; 依赖；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何‘正确’使用 &lt;code&gt;use Effect&lt;/code&gt; 是个复杂的问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要 &lt;code&gt;useMemo/useCallback&lt;/code&gt; 等手动优化，否则的话就会不知不觉的导致一些性能问题；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤大大表示作为竞争框架的作者，对 React Hooks 框架的看法可能相对更直接一些，但这些也并非尤大大一个人的看法，而是近年来 React 社区和 React 团队也已经意识到的问题，当然 React 团队针对这些问题也在做改善的努力，据代表性的改善从下三个方面：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3359375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g6KibhXGLu2j77cK28PCcCM0icZwDSmfjLClgtq0mvvOg33AicaQOtLOBA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于依赖追踪范式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的这些改进之前，其实很多 React 的社区成员也包括一些本身就不适用 React 的用户来说，虽然 React Hooks 产生了重大的影响但是大家也意识到了他的一些问题，反而是一些跟 React Hooks 相似的一些逻辑组合能力，另一方面基于依赖追踪的范式开始重新得到了重视；比如在 React 内部的 Recoil ，当然在社区之外就有更多了比如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2890625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gS0KhdlGrqPCqawK1X0pGhXZLOrlOkXeeR5cia7FMzahva4c6r9JLFUA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看一下就基于依赖追踪的范式而言上面三个方案的代码：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SolidJS&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const [count,setCount] = createSignal(0)&lt;br/&gt;//副作用&lt;br/&gt;createEffect(() =&amp;gt; console.log(`&lt;span&gt;${count()`}&lt;/span&gt;&lt;br/&gt;//状态更新&lt;br/&gt;setCount(count() + 1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能够看出其实 SolidJS 和 React Hooks 非常相似&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;副作用中的 createEffect 跟 React 中的 use Effect 其实是类似的，但是 createEffect 并不需要去声明依赖，在调用 count 函数的时候其实帮你收集了依赖；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;状态更新的时候我们也并不需要用到 useCallback 这种额外的方式去创造函数来去传递给我们的事件侦听器；这些都是非常符合直觉的；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Vue Composition API&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const count = ref(0)&lt;br/&gt;//副作用&lt;br/&gt;watchEffect(() =&amp;gt; console.log(count.value))&lt;br/&gt;//状态更新&lt;br/&gt;count.value++&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 &lt;code&gt;Vue&lt;/code&gt; 中使用的 &lt;code&gt;Composition API&lt;/code&gt; 跟 &lt;code&gt;SolidJS&lt;/code&gt; 本质上的内部实现几乎是一样的，只不过 &lt;code&gt;SolidJS&lt;/code&gt; 看起来更像是 &lt;code&gt;React&lt;/code&gt; ，而 &lt;code&gt;Vue&lt;/code&gt; 是通过一个 ref 对象，对象上的 value 机可以读也可以写，在读和写之中就会自动的追踪和更新依赖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Ember Starbeam&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//状态&lt;br/&gt;const count = Cell(0)&lt;br/&gt;//副作用&lt;br/&gt;DEBUG_RENDERER.render({render: () =&amp;gt; console.log(count.current)})&lt;br/&gt;//状态更新&lt;br/&gt;count.set(prev =&amp;gt; prev + 1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Ember Starbeam&lt;/code&gt; 中的这个 &lt;code&gt;Cell&lt;/code&gt; 其实就和 &lt;code&gt;Vue&lt;/code&gt; 中的 &lt;code&gt;ref&lt;/code&gt; api 几乎是一样的，暴露出 &lt;code&gt;count&lt;/code&gt; 为当前的值和 &lt;code&gt;set&lt;/code&gt; 方法来进行状态的更新&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于依赖追踪范式—共同点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的三种基于依赖追踪的范式他们的共同点有什么呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.346875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gv2YM3IIfibR2uWkTfX0FZcMnrsNqofPe6uWkS7UjvmHKDTp1Ll6KiaqA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时以依赖追踪为一等功名概念的框架中，本身组件的设计肯定也是跟依赖追踪有紧密的结合，所以组件的更新渲染也会有自动的依赖追踪，也就是说组件的更新会更精确，而不再依赖于一个状态从父组件到子组件一层层传递下去，而是每一个即使是深层嵌套的组件也可以自发的更新，整体上的性能会更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;react&lt;/code&gt; 生态中的 &lt;code&gt;Recoil&lt;/code&gt; 这样的方案，虽然也提供了依赖自动的依赖追踪和一定程度的逐渐的更新优化，但是因为他们仍然是需要在 &lt;code&gt;React Hooks&lt;/code&gt; 的这个大的体系中使用的，所以在很多其他的方面依然会受制于 &lt;code&gt;hooks&lt;/code&gt; 的问题，那么 &lt;code&gt;Hooks&lt;/code&gt; 本身在这些方案之外，还是会存在过期闭包等等 user fact 这些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;React Hooks&lt;/code&gt; 确实是启发了一个新范式的时代，但是慢慢的我们也发现他自己自身存在的一些问题，当然 &lt;code&gt;React&lt;/code&gt; 团队正在试图解决这些问题，同时在 &lt;code&gt;React&lt;/code&gt; 体系之外，开始有一些其他的具有同等的逻辑组合能力，但同时避免了 &lt;code&gt;React Hooks&lt;/code&gt; 这些问题的这些方案存在，也渐渐的收到了前端社区的重视。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于编译的响应式系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3046875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gMvZeXMKwWAeaA2ia76ECCDLibVB5FIsW5Bb0UYpIzuWCndB4ibh8qhnNw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过即使是基于依赖追踪的方案，我们也可以进行一些基于编译时的这个优化，那这里首当其冲的就是 &lt;code&gt;Svelte3&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Svelte&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.453125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gfHaiaSkvHEtAXwPPVtxlrJ67g2ZSE98NTgYRDRCia0ib1YBThnfGHONuw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Svelte3&lt;/code&gt; 从一开始就是一个编译时优化方案，上面就是 &lt;code&gt;Svelte&lt;/code&gt; 组件中的一个使用状态的代码，我们看到他跟他的状态就是这个 &lt;code&gt;javaScript&lt;/code&gt; 的这个 &lt;code&gt;let&lt;/code&gt; 这样声明一个变量，就是一个响应式的状态，那么你要更新这个状态就直接去操作这个变量就可以，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;副作用是用一个神奇的编译式的魔法，也就是这个 &lt;code&gt;$&lt;/code&gt; ，&lt;span&gt;这个 &lt;/span&gt;&lt;code&gt;$&lt;/code&gt;&lt;span&gt; 的一个label，这其实是 &lt;/span&gt;&lt;code&gt;javaScript&lt;/code&gt;&lt;span&gt; 的一个label语法来声明， &lt;/span&gt;&lt;code&gt;$&lt;/code&gt;&lt;span&gt; 之后的这个语句会自动去追踪&lt;/span&gt;&lt;code&gt;count&lt;/code&gt;&lt;span&gt;这个变量的变化，当&lt;/span&gt;&lt;code&gt;count&lt;/code&gt;&lt;span&gt;变化的时候，这个语句就会自动重新执行，那么我们可以看到这个跟我们之前的这个几个代码范例，他所达成的目标其实是一致的，只是他使用编译的手段使代码变的更加简洁，但也正是因为简洁所以存在下面的限制：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gnnMvLyWLIkrAcwibRWia7g0QrwVYQ36vebYpONZ36ZBOgAicOSu2fHUWg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Vue Reactivity Transform&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也正是受到上方的限制的启发，Vue 在3.2的时候引入了一个实现性的功能 &lt;code&gt;Vue Reactivity Transform&lt;/code&gt; 响应式转换 ，下面就是 Vue 转化后的一段代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gIfwYbJy3rqtB8SZEJD3w2c4YYLye4OSiage6KeW4pibA4Vr84cBRIytA/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是一个简单的变量声明，但是我们用一个 $ref 这样的一个函数，这个函数其实是一个编译时的一个宏的概念，这个函数并不是真实存在的，只是给编译一个提示，那编译器通过编译之后就会把它转化成我们之前看到的基于真实的 ref 的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在使用时候，体验就变成了只是声明一个函数，然后使用这个变量和更新这个变量就跟使用一个普通 &lt;code&gt;javaScript&lt;/code&gt; 变量没有区别。同时这个语法因为在声明的时候会显式的声明，说哪个变量是响应声，哪个变量不是响应式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个语法可以在嵌套的函数中使用，也可以在 TS/JS 文件中使用，他并不限制于 Vue 文件，所以这是一个更加朴实的编译响应式模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Solid -labels&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4421875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gESWtnqvT1mic4PJ1Kooj8XiaBXEucgW2JncTQCzKuHaJSFVIGl6x2Ezw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;Solid&lt;/code&gt; 的生态中，其实也受启发于 &lt;code&gt;Vue Reactivity Transform&lt;/code&gt; ，他的社区用户做的一个 &lt;code&gt;Solid-label&lt;/code&gt;，也是基于 &lt;code&gt;Solid&lt;/code&gt; 的响应式方案，然后再做一层编译式的优化，那么可以看到跟 &lt;code&gt;Reactivity Transform&lt;/code&gt; 能够达成的效果是非常相似的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那最终的目的就是让大家可以用更简洁的代码去表达组件逻辑，同时又不放弃这个逻辑组合，像 &lt;code&gt;React Hooks&lt;/code&gt; 那样进行自由的逻辑组合的这些能力啊。所以说这也是一个很有意思的探索方向。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;统一模型的优势和代价&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gdhibliclic7ibdVhUv4iavmlMId5Tu0EG9lJNiaXGBNcvicEhickib0RKg5uu3w/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优势：&lt;/strong&gt; 和&lt;code&gt;Svelte&lt;/code&gt;相比，Vue的 &lt;code&gt;Reactivity Transform&lt;/code&gt; 和 &lt;code&gt;Solid \-labels&lt;/code&gt; 都属于统一模型，也就是他不受限于组件上下文，它可以在组建内使用，也可以在组建外使用，优势就是有利于长期的重构和复用，因为很多时候我们的大型项目中的逻辑复用都是在我们一个组件写着写着发现这个组件变得很臃肿，很大的时候我们才开始考虑要把逻辑开始重新组织抽取复用，那么由于 &lt;code&gt;Svelte&lt;/code&gt; 的语法只能在组件内使用，就使得把逻辑挪到组件外成为一个代价相当大的一个行为，并不是一个简单把文把这个逻辑拷贝复制出去，而是需要进行一次彻底的重构，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为组件外用的是完全一套不同的系统，但是像用 &lt;code&gt;Reactivity Transform&lt;/code&gt; 和 &lt;code&gt;Solid \-labels&lt;/code&gt; 这样的方案呢，我们就可以把组件内的这些逻辑原封不动的直接拷贝到组件外，然后把它包在一个函数里面，抽取就完成了，那么这样重构时的这个代价就非常小，也就更鼓励团队的这样的优化，对于长期的维护性更有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代价：&lt;/strong&gt; 因为我们需要显示的去声明响应式的变量，所以它会有一定程度的底层实现的抽象泄露，也就是说，用户其实是需要先了解底层的响应式模型的实现，然后才能更好地理解这个语法糖是如何运作的，而不像 &lt;code&gt;Svelte&lt;/code&gt; 组建中的这个语法，即使你完全不了解他底层如何运作的也可以，几乎可以零成本的上手，这就是一个长期的可维护性和一个初期的上手成本之间的一个平衡和取舍。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于编译的运行是优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.340625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g5jnlUKJzfoCic2JW9xJE04icm06yYU0TQzVLTOZOiaZ54sFUJfTHxxvmg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲完了状态管理，我们在还可以聊一聊关于基于编译的运行时优化，编译的运行时优化又是三个主要的代表，如上图所示，那首先我们可以看一下不同的这个策略：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18guZBqmq53DSdTg14tubvGUicUiaGp0wBiaZqvwpQOTTLFy2vL9hPLicGT3A/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Svelte&lt;/code&gt; 的这个代码生成策略相对更更繁琐一些，而 &lt;code&gt;Solid&lt;/code&gt; 是基于先生成一个基本的HTML字符串，然后在里面找到对应的 &lt;code&gt;DOM&lt;/code&gt; 节点进行绑定，而 &lt;code&gt;Svelte&lt;/code&gt; 是通过生成一这个命令式的一个一个节点，然后把节点拼接的这些 &lt;code&gt;javaScript&lt;/code&gt; 代码，但这个策略就导致掉同等的这个组件源码之下 &lt;code&gt;Svelte&lt;/code&gt; 的每个组件的编译输出会更臃肿，所以虽然大家感觉 &lt;code&gt;Svelte&lt;/code&gt; 是以轻量出名的，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但其实我们会发现在相对大型的项目中，在项目中组建超过15个之后，&lt;code&gt;Svelte&lt;/code&gt; 的整体的打包体积优势就已经几乎不存在了，那么当组建超过50个，甚至是达到100个的时候，所有的体积会越来越越来越臃肿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而相对于而言，我们可以看到 &lt;code&gt;Vue&lt;/code&gt; 和 &lt;code&gt;Solid&lt;/code&gt; 的编译这个输出啊，整体的这个曲线就平缓很多，所以其实在越大型的项目中。反而是 &lt;code&gt;Svelte&lt;/code&gt; 的体积优势反而是一个劣势，据我所知，&lt;code&gt;Svelte&lt;/code&gt; 团队也有在想要优化这一方面的，可能会在下一个大版本中才能实现，那么我们也会拭目以待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时尤大大提出 &lt;code&gt;Solid&lt;/code&gt; 的编译性能确实是非常的猛，其实在我们的 Vue 引入了很多编译时的优化以后我们的性能已经比 &lt;code&gt;Svelte&lt;/code&gt; 好了，但是离 &lt;code&gt;Solid&lt;/code&gt; 还是有一定的距离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Vue Vapor Mode（input）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就上面提及到的编译时性能优化，其实我们的 Vue 在早期的时候也做了这方面的探索，如还在试验中的一个项目 &lt;code&gt;Vue Vapor Mode&lt;/code&gt; 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g73DAAicz73Ixp8fVvmFhEGRt69exou9EibjzJ3sTFhlFeBc3nmBPHWMw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那同样的这个只有单文件组件输入，我们现在是通过把模板编译成虚拟&lt;code&gt;DOM&lt;/code&gt; 的一个渲染函数来进行运行时的实现。但是因为模板是一个编译源，所以我们也可以选择在另一个模式下把它编译成不同的输出，也就是一个更类似于 &lt;code&gt;Svelte&lt;/code&gt; 输出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.446875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gg6coowy7x3XhlS4HdXQNP1M8BEWfHv46YsZHuJicCa8DRrmHZjxGBUQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里这个输出的代码只是一个示例代码。并不一定是最终的代码，也不是你需要书写的代码，它完全是一个编译器的输出啊，它的整体的思路就是一次性生成这个模板的静态结构、静态节点，然后再去生成命令式的，找到动态节点，并对把它跟状态进行响应式的绑定的这样一些代码，这个策略本质上就是 &lt;code&gt;Solid&lt;/code&gt; 所采用的策略，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么其实呢，这个策略可以被所有的模板引擎所使用，我们也在探索某个版本的 &lt;code&gt;Vue&lt;/code&gt; 当中会引入一个可选的这样的一个模式，把模板编译成这样的，性能更优的，运行时的这个体积也更小的一个模式，当然这不会是一个破坏性更新，因为我们的目标是可以让你渐进式的去使用这个功能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工具链&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;原生语言在前端工具链中的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3765625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gEKAFibmSv3O0wfbQWt4Prialobd5HEdMOiaGMds8qjBxbDykiaNYYXWcZg/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于原生语言在前端工具链中的使用尤大大提出下面几个见解：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18g56icQnpFDbPhr7kJHCeibDGOiazdPb7wLcEcFCXmlEMCicL94jCAc6Gd2Q/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;工具链的抽象层次&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.396875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gXmSjXlWrj7I39K7QDN013rltaOYKu5RFSy6j0M3kLjzKiaQwoq8jySQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最早的打包工具，包括 &lt;code&gt;brow/webpack/rollup&lt;/code&gt; 他们都是专注于打包的，他们的抽象层次相对低，当你想要用这些工具去做一个真正的应用的时候，你需要使用大量第三方插件，以及大量的配置来达到一个满足你自己要求的最终的形态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在这个基础上就产生了像 &lt;code&gt;Parcel/Vue-cli/CRA&lt;/code&gt; ，这样的一些所谓的脚手架，更高抽象层次的这些工具，这些工具的特点是他们的抽象层的高，也就说他们专注于应用，专注于解决一个完整的应用方案呢，它的相对而言的缺点就是它是一个比较复杂、比较庞大的一个黑盒儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你需要去进行自定义的定制的时候，你就会不可避免的遇到一些问题，比如说你跟他默认的功能产生一些意见上的冲突的时候，你就会比较痛苦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们现在做的这个新项目 &lt;code&gt;Vite&lt;/code&gt; 其实可能有一些同学已经在用了，其实我们是在思考过这个抽象层次的问题之后才决定的他要走一个怎么样的路线，也就是说 &lt;code&gt;Vite&lt;/code&gt; 的 &lt;code&gt;CLI&lt;/code&gt; 它是专注于应用层次啊，它的抽象层次高，它有很多的开箱记，就是事先帮你寄配置好的功能，那么大部分的情况下，你开箱即用就可以达到跟 &lt;code&gt;Parcel/Vue-cli/CRA&lt;/code&gt; 几乎同等的这些功能啊，但是我们的&lt;code&gt;API&lt;/code&gt;层面啊，这个可能用到的同学会少一些，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它的&lt;code&gt;API&lt;/code&gt;层面其实是专注于支持上层框架，我们这个抽象层次会更低一点，我们只解决一些所有的够 &lt;code&gt;meta framework&lt;/code&gt; 都必须要解决的问题，但是对于上层框架，你用什么，我们并不会做过多的限制，反而是要做的更尽可能的灵活，能够支持任何上层框架的用例，所以这也是为什么 &lt;code&gt;Vite&lt;/code&gt; 现在几乎成为了下一代的&lt;code&gt;meta framework&lt;/code&gt; 共同的一个基底层选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于 Vite 的上层框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3515625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gANSPEae6Sog2NtAUJFZJLNX6EsjNoiaXlKW6cBJmt4cmWHXg4tXWbCQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到上面这么多的上层框架都在基于 &lt;code&gt;Vite&lt;/code&gt; 说明我们 &lt;code&gt;Vite&lt;/code&gt; 走的路线还是相对成功的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上层框架 Meta Frameworks&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JS全栈的意义是什么 ？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们讲到这个 &lt;code&gt;Meta Frameworks&lt;/code&gt;，也就是最典型的例子，也就是&lt;code&gt;NextJS 、NuxtJS&lt;/code&gt;、以及现在React社区中的新秀 &lt;code&gt;Remix&lt;/code&gt; 等等，那么当我们思考这样类型的JS全栈的时候，我们做全栈的意义是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么相信在国内很多大企业的朋友都知道，因为我们可以用同一个语言去做前后的连接，我们可以做一些纯前端和纯后端都各自做不到的事情，或者说之前需要很复杂的联调才能达成的一些事情，那么JS全栈可以更好的去完成一个语言让我们可以把前后打通。那么我们能够打通什么呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据的前后端打通&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3109375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18grUczecZ66icSgR3DhpRhJO4Cj3pzzh9iav0HPIHL9uEdIsJblrjeiazAQ/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;类型的前后端打通&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.321875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gT5ea0ibn25XtUmLQzWd6AX74IbCXxrtdEvzhVO45e6QNzqB5fwR6r5w/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JS全栈的代价&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3609375&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gQGemAI7w4ic8437zeJk4UeoS6sGiaZbOFZ2lEVGFgbBXj2HkYT4A83Qw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些新的全栈框架，现在在试图去改善的一些问题首先。我们现有的这些前端框架，比如说像主流的像 &lt;code&gt;React、Vue&lt;/code&gt; 我们在做了服务端渲染之后，还需要在前端要进行一次所谓的注水，也就是 &lt;code&gt;Hydrate&lt;/code&gt; 在追寻的过程中，我们要确保在客户端和前端有同样的数据，所以其实虽然我们的数据已经用于渲染HTML，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些数据理论上在HTML里面已经都用过了，但是我们还得再把这个数据再发送一次，一起发送到前端，让前端去进行 &lt;code&gt;Hydrate&lt;/code&gt; 这样一个过程。因为没有这个数据，我们在前端就没有办法保证 &lt;code&gt;Hydrate&lt;/code&gt; 的正确性啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在客户端，有些组件它可能在客户端是不，需要交互的是静态的，但是他在服务端用到了动态的这个数据，但这个组件依然会被发到服务端，它依然会可能产生这个&lt;code&gt;javascript&lt;/code&gt; 运行时的代价啊，以及缓慢的这个 &lt;code&gt;Hydrate&lt;/code&gt; 会影响页面的交互指标，也就是 time to interactive。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些比较复杂的庞大的项目，他可能这个注水的过程会把页面卡顿，以至于虽然能看到页面，但是没法交互，要等个一秒钟才能交互等等，会产生这样的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;社区探索的方向&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3578125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHr1Cgjk13Johy76vQPPe18gl5eS6VXV2vCMRpicrMTGFjRBm5PepicvZkxTmwDwHSibr2Htiafsf3DvYw/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;社区现在新一代的这些全栈框架都在试图解决这些问题啊，比如说像 &lt;code&gt;React&lt;/code&gt; 提出了 &lt;code&gt;server only components&lt;/code&gt; 其实从这个定义上，我们就发现他是没有一个全栈框架，围绕一个全栈框架去做，其实用户是没有办法简单地使用的一个概念，所以 &lt;code&gt;React server only components&lt;/code&gt; 其实是一个必须要全站才能做的概念，Next 当然也会去做，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，其实 Nuxt 最近也开了一个 &lt;code&gt;server only components&lt;/code&gt; 的一个提案，所以说这个已经就是说 &lt;code&gt;server only components&lt;/code&gt; 其实不仅仅是一个 &lt;code&gt;React&lt;/code&gt; 独有的概念，在很多其他的框架中，我们可能慢慢都会出现类似的这个类似的东西。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个方向就是减少注水，&lt;code&gt;hydration&lt;/code&gt; 的这个成本，那么也就是局部的注水，或者也叫 &lt;code&gt;island architecture&lt;/code&gt; 就像大海中一个小岛，只有这些小岛去对他进行注水，让他交可交互啊。那么比较代表性的就是 &lt;code&gt;astro、isles&lt;/code&gt; 和生态里面的 &lt;code&gt;fresh&lt;/code&gt; 这些框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后呢，还有一个探索方向，就是所谓的 &lt;code&gt;fine-grained+resumabl hydration&lt;/code&gt;，就是细粒度懒加载，这个数据其实是&lt;code&gt;Qwik&lt;/code&gt;这个框架所发明的，&lt;code&gt;Quick&lt;/code&gt; 的作者就是 &lt;code&gt;Misko Hevery&lt;/code&gt;，也就是 &lt;code&gt;Angular&lt;/code&gt; 的原作者，离开Google之后，现在新开发的这个框架啊，那么 &lt;code&gt;Qwik&lt;/code&gt; 它主打的就是说它的特点就是不需要再把数据重新发送一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他是直接在生成的渲染的html里面嵌入所需的数据从而使得客户端的js可以直接在html里面获得所要的数据，甚至是可以跳过一些需要执行的js步骤，直接跳到一个已经完成的状态上面去，这就是所谓的&lt;code&gt;resumable&lt;/code&gt; ，也是一个比较值得关注的一个方向。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及我们的 Vue 生态里面生态里面有一个我们的 &lt;code&gt;VitePress&lt;/code&gt;，我们其实探索的是一个在我们页面的核心内容：其实是静态的MD文件的前提下如何做高效率的 &lt;code&gt;hydration&lt;/code&gt; 那么我们做的是所谓的 &lt;code&gt;hydration&lt;/code&gt; 就是整个的外部的这个一个框架内容外包着的这一层ui是动态的，然后呢在内部静态的里继续进行局部的注水，然后这样的话，我们依然可以获得一个单页应用的体验，但又获得很好的客户端注水的性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里呢尤大大的分享就结束了，本总结的内容中如果存在争议大家可以在评论区进行留言，希望能够给大家带来一定的收获和成长！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>de02c50edf2c525821755cba8909541c</guid>
<title>揭秘webpack5模块打包</title>
<link>https://toutiao.io/k/evlm88o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNjgwMDIzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/udZl15qqib0OiahcrjrJncW0GOiclg6Jic6IQHYeIGzfXSbZicLUeUxNyQVmPSelMxQxTSu8wAibsyXjy9U3pVfic7FGA/0?wx_fmt=png&quot; data-nickname=&quot;全栈前端精选&quot; data-alias=&quot;Just_FED&quot; data-signature=&quot;内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们所知道的本地服务，资源的压缩，代码分割，在&lt;code&gt;webpack&lt;/code&gt;构建的工程中有一个比较显著的特征是，模块化，要么&lt;code&gt;commonjs&lt;/code&gt;要么&lt;code&gt;esModule&lt;/code&gt;,在开发环境我们都是基于这两种，那么通过&lt;code&gt;webpack&lt;/code&gt;打包后，如何让其支持浏览器能正常的加载两种不同的模式呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们一起来探讨下&lt;code&gt;webpack&lt;/code&gt;中打包后代码的原理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始...&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化基础项目&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个文件夹&lt;code&gt;webpack-05-module&lt;/code&gt;，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm init -y &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们安装项目一些基础支持的插件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i webpack webpack-cli webpack-dev-server html-webpack-plugin babel-loader @babel&lt;br/&gt;l/core -D&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在根目录新建&lt;code&gt;webpack.config.js&lt;/code&gt;，配置相关参数，为了测试webpack打包&lt;code&gt;cjs&lt;/code&gt;与&lt;code&gt;esModule&lt;/code&gt;我在&lt;code&gt;entry&lt;/code&gt;写了两个入口文件，并且设置&lt;code&gt;mode:development&lt;/code&gt;与&lt;code&gt;devtool: &#x27;source-map&#x27;&lt;/code&gt;,设置&lt;code&gt;source-map&lt;/code&gt;是为了更好的查看源代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; path = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;path&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; HtmlWebpackPlugin = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;html-webpack-plugin&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { CleanWebpackPlugin } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;clean-webpack-plugin&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  &lt;span&gt;entry&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;cjs&lt;/span&gt;: &lt;span&gt;&#x27;./src/commonjs_index.js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;esjs&lt;/span&gt;: &lt;span&gt;&#x27;./src/esmodule_index.js&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;devtool&lt;/span&gt;: &lt;span&gt;&#x27;source-map&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;filename&lt;/span&gt;: &lt;span&gt;&#x27;js/[name].js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;path&lt;/span&gt;: path.resolve(__dirname, &lt;span&gt;&#x27;dist&#x27;&lt;/span&gt;),&lt;br/&gt;    &lt;span&gt;assetModuleFilename&lt;/span&gt;: &lt;span&gt;&#x27;images/[name][ext]&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;development&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;rules&lt;/span&gt;: [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.js$/&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;loader&lt;/span&gt;: &lt;span&gt;&#x27;babel-loader&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;options&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;presets&lt;/span&gt;: [&lt;span&gt;&#x27;@babel/env&#x27;&lt;/span&gt;]&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;test&lt;/span&gt;: &lt;span&gt;/\.(png|jpg)$/i&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;asset/resource&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// generator: {&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   // filename: &#x27;images/[name][ext]&#x27;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//   publicPath: &#x27;/assets/images/&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ]&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; CleanWebpackPlugin(),&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; HtmlWebpackPlugin({&lt;br/&gt;      &lt;span&gt;template&lt;/span&gt;: &lt;span&gt;&#x27;./public/index.html&#x27;&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;  ]&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;src&lt;/code&gt;目录下新建&lt;code&gt;commonjs_index.js&lt;/code&gt;, &lt;code&gt;esmodule_index.js&lt;/code&gt;文件&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;commonjs_index.js&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// commonjs_index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { twoSum } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./utils/common.js&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; imgSrc &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./assets/images/1.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;cm_sum=&#x27;&lt;/span&gt; + twoSum(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; domApp = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt; Image();&lt;br/&gt;img.src = imgSrc;&lt;br/&gt;domApp.appendChild(img);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入的&lt;code&gt;common.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// utils/common.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;twoSum&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;  twoSum&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;esmodule_index.js&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// esmodule_index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; twoSumMul &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./utils/esmodule.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;es_sum=&#x27;&lt;/span&gt; + twoSumMul(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入的&lt;code&gt;esmodule.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// utils/esmodule.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;twoSumMul&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a * b;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// esModule&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; twoSumMul;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们运行&lt;code&gt;npm run build&lt;/code&gt;命令，会在根目录&lt;code&gt;dist/js&lt;/code&gt;文件夹下打包入口指定的两个文件&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35452793834296725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx61FG2CLdnuibvhgowORf9iayBJBv2mZfkyqEUiaXhiautMRBXCwlxWfCpwlAbfkTtB1LE1OHDblRVibVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1038&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;webpack打包cjs最终代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把对应注释去掉后就是下面这样的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// cjs.js&lt;br/&gt;(() =&amp;gt; {&lt;br/&gt;  var __webpack_modules__ = {&lt;br/&gt;    &lt;span&gt;&#x27;./src/utils/common.js&#x27;&lt;/span&gt;: (module) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;function&lt;/span&gt; twoSum(a, b) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;      }&lt;br/&gt;&lt;br/&gt;      module.exports = {&lt;br/&gt;        twoSum: twoSum&lt;br/&gt;      };&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&#x27;./src/assets/images/1.png&#x27;&lt;/span&gt;: (module, __unused_webpack_exports, __webpack_require__) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;&#x27;use strict&#x27;&lt;/span&gt;;&lt;br/&gt;      module.exports = __webpack_require__.p + &lt;span&gt;&#x27;images/1.png&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  var __webpack_module_cache__ = {};&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt; __webpack_require__(moduleId) {&lt;br/&gt;    var cachedModule = __webpack_module_cache__[moduleId];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cachedModule !== undefined) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; cachedModule.exports;&lt;br/&gt;    }&lt;br/&gt;    var module = (__webpack_module_cache__[moduleId] = {&lt;br/&gt;      exports: {}&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    __webpack_modules__[moduleId](module, module.exports, __webpack_require__ &lt;span&gt;&quot;moduleId&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; module.exports;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  (() =&amp;gt; {&lt;br/&gt;    __webpack_require__.g = (&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt; () {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (typeof globalThis === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; globalThis;&lt;br/&gt;      try {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this || new Function(&lt;span&gt;&#x27;return this&#x27;&lt;/span&gt;)();&lt;br/&gt;      } catch (e) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (typeof window === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; window;&lt;br/&gt;      }&lt;br/&gt;    })();&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  (() =&amp;gt; {&lt;br/&gt;    __webpack_require__.r = (exports) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (typeof Symbol !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; Symbol.toStringTag) {&lt;br/&gt;        Object.defineProperty(exports, Symbol.toStringTag, { value: &lt;span&gt;&#x27;Module&#x27;&lt;/span&gt; });&lt;br/&gt;      }&lt;br/&gt;      Object.defineProperty(exports, &lt;span&gt;&#x27;__esModule&#x27;&lt;/span&gt;, { value: &lt;span&gt;true&lt;/span&gt; });&lt;br/&gt;    };&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  (() =&amp;gt; {&lt;br/&gt;    var scriptUrl;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    var document = __webpack_require__.g.document;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!scriptUrl &amp;amp;&amp;amp; document) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (document.currentScript) scriptUrl = document.currentScript.src;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!scriptUrl) {&lt;br/&gt;        var scripts = document.getElementsByTagName(&lt;span&gt;&#x27;script&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (scripts.length) scriptUrl = scripts[scripts.length - 1].src;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!scriptUrl) throw new Error(&lt;span&gt;&#x27;Automatic publicPath is not supported in this browser&#x27;&lt;/span&gt;);&lt;br/&gt;    scriptUrl = scriptUrl&lt;br/&gt;      .replace(/&lt;span&gt;#.*$/, &#x27;&#x27;)&lt;/span&gt;&lt;br/&gt;      .replace(/\?.*$/, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;      .replace(/\/[^\/]+$/, &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;);&lt;br/&gt;    __webpack_require__.p = scriptUrl + &lt;span&gt;&#x27;../&#x27;&lt;/span&gt;;&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  var __webpack_exports__ = {};&lt;br/&gt;  (() =&amp;gt; {&lt;br/&gt;    &lt;span&gt;&#x27;use strict&#x27;&lt;/span&gt;;&lt;br/&gt;    __webpack_require__.r(__webpack_exports__);&lt;br/&gt;     var _assets_images_1_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/images/1.png */ &lt;span&gt;&#x27;./src/assets/images/1.png&#x27;&lt;/span&gt;);&lt;br/&gt;    var _require = __webpack_require__(/*! ./utils/common.js */ &lt;span&gt;&#x27;./src/utils/common.js&#x27;&lt;/span&gt;),&lt;br/&gt;      twoSum = _require.twoSum;&lt;br/&gt;&lt;br/&gt;    console.log(&lt;span&gt;&#x27;cm_sum=&#x27;&lt;/span&gt; + twoSum(1, 2));&lt;br/&gt;    var domApp = document.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;);&lt;br/&gt;    var img = new Image();&lt;br/&gt;    img.src = _assets_images_1_png__WEBPACK_IMPORTED_MODULE_0__;&lt;br/&gt;    domApp.appendChild(img);&lt;br/&gt;  })();&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初次看，感觉&lt;code&gt;webpack&lt;/code&gt;打包&lt;code&gt;cjs&lt;/code&gt;的代码太长了，但是删除掉注释后，我们仔细分析发现，并没有那么复杂&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是该模块采用IFEE模式，一个匿名的自定义自行函数内包裹了几大块区域&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、初始化定义了webpack依赖的模块&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;var&lt;/span&gt; __webpack_modules__ = {&lt;br/&gt;    &lt;span&gt;&#x27;./src/utils/common.js&#x27;&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;&lt;span&gt;module&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;twoSum&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 当在执行时，返回这个具体函数体内容&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;        &lt;span&gt;twoSum&lt;/span&gt;: twoSum&lt;br/&gt;      };&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&#x27;./src/assets/images/1.png&#x27;&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;&lt;span&gt;module&lt;/span&gt;, __unused_webpack_exports, __webpack_require__&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;&#x27;use strict&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;// 每一个对应的模块对应的内容&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;module&lt;/span&gt;.exports = __webpack_require__.p + &lt;span&gt;&#x27;images/1.png&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现&lt;code&gt;webpack&lt;/code&gt;是用模块引入的路径当成&lt;code&gt;key&lt;/code&gt;,然后&lt;code&gt;value&lt;/code&gt;就是一个函数，函数体内就是引入的具体代码内容，并且内部传入了一个形参&lt;code&gt;module&lt;/code&gt;,实际上这个&lt;code&gt;module&lt;/code&gt;就是为&lt;code&gt;{exports: {}}&lt;/code&gt;定义的对象，把内部函数&lt;code&gt;twoSum&lt;/code&gt;绑定了在对象上&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、调用模块优先从缓存对象模块取值&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;var&lt;/span&gt; __webpack_module_cache__ = {};&lt;br/&gt; &lt;span&gt;// moduleId 就是引入的路径&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;__webpack_require__&lt;/span&gt;(&lt;span&gt;moduleId&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 根据moduleId优先从缓存中获取__webpack_modules__中绑定的值 {twoSum: TwoSum}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; cachedModule = __webpack_module_cache__[moduleId];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cachedModule !== &lt;span&gt;undefined&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; cachedModule.exports;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 传入__webpack_modules__内部value的形参 module&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;module&lt;/span&gt; = (__webpack_module_cache__[moduleId] = {&lt;br/&gt;      &lt;span&gt;exports&lt;/span&gt;: {}&lt;br/&gt;    });&lt;br/&gt;    __webpack_modules__[moduleId](&lt;span&gt;module&lt;/span&gt;, &lt;span&gt;module&lt;/span&gt;.exports, __webpack_require__ &lt;span&gt;&quot;moduleId&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;// 根据moduleId依次返回 {twoSum: twoSum}、__webpack_require__.p + &#x27;images/1.png‘图片路径&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;module&lt;/span&gt;.exports;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、绑定全局对象，引入图片的资源路径，主要是&lt;code&gt;__webpack_require__.p&lt;/code&gt;图片地址&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  (&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    __webpack_require__.g = (&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; globalThis === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; globalThis;&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt; || &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Function&lt;/span&gt;(&lt;span&gt;&#x27;return this&#x27;&lt;/span&gt;)();&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;window&lt;/span&gt; === &lt;span&gt;&#x27;object&#x27;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;window&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    })();&lt;br/&gt;  })();&lt;br/&gt;  &lt;br/&gt;   &lt;span&gt;(&lt;span&gt;(&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; scriptUrl;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;document&lt;/span&gt; = __webpack_require__.g.document;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!scriptUrl &amp;amp;&amp;amp; &lt;span&gt;document&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;document&lt;/span&gt;.currentScript) scriptUrl = &lt;span&gt;document&lt;/span&gt;.currentScript.src;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!scriptUrl) {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; scripts = &lt;span&gt;document&lt;/span&gt;.getElementsByTagName(&lt;span&gt;&#x27;script&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (scripts.length) scriptUrl = scripts[scripts.length - &lt;span&gt;1&lt;/span&gt;].src;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!scriptUrl) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Automatic publicPath is not supported in this browser&#x27;&lt;/span&gt;);&lt;br/&gt;    scriptUrl = scriptUrl&lt;br/&gt;      .replace(&lt;span&gt;/#.*$/&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;      .replace(&lt;span&gt;/\?.*$/&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;      .replace(&lt;span&gt;/\/[^\/]+$/&lt;/span&gt;, &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;// 获取图片路径&lt;/span&gt;&lt;br/&gt;    __webpack_require__.p = scriptUrl + &lt;span&gt;&#x27;../&#x27;&lt;/span&gt;;&lt;br/&gt;  })();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、将&lt;code&gt;esModule&lt;/code&gt;转换，用&lt;code&gt;Object.defineProperty&lt;/code&gt;拦截&lt;code&gt;exports&lt;/code&gt;(module.exports)对象添加&lt;code&gt;__esModule&lt;/code&gt;属性&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  (&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    __webpack_require__.r = &lt;span&gt;(&lt;span&gt;exports&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;Symbol&lt;/span&gt; !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;Symbol&lt;/span&gt;.toStringTag) {&lt;br/&gt;        &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, &lt;span&gt;Symbol&lt;/span&gt;.toStringTag, { &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;Module&#x27;&lt;/span&gt; });&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, &lt;span&gt;&#x27;__esModule&#x27;&lt;/span&gt;, { &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });&lt;br/&gt;    };&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、&lt;code&gt;__webpack_require__(moduleId)&lt;/code&gt;执行获取对应的内容&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; __webpack_exports__ = {};&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;(&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&#x27;use strict&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 在步骤4中做对象拦截，添加__esMoules属性&lt;/span&gt;&lt;br/&gt;    __webpack_require__.r(__webpack_exports__);&lt;br/&gt;    &lt;span&gt;//根据路径获取对应module.exports的内容也就是__webpack_require__中的module.exports对象的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; _assets_images_1_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&lt;span&gt;/*! ./assets/images/1.png */&lt;/span&gt; &lt;span&gt;&#x27;./src/assets/images/1.png&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; _require = __webpack_require__(&lt;span&gt;/*! ./utils/common.js */&lt;/span&gt; &lt;span&gt;&#x27;./src/utils/common.js&#x27;&lt;/span&gt;),&lt;br/&gt;      twoSum = _require.twoSum;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;cm_sum=&#x27;&lt;/span&gt; + twoSum(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; domApp = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;app&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; img = &lt;span&gt;new&lt;/span&gt; Image();&lt;br/&gt;    img.src = _assets_images_1_png__WEBPACK_IMPORTED_MODULE_0__;&lt;br/&gt;    domApp.appendChild(img);&lt;br/&gt;  })();&lt;br/&gt;})();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;webpack打包esModule最终代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下具体代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// esjs.js&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// webpackBootstrap&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&#x27;use strict&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; __webpack_modules__ = {&lt;br/&gt;    &lt;span&gt;&#x27;./src/utils/esmodule.js&#x27;&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;__unused_webpack_module, __webpack_exports__, __webpack_require__&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      __webpack_require__.r(__webpack_exports__);&lt;br/&gt;      &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;twoSumMul&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a * b;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; __WEBPACK_DEFAULT_EXPORT__ = twoSumMul;&lt;br/&gt;      __webpack_require__.d(__webpack_exports__, {&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; __WEBPACK_DEFAULT_EXPORT__&lt;br/&gt;      });&lt;br/&gt;     &lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// The module cache&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; __webpack_module_cache__ = {};&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// The require function&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;__webpack_require__&lt;/span&gt;(&lt;span&gt;moduleId&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Check if module is in cache&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; cachedModule = __webpack_module_cache__[moduleId];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (cachedModule !== &lt;span&gt;undefined&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; cachedModule.exports;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// Create a new module (and put it into the cache)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;module&lt;/span&gt; = (__webpack_module_cache__[moduleId] = {&lt;br/&gt;      &lt;span&gt;// no module.id needed&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// no module.loaded needed&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;exports&lt;/span&gt;: {}&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Execute the module function&lt;/span&gt;&lt;br/&gt;    __webpack_modules__[moduleId](&lt;span&gt;module&lt;/span&gt;, &lt;span&gt;module&lt;/span&gt;.exports, __webpack_require__ &lt;span&gt;&quot;moduleId&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Return the exports of the module&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;module&lt;/span&gt;.exports;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  (&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// define getter functions for harmony exports&lt;/span&gt;&lt;br/&gt;    __webpack_require__.d = &lt;span&gt;(&lt;span&gt;exports, definition&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; definition) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__webpack_require__.o(definition, key) &amp;amp;&amp;amp; !__webpack_require__.o(exports, key)) {&lt;br/&gt;          &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, key, { &lt;span&gt;enumerable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;get&lt;/span&gt;: definition[key] });&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    };&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/* webpack/runtime/hasOwnProperty shorthand */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;(&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    __webpack_require__.o = &lt;span&gt;(&lt;span&gt;obj, prop&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt;.prototype.hasOwnProperty.call(obj, prop);&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/* webpack/runtime/make namespace object */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;(&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// define __esModule on exports&lt;/span&gt;&lt;br/&gt;    __webpack_require__.r = &lt;span&gt;(&lt;span&gt;exports&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;Symbol&lt;/span&gt; !== &lt;span&gt;&#x27;undefined&#x27;&lt;/span&gt; &amp;amp;&amp;amp; &lt;span&gt;Symbol&lt;/span&gt;.toStringTag) {&lt;br/&gt;        &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, &lt;span&gt;Symbol&lt;/span&gt;.toStringTag, { &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;Module&#x27;&lt;/span&gt; });&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, &lt;span&gt;&#x27;__esModule&#x27;&lt;/span&gt;, { &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; });&lt;br/&gt;    };&lt;br/&gt;  })();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;/************************************************************************/&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; __webpack_exports__ = {};&lt;br/&gt;  &lt;span&gt;(&lt;span&gt;(&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    __webpack_require__.r(__webpack_exports__);&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; _utils_esmodule_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(&lt;span&gt;/*! ./utils/esmodule.js */&lt;/span&gt; &lt;span&gt;&#x27;./src/utils/esmodule.js&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;es_sum=&#x27;&lt;/span&gt; + (&lt;span&gt;0&lt;/span&gt;, _utils_esmodule_js__WEBPACK_IMPORTED_MODULE_0__[&lt;span&gt;&#x27;default&#x27;&lt;/span&gt;])(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;  })();&lt;br/&gt;})();&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看着代码似乎与&lt;code&gt;cjs&lt;/code&gt;大体差不多，事实上有些不一样&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们执行&lt;code&gt;_utils_esmodule_js__WEBPACK_IMPORTED_MODULE_0__&lt;/code&gt;这个方法时，实际会在&lt;code&gt;__webpack_modules__&lt;/code&gt;方法会根据&lt;code&gt;moduleId&lt;/code&gt;执行value值的函数体，而函数体会被&lt;code&gt;__webpack_require__.d&lt;/code&gt;这个方法进行拦截，会执行&lt;code&gt; Object.defineProperty&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法，返回绑定在&lt;code&gt;__webpack_exports__&lt;/code&gt;对象的值上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要看以下两段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;var&lt;/span&gt; __webpack_modules__ = {&lt;br/&gt;    &lt;span&gt;&#x27;./src/utils/esmodule.js&#x27;&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;__unused_webpack_module, __webpack_exports__, __webpack_require__&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 这里定义模块时就已经先进行了拦截，这里与cjs有很大的区别&lt;/span&gt;&lt;br/&gt;      __webpack_require__.r(__webpack_exports__);&lt;br/&gt;      &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;twoSumMul&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; a * b;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; __WEBPACK_DEFAULT_EXPORT__ = twoSumMul;&lt;br/&gt;      __webpack_require__.d(__webpack_exports__, {&lt;br/&gt;        &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; __WEBPACK_DEFAULT_EXPORT__&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;  };&lt;br/&gt;  ...&lt;br/&gt;    (&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// define getter functions for harmony exports&lt;/span&gt;&lt;br/&gt;    __webpack_require__.d = &lt;span&gt;(&lt;span&gt;exports, definition&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; definition) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (__webpack_require__.o(definition, key) &amp;amp;&amp;amp; !__webpack_require__.o(exports, key)) {&lt;br/&gt;          &lt;span&gt;Object&lt;/span&gt;.defineProperty(exports, key, { &lt;span&gt;enumerable&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;get&lt;/span&gt;: definition[key] });&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    };&lt;br/&gt;  })();&lt;br/&gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在webpack转换&lt;code&gt;esModule&lt;/code&gt;代码中,同样会是有优先从缓存对象中获取，通过调用&lt;code&gt;  __webpack_modules__[moduleId](module, module.exports, __webpack_require__ &quot;moduleId&quot;);&lt;/code&gt; 这个方法，改变&lt;code&gt;module.exports&lt;/code&gt;根据&lt;code&gt;moduleId&lt;/code&gt;获取函数体内的值&lt;code&gt;twoSumMul&lt;/code&gt;函数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后画了一张简易的图，文字理解还是有点多，纸上得来终学浅，绝知此事要躬行，还是得写个简单的&lt;code&gt;demo&lt;/code&gt;自己深深体会下，具体参考文末的&lt;code&gt;code example&lt;/code&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39814814814814814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx61FG2CLdnuibvhgowORf9iayZBfV2MF6Qpd6cWcIJSefnsicdrxeMfQJywp6LAJiaGWPhDbwGzDocE8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;webpack打包&lt;code&gt;cjs&lt;/code&gt;与&lt;code&gt;esModule&lt;/code&gt;的区别，本质上就是为了在浏览器支持webpack中使用&lt;code&gt;export default {}&lt;/code&gt;与&lt;code&gt;module.exports &lt;/code&gt;在浏览器定义了一个全局变量&lt;code&gt;__webpack_modules__&lt;/code&gt;根据引入的模块路径变成&lt;code&gt;key&lt;/code&gt;,&lt;code&gt;value&lt;/code&gt;就是在&lt;code&gt;webpack&lt;/code&gt;中的&lt;code&gt;cjs&lt;/code&gt;或者&lt;code&gt;esModule&lt;/code&gt;中函数体。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们在&lt;code&gt;cjs&lt;/code&gt;使用&lt;code&gt;require(&#x27;/path&#x27;)&lt;/code&gt;、或者在&lt;code&gt;esModule&lt;/code&gt;中使用&lt;code&gt;import xx from &#x27;/path&#x27;&lt;/code&gt;时，实际上&lt;code&gt;webpack&lt;/code&gt;把&lt;code&gt;require&lt;/code&gt;or&lt;code&gt;import&lt;/code&gt;转变成了一个定义的函数&lt;code&gt;__webpack_require__(&#x27;moduleId&#x27;)&lt;/code&gt;的可执行函数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;cjs&lt;/code&gt;是在执行&lt;code&gt;__webpack_require__.r(__webpack_exports__)&lt;/code&gt;是就已经预先将&lt;code&gt;__webpack_require__&lt;/code&gt;返回的函数体内容进行了绑定，只有在执行&lt;code&gt;_webpack_require__(/*! ./utils/common.js */ &#x27;./src/utils/common.js&#x27;)&lt;/code&gt;返回函数体，本质上就是在运行时执行&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;esMoule&lt;/code&gt;实际上是在定义时就已经进行了绑定，在定义&lt;code&gt;__webpack_exports__&lt;/code&gt;时，执行了&lt;code&gt; __webpack_require__.r(__webpack_exports__);&lt;/code&gt;动态添加&lt;code&gt;__esModule&lt;/code&gt;属性,根据&lt;code&gt;moduleId&lt;/code&gt;定义模块时，执行了&lt;code&gt;  __webpack_require__.d(__webpack_exports__, { default: () =&amp;gt; __WEBPACK_DEFAULT_EXPORT__});&lt;/code&gt;,将对应模块函数体会直接用对象拦截执行&lt;code&gt;Object.defineProperty&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法,执行&lt;code&gt;definition[key]&lt;/code&gt;从而返回函数体。本质上就是在编译前执行，而不是像&lt;code&gt;cjs&lt;/code&gt;一样在函数体执行阶段直接输出对应内容。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;他们相同点就是优先会从缓存&lt;code&gt;__webpack_module_cache__&lt;/code&gt;对象中根据&lt;code&gt;moduleId&lt;/code&gt;直接获取对应的可执行函数体&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文&lt;span&gt;code example&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料 &lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1] &lt;/span&gt;&lt;p&gt;code example: &lt;em&gt;https://github.com/maicFir/lessonNote/tree/master/webpack/webpack-05-module&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>