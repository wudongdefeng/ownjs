<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8e41d4ebe72fb60627fb46c63ac3b333</guid>
<title>周杰伦在唱什么？数据可视化告诉你！</title>
<link>https://toutiao.io/k/p89fu48</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;👆&lt;/span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;博文视点Broadview&lt;/span&gt;&lt;span&gt;”，获取更多书讯&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05669291338582677&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3nr1VNxfeqxVOw2nPJHVH4xeZibzPY5F4ibOuOZLMsUMrzIibGB6KMw7EurSKv6DkrtLzuhYdBa30A9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.10027855153203342&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3npgLu0khEqdibc8UNib9mUOF5Oic7ofxC1krfeqOz5wtoEWMiczOpKGic8QcQLLuSPHicTEZhBqib9LGTeA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;121695&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39866666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpLwNEhN0LV2px5TeZBq1q6zutnPpibuvCWcPCu7Uia1XxcHjDZjkcJ4ibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_live_iframe&quot; data-pluginname=&quot;videosnap&quot; data-headimgurl=&quot;https://wx.qlogo.cn/finderhead/oLU121BePGlK5gCzY9FXd7w0qDZtIDcFtaSTNicpYrEvHvAA2kfCLKg/0&quot; data-username=&quot;v2_060000231003b20faec8c7e48b1dc6dccd04e436b0771df137f3e0832e32a92192ea2165411c@finder&quot; data-nickname=&quot;博文视点Broadview&quot; data-desc=&quot;将在03月23日 20:00 直播&quot; data-intro=&quot;网络运维自动化：网络工程师修炼之路&quot; data-noticeid=&quot;finderlivenotice-v2_060000231003b20faec8c7e48b1dc6dccd04e436b0771df137f3e0832e32a92192ea2165411c@finder-1679284341760559-1595378128&quot; data-type=&quot;live&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本案例中的歌词数据来自中文歌词数据库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个数据库提供了华语歌手的歌曲及歌词信息，数据以&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;JSON 格式存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了尽量完整地呈现从原始数据到可视化的过程，接下来我们会先&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;简单讲解数据的预处理过程，即如何将 JSON 数据转化为Excel 格式，以及如何对周杰伦的歌曲进行分词。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;若你希望跳过数据预处理的过程，也可以在《数据可视化设计指南：从数据到新知》一书的下载文件中，直接使用分好词的 Excel 文件进行可视化练习。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据预处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;指的是将原始数据处理成我们希望的格式，并提取出我们需要的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在本案例中，我们需要先从数据库中筛选出演唱者为周杰伦的歌曲，然后获得这些歌曲的歌词，并将它们存储到纯文本文档（.txt 格式）中。以下提供两种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一种方法，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;先把 JSON 文件转换为 Excel 可以打开的 .csv 文件或 .xlsx 文件格式。这可以借助一些在线的转换工具完成（如 JSON to CSV Converter）。一般而言，只需将文件拖入这些工具，选择好转换格式类型，即可转换完成。接着，我们便可以在 Excel 中打开该数据，然后单击“数据→筛选”命令，选择歌手为“周杰伦”的歌曲。之后，选中它们的歌词，并将其粘贴到纯文本文档中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二种方法，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通过 Python 进行数据预处理。代码如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，需要引入 JSON 库（未安装者通过 pip install json 安装）。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; json&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，读取我们下载的 JSON 文件，存储在名为 data 的变量中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;open&lt;/span&gt;(‘ lyrics.json’ , ‘ r’ ) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; = json.load(f)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着，遍历 data 中的每一项，找出“歌手”=“周杰伦”的数据项，存到data_zjl 中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;data_zjl = [item &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; data &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; item[‘ singer’ ]==’ 周杰伦’ ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(len(data_zjl))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建立一个空列表 zjl_lyrics，用于存储歌词。遍历 data_zjl 中的每一首歌，将它们的歌词存到 zjl_lyrics 中。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Zjl_lyrics = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;for song in data_zjl:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;zjl_lyrics = zjl_lyrics + song[‘ lyric’ ]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后将 zjl_lyrics 写入一个新的 .txt 文件。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;open&lt;/span&gt;(“ &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;zjl_lyrics&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.txt&lt;/span&gt;” , “ &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;w&lt;/span&gt;” ) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;outfifile&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;outfifile&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.write&lt;/span&gt;(“ \&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;n&lt;/span&gt;” &lt;span class=&quot;code-snippet__selector-class&quot;&gt;.join&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;zjl_lyrics&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这几行代码，我们就获得了周杰伦所有歌曲的歌词数据（见图1）。以这个 .txt 文件为基础，我们便可以进行词频统计了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJprm5DcZwlnzYdMWrGTVgmAIoDicKXQzq12rPOd8COK47g1VErv312bkA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;715&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;455.46263345195734&quot; data-ratio=&quot;0.6363636363636364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJp56UqSerNT4aSrZQ4pG1kEgOuUsrdfjicWtNHcEhpNMv7icAILadic6Neg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;715&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下附上一种在 Python 中分词的方法。首先引入 jieba 库（安装 ：pip install jieba）、pandas 库（安装 ：pip install pandas）、用于频次统计的 Counter 库，以及表单工具，代码如下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; jieba&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; jieba.analyse&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; pandas as pd&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from collections &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; Counter&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事先准备好一个中文的停用词表（.txt 文件，里面包含一些常见的、需要过滤的中文标点和虚词，可在网上下载），代码如下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;open&lt;/span&gt;(‘ chinese_stop_words.txt’ ) &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; f:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;stopwords = [line.strip() &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; line &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; f.readlines()]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;打开歌词文件，利用 jieba 库进行分词。分词之后，删除停用词、去除无用的符号等。用 Counter 库对清洗干净的词语进行频次统计。然后将统计结果用 pandas库转换为数据表单，存储为 Excel 文件，代码如下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fifile = open(“ zjl_lyrics.txt” ).read()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;words = jieba.lcut(fifile, cut_all=False, use_paddle=True)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;words = [w for w in words if w not in stopwords]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;words = [w.strip() for w in words]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;words = [w for w in words if w != ‘ ’ ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;words_fifilter = [w for w in words if len(w) &amp;gt; 1]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df = pd.DataFrame.from_dict(Counter(words_fifilter), orient=’ index’ ).&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;reset_index()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df = df.rename(columns={‘ index’ :’ words’ , 0:’ count’ })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;df.to_excel(“ 周杰伦分词结果 .xlsx” )&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此，我们便获得了分词后的单词及词频（见表1）。使用这个文档，我们就可以开始制作可视化了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpSq6tGe3mZztv8QQTDzV8MfA0ria4BW61glYxibof8sChnAAxldls7d9Q/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;752&quot; data-cropy1=&quot;32.113879003558715&quot; data-cropy2=&quot;453.6085409252669&quot; data-ratio=&quot;0.5598404255319149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpUFABu7b2T1MNDSnGEATY4UXwBhaLHib3YlqfgZxjFiajJUOHVD9ucElg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于是文本类数据，我们首先想到的可视化形式可能是文字云。如果你使用 Python，则可以直接基于刚才的分析结果，调用wordcloud库绘制文字云，代码如下。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;from wordcloud import WordCloud&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wc = WordCloud(font_path = ‘ Alibaba-PuHuiTi-Regular.ttf’ ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;background_color=” white” ,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;max_words = 2000)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wc.generate(‘ ‘ .join(words_fifilter))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import matplotlib.pyplot as plt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.imshow(wc)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.fifigure(fifigsize=(12,10), dpi = 300)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.axis(“ off” )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;plt.show()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;绘制结果如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpmNuviaZqeDhYE5BqgiaKujAyB8xtnPD6DWOSGenrPMAdm4BE25ok2Mfg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;645&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;367.25978647686827&quot; data-ratio=&quot;0.5689922480620155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpywzicFFmvQObZicI9zy5algPXcVoQtQACXzpTXgMYK9vr3r27RicsJh9g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，在代码工具内绘制文字云，进行定制化设计相对比较复杂。因此，也可以借助一些在线工具帮助我们实现更好的可视化效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，许多中文的工具都可以专门用来制作文字云，如微词云、易词云、图悦等&lt;/span&gt;&lt;span&gt;（相关总结可参考知乎专栏的一篇文章《词频统计工具哪家强，对比 8 款工具得出了结果》）。下面，我们以微词云为例进行演示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入微词云界面后，首先单击“导入单词”，进行数据导入。选择“从 Excel 中导入关键词”，然后上传我们刚才得到的包含单词和词频的 Excel 文档（需要注意的是，微词云目前对上传的 Excel 文件格式有一定要求，比如，列名必须叫“单词”和“词频”才能识别，详见其页面指引），即可生成文字云（见图3）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpHfp22xzITHOo2yfH6L7ocUia79icwKuCPCNWHy0B8Oiap1I6cbFk9IpYA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;757&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;331.355871886121&quot; data-ratio=&quot;0.4372523117569353&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpuXref5DV4y2Z1oJDLSfoLeBFwjJsMEf8Akeo0vk3Ezib37jFianKWRXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;757&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，微词云的页面上还有另外两种导入数据的选项。其中，“简单导入”支持用户输入用逗号隔开的单词。“分词筛词后导入”则支持用户粘贴长文本，然后由系统自动进行分词和词性判别。换句话说，如果你有一个文档文件，也可以直接粘贴进微词云进行分词。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接下来我们用周杰伦的歌词文档来尝试一下。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;选择“分词筛词后导入”，然后将图1 的 .txt 格式的文档粘贴进微词云。之后，单击“开始分词”，软件就会自动把词语切割出来，并按词性归类，结果如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpjSicL7hfVJhLBic96Q6ZFlibv6OcwN4FxlpFJQBwbicM62yWjqmGaYR5EQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;754&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;415.90747330960846&quot; data-ratio=&quot;0.5517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpXNLWo71jWzm81JqKTYx6ibcgDyX2b9WOc3EjIYcXnhPtib2abghvhynw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，所有的词语被按照动词、名词、形容词、人名等归类。词语后面的括号标注了词频。同时，微词云还自动帮我们把高频的词汇勾选出来。我们也可以根据个人需求，在这个界面中进一步编辑，例如只显示名词、只显示动词等，然后单击“确定使用所选单词”按钮，即可生成词云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后，我们可以在“配置”栏中编辑词云的显示方式。其中，“计算模式”指的是字体的大小是否严格与词频匹配，因此我们选择“严格比例”。另外，我们还可以更改文字的颜色，以及文字云中单词的数量等。在本案例中，我们把单词数量调整到 200（见图5）。调整完毕后，单击右上角的“下载到本地”按钮即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJp92Mju0VCmwHgDdN1PTtiar2QOOYt5e2Or4UmH3u3OGTia5cKmrkzuYYg/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;750&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;415.0355871886121&quot; data-ratio=&quot;0.552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpjhL8ooQR1g9GXs2DwDN82ZjjOn7JeFDcgcA76p6KW4b36kBhHAkpZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在左侧编辑区的“形状”中，可以替换词云的蒙版。其中既有内置的一些矢量形状， 也可以上传自己的图片（见图6，笔者上传了一张周杰伦的素材图片）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpjS2XDKew4EkKC5GTHibBib3QGcByakzAhgSuxvbnNkvkxguqibkmRfbjA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;238.99999999999997&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;362.71764705882356&quot; data-ratio=&quot;1.5188284518828452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpia3ib62uZxYBV2MVPplPYW41VtLDWWianLuSODj6Xp2kVlq5ToV9SCibJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;239&quot; data-width=&quot;170px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，虽然词云在视觉上比较有趣，但在展示数据上却不一定清晰。因此，我们也可以使用其他的图表来进行可视化。比如，可以用圆面积来展示最高频的词汇。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7 是使用 AI 工具绘制的。首先，我们在“图表工具”中选择“饼图”，按竖直方向将数据粘贴进去，单击“确定”按钮，即可生成对应面积的一系列圆形。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpjscvvljwHv20vb3IVp7yQLRxbCd3NibYiafgmLvRVfLetyZJqF0BS5bQ/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;471&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;437.713780918728&quot; data-ratio=&quot;0.9299363057324841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpC3H3tYUYGDMdnzx9XKgt3eHfpBFg1juCdZNLdJIr4M5SVKFxicVw1fQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;471&quot; data-width=&quot;283px&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，选中所有圆形，取消分组，即可对它们进行单独编辑。之后，我们分别为它们加上文字，并调整颜色、背景等，即可得到一幅圆面积图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上，我们讲解了使用 Python 分词和使用在线工具分词的两种方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要提醒的是，不同的分词途径，分词的结果可能不同（尤其是在语句比较复杂、生僻的情况下）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，对分词质量比较看重的读者有必要对比不同方法分词的效果，选择最优的方案。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot;&gt;本文节选自《数据可视化设计指南：从数据到新知（全彩）》一书，欢迎阅读本书了解更多精彩内容。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47215189873417723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpuuibTRFjfAIvzNk9Qpibx7OJo2GgxTcibEN3awzvWlkGaV2iaBn6l8dEibg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;790&quot; title=&quot;新知海报-01.gif&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;4.323651452282157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJp6t4q93wfv8diceSj82icdchuMCTGDydmUrWLGXCkI2ibDtAiaQyIJX4ffA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;723&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;179&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;179&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpiagbRozPyuk3nhNS3eM5nZGa4lymicnq8yFeH0zxG6J7ywCxgXGm961Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-width=&quot;162px&quot; title=&quot;数据可视化二维码.png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;限时五折优惠，快快扫码抢购吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94013&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/7QRTvkK2qC6EKB3qBHxT1pNjWWaBmsyddIgGDPoUFAfqOJ01k5aGCNzal5A2caXCzfFbcqXxc3kBc4nhicVjNDw/640?wx_fmt=gif&quot; data-ratio=&quot;1.6167664670658684&quot; data-w=&quot;334&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;参与抽奖&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;免费获赠本书&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PW0wIHxgg3lo1lsmL2oibgeEyicflJNXJpIcUz3OKYTJXjnKtBhclyhIicRP4BLIsT2ZyO6CXx7UPsgLNZcyYbdbg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;450&quot; data-width=&quot;166px&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;发布：刘恩惠&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;审核：陈歆懿&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt; &lt;section data-role=&quot;splitline&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;16401&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果喜欢本文&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;欢迎&lt;/span&gt; &lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;留言&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;丨&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享至朋友圈&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 三连&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;119077&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;&amp;lt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;  PAST · 往期回顾 &lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong data-brushtype=&quot;text&quot;&gt; &amp;gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NTk0NjMwOQ==&amp;amp;mid=2651172274&amp;amp;idx=1&amp;amp;sn=445ab2b7c11648c923b038940b2f916a&amp;amp;chksm=bd01c7988a764e8ed66603961de3848c3f98596b81a3841243c94c6cfd199ae78bfb2d6ff1b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;246&quot; data-ratio=&quot;0.42592592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3n9m4ZyRZYsJRr4agibHb4pJFLe66Z9gkB7NpKicBaj7VKFcGx3Ny8MbD11YKTeP1Nh2jEWBd51Cpsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;100%&quot; title=&quot;默认标题__2023-02-10+17_41_32.png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NTk0NjMwOQ==&amp;amp;mid=2651172274&amp;amp;idx=1&amp;amp;sn=445ab2b7c11648c923b038940b2f916a&amp;amp;chksm=bd01c7988a764e8ed66603961de3848c3f98596b81a3841243c94c6cfd199ae78bfb2d6ff1b9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;【值得收藏】9种让你受益终身的数据分析思维&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【值得收藏】9种让你受益终身的数据分析思维&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;574&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;244&quot; data-ratio=&quot;0.4777777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PW0wIHxgg3npgLu0khEqdibc8UNib9mUOFWz3Av7aEWkgib7uEOIIVCVonIgnJrUgibElFcvUXFAIMOvoxHX3gqU5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;900-400_画板 1-1.png&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTMNtGy7KWfCrdJibAYY6HtIGhhtVOFQXzkE5GcmZIhTLgxggMlCe3oMwqKNesBDoU7kfgzFHuxyeA/640?wx_fmt=gif&quot; data-w=&quot;160&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文，查看本书详情！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8c19b818ff750828a7ef19e7d20375d1</guid>
<title>【JVM盲点补漏系列】「并发编程的难题和挑战」深入理解JMM及JVM内存模型知识体系_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/61t943u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_1&quot;/&gt;并发编程的难题和挑战&lt;/h2&gt; 
&lt;p&gt;在并发编程的技术领域中，对于我们而言的难题主要有两个：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;多线程之间如何进行通信和线程之间如何同步，通信是指线程之间以何种机制来交换信息。&lt;/li&gt;&lt;/ol&gt; 
&lt;h2&gt;&lt;a id=&quot;_7&quot;/&gt;多线程的线程通信机制&lt;/h2&gt; 
&lt;p&gt;在命令式编程中，线程之间的通信机制有两种：&lt;strong&gt;共享内存&lt;/strong&gt;和&lt;strong&gt;消息传递&lt;/strong&gt;。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;共享内存的方式，&lt;strong&gt;多线程之间共享公共的状态&lt;/strong&gt;（变量），那么线程之间通过写/读内存中的公共状态（变量）来隐式进行通信。在此模式下，同步实现是隐式进行的，由于消息的发送必须在消息的接收之前。&lt;/li&gt;&lt;li&gt;消息传递的方式，&lt;strong&gt;多线程之间没有公共的状态&lt;/strong&gt;（变量），那么线程之间必须通过明确的传递状态（变量）来显式进行通信。在此模式下，同步实现是显式进行的，必须显式指定某个方法或某段代码需要在线程之间互斥执行。&lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;Java_14&quot;/&gt;Java中的同步模式是什么？&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;同步机制&lt;/strong&gt;是指程序用于控制不同线程之间操作发生相对顺序的机制。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Java生态中的并发编程模型采用的是共享内存模型，因此在Java线程之间的通信总是隐式进行， 整个通信过程对开发者是黑盒的，如果编写多线程程序的开发者不深入理解这种隐式模式下的线程之间通信机制，就会会出现内存可见性和一致性的问题，我们统称为线程不安全问题。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_20&quot;/&gt;存在内存可见问题&lt;/h3&gt; 
&lt;p&gt;Java应用程序中， 所有实例域、静态域和数组元素存储在堆内存中， 堆内存在线程之间共享。会存在这内存可见性问题。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_24&quot;/&gt;不存在内存可见问题&lt;/h3&gt; 
&lt;p&gt;局部变量(Local variables) ， 方法定义参数（java语言规范称之为formal method parameters） 和异常处理器参数(exception handler parameters) 不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;所以，我们在开发多线程场景下的程序的时候主要需要关注的就是内存可见问题变量，包含：实例域、静态域和数组元素。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;而为了降低并发编程的难度和门槛，这些线程之间的数据同步和通信控制就交由一个特定的数据模型进行控制和管理，我们称之为Java内存模型（JMM）。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;JavaJMM_32&quot;/&gt;Java内存模型（JMM）&lt;/h2&gt; 
&lt;p&gt;JMM决定在程序运行中，一个线程对共享变量的写入何时对另一个线程可见。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;JMM_36&quot;/&gt;JMM定义了线程和主内存之间的抽象关系&lt;/h3&gt; 
&lt;p&gt;线程之间的共享变量存储在&lt;strong&gt;主内存&lt;/strong&gt;中，每个线程都有一个私有的&lt;strong&gt;本地内存&lt;/strong&gt; ， 本地内存中存储了该线程以读/写共享变量的副本。&lt;/p&gt; 
&lt;p&gt;本地内存是JMM的一个抽象概念， 并不真实存在。它涵盖了缓存， 写缓冲区， 寄存器以及其他的硬件和编译器优化。&lt;/p&gt; 
&lt;p&gt;Java 内存模型的抽象示意图如下：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f2c86d69eebce5a8a2f383f035d6c1ac.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;由上图可见，线程A与线程B之间如要数据通信，需要有以下两个步骤：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;线程A把本地内存A中更新过的共享变量刷新到&lt;strong&gt;主内存&lt;/strong&gt;中去。&lt;/li&gt;&lt;li&gt;线程B到主内存中去读取线程A之前已更新过的&lt;strong&gt;共享变量&lt;/strong&gt;。&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;下面通过示意图来说明这两个步骤：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/00a415c9844d4c4c18fc776873451855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;线程A在执行时，把更新后的x值，临时存放在自己的本地内存A中。&lt;/li&gt;&lt;li&gt;线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变了。&lt;/li&gt;&lt;li&gt;线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变了。&lt;/li&gt;&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;总结一下就是，这两个步骤数据角度而言是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互， 来为程序提供内存可见性保证。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_63&quot;/&gt;线程不安全因素之一（指令重排序问题）&lt;/h3&gt; 
&lt;p&gt;基于上述所说的场景之下，JVM为了在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。在此我们将按照&lt;strong&gt;重排序&lt;/strong&gt;的执行时间前后分为重排序分三种类型，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/52bbd6002a82fcd898e02b8c48f4ea55.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;第一步属于&lt;strong&gt;编译器&lt;/strong&gt;重排序：&lt;strong&gt;编译器优化的重排序&lt;/strong&gt;，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第二步属于&lt;strong&gt;处理器&lt;/strong&gt;重排序：&lt;strong&gt;指令级并行的重排序&lt;/strong&gt;，现代处理器采用了指令级并行技术(Instruction-Level Parallelism， ILP) 来将多条指令重叠执行。如果不存在数据依赖性， 处理器可以改变语句对应机器指令的执行顺序。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;第三步属于&lt;strong&gt;处理器&lt;/strong&gt;重排序：&lt;strong&gt;内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行，此处特别是针对与本地内存和共享主存之间的更新操作的一致性和可见性&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;这些重排序都可能会导致多线程程序出现内存可见性问题。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;JMM_77&quot;/&gt;JMM解决重排序的线程不安全问题&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;_79&quot;/&gt;解决编译器级别重排序&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JMM的编译器重排序规则&lt;/strong&gt;会禁止特定类型的编译器重排序，此处注意：&lt;strong&gt;不是所有的编译器重排序都要禁止&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;_83&quot;/&gt;解决处理器级别重排序&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;JMM的处理器重排序规则会要求java编译器在生成指令序列时， 插入特定类型的内存屏障(memory barriers， 也可以称之为memory fence）指令&lt;/strong&gt;， 通过 &lt;strong&gt;内存屏障&lt;/strong&gt; 指令来禁止&lt;strong&gt;特定类型的处理器重排序&lt;/strong&gt;，&lt;strong&gt;此处注意：不是所有的处理器重排序都要禁止)&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;总结一下，针对于JMM属于语言级的内存模型， 它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，从而实现了内存的可见性以及一致性。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h3&gt;&lt;a id=&quot;_89&quot;/&gt;处理器重排序与内存屏障指令&lt;/h3&gt; 
&lt;p&gt;上面说了其实是通过插入了内存屏障指令，从而控制住了对应的处理器级别的指令重排。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_93&quot;/&gt;线程不安全因素之一（写缓存处理模式）&lt;/h4&gt; 
 
&lt;p&gt;这个特性会对内存操作的执行顺序产生重要的影响，处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/22896428a7f38f84f876f936c6e07d47.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;处理器A&lt;/strong&gt;和&lt;strong&gt;处理器B&lt;/strong&gt;可以同时把共享变量写入自己的写缓冲区(A1，B1)&lt;/li&gt;&lt;li&gt;从内存中读取另一个共享变量(A2，B2)&lt;/li&gt;&lt;li&gt;最后才把自己写缓存区中保存的脏数据刷新到内存中(A3，B3)。&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;从内存操作实际发生的顺序来看，直到处理器A执行A3来刷新自己的写缓存区，写操作A1才算真正执行了。虽然处理器A执行内存操作的顺序为：A1-&amp;gt;A2，但内存操作实际发生的顺序却是：A2-&amp;gt;A1。此时，处理器A的内存操作顺序被重排序了(处理器B的情况和处理器A一样)。&lt;/p&gt; 
&lt;p&gt;由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写-读操作重排序。常见的处理器都允许Store-Load重排序，常见的处理器都不允许对存在数据依赖的操作做重排序。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;_112&quot;/&gt;内存屏障指令&lt;/h2&gt; 
&lt;p&gt;为了保证内存可见性， java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：&lt;/p&gt; 
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;内存屏障类型&lt;/th&gt;&lt;th&gt;指令示例&lt;/th&gt;&lt;th&gt;备注&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;LoadLoad Barries&lt;/td&gt;&lt;td&gt;Load1\LoadLoad\Load2&lt;/td&gt;&lt;td&gt;确保Load1数据的装载，之前于Load2及所有后续装载指令的装载&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StoreStore Barries&lt;/td&gt;&lt;td&gt;Store1\StoreStore\Store2&lt;/td&gt;&lt;td&gt;确保Store1数据对其他处理器可见(刷新到内存)，之前于Store2及所有后续存储指令的存储。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LoadStore Barriers&lt;/td&gt;&lt;td&gt;Load1\ LoadStore\Store2&lt;/td&gt;&lt;td&gt;确保Load1数据装载， 之前于Store2及所有后续的存储指令刷新到内存&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;StoreLoad Barriers&lt;/td&gt;&lt;td&gt;Store1\StoreLoad\Load2&lt;/td&gt;&lt;td&gt;确保Storel数据对其他处理器变得可见(指刷新到内存)，之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令(存储和装载指令)完成之后，才执行该屏障之后的内存访问指令。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt; 
 &lt;p&gt;**StoreLoad Barriers是一个“全能型”的屏障， 它同时具有其他三个屏障的效果。现代的多处理器大都支持该屏障(其他类型的屏障不一定被所有处理器支持)。执行该屏障开销会很昂贵，因为当前处理器通常要把写缓冲区中的数据全部刷新到内存中(buffer fully flush) **。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;未完善待续！&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1707f430501f60ea96a7fdcaa2df884a</guid>
<title>为什么你的抓包工具抓不到baidu的数据包</title>
<link>https://toutiao.io/k/2okijkr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;最近，有位读者问起一个奇怪的事情，他说他想抓一个&lt;code&gt;baidu.com&lt;/code&gt;的数据包，体验下看包的乐趣。&lt;/p&gt;&lt;p&gt;但却发现“&lt;strong&gt;抓不到&lt;/strong&gt;”，这就有些奇怪了。&lt;/p&gt;&lt;p&gt;我来还原下他的操作步骤。&lt;/p&gt;&lt;p&gt;首先，通过&lt;code&gt;ping&lt;/code&gt;命令，获得访问百度时会请求哪个IP。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; ping baidu.com&lt;br/&gt;PING baidu.com (&lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;) bytes of &lt;span&gt;data&lt;/span&gt;.&lt;br/&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt; (&lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt;): icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;49&lt;/span&gt; time=&lt;span&gt;30.6&lt;/span&gt; ms&lt;br/&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt; (&lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt;): icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;49&lt;/span&gt; time=&lt;span&gt;30.6&lt;/span&gt; ms&lt;br/&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt; (&lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt;): icmp_seq=&lt;span&gt;3&lt;/span&gt; ttl=&lt;span&gt;49&lt;/span&gt; time=&lt;span&gt;30.6&lt;/span&gt; ms&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的结果可以知道请求&lt;code&gt;baidu.com&lt;/code&gt;时会去访问&lt;code&gt;39.156.66.10&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;于是用下面的&lt;code&gt;tcpdump&lt;/code&gt;命令进行抓包，大概的意思是抓&lt;code&gt;eth0&lt;/code&gt;网卡且&lt;code&gt;ip&lt;/code&gt;为&lt;code&gt;39.156.66.10&lt;/code&gt;的网络包，保存到&lt;code&gt;baidu.pcap&lt;/code&gt;文件中。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; tcpdump &lt;span&gt;-i&lt;/span&gt; eth0 host &lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt; &lt;span&gt;-w&lt;/span&gt; baidu.pcap&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时在浏览器中打开&lt;code&gt;baidu.com&lt;/code&gt;网页。或者在另外一个命令行窗口，直接用&lt;code&gt;curl&lt;/code&gt;命令来模拟下。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; &lt;span&gt;curl&lt;/span&gt; &lt;span&gt;&#x27;https://baidu.com&#x27;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按理说，&lt;strong&gt;访问baidu.com的数据包肯定已经抓下来了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;然后停止抓包。&lt;/p&gt;&lt;p&gt;再用&lt;code&gt;wireshark&lt;/code&gt;打开&lt;code&gt;baidu.pcap&lt;/code&gt;文件，在过滤那一栏里输入&lt;code&gt;http.host == &quot;baidu.com&quot;&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;此时发现，一无所获。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.22037037037037038&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCr3fo1ukjOibqXStCMs21EqsCvzzH7kB9CoKDwgLZl5IK8XKhahxuibGg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;在wireshark中搜索baidu的包，发现一无所获&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这是为啥？&lt;/p&gt;&lt;p&gt;到这里，有经验的小伙伴，其实已经知道问题出在哪里了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;为什么没能抓到包&lt;/h2&gt;&lt;p&gt;这其实是因为他访问的是HTTPS协议的baidu.com。HTTP协议里的Host和实际发送的request body都会被加密。&lt;/p&gt;&lt;p&gt;正因为被加密了，所以没办法通过&lt;code&gt;http.host&lt;/code&gt;进行过滤。&lt;/p&gt;&lt;p&gt;但是。&lt;/p&gt;&lt;p&gt;虽然加密了，如果想筛选还是可以筛的。&lt;/p&gt;&lt;p&gt;HTTPS握手中的Client Hello阶段，里面有个扩展&lt;code&gt;server_name&lt;/code&gt;，会记录你想访问的是哪个网站，通过下面的筛选条件可以将它过滤出来。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;  tls.handshake.extensions_server_name == &lt;span&gt;&quot;baidu.com&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9055555555555556&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCggGplcUjOW6NAIv3untzR7kM4T1U5ggxia4Qkh5WMj5Agd4xWd1CrHQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;通过tls的扩展server_name可以搜索到baidu的包&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;此时选中其中一个包，点击右键，选中&lt;code&gt;Follow-TCP Stream&lt;/code&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4398148148148148&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCnVkRwxOibusnLUe2DBZsyeqRIicoue0vPYyNuibVvQEEqsYNmZJZ5JR9w/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;右键找到tcp 流&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;这个TCP连接的其他相关报文全都能被展示出来。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6685185185185185&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCibXOKeaPF230PzQIfuJianK8JVJ9OwMY81zZicoicKOICz6nGZUo39Ra9g/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;HTTPS抓包&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;从截图可以看出，这里面完整经历了&lt;strong&gt;TCP握手&lt;/strong&gt;和&lt;strong&gt;TLS加密握手&lt;/strong&gt;流程，之后就是&lt;strong&gt;两段加密信息&lt;/strong&gt;和&lt;strong&gt;TCP挥手流程&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;可以看出18号和20号包，一个是从端口56028发到443，一个是443到56028的回包。&lt;/p&gt;&lt;p&gt;一般来说，像&lt;code&gt;56028&lt;/code&gt;这种比较大且没啥规律的数字，都是&lt;strong&gt;客户端随机生成的端口号&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;而&lt;code&gt;443&lt;/code&gt;，则是HTTPS的服务器端口号。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;HTTP用的是80端口，如果此时对着80端口抓包，也会抓不到数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;粗略判断，18号和20号包分别是客户端请求&lt;code&gt;baidu.com&lt;/code&gt;的请求包和响应包。&lt;/p&gt;&lt;p&gt;点进去看会发现&lt;strong&gt;URL和body都被加密了&lt;/strong&gt;，一无所获。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么问题就来了。有没有办法解密里面的数据呢？&lt;/p&gt;&lt;p&gt;有办法。我们来看下怎么做。&lt;/p&gt;&lt;h2&gt;解密数据包&lt;/h2&gt;&lt;p&gt;还是先执行tcpdump抓包&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; tcpdump &lt;span&gt;-i&lt;/span&gt; eth0 host &lt;span&gt;39.156&lt;/span&gt;.&lt;span&gt;66.10&lt;/span&gt; &lt;span&gt;-w&lt;/span&gt; baidu.pcap&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在另外一个命令行窗口下执行下面的命令，&lt;strong&gt;目的是将加密的key导出，并给出对应的导出地址&lt;/strong&gt;是&lt;code&gt;/Users/xiaobaidebug/ssl.key&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; export SSLKEYLOGFILE=/Users/xiaobaidebug/ssl.key&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在同一个命令行窗口下，继续执行curl命令或用命令行打开chrome浏览器。&lt;strong&gt;目的是为了让curl或chrome继承这个环境变量。&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt; &lt;span&gt;curl&lt;/span&gt; &lt;span&gt;&#x27;https://baidu.com&#x27;&lt;/span&gt;&lt;br/&gt;或者&lt;br/&gt;&lt;span&gt;$&lt;/span&gt; open &lt;span&gt;-a&lt;/span&gt; Google\ Chrome &lt;span&gt;#在mac里打开chrome浏览器&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此时会看到在&lt;code&gt;/Users/xiaobaidebug/&lt;/code&gt;下会多了一个&lt;code&gt;ssl.key&lt;/code&gt;文件。&lt;/p&gt;&lt;p&gt;这时候跟着下面的操作修改&lt;code&gt;wireshark&lt;/code&gt;的配置项。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6606741573033708&quot; data-type=&quot;png&quot; data-w=&quot;890&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwC27aib4vvXUvPuLkkqSuRqzBEKjjU6ibbwqfibc0e1KD4atHhvdmFLicxvg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;打开wireshark的配置项&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;找到Protocols之后，使劲往下翻，找到&lt;code&gt;TLS&lt;/code&gt;那一项。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4777777777777778&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCY1AOFH9El2xntd1s7qfQsTlVASdJDwVHORL3nic04H68oiaD3pfQibsaw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;在配置项中找到Protocols&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;将导出的&lt;code&gt;ssl.key&lt;/code&gt;文件路径输入到这里头。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5879629629629629&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCQhUsUMicGdmK4kQ6tz8GOgp7KdyGIdVxQg3QmhW0j3iaaH6w7Sz7Y2UQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;在Protocols中找到TLS那一栏&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;点击确定后，就能看到&lt;strong&gt;18号和20号数据包已经被解密&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6546296296296297&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwClnA4gzqhPtiaVkMssKkCMvkEa1WVWJGbQhSpUK6AibyUly3WchXJOoRQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;解密后的数据包内容&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;此时再用&lt;code&gt;http.host == &quot;baidu.com&quot;&lt;/code&gt;，就能过滤出数据了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.22962962962962963&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCUoQ8olJPPMWUEep0TpTFHLlND4xgCiaibDs9k1CmGqrzRick0UBOPYmgg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;解密后的数据包中可以过滤出baidu的数据包&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;到这里，其实&lt;strong&gt;看不了数据包的问题&lt;/strong&gt;就解决了。&lt;/p&gt;&lt;p&gt;但是，新的问题又来了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;ssl.key文件是个啥？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这就要从HTTPS的加密原理说起了。&lt;/p&gt;&lt;h3&gt;HTTPS握手过程&lt;/h3&gt;&lt;p&gt;HTTPS的握手过程比较繁琐，我们来回顾下。&lt;/p&gt;&lt;p&gt;先是建立TCP连接，毕竟HTTP是基于TCP的应用层协议。&lt;/p&gt;&lt;p&gt;在TCP成功建立完协议后，就可以开始进入HTTPS阶段。&lt;/p&gt;&lt;p&gt;HTTPS可以用TLS或者SSL啥的进行加密，下面我们以&lt;code&gt;TLS1.2&lt;/code&gt;为例。&lt;/p&gt;&lt;p&gt;总的来说。整个加密流程其实分为&lt;strong&gt;两阶段&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一阶段&lt;/strong&gt;是TLS四次握手，这一阶段主要是利用&lt;strong&gt;非对称加密&lt;/strong&gt;的特性各种交换信息，最后得到一个&quot;会话秘钥&quot;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;是则是在第一阶段的&quot;会话秘钥&quot;基础上，进行&lt;strong&gt;对称加密&lt;/strong&gt;通信。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.1879629629629629&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCbaBD1Rgd5WGSPFKxwm3MjIGMCbXEiczk8cib8j7o0Jktl3kgWB2OwfjA/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;TLS四次握手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们先来看下第一阶段的TLS四次握手是怎么样的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一次握手&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第二次握手&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第三次握手&lt;/strong&gt;：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;Client Key Exchange&lt;/code&gt;: 此时客户端再生成&lt;strong&gt;一个随机数&lt;/strong&gt;，叫 &lt;code&gt;pre_master_key &lt;/code&gt;。从第二次握手的&lt;strong&gt;服务器证书&lt;/strong&gt;里取出服务器公钥，用公钥加密 &lt;code&gt;pre_master_key&lt;/code&gt;，发给服务器。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;Change Cipher Spec&lt;/code&gt;: 客户端这边&lt;strong&gt;已经拥有三个随机数&lt;/strong&gt;：客户端随机数，服务器随机数和pre_master_key，用这三个随机数进行计算得到一个&quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&quot;。此时客户端通知服务端，后面会用这个会话秘钥进行对称机密通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;Encrypted Handshake Message&lt;/code&gt;：客户端会把迄今为止的通信数据内容生成一个摘要，用&quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&quot;加密一下，发给服务器做校验，此时客户端这边的握手流程就结束了，因此也叫&lt;strong&gt;Finished报文&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;第四次握手&lt;/strong&gt;：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;Change Cipher Spec&lt;/code&gt;：服务端此时拿到客户端传来的 &lt;code&gt;pre_master_key&lt;/code&gt;（虽然被服务器公钥加密过，但服务器有私钥，能解密获得原文），集齐三个随机数，跟客户端一样，用这三个随机数通过同样的算法获得一个&quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&quot;。此时服务器告诉客户端，后面会用这个&quot;会话秘钥&quot;进行加密通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• &lt;code&gt;Encrypted Handshake Message&lt;/code&gt;：跟客户端的操作一样，将迄今为止的通信数据内容生成一个摘要，用&quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&quot;加密一下，发给客户端做校验，到这里，服务端的握手流程也结束了，因此这也叫&lt;strong&gt;Finished报文&lt;/strong&gt;。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;四次握手中，客户端和服务端最后都拥有&lt;strong&gt;三个随机数&lt;/strong&gt;，他们很关键，我特地加粗了表示。&lt;/p&gt;&lt;p&gt;第一次握手，产生的客户端随机数，叫&lt;code&gt;client random&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;第二次握手时，服务器也会产生一个服务器随机数，叫&lt;code&gt;server random&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;第三次握手时，客户端还会产生一个随机数，叫&lt;code&gt;pre_master_key&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;这三个随机数共同构成最终的&lt;strong&gt;对称加密秘钥&lt;/strong&gt;，也就是上面提到的&quot;&lt;strong&gt;会话秘钥&lt;/strong&gt;&quot;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2777777777777778&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCibY2A20oUu6XuKFnWvHYqcia7XKxb8iaNRzsE7Lb7uv2VJCX6p4d1PtSw/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;三个随机数生成对称秘钥&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;你可以简单的认为，&lt;strong&gt;只要知道这三个随机数，你就能破解HTTPS通信。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;而这三个随机数中，&lt;code&gt;client random&lt;/code&gt; 和 &lt;code&gt;server random&lt;/code&gt; 都是&lt;strong&gt;明文&lt;/strong&gt;的，谁都能知道。&lt;strong&gt;而&lt;code&gt;pre_master_key&lt;/code&gt;却不行，它被服务器的公钥加密过，只有客户端自己，和拥有对应服务器私钥的人能知道。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所以问题就变成了，&lt;strong&gt;怎么才能得到这个&lt;code&gt;pre_master_key&lt;/code&gt;？&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;怎么得到pre_master_key&lt;/h2&gt;&lt;p&gt;服务器私钥不是谁都能拿到的，所以问题就变成了，&lt;strong&gt;有没有办法从客户端那拿到这个&lt;code&gt;pre_master_key&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;有的。&lt;/p&gt;&lt;p&gt;客户端在使用HTTPS与服务端进行数据传输时，是需要先基于TCP建立HTTP连接，然后再调用客户端侧的TLS库（OpenSSL、NSS）。触发TLS四次握手。&lt;/p&gt;&lt;p&gt;这时候如果加入环境变量SSLKEYLOGFILE就可以干预TLS库的行为，让它输出一份含有&lt;code&gt;pre_master_key&lt;/code&gt;的文件。这个文件就是我们上面提到的&lt;code&gt;/Users/xiaobaidebug/ssl.key&lt;/code&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5296296296296297&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwC48iahhIISwRmdLbZsMeoek4FHkZomIIdnozia5EMsVh2unjNpyEkM1Sg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;将环境变量注入到curl和chrome中&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;但是，虽然TLS库支持导出key文件。但前提也是，上层的应用程序在调用TLS库的时候，支持通过&lt;code&gt;SSLKEYLOGFILE&lt;/code&gt;环境触发TLS库导出文件。实际上，也&lt;strong&gt;并不是所有应用程序都支持将SSLKEYLOGFILE&lt;/strong&gt;。只是目前常见的curl和chrome浏览器都是支持的。&lt;/p&gt;&lt;h2&gt;SSLKEYLOGFILE文件内容&lt;/h2&gt;&lt;p&gt;再回过头来看&lt;code&gt;ssl.key&lt;/code&gt;文件里的内容。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# SSL/TLS secrets log file, generated by NSS&lt;/span&gt;&lt;br/&gt;CLIENT_RANDOM &lt;span&gt;5709&lt;/span&gt;aef8ba36a8eeac72bd6f970a74f7533172c52be41b200ca9b91354bd662b &lt;span&gt;09&lt;/span&gt;d156a5e6c0d246549f6265e73bda72f0d6ee81032eaaa0bac9bea362090800174e0effc93b93c2ffa50cd8a715b0f0&lt;br/&gt;CLIENT_RANDOM &lt;span&gt;57&lt;/span&gt;d269386549a4cec7f91158d85ca1376a060ef5a6c2ace04658fe88aec48776 &lt;span&gt;48&lt;/span&gt;c16429d362bea157719da5641e2f3f13b0b3fee2695ef2b7cdc71c61958d22414e599c676ca96bbdb30eca49eb488a&lt;br/&gt;CLIENT_RANDOM &lt;span&gt;5&lt;/span&gt;fca0f2835cbb5e248d7b3e75180b2b3aff000929e33e5bacf5f5a4bff63bbe5 &lt;span&gt;424&lt;/span&gt;e1fcfff35e76d5bf88f21d6c361ee7a9d32cb8f2c60649135fd9b66d569d8c4add6c9d521e148c63977b7a95e8fe8&lt;br/&gt;CLIENT_RANDOM be610cb1053e6f3a01aa3b88bc9e8c77a708ae4b0f953b2063ca5f925d673140 c26e3cf83513a830af3d3401241e1bc4fdda187f98ad5ef9e14cae71b0ddec85812a81d793d6ec934b9dcdefa84bdcf3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有三列。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一列&lt;/strong&gt;是CLIENT_RANDOM，意思是接下来的&lt;strong&gt;第二列&lt;/strong&gt;就是&lt;strong&gt;客户端随机数&lt;/strong&gt;，再接下来的&lt;strong&gt;第三列&lt;/strong&gt;则是&lt;code&gt;pre_master_key&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;但是问题又来了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这么多行，wireshark怎么知道用哪行的pre_master_key呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;wireshark&lt;/code&gt;是可以获得数据报文上的&lt;code&gt;client random&lt;/code&gt;的。&lt;/p&gt;&lt;p&gt;比如下图这样。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6851851851851852&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCOYzB4M6qFotOibQGxsMOa6rQMRR90ic1hDvDmvkv1QuM4PwABMDsvG2Q/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;Client Hello 里的客户端随机数&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;注意上面的客户端随机数是以 &lt;code&gt;&quot;bff63bbe5&quot;&lt;/code&gt;结尾的。&lt;/p&gt;&lt;p&gt;同样，还能在数据报文里拿到&lt;strong&gt;server random&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7638888888888888&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCTRrKwUrAlNcWd39GBKYMlc6mzkU61dUEnCsvSVvcY52ETWrsiaKFLIQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;找到server random&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;此时将&lt;code&gt;client random&lt;/code&gt;放到ssl.key的第二列里挨个去做匹配。&lt;/p&gt;&lt;p&gt;就能找到对应的那一行记录。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15833333333333333&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIialv6kg0JthaZDYINaceCvwCS1Od4bgLkMv2XTotWCL6R0LiabBpvYSTF7tLVBO2KicOcoyX6rRBN2wg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;ssl.key里的数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;注意第二列的那串字符串，也是以 &lt;code&gt;&quot;bff63bbe5&quot;&lt;/code&gt;结尾的，它其实就是前面提到的&lt;code&gt;client random&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;再取出这一行的&lt;strong&gt;第三列&lt;/strong&gt;数据，就是我们想要的&lt;code&gt;pre_master_key&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;那么这时候&lt;code&gt;wireshark&lt;/code&gt;就集齐了三个随机数，此时就可以计算得到&lt;strong&gt;会话秘钥&lt;/strong&gt;，通过它对数据进行解密了。&lt;/p&gt;&lt;p&gt;反过来，正因为需要客户端随机数，才能定位到&lt;code&gt;ssl.key&lt;/code&gt;文件里对应的&lt;code&gt;pre_master_key&lt;/code&gt;是哪一个。而只有TLS第一次握手（&lt;code&gt;client hello&lt;/code&gt;）的时候才会有这个随机数，所以如果你想用解密HTTPS包，就必须将TLS四次握手能抓齐，才能进行解密。如果连接早已经建立了，数据都来回传好半天了，这时候你再去抓包，是没办法解密的。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 文章开头通过抓包baidu的数据包，展示了用wireshark抓包的简单操作流程。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• HTTPS会对HTTP的URL和Request Body都进行加密，因此直接在&lt;code&gt;filter栏&lt;/code&gt;进行过滤&lt;code&gt;http.host == &quot;baidu.com&quot;&lt;/code&gt;会一无所获。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• HTTPS握手的过程中会先通过非对称机密去交换各种信息，其中就包括3个随机数，再通过这三个随机数去生成对称机密的会话秘钥，后续使用这个会话秘钥去进行对称加密通信。如果能获得这三个随机数就能解密HTTPS的加密数据包。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 三个随机数，分别是客户端随机数（client random），服务端随机数（server random）以及pre_master_key。前两个，是明文，第三个是被服务器公钥加密过的，在客户端侧需要通过SSLKEYLOGFILE去导出。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 通过设置SSLKEYLOGFILE环境变量，再让curl或chrome会请求HTTPS域名，会让它们在调用TLS库的同时导出对应的sslkey文件。这个文件里包含了三列，其中最重要的是第二列的client random信息以及第三列的pre_master_key。第二列client random用于定位，第三列pre_master_key用于解密。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;参考资料&lt;/h2&gt;&lt;p&gt;极客时间 -《网络排查案例课》&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;&lt;span&gt;别说了，一起在知识的海洋里呛水吧&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;Mzg5NDY2MDk4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AnAgeMhDIianpibeb1icaNfMQWI9DibKw3EcA2nvqMtwQ1GuX5bFuupzh6LaH1AkOZggtabj6t0mXvgIGibhwUYCz4w/0?wx_fmt=png&quot; data-nickname=&quot;小白debug&quot; data-alias=&quot;xiaobaidebug&quot; data-signature=&quot;答应我，关注之后，好好学技术，别只是收藏我的表情包。。&quot; data-from=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;扫码关注公众号「网管叨bi叨」&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0188679245283019&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4icJbGAQ8RjXUUVdUZsGADuMBVWePgn7tfrWjjHyc6b8kXTQ7Sdkp0QQFFK4mel5tniczqooMna1CA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;给网管个星标，第一时间吸我的知识 👆&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网管整理了一本《Go 开发参考书》收集了70多条开发实践。去公众号回复【gocookbook】领取！还有一本《k8s 入门实践》讲解了常用软件在K8s上的部署过程，公众号回复【k8s&lt;/span&gt;&lt;span&gt;】即可领取！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得有用就点个在看&lt;/span&gt;&lt;span&gt;  👇👇👇&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5342ea092a409459932d4e0fb7baf0d2</guid>
<title>C语言中的const竟是个 &amp;quot;冒牌货&amp;quot;</title>
<link>https://toutiao.io/k/87lb6w4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content              autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;15&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;来自公众号：&lt;span&gt;混说Linux&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;是限定一个变量不允许改变（&lt;strong&gt;只读&lt;/strong&gt;），使用const在一定程度上可以提高程序的安全性和可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 我们先来看看const的基础知识&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void main()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    const int a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int const b;         // 和前面一个意思一样，代表常整型数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    const int *c;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int const *d;        // 和前面一个意思一样，表示所指向的内存数据不能被修改，但是本身可以修改&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int * const e;       // 指针变量不能指向其他的地址，但是它所指向内存数据可以被修改&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    const int * const f; // 指针变量不能指向其他的地址，它所指向内存数据也不可以被修改&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来做一个关于const的实验：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    a = &lt;span&gt;11&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 编译报错：error: assignment of read-only variable ‘a’&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面代码看来const好像确实是限定一个变量不允许改变（只读），定义的变量 a 貌似变成了一个常量一样，那我们接下来继续：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;// 貌似定义的 a 是一个常量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;// a = 11;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;int&lt;/span&gt; *p = (&lt;span&gt;int&lt;/span&gt; *)&amp;amp;a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *p = &lt;span&gt;11&lt;/span&gt;;   &lt;span&gt;// 通过指针间接赋值试试看&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;a = %d \n&quot;&lt;/span&gt;, a);   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 编译成功   打印结果 a = 11 &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们发现貌似定义的 a是一个常量，但是通过指针却可以间接的修改 a 的值，const不是限定变量不允许修改吗？怎么被改了？这样看来C语言中const好像确实是一个“冒牌货”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么同样的代码，我们看看在C++中的表现：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void main()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // 貌似定义的 a 是一个常量&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const int a = 10;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // a = 11;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  int *p = (int *)&amp;amp;a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  *p = 11;   // 间接赋值&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  printf(&quot;a = %d \n&quot;, a);   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  system(&quot;pause&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 打印结果 a = 10  （结果不应该是 a = 11  ？？？？？？？？？）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 大家可以尝试 C 和 C++ 都进行编译对比一下。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么 c 和 c++ 编译的结果大相径庭？好好想想，如果是你用 c++写了一个这样的程序是用在银行后台算账的，那就麻烦大了，竟然存在这样的bug？银行每天流水那么多，账要是错了，想想都害怕吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实在 c++语言里面const修饰的才算是一个真正的常量，在 c 语言中 const 可以说是个“冒牌货”。为什么会这样？其实是 c++ 编译器对 const 进行了加强，当 c++ 编译器遇到常量声明时，不会像 c 语言一样给这样const对象单独分配内存，c 语言一般是放在只读数据区，而 c ++ 编译器是把const对象放在一个符号表里面（我个人觉得放在符号表里面的其中一个原因可能是想减少一些存储操作次数），至于符号表是属于内存布局（文章：&lt;/span&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNDQwMjIwNQ==&amp;amp;mid=2247483770&amp;amp;idx=1&amp;amp;sn=6b8556258294a0371c01fb626b98e026&amp;amp;chksm=96c1fa08a1b6731ede7b4207087591d6dd0c7040ab6d02b0e1db6b9fde9e32ab835c415ba406&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot; tab=&quot;innerlink&quot; data-itemshowtype=&quot;0&quot;&gt;&lt;span&gt;你该知道你写的程序的内存布局&lt;/span&gt;&lt;/a&gt;&lt;span&gt;）中的哪一块，我也不知道，写 c++ 编译器的人才知道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 c++ 中使用 const 对象（比如打印这个对象）的时候，就会从符号表里面把对象的值拿出来使用，比如printf(&quot;a = %d \n&quot;, a);  ，这时候就是把 a 的值10拿出来使用，但是当你对 a 取地址（&amp;amp;a）的时候，c++ 编译器会为这个a单独分配一个内存空间，如果定义一个指针指向这个内存空间（int *p = (int *)&amp;amp;a;），那么这个指针指向的是这个新分配的一个内存空间，然后通过这个指针间接修改这个值（*p = 11;），这时候修改的其实新分配的这个空间的值，不管你间接修改的这个值是11、20、30还是100，都和符号表原本的 a 的值没有任何关系，所以使用 a 的时候打印出来的结果是 a = 10，这就是符号表，是 c++ 对 c 的一些扩展，这样就会发现 c++ 编译器把 const 变成符号表这个手段确确实实把 const 修饰的变量变成了一个常量，结论就是在 c 语言里面 const 确实是一个“冒牌货”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候可能还有一个疑问，这个新分配的内存到底存不存在？这个简单，我们加一句打印就行：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;// 貌似定义的 a 是一个常量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;// a = 11;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;int&lt;/span&gt; *p = (&lt;span&gt;int&lt;/span&gt; *)&amp;amp;a;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  *p = &lt;span&gt;11&lt;/span&gt;;   &lt;span&gt;// 间接赋值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;*p = %d \n&quot;&lt;/span&gt;, *p);   &lt;span&gt;// 加上这句打印&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot; a = %d \n&quot;&lt;/span&gt;, a);   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  system(&lt;span&gt;&quot;pause&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 打印结果：*p = 11     a = 10&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从打印可以看出单独分配的这个内存空间值是11，和原来的 a 是不同的两个概念，这就是在 C++ 中 const 的符号表的实现机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---END---&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzI2NjA3NTc4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vpWlcHcJUIDbm698AfiamT96KE07q1HMQPl233xlnydA1Y9oJJzvNriaZGea9gm2hdx0G1KMy0LGkFnn1ustcPqw/0?wx_fmt=png&quot; data-nickname=&quot;算法与数据结构&quot; data-alias=&quot;TheAlgorithm&quot; data-signature=&quot;分享数据结构及算法知识，分享ACM算法题、面试算法题。涵盖各种排序算法、动态规划等常见算法；字符串、树、数组、队列、链表数据结构实现。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>49125dda70e199be14358df6e3c64f46</guid>
<title>程序员 在距离公司一公里健身房 猝死，能可认定工伤吗？法院给出答案</title>
<link>https://toutiao.io/k/zla4xwe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;重磅资讯，干货，第一时间送达&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;10月24日，北京海淀法院公布了一起程序员健身房猝死后工伤认定纠纷案的判决结果，程序员中午去距离公司一公里的健身房健身，不幸猝死，法院最终判定是工伤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;案件文书写道：&lt;span&gt;刘涵（化名）是一名程序员，在某公司担任软件开发工程师。一日，刘涵在完成了上午的忙碌工作后，于12：30来到公司附近的健身房健身，13：04健身结束后，正在更衣室换衣服的刘涵却突然倒地不醒。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;健身房的工作人员发现后立即呼叫救护车，13：30刘涵被抬上救护车时心电图显示“心室停搏”，当日15：24医院宣布刘涵经抢救无效死亡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事发后，涉事公司向人力资源和社会保障局提出工伤认定申请。人保局认为，刘涵所受伤害不符合工伤保险条例第十五条“在工作时间和工作岗位，突发疾病死亡或者在48小时之内经抢救无效死亡的”视同工伤的情形，遂作出不予认定工伤决定。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某公司认为，刘涵发生事故应属于工伤，故诉至法院，要求撤销被告人保局作出的不予认定工伤决定。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;庭审中，被告人保局辩称，首先，刘涵在非工作的午休时间前往距离单位一公里的健身房健身，已超出工作时间和工作岗位；其次，刘涵健身时已脱离工作状态，其健身行为与工作没有必然联系，属于主观支配的个人行为；再次，刘涵的死亡地点为健身房内，并非工作地点。因此，人保局对刘涵所受伤害不能认定为工伤或“视同工伤”，请求法院维持其作出的被诉不予认定工伤决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;法院经审理查明，刘涵系某公司职工，双方签有标准工时劳动合同。&lt;span&gt;该公司与案涉健身房签有《合作协议》，约定健身房提供健身场地、作为公司场地的延伸，供某公司职工用以专门健身。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;涉事公司《职工手册》载明，公司特色福利为“因公司工作的特殊性，公司将健身时间确定为工作时间”；考勤制度为“每周五天、每天8小时，上下班时间可灵活调整的弹性工作制度；具体作息时间为上午9：00至下午18：00，其中自行休息一小时；职工按照单位指定地方进行健身运动的时间计入八小时工作时间”；健身管理制度为“如用中午时间进行健身的，可不用领导批准，自行进行，在两个小时内为合理时间，这两个小时中除去在途时间30分钟，剩余时间计入工作时间，中午健身总时长超过两个小时的，每超过一分钟算作迟到一分钟处理”。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;法院经审理认为，&lt;span&gt;工作时间包括法律及单位制度下的标准工作时间、临时性工作时间及不定时工作制度下的不定时工作时间，是具有延续性的，不能简单地理解为劳动时间。&lt;/span&gt;判断一段时间是否属于工作时间，可综合考虑这段时间内劳动者的活动是否符合用工单位的目的、是否从事与工作内容相关的活动、是否受用人单位支配和控制等因素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该案中，涉事公司《职工手册》特别说明，职工按照单位指定地方进行健身运动的时间计入八小时工作时间，且如职工用中午时间进行健身的，可不用领导批准，在两个小时内为合理时间。刘涵于事发当天上午8：50到单位工作，中午12：30前往健身房健身，13：04晕倒在健身房内更衣室，其健身时间符合某公司对于工作时间的规定，亦受某公司管理和支配，目的也是为单位更好创造效益等因素，因此应当认定刘涵事发时属于工作时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于工作岗位的认定应结合职工从事的活动是否和工作有关进行判断。&lt;span&gt;工作场所具有一定的延展性，不能仅局限于生产、经营、培训过程中的场所，与职工工作职责相关的区域以及自然延伸的合理区域均应视为工作场所。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，法院判决撤销被告人力资源和社会保障局作出的不予认定工伤决定书，责令被告于判决生效后的法定期限内对原告公司提出的工伤认定申请重新作出处理。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;网友认为：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“真是良心单位，不但帮员工打本来和自己无关的官司，还把健身属于什么写进了劳动合同，赞一个。反倒是社保局，强制购买还这么苛刻，合适么，是不是该改一下条款了？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“这篇文章准备转发给我们领导看，我们单位旁边300米有一个按摩房，有时领导和员工去按摩。是不是仿效弄一个合同，中午或晚上去按摩就作为工作时间的延伸。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“白天996，深夜健身房，好像已经成了我的日常。。。”&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>