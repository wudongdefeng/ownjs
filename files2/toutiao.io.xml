<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d23715a809d7c50f99396cb4623c9638</guid>
<title>为什么 Spring和IDEA 都不推荐使用 @Autowired 注解</title>
<link>https://toutiao.io/k/xv1x088</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-style-type=&quot;5&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;965972&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击关注#互联网架构师公众号，领取&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;架构师全套资料&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;架构师全套资料&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 都在这里&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100029587&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21&amp;amp;token=171858062&amp;amp;lang=zh_CN#wechat_redirect&quot; textvalue=&quot;0、2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;0、&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;2T架构师学习资料干货分&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上一篇：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247530700&amp;amp;idx=1&amp;amp;sn=c2e58e1639e57e609dac9a6a219902f2&amp;amp;chksm=ea5fb5aadd283cbcdb0f69a8e60dbb64114f9990889b53170e830f64b951b38fe4a9e46eac9b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;互联网最值得加入的173家国企汇总！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;互联网最值得加入的173家国企汇总！！&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;大家好，我是互联网架构师！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在使用IDEA开发的时候有没有注意到过一个提示，在字段上使用Spring的依赖注入注解&lt;code&gt;@Autowired&lt;/code&gt;后会出现如下警告&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Field injection is not recommended (字段注入是不被推荐的)&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是使用&lt;code&gt;@Resource&lt;/code&gt;却不会出现此提示&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上文章大部分都是介绍两者的区别，没有提到为什么，当时想了好久想出了可能的原因，今天来总结一下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Spring常见的DI方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;构造器注入&lt;/strong&gt;：利用构造方法的参数注入依赖&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;Setter注入&lt;/strong&gt;：调用Setter的方法注入依赖&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;字段注入&lt;/strong&gt;：在字段上使用&lt;code&gt;@Autowired/Resource&lt;/code&gt;注解&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;@Autowired VS @Resource&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，他们的基本功能都是通过注解实现&lt;strong&gt;依赖注入&lt;/strong&gt;，只不过&lt;code&gt;@Autowired&lt;/code&gt;是&lt;code&gt;Spring&lt;/code&gt;定义的，而&lt;code&gt;@Resource&lt;/code&gt;是&lt;code&gt;JSR-250&lt;/code&gt;定义的。大致功能基本相同，但是还有一些细节不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;依赖识别方式&lt;/strong&gt;：&lt;code&gt;@Autowired&lt;/code&gt;默认是&lt;strong&gt;byType&lt;/strong&gt;可以使用&lt;code&gt;@Qualifier&lt;/code&gt;指定Name，&lt;code&gt;@Resource&lt;/code&gt;&lt;strong&gt;默认ByName&lt;/strong&gt;如果&lt;strong&gt;找不到则ByType&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;适用对象&lt;/strong&gt;：&lt;code&gt;@Autowired&lt;/code&gt;可以对&lt;strong&gt;构造器、方法、参数、字段&lt;/strong&gt;使用，&lt;code&gt;@Resource&lt;/code&gt;只能对&lt;strong&gt;方法、字段&lt;/strong&gt;使用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;提供方&lt;/strong&gt;：&lt;code&gt;@Autowired&lt;/code&gt;是&lt;strong&gt;Spring&lt;/strong&gt;提供的，&lt;code&gt;@Resource&lt;/code&gt;是&lt;strong&gt;JSR-250&lt;/strong&gt;提供的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;各种DI方式的优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;参考Spring官方文档，建议了如下的使用场景：&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;构造器注入&lt;/strong&gt;：&lt;strong&gt;强依赖性&lt;/strong&gt;（即必须使用此依赖），&lt;strong&gt;不变性&lt;/strong&gt;（各依赖不会经常变动）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Setter注入&lt;/strong&gt;：&lt;strong&gt;可选&lt;/strong&gt;（没有此依赖也可以工作），&lt;strong&gt;可变&lt;/strong&gt;（依赖会经常变动）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Field注入&lt;/strong&gt;：大多数情况下尽量&lt;strong&gt;少使用&lt;/strong&gt;字段注入，一定要使用的话， &lt;strong&gt;@Resource相对@Autowired&lt;/strong&gt;对IoC容器的&lt;strong&gt;耦合更低&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Field注入的缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;不能像构造器那样注入不可变的对象&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;依赖对外部不可见&lt;/strong&gt;，外界可以看到构造器和setter，但无法看到私有字段，自然无法了解所需依赖&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;会导致&lt;strong&gt;组件与IoC容器紧耦合&lt;/strong&gt;（这是最重要的原因，离开了IoC容器去使用组件，在注入依赖时就会十分困难）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;导致&lt;strong&gt;单元测试也必须使用IoC容器&lt;/strong&gt;，原因同上&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;依赖过多时不够明显&lt;/strong&gt;，比如我需要10个依赖，用构造器注入就会显得庞大，这时候应该考虑一下此组件是不是&lt;strong&gt;违反了单一职责原则&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;为什么IDEA只对@Autowired警告&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Field注入虽然有很多缺点，但它的好处也不可忽略：&lt;span&gt;那就是&lt;/span&gt;&lt;strong&gt;太方便了&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;使用构造器或者setter注入需要写更多业务无关的代码，十分麻烦，而字段注入大幅简化了它们。&lt;/span&gt;&lt;span&gt;并且绝大多数情况下业务代码和框架就是强绑定的，完全松耦合只是一件理想上的事，牺牲了敏捷度去过度追求松耦合反而得不偿失。&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;那么问题来了，为什么IDEA只对@Autowired警告，却对@Resource视而不见呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;个人认为&lt;/strong&gt;，就像我们前面提到过的：&lt;strong&gt;@Autowired&lt;/strong&gt;是&lt;strong&gt;Spring&lt;/strong&gt;提供的，它是&lt;strong&gt;特定IoC提供的特定注解&lt;/strong&gt;，这就导致了应用与框架的&lt;strong&gt;强绑定&lt;/strong&gt;，一旦换用了其他的IoC框架，是&lt;strong&gt;不能够支持注入&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 &lt;strong&gt;@Resource&lt;/strong&gt;是&lt;strong&gt;JSR-250&lt;/strong&gt;提供的，它是&lt;strong&gt;Java标准&lt;/strong&gt;，我们使用的IoC容器应当去兼容它，这样即使更换容器，也可以正常工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：&lt;/span&gt;&lt;span&gt;juejin.cn/post/7080441168462348319&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523205&amp;amp;idx=1&amp;amp;sn=89b261f829ce6c3487ce8b2ccf3ed06b&amp;amp;chksm=ea5f56e3dd28dff5238989d3e07d775d34c04a4e80a166059e92e84379274819203d72d1dc1d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Alibaba开源内网高并发编程手册.pdf&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Alibaba开源内网高并发编程手册.pdf&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247487508&amp;amp;idx=1&amp;amp;sn=78cf235aa9ba5f988c6922ca98f8bfd6&amp;amp;chksm=ea5cdd72dd2b54647cf55b4a73dcafa69fc7228205ad39ecc98fe57b39cdecb21c238c6d6cb6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2T架构师学习资料干货分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2T架构师学习资料干货分享&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523100&amp;amp;idx=1&amp;amp;sn=82a70350577bde0bca6dd2dde811ca17&amp;amp;chksm=ea5f567add28df6cb6a780ff744c3ffdc79e498d2c2536ffb1853d8082ebfa986e1e5c43d532&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10000+TB 资源，阿里云盘，牛逼！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;10000+TB 资源，阿里云盘，牛逼！！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;4、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MTIzMzY3Mw==&amp;amp;mid=2247523863&amp;amp;idx=1&amp;amp;sn=4d2a2b5da60f14f3e8947e174d485c03&amp;amp;chksm=ea5f5371dd28da6791af6cb3a164c8052f1e77d7392cbbc87c5a73ccc6916b76eab29dbc9991&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基本涵盖了Spring所有核心知识点总结&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;基本涵盖了Spring所有核心知识点总结&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;  · END ·&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后，关注公众号互联网架构师，在后台回复：2T，可以获取我整理的 Java 系列面试题和答案，非常齐全&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRL358RWHQSLbUws79uyGm5RJ6WZibYJMAKUQibz8aYNA5LPSmbo1boibnD3IhggQ2F7kS37xgk3WXQ8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a96c2bbdbffb1b7fc4092fe5928133a2</guid>
<title>参加了个算法比赛，真是一言难尽啊</title>
<link>https://toutiao.io/k/3mxn8wi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hello大家好呀，我是小楼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上周参加了一个区的程序员技能比赛的初赛，其实就是算法比赛，虽然最后结果是过了初赛，但过程真是一言难尽啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次的算法比赛和ACM非常类似，虽然我大学是数学专业，虽然大学也修过ACM这门课，但是我的算法是真的不行，很菜很菜的那种。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9123076923076923&quot; data-type=&quot;jpeg&quot; data-w=&quot;650&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJ0aDZsCNFK6tl3s6eKJYSBibq78UDfLLEtITIWJKmkdTwneCHBgop3dg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好在这次比赛是组（抱大腿）队模式，3人一组，3个小时时间，一共7道算法题，1入门，2简单，2中等，2困难。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10分钟写出入门题，但...&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我知道我比较菜，所以比赛一开始，我就挑了一个看起来最简单的题目做，难题交给队友。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果是3个小时过去，这个看起来最简单的题目，愣是没有做出来，下面就结合这道题讲讲我的心路历程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题的描述是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0455991516436904&quot; data-type=&quot;png&quot; data-w=&quot;943&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJ64CD0icFDWOWGibX30zWgtFVoHg2C9trLXR0nhIT7YqV5icXZ86zmibXng/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来文字很多，其实要表达的很简单，就是输入一些成绩，每个成绩输进去时，如果超过全班最好成绩则输出prefect，如果超过自己的最好成绩则输出great，如果没超过自己最好成绩则输出bad。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很简单？用一个max变量保存全班最好成绩，用一个map保存每个人的最好成绩，不就解决了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这是我第一次用这个oj系统，连用户都是刚注册的，所以我还特地看了一会输入输出的demo，这次比赛只能使用ACM的输入输出模式，例如如果用的是Go语言，输入输出应该是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1206225680933852&quot; data-type=&quot;png&quot; data-w=&quot;514&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJpNJI3f2f1oUck1DYJeFWFLEO46pScvicU8IHDphjWAYJicGAorys9XZA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学会了输入输出之后，一口气写入如下的解法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; x &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; max &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt; scores := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;float32&lt;/span&gt;, n)&lt;br/&gt;&lt;br/&gt; fmt.Scan(&amp;amp;n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  fmt.Scan(&amp;amp;name, &amp;amp;x)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; x &amp;gt; max || i == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;perfect&quot;&lt;/span&gt;)&lt;br/&gt;   max = x&lt;br/&gt;   scores[name] = x&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; s, ok := scores[name]; ok {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x &amp;gt; s {&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;great&quot;&lt;/span&gt;)&lt;br/&gt;     scores[name] = x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;bad&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;great&quot;&lt;/span&gt;)&lt;br/&gt;    scores[name] = x&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我正得意，觉得这题10分钟就能解决的时候，提交上去的代码竟然超时了，在比赛时没有截图，提交后显示有少数用例超过了2秒，oj的判定原理是准备一堆测试用例，如果全部通过则判定为通过，当然这批测试用例肯定不是那么好通过的，设计者会出各种极端的case。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化map性能&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调转头去仔细审题，果然时间和空间都有限制：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;时间限制：C/C++ 1秒，其他语言2秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空间限制：C/C++ 262144K，其他语言524288K&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;64bit IO Format: %lld&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这题除了有map的读写，其他都是O(1)复杂度，性能不够难道是map性能不够？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是map的性能不够，不够在哪里呢？众所周知，map的原理一般是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354539430086149&quot; data-type=&quot;png&quot; data-w=&quot;1509&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJW3G3ibM0bXQLIfrLypHY9STW8ROUoshrVS0fVBRXf9wzgd7LjYHo0OQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一些key存入map时，会先对key计算hash值，在map中找到对应的hash槽，这个槽之后一般是个链表（有的语言也会做一些优化成树状，这里我们简化为链表），因为不同的key的hash值可能会重复（冲突），冲突了只能把key排成一个链表，每次查找时都要遍历链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以有没有可能，设计者给出了一堆hash值重复的name，数量又多，导致每次插入、查找时都要遍历链表，性能下降，导致超时？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是再仔细审题，我发现输入的姓名和成绩是有限制的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;name保证长度不超过6，仅由小写英文字母组成，每个名字代表唯一一个同学&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;x为1位小数，0≤x≤300&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;name最长为6，且为小写字母&lt;/strong&gt;，这点给了我一点启发，能不能让查询map变成O(1)复杂度？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然可以的，小写字母范围为&lt;strong&gt;a~z&lt;/strong&gt;，如果看成数字就是1-26，也就是27进制，所以每个name可以表示为一个27进制的数，这样就可以把所有人的成绩放到一个大数组里去，按name的27进制进行O(1)的查找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是27进制而不是26，因为name没说是多少位，比如只有5位，那空出的一位怎么表示？只能用0表示了，a-z就是1-26，合起来是27进制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考10进制计算法则，27进制应该这样计算（以roshi为例）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20679886685552407&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJzibpLribfxVKy0fJGNOCXhDo01G1CBdamI30KTicenmvqkkA7fm1X49dQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算出的值即为数组的下标，那么这个数组的最大值是多少呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;26 * 27^5 + 26 * 27^4 + 26 * 27^3 + 26 * 27^2 + 26 * 27^1 + 26 * 27^0&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很容易算出来是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;387420488&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要这么大个数组，大概3亿多，输入成绩是个1位小数，可以转换为int，大概4个字节，掐指一算得 &lt;strong&gt;1513361KB&lt;/strong&gt;，好像比要求的&lt;strong&gt;524288K&lt;/strong&gt;多，先不管空间，写一版跑跑看，万一能过呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很简单写出代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; x &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; fmt.Scan(&amp;amp;n)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; scores [&lt;span&gt;387420488&lt;/span&gt;]&lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; exist [&lt;span&gt;387420488&lt;/span&gt;]&lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; max &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  fmt.Scan(&amp;amp;name, &amp;amp;x)&lt;br/&gt;&lt;br/&gt;  idx := mapIndex(name)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; x &amp;gt; max || i == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Printf(&lt;span&gt;&quot;perfect\n&quot;&lt;/span&gt;)&lt;br/&gt;   max = x&lt;br/&gt;   scores[idx] = x&lt;br/&gt;   exist[idx] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; exist[idx] == &lt;span&gt;0&lt;/span&gt; || x &amp;gt; scores[idx] {&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;great\n&quot;&lt;/span&gt;)&lt;br/&gt;    scores[idx] = x&lt;br/&gt;    exist[idx] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Printf(&lt;span&gt;&quot;bad\n&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; index27 = [&lt;span&gt;6&lt;/span&gt;]&lt;span&gt;int32&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt; * &lt;span&gt;27&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mapIndex&lt;/span&gt;&lt;span&gt;(x &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; index &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;len&lt;/span&gt;(x) - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i-- {&lt;br/&gt;  index = index + &lt;span&gt;int32&lt;/span&gt;(x[i]&lt;span&gt;-96&lt;/span&gt;)*index27[&lt;span&gt;len&lt;/span&gt;(x)&lt;span&gt;-1&lt;/span&gt;-i]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; index&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24594594594594596&quot; data-type=&quot;png&quot; data-w=&quot;740&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJqPibI3Irpp1ctKf9uCtsP8iaAnebX92b4L8bSVsqGTRouRicibtBseVVFg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果竟然报错了，我当时不理解，事后理解了，我们暂且不说，后面会说到原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是因为这个报错不明不白，明明能测试通过，到底哪里理解有偏差？亦或是内存超了？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化内存占用&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码用到了2个数组，一个存最大值，一个存值是否存在，一个数组是1513361KB，2个就是3026722KB，是最大内存限制的5.7倍&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; scores [&lt;span&gt;387420488&lt;/span&gt;]&lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; exist [&lt;span&gt;387420488&lt;/span&gt;]&lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;exist数组可以用boolean类型，分数最大值0&amp;lt;=0&amp;lt;=300，int16足矣&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;大小&lt;/th&gt;&lt;th&gt;范围&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;int8&lt;/td&gt;&lt;td&gt;1字节&lt;/td&gt;&lt;td&gt;-128 ~ 127&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int16&lt;/td&gt;&lt;td&gt;2字节&lt;/td&gt;&lt;td&gt;-32768 ~ 32767&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int32&lt;/td&gt;&lt;td&gt;4字节&lt;/td&gt;&lt;td&gt;-2147483648 ~ 2147483647&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是这个组合，将占用 &lt;strong&gt;1135020KB&lt;/strong&gt;，是上限的2倍多，还是有点超，先试试：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24934036939313983&quot; data-type=&quot;png&quot; data-w=&quot;758&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJqLmnVbjKX0EiaQ2WfvibiacDmIhdlOAKBkC0OR77zvM2LveaBLuc1CcRg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是一样，难道是我算法有问题？没道理啊。到这里我实在是没招了，3小时也耗尽了，比赛结束。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;赛后思考&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赛后，我拿着这道题去找了一位刚入职字节的朋友，想着刚去字节应该刷过不少题吧，果然大佬就是大佬，给出了一个有新意的思路，用前缀树做：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.814748201438849&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJVKFsLBT86k3pvIJ1XgIYabVI1SEiazSSM8P3WsbK2hBYfkhvpIJAhUg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个name都构造出一个前缀树，查找时最多只需要查找6次，内存使用应该也不会太多，算是时间与空间的一个平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大佬还补充了一句：比赛还是比较特殊的，可能就是某一个case卡主了，而你要做的就是如何能把这个特殊的case也ac掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大佬的话似乎很有道理，于是我写了一个前缀树的版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; treeNode &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; max  &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt; next [&lt;span&gt;26&lt;/span&gt;]*treeNode&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; n &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; x &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt; fmt.Scan(&amp;amp;n)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; max &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt; tree := &lt;span&gt;new&lt;/span&gt;(treeNode)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  fmt.Scan(&amp;amp;name, &amp;amp;x)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; x &amp;gt; max || i == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;perfect&quot;&lt;/span&gt;)&lt;br/&gt;   max = x&lt;br/&gt;   insert(tree, name, x)&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; tmp := searchAndStoreMax(tree, name, x); tmp != &lt;span&gt;-1&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x &amp;gt; tmp {&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;great&quot;&lt;/span&gt;)&lt;br/&gt;     insert(tree, name, x)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;bad&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    fmt.Println(&lt;span&gt;&quot;great&quot;&lt;/span&gt;)&lt;br/&gt;    insert(tree, name, x)&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt;&lt;span&gt;(node *treeNode, name &lt;span&gt;string&lt;/span&gt;, x &lt;span&gt;float32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(name); i++ {&lt;br/&gt;  idx := &lt;span&gt;int32&lt;/span&gt;(name[i] - &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; node.next[idx] == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   node.next[idx] = &lt;span&gt;new&lt;/span&gt;(treeNode)&lt;br/&gt;  }&lt;br/&gt;  node = node.next[idx]&lt;br/&gt; }&lt;br/&gt; node.max = x&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;searchAndStoreMax&lt;/span&gt;&lt;span&gt;(node *treeNode, name &lt;span&gt;string&lt;/span&gt;, x &lt;span&gt;float32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;float32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(name); i++ {&lt;br/&gt;  idx := &lt;span&gt;int32&lt;/span&gt;(name[i] - &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; node.next[idx] == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  node = node.next[idx]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; x &amp;gt; node.max {&lt;br/&gt;  tmp := node.max&lt;br/&gt;  node.max = x&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; tmp&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; node.max&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果又又又是超时，我服了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;终于发现问题&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来我又尝试了很多方法都不行，比如怀疑是不是Go的map性能不行，换成Java试试，结果还是不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我在网上搜索牛客网时发现了一个突破口（对，没错，这次比赛是在牛客网上举办的）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6274509803921569&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJvbbnSxPfqDsBbGvicz7fvuPxANYQIHCsWmU6fP0icrF5RFj0iaPdfaJlA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，牛客网的ACM模式输入可能需要读入一行然后再自己处理成想要的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抱着怀疑的态度我试了下，果然，淦！用最开始的map就能ac掉！虽然我也不知道这两种输入有什么区别。关键我还是用的网站上提示的输入方式，确实太坑了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正确的输入方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import (&lt;br/&gt; &lt;span&gt;&quot;bufio&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strconv&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; var n int&lt;br/&gt; var name string&lt;br/&gt; var x float64&lt;br/&gt; input := bufio.NewScanner(os.Stdin)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; input.&lt;span&gt;&lt;span&gt;Scan&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;  n, _ = strconv.Atoi(input.Text())&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; scores := make(map[string]float64, n)&lt;br/&gt; var max float64&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; n; i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; input.&lt;span&gt;&lt;span&gt;Scan&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   arr := strings.Split(input.Text(), &lt;span&gt;&quot; &quot;&lt;/span&gt;)&lt;br/&gt;   name = arr[0]&lt;br/&gt;   x, _ = strconv.ParseFloat(arr[1], 32)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44346289752650175&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJCfpCL3ZwnoxrtWAsC3O54oczROKw4fTjs1WzMD56gQyiaeickQsp8iamg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的想法属于强行增加难度了~害！想了好几天的题竟然败在了输入上，真是一言难尽！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;之前的方法能行吗&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把几个版本的输入改了之后，看看通过后的耗时和内存&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;版本&lt;/th&gt;&lt;th&gt;是否通过&lt;/th&gt;&lt;th&gt;耗时&lt;/th&gt;&lt;th&gt;内存&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;map版&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;td&gt;315ms&lt;/td&gt;&lt;td&gt;10096KB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;27进制版&lt;/td&gt;&lt;td&gt;否&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;前缀树版&lt;/td&gt;&lt;td&gt;是&lt;/td&gt;&lt;td&gt;433ms&lt;/td&gt;&lt;td&gt;43720KB&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中27进制版本在改成正确的输入后，露出了庐山真面目：内存超了！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33111702127659576&quot; data-type=&quot;png&quot; data-w=&quot;752&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0QFptviaVgcSwQn6yKaH5TmJqAuib3P98P9gczziarzicLkKmSsbTsyia2FxbbibtdnJycwUh7QjMGpaDvg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程虽然曲折，但最终还是解决了这个入门题，而且还尝试着用几种方法来解，虽然不尽如人意，但终究还是有点收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然我们组的小伙伴也很给力，做出来3道题，我们最终的成绩是排名进了前10%，虽然我只贡献了一点点（没完全做出来也有得分，按通过的用例算，我这题大概拿到了90%的分），也算是可以了，而且还有一道题也可能是因为这个输入被卡了，所以如果这两道卡的题都做出来，估计排名能进前三。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初赛算是过了，接下来准备复赛，如果复赛还有好玩的事情，我再来写一篇文章，哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一言难尽的比赛，大家给个赞鼓励下吧。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;想进技术交流群的小伙伴加我微信「MrRoshi」备注加群即可，群里大佬如云，带你起飞~&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;span/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75f8a87d49705827885b08c5e640e75e</guid>
<title>微服务网关Gateway实践总结</title>
<link>https://toutiao.io/k/f4nh7n3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;有多少请求，被网关截胡；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、Gateway简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;微服务架构中，网关服务通常提供动态路由，以及流量控制与请求识别等核心能力，在之前的篇幅中有说过Zuul组件的使用流程，但是当下Gateway组件是更常规的选择，下面就围绕Gateway的实践做详细分析；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.58046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCu97J3Dg4hIl1VSQF5DhibFCCkbjQxS2doI4j9nOVYFAMFKSvpWtBDa8NSkGSoYCPkfaLxWQBbeTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从架构模式上看，网关不管采用什么技术组件，都是在客户端与业务服务中间提供一层拦截与校验的能力，但是相比较Zuul来说，Gateway提供了更强大的功能和卓越的性能；&lt;/p&gt;&lt;p&gt;基于实践的场景来看，在功能上网关更侧重请求方的合法校验，流量管控，以及IP级别的拦截，从架构层面看，通常需要提供灵活的路由机制，比如灰度，负载均衡的策略等，并基于消息机制，进行系统级的安全通知等；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCu97J3Dg4hIl1VSQF5DhibFSsKJYTDEuGVu0s7BfhyDjaKeJby6IjV8gEZORQhOQB8lEMwNKvQ7KA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面围绕客户端、网关层、门面服务的三个节点，分析Gateway的使用细节，即客户端向网关发出请求，经过网关路由到门面服务处理；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、动态路由&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;路由&lt;/strong&gt;：作为网关中最核心的能力，从源码结构上看，包括ID、请求URI、断言集合、过滤集合等组成；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteDefinition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; String id;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; URI uri;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;PredicateDefinition&amp;gt; predicates = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; List&amp;lt;FilterDefinition&amp;gt; filters = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;断言+过滤&lt;/strong&gt;：通常在断言中定义请求的匹配规则，在过滤中定义请求的处理动作，结构上看都是名称加参数集合，并且支持快捷的方式配置；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PredicateDefinition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; args = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FilterDefinition&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt; &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; args = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2、配置路由&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;以配置的方式，添加&lt;code&gt;facade&lt;/code&gt;服务路由，以路径匹配的方式，如果请求路径错误则断言失败，StripPrefix设置为1，即在过滤中去掉第一个&lt;code&gt;/facade&lt;/code&gt;参数；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;application:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;gateway&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;gateway:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;routes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;id:&lt;/span&gt; &lt;span&gt;facade&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;uri:&lt;/span&gt; &lt;span&gt;http://127.0.0.1:8082&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;predicates:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;Path=/facade/**&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;filters:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;StripPrefix=1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行原理如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.14140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCu97J3Dg4hIl1VSQF5DhibF4RM6WOdbtJVeoQHXhQe1ibgZl8iaeYibP4s69Z5kWJzgYCztd4F7xiaiaEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里是以配置文件的方式，设置&lt;code&gt;facade&lt;/code&gt;服务的路由策略，其中指定了路径方式，在Gateway文档中提供了多种路由样例，比如：Header、Cookie、Method、Query、Host等断言方式；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、编码方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;基于编码的方式管理路由策略，在Gateway文档同样提供了多种参考样例，如果路由服务少并且固定，配置的方式可以解决，如果路由服务很多，并且需要动态添加，那基于库表方式更适合；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GateConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; builder.routes()&lt;br/&gt;                .route(&lt;span&gt;&quot;facade&quot;&lt;/span&gt;,r -&amp;gt; r.path(&lt;span&gt;&quot;/facade/**&quot;&lt;/span&gt;).filters(f -&amp;gt; f.stripPrefix(&lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;                .uri(&lt;span&gt;&quot;http://127.0.0.1:8082&quot;&lt;/span&gt;)).build();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、库表加载&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在常规的应用中，从库表中读取路由策略是比较常见的方式，定义路由工厂类并实现&lt;code&gt;RouteDefinitionRepository&lt;/code&gt;接口，涉及加载、添加、删除三个核心方法，然后基于服务类从库中读取数据转换为&lt;code&gt;RouteDefinition&lt;/code&gt;对象即可；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCu97J3Dg4hIl1VSQF5DhibFB21SEY31t0kvBugKEs4n0MFnGWOklMmKibkfqFyicaZFChib0b82qJ6dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefRouteFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RouteDefinitionRepository&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ConfigRouteService routeService ;&lt;br/&gt;    &lt;span&gt;// 加载&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Flux&amp;lt;RouteDefinition&amp;gt; &lt;span&gt;getRouteDefinitions&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Flux.fromIterable(routeService.getRouteDefinitions());&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 添加&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(Mono&amp;lt;RouteDefinition&amp;gt; route)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; route.flatMap(routeDefinition -&amp;gt; { routeService.saveRouter(routeDefinition);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Mono.empty();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 删除&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;delete&lt;/span&gt;&lt;span&gt;(Mono&amp;lt;String&amp;gt; idMono)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; idMono.flatMap(routeId -&amp;gt; { routeService.removeRouter(routeId);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Mono.empty();&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在源码仓库中采用的就是库表管理的方式，代码逻辑的更多细节可以移步Git参考，此处不再过多粘贴；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、自定义路由策略&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自定义断言&lt;/strong&gt;，继承&lt;code&gt;AbstractRoutePredicateFactory&lt;/code&gt;类，注意命名以&lt;code&gt;RoutePredicateFactory&lt;/code&gt;结尾，重写&lt;code&gt;apply&lt;/code&gt;方法，即可执行特定的匹配规则；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefCheckRoutePredicateFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractRoutePredicateFactory&lt;/span&gt;&amp;lt;&lt;span&gt;DefCheckRoutePredicateFactory&lt;/span&gt;.&lt;span&gt;Config&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefCheckRoutePredicateFactory&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(Config&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Predicate&amp;lt;ServerWebExchange&amp;gt; &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(Config config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GatewayPredicate() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;test&lt;/span&gt;&lt;span&gt;(ServerWebExchange serverWebExchange)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                log.info(&lt;span&gt;&quot;DefCheckRoutePredicateFactory：&quot;&lt;/span&gt; + config.getName());&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; StrUtil.equals(&lt;span&gt;&quot;butte&quot;&lt;/span&gt;,config.getName());&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Config&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;private&lt;/span&gt; String name; }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;shortcutFieldOrder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; Collections.singletonList(&lt;span&gt;&quot;name&quot;&lt;/span&gt;); }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;自定义过滤&lt;/strong&gt;，继承&lt;code&gt;AbstractNameValueGatewayFilterFactory&lt;/code&gt;类，注意命名以&lt;code&gt;GatewayFilterFactory&lt;/code&gt;结尾，重写&lt;code&gt;apply&lt;/code&gt;方法，即可执行特定的过滤规则；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefHeaderGatewayFilterFactory&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNameValueGatewayFilterFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; GatewayFilter &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(AbstractNameValueGatewayFilterFactory.NameValueConfig config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (exchange, chain) -&amp;gt; {&lt;br/&gt;            log.info(&lt;span&gt;&quot;DefHeaderGatewayFilterFactory：&quot;&lt;/span&gt;+ config.getName() + &lt;span&gt;&quot;-&quot;&lt;/span&gt; + config.getValue());&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;        };&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;配置加载方式&lt;/strong&gt;，此处断言与过滤即快捷的配置方式，所以在命名上要遵守Gateway的约定；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;spring:&lt;br/&gt;  cloud:&lt;br/&gt;    gateway:&lt;br/&gt;      routes:&lt;br/&gt;        - id: facade&lt;br/&gt;          uri: http://127.0.0.1:8082&lt;br/&gt;          predicates:&lt;br/&gt;            - Path=/facade/**&lt;br/&gt;            - DefCheck=butte&lt;br/&gt;          filters:&lt;br/&gt;            - StripPrefix=1&lt;br/&gt;            - DefHeader=cicada,smile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通常来说，在应用级的系统中都需要进行断言和过滤的策略自定义，以提供业务或者架构层面的支撑，完成更加细致的规则校验，尤其在相同服务多版本并行时，可以更好的管理路由策略，从而避免分支之间的影响；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、全局过滤器&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在路由中采用的过滤是&lt;code&gt;GatewayFilter&lt;/code&gt;，实际Gateway中还提供了&lt;code&gt;GlobalFilter&lt;/code&gt;全局过滤器，虽然从结构上看十分相似，但是其职责是有本质区别的；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Order&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefOneGlobalFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;request-id:{}&quot;&lt;/span&gt;,exchange.getRequest().getId()) ;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Order&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefTwoGlobalFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;request-uri:{}&quot;&lt;/span&gt;,exchange.getRequest().getURI()) ;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chain.filter(exchange);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gateway网关作为微服务架构系统中最先接收请求的一层，可以定义许多策略来保护系统的安全，比如高并发接口的限流，第三方授权验证，遭到恶意攻击时的IP拦截等等，尽量将非法请求在网关中拦截掉，从而保证系统的安全与稳定。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>65944d481b2e9fa98887d2be87bde12d</guid>
<title>C++最佳实践 | 4. 可维护性</title>
<link>https://toutiao.io/k/zkc86sq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;本系列是开源书&lt;span&gt;C++ Best Practises&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;的中文版，全书从工具、代码风格、安全性、可维护性、可移植性、多线程、性能、正确性等角度全面介绍了现代C++项目的最佳实践。本文是该系列的第四篇。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;C++最佳实践:&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247485809&amp;amp;idx=1&amp;amp;sn=dad7bd7048a315ec76a41e8ab28dc880&amp;amp;chksm=fc73b4aacb043dbc09d7f891c124257cdfa76c55dc8711ba2235c345056cbba77f4894469e97&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1. 工具&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;1. 工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247485810&amp;amp;idx=1&amp;amp;sn=038ad9bffe583294e2acfd86c19bf409&amp;amp;chksm=fc73b4a9cb043dbf7b6d802ffa36a87cb38d5ba147601e7bc918c4125466b17314f7f5bbb054&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2. 代码风格&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2. 代码风格&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTgxODgwNA==&amp;amp;mid=2247485811&amp;amp;idx=1&amp;amp;sn=826a810a843e02114381f20f6a4527b4&amp;amp;chksm=fc73b4a8cb043dbe20175ac72338233dae140b660cef9076f35cb5d2a89f570c42d02e8c457e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;3. 安全性&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;3. 安全性&lt;/a&gt;&lt;/p&gt;&lt;p&gt;4. 可维护性（本文）&lt;/p&gt;&lt;p&gt;5. 可移植性及多线程&lt;/p&gt;&lt;p&gt;6. 性能&lt;/p&gt;&lt;p&gt;7. 正确性和脚本&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;可维护性&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免使用编译宏&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;宏在编译之前被预处理器所替换，从而使得调试非常困难，因为调试器无法知道源代码来自哪里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; PI 3.14159;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good Idea&lt;/span&gt;&lt;br/&gt;&lt;span&gt;namespace&lt;/span&gt; my_project {&lt;br/&gt;  &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Constants&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;public&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;// if the above macro would be expanded, then the following line would be:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//   static const double 3.14159 = 3.14159;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// which leads to a compile-time error. Sometimes such errors are hard to understand.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; PI = &lt;span&gt;3.14159&lt;/span&gt;;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免使用布尔值作为函数参数&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阅读代码时，布尔值无法提供任何额外含义。可以创建一个名称更有意义的独立函数，或者传递含义更明确的枚举值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 http://mortoray.com/2015/06/15/get-rid-of-those-boolean-function-parameters 了解更多信息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;避免使用裸循环&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解和理解现有C++标准算法，并付诸实践。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;参考&lt;span&gt;cppreference&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;观看&lt;span&gt;C++ Seasoning&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将对&lt;code&gt;[]&lt;/code&gt;的调用看作是一种潜在的代码坏味道，表明没有在需要的地方使用合适的算法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;永远不要使用有副作用的&lt;code&gt;assert&lt;/code&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad Idea&lt;/span&gt;&lt;br/&gt;assert(set_value(something));&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Better Idea&lt;/span&gt;&lt;br/&gt;[[maybe_unused]] &lt;span&gt;const&lt;/span&gt; &lt;span&gt;auto&lt;/span&gt; success = set_value(something);&lt;br/&gt;assert(success);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在release版本中&lt;code&gt;assert()&lt;/code&gt;将会被删除，从而造成&lt;code&gt;set_value&lt;/code&gt;无法被调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然第二个版本更丑，但总比第一个错误版本好一点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;正确使用“override”和“final”&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些关键字使其他开发人员可以清楚知道虚函数可以被如何使用，如果虚函数的签名发生了变化，就可以捕获潜在错误，并有可能向编译器提示可以执行哪些优化（参考: &lt;span&gt;How does the compiler benefit from C++&#x27;s new final keyword?&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;C++ Best Practises: &lt;em&gt;https://lefticus.gitbooks.io/cpp-best-practices/content/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;cppreference: &lt;em&gt;https://en.cppreference.com/w/cpp/algorithm&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;C++ Seasoning: &lt;em&gt;https://www.youtube.com/watch?v=qH6sSOr-yk8&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;How does the compiler benefit from C++&#x27;s new final keyword?: &lt;em&gt;https://stackoverflow.com/questions/7538820/how-does-the-compiler-benefit-from-cs-new-final-keyword&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>967e5789f144fa7f45b4ec86c2692d65</guid>
<title>从 Linux 内核角度探秘 JDK NIO 文件读写本质</title>
<link>https://toutiao.io/k/7fp2k33</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《从 Linux 内核角度看 IO 模型的演变》&lt;/a&gt;一文中曾对 Socket 文件在内核中的相关数据结构为大家做了详尽的阐述。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6056451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7zzfnGORNVwfrfia3ibcIxYGO9BB3iaJNpXvicZaORibzicic96nKmONXRGD9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Socket内核结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又在此基础之上介绍了针对 socket 文件的相关操作及其对应在内核中的处理流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5620967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7LzzdY9loY0gw13636eCh5Dg0PAoibwI3R6O3xqW03KdKZjvhnJXibB0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;系统IO调用结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并与 epoll 的工作机制进行了串联：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4475806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7kQj1ovGeorGcIXWXXiaialTOTQibagsqcBrqvxZRhUqhqm8jiaeIuYPb6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;数据到来epoll_wait流程.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这些内容的串联介绍，我想大家现在一定对 socket 文件非常熟悉了，在我们利用 socket 文件接口在与内核进行网络数据读取，发送的相关交互的时候，不可避免的涉及到一个新的问题，就是我们如何在用户空间设计一个字节缓冲区来高效便捷的存储管理这些需要和 socket 文件进行交互的网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是笔者又在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247485497&amp;amp;idx=1&amp;amp;sn=eb4afe6764b2b976fb80f6dc5c6fd68a&amp;amp;chksm=ce77ce7ef900476865864e09bb6f0688ca784afc396084ecc90a894bfd733692049c332edd11&amp;amp;token=927203489&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《一步一图带你深入剖析 JDK NIO ByteBuffer 在不同字节序下的设计与实现》&lt;/a&gt; 一文中带大家从 JDK NIO Buffer 的顶层设计开始，详细介绍了 NIO Buffer 中的顶层抽象设计以及行为定义，随后我们选取了在网络应用程序中比较常用的 ByteBuffer 来详细介绍了这个Buffer具体类型的实现，并以 HeapByteBuffer 为例说明了JDK NIO 在不同字节序下的 ByteBuffer 实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4854838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r78rr4SFRhggJcGPCOPGRMweGIibBl3aUGoa5KonHSib7huWpYlQYpmXUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;HeapByteBuffer结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经熟悉了 socket 文件的相关操作及其在内核中的实现，但笔者觉得这还不够，还是有必要在为大家介绍一下 JDK NIO 如何利用 ByteBuffer 对普通文件进行读写的相关原理及其实现，为大家彻底打通 Linux 文件操作相关知识的系统脉络，于是就有了本文的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就让我们从一个普通的 IO 读写操作开始聊起吧~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0370967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7wPVjaWFHClj4iclrCxjgdXuTxSGtjmibZCbIp3QeTicpFHjt7icNPibbK3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. JDK NIO 读取普通文件&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个利用 NIO FileChannel 来读写普通文件的例子，由这个简单的例子开始，慢慢地来一步一步深入本质。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;JDK NIO  中的 FileChannel 比较特殊，它只能是阻塞的，不能设置非阻塞模式。FileChannel的读写方法均是线程安全的。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：下面的例子并不是最佳实践，之所以这里引入 HeapByteBuffer 是为了将上篇文章的内容和本文衔接起来。事实上，对于 IO 的操作一般都会选择 DirectByteBuffer ，关于 DirectByteBuffer 的相关内容笔者会在后面的文章中详细为大家介绍。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        FileChannel fileChannel = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;file-read-write.txt&quot;&lt;/span&gt;), &lt;span&gt;&quot;rw&quot;&lt;/span&gt;).getChannel();&lt;br/&gt;        ByteBuffer heapByteBuffer = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;        fileChannel.read(heapByteBuffer);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先利用 RandomAccessFile 在内核中打开指定的文件 file-read-write.txt 并获取到它的文件描述符 fd = 5000。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6879032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7PWsD02gNXA3herRiagkqIVxPe8BLsOrIQXUFmEKVJNmnIAkENZSwwZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后我们在 JVM 堆中开辟一块 4k 大小的虚拟内存 heapByteBuffer，用来读取文件中的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5652557319223986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7ZB1FMp4vLOLVpq6EhOASPRPV0a0By82BGI9K2Vt939umDbIyR9EGyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;操作系统在管理内存的时候是将内存分为一页一页来管理的，每页大小为 4k ，我们在操作内存的时候一定要记得进行页对齐，也就是偏移位置以及读取的内存大小需要按照 4k 进行对齐。具体为什么？文章后边会从内核角度详细为大家介绍。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后通过 &lt;code&gt;FileChannel#read&lt;/code&gt; 方法触发底层系统调用 read。进行文件读取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileChannelImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FileChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 前边介绍打开的文件描述符 5000&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileDescriptor fd;&lt;br/&gt;  &lt;span&gt;// NIO 中用它来触发 native read 和 write 的系统调用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileDispatcher nd;&lt;br/&gt;  &lt;span&gt;// 读写文件时加锁，前边介绍 FileChannel 的读写方法均是线程安全的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object positionLock = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(ByteBuffer dst)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (positionLock) {&lt;br/&gt;            .......... 省略 .......&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                .......... 省略 .......&lt;br/&gt;                &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                    n = IOUtil.read(fd, dst, -&lt;span&gt;1&lt;/span&gt;, nd);&lt;br/&gt;                } &lt;span&gt;while&lt;/span&gt; ((n == IOStatus.INTERRUPTED) &amp;amp;&amp;amp; isOpen());&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; IOStatus.normalize(n);&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                 .......... 省略 .......&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在 FileChannel 中会调用 IOUtil 的 read 方法，NIO 中的所有 IO 操作全部封装在 IOUtil 类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 NIO 中的 SocketChannel 以及这里介绍的 FileChannel 底层依赖的系统调用可能不同，这里会通过 NativeDispatcher 对具体 Channel 操作实现分发，调用具体的系统调用。对于 FileChannel 来说 NativeDispatcher 的实现类为 FileDispatcher。对于 SocketChannel 来说 NativeDispatcher 的实现类为 SocketDispatcher。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们进入 IOUtil 里面来一探究竟~~&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IOUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, ByteBuffer dst, &lt;span&gt;long&lt;/span&gt; position,&lt;br/&gt;                    NativeDispatcher nd)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;         .......... 省略 .......&lt;br/&gt;&lt;br/&gt;         .... 创建一个临时的directByteBuffer....&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; n = readIntoNativeBuffer(fd, directByteBuffer, position, nd);&lt;br/&gt;&lt;br/&gt;            .......... 省略 .......&lt;br/&gt;&lt;br/&gt;         .... 将directByteBuffer中读取到的内容再次拷贝到heapByteBuffer中给用户返回....&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; n;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            .......... 省略 .......&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;readIntoNativeBuffer&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, ByteBuffer bb,&lt;br/&gt;                                            &lt;span&gt;long&lt;/span&gt; position, NativeDispatcher nd)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; pos = bb.position();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lim = bb.limit();&lt;br/&gt;        &lt;span&gt;assert&lt;/span&gt; (pos &amp;lt;= lim);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rem = (pos &amp;lt;= lim ? lim - pos : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        .......... 省略 .......&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (position != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;          .......... 省略 .......&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            n = nd.read(fd, ((DirectBuffer)bb).address() + pos, rem);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            bb.position(pos + n);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; n;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到 FileChannel 的 read  方法最终会调用到 NativeDispatcher 的 read 方法。前边我们介绍了这里的 NativeDispatcher 就是 FileDispatcher 在 NIO 中的实现类为 FileDispatcherImpl，用来触发 native 方法执行底层系统调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileDispatcherImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FileDispatcher&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, &lt;span&gt;long&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; read0(fd, address, len);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;read0&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, &lt;span&gt;long&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终在 FileDispatcherImpl 类中触发了 native 方法 read0 的调用，我们继续到 FileDispatcherImpl.c 文件中去查看 native 方法的实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// FileDispatcherImpl.c 文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT jint JNICALL &lt;span&gt;Java_sun_nio_ch_FileDispatcherImpl_read0&lt;/span&gt;&lt;span&gt;(JNIEnv *env, jclass clazz,&lt;br/&gt;                             jobject fdo, jlong address, jint len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    jint fd = fdval(env, fdo);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *buf = (&lt;span&gt;void&lt;/span&gt; *)jlong_to_ptr(address);&lt;br/&gt;    &lt;span&gt;// 发起 read 系统调用进入内核&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; convertReturnVal(env, read(fd, buf, len), JNI_TRUE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统调用 read(fd, buf, len) 最终是在 native 方法 read0 中被触发的。下面是系统调用 read 在内核中的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SYSCALL_DEFINE3(read, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, fd, &lt;span&gt;char&lt;/span&gt; __user *, buf, &lt;span&gt;size_t&lt;/span&gt;, count){  &lt;br/&gt;&lt;br/&gt;    ...... 省略 ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来我们就从 JDK NIO 这一层逐步来到了用户空间与内核空间的边界处 --- OS 系统调用 read 这里，马上就要进入内核了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6370967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7BZYvGmI9YvdQV91W6F9A34CaFhTCK3IJZTJsFc2IupwHDxhxrZbErw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就来看一下当系统调用 read 发起之后，用户进程在内核态具体做了哪些事情？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 从内核角度探秘文件读取本质&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核将文件的 IO 操作根据是否使用内存（页高速缓存 page cache）做磁盘热点数据的缓存，将文件 IO 分为：Buffered IO 和 Direct IO 两种类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程在通过系统调用 open() 打开文件的时候，可以通过将参数 flags 赋值为 O_DIRECT 来指定文件操作为 Direct IO。默认情况下为 Buffered IO。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *pathname, &lt;span&gt;int&lt;/span&gt; flags, &lt;span&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Java 在 JDK 10 之前一直是不支持 Direct IO 的，到了 JDK 10 才开始支持 Direct IO。但是在 JDK 10 之前我们可以使用第三方的 Direct IO 框架 Jaydio 来通过 Direct IO 的方式对文件进行读写操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Jaydio GitHub ：https://github.com/smacke/jaydio&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者就带大家从内核角度深度剖析下这两种 IO 类型各自的特点：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 Buffered IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分文件系统默认的文件 IO 类型为 Buffered IO，当进程进行文件读取时，内核会首先检查文件对应的页高速缓存 page cache 中是否已经缓存了文件数据，如果有则直接返回，如果没有才会去磁盘中去读取文件数据，而且还会根据非常精妙的预读算法来预先读取后续若干文件数据到 page cache 中。这样等进程下一次顺序读取文件时，想要的数据已经预读进 page  cache 中了，进程直接返回，不用再到磁盘中去龟速读取了，这样一来就极大地提高了 IO  性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一些著名的消息队列中间件 Kafka , RocketMq 对消息日志文件进行顺序读取的时候，访问速度接近于内存。这就是 Buffered IO 中页高速缓存 page cache 的功劳。在本文的后面，笔者会为大家详细的介绍这一部分内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9024193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7IQlsK8Z41EfrtpAwdG8r9YglnK9lr9LCIf3ZmpK9JYIZT9AIsfvkBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们使用在上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247485497&amp;amp;idx=1&amp;amp;sn=eb4afe6764b2b976fb80f6dc5c6fd68a&amp;amp;chksm=ce77ce7ef900476865864e09bb6f0688ca784afc396084ecc90a894bfd733692049c332edd11&amp;amp;token=927203489&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《一步一图带你深入剖析 JDK NIO ByteBuffer 在不同字节序下的设计与实现》&lt;/a&gt; 中介绍的 HeapByteBuffer 来接收 NIO 读取文件数据的时候，整个文件读取的过程分为如下几个步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NIO 首先会将创建一个临时的 DirectByteBuffer 用于临时接收文件数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体为什么会创建一个临时的 DirectByteBuffer 来接收数据以及关于 DirectByteBuffer 的原理笔者会在后面的文章中为大家详细介绍。这里大家可以把它简单看成在 OS 堆中的一块虚拟内存地址。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后 NIO 会在&lt;strong&gt;用户态&lt;/strong&gt;调用系统调用 read 向内核发起文件读取的请求。此时发生&lt;strong&gt;第一次上下文切换&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户进程随即转到内核态运行，进入虚拟文件系统层，在这一层内核首先会查看读取文件对应的页高速缓存 page cache 中是否含有请求的文件数据，如果有直接返回，避免一次磁盘 IO。并根据内核预读算法从磁盘中&lt;strong&gt;异步预读&lt;/strong&gt;若干文件数据到 page cache 中（文件顺序读取高性能的关键所在）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在内核中，一个文件对应一个 page cache 结构，注意：这个 page cache 在内存中只会有一份。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果进程请求数据不在 page cache 中，则会进入文件系统层，在这一层调用块设备驱动程序触发真正的磁盘 IO。并根据内核预读算法&lt;strong&gt;同步预读&lt;/strong&gt;若干文件数据。请求的文件数据和预读的文件数据将被一起填充到 page cache 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在块设备驱动层完成真正的磁盘 IO。在这一层会从磁盘中读取进程请求的文件数据以及内核预读的文件数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;磁盘控制器 DMA 将从磁盘中读取的数据拷贝到页高速缓存 page cache 中。&lt;strong&gt;发生第一次数据拷贝&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后 CPU 将 page cache 中的数据拷贝到 NIO 在用户空间临时创建的缓冲区 DirectByteBuffer 中，&lt;strong&gt;发生第二次数据拷贝&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后系统调用 read 返回。进程从内核态切换回用户态。&lt;strong&gt;发生第二次上下文切换&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NIO 将 DirectByteBuffer 中临时存放的文件数据拷贝到 JVM 堆中的 HeapBytebuffer 中。&lt;strong&gt;发生第三次数据拷贝&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到如果使用 HeapByteBuffer 进行 NIO 文件读取的整个过程中，一共发生了 &lt;strong&gt;两次上下文切换&lt;/strong&gt;和&lt;strong&gt;三次数据拷贝&lt;/strong&gt;，如果请求的数据命中 page cache 则发生&lt;strong&gt;两次数据拷贝&lt;/strong&gt;省去了一次磁盘的 DMA 拷贝。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 Direct IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节中，笔者介绍了 Buffered IO 的诸多好处，尤其是在进程对文件进行顺序读取的时候，访问性能接近于内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有些情况，我们并不需要 page cache。比如一些高性能的数据库应用程序，它们在用户空间自己实现了一套高效的高速缓存机制，以充分挖掘对数据库独特的查询访问性能。所以这些数据库应用程序并不希望内核中的 page cache起作用。否则内核会同时处理 page cache 以及预读相关操作的指令，会使得性能降低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一种情况是，当我们在随机读取文件的时候，也不希望内核使用 page cache。因为这样违反了程序局部性原理，当我们随机读取文件的时候，内核预读进 page cache 中的数据将很久不会再次得到访问，白白浪费 page cache 空间不说，还额外增加了预读的磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上两点原因，我们很自然的希望内核能够提供一种机制可以绕过 page cache 直接对磁盘进行读写操作。这种机制就是本小节要为大家介绍的 Direct IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是内核采用 Direct IO 读取文件的工作流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7x7DM7upKicJV5VLFQFQicnxtmy5iccG9icDC6axEw8npIRLAGnhhpBeViaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Direct IO 和 Buffered IO 在进入内核虚拟文件系统层之前的流程全部都是一样的。区别就是进入到虚拟文件系统层之后，Direct IO 会绕过 page cache 直接来到文件系统层通过 direct_io 调用来到块驱动设备层，在块设备驱动层调用 __blockdev_direct_IO 对磁盘内容直接进行读写。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;和 Buffered IO 一样，在系统调用 read 进入内核以及 Direct IO 完成从内核返回的时候各自会发生一次上下文切换。&lt;strong&gt;共两次上下文切换&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;磁盘控制器 DMA 从磁盘中读取数据后直接拷贝到用户空间缓冲区 DirectByteBuffer 中。&lt;strong&gt;只发生一次 DMA 拷贝&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后 NIO 将 DirectByteBuffer 中临时存放的数据拷贝到 JVM 堆 HeapByteBuffer 中。&lt;strong&gt;发生第二次数据拷贝&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;注意块设备驱动层的 __blockdev_direct_IO 需要等到所有的 Direct IO 传送数据完成之后才会返回，&lt;strong&gt;这里的传送指的是直接从磁盘拷贝到用户空间缓冲区中&lt;/strong&gt;，当 Direct IO 模式下的 read() 或者 write() 系统调用返回之后，进程就可以安全放心地去读取用户缓冲区中的数据了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从整个 Direct IO 的过程中我们看到，一共发生了&lt;strong&gt;两次上下文的切换&lt;/strong&gt;，&lt;strong&gt;两次的数据拷贝&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Talk is cheap ! show you the code&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是系统调用 read 在内核中的完整定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SYSCALL_DEFINE3(read, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, fd, &lt;span&gt;char&lt;/span&gt; __user *, buf, &lt;span&gt;size_t&lt;/span&gt;, count) { &lt;br/&gt;      &lt;span&gt;// 根据文件描述符获取文件对应的 struct file结构&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt; &lt;span&gt;f&lt;/span&gt; = &lt;span&gt;fdget_pos&lt;/span&gt;(&lt;span&gt;fd&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;        ..... &lt;br/&gt;      &lt;span&gt;// 获取当前文件的读取位置 offset&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;loff_t&lt;/span&gt; pos = file_pos_read(f.file); &lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 进入虚拟文件系统层，执行具体的文件操作&lt;/span&gt;&lt;br/&gt;      ret = vfs_read(f.file, buf, count, &amp;amp;pos);&lt;br/&gt;       ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先会根据文件描述符 fd 通过 fdget_pos 方法获取 struct fd 结构，进而可以获取到文件的 struct file 结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;file&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt; need_put;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;file_pos_read 获取当前文件的读取位置 offset，并通过 vfs_read 进入虚拟文件系统层。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;ssize_t&lt;/span&gt; __vfs_read (struct file *file, &lt;span&gt;char&lt;/span&gt; __user *buf, &lt;span&gt;size_t&lt;/span&gt; count,  &lt;span&gt;loff_t&lt;/span&gt; *pos) {  &lt;br/&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;read)    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; file-&amp;gt;f_op-&amp;gt;read(file, buf, count, pos); &lt;br/&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;read_iter)    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; new_sync_read(file, buf, count, pos);  &lt;br/&gt;       &lt;span&gt;else&lt;/span&gt;    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -EINVAL;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到内核对文件的操作全部定义在 struct file 结构中的 f_op 字段中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt;  *&lt;span&gt;f_op&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;对于 Java 程序员来说，file_operations 大家可以把它当做内核针对文件相关操作定义的一个公共接口（其实就是一个函数指针），它只是一个接口。具体的实现根据不同的文件类型有所不同。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中详细介绍过的 Socket 文件。针对 Socket 文件类型，这里的 file_operations 指向的是 socket_file_ops。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;socket_file_ops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .owner =  THIS_MODULE,&lt;br/&gt;  .llseek =  no_llseek,&lt;br/&gt;  .read_iter =  sock_read_iter,&lt;br/&gt;  .write_iter =  sock_write_iter,&lt;br/&gt;  .poll =    sock_poll,&lt;br/&gt;  .unlocked_ioctl = sock_ioctl,&lt;br/&gt;  .mmap =    sock_mmap,&lt;br/&gt;  .release =  sock_close,&lt;br/&gt;  .fasync =  sock_fasync,&lt;br/&gt;  .sendpage =  sock_sendpage,&lt;br/&gt;  .splice_write = generic_splice_sendpage,&lt;br/&gt;  .splice_read =  sock_splice_read,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48629032258064514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7N2eq4oxAalevHsMvZ3dib98ibDXkWH2CMbgzhD5HUrWFC2xbFeHj9dxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;进程中管理文件列表结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而本小节中我们讨论的是对普通文件的操作，针对普通文件的操作定义在具体的文件系统中，这里我们以 Linux 中最为常见的 ext4 文件系统为例说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ext4 文件系统中管理的文件对应的 file_operations 指向 ext4_file_operations，专门用于操作 ext4 文件系统中的文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;ext4_file_operations&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      ......省略........&lt;br/&gt;&lt;br/&gt;      .read_iter  = ext4_file_read_iter,&lt;br/&gt;      .write_iter  = ext4_file_write_iter,&lt;br/&gt;&lt;br/&gt;      ......省略.........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7BqG2l6qbY098iarJ7FeYYHZlHicovvicEtjickGn7feTBP3PqMicTYvb1zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到 ext4 文件系统定义的相关文件操作 ext4_file_operations 并未定义 .read 函数指针。而是定义了 .read_iter 函数指针，指向 ext4_file_read_iter 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;ssize_t&lt;/span&gt; __vfs_read (struct file *file, &lt;span&gt;char&lt;/span&gt; __user *buf, &lt;span&gt;size_t&lt;/span&gt; count,  &lt;span&gt;loff_t&lt;/span&gt; *pos) {  &lt;br/&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;read)    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; file-&amp;gt;f_op-&amp;gt;read(file, buf, count, pos); &lt;br/&gt;       &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;read_iter)    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; new_sync_read(file, buf, count, pos);  &lt;br/&gt;       &lt;span&gt;else&lt;/span&gt;    &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -EINVAL;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在虚拟文件系统 VFS 中，__vfs_read 调用的是  new_sync_read 方法，在该方法中会对系统调用传进来的参数进行重新封装。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;struct file *filp ：要读取文件的 struct file 结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;char __user *buf ：用户空间的 Buffer，这里指的我们例子中 NIO 创建的临时  DirectByteBuffer。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;size_t count ：进行读取的字节数。也就是我们传入的用户态缓冲区 DirectByteBuffer 剩余可容纳的容量大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;loff_t *pos ：文件当前读取位置偏移 offset。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将这些参数重新封装到 struct iovec 和 struct kiocb 结构体中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;new_sync_read&lt;/span&gt;&lt;span&gt;(struct file *filp, &lt;span&gt;char&lt;/span&gt; __user *buf, &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;loff_t&lt;/span&gt; *ppos)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 将 DirectByteBuffer 以及要读取的字节数封装进 iovec 结构体中&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iovec&lt;/span&gt; &lt;span&gt;iov&lt;/span&gt; = {&lt;/span&gt; .iov_base = buf, .iov_len = len };&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kiocb&lt;/span&gt; &lt;span&gt;kiocb&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iov_iter&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt; ret;&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 利用文件 struct file 初始化 kiocb 结构体&lt;/span&gt;&lt;br/&gt; init_sync_kiocb(&amp;amp;kiocb, filp);&lt;br/&gt;    &lt;span&gt;// 设置文件读取偏移&lt;/span&gt;&lt;br/&gt; kiocb.ki_pos = *ppos;&lt;br/&gt;    &lt;span&gt;// 读取文件字节数&lt;/span&gt;&lt;br/&gt; kiocb.ki_nbytes = len;&lt;br/&gt;    &lt;span&gt;// 初始化 iov_iter 结构&lt;/span&gt;&lt;br/&gt; iov_iter_init(&amp;amp;iter, READ, &amp;amp;iov, &lt;span&gt;1&lt;/span&gt;, len);&lt;br/&gt;    &lt;span&gt;// 最终调用 ext4_file_read_iter&lt;/span&gt;&lt;br/&gt; ret = filp-&amp;gt;f_op-&amp;gt;read_iter(&amp;amp;kiocb, &amp;amp;iter);&lt;br/&gt;        .......省略......&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct iovec 结构体主要用来封装用来接收文件数据用的用户缓存区相关的信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iovec&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt; __user *iov_base;  &lt;span&gt;// 用户空间缓存区地址 这里是 DirectByteBuffer 的地址&lt;/span&gt;&lt;br/&gt; &lt;span&gt;__kernel_size_t&lt;/span&gt; iov_len; &lt;span&gt;// 缓冲区长度&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是内核中一般会使用 struct iov_iter 结构体对 struct iovec 进行包装，iov_iter 中可以包含多个 iovec。这一点从 struct iov_iter 结构体的命名关键字 &lt;code&gt;iter&lt;/code&gt; 上可以看得出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iov_iter&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;        ......省略.....&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iovec&lt;/span&gt; *&lt;span&gt;iov&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以使用 struct iov_iter 结构体来包装 struct iovec 是为了兼容 readv() 系统调用，它允许用户使用多个用户缓存区去读取文件中的数据。&lt;strong&gt;JDK NIO Channel 支持的 scatter 操作底层原理就是 readv 系统调用&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;       FileChannel fileChannel = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;file-read-write.txt&quot;&lt;/span&gt;), &lt;span&gt;&quot;rw&quot;&lt;/span&gt;).getChannel();&lt;br/&gt;&lt;br/&gt;       ByteBuffer  heapByteBuffer1 = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;       ByteBuffer  heapByteBuffer2 = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;       ByteBuffer[] scatter = { heapByteBuffer1, heapByteBuffer2 };&lt;br/&gt;&lt;br/&gt;       fileChannel.read(scatter);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;struct kiocb 结构体则是用来封装文件 IO 相关操作的状态和进度信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kiocb&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;  *&lt;span&gt;ki_filp&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;// 要读取的文件 struct file 结构&lt;/span&gt;&lt;br/&gt; &lt;span&gt;loff_t&lt;/span&gt;   ki_pos; &lt;span&gt;// 文件读取位置偏移，表示文件处理进度&lt;/span&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt; (*ki_complete)(struct kiocb *iocb, &lt;span&gt;long&lt;/span&gt; ret); &lt;span&gt;// IO完成回调 &lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt;   ki_flags; &lt;span&gt;// IO类型，比如是 Direct IO 还是 Buffered IO&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;        ........省略.......&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 struct iovec  和 struct kiocb 在 new_sync_read 方法中被初始化好之后，最终通过 file_operations 中定义的函数指针  .read_iter 调用到 ext4_file_read_iter 方法中，从而进入 ext4 文件系统执行具体的读取操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;ext4_file_read_iter&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb, struct iov_iter *to)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ........省略........&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; generic_file_read_iter(iocb, to);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;generic_file_read_iter&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb, struct iov_iter *iter)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    ........省略........&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (iocb-&amp;gt;ki_flags &amp;amp; IOCB_DIRECT) {&lt;br/&gt;&lt;br/&gt;        ........ Direct IO ........&lt;br/&gt;        &lt;span&gt;// 获取 page cache&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;mapping&lt;/span&gt; = &lt;span&gt;file&lt;/span&gt;-&amp;gt;&lt;span&gt;f_mapping&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        ........省略........&lt;br/&gt;        &lt;span&gt;// 绕过 page cache 直接从磁盘中读取数据&lt;/span&gt;&lt;br/&gt;        retval = mapping-&amp;gt;a_ops-&amp;gt;direct_IO(iocb, iter);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    ........ Buffered IO ........&lt;br/&gt;    &lt;span&gt;// 从 page cache 中读取数据&lt;/span&gt;&lt;br/&gt;    retval = generic_file_buffered_read(iocb, iter, retval);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;generic_file_read_iter 会根据 struct kiocb 中的 ki_flags 属性判断文件 IO 操作是 Direct IO 还是 Buffered IO。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 Direct IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7x7DM7upKicJV5VLFQFQicnxtmy5iccG9icDC6axEw8npIRLAGnhhpBeViaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 open 系统调用在打开文件的时候指定相关 IO 操作的模式是 Direct IO 还是 Buffered IO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;open&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *pathname, &lt;span&gt;int&lt;/span&gt; flags, &lt;span&gt;mode_t&lt;/span&gt; mode)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;char *pathname ：指定要文件的路径。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;int flags ：指定文件的访问模式。比如：O_RDONLY（只读），O_WRONLY,（只写）， O_RDWR（读写），O_DIRECT（Direct IO）。默认为 Buffered IO。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;mode_t mode ：可选，指定打开文件的权限&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Java 在 JDK 10 之前一直是不支持 Direct IO，到了 JDK 10 才开始支持 Direct IO。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Path path = Paths.get(&lt;span&gt;&quot;file-read-write.txt&quot;&lt;/span&gt;);&lt;br/&gt;FileChannel fc = FileChannel.open(p, ExtendedOpenOption.DIRECT)；&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在文件打开的时候，我们设置了 Direct IO 模式，那么以后在对文件进行读取的过程中，内核将会绕过 page cache，直接从磁盘中读取数据到用户空间缓冲区 DirectByteBuffer 中。这样就可以避免一次数据从内核 page cache 到用户空间缓冲区的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用程序期望使用自定义的缓存算法从而可以在用户空间实现更加高效更加可控的缓存逻辑时（比如数据库等应用程序），这时应该使用直接 Direct IO。在随机读取，随机写入的场景中也是比较适合用 Direct IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统进程在接下来使用 read() 或者 write() 系统调用去读写文件的时候使用的是 Direct IO 方式，所传输的数据均不经过文件对应的高速缓存 page cache （这里就是网上常说的内核缓冲区）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道操作系统是将内存分为一页一页的单位进行组织管理的，每页大小 4K ，那么同样文件中的数据在磁盘中的组织形式也是按照一块一块的单位来组织管理的，每块大小也是 4K ，所以我们在使用 Direct IO 读写数据时必须要按照文件在磁盘中的组织单位进行磁盘块大小对齐，缓冲区的大小也必须是磁盘块大小的整数倍。具体表现在如下几点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文件的读写位置偏移需要按照磁盘块大小对齐。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户缓冲区 DirectByteBuffer 起始地址需要按照磁盘块大小对齐。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 Direct IO 进行数据读写时，读写的数据大小需要按照磁盘块大小进行对齐。这里指 DirectByteBuffer 中剩余数据的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们采用 Direct IO 直接读取磁盘中的文件数据时，内核会从 struct file 结构中获取到该文件在内存中的 page cache。而我们多次提到的这个 page cache 在内核中的数据结构就是 struct address_space 。我们可以根据 file-&amp;gt;f_mapping 获取。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// page cache&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;f_mapping&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和前面我们介绍的 struct file 结构中的 file_operations 一样，内核中将 page cache 相关的操作全部定义在 struct address_space_operations 结构中。这里和前边介绍的 file_operations 的作用是一样的，只是内核针对 page cache 操作定义的一个公共接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; *&lt;span&gt;a_ops&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的实现会根据文件系统的不同而不同，这里我们还是以 ext4 文件系统为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; &lt;span&gt;ext4_aops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .direct_IO  = ext4_direct_IO,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核通过 struct address_space_operations 结构中定义的 .direct_IO 函数指针，具体函数为 ext4_direct_IO 来绕过 page cache 直接对磁盘进行读写。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;采用 Direct IO 的方式对文件的读写操作全部是在  ext4_direct_IO 这一个函数中完成的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于磁盘文件中的数据是按照块为单位来组织管理的，所以文件系统其实就是一个块设备，通过 ext4_direct_IO 绕过 page cache 直接来到了文件系统的块设备驱动层，最终在块设备驱动层调用 __blockdev_direct_IO 来完成磁盘的读写操作。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：块设备驱动层的 __blockdev_direct_IO 需要等到所有的 Direct IO 传送数据完成之后才会返回，这里的传送指的是直接从磁盘拷贝到用户空间缓冲区中，当 Direct IO 模式下的 read() 或者 write() 系统调用返回之后，进程就可以安全放心地去读取用户缓冲区中的数据了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 Buffered IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9024193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7IQlsK8Z41EfrtpAwdG8r9YglnK9lr9LCIf3ZmpK9JYIZT9AIsfvkBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Buffered IO 相关的读取操作封装在 generic_file_buffered_read 函数中，其核心逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于文件在磁盘中是以块为单位组织管理的，每块大小为 4k，内存是按照页为单位组织管理的，每页大小也是 4k。文件中的块数据被缓存在 page cache 中的缓存页中。所以首先通过 find_get_page 方法查找我们要读取的文件数据是否已经缓存在了 page cache 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果 page cache 中不存在文件数据的缓存页，就需要通过 page_cache_sync_readahead 方法从磁盘中读取数据并缓存到 page cache 中。于此同时还需要&lt;strong&gt;同步&lt;/strong&gt;预读若干相邻的数据块到 page cache 中。这样在下一次顺序读取的时候，直接就可以从 page cache 中读取了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果此次读取的文件数据已经存在于 page cache 中了，就需要调用 PageReadahead 来判断是否需要进一步预读数据到缓存页中。如果是，则从磁盘中&lt;strong&gt;异步&lt;/strong&gt;预读若干页到 page cache 中。具体预读多少页是根据内核相关预读算法来动态调整的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;经过上面几个流程，此时文件数据已经存在于 page cache 中的缓存页中了，最后内核调用 copy_page_to_iter 方法将 page cache 中的数据拷贝到用户空间缓冲区 DirectByteBuffer 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;generic_file_buffered_read&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb,&lt;br/&gt;    struct iov_iter *iter, &lt;span&gt;ssize_t&lt;/span&gt; written)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 获取文件在内核中对应的 struct file 结构&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;filp&lt;/span&gt; = &lt;span&gt;iocb&lt;/span&gt;-&amp;gt;&lt;span&gt;ki_filp&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 获取文件对应的 page cache&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;mapping&lt;/span&gt; = &lt;span&gt;filp&lt;/span&gt;-&amp;gt;&lt;span&gt;f_mapping&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 获取文件的 inode&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;   ...........省略...........&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 开始 Buffered IO 读取逻辑&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;    &lt;span&gt;// 用于从 page cache 中获取缓存的文件数据 page&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 根据文件读取偏移计算出 第一个字节所在物理页的索引&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pgoff_t&lt;/span&gt; index;&lt;br/&gt;    &lt;span&gt;// 根据文件读取偏移计算出 第一个字节所在物理页中的页内偏移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset; &lt;br/&gt;    &lt;span&gt;// 在 page cache 中查找是否有读取数据在内存中的缓存页&lt;/span&gt;&lt;br/&gt;    page = find_get_page(mapping, index);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!page) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (iocb-&amp;gt;ki_flags &amp;amp; IOCB_NOWAIT) {&lt;br/&gt;           ....... 如果设置的是异步IO，则直接返回 -EAGAIN ......&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// 要读取的文件数据在 page cache 中没有对应的缓存页&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 则从磁盘中读取文件数据，并同步预读若干相邻的数据块到 page cache中&lt;/span&gt;&lt;br/&gt;      page_cache_sync_readahead(mapping,&lt;br/&gt;          ra, filp,&lt;br/&gt;          index, last_index - index);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 再一次触发缓存页的查找，这一次就可以找到了&lt;/span&gt;&lt;br/&gt;      page = find_get_page(mapping, index);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (unlikely(page == &lt;span&gt;NULL&lt;/span&gt;))&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; no_cached_page;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//如果读取的文件数据已经在 page cache 中了，则判断是否进行近一步的预读操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (PageReadahead(page)) {&lt;br/&gt;      &lt;span&gt;//异步预读若干文件数据块到 page cache 中&lt;/span&gt;&lt;br/&gt;      page_cache_async_readahead(mapping,&lt;br/&gt;          ra, filp, page,&lt;br/&gt;          index, last_index - index);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    ..............省略..............&lt;br/&gt;    &lt;span&gt;//将 page cache 中的数据拷贝到用户空间缓冲区 DirectByteBuffer 中&lt;/span&gt;&lt;br/&gt;    ret = copy_page_to_iter(page, offset, nr, iter);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7oF9kmnFZfga2UDFFwdg2e2WQH3TLh04EuvnQVgWZOsWAUvlJEZHk4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里关于文件读取的两种模式 Buffered IO 和 Direct IO 在内核中的主干逻辑流程笔者就为大家介绍完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是大家可能会对 Buffered IO 中的两个细节比较感兴趣：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如何在 page cache 中查找我们要读取的文件数据 ？也就是说上面提到的 find_get_page 函数是如何实现的？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文件预读的过程是怎么样的？内核中的预读算法又是什么样的呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在为大家解答这两个疑问之前，笔者先为大家介绍一下内核中的页高速缓存 page cache。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 页高速缓存 page cache&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484304&amp;amp;idx=1&amp;amp;sn=54bf0d07e69c5621c145afaece8f50d6&amp;amp;chksm=ce77c5d7f9004cc1249a03dfd0fb12b7d75171f1b87acea1fa44bbb11ca374b6f42a66fa274d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《一文聊透对象在 JVM 中的内存布局，以及内存对齐和压缩指针的原理及应用》&lt;/a&gt; 文章中为大家介绍 CPU 的高速缓存时曾提到过，根据摩尔定律：芯片中的晶体管数量每隔 18 个月就会翻一番。导致 CPU 的性能和处理速度变得越来越快，而提升 CPU 的运行速度比提升内存的运行速度要容易和便宜的多，所以就导致了 CPU 与内存之间的速度差距越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 与内存之间的速度差异到底有多大呢？我们知道寄存器是离 CPU 最近的，CPU 在访问寄存器的时候速度近乎于 0 个时钟周期，访问速度最快，基本没有时延。而访问内存则需要 50 - 200 个时钟周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了弥补 CPU 与内存之间巨大的速度差异，提高 CPU 的处理效率和吞吐，于是我们引入了 L1 , L2 , L3 高速缓存集成到 CPU 中。CPU 访问高速缓存仅需要用到 1 - 30 个时钟周期，CPU 中的高速缓存是对内存热点数据的一个缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r73GEBMSEmKwRpLFCNLRvaibZVMmSWnWMbYrk9yRyibllxnhMSicV7acWcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而本文我们讨论的主题是内存与磁盘之间的关系，CPU 访问磁盘的速度就更慢了，需要用到大概约几千万个时钟周期.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到 CPU 访问高速缓存的速度比访问内存的速度快大约10倍，而访问内存的速度要比访问磁盘的速度快大约 100000 倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入 CPU 高速缓存的目的在于消除 CPU 与内存之间的速度差距，CPU 用高速缓存来存放内存中的热点数据。那么同样的道理，本小节中我们引入的页高速缓存 page cache 的目的是为了消除内存与磁盘之间的巨大速度差距，page cache 中缓存的是磁盘文件的热点数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们根据程序的时间局部性原理可以知道，磁盘文件中的数据一旦被访问，那么它很有可能在短期被再次访问，如果我们访问的磁盘文件数据缓存在 page cache 中，那么当进程再次访问的时候数据就会在 page cache 中命中，这样我们就可以把对磁盘的访问变为对物理内存的访问，极大提升了对磁盘的访问性能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边的内容中我们多次提到操作系统是将物理内存分为一个一个的页面来组织管理的，每页大小为 4k ，而磁盘中的文件数据在磁盘中是分为一个一个的块来组织管理的，每块大小也为 4k。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;page cache 中缓存的就是这些内存页面，页面中的数据对应于磁盘上物理块中的数据。page cache 中缓存的大小是可以动态调整的，它可以通过占用空闲内存来扩大缓存页面的容量，当内存不足时也可以通过回收页面来缓解内存使用的压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们上小节介绍的 read 系统调用在内核中的实现逻辑那样，当用户进程发起 read 系统调用之后，内核首先会在 page cache 中检查请求数据所在页面是否已经缓存在 page cache 中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果缓存命中，内核直接会把 page cache 中缓存的磁盘文件数据拷贝到用户空间缓冲区 DirectByteBuffer 中，从而避免了龟速的磁盘 IO。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果缓存没有命中，内核会分配一个物理页面，将这个新分配的页面插入 page cache 中，然后调度磁盘块 IO 驱动从磁盘中读取数据，最后用从磁盘中读取的数据填充这个物里页面。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据前面介绍的程序时间局部性原理，当进程在不久之后再来读取数据的时候，请求的数据已经在 page cache 中了。极大地提升了文件 IO 的性能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;page cache 中缓存的不仅有基于文件的缓存页，还会缓存内存映射文件，以及磁盘块设备文件。这里大家只需要有这个概念就行，本文我们主要聚焦于基于文件的缓存页。在笔者后面的文章中，我们还会再次介绍到这些剩余类型的缓存页。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们了解了 page cache 引入的目的以及 page cache 在磁盘 IO 中所发挥的作用之后，大家一定会很好奇这个 page cache 在内核中到底是怎么实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们先从 page cache 在内核中的数据结构开始聊起~~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. page cache 在内核中的数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;page cache 在内核中的数据结构是一个叫做 address_space 的结构体：struct address_space。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这个名字起的真是有点词不达意，从命名上根本无法看出它是表示 page cache 的，所以大家在日常开发中一定要注意命名的精准规范。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个文件都会有自己的 page cache。struct address_space 结构在内存中只会保留一份。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么意思呢？比如我们可以通过多个不同的进程打开一个相同的文件，进程每打开一个文件，内核就会为它创建 struct file 结构。这样在内核中就会有多个 struct file 结构来表示同一个文件，但是同一个文件的 page cache 也就是 struct address_space 在内核中只会有一个。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6056451612903225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r75at0hFKmFicVSiaNHSDRicqToibIQTXhzJTwJYAibOc7DkLOibEnwicvuG2Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt;  *&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;// 关联 page cache 对应文件的 inode&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_root&lt;/span&gt; &lt;span&gt;page_tree&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 这里就是 page cache。里边缓存了文件的所有缓存页面&lt;/span&gt;&lt;br/&gt; &lt;span&gt;spinlock_t&lt;/span&gt;  tree_lock; &lt;span&gt;// 访问 page_tree 时用到的自旋锁&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;  nrpages; &lt;span&gt;// page cache 中缓存的页面总数&lt;/span&gt;&lt;br/&gt;         ..........省略..........&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; *&lt;span&gt;a_ops&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 定义对 page cache 中缓存页的各种操作方法&lt;/span&gt;&lt;br/&gt;         ..........省略..........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;struct inode *host&lt;/code&gt; ：一个文件对应一个 page cache 结构 struct address_space ，文件的 inode 描述了一个文件的所有元信息。在 struct address_space 中通过 host 指针与文件的 inode 关联。而在 inode 结构体 struct inode 中又通过 i_mapping 指针与文件的 page cache 进行关联。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;i_mapping&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 关联文件的 page cache&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct radix_tree_root  page_tree&lt;/code&gt; :  page cache 中缓存的所有文件页全部存储在 radix_tree 这样一个高效搜索树结构当中。在文件 IO 相关的操作中，内核需要频繁大量地在 page cache 中搜索请求页是否已经缓存在页高速缓存中，所以针对 page cache 的搜索操作必须是高效的，否则引入 page cache 所带来的性能提升将会被低效的搜索开销所抵消掉。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;unsigned long nrpages&lt;/code&gt; ：记录了当前文件对应的 page cache 缓存页面的总数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;const struct address_space_operations *a_ops&lt;/code&gt; ：a_ops 定义了 page cache 中所有针对缓存页的 IO 操作，提供了管理 page cache 的各种行为。比如：常用的页面读取操作 readPage() 以及页面写入操作 writePage() 等。保证了所有针对缓存页的 IO 操作必须是通过 page cache 进行的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 写入更新页面缓存&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; (*writepage)(struct page *page, struct writeback_control *wbc);&lt;br/&gt;    &lt;span&gt;// 读取页面缓存&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; (*readpage)(struct file *, struct page *);&lt;br/&gt;    &lt;span&gt;// 设置缓存页为脏页，等待后续内核回写磁盘&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; (*set_page_dirty)(struct page *page);&lt;br/&gt;    &lt;span&gt;// Direct IO 绕过 page cache 直接操作磁盘&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt; (*direct_IO)(struct kiocb *, struct iov_iter *iter);&lt;br/&gt;&lt;br/&gt;        ........省略..........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们提到 page cache 中缓存的不仅仅是基于文件的页，它还会缓存内存映射页，以及磁盘块设备文件，况且基于文件的内存页背后也有不同的文件系统。所以内核只是通过 a_ops 定义了操作 page cache 缓存页 IO 的通用行为定义。而具体的实现需要各个具体的文件系统通过自己定义的 address_space_operations 来描述自己如何与 page cache 进行交互。比如前边我们介绍的 ext4 文件系统就有自己的 address_space_operations 定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; &lt;span&gt;ext4_aops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt; .readpage  = ext4_readpage,&lt;br/&gt; .writepage  = ext4_writepage,&lt;br/&gt; .direct_IO  = ext4_direct_IO,&lt;br/&gt;&lt;br/&gt;      ........省略.....&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们从整体上了解了 page cache 在内核中的数据结构 struct address_space  之后，我们接下来看一下 radix_tree 这个数据结构是如何支持内核来高效搜索文件页的，以及 page cache 中这些被缓存的文件页是如何组织管理的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 基树 radix_tree&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如前边我们提到的，在文件 IO 相关的操作中，内核会频繁大量地在 page cache 中查找请求页是否在页高速缓存中。还有就是当我们访问大文件时（linux 能支持大到几个 TB 的文件），page cache 中将会充斥着大量的文件页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于上面提到的两个原因：一个是内核对 page cache 的频繁搜索操作，另一个是 page cache 中会缓存大量的文件页。所以内核需要采用一个高效的搜索数据结构来组织管理 page cache 中的缓存页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们就来介绍下，page cache 中用来存储缓存页的数据结构 radix_tree。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在 linux 内核 5.0 版本中 radix_tree 已被替换成 xarray 结构。感兴趣的同学可以自行了解下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 page cache 结构 struct address_space 中有一个类型为  struct radix_tree_root  的字段 page_tree，它表示的是 radix_tree 的根节点。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_root&lt;/span&gt;  &lt;span&gt;page_tree&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 这里就是 page cache。里边缓存了文件的所有缓存页面&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    ..........省略..........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_root&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;gfp_t&lt;/span&gt;   gfp_mask;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_node&lt;/span&gt; __&lt;span&gt;rcu&lt;/span&gt; *&lt;span&gt;rnode&lt;/span&gt;;&lt;/span&gt;  &lt;span&gt;// radix_tree 根节点&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;radix_tree 中的节点类型为 struct radix_tree_node。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_node&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt; __rcu *slots[RADIX_TREE_MAP_SIZE]; &lt;span&gt;//包含 64 个指针的数组。用于指向下一层节点或者缓存页&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; offset; &lt;span&gt;//父节点中指向该节点的指针在父节点 slots 数组中的偏移&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; count;&lt;span&gt;//记录当前节点的 slots 数组指向了多少个节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_node&lt;/span&gt; *&lt;span&gt;parent&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 父节点指针&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;radix_tree_root&lt;/span&gt; *&lt;span&gt;root&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 根节点&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;         ..........省略.........&lt;br/&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS]; &lt;span&gt;// radix_tree 中的二维标记数组，用于标记子节点的状态。&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7OcNtSa6mJq1IpMj8vx0j0lxW9kOI2sCLoqlIP2GeDR8B4iasXhAgAvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;void __rcu  *slots[RADIX_TREE_MAP_SIZE]&lt;/code&gt; ：radix_tree 树中的每个节点中包含一个 slots ，它是一个包含 64 个指针的数组，每个指针指向它的下一层节点或者缓存页描述符 struct page。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;radix_tree 将缓存页全部存放在它的叶子结点中，所以它的叶子结点类型为 struct page。其余的节点类型为 radix_tree_node。最底层的 radix_tree_node 节点中的 slots 指向缓存页描述符 struct page。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;unsigned char   offset&lt;/code&gt; 用于表示父节点的 slots 数组中指向当前节点的指针，在父节点的slots数组中的索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;unsigned char   count&lt;/code&gt; 用于记录当前 radix_tree_node 的 slots 数组中指向的节点个数，因为 slots 数组中的指针有可能指向 null 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里大家可能已经注意到了在 struct radix_tree_node  结构中还有一个 long 型的 tags 二维数组 &lt;code&gt;tags[RADIX_TREE_MAX_TAGS][RADIX_TREE_TAG_LONGS]&lt;/code&gt;。那么这个二维数组到底是用来干嘛的呢？我们接着往下看~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.1 radix_tree 的标记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前面的介绍我们知道，页高速缓存 page cache 的引入是为了在内存中缓存磁盘的热点数据尽可能避免龟速的磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在进行文件 IO 的时候，内核会频繁大量的在 page cache 中搜索请求数据是否已经缓存在 page cache 中，如果是，内核就直接将 page cache 中的数据拷贝到用户缓冲区中。从而避免了一次磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就要求内核需要采用一种支持高效搜索的数据结构来组织管理这些缓存页，所以引入了基树 radix_tree。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，我们还没有涉及到缓存页的状态，不过在文章的后面我们很快就会涉及到，这里提前给大家引出来，让大家脑海里先有个概念。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么是缓存页的状态呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道在 Buffered IO  模式下，对于文件 IO 的操作都是需要经过 page cache 的，后面我们即将要介绍的 write 系统调用就会将数据直接写到 page cache 中，并将该缓存页标记为脏页（PG_dirty）直接返回，随后内核会根据一定的规则来将这些脏页回写到磁盘中，在会写的过程中这些脏页又会被标记为 PG_writeback，表示该页正在被回写到磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PG_dirty 和 PG_writeback 就是缓存页的状态，而内核不仅仅是需要在 page cache 中高效搜索请求数据所在的缓存页，还需要高效搜索给定状态的缓存页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：快速查找 page cache 中的所有脏页。但是如果此时 page cache 中的大部分缓存页都不是脏页，那么顺序遍历 radix_tree 的方式就实在是太慢了，所以为了快速搜索到脏页，就需要在 radix_tree 中的每个节点 radix_tree_node
中加入一个针对其所有子节点的脏页标记，如果其中一个子节点被标记被脏时，那么这个子节点对应的父节点 radix_tree_node 结构中的对应脏页标记位就会被置 1 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用来存储脏页标记的正是上小节中提到的 tags 二维数组。其中第一维 tags[] 用来表示标记类型，有多少标记类型，数组大小就为多少，比如 tags[0] 表示 PG_dirty 标记数组，tags[1] 表示 PG_writeback 标记数组。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43790322580645163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7se4mlJP91EoAIqv9at8C8t3LCz7ichZfggy6QkHQG66zfXWDmV9gvfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二维 tags[][] 数组则表示对应标记类型针对每一个子节点的标记位，因为一个 radix_tree_node 节点中包含 64 个指针指向对应的子节点，所以二维 tags[][] 数组的大小也为 64 ，数组中的每一位表示对应子节点的标记。tags[0][0] 指向 PG_dirty 标记数组，tags[1][0] 指向PG_writeback 标记数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而缓存页（ radix_tree 中的叶子结点）这些标记是存放在其对应的页描述符 struct page 里的 flag 中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; flags;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7a5p4udGQ2vDsvOe2o1LBYODmVhHDUibtOo0EkGDGelnJwGYOD1cvAFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要一个缓存页（叶子结点）被标记，那么从这个叶子结点一直到 radix_tree 根节点的路径将会全部被标记。这就好比你在一盆清水中滴入一滴墨水，不久之后整盆水就会变为黑色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7pvNnia8hsUZ2hS3eUuPVyNGls0lQovSiaIzjMz3ANHNexwibvAbLLeAMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样内核在 radix_tree 中搜索被标记的脏页（PG_dirty）或者正在回写的页（PG_writeback）时，就可以迅速跳过哪些标记为 0 的中间节点的所有子树，中间节点对应的标记为 0 说明其所有的子树中包含的缓存页（叶子结点）都是干净的（未标记）。从而达到在 radix_tree 中迅速搜索指定状态的缓存页的目的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. page cache 中查找缓存页&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们明白了 radix_tree 这个数据结构之后，接下来我们来看一下在《4.2 Buffered IO》小节中遗留的问题：内核如何通过 find_get_page 在 page cache 中高效查找缓存页？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍 find_get_page 之前，笔者先来带大家看看 radix_tree 具体是如何组织和管理其中的缓存页 page 的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7a5p4udGQ2vDsvOe2o1LBYODmVhHDUibtOo0EkGDGelnJwGYOD1cvAFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上小节相关内容的介绍，我们了解到在 radix_tree 中每个节点 radix_tree_node 包含一个大小为 64 的指针数组 slots 用于指向它的子节点或者缓存页描述符（叶子节点）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 radix_tree_node 节点下边最多可容纳 64 个子节点，如果 radix_tree 的深度为 1 （不包括叶子节点），那么这颗 radix_tree 就可以缓存 64 个文件页。而每页大小为 4k，所以一颗深度为 1 的 radix_tree 可以缓存 256k 的文件内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36370967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7xM9cOicSVia60xnic61QNpv3QP81c00ozzeibEmzF3lg1ImkwwicqvbO6hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果一颗 radix_tree 的深度为 2，那么它就可以缓存 64 * 64 = 4096 个文件页，总共可以缓存 16M 的文件内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5241935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7bFHm3S89xyWTFkLj088BWz3PAHIZCibTJnfML4VNeTvRNdl9v97Qf8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依次类推我们可以得到不同的 radix_tree 深度可以缓存多大的文件内容：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;radix_tree 深度&lt;/th&gt;&lt;th&gt;page 最大索引值&lt;/th&gt;&lt;th&gt;缓存文件大小&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;2^6 - 1 = 63&lt;/td&gt;&lt;td&gt;256K&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;2^12 - 1 = 4095&lt;/td&gt;&lt;td&gt;16M&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2^18 - 1 = 262143&lt;/td&gt;&lt;td&gt;1G&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;2^24 -1 =16777215&lt;/td&gt;&lt;td&gt;64G&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;2^30 - 1&lt;/td&gt;&lt;td&gt;4T&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;2^36 - 1&lt;/td&gt;&lt;td&gt;64T&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容的介绍，我们看到在 radix_tree 是根据缓存页的 index （索引）来组织管理缓存页的，内核会根据这个 index 迅速找到对应的缓存页。在缓存页描述符 struct page 结构中保存了其在 page cache 中的索引 index。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; flags;  &lt;span&gt;//缓存页标记&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;mapping&lt;/span&gt;;&lt;/span&gt; &lt;span&gt;// 缓存页所在的 page cache&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; index;  &lt;span&gt;// 页索引&lt;/span&gt;&lt;br/&gt;    ...  &lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上 find_get_page 函数也是根据缓存页描述符中的这个 index 来在 page cache 中高效查找对应的缓存页。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; struct page *&lt;span&gt;find_get_page&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;     &lt;span&gt;pgoff_t&lt;/span&gt; offset)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; pagecache_get_page(mapping, offset, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct address_space *mapping&lt;/code&gt; : 为读取文件对应的 page cache 页高速缓存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;pgoff_t offset&lt;/code&gt; ：为所请求的缓存页在 page cache 中的索引 index，类型为 long 型。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在内核是如何利用这个 long 型的 offset 在 page cache 中高效搜索指定的缓存页呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边我们对 radix_tree 结构的介绍，我们已经知道 radix_tree 中每个节点 radix_tree_node 包含一个大小为 64 的指针数组 slots 用于指向它的子节点或者缓存页描述符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 radix_tree_node 节点下边最多可容纳 64 个子节点，如果 radix_tree 的深度为 1 （不包括叶子节点），那么这颗 radix_tree 就可以缓存 64 个文件页。只能表示 0 - 63 的索引范围，所以 long 型的缓存页 offset 的低 6 位可以表示这个范围，对应于第一层 radix_tree_node 节点的 slots 数组下标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7OcNtSa6mJq1IpMj8vx0j0lxW9kOI2sCLoqlIP2GeDR8B4iasXhAgAvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一颗 radix_tree 的深度为 2（不包括叶子节点），那么它就可以缓存 64 * 64 = 4096 个文件页，表示的索引范围为 0 - 4095，在这种情况下，缓存页索引 offset 的低 12 位可以分成 两个 6 位的字段，高位的字段用来表示第一层节点的 slots 数组的下标，低位字段用于表示第二层节点的 slots 数组下标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依次类推，如果 radix_tree 的深度为 6 那么它可以缓存 64T 的文件页，表示的索引范围为：0 到 2^36 - 1。缓存页索引 offset 的低 36 位可以分成 六 个 6 位的字段。缓存页索引的最高位字段来表示 radix_tree 中的第一层节点中的 slots 数组下标，接下来的 6 位字段表示第二层节点中的 slots 数组下标，这样一直到最低的 6 位字段表示第 6 层节点中的 slots 数组下标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上根据缓存页索引 offset 的查找过程，我们看出内核在 page cache 查找缓存页的时间复杂度和 radix_tree 的深度有关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们理解了内核在 radix_tree 中的查找缓存页逻辑之后，再来看 find_get_page 的代码实现就变得很简单了~~&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;struct page *&lt;span&gt;pagecache_get_page&lt;/span&gt;&lt;span&gt;(struct address_space *mapping, &lt;span&gt;pgoff_t&lt;/span&gt; offset,&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; fgp_flags, &lt;span&gt;gfp_t&lt;/span&gt; gfp_mask)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;repeat:&lt;br/&gt;    &lt;span&gt;// 在 radix_tree 中根据 缓存页 offset 查找缓存页&lt;/span&gt;&lt;br/&gt; page = find_get_entry(mapping, offset);&lt;br/&gt;    &lt;span&gt;// 缓存页不存在的话，跳转到 no_page 处理逻辑&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!page)&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; no_page;&lt;br/&gt;&lt;br/&gt;   .......省略.......&lt;br/&gt;no_page:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!page &amp;amp;&amp;amp; (fgp_flags &amp;amp; FGP_CREAT)) { &lt;br/&gt;         &lt;span&gt;// 分配新页&lt;/span&gt;&lt;br/&gt;  page = __page_cache_alloc(gfp_mask);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!page)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (fgp_flags &amp;amp; FGP_ACCESSED)&lt;br/&gt;            &lt;span&gt;//增加页的引用计数&lt;/span&gt;&lt;br/&gt;   __SetPageReferenced(page);&lt;br/&gt;        &lt;span&gt;// 将新分配的内存页加入到页高速缓存 page cache 中&lt;/span&gt;&lt;br/&gt;  err = add_to_page_cache_lru(page, mapping, offset, gfp_mask);&lt;br/&gt;&lt;br/&gt;              .......省略.......&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; page;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核首先调用 find_get_entry 方法根据缓存页的 offset 到 page cache 中去查找看请求的文件页是否已经在页高速缓存中。如果存在直接返回。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果请求的文件页不在 page cache 中，内核则会首先会在物理内存中分配一个内存页，然后将新分配的内存页加入到 page cache 中，并增加页引用计数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后会通过 address_space_operations 重定义的 readpage 激活块设备驱动从磁盘中读取请求数据，然后用读取到的数据填充新分配的内存页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; &lt;span&gt;ext4_aops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;    .readpage       = ext4_readpage,&lt;br/&gt;    .writepage      = ext4_writepage,&lt;br/&gt;    .direct_IO      = ext4_direct_IO,&lt;br/&gt;&lt;br/&gt;      ........省略.....&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 文件页的预读&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们在引入 page cache 的时候提到过，根据程序时间局部性原理：如果进程在访问某一块数据，那么在访问的不久之后，进程还会再次访问这块数据。所以内核引入了 page cache 在内存中缓存磁盘中的热点数据，从而减少对磁盘的 IO 访问，提升系统性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而本小节我们要介绍的文件页预读特性是根据程序空间局部性原理：当进程访问一段数据之后，那么在不就的将来和其临近的一段数据也会被访问到。所以当进程在访问文件中的某页数据的时候，内核会将它和临近的几个页一起预读到 page cache 中。这样当进程再次访问文件的时候，就不需要进行龟速的磁盘 IO 了，因为它所请求的数据已经预读进 page cache 中了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们常提到的当你顺序读取文件的时候，性能会非常的高，因为相当于是在读内存，这就是文件预读的功劳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在我们随机访问文件的时候，文件预读不仅不会提高性能，返回会降低文件读取的性能，因为随机读取文件并不符合程序空间局部性原理，因此预读进 page cache 中的文件页通常是无效的，下一次根本不会再去读取，这无疑是白白浪费了 page cache 的空间，还额外增加了不必要的预读磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，在我们对文件进行随机读取的场景下，更适合用 Direct IO 的方式绕过 page cache 直接从磁盘中读取文件，还能减少一次从 page cache 到用户缓冲区的拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以内核需要一套非常精密的预读算法来根据进程是顺序读文件还是随机读文件来精确地调控预读的文件页数，或者直接关闭预读。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;进程在读取文件数据的时候都是逐页进行读取的，因此在预读文件页的时候内核并不会考虑页内偏移，而是根据请求数据在文件内部的页偏移进行读取。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45645161290322583&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r72Inicu39bsNLNZOBZskaib9dAP5HACVCN33gAYnsiakzt0dF17GrfR3dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果进程持续的顺序访问一个文件，那么预读页数也会随着逐步增加。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当发现进程开始随机访问文件了（当前访问的文件页和最后一次访问的文件页 offset 不是连续的），内核就会逐步减少预读页数或者彻底禁止预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当内核发现进程再重复的访问同一文件页时或者文件中的文件页已经几乎全部缓存在 page cache 中了，内核此时就会禁止预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上几点就是内核的预读算法的核心逻辑，从这个预读逻辑中我们可以看出，进程在进行文件读取的时候涉及到两种不同类型的页面集合，一个是进程可以请求的文件页（已经缓存在 page cache 中的文件页），另一个是内核预读的文件页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而内核也确实按照这两种页面集合分为两个窗口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当前窗口（current window）:  表示进程本次文件请求可以直接读取的页面集合，这个集合中的页面全部已经缓存在 page cache 中，进程可以直接读取返回。当前窗口中包含进程本次请求的文件页以及上次内核预读的文件页集合。表示进程本次可以从 page cache 直接获取的页面范围。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;预读窗口（ahead window）：预读窗口的页面都是内核正在预读的文件页，它们此时并不在 page cache 中。这些页面并不是进程请求的文件页，但是内核根据空间局部性原理假定它们迟早会被进程请求。预读窗口内的页面紧跟着当前窗口后面，并且内核会动态调整预读窗口的大小（有点类似于 TCP 中的滑动窗口）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7FfQCamp5GTBAPQziaGiax0fNPuqvicvCUplYsiciaiaqWXvmvugumHq6Q6ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果进程本次文件请求的第一页的 offset，紧跟着上一次文件请求的最后一页的 offset，内核就认为是顺序读取。在顺序读取文件的场景下，如果请求的第一页在当前窗口内，内核随后就会检查是否建立了预读窗口，如果没有就会创建预读窗口并触发相应页的读取操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在理想情况下，进程会继续在当前窗口内请求页，于此同时，预读窗口内的预读页同时异步传送着，这样进程在顺序读取文件的时候就相当于直接读取内存，极大地提高了文件 IO 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上包含的这些文件预读信息，比如：如何判断进程是顺序读取还是随机读取，当前窗口信息，预读窗口信息。全部保存在 struct file 结构中的 f_ra 字段中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_ra_state&lt;/span&gt; &lt;span&gt;f_ra&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于描述文件预读信息的结构体在内核中用 struct file_ra_state 结构体来表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_ra_state&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;pgoff_t&lt;/span&gt; start; &lt;span&gt;// 当前窗口第一页的索引&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;  &lt;span&gt;// 当前窗口的页数，-1表示临时禁止预读&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; async_size; &lt;span&gt;// 异步预读页面的页数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ra_pages;  &lt;span&gt;// 文件允许的最大预读页数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;loff_t&lt;/span&gt; prev_pos;  &lt;span&gt;// 进程最后一次请求页的索引&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核可以根据 start 和 prev_pos 这两个字段来判断进程是否在顺序访问文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ra_pages 表示当前文件允许预读的最大页数，进程可以通过系统调用 posix_fadvise() 来改变已打开文件的 ra_page 值来调优预读算法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;posix_fadvise&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;off_t&lt;/span&gt; offset, &lt;span&gt;off_t&lt;/span&gt; len, &lt;span&gt;int&lt;/span&gt; advice)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该系统调用用来通知内核，我们将来打算以特定的模式 advice 访问文件数据，从而允许内核执行适当的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;advice 参数主要有下面几种数值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;POSIX_FADV_NORMAL ：设置文件最大预读页数 ra_pages 为默认值 32 页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;POSIX_FADV_SEQUENTIAL ：进程期望顺序访问指定的文件数据，ra_pages 值为默认值的两倍。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;POSIX_FADV_RANDOM ：进程期望以随机顺序访问指定的文件数据。ra_pages 设置为 0，表示禁止预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;后来人们发现当禁止预读后，这样一页一页的读取性能非常的低下，于是 linux 3.19.8 之后 POSIX_FADV_RANDOM 的语义被改变了，它会在 file-&amp;gt;f_flags 中设置 FMODE_RANDOM 属性（后面我们分析内核预读相关源码的时候还会提到），当遇到 FMODE_RANDOM 的时候内核就会走强制预读的逻辑，按最大 2MB 单元大小的 chunk 进行预读。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;This fixes inefficient page-by-page reads on POSIX_FADV_RANDOM.&lt;br/&gt;POSIX_FADV_RANDOM used to &lt;span&gt;set&lt;/span&gt; ra_pages=0, &lt;span&gt;which&lt;/span&gt; leads to poor&lt;br/&gt;performance: a 16K &lt;span&gt;read&lt;/span&gt; will be carried out &lt;span&gt;in&lt;/span&gt; 4 _sync_ 1-page reads.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;POSIX_FADV_WILLNEED ：通知内核，进程指定这段文件数据将在不久之后被访问。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而触发内核进行文件预读的场景，分为以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当进程采用 Buffered IO 模式通过系统调用 read 进行文件读取时，内核会触发预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过 POSIX_FADV_WILLNEED 参数执行系统调用 posix_fadvise，会通知内核这个指定范围的文件页不就将会被访问。触发预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当进程显示执行 readahead() 系统调用时，会显示触发内核的预读动作。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当内核为内存文件映射区域分配一个物理页面时，会触发预读。关于内存映射的相关内容，笔者会在后面的文章为大家详细介绍。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;和 posix_fadvise 一样的道理，系统调用 madvise 主要用来指定内存文件映射区域的访问模式。可通过 advice = MADV_WILLNEED 通知内核，某个文件内存映射区域中的指定范围的文件页在不久将会被访问。触发预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;madvise&lt;/span&gt;&lt;span&gt;(&lt;span&gt;caddr_t&lt;/span&gt; addr, &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;int&lt;/span&gt; advice)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从触发内核预读的这几种场景中我们可以看出，预读分为主动触发和被动触发，在《4.2 Buffered IO》小节中遗留的 page_cache_sync_readahead 函数为被动触发，接下来我们来看下它在内核中的实现逻辑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.1 page_cache_sync_readahead&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;page_cache_sync_readahead&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;          struct file_ra_state *ra, struct file *filp,&lt;br/&gt;          &lt;span&gt;pgoff_t&lt;/span&gt; offset, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; req_size)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 禁止预读，直接返回&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!ra-&amp;gt;ra_pages)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (blk_cgroup_congested())&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 通过 posix_fadvise 设置了 POSIX_FADV_RANDOM，内核走强制预读逻辑&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (filp &amp;amp;&amp;amp; (filp-&amp;gt;f_mode &amp;amp; FMODE_RANDOM)) {&lt;br/&gt;        &lt;span&gt;// 按最大2MB单元大小的chunk进行预读&lt;/span&gt;&lt;br/&gt;  force_page_cache_readahead(mapping, filp, offset, req_size);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 执行预读逻辑&lt;/span&gt;&lt;br/&gt; ondemand_readahead(mapping, ra, filp, &lt;span&gt;false&lt;/span&gt;, offset, req_size);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;!ra-&amp;gt;ra_pages&lt;/code&gt; 表示 ra_pages 设置为 0 ，预读被禁止，直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果进程通过前边介绍的 posix_fadvise 系统调用并且 advice 参数设置为 POSIX_FADV_RANDOM。在 linux 3.19.8 之后文件的  file-&amp;gt;f_flags 属性会被设置为 FMODE_RANDOM，这样内核会走强制预读逻辑，按最大 2MB 单元大小的 chunk 进行预读。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;posix_fadvise&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;off_t&lt;/span&gt; offset, &lt;span&gt;off_t&lt;/span&gt; len, &lt;span&gt;int&lt;/span&gt; advice)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// mm/fadvise.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (advice) {&lt;br/&gt;&lt;br/&gt;      .........省略........&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;case&lt;/span&gt; POSIX_FADV_RANDOM:&lt;br/&gt;              .........省略........&lt;br/&gt;        file-&amp;gt;f_flags |= FMODE_RANDOM;&lt;br/&gt;              .........省略........&lt;br/&gt;         &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;      .........省略........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而真正的预读逻辑封装在 ondemand_readahead 函数中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.2 ondemand_readahead&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法中封装了前边介绍的预读算法逻辑，动态的调整当前窗口以及预读窗口的大小。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt; * A minimal readahead algorithm for trivial sequential/random reads.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ondemand_readahead&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;     struct file_ra_state *ra, struct file *filp,&lt;br/&gt;     &lt;span&gt;bool&lt;/span&gt; hit_readahead_marker, &lt;span&gt;pgoff_t&lt;/span&gt; offset,&lt;br/&gt;     &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; req_size)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;backing_dev_info&lt;/span&gt; *&lt;span&gt;bdi&lt;/span&gt; = &lt;span&gt;inode_to_bdi&lt;/span&gt;(&lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; max_pages = ra-&amp;gt;ra_pages; &lt;span&gt;// 默认32页&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; add_pages;&lt;br/&gt; &lt;span&gt;pgoff_t&lt;/span&gt; prev_offset;&lt;br/&gt;&lt;br/&gt;    ........预读算法逻辑，动态调整当前窗口和预读窗口.........&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//根据条件，计算本次预读最大预读取多少个页，一般情况下是max_pages=32个页&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (req_size &amp;gt; max_pages &amp;amp;&amp;amp; bdi-&amp;gt;io_pages &amp;gt; max_pages)&lt;br/&gt;        max_pages = min(req_size, bdi-&amp;gt;io_pages);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//offset即page index，如果page index=0，表示这是文件第一个页，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//内核认为是顺序读，跳转到initial_readahead进行处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!offset)&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; initial_readahead;&lt;br/&gt;&lt;br/&gt;initial_readahead:&lt;br/&gt;    &lt;span&gt;// 当前窗口第一页的索引&lt;/span&gt;&lt;br/&gt;    ra-&amp;gt;start = offset;&lt;br/&gt;    &lt;span&gt;// get_init_ra_size初始化第一次预读的页的个数，一般情况下第一次预读是4个页 &lt;/span&gt;&lt;br/&gt;    ra-&amp;gt;size = get_init_ra_size(req_size, max_pages);&lt;br/&gt;    &lt;span&gt;// 异步预读页面个数也就是预读窗口大小&lt;/span&gt;&lt;br/&gt;    ra-&amp;gt;async_size = ra-&amp;gt;size &amp;gt; req_size ? ra-&amp;gt;size - req_size : ra-&amp;gt;size;&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;// 默认情况下是 ra-&amp;gt;start=0, ra-&amp;gt;size=0, ra-&amp;gt;async_size=0 ra-&amp;gt;prev_pos=0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 但是经过第一次预读后，上面三个值会出现变化&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((offset == (ra-&amp;gt;start + ra-&amp;gt;size - ra-&amp;gt;async_size) ||&lt;br/&gt;         offset == (ra-&amp;gt;start + ra-&amp;gt;size))) {&lt;br/&gt;        ra-&amp;gt;start += ra-&amp;gt;size;&lt;br/&gt;        ra-&amp;gt;size = get_next_ra_size(ra, max_pages);&lt;br/&gt;        ra-&amp;gt;async_size = ra-&amp;gt;size;&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; readit;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;//异步预读的时候会进入这个判断，更新ra的值，然后预读特定的范围的页&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//异步预读的调用表示Readahead出来的页连续命中  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (hit_readahead_marker) {&lt;br/&gt;        &lt;span&gt;pgoff_t&lt;/span&gt; start;&lt;br/&gt; &lt;br/&gt;        rcu_read_lock();&lt;br/&gt;        &lt;span&gt;// 这个函数用于找到offset + 1开始到offset + 1 + max_pages这个范围内，第一个不在page cache的页的index&lt;/span&gt;&lt;br/&gt;        start = page_cache_next_miss(mapping, offset + &lt;span&gt;1&lt;/span&gt;, max_pages);&lt;br/&gt;        rcu_read_unlock();&lt;br/&gt; &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!start || start - offset &amp;gt; max_pages)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;        ra-&amp;gt;start = start;&lt;br/&gt;        ra-&amp;gt;size = start - offset;    &lt;span&gt;/* old async_size */&lt;/span&gt;&lt;br/&gt;        ra-&amp;gt;size += req_size;&lt;br/&gt;         &lt;br/&gt;        &lt;span&gt;// 由于连续命中，get_next_ra_size会加倍上次的预读页数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 第一次预读了4个页&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 第二次命中以后，预读8个页&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 第三次命中以后，预读16个页&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 第四次命中以后，预读32个页，达到默认情况下最大的读取页数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 第五次、第六次、第N次命中都是预读32个页 &lt;/span&gt;&lt;br/&gt;        ra-&amp;gt;size = get_next_ra_size(ra, max_pages);&lt;br/&gt;        ra-&amp;gt;async_size = ra-&amp;gt;size;&lt;br/&gt;        &lt;span&gt;goto&lt;/span&gt; readit;&lt;br/&gt;&lt;br/&gt;       ........ 省略.........&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; __do_page_cache_readahead(mapping, filp, offset, req_size, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct address_space *mapping&lt;/code&gt; :  读取文件对应的 page cache 结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct file_ra_state *ra&lt;/code&gt; : 文件对应的预读状态信息，封装在 file-&amp;gt;f_ra 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;struct file *filp&lt;/code&gt; : 读取文件对应的 struct file 结构。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;pgoff_t offset &lt;/code&gt; : 本次请求文件页在 page cache 中的索引。（文件页偏移）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;long req_size &lt;/code&gt; : 要完成当前读操作还需要读取的页数。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在预读算法逻辑中，内核通过 struct file_ra_state 结构中封装的文件预读信息来判断文件的读取是否为顺序读。比如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过检查 ra-&amp;gt;prev_pos 和 offset 是否相同，来判断当前请求页是否和最近一次请求的页相同，如果重复访问同一页，预读就会停止。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过检查 ra-&amp;gt;prev_pos 和 offset 是否相邻，来判断进程是否顺序读取文件。如果是顺序访问文件，预读就会增加。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当进程第一次访问文件时，并且请求的第一个文件页在文件中的偏移量为 0 时表示进程从头开始读取文件，那么内核就会认为进程想要顺序的访问文件，随后内核就会从文件的第一页开始创建一个新的当前窗口，初始的当前窗口总是 2 的次幂，窗口具体大小与进程的读操作所请求的页数有一定的关系。请求页数越大，当前窗口就越大，直到最大值 ra-&amp;gt;ra_pages 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;get_init_ra_size&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; size, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; max)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; newsize = roundup_pow_of_two(size);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (newsize &amp;lt;= max / &lt;span&gt;32&lt;/span&gt;)&lt;br/&gt;  newsize = newsize * &lt;span&gt;4&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (newsize &amp;lt;= max / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;  newsize = newsize * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  newsize = max;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; newsize;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;相反，当进程第一次访问文件，但是请求页在文件中的偏移量不为 0 时，内核就会假定进程不准备顺序读取文件，函数就会暂时禁止预读。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一旦内核发现进程在当前窗口内执行了顺序读取，那么预读窗口就会被建立，预读窗口总是紧挨着当前窗口的最后一页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;预读窗口的大小和当前窗口有关，如果已经被预读的页不在 page cache 中（可能内存紧张，预读页被回收），那么预读窗口就会是 &lt;code&gt;当前窗口大小 - 2&lt;/code&gt;，最小值为 4。否则预读窗口就会是当前窗口的4倍或者2倍。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当进程继续顺序访问文件时，最终预读窗口就会变为当前窗口，随后新的预读窗口就会被建立，随着进程顺序地读取文件，预读会越来越大，但是内核一旦发现对于文件的访问 offset 相对于上一次的请求页 ra-&amp;gt;prev_pos 不是顺序的时候，当前窗口和预读窗口就会被清空，预读被暂时禁止。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当内核通过以上介绍的预读算法确定了预读窗口的大小之后，就开始调用 __do_page_cache_readahead 从磁盘去预读指定的页数到 page cache 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.3 __do_page_cache_readahead&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __do_page_cache_readahead(struct address_space *mapping,&lt;br/&gt;  struct file *filp, &lt;span&gt;pgoff_t&lt;/span&gt; offset, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; nr_to_read,&lt;br/&gt;  &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; lookahead_size)&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; end_index; &lt;span&gt;/* The last page we want to read */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; page_idx;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; nr_pages = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;loff_t&lt;/span&gt; isize = i_size_read(inode);&lt;br/&gt; end_index = ((isize - &lt;span&gt;1&lt;/span&gt;) &amp;gt;&amp;gt; PAGE_SHIFT);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;/*&lt;br/&gt;  * 尽可能的一次性分配全部需要预读的页 nr_to_read&lt;br/&gt;     * 注意这里是尽可能的分配，意思就是能分配多少就分配多少，并不一定要全部分配&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (page_idx = &lt;span&gt;0&lt;/span&gt;; page_idx &amp;lt; nr_to_read; page_idx++) {&lt;br/&gt;  &lt;span&gt;pgoff_t&lt;/span&gt; page_offset = offset + page_idx;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (page_offset &amp;gt; end_index)&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        .......省略.....&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 首先在内存中为预读数据分配物理页面&lt;/span&gt;&lt;br/&gt;  page = __page_cache_alloc(gfp_mask);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!page)&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 设置新分配的物理页在 page cache 中的索引&lt;/span&gt;&lt;br/&gt;  page-&amp;gt;index = page_offset;&lt;br/&gt;        &lt;span&gt;// 将新分配的物理页面加入到 page cache 中&lt;/span&gt;&lt;br/&gt;  list_add(&amp;amp;page-&amp;gt;lru, &amp;amp;page_pool);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (page_idx == nr_to_read - lookahead_size)&lt;br/&gt;            &lt;span&gt;// 设置页面属性为 PG_readahead 后续会开启异步预读&lt;/span&gt;&lt;br/&gt;   SetPageReadahead(page);&lt;br/&gt;  nr_pages++;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;/*&lt;br/&gt;  * 当需要预读的页面分配完毕之后，开始真正的 IO 动作，从磁盘中读取&lt;br/&gt;     * 数据填充 page cache 中的缓存页。&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (nr_pages)&lt;br/&gt;  read_pages(mapping, filp, &amp;amp;page_pool, nr_pages, gfp_mask);&lt;br/&gt; BUG_ON(!list_empty(&amp;amp;page_pool));&lt;br/&gt;out:&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nr_pages;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核调用 read_pages 方法激活磁盘块设备驱动程序从磁盘中读取文件数据之前，需要为本次进程读取请求所需要的所有页面尽可能地一次性全部分配，如果不能一次性分配全部页面，预读操作就只在分配好的缓存页面上进行，也就是说只从磁盘中读取数据填充已经分配好的页面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. JDK NIO 对普通文件的写入&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：下面的例子并不是最佳实践，之所以这里引入 HeapByteBuffer 是为了将上篇文章的内容和本文衔接起来。事实上，对于 IO 的操作一般都会选择 DirectByteBuffer ，关于 DirectByteBuffer 的相关内容笔者会在后面的文章中详细为大家介绍。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        FileChannel fileChannel = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;file-read-write.txt&quot;&lt;/span&gt;), &lt;span&gt;&quot;rw&quot;&lt;/span&gt;).getChannel();&lt;br/&gt;        ByteBuffer  heapByteBuffer = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;        fileChannel.write(heapByteBuffer);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对文件进行读写之前，我们需要首先利用 RandomAccessFile 在内核中打开指定的文件 file-read-write.txt ，并获取到它的文件描述符 fd = 5000。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6879032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7PWsD02gNXA3herRiagkqIVxPe8BLsOrIQXUFmEKVJNmnIAkENZSwwZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本例 heapByteBuffer 中存放着需要写入文件的内容，随后来到 FileChannelImpl 实现类调用 IOUtil 触发底层系统调用 write 来写入文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileChannelImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FileChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 前边介绍打开的文件描述符 5000&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileDescriptor fd;&lt;br/&gt;  &lt;span&gt;// NIO中用它来触发 native read 和 write 的系统调用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; FileDispatcher nd;&lt;br/&gt;  &lt;span&gt;// 读写文件时加锁，前边介绍 FileChannel 的读写方法均是线程安全的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object positionLock = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(ByteBuffer src)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        ensureOpen();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!writable)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NonWritableChannelException();&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (positionLock) {&lt;br/&gt;            &lt;span&gt;//写入的字节数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ......省略......&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!isOpen())&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                    n = IOUtil.write(fd, src, -&lt;span&gt;1&lt;/span&gt;, nd);&lt;br/&gt;                } &lt;span&gt;while&lt;/span&gt; ((n == IOStatus.INTERRUPTED) &amp;amp;&amp;amp; isOpen());&lt;br/&gt;                &lt;span&gt;// 返回写入的字节数&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; IOStatus.normalize(n);&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                  ......省略......&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO 中的所有 IO 操作全部封装在 IOUtil 类中，而 NIO 中的 SocketChannel 以及这里介绍的 FileChannel 底层依赖的系统调用可能不同，这里会通过 NativeDispatcher 对具体 Channel 操作实现分发，调用具体的系统调用。对于 FileChannel 来说 NativeDispatcher 的实现类为 FileDispatcher。对于 SocketChannel 来说 NativeDispatcher 的实现类为 SocketDispatcher。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IOUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, ByteBuffer src, &lt;span&gt;long&lt;/span&gt; position,&lt;br/&gt;                     NativeDispatcher nd)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 标记传递进来的 heapByteBuffer 的 position 位置用于后续恢复&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; pos = src.position();&lt;br/&gt;        &lt;span&gt;// 获取 heapByteBuffer 的 limit 用于计算 写入字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lim = src.limit();&lt;br/&gt;        &lt;span&gt;assert&lt;/span&gt; (pos &amp;lt;= lim);&lt;br/&gt;        &lt;span&gt;// 写入的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rem = (pos &amp;lt;= lim ? lim - pos : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 创建临时的 DirectByteBuffer，用于通过系统调用 write 写入数据到内核&lt;/span&gt;&lt;br/&gt;        ByteBuffer bb = Util.getTemporaryDirectBuffer(rem);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 将 heapByteBuffer 中的内容拷贝到临时 DirectByteBuffer 中&lt;/span&gt;&lt;br/&gt;            bb.put(src);&lt;br/&gt;            &lt;span&gt;// DirectByteBuffer 切换为读模式，用于后续发送数据&lt;/span&gt;&lt;br/&gt;            bb.flip();&lt;br/&gt;            &lt;span&gt;// 恢复 heapByteBuffer 中的 position&lt;/span&gt;&lt;br/&gt;            src.position(pos);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; n = writeFromNativeBuffer(fd, bb, position, nd);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 此时 heapByteBuffer 中的内容已经发送完毕，更新它的 postion + n &lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 这里表达的语义是从 heapByteBuffer 中读取了 n 个字节并发送成功&lt;/span&gt;&lt;br/&gt;                src.position(pos + n);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 返回发送成功的字节数&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; n;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 释放临时创建的 DirectByteBuffer&lt;/span&gt;&lt;br/&gt;            Util.offerFirstTemporaryDirectBuffer(bb);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;writeFromNativeBuffer&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, ByteBuffer bb,&lt;br/&gt;                                             &lt;span&gt;long&lt;/span&gt; position, NativeDispatcher nd)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;br/&gt;    &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; pos = bb.position();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; lim = bb.limit();&lt;br/&gt;        &lt;span&gt;assert&lt;/span&gt; (pos &amp;lt;= lim);&lt;br/&gt;        &lt;span&gt;// 要发送的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rem = (pos &amp;lt;= lim ? lim - pos : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; written = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (rem == &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (position != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;             ........省略.......&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            written = nd.write(fd, ((DirectBuffer)bb).address() + pos, rem);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (written &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;// 发送完毕之后更新 DirectByteBuffer 的position&lt;/span&gt;&lt;br/&gt;            bb.position(pos + written);&lt;br/&gt;        &lt;span&gt;// 返回写入的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; written;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 IOUtil 中首先创建一个临时的 DirectByteBuffer，然后将本例中 HeapByteBuffer 中的数据全部拷贝到这个临时的 DirectByteBuffer 中。这个 DirectByteBuffer 就是我们在 IO 系统调用中经常提到的用户空间缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后在 writeFromNativeBuffer 方法中通过  FileDispatcher 触发 JNI 层的
native 方法执行底层系统调用 write 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileDispatcherImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;FileDispatcher&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, &lt;span&gt;long&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; write0(fd, address, len);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;write0&lt;/span&gt;&lt;span&gt;(FileDescriptor fd, &lt;span&gt;long&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;throws&lt;/span&gt; IOException&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO 中关于文件 IO 相关的系统调用全部封装在 JNI 层中的 FileDispatcherImpl.c 文件中。里边定义了各种 IO 相关的系统调用的 native 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// FileDispatcherImpl.c 文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT jint JNICALL&lt;br/&gt;&lt;span&gt;Java_sun_nio_ch_FileDispatcherImpl_write0&lt;/span&gt;&lt;span&gt;(JNIEnv *env, jclass clazz,&lt;br/&gt;                              jobject fdo, jlong address, jint len)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    jint fd = fdval(env, fdo);&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; *buf = (&lt;span&gt;void&lt;/span&gt; *)jlong_to_ptr(address);&lt;br/&gt;    &lt;span&gt;// 发起 write 系统调用进入内核&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; convertReturnVal(env, write(fd, buf, len), JNI_FALSE);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统调用 write 在内核中的定义如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SYSCALL_DEFINE3(write, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, fd, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *, buf,&lt;br/&gt;    &lt;span&gt;size_t&lt;/span&gt;, count)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt; &lt;span&gt;f&lt;/span&gt; = &lt;span&gt;fdget_pos&lt;/span&gt;(&lt;span&gt;fd&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;         ......&lt;br/&gt;  &lt;span&gt;loff_t&lt;/span&gt; pos = file_pos_read(f.file);&lt;br/&gt;  ret = vfs_write(f.file, buf, count, &amp;amp;pos);&lt;br/&gt;         ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们就从用户空间的 JDK NIO 这一层逐步来到了内核空间的边界处 --- OS 系统调用 write 这里，马上就要进入内核了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6370967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7IMHUSQEaDic3ernMUxT5GibAxNzNoWqMeEJJpj9u1sl3KB6f5ibgfCJUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次我们来看一下当系统调用 write 发起之后，用户进程在内核态具体做了哪些事情？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. 从内核角度探秘文件写入本质&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在让我们再次进入内核，来看一下内核中具体是如何处理文件写入操作的，这个过程会比文件读取要复杂很多，大家需要有点耐心~~&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;再次强调一下，本文所举示例中用到的 HeapByteBuffer 只是为了与上篇文章 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247485497&amp;amp;idx=1&amp;amp;sn=eb4afe6764b2b976fb80f6dc5c6fd68a&amp;amp;chksm=ce77ce7ef900476865864e09bb6f0688ca784afc396084ecc90a894bfd733692049c332edd11&amp;amp;token=927203489&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《一步一图带你深入剖析 JDK NIO ByteBuffer 在不同字节序下的设计与实现》&lt;/a&gt;介绍的内容做出呼应，并不是最佳实践。笔者会在后续的文章中一步一步为大家展开这块内容的最佳实践。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.1 Buffered IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7nllT7WfiaZTA8kXVowS40XwMwmPzzst4uFc569ib9ibkX92O9UJkv1KlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 JDK NIO 中的 HeapByteBuffer 在对文件进行写入的过程，主要分为如下几个核心步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先会在用户空间的 JDK 层将位于 JVM 堆中的 HeapByteBuffer 中的待写入数据拷贝到位于 OS 堆中的 DirectByteBuffer 中。&lt;strong&gt;这里发生第一次拷贝&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后 NIO 会在用户态通过系统调用 write 发起文件写入的请求，&lt;strong&gt;此时发生第一次上下文切换&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;随后用户进程进入内核态，在虚拟文件系统层调用 vfs_write 触发对 page cache 写入的操作。相关操作封装在 generic_perform_write 函数中。这个后面笔者会细讲，这里我们只关注核心总体流程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核调用 iov_iter_copy_from_user_atomic 函数将用户空间缓冲区 DirectByteBuffer 中的待写入数据拷贝到 page cache 中。&lt;strong&gt;发生第二次拷贝动作&lt;/strong&gt;，这里的操作就是我们常说的 CPU 拷贝。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当待写入数据拷贝到 page cache 中时，内核会将对应的文件页标记为脏页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;脏页表示内存中的数据要比磁盘中对应文件数据要新。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;此时内核会根据一定的阈值判断是否要对 page cache 中的脏页进行回写，如果不需要同步回写，进程直接返回。文件写入操作完成。&lt;strong&gt;这里发生第二次上下文切换&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从这里我们看到在对文件进行写入时，内核只会将数据写入到 page cache 中。整个写入过程就完成了，并不会写到磁盘中。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;脏页回写又会根据脏页数量在内存中的占比分为：进程同步回写和内核异步回写。当脏页太多了，进程自己都看不下去的时候，会同步回写内存中的脏页，直到回写完毕才会返回。在回写的过程中会发生&lt;strong&gt;第三次拷贝&lt;/strong&gt;，通过DMA 将 page cache 中的脏页写入到磁盘中。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所谓内核异步回写就是内核会定时唤醒一个 flusher 线程，定时将内存中的脏页回写到磁盘中。这部分的内容笔者会在后续的章节中详细讲解。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 NIO 使用 HeapByteBuffer 在对文件进行写入的过程中，一般只会发生两次拷贝动作和两次上下文切换，因为内核将数据拷贝到 page cache 中后，文件写入过程就结束了。如果脏页在内存中的占比太高了，达到了进程同步回写的阈值，那么就会发生第三次 DMA 拷贝，将脏页数据回写到磁盘文件中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果进程需要同步回写脏页数据时，在本例中是要发生三次拷贝动作。但一般情况下，在本例中只会发生两次，没有第三次的 DMA 拷贝。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.2 Direct IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 JDK 10 中我们可以通过如下的方式采用 Direct IO 模式打开文件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;FileChannel fc = FileChannel.open(p, StandardOpenOption.WRITE,&lt;br/&gt;             ExtendedOpenOption.DIRECT)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r75wQLc6PV6baBibqgTNgB8zib9TCibtiaP6bJBXOKeDKX3yZxVkSk73jTmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Direct IO 模式下的文件写入操作最明显的特点就是绕过 page cache 直接通过 DMA 拷贝将用户空间缓冲区 DirectByteBuffer 中的待写入数据写入到磁盘中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;同样发生两次上下文切换、&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在本例中只会发生&lt;strong&gt;两次数据拷贝&lt;/strong&gt;，第一次是将 JVM 堆中的 HeapByteBuffer 中的待写入数据拷贝到位于 OS 堆中的 DirectByteBuffer 中。第二次则是 DMA 拷贝，将用户空间缓冲区 DirectByteBuffer 中的待写入数据写入到磁盘中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12. Talk is cheap ! show you the code&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是系统调用 write 在内核中的完整定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SYSCALL_DEFINE3(write, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, fd, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *, buf,&lt;br/&gt;    &lt;span&gt;size_t&lt;/span&gt;, count)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;// 根据文件描述符获取文件对应的 struct file 结构&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;fd&lt;/span&gt; &lt;span&gt;f&lt;/span&gt; = &lt;span&gt;fdget_pos&lt;/span&gt;(&lt;span&gt;fd&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;         ......&lt;br/&gt;  &lt;span&gt;// 获取当前文件的写入位置 offset&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;loff_t&lt;/span&gt; pos = file_pos_read(f.file);&lt;br/&gt;  &lt;span&gt;// 进入虚拟文件系统层，执行具体的文件写入操作&lt;/span&gt;&lt;br/&gt;  ret = vfs_write(f.file, buf, count, &amp;amp;pos);&lt;br/&gt;         ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里和文件读取的流程基本一样，也是通过 vfs_write 进入虚拟文件系统层。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;ssize_t&lt;/span&gt; __vfs_write(struct file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *p, &lt;span&gt;size_t&lt;/span&gt; count,&lt;br/&gt;        &lt;span&gt;loff_t&lt;/span&gt; *pos)&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;write)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; file-&amp;gt;f_op-&amp;gt;write(file, p, count, pos);&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (file-&amp;gt;f_op-&amp;gt;write_iter)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; new_sync_write(file, p, count, pos);&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; -EINVAL;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在虚拟文件系统层，通过 struct file 中定义的函数指针 file_operations 在具体的文件系统中执行相应的文件 IO 操作。我们还是以 ext4 文件系统为例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt;  *&lt;span&gt;f_op&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ext4 文件系统中 .write_iter 函数指针指向的是 ext4_file_write_iter 函数执行具体的文件写入操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file_operations&lt;/span&gt; &lt;span&gt;ext4_file_operations&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      ......省略........&lt;br/&gt;&lt;br/&gt;      .read_iter  = ext4_file_read_iter,&lt;br/&gt;      .write_iter  = ext4_file_write_iter,&lt;br/&gt;&lt;br/&gt;      ......省略.........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7BqG2l6qbY098iarJ7FeYYHZlHicovvicEtjickGn7feTBP3PqMicTYvb1zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 ext4_file_operations 中只定义了 .write_iter 函数指针，所以在 __vfs_write 函数中流程进入 else if {......} 分支来到 new_sync_write 函数中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;new_sync_write&lt;/span&gt;&lt;span&gt;(struct file *filp, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, &lt;span&gt;size_t&lt;/span&gt; len, &lt;span&gt;loff_t&lt;/span&gt; *ppos)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 将 DirectByteBuffer 以及要写入的字节数封装进 iovec 结构体中&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iovec&lt;/span&gt; &lt;span&gt;iov&lt;/span&gt; = {&lt;/span&gt; .iov_base = (&lt;span&gt;void&lt;/span&gt; __user *)buf, .iov_len = len };&lt;br/&gt;    &lt;span&gt;// 用来封装文件 IO 相关操作的状态和进度信息：&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;kiocb&lt;/span&gt; &lt;span&gt;kiocb&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 用来封装用用户缓存区 DirectByteBuffer 的相关的信息&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iov_iter&lt;/span&gt; &lt;span&gt;iter&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt; ret;&lt;br/&gt;    &lt;span&gt;// 利用文件 struct file 初始化 kiocb 结构体&lt;/span&gt;&lt;br/&gt; init_sync_kiocb(&amp;amp;kiocb, filp);&lt;br/&gt;    &lt;span&gt;// 设置文件写入偏移位置&lt;/span&gt;&lt;br/&gt; kiocb.ki_pos = (ppos ? *ppos : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt; iov_iter_init(&amp;amp;iter, WRITE, &amp;amp;iov, &lt;span&gt;1&lt;/span&gt;, len);&lt;br/&gt;    &lt;span&gt;// 调用 ext4_file_write_iter&lt;/span&gt;&lt;br/&gt; ret = call_write_iter(filp, &amp;amp;kiocb, &amp;amp;iter);&lt;br/&gt; BUG_ON(ret == -EIOCBQUEUED);&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ret &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; ppos)&lt;br/&gt;  *ppos = kiocb.ki_pos;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在文件读取的相关章节中，我们介绍了用于封装传递进来的用户空间缓冲区 DirectByteBuffer 相关信息的 struct iovec 结构体，也介绍了用于封装文件 IO 相关操作的状态和进度信息的 struct kiocb 结构体，这里笔者不在赘述。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过在这里笔者还是想强调的一下，内核中一般会使用 struct iov_iter 结构体对 struct iovec 进行包装，iov_iter 中包含多个 iovec。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iov_iter&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;        ......省略.....&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iovec&lt;/span&gt; *&lt;span&gt;iov&lt;/span&gt;;&lt;/span&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为了兼容 readv() ，writev() 等系统调用，它允许用户使用多个缓存区去读取文件中的数据或者从多个缓冲区中写入数据到文件中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK NIO Channel 支持的 Scatter 操作底层原理就是 readv 系统调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JDK NIO Channel 支持的 Gather 操作底层原理就是 writev 系统调用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;       FileChannel fileChannel = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(&lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;file-read-write.txt&quot;&lt;/span&gt;), &lt;span&gt;&quot;rw&quot;&lt;/span&gt;).getChannel();&lt;br/&gt;&lt;br/&gt;       ByteBuffer  heapByteBuffer1 = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;       ByteBuffer  heapByteBuffer2 = ByteBuffer.allocate(&lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;       ByteBuffer[] gather = { heapByteBuffer1, heapByteBuffer2 };&lt;br/&gt;&lt;br/&gt;       fileChannel.write(gather);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终在  call_write_iter 中触发 ext4_file_write_iter 的调用，从虚拟文件系统层进入到具体文件系统 ext4 中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;call_write_iter&lt;/span&gt;&lt;span&gt;(struct file *file, struct kiocb *kio,&lt;br/&gt;          struct iov_iter *iter)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; file-&amp;gt;f_op-&amp;gt;write_iter(kio, iter);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ssize_t&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ext4_file_write_iter&lt;/span&gt;&lt;span&gt;(struct kiocb *iocb, struct iov_iter *from)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ..........省略..........&lt;br/&gt; ret = __generic_file_write_iter(iocb, from);&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在文件系统 ext4 中调用的是 __generic_file_write_iter 方法。内核针对文件写入的所有逻辑都封装在这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;ssize_t&lt;/span&gt; __generic_file_write_iter(struct kiocb *iocb, struct iov_iter *from)&lt;br/&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;file&lt;/span&gt; *&lt;span&gt;file&lt;/span&gt; = &lt;span&gt;iocb&lt;/span&gt;-&amp;gt;&lt;span&gt;ki_filp&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; * &lt;span&gt;mapping&lt;/span&gt; = &lt;span&gt;file&lt;/span&gt;-&amp;gt;&lt;span&gt;f_mapping&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt;  *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt;  written = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt;  err;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt;  status;&lt;br/&gt;&lt;br/&gt;        ........省略基本校验逻辑和更新文件原数据逻辑........&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (iocb-&amp;gt;ki_flags &amp;amp; IOCB_DIRECT) {&lt;br/&gt;  &lt;span&gt;loff_t&lt;/span&gt; pos, endbyte;&lt;br/&gt;        &lt;span&gt;// Direct IO&lt;/span&gt;&lt;br/&gt;  written = generic_file_direct_write(iocb, from);&lt;br/&gt;         .......省略......&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// Buffered IO&lt;/span&gt;&lt;br/&gt;  written = generic_perform_write(file, from, iocb-&amp;gt;ki_pos);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (likely(written &amp;gt; &lt;span&gt;0&lt;/span&gt;))&lt;br/&gt;   iocb-&amp;gt;ki_pos += written;&lt;br/&gt; }&lt;br/&gt;           .......省略......&lt;br/&gt;    &lt;span&gt;// 返回写入文件的字节数 或者 错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; written ? written : err;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里和我们在介绍文件读取时候提到的 generic_file_read_iter 函数中的逻辑是一样的。都会处理 Direct IO 和 Buffered IO 的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对于 Direct IO 的处理都是一样的，在 generic_file_direct_write 中也是会调用 address_space 中的 address_space_operations 定义的 .direct_IO 函数指针来绕过 page cache 直接写入磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; *&lt;span&gt;a_ops&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;written = mapping-&amp;gt;a_ops-&amp;gt;direct_IO(iocb, from);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7169354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r75wQLc6PV6baBibqgTNgB8zib9TCibtiaP6bJBXOKeDKX3yZxVkSk73jTmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ext4 文件系统中实现 Direct IO 的函数是 ext4_direct_IO，这里直接会调用到块设备驱动层，通过 do_blockdev_direct_IO 直接将用户空间缓冲区 DirectByteBuffer 中的内容写入磁盘中。&lt;strong&gt;do_blockdev_direct_IO 函数会等到所有的 Direct IO 写入到磁盘之后才会返回&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; &lt;span&gt;ext4_aops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;  .direct_IO  = ext4_direct_IO,&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Direct IO 是由 DMA  直接从用户空间缓冲区 DirectByteBuffer 中拷贝到磁盘中。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们主要介绍下 Buffered IO 的写入逻辑 generic_perform_write 方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.1 Buffered IO&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2209677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7nllT7WfiaZTA8kXVowS40XwMwmPzzst4uFc569ib9ibkX92O9UJkv1KlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;ssize_t&lt;/span&gt; &lt;span&gt;generic_perform_write&lt;/span&gt;&lt;span&gt;(struct file *file,&lt;br/&gt;    struct iov_iter *i, &lt;span&gt;loff_t&lt;/span&gt; pos)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 获取 page cache。数据将会被写入到这里&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space&lt;/span&gt; *&lt;span&gt;mapping&lt;/span&gt; = &lt;span&gt;file&lt;/span&gt;-&amp;gt;&lt;span&gt;f_mapping&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 获取 page cache 相关的操作函数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; *&lt;span&gt;a_ops&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;a_ops&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;long&lt;/span&gt; status = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;ssize_t&lt;/span&gt; written = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; flags = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 用于引用要写入的文件页&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 要写入的文件页在 page cache 中的 index&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset; &lt;span&gt;/* Offset into pagecache page */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; bytes; &lt;span&gt;/* Bytes to write to page */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; copied;  &lt;span&gt;/* Bytes copied from user */&lt;/span&gt;&lt;br/&gt; &lt;br/&gt;  offset = (pos &amp;amp; (PAGE_SIZE - &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;  bytes = &lt;span&gt;min_t&lt;/span&gt;(&lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;, PAGE_SIZE - offset,&lt;br/&gt;      iov_iter_count(i));&lt;br/&gt;&lt;br/&gt;again:&lt;br/&gt;        &lt;span&gt;// 检查用户空间缓冲区 DirectByteBuffer 地址是否有效&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (unlikely(iov_iter_fault_in_readable(i, bytes))) {&lt;br/&gt;   status = -EFAULT;&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;        &lt;span&gt;// 从 page cache 中获取要写入的文件页并准备记录文件元数据日志工作&lt;/span&gt;&lt;br/&gt;  status = a_ops-&amp;gt;write_begin(file, mapping, pos, bytes, flags,&lt;br/&gt;      &amp;amp;page, &amp;amp;fsdata);&lt;br/&gt;        &lt;span&gt;// 将用户空间缓冲区 DirectByteBuffer 中的数据拷贝到 page cache 中的文件页中&lt;/span&gt;&lt;br/&gt;  copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes);&lt;br/&gt;  flush_dcache_page(page);&lt;br/&gt;       &lt;span&gt;// 将写入的文件页标记为脏页并完成文件元数据日志的写入&lt;/span&gt;&lt;br/&gt;  status = a_ops-&amp;gt;write_end(file, mapping, pos, bytes, copied,&lt;br/&gt;      page, fsdata);&lt;br/&gt;        &lt;span&gt;// 更新文件 ppos&lt;/span&gt;&lt;br/&gt;  pos += copied;&lt;br/&gt;  written += copied;&lt;br/&gt;        &lt;span&gt;// 判断是否需要回写脏页&lt;/span&gt;&lt;br/&gt;  balance_dirty_pages_ratelimited(mapping);&lt;br/&gt; } &lt;span&gt;while&lt;/span&gt; (iov_iter_count(i));&lt;br/&gt;    &lt;span&gt;// 返回写入字节数&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; written ? written : status;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于本文中笔者是以 ext4 文件系统为例来介绍文件的读写流程，本小节中介绍的文件写入流程涉及到与文件系统相关的两个操作：write_begin，write_end。这两个函数在不同的文件系统中都有不同的实现，在不同的文件系统中，写入每一个文件页都需要调用一次 write_begin，write_end 这两个方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;address_space_operations&lt;/span&gt; &lt;span&gt;ext4_aops&lt;/span&gt; = {&lt;/span&gt;&lt;br/&gt;          ......省略.......&lt;br/&gt;  .write_begin    = ext4_write_begin,&lt;br/&gt;  .write_end    = ext4_write_end,&lt;br/&gt;         ......省略.......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为本文中涉及文件读写的所有内核数据结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6548387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7WtQZlU1v1yWqvYwRAiajNGT4WTIRgDdZjXT8z4To7ANh7wJKcf7V7Mg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边介绍文件读取的章节我们知道在读取文件的时候都是先从 page cache 中读取，如果 page cache 正好缓存了文件页就直接返回。如果没有在进行磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件的写入过程也是一样，内核会将用户缓冲区 DirectByteBuffer 中的待写数据先拷贝到 page cache 中，写完就直接返回。后续内核会根据一定的规则把这些文件页回写到磁盘中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个过程我们可以看出，内核将数据先是写入 page cache 中但是不会立刻写入磁盘中，如果突然断电或者系统崩溃就可能导致文件系统处于不一致的状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这种场景，于是 linux 内核引入了 ext3 , ext4 等日志文件系统。而日志文件系统比非日志文件系统在磁盘中多了一块 Journal 区域，Journal 区域就是存放管理文件元数据和文件数据操作日志的磁盘区域。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文件元数据的日志用于恢复文件系统的一致性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;文件数据的日志用于防止系统故障造成的文件内容损坏，&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ext3 , ext4 等日志文件系统分为三种模式，我们可以在挂载的时候选择不同的模式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;日志模式（Journal 模式）：这种模式在将数据写入文件系统前，必须等待元数据和数据的日志已经落盘才能发挥作用。这样性能比较差，但是最安全。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;顺序模式（Order 模式）：在 Order 模式不会记录数据的日志，只会记录元数据的日志，但是在写元数据的日志前，必须先确保数据已经落盘。这样可以减少文件内容损坏的机会，这种模式是对性能的一种折中，是默认模式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;回写模式（WriteBack 模式）：WriteBack 模式 和 Order 模式一样它们都不会记录数据的日志，只会记录元数据的日志，不同的是在 WriteBack 模式下不会保证数据比元数据先落盘。这个性能最好，但是最不安全。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 write_begin，write_end 正是对文件系统中相关日志的操作，在 ext4 文件系统中对应的是 ext4_write_begin，ext4_write_end。下面我们就来看一下在 Buffered IO 模式下对于 ext4 文件系统中的文件写入的核心步骤。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.2 ext4_write_begin&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ext4_write_begin&lt;/span&gt;&lt;span&gt;(struct file *file, struct address_space *mapping,&lt;br/&gt;       &lt;span&gt;loff_t&lt;/span&gt; pos, &lt;span&gt;unsigned&lt;/span&gt; len, &lt;span&gt;unsigned&lt;/span&gt; flags,&lt;br/&gt;       struct page **pagep, &lt;span&gt;void&lt;/span&gt; **fsdata)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;pgoff_t&lt;/span&gt; index;&lt;br/&gt;&lt;br/&gt;        ...........省略.......&lt;br/&gt;&lt;br/&gt;retry_grab:&lt;br/&gt;    &lt;span&gt;// 从 page cache 中查找要写入文件页&lt;/span&gt;&lt;br/&gt; page = grab_cache_page_write_begin(mapping, index, flags);&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!page)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; -ENOMEM;&lt;br/&gt; unlock_page(page);&lt;br/&gt;&lt;br/&gt;retry_journal:&lt;br/&gt;    &lt;span&gt;// 相关日志的准备工作&lt;/span&gt;&lt;br/&gt; handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);&lt;br/&gt;&lt;br/&gt;         ...........省略.......&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在写入文件数据之前，内核在 ext4_write_begin 方法中调用 ext4_journal_start 方法做一些相关日志的准备工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个重要的事情是在 grab_cache_page_write_begin 方法中从 page cache 中根据 index 查找要写入数据的文件缓存页。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;struct page *&lt;span&gt;grab_cache_page_write_begin&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;          &lt;span&gt;pgoff_t&lt;/span&gt; index, &lt;span&gt;unsigned&lt;/span&gt; flags)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;page&lt;/span&gt; *&lt;span&gt;page&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; fgp_flags = FGP_LOCK|FGP_WRITE|FGP_CREAT;&lt;br/&gt;  &lt;span&gt;// 在 page cache 中查找写入数据的缓存页&lt;/span&gt;&lt;br/&gt;  page = pagecache_get_page(mapping, index, fgp_flags,&lt;br/&gt;      mapping_gfp_mask(mapping));&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (page)&lt;br/&gt;    wait_for_stable_page(page);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; page;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 pagecache_get_page 在 page cache 中查找要写入数据的缓存页。&lt;strong&gt;如果缓存页不在 page cache 中&lt;/strong&gt;，内核则会首先会在物理内存中分配一个内存页，然后将新分配的内存页加入到 page cache 中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;相关的查找过程笔者已经在 《8. page cache 中查找缓存页》小节中详细介绍过了，这里不在赘述。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.3 iov_iter_copy_from_user_atomic&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就是写入过程的关键所在，图中描述的 CPU 拷贝是将用户空间缓存区 DirectByteBuffer 中的待写入数据拷贝到内核里的 page cache 中，这个过程就发生在这里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;size_t&lt;/span&gt; &lt;span&gt;iov_iter_copy_from_user_atomic&lt;/span&gt;&lt;span&gt;(struct page *page,&lt;br/&gt;    struct iov_iter *i, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;size_t&lt;/span&gt; bytes)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// 将缓存页临时映射到内核虚拟地址空间的高端地址上&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *kaddr = kmap_atomic(page), &lt;br/&gt;  *p = kaddr + offset;&lt;br/&gt;  &lt;span&gt;// 将用户缓存区 DirectByteBuffer 中的待写入数据拷贝到文件缓存页中&lt;/span&gt;&lt;br/&gt;  iterate_all_kinds(i, bytes, v,&lt;br/&gt;    copyin((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len),&lt;br/&gt;    memcpy_from_page((p += v.bv_len) - v.bv_len, v.bv_page,&lt;br/&gt;         v.bv_offset, v.bv_len),&lt;br/&gt;    &lt;span&gt;memcpy&lt;/span&gt;((p += v.iov_len) - v.iov_len, v.iov_base, v.iov_len)&lt;br/&gt;  )&lt;br/&gt;  &lt;span&gt;// 解除内核虚拟地址空间与缓存页之间的临时映射，这里映射只是为了拷贝数据用&lt;/span&gt;&lt;br/&gt;  kunmap_atomic(kaddr);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; bytes;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里不能直接进行拷贝，因为此时从 page cache 中取出的缓存页 page 是物理地址，&lt;strong&gt;而在内核中是不能够直接操作物理地址的，只能操作虚拟地址&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么办呢？所以就需要调用 kmap_atomic 将缓存页临时映射到内核空间的一段虚拟地址上，然后将用户空间缓存区 DirectByteBuffer 中的待写入数据通过这段映射的虚拟地址拷贝到 page cache 中的相应缓存页中。这时文件的写入操作就已经完成了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从这里我们看出，内核对于文件的写入只是将数据写入到 page cache 中就完事了并没有真正地写入磁盘。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是临时映射，所以在拷贝完成之后，调用 kunmap_atomic 将这段映射再解除掉。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.4 ext4_write_end&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;ext4_write_end&lt;/span&gt;&lt;span&gt;(struct file *file,&lt;br/&gt;     struct address_space *mapping,&lt;br/&gt;     &lt;span&gt;loff_t&lt;/span&gt; pos, &lt;span&gt;unsigned&lt;/span&gt; len, &lt;span&gt;unsigned&lt;/span&gt; copied,&lt;br/&gt;     struct page *page, &lt;span&gt;void&lt;/span&gt; *fsdata)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;handle_t&lt;/span&gt; *handle = ext4_journal_current_handle();&lt;br/&gt;     &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        ......省略.......&lt;br/&gt;        &lt;span&gt;// 将写入的缓存页在 page cache 中标记为脏页&lt;/span&gt;&lt;br/&gt;        copied = block_write_end(file, mapping, pos, len, copied, page, fsdata);&lt;br/&gt;        &lt;br/&gt;        ......省略.......&lt;br/&gt;        &lt;span&gt;// 完成相关日志的写入&lt;/span&gt;&lt;br/&gt;        ret2 = ext4_journal_stop(handle);&lt;br/&gt;&lt;br/&gt;        ......省略.......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里会对文件的写入流程做一些收尾的工作，比如在 block_write_end 方法中会调用 mark_buffer_dirty 将写入的缓存页在 page cache 中标记为脏页。后续内核会根据一定的规则将 page cache 中的这些脏页回写进磁盘中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体的标记过程笔者已经在《7.1 radix_tree 的标记》小节中详细介绍过了，这里不在赘述。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7pvNnia8hsUZ2hS3eUuPVyNGls0lQovSiaIzjMz3ANHNexwibvAbLLeAMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个核心的步骤就是调用 ext4_journal_stop 完成相关日志的写入。这里日志也只是会先写到缓存里，不会直接落盘。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.5 balance_dirty_pages_ratelimited&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进程将待写数据写入 page cache 中之后，相应的缓存页就变为了脏页，我们需要找一个时机将这些脏页回写到磁盘中。防止断电导致数据丢失。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本小节我们主要聚焦于脏页回写的主体流程，相应细节部分以及内核对脏页的回写时机我们放在下一小节中在详细为大家介绍。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;balance_dirty_pages_ratelimited&lt;/span&gt;&lt;span&gt;(struct address_space *mapping)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;inode&lt;/span&gt; *&lt;span&gt;inode&lt;/span&gt; = &lt;span&gt;mapping&lt;/span&gt;-&amp;gt;&lt;span&gt;host&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;backing_dev_info&lt;/span&gt; *&lt;span&gt;bdi&lt;/span&gt; = &lt;span&gt;inode_to_bdi&lt;/span&gt;(&lt;span&gt;inode&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;bdi_writeback&lt;/span&gt; *&lt;span&gt;wb&lt;/span&gt; = &lt;span&gt;NULL&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ratelimit;&lt;br/&gt;    ......省略......&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (unlikely(current-&amp;gt;nr_dirtied &amp;gt;= ratelimit))&lt;br/&gt;    balance_dirty_pages(mapping, wb, current-&amp;gt;nr_dirtied);&lt;br/&gt;   ......省略......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 balance_dirty_pages_ratelimited  会判断如果脏页数量在内存中达到了一定的规模 ratelimit 就会触发 balance_dirty_pages 回写脏页逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;balance_dirty_pages&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;                struct bdi_writeback *wb,&lt;br/&gt;                &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pages_dirtied)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    .......根据内核异步回写阈值判断是否需要唤醒 flusher 线程异步回写脏页...&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (nr_reclaimable &amp;gt; gdtc-&amp;gt;bg_thresh)&lt;br/&gt;        wb_start_background_writeback(wb);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果达到了脏页回写的条件，那么内核就会唤醒 flusher 线程去将这些脏页异步回写到磁盘中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;wb_start_background_writeback&lt;/span&gt;&lt;span&gt;(struct bdi_writeback *wb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;/*&lt;br/&gt;   * We just wake up the flusher thread. It will perform background&lt;br/&gt;   * writeback as soon as there is no other work to do.&lt;br/&gt;   */&lt;/span&gt;&lt;br/&gt;  wb_wakeup(wb);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13. 内核回写脏页的触发时机&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过前边对文件写入过程的介绍我们看到，用户进程在对文件进行写操作的时候只是将待写入数据从用户空间的缓冲区 DirectByteBuffer 写入到内核中的 page cache 中就结束了。后面内核会对脏页进行延时写入到磁盘中。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当 page cache 中的缓存页比磁盘中对应的文件页的数据要新时，就称这些缓存页为脏页。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时写入的好处就是进程可以多次频繁的对文件进行写入但都是写入到 page cache 中不会有任何磁盘 IO 发生。随后内核可以将进程的这些多次写入操作转换为一次磁盘 IO ，将这些写入的脏页一次性刷新回磁盘中，这样就把多次磁盘 IO 转换为一次磁盘 IO 极大地提升文件 IO 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么内核在什么情况下才会去触发 page cache 中的脏页回写呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核在初始化的时候，会创建一个 timer 定时器去定时唤醒内核 flusher 线程回写脏页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当内存中脏页的数量太多了达到了一定的比例，就会主动唤醒内核中的 flusher 线程去回写脏页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;脏页在内存中停留的时间太久了，等到 flusher 线程下一次被唤醒的时候就会回写这些驻留太久的脏页。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户进程可以通过 sync() 回写内存中的所有脏页和 fsync() 回写指定文件的所有脏页，这些是进程主动发起脏页回写请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在内存比较紧张的情况下，需要回收物理页或者将物理页中的内容 swap 到磁盘上时，如果发现通过页面置换算法置换出来的页是脏页，那么就会触发回写。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们了解了内核回写脏页的一个大概时机，这里大家可能会问了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核通过 timer 定时唤醒 flush 线程回写脏页，那么到底间隔多久唤醒呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内存中的脏页数量太多会触发回写，那么这里的太多指的具体是多少呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;脏页在内存中驻留太久也会触发回写，那么这里的太久指的到底是多久呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这三个问题中涉及到的具体数值，内核都提供了参数供我们来配置。这些参数的配置文件存在于 &lt;code&gt;proc/sys/vm&lt;/code&gt; 目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37520938023450584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7n5Pdeiav53J1jXibvoFwDt3dGXe8KbVzDhJm6fEcmuV78bsicnGzaHVhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者就为大家介绍下内核回写脏页涉及到的这 6 个参数，并解答上面我们提出的这三个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.1 内核中的定时器间隔多久唤醒 flusher 线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核中通过 dirty_writeback_centisecs 参数来配置唤醒 flusher 线程的间隔时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11195928753180662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7pb8N98HrBJWu1SATza17ppdW4awkP9aVtM8CzwYYMNcINMyU2MRKSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该参数可以通过修改 &lt;code&gt;/proc/sys/vm/dirty_writeback_centisecs&lt;/code&gt; 文件来配置参数，我们也可以通过 sysctl 命令或者通过修改 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 配置文件来对这些参数进行修改。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们先主要关注这些内核参数的含义以及源码实现，文章后面笔者有一个专门的章节来介绍这些内核参数各种不同的配置方式。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dirty_writeback_centisecs 内核参数的默认值为 500。单位为 0.01 s。也就是说内核会每隔 5s 唤醒一次 flusher 线程来执行相关脏页的回写。&lt;strong&gt;该参数在内核源码中对应的变量名为 dirty_writeback_interval&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者这里在列举一个生活中的例子来解释下这个 dirty_writeback_interval 的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设大家的工作都非常繁忙，于是大家就到家政公司请了专门的保洁阿姨（内核 flusher 回写线程）来帮助我们打扫房间卫生（回写脏页）。你和保洁阿姨约定每周（dirty_writeback_interval）来你房间（内存）打扫一次卫生（回写脏页），保洁阿姨会固定每周日按时来到你房间打扫。记住这个例子，我们后面还会用到~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.2 内核中如何使用 dirty_writeback_interval 来控制 flusher 唤醒频率&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在磁盘中数据是以块的形式存储于扇区中的，前边在介绍文件读写的章节中，读写流程的最后都会从文件系统层到块设备驱动层，由块设备驱动程序将数据写入对应的磁盘块中存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存中的文件页对应于磁盘中的一个数据块，而这块磁盘就是我们常说的块设备。而每个块设备在内核中对应一个 backing_dev_info 结构用于存储相关信息。其中最重要的信息是 workqueue_struct *bdi_wq 用于缓存块设备上所有的回写脏页异步任务的队列。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/* bdi_wq serves all asynchronous writeback tasks */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;workqueue_struct&lt;/span&gt; *&lt;span&gt;bdi_wq&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; __init &lt;span&gt;default_bdi_init&lt;/span&gt;&lt;span&gt;(&lt;span&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; err;&lt;br/&gt;    &lt;span&gt;// 创建 bdi_wq 队列&lt;/span&gt;&lt;br/&gt; bdi_wq = alloc_workqueue(&lt;span&gt;&quot;writeback&quot;&lt;/span&gt;, WQ_MEM_RECLAIM | WQ_FREEZABLE |&lt;br/&gt;           WQ_UNBOUND | WQ_SYSFS, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!bdi_wq)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; -ENOMEM;&lt;br/&gt;    &lt;span&gt;// 初始化 backing_dev_info&lt;/span&gt;&lt;br/&gt; err = bdi_init(&amp;amp;noop_backing_dev_info);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; err;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统启动的时候，内核会调用 default_bdi_init 来创建 bdi_wq 队列和初始化 backing_dev_info。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;bdi_init&lt;/span&gt;&lt;span&gt;(struct backing_dev_info *bdi)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; ret;&lt;br/&gt;&lt;br/&gt; bdi-&amp;gt;dev = &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 初始化 backing_dev_info 相关信息&lt;/span&gt;&lt;br/&gt; kref_init(&amp;amp;bdi-&amp;gt;refcnt);&lt;br/&gt; bdi-&amp;gt;min_ratio = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; bdi-&amp;gt;max_ratio = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt; bdi-&amp;gt;max_prop_frac = FPROP_FRAC_BASE;&lt;br/&gt; INIT_LIST_HEAD(&amp;amp;bdi-&amp;gt;bdi_list);&lt;br/&gt; INIT_LIST_HEAD(&amp;amp;bdi-&amp;gt;wb_list);&lt;br/&gt; init_waitqueue_head(&amp;amp;bdi-&amp;gt;wb_waitq);&lt;br/&gt;    &lt;span&gt;// 这里会设置 flusher 线程的定时器 timer&lt;/span&gt;&lt;br/&gt; ret = cgwb_bdi_init(bdi);&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ret;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 bdi_init 中初始化 backing_dev_info 结构的相关信息，并在 cgwb_bdi_init 中调用 wb_init 初始化回写脏页任务 bdi_writeback *wb，并创建一个 timer 用于定时启动 flusher 线程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;wb_init&lt;/span&gt;&lt;span&gt;(struct bdi_writeback *wb, struct backing_dev_info *bdi,&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; blkcg_id, &lt;span&gt;gfp_t&lt;/span&gt; gfp)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  ......... 初始化 bdi_writeback 结构该结构表示回写脏页任务相关信息.....&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 创建 timer 定时执行 flusher 线程&lt;/span&gt;&lt;br/&gt;  INIT_DELAYED_WORK(&amp;amp;wb-&amp;gt;dwork, wb_workfn);&lt;br/&gt;  &lt;br/&gt;   ......&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; __INIT_DELAYED_WORK(_work, _func, _tflags)      \&lt;br/&gt;  do {                \&lt;br/&gt;    INIT_WORK(&amp;amp;(_work)-&amp;gt;work, (_func));      \&lt;br/&gt;    __setup_timer(&amp;amp;(_work)-&amp;gt;timer, delayed_work_timer_fn,  \&lt;br/&gt;            (unsigned long)(_work),      \&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bdi_writeback 有个成员变量 struct delayed_work dwork，bdi_writeback 就是把 delayed_work 结构挂到 bdi_wq 队列上的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 wb_workfn 函数则是 flusher 线程要执行的回写核心逻辑，全部封装在 wb_workfn 函数中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt; * Handle writeback of dirty data for the device backed by this bdi. Also&lt;br/&gt; * reschedules periodically and does kupdated style flushing.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;wb_workfn&lt;/span&gt;&lt;span&gt;(struct work_struct *work)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;bdi_writeback&lt;/span&gt; *&lt;span&gt;wb&lt;/span&gt; = &lt;span&gt;container_of&lt;/span&gt;(&lt;span&gt;to_delayed_work&lt;/span&gt;(&lt;span&gt;work&lt;/span&gt;),&lt;br/&gt;      &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;bdi_writeback&lt;/span&gt;, &lt;span&gt;dwork&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt; &lt;span&gt;long&lt;/span&gt; pages_written;&lt;br/&gt;&lt;br/&gt; set_worker_desc(&lt;span&gt;&quot;flush-%s&quot;&lt;/span&gt;, bdi_dev_name(wb-&amp;gt;bdi));&lt;br/&gt; current-&amp;gt;flags |= PF_SWAPWRITE;&lt;br/&gt;&lt;br/&gt;        .......在循环中不断的回写脏页..........&lt;br/&gt;&lt;br/&gt;     &lt;span&gt;// 如果 work-list 中还有回写脏页的任务，则立即唤醒flush线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!list_empty(&amp;amp;wb-&amp;gt;work_list))&lt;br/&gt;  wb_wakeup(wb);&lt;br/&gt;     &lt;span&gt;// 如果回写任务已经被全部执行完毕，但是内存中还有脏页，则延时唤醒&lt;/span&gt;&lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (wb_has_dirty_io(wb) &amp;amp;&amp;amp; dirty_writeback_interval)&lt;br/&gt;  wb_wakeup_delayed(wb);&lt;br/&gt;&lt;br/&gt; current-&amp;gt;flags &amp;amp;= ~PF_SWAPWRITE;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 wb_workfn 中会不断的循环执行 work_list 中的脏页回写任务。当这些回写任务执行完毕之后调用 wb_wakeup_delayed 延时唤醒 flusher线程。&lt;strong&gt;大家注意到这里的 dirty_writeback_interval 配置项终于出现了&lt;/strong&gt;，后续会根据 dirty_writeback_interval 计算下次唤醒 flusher 线程的时机。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;wb_wakeup_delayed&lt;/span&gt;&lt;span&gt;(struct bdi_writeback *wb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; timeout;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 使用 dirty_writeback_interval 配置设置下次唤醒时间 &lt;/span&gt;&lt;br/&gt; timeout = msecs_to_jiffies(dirty_writeback_interval * &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt; spin_lock_bh(&amp;amp;wb-&amp;gt;work_lock);&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (test_bit(WB_registered, &amp;amp;wb-&amp;gt;state))&lt;br/&gt;  queue_delayed_work(bdi_wq, &amp;amp;wb-&amp;gt;dwork, timeout);&lt;br/&gt; spin_unlock_bh(&amp;amp;wb-&amp;gt;work_lock);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.3 脏页数量多到什么程度会主动唤醒 flusher 线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一节的内容中涉及到四个内核参数分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;drity_background_ratio ：当脏页数量在系统的可用内存 available 中占用的比例达到 drity_background_ratio 的配置值时，内核就会调用 wakeup_flusher_threads 来唤醒 flusher 线程&lt;strong&gt;异步&lt;/strong&gt;回写脏页。默认值为：10。表示如果 page cache 中的脏页数量达到系统可用内存的 10% 的话，就主动唤醒 flusher 线程去回写脏页到磁盘。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08757062146892655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r70RAic1nZZ7MtNZ6DDBuFuY1X6tSQsicf5rKGicZas9BhpVx6iaHJDjQjCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;系统的可用内存 = 空闲内存 + 可回收内存。可以通过 free 命令的 available 项查看。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14013840830449828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r73RqS3vrgic1ichlmkOmCNvVqpY9sIFhoRz3y6Te5fficIug76Xwz6s5JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dirty_background_bytes ：如果 page cache 中脏页占用的内存用量绝对值达到指定的 dirty_background_bytes。内核就会调用 wakeup_flusher_threads 来唤醒 flusher 线程&lt;strong&gt;异步&lt;/strong&gt;回写脏页。默认为：0。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08042895442359249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7hmmYNk0g21YLSRJgoVyiccTvbXNTb48hEBtJCtjxW5kSCT6AhAicFrBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;dirty_background_bytes 的优先级大于 drity_background_ratio 的优先级。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dirty_ratio ：dirty_background_* 相关的内核配置参数均是内核通过唤醒 flusher 线程来异步回写脏页。下面要介绍的 dirty_* 配置参数，均是由用户进程&lt;strong&gt;同步&lt;/strong&gt;回写脏页。表示内存中的脏页太多了，用户进程自己都看不下去了，不用等内核 flusher 线程唤醒，&lt;strong&gt;用户进程自己主动去回写脏页到磁盘中&lt;/strong&gt;。当脏页占用系统可用内存的比例达到 dirty_ratio 配置的值时，用户进程同步回写脏页。默认值为：20 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11724137931034483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7LdibvuQWXSqbfXsiaEKZOUQhx8yrGmYDqbuGB3rO7CyW1MRKvX6voDoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;580&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dirty_bytes ：如果 page cache 中脏页占用的内存用量绝对值达到指定的 dirty_bytes。用户进程&lt;strong&gt;同步&lt;/strong&gt;回写脏页。默认值为：0。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;*_bytes 相关配置参数的优先级要大于 *_ratio 相关配置参数。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7Uu31ltnFA2ZcLr2zNSPQ3SZDCfNCqQpSNCWgRTia19OvNJJqu7reLAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;560&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续使用上小节中保洁阿姨的例子说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前你们已经约定好了，保洁阿姨会每周日固定（dirty_writeback_centisecs）来到你的房间打扫卫生（脏页），但是你周三回家的时候，发现屋子里太脏了，实在是脏到一定程度了（drity_background_ratio ，dirty_background_bytes），你实在是看不去了，这时你就不会等这周日（dirty_writeback_centisecs）保洁阿姨过来才打扫，你会直接给阿姨打电话让阿姨周三就来打扫一下（内核主动唤醒 flusher 线程异步回写脏页）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种更极端的情况就是，你的房间已经脏到很夸张的程度了（dirty_ratio ，dirty_byte）连你自己都忍不了了，于是你都不用等保洁阿姨了（内核 flusher 回写线程），你自己就乖乖的开始打扫房间卫生了。这就是用户进程同步回写脏页。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.4 内核如何主动唤醒 flusher 线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 《12.5 balance_dirty_pages_ratelimited》小节的介绍，我们知道在 generic_perform_write 函数的最后一步会调用 balance_dirty_pages_ratelimited 来判断是否要触发脏页回写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;balance_dirty_pages_ratelimited&lt;/span&gt;&lt;span&gt;(struct address_space *mapping)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ................省略............&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (unlikely(current-&amp;gt;nr_dirtied &amp;gt;= ratelimit))&lt;br/&gt;  balance_dirty_pages(mapping, wb, current-&amp;gt;nr_dirtied);&lt;br/&gt;&lt;br/&gt; wb_put(wb);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会触发 balance_dirty_pages 函数进行脏页回写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;balance_dirty_pages&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;    struct bdi_writeback *wb,&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pages_dirtied)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ..................省略.............&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;        &lt;span&gt;// 获取系统可用内存&lt;/span&gt;&lt;br/&gt;  gdtc-&amp;gt;avail = global_dirtyable_memory();&lt;br/&gt;        &lt;span&gt;// 根据 *_ratio 或者 *_bytes 相关内核配置计算脏页回写触发的阈值&lt;/span&gt;&lt;br/&gt;  domain_dirty_limits(gdtc);&lt;br/&gt;                .............省略..........&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;        .............省略..........&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 balance_dirty_pages 中首先通过 global_dirtyable_memory() 获取系统当前可用内存。在 domain_dirty_limits 函数中根据前边我们介绍的  *_ratio 或者 *_bytes 相关内核配置计算脏页回写触发的阈值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;domain_dirty_limits&lt;/span&gt;&lt;span&gt;(struct dirty_throttle_control *dtc)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 获取可用内存&lt;/span&gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; available_memory = dtc-&amp;gt;avail;&lt;br/&gt;    &lt;span&gt;// 封装触发脏页回写相关阈值信息&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;dirty_throttle_control&lt;/span&gt; *&lt;span&gt;gdtc&lt;/span&gt; = &lt;span&gt;mdtc_gdtc&lt;/span&gt;(&lt;span&gt;dtc&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 这里就是内核参数 dirty_bytes 指定的值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; bytes = vm_dirty_bytes;&lt;br/&gt;    &lt;span&gt;// 内核参数 dirty_background_bytes 指定的值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; bg_bytes = dirty_background_bytes;&lt;br/&gt;    &lt;span&gt;// 将内核参数 dirty_ratio 指定的值转换为以 页 为单位&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ratio = (vm_dirty_ratio * PAGE_SIZE) / &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;     &lt;span&gt;// 将内核参数 dirty_background_ratio 指定的值转换为以 页 为单位&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; bg_ratio = (dirty_background_ratio * PAGE_SIZE) / &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;     &lt;span&gt;// 进程同步回写 dirty_* 相关阈值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; thresh;&lt;br/&gt;     &lt;span&gt;// 内核异步回写 direty_background_* 相关阈值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; bg_thresh;&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;task_struct&lt;/span&gt; *&lt;span&gt;tsk&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (gdtc) {&lt;br/&gt;        &lt;span&gt;// 系统可用内存&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; global_avail = gdtc-&amp;gt;avail;&lt;br/&gt;        &lt;span&gt;// 这里可以看出 bytes 相关配置的优先级大于 ratio 相关配置的优先级&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (bytes)&lt;br/&gt;            &lt;span&gt;// 将 bytes 相关的配置转换为以页为单位的内存占用比例ratio&lt;/span&gt;&lt;br/&gt;   ratio = min(DIV_ROUND_UP(bytes, global_avail),&lt;br/&gt;        PAGE_SIZE);&lt;br/&gt;        &lt;span&gt;// 设置 dirty_backgound_* 相关阈值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (bg_bytes)&lt;br/&gt;   bg_ratio = min(DIV_ROUND_UP(bg_bytes, global_avail),&lt;br/&gt;           PAGE_SIZE);&lt;br/&gt;  bytes = bg_bytes = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;        &lt;br/&gt;    &lt;span&gt;// 这里可以看出 bytes 相关配置的优先级大于 ratio 相关配置的优先级&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (bytes)&lt;br/&gt;        &lt;span&gt;// 将 bytes 相关的配置转换为以页为单位的内存占用比例ratio&lt;/span&gt;&lt;br/&gt;  thresh = DIV_ROUND_UP(bytes, PAGE_SIZE);&lt;br/&gt; &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  thresh = (ratio * available_memory) / PAGE_SIZE;&lt;br/&gt;    &lt;span&gt;// 设置 dirty_background_* 相关阈值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (bg_bytes)&lt;br/&gt;         &lt;span&gt;// 将 dirty_background_bytes 相关的配置转换为以页为单位的内存占用比例ratio&lt;/span&gt;&lt;br/&gt;  bg_thresh = DIV_ROUND_UP(bg_bytes, PAGE_SIZE);&lt;br/&gt; &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  bg_thresh = (bg_ratio * available_memory) / PAGE_SIZE;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 保证异步回写 backgound 的相关阈值要比同步回写的阈值要低&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (bg_thresh &amp;gt;= thresh)&lt;br/&gt;  bg_thresh = thresh / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; dtc-&amp;gt;thresh = thresh;&lt;br/&gt; dtc-&amp;gt;bg_thresh = bg_thresh;&lt;br/&gt;        &lt;br/&gt;        ..........省略..........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;domain_dirty_limits 函数会分别计算用户进程同步回写脏页的相关阈值 thresh 以及内核异步回写脏页的相关阈值 bg_thresh。逻辑比较好懂，笔者将每一步的注释已经为大家标注出来了。这里只列出几个关键核心点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从源码中的 if (bytes) {....} else {.....} 分支以及 if (bg_bytes) {....} else {.....} 我们可以看出内核配置 *_bytes 相关的优先级会高于 *_ratio 相关配置的优先级。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;*_bytes 相关配置我们只会指定脏页占用内存的 bytes 阈值，但在内核实现中会将其转换为 页 为单位。（每页 4K 大小）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核中对于脏页回写阈值的判断是通过 ratio 比例来进行判断的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;内核异步回写的阈值要小于进程同步回写的阈值，如果超过，那么内核异步回写的阈值将会被设置为进程通过回写的一半。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;balance_dirty_pages&lt;/span&gt;&lt;span&gt;(struct address_space *mapping,&lt;br/&gt;    struct bdi_writeback *wb,&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; pages_dirtied)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ..................省略.............&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;        &lt;span&gt;// 获取系统可用内存&lt;/span&gt;&lt;br/&gt;  gdtc-&amp;gt;avail = global_dirtyable_memory();&lt;br/&gt;        &lt;span&gt;// 根据 *_ratio 或者 *_bytes 相关内核配置计算 脏页回写触发的阈值&lt;/span&gt;&lt;br/&gt;  domain_dirty_limits(gdtc);&lt;br/&gt;                .............省略..........&lt;br/&gt;     }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 根据进程同步回写阈值判断是否需要进程直接同步回写脏页  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (writeback_in_progress(wb))&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 根据内核异步回写阈值判断是否需要唤醒flusher异步回写脏页&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (nr_reclaimable &amp;gt; gdtc-&amp;gt;bg_thresh)&lt;br/&gt;  wb_start_background_writeback(wb);&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是异步回写，内核则唤醒 flusher 线程开始异步回写脏页，直到脏页数量低于阈值或者全部回写到磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;wb_start_background_writeback&lt;/span&gt;&lt;span&gt;(struct bdi_writeback *wb)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;/*&lt;br/&gt;  * We just wake up the flusher thread. It will perform background&lt;br/&gt;  * writeback as soon as there is no other work to do.&lt;br/&gt;  */&lt;/span&gt;&lt;br/&gt; trace_writeback_wake_background(wb);&lt;br/&gt; wb_wakeup(wb);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.5 脏页到底在内存中能驻留多久&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核为了避免 page cache 中的脏页在内存中长久的停留，所以会给脏页在内存中的驻留时间设置一定的期限，这个期限可由前边提到的 dirty_expire_centisecs 内核参数配置。默认为：3000。单位为：0.01 s。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08635097493036212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7nlH4wRW7hqFKgQE9a3RXK87QVVHjpIPhiccgMxnyibgSmKQbt908EOuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说在默认配置下，脏页在内存中的驻留时间为 30 s。超过 30 s 之后，&lt;strong&gt;flusher 线程将会在下次被唤醒的时候将这些脏页回写到磁盘中&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些过期的脏页最终会在 flusher 线程下一次被唤醒时候被 flusher 线程回写到磁盘中。而前边我们也多次提到过 flusher 线程执行逻辑全部封装在 wb_workfn 函数中。接下来的调用链为 wb_workfn-&amp;gt;wb_do_writeback-&amp;gt;wb_writeback。在 wb_writeback 中会判断根据  dirty_expire_interval 判断哪些是过期的脏页。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/*&lt;br/&gt; * Explicit flushing or periodic writeback of &quot;old&quot; data.&lt;br/&gt; *&lt;br/&gt; * Define &quot;old&quot;: the first time one of an inode&#x27;s pages is dirtied, we mark the&lt;br/&gt; * dirtying-time in the inode&#x27;s address_space.  So this periodic writeback code&lt;br/&gt; * just walks the superblock inode list, writing back any inodes which are&lt;br/&gt; * older than a specific point in time.&lt;br/&gt; *&lt;br/&gt; * Try to run once per dirty_writeback_interval.  But if a writeback event&lt;br/&gt; * takes longer than a dirty_writeback_interval interval, then leave a&lt;br/&gt; * one-second gap.&lt;br/&gt; *&lt;br/&gt; * older_than_this takes precedence over nr_to_write.  So we&#x27;ll only write back&lt;br/&gt; * all dirty pages if they are all attached to &quot;old&quot; mappings.&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;wb_writeback&lt;/span&gt;&lt;span&gt;(struct bdi_writeback *wb,&lt;br/&gt;    struct wb_writeback_work *work)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;        ........省略.......&lt;br/&gt; work-&amp;gt;older_than_this = &amp;amp;oldest_jif;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;                ........省略.......&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (work-&amp;gt;for_kupdate) {&lt;br/&gt;   oldest_jif = jiffies -&lt;br/&gt;    msecs_to_jiffies(dirty_expire_interval * &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (work-&amp;gt;for_background)&lt;br/&gt;   oldest_jif = jiffies;&lt;br/&gt;        }&lt;br/&gt;         ........省略.......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.6 脏页回写参数的相关配置方式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的几个小节笔者结合内核源码实现为大家介绍了影响内核回写脏页时机的六个参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核越频繁的触发脏页回写，数据的安全性就越高，但是同时系统性能会消耗很大。所以我们在日常工作中需要结合数据的安全性和 IO 性能综合考虑这六个内核参数的配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节笔者就为大家介绍一下配置这些内核参数的方式，前面的小节中也提到过，内核提供的这些参数存在于 &lt;code&gt;proc/sys/vm&lt;/code&gt; 目录下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37520938023450584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r7n5Pdeiav53J1jXibvoFwDt3dGXe8KbVzDhJm6fEcmuV78bsicnGzaHVhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们直接将要配置的具体数值写入对应的配置文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;value&quot;&lt;/span&gt; &amp;gt; /proc/sys/vm/dirty_background_ratio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以使用 sysctl 来对这些内核参数进行配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sysctl -w variable=value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sysctl 命令中定义的这些变量 variable 全部定义在内核 &lt;code&gt;kernel/sysctl.c&lt;/code&gt; 源文件中。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其中 .procname 定义的就是 sysctl 命令中指定的配置变量名字。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;.data 定义的是内核源码中引用的变量名字。这在前边我们介绍内核代码的时候介绍过了。比如配置参数 dirty_writeback_centisecs 在内核源码中的变量名为 dirty_writeback_interval ， dirty_ratio 在内核中的变量名为 vm_dirty_ratio。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ctl_table&lt;/span&gt; &lt;span&gt;vm_table&lt;/span&gt;[] = {&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        ........省略........&lt;br/&gt;&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_background_ratio&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;dirty_background_ratio,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(dirty_background_ratio),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = dirty_background_ratio_handler,&lt;br/&gt;  .extra1  = SYSCTL_ZERO,&lt;br/&gt;  .extra2  = SYSCTL_ONE_HUNDRED,&lt;br/&gt; },&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_background_bytes&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;dirty_background_bytes,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(dirty_background_bytes),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = dirty_background_bytes_handler,&lt;br/&gt;  .extra1  = SYSCTL_LONG_ONE,&lt;br/&gt; },&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_ratio&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;vm_dirty_ratio,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(vm_dirty_ratio),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = dirty_ratio_handler,&lt;br/&gt;  .extra1  = SYSCTL_ZERO,&lt;br/&gt;  .extra2  = SYSCTL_ONE_HUNDRED,&lt;br/&gt; },&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_bytes&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;vm_dirty_bytes,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(vm_dirty_bytes),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = dirty_bytes_handler,&lt;br/&gt;  .extra1  = (&lt;span&gt;void&lt;/span&gt; *)&amp;amp;dirty_bytes_min,&lt;br/&gt; },&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_writeback_centisecs&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;dirty_writeback_interval,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(dirty_writeback_interval),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = dirty_writeback_centisecs_handler,&lt;br/&gt; },&lt;br/&gt; {&lt;br/&gt;  .procname = &lt;span&gt;&quot;dirty_expire_centisecs&quot;&lt;/span&gt;,&lt;br/&gt;  .data  = &amp;amp;dirty_expire_interval,&lt;br/&gt;  .maxlen  = &lt;span&gt;sizeof&lt;/span&gt;(dirty_expire_interval),&lt;br/&gt;  .mode  = &lt;span&gt;0644&lt;/span&gt;,&lt;br/&gt;  .proc_handler = proc_dointvec_minmax,&lt;br/&gt;  .extra1  = SYSCTL_ZERO,&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;       ........省略........&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边介绍的这两种配置方式全部是临时的，我们可以通过编辑  &lt;code&gt;/etc/sysctl.conf &lt;/code&gt; 文件来永久的修改内核相关的配置。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们也可以在目录 &lt;code&gt;/etc/sysctl.d/&lt;/code&gt;下创建自定义的配置文件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; vi /etc/sysctl.conf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;/etc/sysctl.conf &lt;/code&gt; 文件中直接以 &lt;code&gt;variable = value&lt;/code&gt; 的形式添加到文件的末尾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7542857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUayzMQRPfBBF8JQXIRkM1r750K9AsicPgaiaunYEQItuHUpHR7pdQs34d2FibleLOhibY74v4X8ZQUkVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用 &lt;code&gt;sysctl -p /etc/sysctl.conf&lt;/code&gt; 使 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 配置文件中新添加的那些配置生效。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者带大家从 Linux 内核的角度详细解析了 JDK NIO 文件读写在 Buffered IO 以及 Direct IO  这两种模式下的内核源码实现，探秘了文件读写的本质。并对比了 Buffered IO 和 Direct IO 的不同之处以及各自的适用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个过程中又详细地介绍了与 Buffered IO 密切相关的文件页高速缓存 page cache 在内核中的实现以及相关操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们详细介绍了影响文件 IO 的两个关键步骤：文件预读和脏页回写的详细内核源码实现，以及内核中影响脏页回写时机的 6 个关键内核配置参数相关的实现及应用。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_background_bytes&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_background_ratio&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_bytes&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_ratio&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_expire_centisecs&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;dirty_writeback_centisecs&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及关于内核参数的三种配置方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过直接修改 &lt;code&gt;proc/sys/vm&lt;/code&gt; 目录下的相关参数配置文件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 sysctl 命令来对相关参数进行修改。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过编辑 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 文件来永久的修改内核相关配置。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本文的内容到这里就结束了，能够看到这里的大家一定是个狠人儿，但是辛苦的付出总会有所收获，恭喜大家现在已经彻底打通了 Linux 文件操作相关知识的系统脉络。感谢大家的耐心观看，我们下篇文章见~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>