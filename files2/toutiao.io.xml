<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ee0e5ef8336bc1ddc8642839df3816d2</guid>
<title>万字图文讲透数据库缓存一致性问题</title>
<link>https://toutiao.io/k/1exlsmh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;span&gt;点个关注👆跟腾讯工程师学技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe94NkoG8ic4cxAHXIAeNJugn2C3ibibg0zRygM6XpWUCFCS2jFyBK9J6WPBv8hzQFpnNHoneSEGMe8mqQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-w=&quot;1071&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10899182561307902&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDWibXoicOmWRPWDtKd4KicjNbOybYFjuxwAMrXNWs2cE6DjLKhzDwE48IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;导语|&lt;/span&gt; &lt;/span&gt;&lt;span&gt;缓存合理使用确提升了系统的吞吐量和稳定性，然而这是有代价的。这个代价便是缓存和数据库的一致性带来了挑战，本文将针对最常见的cache-aside策略下如何维护缓存一致性彻底讲透。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;但&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;客观上，我们的业务规模&lt;/span&gt;&lt;span&gt;很可能要求着更高的 QPS，有些业务的规模本身就非常大，也有些业务会遇到一些流量高峰，比如电商会遇到大促的情况。&lt;/span&gt;&lt;/section&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这时候大部分的流量实际上都是读请求，而且大部分数据也是没有那么多变化的，如热门商品信息、微博的内容等常见数据就是如此。此时，缓存就是我们应对此类场景的利器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08148148148148149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;缓存的意义&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓缓存，实际上就是用空间换时间，准确地说是用更高速的空间来换时间，从而整体上提升读的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;何为更高速的空间呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更快的存储介质。通常情况下，如果说数据库的速度慢，就得用更快的存储组件去替代它，目前最常见的就是Redis（内存存储）。Redis 单实例的读 QPS 可以高达 10w/s，90% 的场景下只需要正确使用 Redis 就能应对。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就近使用本地内存。就像 CPU 也有高速缓存一样，缓存也可以分为一级缓存、二级缓存。即便 Redis 本身性能已经足够高了，但访问一次 Redis 毕竟也需要一次网络 IO，而使用本地内存无疑有更快的速度。不过单机的内存是十分有限的，所以这种一级缓存只能存储非常少量的数据，通常是最热点的那些 key 对应的数据。这就相当于额外消耗宝贵的服务内存去换取高速的读取性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08148148148148149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;引入缓存后的一致性挑战&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用空间换时间，意味着数据同时存在于多个空间。最常见的场景就是数据同时存在于 Redis 与 MySQL 上（为了问题的普适性，后面举例中若没有特别说明，缓存均指 Redis 缓存）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，最权威最全的数据还是在 MySQL 里的。而万一 Redis数据没有得到及时的更新（例如数据库更新了没更新到Redis），就出现了数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分情况下，只要使用了缓存，就必然会有不一致的情况出现，只是说这个不一致的时间窗口是否能做到足够的小。有些不合理的设计可能会导致数据持续不一致，这是我们需要改善设计去避免的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的一致性实际上对于本地缓存也是同理的，例如数据库更新后没有及时更新本地缓存，也是有一致性问题的，下文统一以Redis缓存作为引子讲述，实际上处理本地缓存原理基本一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（一）缓存不一致性无法客观地完全消灭&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为什么我们几乎没办法做到缓存和数据库之间的强一致呢？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理想情况下，我们需要在数据库更新完后把对应的最新数据同步到缓存中，以便在读请求的时候能读到新的数据而不是旧的数据（脏数据）。但是很可惜，由于数据库和 Redis 之间是没有事务保证的，所以我们无法确保写入数据库成功后，写入 Redis 也是一定成功的；即便 Redis 写入能成功，在数据库写入成功后到 Redis 写入成功前的这段时间里，Redis 数据也肯定是和 MySQL 不一致的。如下两图所示：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7667844522968198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDjuald3fWYEiaCKDZ84tTkAYBaG4SLicEcYuFT4O75icGgZSxuQjGVA7Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无法事务保持一致&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说这个时间窗口是没办法完全消灭的，除非我们付出极大的代价，使用分布式事务等各种手段去维持强一致，但是这样会使得系统的整体性能大幅度下降，甚至比不用缓存还慢，这样不就与我们使用缓存的目标背道而驰了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;不过虽然无法做到强一致，但是我们能做到的是缓存与数据库达到最终一致，而且不一致的时间窗口我们能做到尽可能短，按照经验来说，如果能将时间优化到 1ms 之内，这个一致性问题带来的影响我们就可以忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35962145110410093&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyD1629nYc12ZjrgVbH8d4qFjW8KGB7sicSVTfqM8rJiaZnMliaqQXHgzh3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更新缓存的手段&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通常情况&lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;我们在&lt;/span&gt;&lt;span&gt;处理查询&lt;/span&gt;&lt;span&gt;请求的&lt;/span&gt;&lt;span&gt;时候，使用缓存的逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; = queryDataRedis(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; ==&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; = queryDataMySQL(key); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;!=&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说优先查询缓存，查询不到才查询数据库。如果这时候数据库查到数据了，就将缓存的数据进行更新。这是我们常说的cache aside的策略，也是最常用的策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑是正确的，而一致性的问题一般不来源于此，而是出现在处理写请求的时候。所以我们简化成最简单的写请求的逻辑，此时你可能会面临多个选择，究竟是直接更新缓存，还是失效缓存？而无论是更新缓存还是失效缓存，都可以选择在更新数据库之前，还是之后操作。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这样就演变出 4 个策略：更新数据库后更新缓存、更新数据库前更新缓存、更新数据库后删除缓存、更新数据库前删除缓存。下面我们来分别讲述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（一）更新数据库后更新缓存的不一致问题&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种常见的操作是，设置一个过期时间，让写请求以数据库为准，过期后，读请求同步数据库中的最新数据给缓存。那么在加入了过期时间后，是否就不会有问题了呢？并不是这样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家设想一下这样的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如这里有一个计数器，把数据库自减 1，原始数据库数据是 100，同时有两个写请求申请计数减一，假设线程 A 先减数据库成功，线程 B 后减数据库成功。那么这时候数据库的值是 98，缓存里正确的值应该也要是 98。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是特殊场景下，你可能会遇到这样的情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 和线程 B 同时更新这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先 A 后 B&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;更新缓存时顺序是先 B 后 A&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们的代码逻辑还是更新数据库后立刻更新缓存的数据，那么——&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;powershell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就可能出现：数据库的值是 100-&amp;gt;99-&amp;gt;98，但是缓存的数据却是 100-&amp;gt;98-&amp;gt;99，也就是数据库与缓存的不一致。而且这个不一致只能等到下一次数据库更新或者缓存失效才可能修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table align=&quot;left&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库为98&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存数据为98&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存数据为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为99，但是实际上数据库的值已经是98，数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，如果更新Redis本身是失败的话，两边的值固然也是不一致的，这个前文也阐述过，几乎无法根除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/article&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8894472361809045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyD66JhRse8ousJOZCLKN0gU6g65uWeW0j6hLj2kZAbhPPL2Sibkhuialkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（二）更新数据库前更新缓存的不一致问题&lt;/span&gt;&lt;/p&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那你可能会想，这是否表示，我应该先让缓存更新，之后再去更新数据库呢？类似这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这样操作产生的问题更是显而易见的，因为我们无法保证数据库的更新成功，万一数据库更新失败了，你缓存的数据就不只是脏数据，而是错误数据了。&lt;/span&gt;&lt;/p&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9209876543209876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDMHedlaqeQDJxkNhtVUWWvEE1vWibcbEFhUvwbvxjUCqp2kVVdNTXC8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;你可能会想，是否我在更新数据库失败的时候做 Redis 回滚的操作能够解决呢？这其实也是不靠谱的，因为我们也不能保证这个回滚的操作 100% 被成功执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，在写写并发的场景下，同样有类似的一致性问题&lt;/span&gt;&lt;span&gt;，请看以下情况：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;article&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 A 和线程 B 同时更新同这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更新缓存的顺序是先 A 后 B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先 B 后 A&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子。线程 A 希望把计数器置为 0，线程 B 希望置为 1。而按照以上场景，缓存确实被设置为 1，但数据库却被设置为 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存为0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存为1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库为1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库数据为0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为1，但是实际上数据库的值是0，数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以通常情况下，更新缓存再更新数据库是我们应该避免使用的一种手段。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;br/&gt;&lt;h1&gt;&lt;span&gt;（三）更新数据库前删除缓存的问题&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如果采取删除缓存的策略呢？也就是说我们在更新数据库的时候失效对应的缓存，让缓存在下次触发读请求时进行更新，是否会更好呢？同样地，针对在更新数据库前和数据库后这两个删除时机，我们来比较下其差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最直观的做法，我们可能会先让缓存失效，然后去更新数据库，代码逻辑如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedis(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑看似没有问题，毕竟删除缓存后即便数据库更新失败了，也只是缓存上没有数据而已。然后并发两个写请求过来，无论怎么样的执行顺序，缓存最后的值也都是会被删除的，也就是说在并发写写的请求下这样的处理是没问题的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，这种处理在读写并发的场景下却存在着隐患。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是刚刚更新计数的例子。例如现在缓存的数据是 100，数据库也是 100，这时候需要对此计数减 1，减成功后，数据库应该是 99。如果这之后触发读请求，缓存如果有效的话，里面应该也要被更新为 99 才是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么思考下这样的请求情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 更新这个数据的同时，线程 B 读取这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 成功删除了缓存里的老数据，这时候线程 B 查询数据发现缓存失效&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 更新数据库成功&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1.读取缓存数据，缓存缺失，从数据库读取数据100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库中的数据X的值为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将数据100的值写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，在读写并发的场景下，一样会有不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这种场景，有个做法是所谓的“延迟双删策略”，就是说，既然可能因为读请求把一个旧的值又写回去，那么我在写请求处理完之后，等到差不多的时间延迟再重新删除这个缓存值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程C（新的读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程D（新的读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T5&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;sleep(N)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缓存存在，读取到缓存旧值100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;其他线程可能在双删成功前读到脏数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T6&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T7&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缓存缺失，从数据库读取数据的最新值（99）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种解决思路的关键在于对 N 的时间的判断，如果 N 时间太短，线程 A 第二次删除缓存的时间依旧早于线程 B 把脏数据写回缓存的时间，那么相当于做了无用功。而 N 如果设置得太长，那么在触发双删之前，新请求看到的都是脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（四）更新数据库后删除缓存&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如果我们把更新数据库放在删除缓存之前呢，问题是否解决？我们继续从读写并发的场景看下去，有没有类似的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程C（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新主库 X = 99（原值 X = 100）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读取数据，查询到缓存还有数据，返回100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程C实际上读取到了和数据库不一致的数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;查询缓存，缓存缺失，查询数据库得到当前值99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T5&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;99写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，大体上，采取先更新数据库再删除缓存的策略是没有问题的，仅在更新数据库成功到缓存删除之间的时间差内——[T2,T3)的窗口 ，可能会被别的线程读取到老值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在开篇的时候我们说过，缓存不一致性的问题无法在客观上完全消灭，因为我们无法保证数据库和缓存的操作是一个事务里的，而我们能做到的只是尽量缩短不一致的时间窗口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更新数据库后删除缓存这个场景下，不一致窗口仅仅是 T2 到 T3 的时间，内网状态下通常不过 1ms，在大部分业务场景下我们都可以忽略不计。因为大部分情况下一个用户的请求很难能再1ms内快速发起第二次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是真实场景下，还是会有一个情况存在不一致的可能性，这个场景是读线程发现缓存不存在，于是读写并发时，读线程回写进去老值。并发情况如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求--缓存不存在场景）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;查询缓存，缓存缺失，查询数据库得到当前值100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新主库 X = 99（原值 X = 100）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将100写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，这个不一致场景出现条件非常严格，因为并发量很大时，缓存不太可能不存在；如果并发很大，而缓存真的不存在，那么很可能是这时的写场景很多，因为写场景会删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以待会我们会提到，写场景很多时候实际上并不适合采取删除策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（五）总结四种更新策略&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;终上所述，我们对比了四个更新缓存的手段，做一个总结对比，其中应对方案也提供参考，具体不做展开，如下表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应对方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库+更新缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A未更新完缓存之前，线程B的读请求会短暂读到旧值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;可以忽略&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，数据库和缓存数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存+更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;无并发&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A还未更新完缓存但是更新数据库可能失败&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;利用MQ确认数据库更新成功（较复杂）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存的顺序是先A后B，但更新数据库时顺序是先B后A&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作很重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值+更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写请求的线程A删除了缓存在更新数据库之前，这时候读请求线程B到来，因为缓存缺失，则把当前数据读取出来放到缓存，而后线程A更新成功了数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;延迟双删（但是延迟的时间不好估计，且延迟的过程中依旧有不一致的时间窗口）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库+删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读（缓存命中）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A完成数据库更新成功后，尚未删除缓存，线程B有并发读请求会读到旧的脏数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;可以忽略&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读（缓存不命中）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读请求不命中缓存，写请求处理完之后读请求才回写缓存，此时缓存不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从一致性的角度来看，采取更新数据库后删除缓存值，是更为适合的策略。因为出现不一致的场景的条件更为苛刻，概率相比其他方案更低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么是否更新缓存这个策略就一无是处呢？不是的！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除缓存值意味着对应的 key 会失效，那么这时候读请求都会打到数据库。如果这个数据的写操作非常频繁，就会导致缓存的作用变得非常小。而如果这时候某些 Key 还是非常大的热 key，就可能因为扛不住数据量而导致系统不可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3665943600867679&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDE1oYyJic1e5ibyWB7rntUV6wtTZhSiao8YMRKXexSzjyo1aMz8L50Sib4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除策略频繁的缓存失效导致读请求无法利用缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以做个简单总结，足以适应绝大部分的互联网开发场景的决策：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对大部分读多写少场景，建议选择更新数据库后删除缓存的策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最终一致性如何保证？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存设置过期时间&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一个方法便是我们上面提到的，当我们无法确定 MySQL 更新完成后，缓存的更新/删除一定能成功，例如 Redis 挂了导致写入失败了，或者当时网络出现故障，更常见的是服务当时刚好发生重启了，没有执行这一步的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些时候 MySQL 的数据就无法刷到 Redis 了。为了避免这种不一致性永久存在，使用缓存的时候，我们必须要给缓存设置一个过期时间，例如 1 分钟，这样即使出现了更新 Redis 失败的极端场景，不一致的时间窗口最多也只是 1 分钟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是我们最终一致性的兜底方案，万一出现任何情况的不一致问题，最后都能通过缓存失效后重新查询数据库，然后回写到缓存，来做到缓存与数据库的最终一致。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F9gEWETfj769ZEnnF4YHYbm1UBFpYldG1ibl6E9owa0M3yRB40WtEqLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何减少缓存删除/更新的失败？&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;万一删除缓存这一步因为服务重启没有执行，或者 Redis 临时不可用导致删除缓存失败了，就会有一个较长的时间（缓存的剩余过期时间）是数据不一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们有没有什么手段来减少这种不一致的情况出现呢？这时候借助一个可靠的消息中间件就是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为消息中间件有 ATLEAST-ONCE 的机制，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8088803088803089&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDbhKBOIj2FNXuTYicyU1K5jITpzSkTrpKv19YcPzj1XPwPWrU6ZdmGWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把删除 Redis 的请求以消费 MQ 消息的手段去失效对应的 Key 值，如果 Redis 真的存在异常导致无法删除成功，我们依旧可以依靠 MQ 的重试机制来让最终 Redis 对应的 Key 失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而你们或许会问，极端场景下，是否存在更新数据库后 MQ 消息没发送成功，或者没机会发送出去机器就重启的情况？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个场景的确比较麻烦，如果 MQ 使用的是 RocketMQ，我们可以借助 RocketMQ 的事务消息，来让删除缓存的消息最终一定发送出去。而如果你没有使用 RocketMQ，或者你使用的消息中间件并没有事务消息的特性，则可以采取消息表的方式让更新数据库和发送消息一起成功。事实上这个话题比较大了，我们不在这里展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FibDz8VdeMtTPP6QGg7Qg03rhEzsPz8nRZlEVnmBdT96EyJFHfMz0iavQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何处理复杂的多缓存场景？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些时候，真实的缓存场景并不是数据库中的一个记录对应一个 Key 这么简单，有可能一个数据库记录的更新会牵扯到多个 Key 的更新。还有另外一个场景是，更新不同的数据库的记录时可能需要更新同一个 Key 值，这常见于一些 App 首页数据的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以一个数据库记录对应多个 Key 的场景来举例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如系统设计上我们缓存了一个粉丝的主页信息、主播打赏榜 TOP10 的粉丝、单日 TOP 100 的粉丝等多个信息。如果这个粉丝注销了，或者这个粉丝触发了打赏的行为，上面多个 Key 可能都需要更新。只是一个打赏的记录，你可能就要做：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedisKey1();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedisKey2();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedisKey3();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这就涉及多个 Redis 的操作，每一步都可能失败，影响到后面的更新。甚至从系统设计上，更新数据库可能是单独的一个服务，而这几个不同的 Key 的缓存维护却在不同的 3 个微服务中，这就大大增加了系统的复杂度和提高了缓存操作失败的可能性。最可怕的是，操作更新记录的地方很大概率不只在一个业务逻辑中，而是散发在系统各个零散的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这个场景，解决方案和上文提到的保证最终一致性的操作一样，就是把更新缓存的操作以 MQ 消息的方式发送出去，由不同的系统或者专门的一个系统进行订阅，而做聚合的操作。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4594240837696335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDk6GxakNUd7Gia5VOXPs9s3Vj7aO1YEUuEB2SsM5lM7ASr6oPia19LeYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不同业务系统订阅MQ消息单独维护各自的缓存Key&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47368421052631576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDtHXHmQb1SH28bWzquewVMDecoAS9cecdGs7pueIDVXeY1A8aCjjYDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;专门更新缓存的服务订阅MQ消息维护所有相关Key的缓存操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97wd1kjBtWzys9nG2SWzoiabw5V7EdjQsD9xVByPSSQwIdCa4YpoKGZCP5ZbMK6SBl0eqVapQznw0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;通过订阅MySQL binlog的方式处理缓存&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面讲到的 MQ 处理方式需要业务代码里面显式地发送 MQ 消息。还有一种优雅的方式便是订阅 MySQL 的 binlog，监听数据的真实变化情况以处理相关的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如刚刚提到的例子中，如果粉丝又触发打赏了，这时候我们利用 binlog 表监听是能及时发现的，发现后就能集中处理了，而且无论是在什么系统什么位置去更新数据，都能做到集中处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前业界类似的产品有 Canal，具体的操作图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4147651006711409&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDs4B8jltwmUAamAoTO76ZDaib3ibspONEHfucuToF46g95RaX41CQMoKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用Canel订阅数据库binlog变更从而发出MQ消息，让一个专门消费者服务维护所有相关Key的缓存操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到这里，针对大型系统缓存设计如何保证最终一致性，我们已经从策略、场景、操作方案等角度进行了细致的讲述，希望能对你起到帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;点击下方空白 ▼ 查看明日开发者黄历&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDM3RtYXiaicydYd6oAnjecFFekk7QdwJd3v4e33liaTcEYMIic1GBWtEfMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 375 138&quot; opacity=&quot;1&quot;&gt;&lt;svg&gt;&lt;svg&gt;&lt;rect fill=&quot;rgb(254, 254, 254)&quot; x=&quot;0%&quot; y=&quot;0%&quot;/&gt;&lt;/svg&gt;&lt;svg x=&quot;32.80%&quot; y=&quot;335.53%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;summer&lt;/p&gt;&lt;p&gt;time&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;svg x=&quot;61.07%&quot; y=&quot;26.18%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;2022&lt;/p&gt;&lt;p&gt;/&lt;/p&gt;&lt;p&gt;07.23&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;svg x=&quot;22.93%&quot; y=&quot;280.89%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;/svg&gt;&lt;animate fill=&quot;freeze&quot; attributename=&quot;opacity&quot; begin=&quot;click&quot; from=&quot;1&quot; to=&quot;0&quot; dur=&quot;1&quot; restart=&quot;never&quot;/&gt;&lt;animate fill=&quot;freeze&quot; attributename=&quot;width&quot; begin=&quot;click + 1s&quot; from=&quot;1&quot; to=&quot;0&quot; dur=&quot;0.01&quot; restart=&quot;never&quot;/&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0599455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDzmCVibvoCq3NNLJp0pObVR8AcFNFCgxLJj7QKZ5MEZZ7ecic8TVS3dMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;注：本文基于本人博客https://jaskey.github.io/blog/2022/04/14/cache-consistency/&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt; 作者个人邮箱jaskeylin@apache.org，微信：JaskeyLam&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7c0e5d4882eca7b08357e501003bf0b</guid>
<title>重磅出击，20 张图带你彻底了解 ReentrantLock 加锁解锁的原理</title>
<link>https://toutiao.io/k/jyfkfs8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;点击“阿Q说代码”，关注，设为星标&lt;/center&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;每日技术干货，第一时间送达！&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽大家好，我是阿Q。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近是上班忙项目，下班带娃，忙的不可开交，连摸鱼的时间都没有了。今天趁假期用&lt;strong&gt;图解&lt;/strong&gt;的方式从&lt;strong&gt;源码&lt;/strong&gt;角度给大家说一下&lt;code&gt;ReentrantLock&lt;/code&gt;加锁解锁的全过程。系好安全带，发车了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊它的源码之前，我们先来做个简单的使用说明。当我在&lt;code&gt;IDEA&lt;/code&gt;中创建了一个简单的&lt;code&gt;Demo&lt;/code&gt;之后，它会给出以下提示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09851694915254237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpPBhg9teBc79RAt13jsfx2pna3LEdkvS8c5jUVUafakicrIFibLLKPQOwzyibsk4icCBjogcm4qWLn3IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;提示文字&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用阻塞等待获取锁的方式中，必须在&lt;code&gt;try&lt;/code&gt;代码块之外，并且在加锁方法与&lt;code&gt;try&lt;/code&gt;代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在&lt;code&gt;finally&lt;/code&gt;中无法解锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、如果在&lt;code&gt;lock&lt;/code&gt;方法与&lt;code&gt;try&lt;/code&gt;代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、如果&lt;code&gt;lock&lt;/code&gt;方法在&lt;code&gt;try&lt;/code&gt;代码块之内，可能由于其它方法抛出异常，导致在&lt;code&gt;finally&lt;/code&gt;代码块中，&lt;code&gt;unlock&lt;/code&gt;对未加锁的对象解锁，它会调用&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;tryRelease&lt;/code&gt;方法（取决于具体实现类），抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、在&lt;code&gt;Lock&lt;/code&gt;对象的&lt;code&gt;lock&lt;/code&gt;方法实现中可能抛出&lt;code&gt;unchecked&lt;/code&gt;异常，产生的后果与说明二相同。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.concurrent.LockShouldWithTryFinallyRule.rule.desc&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还举了两个例子，正确案例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock lock = &lt;span&gt;new&lt;/span&gt; XxxLock();&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;lock.lock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    doSomething();&lt;br/&gt;    doOthers();&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    lock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误案例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock lock = &lt;span&gt;new&lt;/span&gt; XxxLock();&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 如果在此抛出异常，会直接执行 finally 块的代码&lt;/span&gt;&lt;br/&gt;    doSomething();&lt;br/&gt;    &lt;span&gt;// 不管锁是否成功，finally 块都会执行&lt;/span&gt;&lt;br/&gt;    lock.lock();&lt;br/&gt;    doOthers();&lt;br/&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    lock.unlock();&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AQS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的案例中加锁调用的是&lt;code&gt;lock()&lt;/code&gt;方法，解锁用的是&lt;code&gt;unlock()&lt;/code&gt;方法，而通过查看源码发现它们都是调用的内部静态抽象类&lt;code&gt;Sync&lt;/code&gt;的相关方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;abstract static class Sync extends AbstractQueuedSynchronizer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sync &lt;/code&gt;是通过继承&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;来实现的，没错，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;就是&lt;code&gt;AQS&lt;/code&gt;的全称。&lt;code&gt;AQS&lt;/code&gt;内部维护着一个&lt;code&gt;FIFO&lt;/code&gt;的双向队列（&lt;code&gt;CLH&lt;/code&gt;），&lt;code&gt;ReentrantLock&lt;/code&gt;也是基于它来实现的，先来张图感受下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5121042830540037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pHjNyqyUzooc9ZmbJ15vnaCSBM63hnIXLgYkbibnmEOvwZx7PSmlJPyQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Node 属性&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//此处是 Node 的部分属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//排他锁标识&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//如果带有这个标识，证明是失效了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//具有这个标识，说明后继节点需要被唤醒&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//Node对象存储标识的地方&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; waitStatus;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//指向上一个节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Node prev;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//指向下一个节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Node next;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//当前Node绑定的线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Thread thread;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//返回前驱节点即上一个节点，如果前驱节点为空，抛出异常&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;final&lt;/span&gt; Node &lt;span&gt;predecessor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{&lt;br/&gt;  Node p = prev;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于里边的&lt;code&gt;waitStatus&lt;/code&gt;属性，我们需要做个解释：&lt;strong&gt;（非常重要）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CANCELLED(1)：当前节点取消获取锁。当等待超时或被中断(响应中断)，会触发变更为此状态，进入该状态后节点状态不再变化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SIGNAL(-1)：后面节点等待当前节点唤醒；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONDITION(-2)：&lt;code&gt;Condition&lt;/code&gt;中使用，当前线程阻塞在&lt;code&gt;Condition&lt;/code&gt;，如果其他线程调用了&lt;code&gt;Condition&lt;/code&gt;的&lt;code&gt;signal&lt;/code&gt;方法，这个结点将从等待队列转移到同步队列队尾，等待获取同步锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PROPAGATE(-3)：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;AQS 属性&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 头结点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node head;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 尾结点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node tail;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//0-&amp;gt;1 拿到锁，大于0 说明当前已经有线程占用了锁资源&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们先简单了解下&lt;code&gt;AQS&lt;/code&gt;的构造以帮助大家更好的理解&lt;code&gt;ReentrantLock&lt;/code&gt;，至于深层次的东西先不做展开！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加锁&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;code&gt;AQS&lt;/code&gt;的结构有了基本了解之后，我们正式进入主题——加锁。从源码中可以看出锁被分为&lt;strong&gt;公平锁&lt;/strong&gt;和&lt;strong&gt;非公平锁&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40091743119266054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pgeX5C1jibmET92ZYicT4Z93t0E6gXxWl31WIsIMzrZm6uQ3aoBaQyiaMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 公平锁代码&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 非公平锁代码&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;        setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步查看代码发现非公平锁似乎包含公平锁的逻辑，所以我们就从“非公平锁”开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;非公平锁&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//通过 CAS 的方式尝试将 state 从0改为1，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果返回 true，代表修改成功，获得锁资源;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果返回false，代表修改失败，未获取锁资源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;        &lt;span&gt;// 将属性exclusiveOwnerThread设置为当前线程，该属性是AQS的父类提供的&lt;/span&gt;&lt;br/&gt;        setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;compareAndSetState()&lt;/code&gt;：底层调用的是&lt;code&gt;unsafe&lt;/code&gt;的&lt;code&gt;compareAndSwapInt&lt;/code&gt;，该方法是原子操作；&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个线程（&lt;code&gt;t1&lt;/code&gt;、&lt;code&gt;t2&lt;/code&gt;）在竞争锁资源，线程1获取锁资源之后，执行&lt;code&gt;setExclusiveOwnerThread&lt;/code&gt;操作，设置属性值为当前线程&lt;code&gt;t1&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4702702702702704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pEMmXYa0YJaVFhPF2Eic2dlXqM9E9H3OVsyOVQiarGMQ0MDKUWljSSh4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，当&lt;code&gt;t2&lt;/code&gt;想要获取锁资源，调用&lt;code&gt;lock()&lt;/code&gt;方法之后，执行&lt;code&gt;compareAndSetState(0, 1)&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，会走&lt;code&gt;else&lt;/code&gt;执行&lt;code&gt;acquire()&lt;/code&gt;方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;方法查看&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// tryAcquire 再次尝试获取锁资源，如果尝试成功，返回true，尝试失败返回false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        &lt;span&gt;// 走到这，代表获取锁资源失败，需要将当前线程封装成一个Node，追加到AQS的队列中&lt;/span&gt;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        &lt;span&gt;// 线程中断&lt;/span&gt;&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;accquire()&lt;/code&gt;中涉及的方法比较多，我们将进行拆解，一个一个来分析，顺序：&lt;code&gt;tryAcquire() -&amp;gt; addWaiter() -&amp;gt; acquireQueued()&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 tryAcquire() 方法&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//AQS中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//AQS 是基类，具体实现在自己的类中实现，我们去查看“非公平锁”中的实现&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//ReentrantLock 中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; nonfairTryAcquire(acquires);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;nonfairTryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;br/&gt; &lt;span&gt;//获取AQS 的 state &lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; c = getState();&lt;br/&gt; &lt;span&gt;// 如果 state 为0，代表尝试再次获取锁资源&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;// 步骤同上：通过 CAS 的方式尝试将 state 从0改为1，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//如果返回 true，代表修改成功，获得锁资源;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//如果返回false，代表修改失败，未获取锁资源&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, acquires)) {&lt;br/&gt;   &lt;span&gt;//设置属性为当前线程&lt;/span&gt;&lt;br/&gt;   setExclusiveOwnerThread(current);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;//当前占有锁资源的线程是否是当前线程，如果是则证明是可重入操作&lt;/span&gt;&lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) {&lt;br/&gt;  &lt;span&gt;//将 state + 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; nextc = c + acquires;&lt;br/&gt;  &lt;span&gt;//为什么会小于 0 呢？因为最大值 + 1 后会将符号位的0改为1 会变成负数(可参考Integer.MAX_VALUE + 1)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;// overflow&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;//加1后小于0，超出锁可重入的最大值，抛异常&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;//设置 state 状态&lt;/span&gt;&lt;br/&gt;  setState(nextc);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程1已经获取到了锁，此时&lt;code&gt;state&lt;/code&gt;为1，所以不走&lt;code&gt;nonfairTryAcquire()&lt;/code&gt;的&lt;code&gt;if&lt;/code&gt;。又因为当前是线程2，不是占有当前锁的线程1，所以也不会走&lt;code&gt;else if&lt;/code&gt;，即&lt;code&gt;tryAcquire()&lt;/code&gt;方法返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 addWaiter() 方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;走到本方法中，代表获取锁资源失败。&lt;code&gt;addWaiter()&lt;/code&gt;将没有获取到锁资源的线程甩到队列的尾部。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;addWaiter&lt;/span&gt;&lt;span&gt;(Node mode)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//创建 Node 类，并且设置 thread 为当前线程，设置为排它锁&lt;/span&gt;&lt;br/&gt; Node node = &lt;span&gt;new&lt;/span&gt; Node(Thread.currentThread(), mode);&lt;br/&gt; &lt;span&gt;// 获取 AQS 中队列的尾部节点&lt;/span&gt;&lt;br/&gt; Node pred = tail;&lt;br/&gt; &lt;span&gt;// 如果 tail == null，说明是空队列，&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 不为 null，说明现在队列中有数据，&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;// 将当前节点的 prev 指向刚才的尾部节点，那么当前节点应该设置为尾部节点&lt;/span&gt;&lt;br/&gt;  node.prev = pred;&lt;br/&gt;  &lt;span&gt;// CAS 将 tail 节点设置为当前节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(pred, node)) {&lt;br/&gt;   &lt;span&gt;// 将之前尾节点的 next 设置为当前节点&lt;/span&gt;&lt;br/&gt;   pred.next = node;&lt;br/&gt;   &lt;span&gt;// 返回当前节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; enq(node);&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;tail&lt;/code&gt;不为空，即队列中有数据时，我们来图解一下&lt;code&gt;pred!=null&lt;/code&gt;代码块中的代码。初始化状态如下，&lt;code&gt;pred&lt;/code&gt;指向尾节点，&lt;code&gt;node&lt;/code&gt;指向新的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5639344262295082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pK24dh2HXmuaX0ib4l3gptj34aYl6lLv2GyP83dYVX9ic68ycI78NDNAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;node.prev = pred;&lt;/code&gt;将&lt;code&gt;node&lt;/code&gt;的前驱节点设置为&lt;code&gt;pred&lt;/code&gt;指向的节点&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pg322lJ6Ht8v7ChiaGRjDsa8uObjQ0CfX9od2cjIx957IMEoKCt7XNnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1218&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;compareAndSetTail(pred, node)&lt;/code&gt;通过&lt;code&gt;CAS&lt;/code&gt;的方式尝试将当前节点&lt;code&gt;node&lt;/code&gt;设置为尾结点，此处我们假设设置成功，则&lt;code&gt;FIFO&lt;/code&gt;队列的&lt;code&gt;tail&lt;/code&gt;指向&lt;code&gt;node&lt;/code&gt;节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5475223395613322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pOwXUliaGvl5u3CPnaDzOWx4Tcfp7c882KiaicljNjVSxjxFbweGmAwRuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1231&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pred.next = node;&lt;/code&gt;将&lt;code&gt;pred&lt;/code&gt;节点的后继节点设置为&lt;code&gt;node&lt;/code&gt;节点，此时&lt;code&gt;node&lt;/code&gt;节点成功进入&lt;code&gt;FIFO&lt;/code&gt;队列尾部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5646586345381526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pGKibxvmluEgZnLZicDgq1eyL3AiaamnT3QOPLko8nolibG9c6eEzJgiaRxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当&lt;code&gt;pred&lt;/code&gt;为空，即队列中没有节点或将&lt;code&gt;node&lt;/code&gt;节点设置为尾结点失败时，会走&lt;code&gt;enq()&lt;/code&gt;方法。我们列举的例子就符合&lt;code&gt;pred&lt;/code&gt;为空的情况，就让我们以例子为基础继续分析吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//现在没人排队，我是第一个 || 前边CAS失败也会进入这个位置重新往队列尾巴去塞&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;enq&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//死循环&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;  &lt;span&gt;//重新获取tail节点&lt;/span&gt;&lt;br/&gt;  Node t = tail;&lt;br/&gt;  &lt;span&gt;// 没人排队，队列为空&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;// 初始化一个 Node 为 head，而这个head 没有意义&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt; Node()))&lt;br/&gt;    &lt;span&gt;// 将头尾都指向了这个初始化的Node，第一次循环结束&lt;/span&gt;&lt;br/&gt;    tail = head;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 有人排队，往队列尾巴塞&lt;/span&gt;&lt;br/&gt;   node.prev = t;&lt;br/&gt;   &lt;span&gt;// CAS 将 tail 节点设置为当前节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(t, node)) {&lt;br/&gt;    &lt;span&gt;//将之前尾节点的 next 设置为当前节点&lt;/span&gt;&lt;br/&gt;    t.next = node;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入死循环，首先会走&lt;code&gt;if&lt;/code&gt;方法的逻辑，通过&lt;code&gt;CAS&lt;/code&gt;的方式尝试将一个新节点设置为&lt;code&gt;head&lt;/code&gt;节点，然后将&lt;code&gt;tail&lt;/code&gt;也指向新节点。可以看出队列中的头节点只是个初始化的节点，没有任何意义。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.574487895716946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pXETtXibjDQMYusCF8OSdeJFywFdyo0WR3XjYjKKNQLe8WDoPWL3lMzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续走死循环中的代码，此时&lt;code&gt;t&lt;/code&gt;不为&lt;code&gt;null&lt;/code&gt;，所以会走&lt;code&gt;else&lt;/code&gt;方法。将&lt;code&gt;node&lt;/code&gt;的前驱节点指向&lt;code&gt;t&lt;/code&gt;，通过&lt;code&gt;CAS&lt;/code&gt;方式将当前节点&lt;code&gt;node&lt;/code&gt;设置为尾结点，然后将&lt;code&gt;t&lt;/code&gt;的后继节点指向&lt;code&gt;node&lt;/code&gt;。此时线程2的节点就被成功塞入&lt;code&gt;FIFO&lt;/code&gt;队列尾部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6016949152542372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pyibKScicqpShhDYKBfwWrHSJWGa5lCqa90G2M0miaOTcgt7VSQLvA7Guw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 acquireQueued()方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将已经在队列中的&lt;code&gt;node&lt;/code&gt;尝试去获取锁否则挂起。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;acquireQueued&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取锁资源的标识,失败为 true，成功为 false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 线程中断的标识，中断为 true，不中断为 false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;   &lt;span&gt;// 获取当前节点的上一个节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;   &lt;span&gt;//p为头节点，尝试获取锁操作&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;    setHead(node);&lt;br/&gt;    p.next = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 将获取锁失败标识置为false&lt;/span&gt;&lt;br/&gt;    failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 获取到锁资源，不会被中断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// p 不是 head 或者 没拿到锁资源，&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;    &lt;span&gt;// 基于 Unsafe 的 park方法，挂起线程&lt;/span&gt;&lt;br/&gt;    parkAndCheckInterrupt())&lt;br/&gt;    interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (failed)&lt;br/&gt;   cancelAcquire(node);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里又出现了一次死循环，首先获取当前节点的前驱节点p，如果p是头节点(头节点没有意义)，说明&lt;code&gt;node&lt;/code&gt;是&lt;code&gt;head&lt;/code&gt;后的第一个节点，此时当前获取锁资源的线程1可能会释放锁，所以线程2可以再次尝试获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设获取成功，证明拿到锁资源了，将&lt;code&gt;node&lt;/code&gt;节点设置为&lt;code&gt;head&lt;/code&gt;节点，并将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;pre&lt;/code&gt;和&lt;code&gt;thread&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。因为拿到锁资源了，&lt;code&gt;node&lt;/code&gt;节点就不需要排队了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将头节点p的&lt;code&gt;next&lt;/code&gt;置为&lt;code&gt;null&lt;/code&gt;，此时p节点就不在队列中存在了，可以帮助&lt;code&gt;GC&lt;/code&gt;回收(可达性分析)。&lt;code&gt;failed&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;，表明获取锁成功；&lt;code&gt;interrupted&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，则线程不会中断。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2p6Th6NW86sGRdwk9gOrjx63bHRhqrwzHOLAjTDVVBZco7qoa44FbKYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1050&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果p不是&lt;code&gt;head&lt;/code&gt;节点或者没有拿到锁资源，会执行下边的代码，因为我们的线程1没有释放锁资源，所以线程2获取锁失败，会继续往下执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//该方法的作用是保证上一个节点的waitStatus状态为-1（为了唤醒后继节点）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;shouldParkAfterFailedAcquire&lt;/span&gt;&lt;span&gt;(Node pred, Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//获取上一个节点的状态,该状态为-1，才会唤醒下一个节点。&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; ws = pred.waitStatus;&lt;br/&gt; &lt;span&gt;// 如果上一个节点的状态是SIGNAL即-1，可以唤醒下一个节点，直接返回true&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws == Node.SIGNAL)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;// 如果上一个节点的状态大于0，说明已经失效了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 将node 的节点与 pred 的前一个节点相关联，并将前一个节点赋值给 pred&lt;/span&gt;&lt;br/&gt;   node.prev = pred = pred.prev;&lt;br/&gt;  } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;// 一直找到小于等于0的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 将重新标识好的最近的有效节点的 next 指向当前节点&lt;/span&gt;&lt;br/&gt;  pred.next = node;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 小于等于0，但是不等于-1，将上一个有效节点状态修改为-1&lt;/span&gt;&lt;br/&gt;  compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;只有节点的状态为-1，才会唤醒后一个节点，如果节点状态未设置，默认为0。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图解一下&lt;code&gt;ws&amp;gt;0&lt;/code&gt;的过程，因为&lt;code&gt;ws&amp;gt;0&lt;/code&gt;的节点为失效节点，所以&lt;code&gt;do...while&lt;/code&gt;中会重复向前查找前驱节点，直到找到第一个&lt;code&gt;ws&amp;lt;=0&lt;/code&gt;的节点为止，将&lt;code&gt;node&lt;/code&gt;节点挂到该节点上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.611965811965812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2piaOhg4jjiaUUv4HpfRt8VEo90Qv8aROA6LIeWpdnCWKtUndcSQmEppFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的&lt;code&gt;pred&lt;/code&gt;是头结点且未设置状态，所以状态为0，会走&lt;code&gt;else&lt;/code&gt;。通过&lt;code&gt;CAS&lt;/code&gt;尝试将&lt;code&gt;pred&lt;/code&gt;节点的&lt;code&gt;waitStatus&lt;/code&gt;设置为-1，表明&lt;code&gt;node&lt;/code&gt;节点需要被&lt;code&gt;pred&lt;/code&gt;唤醒。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6170009551098377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pcoxEbW5zPHyqDOE7DPElqmiawJQfrMoFU0MuwAVf6tsRjjP4JgxP34A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1047&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，继续执行&lt;code&gt;acquireQueued()&lt;/code&gt;中的死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤和上边一样，&lt;code&gt;node&lt;/code&gt;的前驱节点还是&lt;code&gt;head&lt;/code&gt;，继续尝试获取锁。如果线程1释放了锁，线程2就可以拿到，返回&lt;code&gt;true&lt;/code&gt;；否则继续调用&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;，因为上一步已经将前驱结点的&lt;code&gt;ws&lt;/code&gt;设置为-1了，所以直接返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法，通过&lt;code&gt;UNSAFE.park();&lt;/code&gt;方法阻塞当前线程2。等以后执行&lt;code&gt;unpark&lt;/code&gt;方法的时候，如果&lt;code&gt;node&lt;/code&gt;是头节点后的第一个节点，会进入&lt;code&gt;acquireQueued()&lt;/code&gt;方法中走&lt;code&gt;if (p == head &amp;amp;&amp;amp; tryAcquire(arg))&lt;/code&gt;的逻辑获取锁资源并结束死循环。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看cancelAcquire()方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法执行的机率约等于0，为什么这么说呢？因为针对&lt;code&gt;failed&lt;/code&gt;属性，只有&lt;code&gt;JVM&lt;/code&gt;内部出现问题时，才可能出现异常，执行该方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// node 为当前节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;cancelAcquire&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt; node.thread = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;// 上一个节点&lt;/span&gt;&lt;br/&gt; Node pred = node.prev;&lt;br/&gt; &lt;span&gt;// 节点状态大于0，说明节点失效&lt;/span&gt;&lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  node.prev = pred = pred.prev;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 将第一个不是失效节点的后继节点声明出来&lt;/span&gt;&lt;br/&gt; Node predNext = pred.next;&lt;br/&gt; &lt;span&gt;// 节点状态变为失效&lt;/span&gt;&lt;br/&gt; node.waitStatus = Node.CANCELLED;&lt;br/&gt; &lt;span&gt;// node为尾节点，cas设置pred为尾节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {&lt;br/&gt;  &lt;span&gt;//cas将pred的next设置为null&lt;/span&gt;&lt;br/&gt;  compareAndSetNext(pred, predNext, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ws;&lt;br/&gt;  &lt;span&gt;// 中间节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 如果上一个节点不是head 节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (pred != head &amp;amp;&amp;amp;&lt;br/&gt;   ((ws = pred.waitStatus) == Node.SIGNAL ||&lt;br/&gt;    &lt;span&gt;// 前边已经判断了大于0的操作，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// pred 是需要唤醒后继节点的，所以当 waitStatus 不为 -1 时，需要将 pred 节点的 waitStatus 设置为 -1 &lt;/span&gt;&lt;br/&gt;    (ws &amp;lt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;&lt;br/&gt;   pred.thread != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   Node next = node.next;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (next != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; next.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// CAS 尝试将 pred 的 next 指向当前节点的 next&lt;/span&gt;&lt;br/&gt;    compareAndSetNext(pred, predNext, next);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// head 节点，唤醒后继节点&lt;/span&gt;&lt;br/&gt;   unparkSuccessor(node);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  node.next = node; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行到&lt;code&gt;while&lt;/code&gt;时找到前驱节点中最近的有效节点，把当前节点&lt;code&gt;node&lt;/code&gt;挂到有效节点后边，可以过滤掉当前节点前的失效节点。声明出有效节点的第一个后继无效节点&lt;code&gt;predNext&lt;/code&gt;，并把当前的&lt;code&gt;node&lt;/code&gt;节点状态设置为失效状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4808219178082192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pcKWLnKoEh33VAmssQQqeRXZHua57kN08fSUP1BObsiabRxVVcLN5vcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;730&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;if&lt;/code&gt;中的操作：如果当前节点是尾节点，&lt;code&gt;CAS&lt;/code&gt;尝试将最近的有效节点设置为尾节点，并将尾节点的&lt;code&gt;next&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3598901098901099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pazKPf17j7RyjZVplaCcv8bOkVqfPBavYiawhshybAMwPgHic4LSu6tiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1092&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;else&lt;/code&gt;中的操作：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;pred&lt;/code&gt;节点不是头结点即中间节点，并且&lt;code&gt;pred&lt;/code&gt;的&lt;code&gt;waitStatus&lt;/code&gt;为-1或者&lt;code&gt;waitStatus&amp;lt;=0&lt;/code&gt;，为了让&lt;code&gt;pred&lt;/code&gt;节点能唤醒后继节点，需要设置为-1，并且&lt;code&gt;pred&lt;/code&gt;节点的线程不为空。获取&lt;code&gt;node&lt;/code&gt;节点的后继节点，如果后继节点有效，&lt;code&gt;CAS&lt;/code&gt;尝试将&lt;code&gt;pred&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;指向&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2698289269051322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2p9kZicgQriauOUbSbf6BUtRYFtTFPedG3CyicjZGIcMegU4R4HmOxjHsicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当其他节点来找有效节点的时候走当前&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;prev&lt;/code&gt;这条线，而不是再一个一个往前找，可以提高效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是头结点则唤醒后继节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;next&lt;/code&gt;指向自己。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解锁&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁是不区分公平锁和非公平锁的，释放锁的核心是将&lt;code&gt;state&lt;/code&gt;由大于 0 的数置为 0。废话不多说，直接上代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//释放锁方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; sync.release(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//尝试释放锁资源，如果释放成功，返回true&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;br/&gt;  Node h = head;&lt;br/&gt;  &lt;span&gt;// head 不为空且 head 的 ws 不为0（如果为0，代表后边没有其他线程挂起）&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// AQS的队列中有 node 在排队，并且线程已经挂起&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 需要唤醒被挂起的 Node&lt;/span&gt;&lt;br/&gt;   unparkSuccessor(h);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 代表释放一次没有完全释放&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果释放锁成功，需要获取&lt;code&gt;head&lt;/code&gt;节点。如果头结点不为空且&lt;code&gt;waitStatus&lt;/code&gt;不为0，则证明有&lt;code&gt;node&lt;/code&gt;在排队，执行唤醒挂起其他&lt;code&gt;node&lt;/code&gt;的操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;查看tryRelease()方法&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryRelease&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; releases)&lt;/span&gt; &lt;/span&gt;&lt;span&gt;{&lt;br/&gt; &lt;/span&gt;&lt;span&gt;//获取当前锁的状态，先进行减1操作，代表释放一次锁资源&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c = getState() - releases;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;//如果释放锁的线程不是占用锁的线程，直接抛出异常&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.currentThread() != getExclusiveOwnerThread())&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();&lt;br/&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; free = &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;// 如果 c 为0 ，代表锁完全释放了，如果不为0，代表锁之前重入了，一次没释放掉，等待下次再次执行时，再次判断&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (c == &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;// 释放锁标志为 true，代表完全释放了&lt;/span&gt;&lt;span&gt;&lt;br/&gt;  free = &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;// 将占用互斥锁的标识置为 null&lt;/span&gt;&lt;span&gt;&lt;br/&gt;  setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;// 设置 state 状态&lt;/span&gt;&lt;span&gt;&lt;br/&gt; setState(c);&lt;br/&gt; &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;&lt;br/&gt;}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的例子中线程1占用锁资源，线程1释放锁之后，&lt;code&gt;state&lt;/code&gt;为0。进入&lt;code&gt;if&lt;/code&gt;操作，将释放标志更新为&lt;code&gt;true&lt;/code&gt;，将&lt;code&gt;FIFO&lt;/code&gt;队列的&lt;code&gt;exclusiveOwnerThread&lt;/code&gt;标志置为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5366079703429101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pZYdxaoOTX1y38TicBhpDDgm3P3DsuRiaC7kk7nEAZfSzGUSUwb4G2DVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;查看unparkSuccessor()方法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于唤醒&lt;code&gt;AQS&lt;/code&gt;中被挂起的线程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 注意当前的 node 节点是 head 节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unparkSuccessor&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//获取 head 的状态&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; ws = node.waitStatus;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// CAS 将 node 的 ws 设置为0，代表当前 node 接下来会舍弃&lt;/span&gt;&lt;br/&gt;  compareAndSetWaitStatus(node, ws, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 获取头节点的下一个节点&lt;/span&gt;&lt;br/&gt; Node s = node.next;&lt;br/&gt; &lt;span&gt;// 如果下一个节点为null 或者 下一个节点为失效节点，需要找到离 head 最近的有效node&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  s = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 从尾节点开始往前找不等于null且不是node的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.prev)&lt;br/&gt;   &lt;span&gt;// 如果该节点有效，则将s节点指向t节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    s = t;&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 找到最近的node后，直接唤醒&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  LockSupport.unpark(s.thread);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;问题解析：为什么要从尾结点往前查找呢？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在&lt;code&gt;addWaiter&lt;/code&gt;方法中是先给&lt;code&gt;prev&lt;/code&gt;指针赋值，最后才将上一个节点的&lt;code&gt;next&lt;/code&gt;指针赋值，为了避免防止丢失节点或者跳过节点，必须从后往前找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们举例中&lt;code&gt;head&lt;/code&gt;节点的状态为&lt;code&gt;-1&lt;/code&gt;，通过&lt;code&gt;CAS&lt;/code&gt;的方式将&lt;code&gt;head&lt;/code&gt;节点的&lt;code&gt;waitStatus&lt;/code&gt;设置为0。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6102514506769826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pOCBpJLJ0sBHiaZWLLibje87Znicia24v9Rl7tZaV6bz9wDMZ4ETBu2BG5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1034&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的头结点的后继节点是线程2所在的节点，不为&lt;code&gt;null&lt;/code&gt;，所以这边会执行&lt;code&gt;unpark&lt;/code&gt;操作，从上边的&lt;code&gt;acquireQueued()&lt;/code&gt;内的&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法继续执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;parkAndCheckInterrupt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LockSupport.park(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//返回目标线程是否中断的布尔值:中断返回true，不中断返回false，且返回后会重置中断状态为未中断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Thread.interrupted();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程2未中断，所以返回&lt;code&gt;false&lt;/code&gt;。继续执行&lt;code&gt;acquireQueued()&lt;/code&gt;中的死循环&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;    &lt;span&gt;// 获取当前节点的上一个节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;    &lt;span&gt;//p为头节点，尝试获取锁操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;        setHead(node);&lt;br/&gt;        p.next = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 将获取锁失败标识置为false&lt;/span&gt;&lt;br/&gt;        failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 获取到锁资源，不会被中断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// p 不是 head 或者 没拿到锁资源，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;        &lt;span&gt;// 基于 Unsafe 的 park方法，挂起线程&lt;/span&gt;&lt;br/&gt;        parkAndCheckInterrupt())&lt;br/&gt;        interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时p是头节点，且能获取锁成功，将&lt;code&gt;exclusiveOwnerThread&lt;/code&gt;设置为线程2，即线程2 获取锁资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将&lt;code&gt;node&lt;/code&gt;节点设置为&lt;code&gt;head&lt;/code&gt;节点，并将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;pre&lt;/code&gt;和&lt;code&gt;thread&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。因为拿到锁资源了，&lt;code&gt;node&lt;/code&gt;节点就不需要排队了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将头节点p的&lt;code&gt;next&lt;/code&gt;置为&lt;code&gt;null&lt;/code&gt;，此时p节点就不在队列中存在了，可以帮助&lt;code&gt;GC&lt;/code&gt;回收(可达性分析)。&lt;code&gt;failed&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;，表明获取锁成功；&lt;code&gt;interrupted&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，则线程不会中断。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7521367521367521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2puqyW9XU80hIsibda5MhdvZRnXNsAjXlkpnwDiaP7rUwzxFojHmfmZIDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;936&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;为什么被唤醒的线程要调用Thread.interrupted()清除中断标记&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上边的方法可以看出，当&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;时，即&lt;code&gt;Thread.interrupted()&lt;/code&gt;方法返回了&lt;code&gt;true&lt;/code&gt;，也就是该线程被中断了。为了让被唤醒的线程继续执行后续获取锁的操作，就需要让中断的线程像没有被中断过一样继续往下执行，所以在返回中断标记的同时要清除中断标记，将其设置为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清除中断标记之后不代表该线程不需要中断了，所以在&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;时，要自己设置一个中断标志&lt;code&gt;interrupted = true&lt;/code&gt;，为的就是当获取到锁资源执行完相关的操作之后进行中断补偿，故而需要执行&lt;code&gt;selfInterrupt()&lt;/code&gt;方法中断线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们加锁解锁的图解过程了。最后我们再来说一下公平锁和非公平锁的区别。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;区别&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边已经说过了，似乎非公平锁包含了公平锁的全部操作。打开公平锁的代码，我们发现&lt;code&gt;accquire()&lt;/code&gt;方法中只有该方法的实现有点区别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8236040609137056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pibtvDzPzQG1odBkib7PrsgC0f8riaJQTQpq7u0vjbfyJncE0MlPB6EBBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hasQueuedPredecessors()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;时才会尝试获取锁资源。该方法代码实现如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasQueuedPredecessors&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Node t = tail; &lt;br/&gt;    Node h = head;&lt;br/&gt;    Node s;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; h != t &amp;amp;&amp;amp;&lt;br/&gt;        ((s = h.next) == &lt;span&gt;null&lt;/span&gt; || s.thread != Thread.currentThread());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;h==t&lt;/code&gt;时，队列为空，表示没人排队，可以获取锁资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列不为空，头结点有后继节点不为空且s节点获取锁的线程是当前线程也可以获取锁资源，代表锁重入操作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们的全部内容了，我们在最后再做个总结：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码使用要合乎规范，避免加锁成功后，在&lt;code&gt;finally&lt;/code&gt;中无法解锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;理解&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;FIFO&lt;/code&gt;队列以及&lt;code&gt;Node&lt;/code&gt;的相关属性，尤其注意&lt;code&gt;waitStatus&lt;/code&gt;的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用图加深对非公平锁源码的理解；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31427bc13e77fa17f0aa374d289eb27a</guid>
<title>我画了 42 张图爆肝 Nacos 源码，跟着看一遍保证大家都学废了</title>
<link>https://toutiao.io/k/6s1twtt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;「 &lt;/strong&gt;关注&lt;/span&gt;&lt;span&gt;&lt;strong&gt;“石杉的架构笔记”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大厂架构经验&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;倾囊相授&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;strong&gt;」&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLbJbVwpE6KkQ3uSdUskKzrUSMYhGU1tKgaSdvUvXOicExwsSQjoiaIxA2av43tbR9mmjlibQaiaeunhOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文章来源：【公众号：&lt;/span&gt;&lt;span&gt;CodeFox&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GHDOauYyUGbiaHXGx1ib5UxkKzSNtpMzY5tbbGdibG7icBSxlH783x1YTF0icAv8MWrmanB4u5qjyKfmYo1dDf7YbA/640?wx_fmt=gif&quot; data-w=&quot;100&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家好，这篇文章跟大家聊下 SpringCloudAlibaba 中的微服务组件 Nacos。&lt;/span&gt;&lt;span&gt;Nacos 既能做注册中心，又能做配置中心，这篇文章主要来聊下做配置中心时 client 端的一些设计，主要从源码层面进行分析，相信看完这篇文章你对 Nacos client 端的工作原理应该有比较深刻的了解。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;SpringCloud 应用启动拉去配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们之前写过一篇文章，介绍了一些 Spring 提供的扩展机制。其中说到了 &lt;strong&gt;ApplicationContextInitializer&lt;/strong&gt;，该扩展是在上下文准备阶段（prepareContext），容器刷新之前做一些初始化工作，比如我们常用的配置中心 client 基本都是继承该初始化器，在容器刷新前将配置从远程拉到本地，然后封装成 PropertySource 放到 Environment 中供使用。&lt;/p&gt;&lt;p&gt;在 SpringCloud 场景下，SpringCloud 规范中提供了 PropertySourceBootstrapConfiguration 继承 ApplicationContextInitializer，另外还提供了个 PropertySourceLocator，二者配合完成配置中心的接入。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.958904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVuS86eYnAKicqZtzgDDsnAJ90H96KMQeWgKibCfKiccFA4mtiafpSjLvhxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上述截图可以看出，在 PropertySourceBootstrapConfiguration 这个单例对象初始化的时候会将 Spring 容器中所有的 PropertySourceLocator 实现注入进来。然后在 initialize 方法中循环所有的 PropertySourceLocator 进行配置的获取，从这儿可以看出 SpringCloud 应用是支持我们引入多个配置中心实现的，获取到配置后调用 insertPropertySources 方法将所有的 PropertySource（封装的一个个配置文件）添加到 Spring 的环境变量 environment 中。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33719704952581664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVaKbszAEibpZiciazLAVxah619tjj1UlmOjVbHJErIep50SV4Ro9dz981w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图展示了在 spring-cloud-starter-alibaba-nacos-config 包提供的自动装配类中进行了 NacosPropertySourceLocator 的定义，该类继承自上述说的 PropertySourceLocator，重写了 locate 方法进行配置的读取。&lt;/p&gt;&lt;p&gt;我们来分析下 NacosPropertySourceLocator，locate 方法只提取了主要流程代码，可以看到 Nacos 启动会加载以下三种配置文件，也就是我们在 bootstrap.yml 文件里配置的扩展配置 extension-configs、共享配置 shared-configs 以及应用自己的配置，加载到配置文件后会封装成 NacosPropertySource 返回。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4268867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVzIYX5ytGyibuP7zQib2Yv1kwhet9nt0UUa5gaX2cAd1OicVuDwsUvR57w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; PropertySource&amp;lt;?&amp;gt; locate(Environment env) {&lt;br/&gt;        &lt;span&gt;// 生成 NacosConfigService 实例，后续配置操作都是围绕该类进行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ConfigService&lt;/span&gt; &lt;span&gt;configService&lt;/span&gt; = nacosConfigManager.getConfigService();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == configService) {&lt;br/&gt;            log.warn(&lt;span&gt;&quot;no instance of config service found, can&#x27;t load config from nacos&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; &lt;span&gt;timeout&lt;/span&gt; = nacosConfigProperties.getTimeout();&lt;br/&gt;        &lt;span&gt;// 配置获取（使用 configService）、配置封装、配置缓存等操作&lt;/span&gt;&lt;br/&gt;        nacosPropertySourceBuilder = &lt;span&gt;new&lt;/span&gt; NacosPropertySourceBuilder(configService,&lt;br/&gt;                timeout);&lt;br/&gt;        &lt;span&gt;CompositePropertySource&lt;/span&gt; &lt;span&gt;composite&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; CompositePropertySource(&lt;br/&gt;                NACOS_PROPERTY_SOURCE_NAME);&lt;br/&gt;        loadSharedConfiguration(composite);&lt;br/&gt;        loadExtConfiguration(composite);&lt;br/&gt;        loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; composite;&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;loadApplicationConfiguration 加载应用配置时，同时会加载以下三种配置，分别是&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 不带扩展名后缀，application&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 带扩展名后缀，application.yml&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 带环境，带扩展名后缀，application-prod.yml&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;并且从上到下，优先级依次增高&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6292725679228747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVXylL6RS4yojytPZF0sYWf56q6R0knRgKt9gg8DOTqzPhAWiavqficpqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1141&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;加载的核心方法是 loadNacosDataIfPresent -&amp;gt; loadNacosPropertySource&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3842887473460722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVeqlCiajwStUxYDYO4uhibRQxJBaIFzyibKRhJVbsiaVnxey4QkMQ9AQ2NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;build 方法调用 loadNacosData 获取配置，然后封装成 NacosPropertySource，并且将该对象缓存到 NacosPropertySourceRepository 中，后续会用到。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3415559772296015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVwydUdEl9eOYneJmF0BsFyyK9TwZDriaVxtKbqk8EaqNliak6KmWJaATw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23814773980154355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVd7kMyBuL3JF1CJC5FVLgCcJsLaibGiabgHBFzX88ibYvddwgePohEjq7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;loadNacosData 方法中会将实际配置加载请求委托给 configService 去做，然后解析返回的字符串，解析器实现了 PropertySourceLoader 接口，支持 yml、properties、xml、json 这几种。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7071197411003236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVicprCwNiac2kuD4ytz61PSW7EVzfx7sCXFN3DwhnoEOVURLYO4wfpsWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;getConfig 方法会调用到 getConfigInner 方法，通过 namespace, dataId, group 唯一定位一个配置文件&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 首先获取本地缓存文件的配置内容，如果有直接返回&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 如果步骤 1 从本地没找到相应配置文件，开始从远处拉去，Nacos 2.0 以上版本使用 Grpc 协议进行远程通信，1.0 及以下使用 Http 协议进行远程通信，我们这边以 1.x 为例来解读&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7729166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVSicD7b2UnlmfbFa53LpZ1eKF1ySTMZTpItpSCWT0XoD21rCKcCYdpgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;getServerConfig 方法会构造最终的 http 请求参数进行调用，如果返回 ok，则将返回内容写入到本地缓存文件中，并进行返回。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8301620859760395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKKJeAmoAgSIL2As8Ziah3fJcfNaOmYHWRq6ibFXAQHUoLqHIHgqic8D1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1419&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;至此，在项目启动的时候（上下文准备阶段）我们就拉到了远程 Nacos 中的配置，并且封装成 NacosPropertySource 放到了 Spring 的环境变量里。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;监听器注册&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;上面章节我们说了服务启动的时候从远程 Nacos 服务端拉到配置，这个章节我们来说下配置变动怎么实时通知到客户端，首先需要注册监听器。&lt;/p&gt;&lt;p&gt;主要看 NacosContextRefresher 类，该类会监听服务启动发布的 ApplicationReadyEvent 事件，然后进行配置监听器的注册。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7611940298507462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVmzjghRNHyxHgdQsuZEj2AFdg2xGACuCEKR5O0xqqwhqOhQnAemiaMNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;registerNacosListenersForApplications 方法里会进行判断，如果自动刷新机制是开启的，则进行监听器注册。上个章节我们说到了会将拉到的配置缓存到 NacosPropertySourceRepository 中， 这儿就从缓存中获取所有的配置，然后循环进行监听器注册（如果配置文件中配置 refresh 字段为 false，则不注册监听器）。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVBdBd3n0xMjIibG9pQ0WaqQDFnLNz5r4ibhtp7kyl3q2YrkXDBWWN9Bjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以看到，监听器是以 dataId + groupId + namespace 为维度进行注册的，监听器的主要操作就三步。&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. REFRESH_COUNT ++，在上述说的 loadNacosPropertySource 方法有用到&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 往 NacosRefreshHistory#records 中添加一条刷新记录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 发布一个 RefreshEvent 事件，该事件是 SpringCloud 提供的，主要就是用来做环境变更刷新用的&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6911447084233261&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVS2Cd6O1uNwbgNEKNibVCRKECicv68udbZDJicicH9ex3qb94ickib3uc0Nxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注册操作经过 ConfigService，在 ClientWorker 中处理，这块会创建一个 CacheData 对象，该对象主要就是用来管理监听器的，也是非常重要的一个类。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38177874186550975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVoh5Clbho2nVIml1JSq4k5PEQoFx7RSNnaQDomycUQEtrguuFwADhpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;CacheData 中字段如下图，ManagerListenerWrap 对 Listener 做层包装，内部会保存 listener、上次变更的 content 以及 md5（用来判断配置有没有变更用）。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4104401228249744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVTWIKnArwgWD218PA9bKKribJeX2eISdf4tDCJ5gCD2gbmMwJqTjpzKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7438650306748467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVNa9BTxbkGTGibRahfpVvM3XT1xGHxDicrAnCmEQPotP99HVQMvb4QK8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;并且在 addCacheDataIfAbsent 方法中会将刚才创建的 CacheData 缓存到 ClientWorker 中的一个 Map 中，后续会用到。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2682926829268293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVwOXpvrluN1scqm8jzNOU7ibVnZfSRZBPLDUNJK2cERvrAgsOPrrCwvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，在服务启动后向每一个需要支持热更新的配置都注册了一个监听器，用来监听远程配置的变动，以及做相应的处理&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;配置热更新&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面章节我们讲了服务启动的时候从远程 Nacos 服务端拉到配置，以及服务启动后对需要支持热更新的配置都注册了一个监听器，这个章节我们来说下配置变动后具体是怎么处理的。&lt;/p&gt;&lt;p&gt;回到上述说过的 NacosPropertySourceLocator 的 locate 方法看看，该方法首先会获取一个 ConfigService。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39567430025445294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVeSlYBnicAicNeGG6bec1QCdbcpoMHa6iblZh5EpTYvILuzXarVLbgccjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;NacosConfigManager 中会进行一个 ConfigService 单例对象的创建，创建流程最终会委托给 ConfigFactory，使用反射方式创建一个 NacosConfigService 的实例对象，NacosConfigService 是一个很核心的类，配置的获取，监听器的注册都需要经此。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48662041625371655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVgOZlsPn1xsSSBajl9AEGwKll4Sl72uiasBL6QflEYT3DFLc251EaiaeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们看下 NacosConfigService 的构造函数，会去创建一个 ClientWorker 类的对象，这个类是实现配置热更新的核心类。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42528735632183906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVp5VPaDsOa3sOGgemKdvVZOY6eYKZLPHFI6SrvQ8ClgGdAUMb1mf0JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ClientWorker 的构造函数里会去创建两个线程池，executor 会每隔 10ms 进行一次配置变更的检查，executorService 主要是用来处理长轮询请求的。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.920314253647587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVibeJNGcMErvlRfc1fOwKc2u4ClSs4PzO2S7a1o4YmWYickpHaqztiaPxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;checkConfigInfo 方法中会创建一个长轮询任务丢到 executorService 线程池中去处理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47085201793721976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVMTB3amtvl9FfHE9USIsVHZoqibVDGO3D7df1S0KerBeRTMgNfmK2mUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;LongPollingRunnable 的 run 方法代码有点多，主要流程如下：&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 获取上个章节中说到的缓存 cacheMap，然后遍历，判断如果该配置使用的是本地缓存模式，则调用 checkListenerMd5 去检查读到的本地缓存文件中内容的 Md5 跟上次更新的 Md5 是不是一样，不一样则调用 safeNotifyListener 去通知监听器处理，并且更新 listenerWrap 中的 content、Md5&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6317241379310344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVkaFjZ3jbVcVYcX6hMk351OnsDicG1nwALDRHDQBxkOX9O6hzrDog3pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. checkUpdateDataIds 该方法中，会将所有的 dataId 按定义格式拼接出一个字符串，构造一个长轮询请求，发给服务端，Long-Pulling-Timeout 超时时间默认 30s，如果服务端没有配置变更，则会保持该请求直到超时，有配置变更则直接返回有变更的 dataId 列表。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6905286343612335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVPPPFDqb9micuqKfJrlTOH4kjFHdh7sGrBq86AXkMicq0AJrDPy5VXU6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 拿到第二步有变更的 dataId 后会调用 getServerConfig 获取最新的配置内容，然后遍历调用 checkListenerMd5 去检查最新拉取的配置内容的 Md5 跟上次更新的 Md5 是不是一样，不一样则调用 safeNotifyListener 去通知监听器处理，并且更新 listenerWrap 中的 content、Md5&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6696629213483146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVRdlm9Dnvp773YA1QMAuiblKsIwwiaewzBfcndAMuM83bGTVGBNZcVcqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;checkListenerMd5 方法如下，主要就是判断两个 md5 是不是相同，不同则调用 safeNotifyListener 处理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25949367088607594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVn9T4H91icaLfNqPUhcLOQBzj96QzlS6RiaE327ibko4XupfNLMbI8cuJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;790&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;safeNotifyListener 方法主要就是调用监听器的 receiveConfigInfo 方法，然后更新监听器包装器中的 lastContent、lastCallMd5 字段。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8957894736842106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVjkO92az6NEOUmQ87X7aaw5PKvpWkI9OOSia6NiblQQlJ0d3oMUmoibR9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;监听器要执行的方法我们上面也已经讲过了，这边再贴下截图，主要就是发布 RefreshEvent 事件。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6380434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVr0pno3XVRcDu1F8ZTdUDlIw6ZRTyazQMaC6QF8LOAseel0qHcfpGVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，Nacos 的处理流程已经结束了，RefreshEvent 事件主要由 SpringCloud 相关类来处理。&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;RefreshEvent 事件处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;RefreshEvent 事件会由 RefreshEventListener 来处理，该 listener 含有一个 ContextRefresher 的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7460484720758693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKg2khnphUeBgNpUVpHP0tuUAsfleRb2J6RVp2DA7HfpAtqPXoEg2Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;949&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如下图所示，refreshEnvironment 会去刷新 Spring 环境变量，实际上是交给 updateEnvironment 方法去做的刷新，具体刷新思想就是重新创建一个 Spring 容器，然后将这个新容器中的环境信息设置到原有的 Spring 环境中。拿到所有变化的配置项后，发布一个环境变化的 EnvironmentChangeEvent 事件。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4802494802494803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVUZiaEC1oggzA1sv3pBOkjcTibMPOrPe7YzV6hWAtyQlHmA8NXA5dwPZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7754459601259182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVjfETff9ibicvpK3iaJMG2dWpMeRUxuq8CkpdJhxNicZz4eDmlHp2KCV7Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ConfigurationPropertiesRebinder 会监听 EnvironmentChangeEvent 事件，监听到事件后会对所有的标注有 ConfigurationProperties 注解的配置类进行销毁后重新初始化的操作，完之后我们的配置类中的属性就是最新的了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7336065573770492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVFZw8giagr5T8iarLOw92hL60QNia6CSTtXNt2X9icia1ov5K77Ie9F1U3jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7626774847870182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxV4x5anmTb6Vyh6uic9XPAA8SHllicQNiatczEmORk2pPoK61rfa13EOJ6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里我们说到了会对标有 ConfigurationProperties 注解的配置类进行 rebind，那对于普通组件类里标有 @Value 注解的属性要怎么生效呢？这个其实需要配合 @RefreshScope 注解来生效的。&lt;/p&gt;&lt;p&gt;我们继续回到上述的 refresh() 方法，接着会有一步 refreshAll 的操作，会调用父类的 destroy 方法。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2900763358778626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKwxBZ9QN6mzg4FGHH2YC1veLjruuiaksibaAn044GtNv1ketbS1n1Cww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23439667128987518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVccwok8o41licleZ9NdV40SOag0WmxXp5GAJNP93pMz7XuPCRoCT1O6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;父类就是 GenericScope，我们知道 Spring 中的 Bean 是有Scope 的概念的，Spring 默认 Scope 有单例和原型两种，同时提供了 Scope 扩展接口，通过实现该接口我们可以定义自己的 Scope。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6775631500742942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVzORrlJJhmW1tibwvEAKPTlNufjfdfDW7iaHsLzEALFvbVrjK4q2ZGQxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;通过doGetBean 方法可以看出，这些自定义 Scope 类型对象的管理会交给相应的 Scope 实现去管理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8311068702290076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVyBluk9ib0CAjvRfiaKf1iaAaMZGBhQYK0RyL4skIYLpSsBSehhtfcsDgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;SpringCloud 实现的 RefreshScope 就是用来在运行时动态刷新 Bean 用的，RefreshScope 继承 GenericScope，提供 get 和 destroy 方法。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28955866523143164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVp7cksicbpGC2qPEZmQ8ScOTh3M3bc6hxV3bKNYpGesb7HgvMopjDQoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;GenericScope 内部有一个 cache，用来保存所有该 Scope 类型的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2790202342917998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxV2EKoEP5NVZLs3oJ5uXj7gkzunlYibcBOY9uvPNtbra5IbDTxULZ7fgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回到主线，所以在 refreshAll 中调用 super.destroy 方法时会将该 scope 的这些 Bean 都销毁掉，在下次 get 的时候在重新创建 Bean，新创建的 Bean 就有了我们最新的配置。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9163591635916359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVARRkPUsGAVaF5K6Y0KMzLfSCmwuB0OwTnoH0cJd6lEajRh6gaaKhzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.310752688172043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVrE8Jv1yd5AErQvaYVkcvicX6ia0vqy1Ok6Ss8dFDYemcyygagqNpMMWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，我们就实现了配置热更新的效果了。&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;文章从服务启动时的配置拉取，服务启动后的配置监听器注册，以及配置变动后的热更新实现三个方面从源码层面解析了整个的原理，希望对大家有所帮助。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;336&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1f982678174c93fc49f12db25939cf4f</guid>
<title>Rust 生命周期</title>
<link>https://toutiao.io/k/o8t36hx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;楔子&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Rust 的每个引用都有自己的生命周期，生命周期指的是引用保持有效的作用域。大多数情况下，引用是隐式的、可以被推断出来的，但当引用可能以不同的方式互相关联时，则需要手动标注生命周期。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; r;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;        r = &amp;amp;x;&lt;br/&gt;    }  &lt;span&gt;// 此处 r 不再有效&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, r);&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;执行的时候会报出如下错误：borrowed value does not live long enough，意思就是借用的值存活的时间不够长。因为把 x 的引用给 r 之后，x 就被销毁了，那么 r 就成为了一个悬空引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而 Rust 会通过借用检查器，来检查借用是否合法，显然上述代码在执行打印语句的时候，r 已经不合法了。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;longest&lt;/span&gt;&lt;/span&gt;(x: &amp;amp;&lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x.len() &amp;gt; y.len() {&lt;br/&gt;        x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        y &lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这段代码也是不合法的，原因就是返回值要么是 x 要么是 y，但具体是哪一个不知道，并且它们的生命周期也都不知道。所以无法通过比较作用域，来判断返回的引用是否是一致有效的，而借用检查器也是做不到的，原因就是它不知道返回值的生命周期是跟 x 有关系还是跟 y 有关系。事实上，这个跟函数体的逻辑也没有关系，函数的声明就决定了它做不到这一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们需要引入生命周期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;生命周期标注语法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先生命周期标注并不会改变引用的生命长度，当指定了生命周期参数，函数可以接收带有任何生命周期的引用。生命周期的标注：描述了多个引用的生命周期间的关系，但不影响生命周期本身。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在光读起来可能有点绕，别急，一会儿会解释。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生命周期参数名以 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&#x27;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 开头，并且名字非常短，通常为 a；标注位置在 &amp;amp; 后面，只有 &amp;amp; 才需要生命周期。因为你引用了一个值，那么这个值的存活时间需要知道，不然人家都被销毁了还傻傻地用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实单个生命周期标注本身没有什么意义，它是为了向 Rust 描述多个具有生命周期的参数之间的关系。并且生命周期和泛型一样，也要声明在尖括号内。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 签名里面的生命周期必须要有&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// &lt;span&gt;相当于告诉 Rust 有这么一个生命周期 &#x27;a&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;longest&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(x: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x.len() &amp;gt; y.len() {&lt;br/&gt;        x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        y&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;此时代码是合法的，但是注意：我们并没有改变&lt;/span&gt;&lt;span&gt;传入的值&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;返回的值&lt;/span&gt;&lt;span&gt;的生命周期，我们只是向借用检查器指出了一些用于检查非法调用的一些约束而已，而借用检查器并不需要知道 x、y 的具体存活时长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而事实上如果函数引用外部的变量，那么单靠 Rust 确定函数和返回值的生命周期几乎是不可能的事情。因为函数传递什么参数都是我们决定的，这样的话函数在每次调用时使用的生命周期都可能发生变化，正因如此我们才需要手动对生命周期进行标注。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 准确来说 &#x27;a 指的就是 x 和 y 生命周期重叠的那一部分&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 而返回值的生命周期不能超重叠的部分&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;longest&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(x: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x.len() &amp;gt; y.len() {&lt;br/&gt;        x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        y&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; y = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;satori&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; result = longest(&amp;amp;x, &amp;amp;y);&lt;br/&gt;        &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;result = {}&quot;&lt;/span&gt;, result);&lt;br/&gt;        &lt;span&gt;// result = satori&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;目前是没有问题的，因为 x 和 y 的生命周期重叠的部分是 y，然后返回值 result 和 y 也是一样的。但如果我们把代码改一下，将 println! 语句移到花括号外面：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;longest&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(x: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x.len() &amp;gt; y.len() {&lt;br/&gt;        x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        y&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;.to_string();&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; result;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; y = &lt;span&gt;&quot;satori&quot;&lt;/span&gt;.to_string();&lt;br/&gt;        result = longest(&amp;amp;x, &amp;amp;y);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;result = {}&quot;&lt;/span&gt;, result);  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;此时就报错了：borrowed value does not live long enough。相信你已经猜到了，因为 x、y 生命周期重叠的部分是 y，&lt;/span&gt;&lt;span&gt;返回值 result 的生命周期不能超过它。但当前明显超过了，所以报错&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说生命周期标注对变量没有什么影响，它只是给了借用检查器一个可以用来判断的约束罢了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结一下就是：生命周期用来关联函数参数和返回值之间的联系，一旦它们取得了某种联系，那么 Rust 就获得了足够多的信息来保证内存安全的操作，并且阻止那些出现悬空指针或者其它导致内存安全的行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到目前为止，你也许还不太了解生命周期，别着急，我们继续往下看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;结构体中的生命周期标注&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;struct 里面可以放任意类型，但是不能放引用，比如下面的结构体定义就是错误的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    name: &amp;amp;&lt;span&gt;str&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;结构体如果是合法的，那么它内部的所有成员值都要是合法的。但现在 name 是一个引用，所以结构体实例化的时候一定会引用某个字符串，这就使得&lt;/span&gt;&lt;span&gt;字符串存活&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;结构体实例存活&lt;/span&gt;&lt;span&gt;的前提。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但在实际编码中，这两者的存活时间没有什么关系，有可能你在使用结构体实例访问 name 成员的时候，它引用的字符串都已经被销毁了。所以 Rust 不允许我们这么做，我们之前是将 name 的类型指定为 String，也就是让结构体持有全部数据的所有权。 &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而如果非要将类型指定为引用的话，那么必须指定生命周期。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 实例.name 会引用外部的一个字符串，所以要指定生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 表示字符串的存活时间一定比结构体实例要长&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 否则字符串没了，而实例还在，那么就会出现悬空引用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#[derive(Debug)]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt; {&lt;br/&gt;    name: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;i32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;古明地觉&quot;&lt;/span&gt;);&lt;br/&gt;        g = Girl{name: &amp;amp;name, age: &lt;span&gt;16&lt;/span&gt;};&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{:?}&quot;&lt;/span&gt;, g);&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;因为指定了生命周期，在编译的时候借用检查器就可以检测出存活时间是否合法。&lt;/span&gt;&lt;span&gt;首先 g 的存活时间是整个 main 函数，而 name 的存活时间是内部的花括号那一段作用域，比 g 的存活时间短，因此编译出错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以通过生命周期标注，Rust 在编译期间就能通过&lt;span&gt;借用检查器&lt;/span&gt;检测出引用是否合法，Rust 不会将这种错误留到运行时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;生命周期的省略&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一个函数返回了一个引用时，往往需要指定生命周期，而它的目的就是为了保证返回的引用是合法的。如果不合法，在编译阶段就能找出来。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;/span&gt;(s: &amp;amp;&lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    s&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;函数参数出现了引用，返回值也有引用，应该指定生命周期呀。是的，在早期版本这段代码是编译不过的，它需要你这么写：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;f&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(s: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&quot;xxx&quot;&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但是久而久之，Rust 团队发现对于这种场景实在没有必要一遍又一遍的重复编写生命周期，并且这种只有一个参数完全是可以预测的，有明确的模式。于是 Rust 团队就将这些模式写入了借用检查器，可以自动进行推导，而无需显式地写上生命周期标注。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在 Rust 引用分析中编入的模式被称为生命周期省略规则：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;如果生命周期在函数/方法的参数中，则被称为&lt;/span&gt;&lt;span&gt;输入生命周期&lt;/span&gt;&lt;span&gt;；在函数/方法的返回值中，则被称为&lt;/span&gt;&lt;span&gt;输出生命周期&lt;/span&gt;&lt;span&gt;。而 Rust 要能够在编译期间基于输入生命周期，来确定输出生命周期，如果能够确定，那么便是合法的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而当我们省略生命周期时，Rust 就会基于内置的省略规则进行推断，如果推断完成后发现引用之间的关系还是模糊不清，就会出现编译错误。而解决办法就需要我们手动标注生命周期了，表明引用之间的相互关系。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那么 Rust 省略规则到底是怎样的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果编译器在应用完上述三个规则后，能够计算出返回值的生命周期，则可以省略，否则不能省略。这些规则同样适用于 fn 定义和 impl 块，我们来举几个例子，感受一下整个过程。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 函数如下，然后开始应用三个规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;first_word&lt;/span&gt;&lt;/span&gt;(s: &amp;amp;&lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt;{};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 1. 每个引用类型的参数都有自己的生命周期，满足&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    所以函数相当于变成如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;first_word&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(s: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt;{};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 2. 只有一个输入生命周期，该生命周期被赋给所有的输出生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    显然也是满足的，所以函数变成如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;first_word&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(s: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;{};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 3. 不满足，所以无事发生&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;应用完三个规则之后，计算出了返回值的生命周期，所以合法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再举个例子：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 函数如下，然后开始应用三个规则&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;first_word&lt;/span&gt;&lt;/span&gt;(s1: &amp;amp;&lt;span&gt;str&lt;/span&gt;, s2: &amp;amp;&lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt;{};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 1. 每个引用类型的参数都有自己的生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    显然满足，所以函数变成如下&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;first_word&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;, &lt;span&gt;&#x27;b&lt;/span&gt;&amp;gt;(s1: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, s2: &amp;amp;&lt;span&gt;&#x27;b&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt;{};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 2. 只有一个输入生命周期，该生命周期被赋予所有的输出生命周期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 但是这里有两个，所以不满足&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 3. 不满足&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;当编译器使用了 3 个规则之后仍然无法计算出返回值的生命周期时，就会出现编译错误，显然上面代码是会报错的。我们需要手动标注生命周期：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;longest&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt;(x: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;从表面上来看 x、y 的生命周期是相同的，都是 &#x27;a，但准确来说它表示的是 x、y 生命周期重叠的部分。而返回值的生命周期标注也是 &#x27;a，所以此处的含义就表示&lt;/span&gt;&lt;span&gt;输出生命周期&lt;/span&gt;&lt;span&gt;是两个&lt;/span&gt;&lt;span&gt;输入生命周期&lt;/span&gt;&lt;span&gt;重叠的部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;longest 函数这么改的话，是合法的。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;方法中的生命周期标注&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后是在方法中标注生命周期，它的语法和泛型是相似的。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 声明周期的语法类似于泛型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 必须要先通过 &amp;lt;&#x27;a&amp;gt; 进行声明，然后才能使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;Girl&lt;/span&gt;&lt;/span&gt; &amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt; {&lt;br/&gt;    name: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 在学习泛型的时候我们知道&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这种方式表示为某个类型实现方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 现在则变成生命周期，并且 &amp;lt;&#x27;a&amp;gt; 不可以省略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;impl&lt;/span&gt; &amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt; Girl &amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;&amp;gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;say_hi&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;) -&amp;gt; &lt;span&gt;String&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 此处无需指定生命周期，因为 Rust 可以推断出来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 会自动将 self 的生命周期赋值给所有的输出生命周期&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;get_name&lt;/span&gt;&lt;/span&gt;(&amp;amp;&lt;span&gt;self&lt;/span&gt;, useless_arg: &amp;amp;&lt;span&gt;str&lt;/span&gt;) -&amp;gt; &amp;amp;&lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;self&lt;/span&gt;.name&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; name = &lt;span&gt;String&lt;/span&gt;::from(&lt;span&gt;&quot;古明地觉&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; g = Girl{name:&amp;amp;name};&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, g.say_hi());  &lt;span&gt;// hello world&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, g.get_name(&lt;span&gt;&quot;&quot;&lt;/span&gt;))  &lt;span&gt;// 古明地觉&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;比较简单，另外程序中还有一个特殊的生命周期叫 &lt;/span&gt;&lt;span&gt;&#x27;static&lt;/span&gt;&lt;span&gt;，它表示整个程序的持续时间。所有的字符串字面量都拥有 &#x27;static 生命周期：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s: &amp;amp;&lt;span&gt;&#x27;static&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;为引用指定 &#x27;static 之前需要三思，是否需要引用在整个程序的生命周期内都存活。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.1153846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HlNkQjetfwiaeG2eibibS4RBQY8AFicia9q36jicvERnwdOiatCCicr8H3m5do4ZANHLuqF8yiawknQEaR6LFmL7e97iazfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;&lt;span&gt;同时指定生命周期和泛型&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08421052631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaFp77VHVDePrc5TvQGXzzWwicp8jNAyz4O2uURnfYBeoHZ1VItu2A5IQFO5ohzNYV0ABcPcHCZeOtMomUILe16g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生命周期的指定方式和泛型是一样的，那如果想同时指定生命周期和泛型，应该怎么做呢？&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;largest&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;&#x27;a&lt;/span&gt;, T&amp;gt;(x: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;, y: &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt;,&lt;br/&gt;                  useless_arg: T) -&amp;gt; &amp;amp;&lt;span&gt;&#x27;a&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; x &amp;gt; y {&lt;br/&gt;        x&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        y&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;fn&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s1 = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; s2 = &lt;span&gt;&quot;hellO&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;println!&lt;/span&gt;(&lt;span&gt;&quot;{}&quot;&lt;/span&gt;, largest(s1, s2, &lt;span&gt;&quot;&quot;&lt;/span&gt;));&lt;br/&gt;    &lt;span&gt;// hello&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;非常简单，但要保证生命周期在前，泛型在后。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是 Rust 的生命周期，它并没有改变 Rust 变量的存活时间，只是给了借用检查器更多的余地去推断引用是否合法。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;就目前来说，我们介绍的内容都还很基础，应该很好理解。等把基础说完了，后面会介绍更多关于 Rust 的细节。&lt;/span&gt;&lt;span&gt;最后的最后，我们&lt;/span&gt;再&lt;span&gt;一起用 Rust 手写一个简易版的 Redis，并和现有的 Redis 做一下性能对比。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b1b3a8c08d220f607528af3eb7e62096</guid>
<title>Bigkey 问题的解决思路与方式探索</title>
<link>https://toutiao.io/k/ne5syi3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：vivo 互联网数据库团队- Du Ting&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;在Redis运维过程中，由于Bigkey 的存在，会影响业务程序的响应速度，严重的还会造成可用性损失，DBA也一直和业务开发方强调 Bigkey 的规避方法以及危害。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;在Redis运维过程中，由于Bigkey的存在，会影响业务程序的响应速度，严重的还会造成可用性损失，DBA也一直和业务开发方强调 Bigkey 的规避方法以及危害，但是Bigkey一直没有完全避免。全网Redis集群有2200个以上，实例数量达到4.5万以上，在当前阶段进行一次全网 Bigkey检查，估计需要以年为时间单位，非常耗时。我们需要新的思路去解决Bigkey问题。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、Bigkey 介绍&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.1、什么是 Bigkey&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在Redis中，一个字符串类型最大可以到512MB，一个二级数据结构（比如hash、list、set、zset等）可以存储大约40亿个(2^32-1)个元素，但实际上不会达到这么大的值，一般情况下如果达到下面的情况，就可以认为它是B&lt;/p&gt;&lt;p&gt;igkey了。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.2 Bigkey是怎么产生的&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们遇到的Bigkey一般都是由于程序设计不当或者对于数据规模预料不清楚造成的，比如以下的情况。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;【统计】：遇到一个统计类的key，是记录某网站的访问用户的IP，随着时间的推移，网站访问的用户越来越多，这个key的元素数量也会越来越大，形成Bigkey。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【缓存】： 缓存类key一般是这样的逻辑，将数据从数据库查询出来序列化放到Redis里，如果业务程序从Redis没有访问到，就会查询数据库并将查询到的数据追加到Redis缓存中，短时间内会缓存大量的数据到Redis的key中，形成Bigkey。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;【队列】：把Redis当做队列使用，处理任务，如果消费出现不及时情况，将导致队列越来越大，形成Bigkey。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;这三种情况，都是我们实际运维中遇到的，需要谨慎使用，合理优化。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;2.3 Bigkey 的危害&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们在运维中，遇到Bigkey的情况下，会导致一些问题，会触发监控报警，严重的还会影响Redis实例可用性，进而影响业务可用性，在需要水平扩容时候，可能导致水平扩容失败。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.3.1内存空间不均匀&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;内存空间不均匀会不利于集群对内存的统一管理，有数据丢失风险。下图中的三个节点是同属于一个集群，它们的key的数量比较接近，但内存容量相差比较多，存在Bigkey的实例占用的内存多了4G以上了。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3495248152059134&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uY0zRzeYyNKnryI8vA1FibO1eBqEqWoE7sJmNSW1piaG1j9niblaFojp7Rw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;可以使用使用Daas平台“工具集-操作项管理”，选择对应的slave实例执行分析，找出具体的Bigkey。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.3.2 超时阻塞&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Redis是单线程工作的，通俗点讲就是同一时间只能处理一个Redis的访问命令，操作Bigkey的命令通常比较耗时，这段时间Redis不能处理其他命令，其他命令只能阻塞等待，这样会造成客户端阻塞，导致客户端访问超时，更严重的会造成master-slave的故障切换。造成阻塞的操作不仅仅是业务程序的访问，还有key的自动过期的删除、del删除命令，对于Bigkey，这些操作也需要谨慎使用。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;超时阻塞案例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们遇到一个这样超时阻塞的案例，业务方反映程序访问Redis集群出现超时现象，hkeys访问Redis的平均响应时间在200毫秒左右，最大响应时间达到了500毫秒以上，如下图。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7634011090573013&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;541&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYyLf2ib0jb4V2qsuxXOTg5I8c4A6PleyOaWks4jnln56TTY04XWZlqcw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;hkeys是获取所有哈希表中的字段的命令，分析应该是集群中某些实例存在hash类型的Bigkey，导致hkeys命令执行时间过长，发生了阻塞现象。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;1.使用Daas平台“服务监控-数据库实例监控”，选择master节点，选择Redis响应时间监控指标“redis.instance.latency.max”，如下图所示，从监控图中我们可以看到&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）正常情况下，该实例的响应时间在0.1毫秒左右。&lt;/p&gt;&lt;p&gt;（2）监控指标上面有很多突刺，该实例的响应时间到了70毫秒左右，最大到了100毫秒左右，这种情况就是该实例会有100毫秒都在处理Bigkey的访问命令，不能处理其他命令。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;通过查看监控指标，验证了我们分析是正确的，是这些监控指标的突刺造成了hkeys命令的响应时间比较大，我们找到了具体的master实例，然后使用master实例的slave去分析下Bigkey情况。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6415770609318996&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYLpJQLJVQ4AWBVBnp7Fs9plSFDhc0HmL2oUTnicLcu4eibX9joeqx9UFA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6432432432432432&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYSFX0oFOhics1uNVeAdFhclHMRA5m5TEJTyRwUeWvacw0Pvib4ZVEibUUQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;2.使用Daas平台“工具集-操作项管理”，选择slave实例执行分析，分析结果如下图，有一个hash类型key有12102218个fields。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3089430894308943&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYn8Tp3ibz9ADxfbGE1X8uiaGr9ju4BB4max0jPw8l2IYa19QUDZoiawb4A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;3. 和业务沟通，这个Bigkey是连续存放了30天的业务数据了，建议根据二次hash方式拆分成多个key，也可把30天的数据根据分钟级别拆分成多个key，把每个key的元素数量控制在5000以内，目前业务正在排期优化中。优化后，监控指标的响应时间的突刺就会消失了。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.3.3 网络阻塞&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Bigkey的value比较大，也意味着每次获取要产生的网络流量较大，假设一个Bigkey为10MB，客户端每秒访问量为100，那么每秒产生1000MB的流量，对于普通的千兆网卡(按照字节算是128MB/s)的服务器来说简直是灭顶之灾。而且我们现在的Redis服务器是采用单机多实例的方式来部署Redis实例的，也就是说一个Bigkey可能会对同一个服务器上的其他Redis集群实例造成影响，影响到其他的业务。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;2.3.4 迁移困难&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们在运维中经常做的变更操作是水平扩容，就是增加Redis集群的节点数量来达到扩容的目的，这个水平扩容操作就会涉及到key的迁移，把原实例上的key迁移到新扩容的实例上。当要对key进行迁移时，是通过migrate命令来完成的，migrate实际上是通过dump + restore + del三个命令组合成原子命令完成，它在执行的时候会阻塞进行迁移的两个实例，直到以下任意结果发生才会释放：迁移成功，迁移失败，等待超时。如果key的迁移过程中遇到Bigkey，会长时间阻塞进行迁移的两个实例，可能造成客户端阻塞，导致客户端访问超时；也可能迁移时间太长，造成迁移超时导致迁移失败，水平扩容失败。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;迁移失败案例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们也遇到过一些因为Bigkey扩容迁移失败的案例，如下图所示，是一个Redis集群水平扩容的工单，需要进行key的迁移，当工单执行到60%的时候，迁移失败了。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;1. 进入工单找到失败的实例，使用失败实例的slave节点，在Daas平台的“工具集-操作项管理”进行Bigkey分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32890625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYj3pHUicWAhJBpZHEAlrogdBiceV7DQ3TNGF8ia6pUaiaagKJcFr5DUFYiaw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;2. 经过分析找出了hash类型的Bigkey有8421874个fields，正是这个Bigkey导致迁移时间太长，超过了迁移时间限制，导致工单失败了。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.19976635514018692&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt6WBnmfRxTkUDeeKXdtp7uYjqO7lad0oQCc4wiceIrqDibYwvzeuqb5jUwSN8c7ib5ibbRDNjanXP7Akw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;3.和业务沟通，这些key是记录用户访问系统的某个功能模块的ip地址的，访问该功能模块的所有ip都会记录到给key里面，随着时间的积累，这个key变的越来越大。同样是采用拆分的方式进行优化，可以考虑按照时间日期维度来拆分，就是一段时间段的访问ip记录到一个key中。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;4.Bigkey优化后，扩容的工单可以重试，完成集群扩容操作。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、Bigkey的发现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Bigkey首先需要重源头治理，防止Bigkey的产生；其次是需要能够及时的发现，发现后及时处理。分析Bigkey的方法不少，这里介绍两种比较常用的方法，也是Daas平台分析Bigkey使用的两种方式，分别是Bigkeys命令分析法、RDB文件分析法。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.1 scan命令分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Redis4.0及以上版本提供了--Bigkeys命令，可以分析出实例中每种数据结构的top 1的Bigkey，同时给出了每种数据类型的键值个数以及平均大小。执行--Bigkeys命令时候需要注意以下几点：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;建议在slave节点执行，因为--Bigkeys也是通过scan完成的，可能会对节点造成阻塞。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;建议在节点本机执行，这样可以减少网络开销。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果没有从节点，可以使用--i参数，例如(--i 0.1 代表100毫秒执行一次)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;--Bigkeys只能计算每种数据结构的top1，如果有些数据结构有比较多的Bigkey，是查找不出来的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Daas平台集成了基于原生--Bigkeys代码实现的查询Bigkey的方式，这个方式的缺点是只能计算每种数据结构的top1，如果有些数据结构有比较多的Bigkey，是查找不出来的。该方式相对比较安全，已经开放出来给业务开发同学使用。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.2 RDB文件分析&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;借助开源的工具，比如rdb-tools，分析Redis实例的RDB文件，找出其中的Bigkey，这种方式需要生成RDB文件，需要注意以下几点：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;Daas平台集成了基于RDB文件分析代码实现的查询Bigkey的方式，可以根据实际需求自定义填写N，分析的top N个Bigkey。该方式相对有一定风险，只有DBA有权限执行分析。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;3.3 Bigkey 巡检&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;通过巡检，可以暴露出隐患，提前解决，避免故障的发生，进行全网Bigkey的巡检，是避免Bigkey故障的比较好的方法。由于全网Redis实例数量非常大，分析的速度比较慢，使用当前的分析方法很难完成。为了解决这个问题，存储研发组分布式数据库同学计划开发一个高效的RDB解析工具，然后通过大规模解析RDB文件来分析Bigkey，可以提高分析速度，实现Bigkey的巡检。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、 Bigkey处理优化&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.1 Bigkey拆分&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;优化Bigkey的原则就是string减少字符串长度，list、hash、set、zset等减少元素数量。当我们知道哪些key是Bigkey时，可以把单个key拆分成多个key，比如以下拆分方式可以参考。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;big list：list1、list2、...listN&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;big hash：可以做二次的hash，例如hash%100&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;按照日期拆分多个：key20220310、key20220311、key202203212&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.2 Bigkey分析工具优化&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们全网Redis集群有2200以上，实例数量达到4.5万以上，有的比较大的集群的实例数量达到了1000以上，前面提到的两种Bigkey分析工具还都是实例维度分析，对于实例数量比较大的集群，进行全集群分析也是比较耗时的，为了提高分析效率，从以下几个方面进行优化：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;li&gt;&lt;p&gt;可以从集群维度选择全部slave进行分析。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同一个集群的相同服务器slave实例串行分析，不同服务器的slave实例并行分析，最大并发度默认10，同时可以分析10个实例，并且可以自定义输入执行分析的并发度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;分析出符合Bigkey规定标准的所有key信息：大于1MB的string类型的所有key，如果不存在就列出最大的50个key；hash、list、set、zset等类型元素个数大于2000的所有key，如不存在就给出每种类型最大的50个key。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;增加暂停、重新开始、结束功能，暂停分析后可以重新开始。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;4.3 水平扩容迁移优化&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;目前情况，我们有一些Bigkey的发现是被动的，一些是在水平扩容时候发现的，由于Bigkey的存在导致扩容失败了，严重的还触发了master-slave的故障切换，这个时候可能已经造成业务程序访问超时，导致了可用性下降。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们分析了Daas平台的水平扩容时迁移key的过程及影响参数，内容如下：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）【cluster-node-timeout】：控制集群的节点切换参数，master堵塞超过cluster-node-timeout/2这个时间，就会主观判定该节点下线pfail状态，如果迁移Bigkey阻塞时间超过cluster-node-timeout/2，就可能会导致master-slave发生切换。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）【migrate timeout】：控制迁移io的超时时间，超过这个时间迁移没有完成，迁移就会中断。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）【迁移重试周期】：迁移的重试周期是由水平扩容的节点数决定的，比如一个集群扩容10个节点，迁移失败后的重试周期就是10次。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）【一个迁移重试周期内的重试次数】：在一个起迁移重试周期内，会有3次重试迁移，每一次的migrate timeout的时间分别是10秒、20秒、30秒，每次重试之间无间隔。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如一个集群扩容10个节点，迁移时候遇到一个Bigkey，第一次迁移的migrate timeout是10秒，10秒后没有完成迁移，就会设置migrate timeout为20秒重试，如果再次失败，会设置migrate timeout为30秒重试，如果还是失败，程序会迁移其他新9个的节点，但是每次在迁移其他新的节点之前还会分别设置migrate timeout为10秒、20秒、30秒重试迁移那个迁移失败的Bigkey。这个重试过程，每个重试周期阻塞（10+20+30）秒，会重试10个周期，共阻塞600秒。其实后面的9个重试周期都是无用的，每次重试之间没有间隔，会连续阻塞了Redis实例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）【迁移失败日志】：迁移失败后，记录的日志没有包括迁移节点、solt、key信息，不能根据日志立即定位到问题key。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;我们对这个迁移过程做了优化，具体如下：&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（1）【cluster-node-timeout】：默认是60秒，在迁移之前设置为15分钟，防止由于迁移Bigkey阻塞导致master-slave故障切换。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）【migrate timeout】：为了最大限度减少实例阻塞时间，每次重试的超时时间都是10秒，3次重试之间间隔30秒，这样最多只会连续阻塞Redis实例10秒。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（3）【重试次数】：迁移失败后，只重试3次（重试是为了避免网络抖动等原因造成的迁移失败），每次重试间隔30秒，重试3次后都失败了，会暂停迁移，日志记录下Bigkey，去掉了其他节点迁移的重试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）【优化日志记录】：迁移失败日志记录迁移节点、solt、key信息，可以立即定位到问题节点及key。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;本文通过对Bigkey的分析，重点介绍了在运维中对bigkey问题的处理思路、解决方式。首先是需要从源头治理，防止Bigkey形成，DBA应该加强对业务开发同学bigkey相关问题的宣导；其次是需要具备及时发现的能力，这个也是我们现在的不足之处。我们后面会从Bigkey巡检、Bigkey分析工具的这两个方面，提高Bigkey发现能力。&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://doc.redisfans.com/index.html&quot; textvalue=&quot;Redis命令参考&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Redis命令参考&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/sripathikrishnan/redis-rdb-tools&quot; textvalue=&quot;Github：rdb-tools&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Github：rdb-tools&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://www.cnblogs.com/szq95716/p/14271108.html&quot; textvalue=&quot;redis之bigkey（看这一篇就够）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;redis之bigkey（看这一篇就够）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:129.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-alias=&quot;vivoVMIC&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-signature=&quot;分享&quot; vivo=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>