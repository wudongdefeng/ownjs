<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ce321f8719ea532f37cb374237e72021</guid>
<title>写在 2023 年初的后端社招面试经历（四年经验）：字节 米哈游 富途 猿辅导</title>
<link>https://toutiao.io/k/ppo92f1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目录&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;背景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试准备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;总结&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些推荐&lt;/section&gt;&lt;/li&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;距离上一次&lt;span&gt;面试&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;已经过去快 3 年了，又碰上 2022 年互联网行业大动荡，很多企业都做出了裁员决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;身为互联网人要时刻关注自身成长，所以会对 “跟面试官切磋” 这种事情比较感兴趣，其实也是一种打探行情的手段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;3 年间自己的技术是线性成长、指数成长还是对数成长，跟同龄人相比如何？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前求职是买方市场还是卖方市场？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此收集这两个信息是我面试&lt;strong&gt;最初的目的&lt;/strong&gt;，当然整个过程很长，&lt;strong&gt;最终的选择&lt;/strong&gt;也会受很多事情影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 面试准备&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;毕业之后我在两家公司工作过，触及的业务包括营销数据分析、供应链物流、社媒广告投放等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个领域包含的内容都比较多，除非是手上正在负责，其它内容想回忆起来是相当难的。因此在简历撰写上，&lt;strong&gt;尽量将业务转化为技术模型&lt;/strong&gt;，好处在于：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;让面试官能更多地从技术角度切入谈某项业务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;求职方向更灵活，没做过这项业务的面试官也有问题可问；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;减少自己复习过往业务的时间（&lt;strong&gt;摆烂&lt;/strong&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常来说简历准备好之后，要有具体的专业知识做支撑。考虑到工作年限不长，所以仍是以基础为准，对接触一线业务的后端来说计算机网络、数据库、操作系统三大块是一定绕不开的，在此之上搭建分布式、微服务架构、服务治理等知识框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后补充对工作项目的思考，例如做的项目在业界中是否有竞争对手、大家的方案横向对比有什么优劣点，自己的创新点在哪里等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是&lt;/strong&gt;面试准备是服务于我的面试目的的，基于&lt;strong&gt;评估自身技术水平&lt;/strong&gt;的想法，我最终也没有拿起课本，而是决定看看在 “&lt;strong&gt;不刻意准备&lt;/strong&gt;”（&lt;strong&gt;摆烂&lt;/strong&gt;）的情况下能表达到什么程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人不认为裸面（again，&lt;strong&gt;摆烂&lt;/strong&gt;）是个好的、值得推广的实践，这导致在面试的时候很多问题（例如：是否了解 Kafka、是否了解一致性哈希）我选择直接回答 “不会”、“没了解过” 来避免 follow up questions，但是在一些特殊背景下确实可以更真实反映出自身的水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，面试中有一些比较 “硬” 的条件要求（算法题咱说的就是你）是须要有所积累的。因为本身不擅长算法，解新题其实会需要一定的时间，所以我选择反复写 Top 100 Like 的老题目来保持手感。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18773006134969325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaj5Tv7AwqcoSXBxWMg5czSJLnD6szdf0UouEr4WjUutvQeaY5jAhpfx2XrA7qPFwicecNOiczdEWyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1630&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后关于求职方向的选择，更多是出于个人偏好，不具备什么可参考性。对我来说，由于未来倾向于换到云原生相关的赛道，那自然是以基础架构相关的岗位为主。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是找到 100% 符合目标的职位其实是很难的，而且所谓的 “云原生”、“基础架构” 本身就是个非常大的范围，其中细分方向、职能无数。征询了一些朋友的意见，最后也是尽可能地往目标方向靠拢即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 面试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求职过程中，有一些公司是直接拒掉了简历的，一方面是简历比较普通，其次也可能确实没有招人的需求。这也是符合预期的，平时大家开发的时候 &lt;span&gt;Liveness Probes&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 也会有失败，说明（简历）该回炉重造了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Anyways，最终进入面试流程的有 4 家，如果只对其中某一家感兴趣的话可以从导航目录直接跳过去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面试过程中我都会进行录音，这是个很有收益的事情，过往面试中我观察到有些同学会自认为回答得 “尚可”，殊不知很多细节只是在脑中形成思路，在表述上则是断断续续。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何细节的缺失在面试官听来都可能导致理解上的差异，最终予以不够好的评价。面试后听录音重新 Review 面试，可以从面试官的角度听自己的回答，也方便整理面试经历。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 字节跳动（国际化电商）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节的面试流程是：组内面试官-&amp;gt;组外面试官(交叉面)-&amp;gt;组内面试官，当然因为菜的原因没继续走到第三面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两位面试官都很感兴趣所做的业务，聊业务的比重也是 4 家中最多的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外字节的面试的时候有个小插曲，二面刚好是疫情爆发最严重的时候，顶着发烧面试也算是一次独特的经历吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细记录：&lt;span&gt;写在 2022 年末的字节跳动面试复盘&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一面摘录&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;了解索引下推吗？什么情况下会下推到引擎去处理？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过某个索引没办法按顺序地覆盖所有的查询条件，但是仍然可以利用索引内存在的字段（尽管不是有序的，需要扫描）去进一步过滤；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;举例：idx(a,b,c,d)，查询条件为 a=? and b=? and d=?，发生下推减少回表数量；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;什么场景下索引会失效？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;场景有很多，但是如果我是一个引擎，我关注的不是什么情况会失效，而是走什么路径所花费的随机 I/O 和顺序 I/O 最少，如果走某个索引花费的随机 I/O 比从聚簇索引（顺序）查（成本）都还要高，那还不如直接去全表扫描；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;典型例子：捞超过全表 30% 的数据；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;有没有具体一点的例子？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;还是刚刚提到的例子，比如说我要按照 update_time 去做范围查询，捞很多的数据，即使 update_time 有索引，也会选择全表扫描；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;WHERE id NOT IN (?, ?, ?) 会走索引吗？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;还是要看成本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;举例：id 字段只包含 3 个值，1、2、3，3 只有几行，而 1、2 各有 100w 行，如果查询条件是 NOT IN (1, 2) 会走索引，如果查询条件是 NOT IN (3) 不会走索引。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反问环节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;团队里面大约有多少个仓库、部署了多少服务（大致规模）？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这些项目会做单元测试吗，或者说平时的自测、代码质量保障是通过什么方式做的？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;工具类的库会写单测；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动化测试会由流量回放平台，QA 执行常用的用例；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;整个流量回放都是 QA 负责的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个业务迭代版本是怎么安排时间发布的呢，比如说是每周固定发布还是说测试完成后的几天发布？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;按双月来排期，产品拟定优先级， 研发扣除 oncall 等时间分配任务；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;oncall 那周安排多少时间精力做 oncall 和其它问题？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;80% 时间在 oncall，剩下的时间会看情况修复一下线上和其他的小问题；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;前面很多问题都没有答对，面试官的建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二面摘录&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这种（短链接服务）场景里面写入（创建短链）耗时长可否容忍？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一定程度上是 OK 的因为创建短链的请求比访问短链的请求少很多，容忍度更高；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;在这个大量 KV 数据读写的场景，为什么不考虑直接使用 KV 存储或者 Redis 来支撑？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;考虑过，但是短链服务本质上更需要背后收集到的访问数据来体现业务价值，而访问数据的聚合分析需要数仓，公司内没有很好的 KV 存储到数仓的支持，不想当小白鼠；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;为何不考虑数据仓库提供 HBase 来支持读写，节约掉 MySQL / KV 存储同步到数仓的过程？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;嗯，好像是个可考虑的想法，但是不太了解 HBase；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;能说一下 LevelDB 的存储结构吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;算法：定义 Redis 跳跃表的结构，再实现一版它的插入方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反问环节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在字节的技术人对于公司的基础架构的满意程度如何？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;外出参加技术会议、交流在字节里机会是否丰富？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面很多问题都没有答对，面试官的建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 米哈游&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来说面试问题都很基础和简单，能不能通过的话（如果没特意复习）就靠平时的积累了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 岗位里对数据结构的提问非常频繁，个人认为对 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;sync.Map&lt;/code&gt;、&lt;code&gt;context&lt;/code&gt;等的熟悉程度应该达到能完整记忆每个结构体字段的水准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细记录：&lt;span&gt;2023 年初的米哈游面试复盘&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一面摘录&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 里面使用 Map 时应注意问题和数据结构？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可以通过定义 value 为 struct 来节约内存；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哈希分桶的结构，用哈希值的高八位和低八位分别来做桶内定位的依据和分桶的依据等；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Map 扩容是怎么做的？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;依照 Redis 渐进式 rehash 的思路说了一版；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Map 的 panic 能被 recover 掉吗？了解 panic 和 recover 的机制吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不懂，但是实际上是不可以的，具体原因可以看看 Map 并发读写的时候抛出的是什么，是不是普通的 panic；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Map 怎么知道自己处于竞争状态？是 Go 编码实现的还是底层硬件实现的？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过结构体中的标记位实现的，可能是通过 CAS 操作的；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CAS 具体是怎么实现的呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;并发使用 Map 除了加锁还有什么其他方案吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有对比过 sync.Map 和加锁的区别吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;说一下（Redis）分布式锁的实现？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基于 Redis 的分布式锁会有什么问题？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis 分布式锁超时可以超时时间设长一点可以吗？不可以的话需要怎么解决？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不根本解决问题，可以考虑旁路的 goroutine 不断自旋续期&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对 Redis 锁续期这个怎么实现呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;日常在用的 Redis 集群都是什么架构？在主从模式和 Redis Cluster 中分布式锁会有什么问题？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反问环节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Golang 在米哈游的使用场景？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目组的一些细节，代码组织、管理形式等是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目质量的保障手段有哪些，单元测试覆盖率要求如何？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试的同学主要以白盒测试还是黑盒测试为主？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面很多问题都没有答对，面试官的建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 富途牛牛（互联网-基础/接入）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4 家中富途牛牛问的基础知识是最多的，给我印象很深刻的是跟每位面试官的沟通都（提）很（示）顺（很）畅（多），那因为一些不熟悉的知识点我基本是依靠同类的工具去类比和猜想，面试官很愿意听我的这些猜想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些思路上和所问的实现确实是不同的，面试官会提出来那（正确实现中）某某问题是如何（在我提出的实现中）解决的，引导我慢慢靠近或者推导出正确实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为作为面试官，这些应该是标配培训的能力，但是实际上在面试中能见到的甚少，一是面试时间有限，二是作为面试官一天面试很多人，耐心难免也会有消磨，这都是可以理解的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以实际上能做到如此的话，对面试者确实会是非常好的体验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细记录：&lt;span&gt;2023 年初的富途牛牛面试复盘&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一面摘录&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(test1())&lt;br/&gt; fmt.Println(test2())&lt;br/&gt; fmt.Println(test3())&lt;br/&gt; fmt.Println(test4())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(v &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(v)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; v&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(v &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(v)&lt;br/&gt; }()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test3&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(v &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; fmt.Println(v)&lt;br/&gt; v = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;test4&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(v &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  fmt.Println(n)&lt;br/&gt; }(v)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Golang 标准库中 map 的底层数据结构是什么样子的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Map 的查询时间复杂度如何分析？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;极端情况下有很多哈希冲突，Golang 标准库如何去避免最坏的查询时间复杂度？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Golang map Rehash 的策略是怎样的？什么时机会发生 Rehash？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Rehash 具体会影响什么？哈希结果会受到什么影响？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Rehash 过程中存放在旧桶的元素如何迁移？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发环境共享同一个 map 是安全的吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果并发环境想要用这种哈希容器有什么方案？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;sync.Mutex / sync.RWMutex&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Map&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;加锁存在什么问题呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Map 比加锁的方案好在哪里，它的底层数据结构是怎样的？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存 + map 组成的结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;底层 map 的操作依然是加锁的，但是读的时候使用上缓存可以增加并发性能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;sync.Map 的 Load() 方法流程？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Map Store() 如何保持缓存层和底层 Map 数据是相同的? 是不是每次执行修改都需要去加锁？&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;或许是通过加锁和 CAS 保证的？（面试官：它下面还有一些 tricky 的思路，面试结束可以再去看看）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;channel 被 close 操作之后进行读和写会有什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未被初始化的 channel 进行读写会有什么问题？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;channel 底层数据结构是怎样的，尝试用结构体来表述一下？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;了解面试部门的基本情况？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部门内微服务的数量？每个研发大概会负责多少服务的开发工作？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++ 和 Golang 在团队内的使用场景和比例？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;研发对开发质量的保障是如何完成的，测试和覆盖率是否有要求？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;研发和测试的人员配置比例？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面很多问题都没有答对，面试官的建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二面摘录&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果做一个翻译服务，翻译能力来自于供应商，如何从技术上对几家（A、B、C）供应商作出评估？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果几家都要接入，且各家之间的翻译能力都各有优劣，那应该如何去搭建这个服务的框架？- 调度器 - 数据采集 / 反馈机制，帮助调度器更好地工作 - 可扩展性，固化供应商的接入标准，方便未来扩展更多供应商选择&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除了回答的这些方面，一个服务的设计还需要注意什么？- 正常服务应该提供的网关，包括鉴权、限流、多租户 - 提供给外部的服务需要注意 SLA，SLA 则围绕日志、监控、Tracing 做文章&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一副扑克牌中随机取 5 张，取到顺子的概率是多少？- Hint 1：一种花色有多少种顺子？9 种 - Hint 2：一个顺子有 5 张牌，有多少种组合可能？4 ^ 5 种 - Hint 3：分子已经知道了，分母怎么表示，n 张取 m 张怎么表示？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目基本都是微服务 &amp;amp; Kubernetes 这套方案吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;研发跟基础设施打交道能到什么样的深度，例如能使用 Kubernetes 的那些内容，中间件的使用权限上有什么样的管控？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;正常业务的 CI/CD 里面都做了/集成了多少测试或检查？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务的研发能在 Kubernetes 上具体写哪些东西呢，例如 sidecar、operator 等等？- 有专门的团队去做，但是还在起步阶段，大家都可以贡献；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三面摘录&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据库迁移的原因是什么？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;完成迁移之后 DB 成本降低多少？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;迁移过程中双读双写具体是什么样的方案？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;双写过程中只写成功了其中一个 DB，返回给用户报错，那是否会存在脏数据呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;双读具体是什么方案，其中一个读成功了就返回还是要两个都读成功才可以？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 流量的录制工具主要是做什么用呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 流量录制会涉及到一些登陆态的处理吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;掷骰子，游戏规则：希望结果尽可能大，如果对第一次的结果不满意可以掷第二次，但是第一次结果就作废了，以第二次的结果为准。这个掷骰子结果的数学期望是多少呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Hint 1：如果第一次扔到 6，还考虑扔第二次吗？如果第一次扔到 1 考虑吗？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Hint 2：那什么情况考虑扔第二次，什么情况不考虑？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;输入两个整数 a 和 b，输出他们相除的结果，如果有循环小数用括号表示。如：- a=-1，b=2，输出 &quot;-0.5&quot; - a=1，b=3，输出 &quot;0.(3)&quot; - a=10，b=80，输出 &quot;0.125&quot; - a=-100，b=10，输出 &quot;-10&quot;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三面反问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一、二、三轮的面试官都是团队中的什么角色呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;组织架构中小组、中心的概念和规模？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;作为管理者如果看到团队中的技术氛围比较欠缺，会考虑什么样的手段（去提升）呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在已有组件能支撑业务的情况下，如何看待 Member 提出的一些组件的升级或引入呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 CI/CD 这块，可能不会直接产生业务影响（例如更高的订单量），在公司的现状如何，以及如何看待将时间投入在这上面呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面很多问题都没有答对，面试官的建议？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 猿辅导（大监控-日志）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实最初有一点点惊讶原来猿辅导在国家一些政策影响下仍在继续活跃。由于投递的是更贴近基础设施的岗位，很多问题能听得出来都是从基础架构工程师的角度发问的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外它们家的面试有一个比较印象深刻的点就是，每位面试官都喜欢问：“你觉得 XXXXX”，例如 “你觉得哪些项目挑战最大”、“你觉得这里面最难的点在哪里”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过作为投递里面唯一完全没接触过的领域，他们问的很多问题我都非常有兴趣继续探讨下去，也是少有的关注简历上&lt;span&gt;**CDC 同步方案**&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;的团队。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细记录：404 orz&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体来说面试没有出现想象中的地狱难度，几乎所有的面试官都很有耐心交流。但是被问到这么多的基础问题确实有一点点出乎意料，正常以为会是项目 &amp;amp; 基础各占 50% 的比例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过或许这也是好事情，个人非常赞同基础扎实但业务薄弱的工程师 &amp;gt; 对业务有不错理解但基础不扎实（或比较远离一线开发、代码生疏）的工程师。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外其实计算机基础确确实实有在我的日常开发中帮到过我（quick question：你有在实际工作、排查问题中找过 &lt;code&gt;TIME_WAIT&lt;/code&gt; 的网络连接吗？）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后回到最初面试的目的，是为了回答下面两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;3 年间自己的技术是线性成长、指数成长还是对数成长，跟同龄人相比如何？&lt;blockquote&gt;&lt;p&gt;是有成长的，但是没有那么理想，可能更介于线性成长和对数成长之间；&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前求职是买方市场还是卖方市场？&lt;blockquote&gt;&lt;p&gt;哈哈&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 一些推荐&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于面试我认为下面的材料很大程度帮到过我，所以也会推荐给在看本文的你，或者要求职的同学。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;USENIX&lt;/strong&gt;：&lt;span&gt;https://www.usenix.org/conferences&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果想树立一些属于自己的亮点，一个捷径是了解面试官不懂的知识&lt;span&gt;（不是）&lt;/span&gt;。关心前沿的学术和工业论文非常简单有效，USENIX 上覆盖了很多基础方向，例如计算机网络、操作系统、存储、分布式、安全，以及按职能划分的 SRE 等等。除了 USENIX 上的以外，如果有你关注方向的其他顶会那当然也是可以的，例如我以前会去看看 VLDB 和 SIGMOD 上的论文了解 KV 存储的一些新知识和研究方向。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;操作系统导论&lt;/strong&gt;：&lt;span&gt;https://book.douban.com/subject/33463930/&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一本很有意思的操作系统的入门书，可以写写里面代码了解一下 Linux 的 API，对于进程和内存相关的讲解让我印象非常深刻。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Go 程序员面试笔试宝典&lt;/strong&gt;：&lt;span&gt;https://book.douban.com/subject/35871233/&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;首先声明一点这个书没帮到我面试，因为在面试前我没什么时间看它...正常来说我也不会推荐这种速食读物（手动狗头），但是结合面试遇到的提问来看，我认为它会对急着在一两个月内找到工作的同学很帮助。不过无论如何，程序员的学习是不建议走捷径的，如果对 Golang 感兴趣的话，有很多更好的替代品，包括 &lt;span&gt;Draveness&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt; 老师、&lt;span&gt;Russ Cox&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 的博客等等。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.学/复习路径&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下我学/复习 golang 的路径：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;看了 go by example 和 learn go with tests 熟悉了基础的语法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后续购入 &amp;amp; 认真读过的 Golang 读物（时间顺序）：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Go 语言核心编程：读完，了解基本的坑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 语言编程之旅：读完，教会我写项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 专家编程：读完，了解了常用数据结构的实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 语言设计与实现：读了一部分，比较多科班的内容考验读者基本功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 语言底层原理剖析：读了一部分，代码有点多，抽象不够，考验耐心&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 程序员面试笔试宝典：读了一部分，Q&amp;amp;A 的形式，八股文大杂烩&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在未来半年内不考虑面试，那应该是有时间吃透其中几本书的；如果马上就要面试了，或许更推荐以抽象程度比较高的博客、文章为主。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;面试: &lt;em&gt;https://jiekun.dev/posts/2020-03-28-shopee%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Liveness Probes: &lt;em&gt;https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;写在 2022 年末的字节跳动面试复盘: &lt;em&gt;https://jiekun.dev/posts/2022-bytedance-interview/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;2023 年初的米哈游面试复盘: &lt;em&gt;https://jiekun.dev/posts/2023-mihoyo-interview/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;2023 年初的富途牛牛面试复盘: &lt;em&gt;https://jiekun.dev/posts/2023-futu-interview/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;&lt;strong&gt;CDC 同步方案&lt;/strong&gt;: &lt;em&gt;https://gist.github.com/jiekun/ac4387b613e91c2d4142df35614cab34&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;https://www.usenix.org/conferences: &lt;em&gt;https://www.usenix.org/conferences&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;https://book.douban.com/subject/33463930/: &lt;em&gt;https://book.douban.com/subject/33463930/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;https://book.douban.com/subject/35871233/: &lt;em&gt;https://book.douban.com/subject/35871233/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;Draveness: &lt;em&gt;https://draveness.me&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;Russ Cox: &lt;em&gt;https://research.swtch.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53d1669ae077baaff8464b9668b49ecf</guid>
<title>Apache Kvrocks 发布了 2.3.0</title>
<link>https://toutiao.io/k/su52lop</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Apache Kvrocks (incubating) 发布了 2.3.0 版本，感谢所有贡献者的无私付出，特别鸣谢社区 Committer &lt;/span&gt;&lt;span&gt;@Myth&lt;/span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;span&gt; 帮助主导本次发版投票流程。这个版本包含了若干新功能，优化提升以及问题修复，其中有几个值得注意的变更:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RocksDB 升级到了 &lt;code&gt;7.9.2&lt;/code&gt; 版本，主要为了解决 7.5.3 之前版本里面存在 Compaction 计算问题导致的性能骤降问题，具体见: &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxNTg5NzM1Nw==&amp;amp;mid=2247483951&amp;amp;idx=1&amp;amp;sn=e91334a9e177960717bd1b179dd62e02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RocksDB 7 终于解决了 Compaction 时性能下降问题&lt;/a&gt;。除此之外，也可以更好利用 RocksDB 里面的新特性来提高性能，比如 async_io  等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群模式下默认在本地存储集群拓扑信息，重启实例后集群拓扑信息不会丢失。如果不预期有这个行为，可以通过  &lt;code&gt;config set persist-cluster-nodes-enable no&lt;/code&gt; 命令在线关闭该特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新增了 &lt;code&gt;&lt;span&gt;hr&lt;/span&gt;&lt;span&gt;an&lt;/span&gt;&lt;span&gt;geByLex&lt;/span&gt;&lt;/code&gt; 命令，可以对 Hash 数据进行 Range 查询&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，该版本也开始在 CI 阶段引入 clang-tidy/clang-format 来让项目整体的代码风格更加规范和统一，具体见: &lt;span&gt;issues/1029&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;优化和提升&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持通过配置 &lt;code&gt;log-retention-days&lt;/code&gt; 来设定日志保留时长 [#1171]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群模式下默认在本地持久化集群配置信息 [#1219]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持通过配置文件指定日志级别 [#1230]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocksDB 升级到 7.9.2 &amp;amp; Google test 升级到 1.13.0  [#1229]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;编译阶段支持 LTO/IPO [#764]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入 fmt 依赖包来简化字符串格式 [#1139]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Info 里面增加 Redis 版本号来兼容 spark-redis [#1158]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新增命令 &lt;code&gt;hrangeByLex&lt;/code&gt; 来允许对 Hash 数据进行 Range 查询 [#1120]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;统一使用 ParseInt 来解析数据类型 [#1191]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复主从同步建立连接没有设置超时时间问题 [#1172]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kvrocks2Redis 支持解析 slot ID  [#1222]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持开启 async_io 选项来提高 Seek 性能 [#1215]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在禁止写入 Slot 阶段返回错误信息增加 TRYAGAIN 前缀 [#1240]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bug 修复&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;修复了日志早于加载配置问题 [#1061]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 Script Load 返回 SHA 格式 [#1133]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 Server::GetRocksDBStatsJson 返回格式  [#1142]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 SockConect 没有解析域名问题 [#1183]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修复 stream unblocking connection 时的死锁问题 [#1228]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布日志以及对应 PR 可点击原文查看：&lt;span&gt;GitHub Release v2.3.0&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，欢迎大家使用和交流。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;@Myth: &lt;em&gt;https://github.com/caipengbo&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;issues/1029: &lt;em&gt;https://github.com/apache/incubator-kvrocks/issues/1029&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;GitHub Release v2.3.0: &lt;em&gt;https://github.com/apache/incubator-kvrocks/releases/tag/v2.3.0&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>108c930dbac08362465f3c5bddeefd14</guid>
<title>25 年 Linux 老兵，聊聊运维的“术”与“道”</title>
<link>https://toutiao.io/k/r3s20of</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;运维百家讲坛，通过采访和约稿的方式，请运维领域老炮输出深刻洞见，共同碰撞，以期形成一些先进的共识，推动行业更好&lt;/span&gt;地&lt;span&gt;前进。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一期我们邀请到的是&lt;/span&gt;&lt;span&gt;又拍云的邵海杨，一个25年的Linux老炮，邵总醉心技术，一步一步往上走，是普通运维人员的典型成长路径&lt;/span&gt;&lt;span&gt;，希望今天的采访可以对你有那么一些启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里是接地气、有高度的《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3ODAxNTIzMQ==&amp;amp;mid=2247485109&amp;amp;idx=1&amp;amp;sn=f8c7e99dca9a84c3435123e2ef7ab396&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;运维百家讲坛&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》第 4 期，开讲！&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;您好邵总，请您先做个自我介绍吧，聊聊您的履历和现状，让大家更好的认识您，了解您的背景也有助于读者理解后面的采访内容&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.97421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUF644bqfBlZiaVx9CetjGepVZoKgn3fqh3ba4ibJLpjYGTrdZrnDyrYdoa1tbia8C8ccNquYEPfeb05g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我是来自又拍云的邵海杨，从1998年开始使用Linux至今快25年了，资深(老鸟)Linux系统运维/架构师，DevOps八荣八耻倡导者，业余撰稿人；精通(心虚)系统优化及网络服务管理，Linux系统定制，CDN加速和安全防御; 擅长互联网高性能网络及架构设计、虚拟化KVM及OpenStack云平台, K8S容器云和Ceph分布式存储等新技术；喜欢交流分享，活跃于社区，一直积极投身于开源活动的组织和传播。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;运维领域，每个公司都会制定自己的运维准则或者操作规范，能否分享一下贵司的经验，给我们一些参考？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;又拍云是一家提供云存储，云分发，云处理服务的公司，也是国内首创可编程CDN 服务的专业云服务提供商，特点就是7x24全年不间断服务，所以云运维也有一些律条或原则，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;先保障稳定，然后再优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过度设计或过早优化很可能会带来更多的故障停机时间，要先集中精力提高系统的可扩展性和高可用性。坚持 “先完成，再完善，后完美”，项目也是“先能用，再好用，后用好”的实施策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;提供可靠的测试依据和时间验证&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入新技术到架构之前，要确保新技术的稳定性和足够时间久的考验，更要有运维工程化中开发出来的工具链的完整。一旦线上返工或变更造成的措手不及可能已经是故障的导火索。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用可控的自动化手段提升效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动部署、自动编排、自动巡检、自动升级等自动化手段越来越多应用于云运维。这是适应云计算时代的趋势，但能力越强，责任越大，要谨慎自动化的雪崩和惊群效应，做好灰度/蓝绿部署和各种测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;保持简单，监控一切&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保持简单，别把事搞得太复杂。除了常见的异常问题报警外，面向业务指标，市场指标和销售数据，成本等都可以用来做趋势分析信息。定期的轮询查看各个趋势数据的峰值峰谷有助于见微知著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向预算的运维&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运维团队通常是最大的花费者，因为预算不足，没有钱的运维是很难兼顾到日益增长的公司业务规模，除非公司业务已经停滞或不再有爆炸式的增长，面对这样的挑战，运维要学会降本增益，开源节流，利用新技术实现能效比的提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向场景的智能运维&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;各种各样的负载场景，从高并发处理到视频转码，从高性能并行计算到海量的网络请求。这些不同的负载场景，对网络带宽，各种处理和IO的要求也各不相同。智能运维就是需要深入理解业务，合理配置资源和架构来满足不同业务场景的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;持续集成和发布系统&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持续发布包括灰度发布、测试发布、滚动发布、回滚发布等多种场景，并且确保每种场景都应该是可以可控的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;确保任何人都可以被替换&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;铁打的营盘流水的兵，人挪活是常态，做好员工的共享文档管理和知识传递和分享，理论上所有人都可以被替换，任何人也不应该成为公司的天花板。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;虽说成长是自己的事情，但如果有合适的场域、合适的项目机会、合适的团队、合适的机制，会让工程师的成长更快，团队更有战斗力，您能否系统的谈一下是如何促成运维同学的成长的？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;公司一直是积极鼓励员工的技能自我提高和促进成长：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每&lt;/span&gt;&lt;span&gt;月开放日：&lt;/span&gt;&lt;span&gt;公司内技术委员会会定期举办讲座，分享前沿研究中的一些收获，要求有主题，有重点，有应用场景，最好有实例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每周分享会：&lt;/span&gt;&lt;span&gt;鼓励所有开发者定期分享新的技术，谈论他们面对的问题，或者任何别的他们正思考的东西，分享的内容会形成文档和视频存档，并根据评分给予奖金和积分激励。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;公司悬赏项目：&lt;/span&gt;&lt;span&gt;无论是公司还是员工自身都可以发起项目，技术委员会评审通过后，自行组队完成，根据产出文档，数据对比，技术分享后获取相应的项目奖金。&lt;/span&gt;&lt;span&gt;申请专利还有相应的专利奖金。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;培养个人影响力：&lt;/span&gt;&lt;span&gt;鼓励员工通过发表文章或演讲的形式，走出去做工程经验分享、工作心得的梳理，提高个人的影响力，并根据受众的反馈给予稿费和讲师费激励。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;订阅报刊，杂志等纸质书籍，了解最新动态。&lt;/span&gt;&lt;span&gt;以部门为单位，配置一定的购书津贴。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;又拍云运维团队内的培养包括：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;化“天花板为托板”：&lt;/span&gt;&lt;span&gt;把自己放在一个培养新人的管理角色，不让自己成公司瓶颈和员工的天花板，鼓励新人们去尝新和处理故障，增加自身的技能和实战经验；&lt;/span&gt;&lt;span&gt;信任，互助，激励，他们会持续不断创造惊喜。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;制作“自动化工具”：&lt;/span&gt;&lt;span&gt;利用自己的经验抽象业务成程序模型，制作或培训自动化脚本的编写，提高团队的工作效率，让员工节省精力和时间去学习其它新知识；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;承担“高精专”项目：&lt;/span&gt;&lt;span&gt;提前准备最新知识的研究和可行性分析，整理成文档作公开培训，再交给团队去深入研究和实施，转化成生产力，积累一线经验再反馈完善文档，良性循环；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;积极提倡“知识分享”：&lt;/span&gt;&lt;span&gt;各种案例和“坑”都会整理成wiki文档，通过文档共享，定期分享讲座，鼓励员工撰写高质量的，可读性很强的文档，开口培训，增加感染力和自信心；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;鼓励“参与开源交流”：&lt;/span&gt;&lt;span&gt;公司鼓励员工走出去参与技术交流大会，闭门造车耗时耗力，不如专业的人点拨。&lt;/span&gt;&lt;span&gt;也会有购书经费，团建活动经费，茶歇文化；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;运维工程师其中一个典型的职业路径是做管理者，但管理者和资深运维要解决的问题截然不同，对于那些刚刚步入管理岗的资深运维，是否可以分享一些您的经验？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;对于刚步入管理岗的运维来说，我的建议是及时梳理遗留的技术债和人才技能的盘点和培养，先打好基础，后面才能有更大的空间进步，具体可以参考我的《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653574974&amp;amp;idx=1&amp;amp;sn=1e831f88bf54fd36c706a73de7b70710&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DevOps的八荣八耻&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》的分享。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一、 以可配置为荣，以硬编码为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;二、 以互&lt;/span&gt;&lt;span&gt;备&lt;/span&gt;&lt;span&gt;为荣，以单点为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;三、 以随时重启为荣，以不能迁移为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;四、 以整体交付为荣，以部分交付为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;五、 以无状态为荣，以有状态为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;六、以标准化为荣，以特殊化为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;七、以自动化工具为荣，以手动和人肉为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;八、以无人值守为荣，以人工介入为耻&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;人才上技能树的盘点，主要是配合人事做好人才九宫格的划分（如果是开发或运维，把左侧的绩效换成潜力，绩效针对销售而言），考查的是管理者对员工的全方面的辨析能力，知人善用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;434&quot; data-ratio=&quot;0.5771428571428572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QMdm8cJjtkAHuLFa7y5JSxvcYzUTNuIic7ctjy9fyM9mxnIdrN76Eyp3romgGTNDNEA36jXt46TzwNHtqsoD2ZA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再结合公司的OKR目标管理来激励员工，它的优点在于聚集目标的同时，还能：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;激励个人自驱力，鼓励员工创新和反思；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;考&lt;/span&gt;查&lt;span&gt;的是相对结果，鼓励有难度的挑战和突破；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;考核的协同配合能力，鼓励员工去全方位的协调推进；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;Kubernetes火了好一段时间了，很多公司也在大规模应用了，但显然，每个技术都不是银弹，无法解决所有场景的问题，这几年观察下来，您觉得哪些公司不适合上Kubernetes？能否给一个这类公司的画像，并说明理由？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;虽然Kubernetes代表着目前为止的devops的最佳工程应用实践(真香)，但也不是所有场合都能应用，如又拍云的CDN边缘服务器，数据中心的日志分析平台，Ceph分布式存储就以物理机为主。所以，我建议找一些合适的场景先试用起来，如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;机器资源错峰空闲浪费严重的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CPU，磁盘和网络IO都不密集的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不需要持久化存储的或抢占资源的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;软件架构已经做了微服务改造的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务处理程序有周期性、可弹性扩容的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;运维和研发是最亲密的伙伴，贵司是如何做工作边界划分的？另外关于如何让这两个角色保持亲密合作，是否可以分享一些经验？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;运维工程师 = 冲锋陷阵的将军&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;软件工程师 = 坐阵帐中的军师&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;理论上，优秀的软件工程师是可以把部分(甚至全部)运维工程师的工作做掉，比如说业务软件性能的监控，如果程序员在程序中插入很多的钩子或探针，就可以统计出数据来，不需要运维劳心劳力的监控；比如说程序员在设计程序的时候，考虑到了分库分表，考虑到了大并发和分布式的设计，那运维就可以水平扩展机器就行；如果软件没有那么多bug，还有很多如果......但是，现实是残酷的，这种高水平的程序员太少了，尤其在中国，大家都忙于实现业务功能，连个文档甚至注释都不愿意写，更别提能够考虑这么周全了；同理，运维接触的很多是开源很优秀很成熟的软件，从中是可以借鉴知晓优秀软件是怎么设计的，比如优秀的程序，日志信息会非常详尽，我们可以通过标准的syslog或者日志去监控它，所以，资深的运维会:&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;积极参与事前的规划，配合开发做演练，自动化部署，协助架构改进&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合理提需求，要资源，最好是有预算，做到防患于未燃&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线上监控，故障复盘，反馈给整个团队，倒逼上下协调做改进&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;当然，要达到上述能力的运维管理，肯定需要潜心研究，承上启下，协调团队，任劳任怨的修行多年，到那个时候，运维就不再是对事情的结果负责，而是转变角色，主导和协调整个过程。当然，这里指的能力不仅仅是技能，还包括对业务的理解能力，站在公司管理层面对整个项目和资源的分配和把握。因此，运维工程师其实是现实中的软件工程师的互补，因为大家的能力侧重点不同，所以大家更要团结一体，要能够打胜仗，离开谁都是不行的，这是一个共同修炼进步的过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，我的个人观点：架构师它可能不是一个人的角色，而是一个团队的统称，它可以:&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不必冲锋陷阵，就可以纵观全局，运筹帷幄，调度所有的资源（运维架构师的功能）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可以带领和团结团队，高屋筑瓴，因时制宜的实现解决方案（软件架构师的功能）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可以把握公司业务方向和深度，洽谈合作，控制成本（业务架构&lt;/span&gt;&lt;span&gt;师&lt;/span&gt;&lt;span&gt;的功能）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;运维需要和其他多个部门沟通协作，鉴于各个团队目标关注点未必一致，合作起来可能未必有那么顺畅，针对这个问题您是用什么招来让这个过程更加顺畅的？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;其实沟通不顺畅的原因大部分在于对后果的不可预见性，你说冗余他说预算，你说架构他说工期，各有立场又各有苦衷，但就是没人对结果负责。我在工作中发现，当故障发生时，各部门的配合是空前团结，战斗力也是最强的，所以，沟通协作的关键在于：&lt;strong&gt;既要团队协作，也要责任分明&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;事前部门沟通时，确定好项目预期，成本，影响要素，故障后果及责任方；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;事后故障复盘时，根据故障原因，有理有据地“甩锅”，同时要引以为戒，亡羊补牢；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;比如说提供在线10W并发的能力，需要冗余带宽冗余服务器数量x2，因为预算不足减半所导致的后果及责任人；再比如软件设计不好，通过性能监控，发现指标异常的后果及责任人；当然，报警处理不及时，人为操作故障也会算到运维亦无可厚非；故障文化就是要关注问题和关注事情本身，对事不对人。大家都在故障中成长，在复盘中变强。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;您觉得运维工作最重要的几个目标是什么？您是怎么落地这些目标的？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;运维自动化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;监控常态化；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;日志可视化！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个篇幅太多了，不展开讲，可以参考《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=402610622&amp;amp;idx=1&amp;amp;sn=2bae92c0b14746bb815db55fecfb28db&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;云运维的启示和架构设计&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;工具选型这块，到底是自研，还是使用开源，还是使用商业产品，是如何抉择的？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;又拍云通常不会重复造轮子，但一定会先用好轮子，或者把轮子改造得更加称手，选择自研往往具备了一定的开发能力，再加上某些必要原因，如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;找不到符合要求的开源软件，如我们自研的云处理软件…&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开源软件有bug或者issue，社区短期内无法推进，但业务又急需，只能通过自研解决，如ats的内存泄露问题…&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开源软件的功能特点跟公司的业务不相符合，不得不改造软件，如nginx的防盗链模块，需要与客户对接定制…&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开源软件的设计目标过于高大上，通用性好但很臃肿，如果我们只要某个小功能点，就不需要牛刀了，如性能探针的埋点…&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有数据保护要求，或者有隐私的场合…&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;越来越多的公司在迁往公有云，云原生架构下，SRE团队的核心职能是否有些变化？应该如何凸显团队的价值呢？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;公有云作为IaaS基座，容器云作为CaaS中间层，云原生作为SaaS应用层，整个云生态日新月异，SRE团队的核心职能会更加注重顶层系统性的容量规划，指标监控，高可用性和分布式的弹性设计，所以跨平台跨部门的职能互补、团队协作、持续精进、勇于承担包括：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;积极参与事前的规划，配合开发做演练，协助架构改进；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;合理&lt;/span&gt;&lt;span&gt;提&lt;/span&gt;&lt;span&gt;可用性需求，冗余资源，最好是有预算，做到防患于未燃；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线上监控，故障分析，反馈给整个团队，倒逼上下协调做改进；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;团队的价值就在于是否总是能够接受新事物，新的挑战，各施所长，不做井底之蛙，也不是温水煮青蛙，在创新或者颠覆来临的时候，也能保持不被时代脱钩。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;对于运维工程师个体，SRE的转型路径是？应该注意些什么？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;技术领域&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;学会抽象业务模型，标准化组件，定制化脚本，自动化部署，提升整体效率；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;学&lt;/span&gt;&lt;span&gt;会收集日志和日志分析并可视化，提升运维&lt;/span&gt;&lt;span&gt;监控和预警报警的效率&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;掌握和熟悉一门或若干语言，能够帮助你成长，提升你的战斗力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;勤做笔记，温故而知新，学思结合，要学会沉&lt;/span&gt;&lt;span&gt;淀，举一反三；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;勇于面对新兴技术的挑战，打不过就学它；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;非技术领域&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;ul class=&quot; list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;学习能力，要知识面广；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;沟通方面，了解客户的精确需求；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;技术风险、人工、进度等成本，权衡取舍；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;社区活动，积极分享，锻炼口才和交流能力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提升自己的影响力，学会与人同行，可以交到更多的朋友；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;面对当下快速发展的基础技术，您对给刚入行和入行已久的运维人员，分别有什么职业规划的建议吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;首先不是工作选择人，而是人选择工作，一个人若对某方面有了兴趣，真正用心学习了近10000个小时，其实做什么都是可以的。比如说我毕业那个时候，都是强调复合型人才，根本没有运维这个职业，我们不光自己攒(DIY)机器，自学Linux操作系统，还学习编程，折腾网络，自己动手写论坛聊天室等程序；Linux给我们带来的是每天都有创新的，好玩的，优秀的开源软件让我们保持激情去尽情的折腾和学习，当互联网兴起的机会来临时，做个运维总监其实也是顺理成章的事；其实，除此之外，我还转型做过售前，技术支持，跑过市场，经常做演讲培训，所以真正的高手是什么不会学什么，技多不压身，做个懂业务、会开发的运维工程师。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;您觉得运维人员最重要的素养是什么？对新入行的运维人员有哪些寄语？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我认为最重要的能力是表达沟通能力，但不排除运维本身所需的技术储备、实践动手能力、编程能力和学习能力。考虑到运维大部分还是一个成本支出的岗位，如何把深奥隐晦的性能及瓶颈指标，用直观的图表展示来获取上层持续的投入是需要技巧的；然后面对你的同事，你的兄弟部门，也需要你的影响力去协调推进工作，如果能够做到这些，说明你已经具备了领导的才能，这样以后做什么事都会站在更高的水平，用全局观的格局去统筹规划整个项目的目标，人员，工期和资源的合理分配和把握。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;快 来&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 找 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;又&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 小 拍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;319&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;319&quot; data-fileid=&quot;506103129&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUFAQemPjhnJTKkl7TwPLibto5mn4m21ZrshVQSeibqIYTw6XqhicImzlLxeW0v3BE4ycJbHd84ic5Oiayg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;推 荐 阅 读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653589640&amp;amp;idx=1&amp;amp;sn=8dbeb290e2cc659e1e639f4eb5a324a6&amp;amp;chksm=bd1b04008a6c8d16b39bd98755ce9a85a0e5da0dc44c4245b1d75f414390d16fddd8c1b7f044&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUGvH37edncA3k7EPQ8zC27eKVib2G8zibuiaU4BaoXicDEBs2o4A52e1iciapBkyWKHuuzmia1QcOTmzNDrA/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653589649&amp;amp;idx=1&amp;amp;sn=d7cc5a26a0498925fda9d6157086b65f&amp;amp;chksm=bd1b04198a6c8d0f6cecb7542c37f5b799db6d7d9e64bbd966d595482da65c1d3ee0e0503c5d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUGvH37edncA3k7EPQ8zC27eCIsiaNWy6f5L1DcON4VXWkZrslDiap9y59PUN6EkZLhW7TmrhKKQaDibw/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653589680&amp;amp;idx=1&amp;amp;sn=cb7a8f71ffc15f8d81b2c5d38bb09d2c&amp;amp;chksm=bd1b04388a6c8d2e0a2bb6f8512529eee3195697f393bf1f0823f58c3ef1090c98959100af4a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUGvH37edncA3k7EPQ8zC27eNJibYhHnYnQeuIA2v3uHOWbiaWiaekpIk8xZLHTZUqtWc9tiaNLHcBR9Bw/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;506103126&quot; data-ratio=&quot;0.9037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUHbb6jzHdqCC83fulktKZtY2WUNN9vVlgibWSiaR7RDHYbVyTy8icCibHV04APOmEqXhdoJv7GHJDMgvg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;135&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;更新不错过&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ade3ccc65d2c7f2cb5385c9436f4859c</guid>
<title>KCL v0.4.5 发布：更好的编写便利性改进，稳定性，体验提升与多平台支持</title>
<link>https://toutiao.io/k/gvoaxer</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18808777429467086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/pQIKoiaRd0nOfiaaQNYDuTZgS9RJ9nh5LL9Un9EvGdgJYibT8ODWPXZb6NjtGDoR6vjZgxRg4mmTK221yDibt6poTw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KCL 团队很高兴地宣布 KCL v0.4.5 版本现在已经可用！本次发布主要为 KCL 语言编写便利性和稳定性提升，错误信息改进以及更多平台包括 windows 版本支持以及更多下载方式支持。在 KCL v0.4.5 版本中，用户可以通过编写更少的 KCL 代码消除更多的配置模版；在新版本中提供了初步的 KCL Playground 支持可用于在线免安装编写并运行 KCL 代码；此外此次更新还包含多项编译器报错信息优化和错误修复。&lt;/p&gt;&lt;p&gt;您可以在 KCL v0.4.5 发布页面 或者 KCL 官方网站 获得 KCL 二进制下载链接和更多详细发布信息。&lt;/p&gt;&lt;p&gt;&lt;span&gt;发布页面：&lt;/span&gt;&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/KCLVM/releases/tag/v0.4.5&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;官方网站：&lt;span&gt;https://kcl-lang.io&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;KCL 是一个开源的基于约束的记录及函数语言，期望通过成熟的编程语言技术和实践来改进对大量繁杂配置和策略的编写，致力于构建围绕配置的更好的模块化、扩展性和稳定性，更简单的逻辑编写，以及更快的自动化集成和良好的生态延展性。&lt;/p&gt;&lt;p&gt;本文将会介绍 KCL v0.4.5 版本的更新内容以及 KCL 社区的近期动态。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;语言更新&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;KCL 语言编写便利性改进&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;支持 Schema 非空属性惰性校验&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在之前的 KCL 版本中，我们已经支持了 schema 属性互相引用（包含继承）以及 check 校验表达式的惰性求值与校验能力，在此次版本更新中，我们支持了更多的 schema 惰性求值能力: Schema 属性非空惰性校验。比如对于下述的 KCL 的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;schema Spec:&lt;br/&gt;    id: int&lt;br/&gt;    value: str&lt;br/&gt;&lt;br/&gt;schema Config:&lt;br/&gt;    name?: str&lt;br/&gt;    spec: Spec = Spec {  &lt;span&gt;# 在 KCL v0.4.5 版本之前，这个语句会报属性非空错误，v0.4.5 版本之后，支持 Schema 非空属性惰性校验能力&lt;/span&gt;&lt;br/&gt;        id = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;config = Config {&lt;br/&gt;    spec.value = &lt;span&gt;&quot;value&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 v0.4.5 之前的 KCL 版本中，直接执行上述代码会在 &lt;code&gt;schema Config&lt;/code&gt; 语句块的 &lt;code&gt;spec: Spec = Spec {&lt;/code&gt; 处抛出一个 &lt;code&gt;spec&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; 属性不能为空的错误，因为在该处只对 &lt;code&gt;spec&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 属性赋值为 &lt;code&gt;1&lt;/code&gt;，而没有对 &lt;code&gt;spec&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; 属性赋值。&lt;/p&gt;&lt;p&gt;在 KCL 的 v0.4.5 版本更新后，我们支持了 schema 属性的惰性非空校验能力之后会避免这个错误的抛出，即当在 &lt;code&gt;config&lt;/code&gt; 属性的 &lt;code&gt;spec.value = &quot;value&quot;&lt;/code&gt; 与 &lt;code&gt;spec.id = 1&lt;/code&gt; 合并之后才会递归地对 &lt;code&gt;config&lt;/code&gt; 的所有属性进行非空检查，此时 &lt;code&gt;spec&lt;/code&gt; 属性的所有值是完整的 (&lt;code&gt;spec&lt;/code&gt; 的 &lt;code&gt;id&lt;/code&gt; 字段的值为 &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; 字段为 &lt;code&gt;&quot;value&quot;&lt;/code&gt;，)，不会抛出必选属性字段为空错误。&lt;/p&gt;&lt;p&gt;因此在 v0.4.5 版本之后，执行上述 KCL 代码，我们会得到如下所示的完整 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;config:&lt;br/&gt;  spec:&lt;br/&gt;    id: 1&lt;br/&gt;    value: value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;支持配置块属性互相引用以消除更多的配置模版&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在 v0.4.5 之前的版本中，KCL 尚未支持配置块内部的属性互相引用，导致在某些场景中会需要定义额外的配置变量或者模版来进行引用，会产生较多的配置模版和重复代码，比如对于如下所示的 KCL 代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;name = &lt;span&gt;&quot;app-name&quot;&lt;/span&gt;&lt;br/&gt;data = {&lt;br/&gt;    name = name&lt;br/&gt;    metadata.name = name  &lt;span&gt;# metadata.name 不能直接引用 data 内部的 name 属性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;data&lt;/code&gt; 配置块的 &lt;code&gt;metadata.name&lt;/code&gt; 属性不能直接引用 &lt;code&gt;data&lt;/code&gt; 内部的 &lt;code&gt;name&lt;/code&gt; 属性，需要额外定义一个全局变量 &lt;code&gt;name&lt;/code&gt; 进行引用。&lt;/p&gt;&lt;p&gt;而在 KCL 的 v0.4.5 版本更新后，我们支持了配置块属性互相引用的特性，可以用于消除更多的配置模版，比如如下所示的 KCL 代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data = {&lt;br/&gt;    name = &lt;span&gt;&quot;app-name&quot;&lt;/span&gt;&lt;br/&gt;    metadata.name = name  &lt;span&gt;# 直接引用 data 配置的 name 属性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;data&lt;/code&gt; 配置块的 &lt;code&gt;metadata.name&lt;/code&gt; 属性可以直接引用 &lt;code&gt;data&lt;/code&gt; 内部的 &lt;code&gt;name&lt;/code&gt; 属性而无需定义额外的全局变量。&lt;/p&gt;&lt;p&gt;执行上述 KCL 代码可以获得如下 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data:&lt;br/&gt;  name: app-name&lt;br/&gt;  metadata:&lt;br/&gt;    name: app-name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是一个更复杂的例子&lt;/p&gt;&lt;pre&gt;&lt;code&gt;name = &lt;span&gt;&quot;global-name&quot;&lt;/span&gt;&lt;br/&gt;metadata = {&lt;br/&gt;    name = &lt;span&gt;&quot;metadata-name&quot;&lt;/span&gt;&lt;br/&gt;    labels = {&lt;br/&gt;        &lt;span&gt;&quot;app.kubernetes.io/name&quot;&lt;/span&gt; = name  &lt;span&gt;# 直接引用 `metadata.name`&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;app.kubernetes.io/instance&quot;&lt;/span&gt; = name  &lt;span&gt;# 直接引用 `metadata.name`&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;data = {&lt;br/&gt;    name = name  &lt;span&gt;# 引用全局的 name 变量&lt;/span&gt;&lt;br/&gt;    metadata = metadata  &lt;span&gt;# 引用全局的 metadata 变量&lt;/span&gt;&lt;br/&gt;    spec.template.metadata.name = metadata.name  &lt;span&gt;# 引用 data 内部的 metadata 变量&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行上述代码可以获得如下 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;name: global-name&lt;br/&gt;metadata:&lt;br/&gt;  name: metadata-name&lt;br/&gt;  labels:&lt;br/&gt;    app.kubernetes.io/name: metadata-name&lt;br/&gt;    app.kubernetes.io/instance: metadata-name&lt;br/&gt;data:&lt;br/&gt;  name: global-name&lt;br/&gt;  metadata:&lt;br/&gt;    name: metadata-name&lt;br/&gt;    labels:&lt;br/&gt;      app.kubernetes.io/name: metadata-name&lt;br/&gt;      app.kubernetes.io/instance: metadata-name&lt;br/&gt;  spec:&lt;br/&gt;    template:&lt;br/&gt;      metadata:&lt;br/&gt;        name: metadata-name&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;注意：当前 KCL 版本尚未支持配置块内部属性后向引用以及直接跳过内部作用域引用全局变量，需要将被引用的属性书写在配置引用处的前方&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;KCL 语言新增功能&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;字符串 format 成员函数支持索引格式化&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在 KCL v0.4.5 版本更新后，KCL 支持了类似 Python 字符串 format 成员函数在 &lt;code&gt;{}&lt;/code&gt; 格式化块中使用 &lt;code&gt;&amp;lt;format_ele_index&amp;gt;[&amp;lt;index_or_key&amp;gt;]&lt;/code&gt; 索引标记样式对列表和字典类型的 KCL 变量进行格式化。其中&lt;/p&gt;&lt;p&gt;比如对于如下的 KCL 代码&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 0[0] 表示取 [&quot;Hello&quot;, &quot;World&quot;] 的第 0 个元素：&quot;Hello&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 0[1] 表示取 [&quot;Hello&quot;, &quot;World&quot;] 的第 1 个元素：&quot;World&quot;&lt;/span&gt;&lt;br/&gt;listIndexFormat = &lt;span&gt;&quot;{0[0]}{0[1]}&quot;&lt;/span&gt;.format([&lt;span&gt;&quot;Hello&quot;&lt;/span&gt;, &lt;span&gt;&quot;World&quot;&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;# 0[0] 表示取 [&quot;0&quot;, &quot;1&quot;] 的第 0 个元素：&quot;1&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 1[Hello] 表示取 {&quot;Hello&quot;: &quot;World&quot;} 键值为 Hello 的字典元素：&quot;World&quot;&lt;/span&gt;&lt;br/&gt;dictIndexFormat = &lt;span&gt;&quot;0{0[0]}, 1{0[1]}, Hello{1[Hello]}&quot;&lt;/span&gt;.format([&lt;span&gt;&quot;0&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;], {&lt;span&gt;&quot;Hello&quot;&lt;/span&gt;: &lt;span&gt;&quot;World&quot;&lt;/span&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行上述代码可以获得如下 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;listIndexFormat: HelloWorld&lt;br/&gt;dictIndexFormat: &quot;00, 11, HelloWorld&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;KCL 语言 Playground 更新&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在此次更新中，我们更新了 KCL Playground 的版本并支持 KCL 代码自动编译和格式化两项能力，您可以通过访问 KCL 官网 并点击 Playground 按钮进行体验。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2881861575178998&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pQIKoiaRd0nMBF2asDd1Zsr1C7IHFVwLLE0rwKGjXqDTicE7xjI7upErNh2iaXYbJfPGHT3F8H3Y8PmEQ1MnIb7PA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3352&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2828863346104725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pQIKoiaRd0nMBF2asDd1Zsr1C7IHFVwLLhdiaoL3xuYF3xQIFD2qG355vibvSACaIk3sDHibmk21DFCOibEbAdr0uog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3132&quot;/&gt;&lt;/p&gt;&lt;p&gt;在后续 KCL 版本中，我们会持续更新 KCL Playground 更多能力支持如 KCL 版本选择与代码分享等功能。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;KCL 更多平台和下载方式支持&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;Windows 版本支持&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;KCL Windows 二进制版本可以从 Github 手动下载并安装，下载完成后将 &lt;code&gt;{install-location}\kclvm\bin&lt;/code&gt; 添加到环境变量 PATH 中。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$env:PATH += &quot;;{install-location}\kclvm\bin;&quot;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;更多下载方式支持&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在此次版本更新中，我们支持了更多的 KCL 下载方式，包括脚本, Python, Go, Homebrew 和 Docker 一键安装，更多详细内容请参考&lt;em&gt;&lt;span&gt;https://kcl-lang.io/docs/user_docs/getting-started/install&lt;/span&gt;&lt;/em&gt;，后续我们会支持更多 KCL 安装方式。&lt;/p&gt;&lt;h4&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;⚠️ 注意：对于上述所有操作系统和安装方式，如果要使用 KCL Python 插件 能力，需要确保已经安装了 Python 3.7+ 版本并将 python3 命令添加到您的 PATH 环境变量中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;错误修复&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;当存在非配置表达式的右值时配置合并顺序错误&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;schema Resource:&lt;br/&gt;    cpu: int&lt;br/&gt;    memory: str&lt;br/&gt;&lt;br/&gt;schema Config:&lt;br/&gt;    resource: Resource&lt;br/&gt;&lt;br/&gt;r = Resource {&lt;br/&gt;    cpu = &lt;span&gt;4&lt;/span&gt;&lt;br/&gt;    memory = &lt;span&gt;&quot;8Gi&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;config: Config {&lt;br/&gt;    resource: Resource {&lt;br/&gt;        cpu = &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        memory = &lt;span&gt;&quot;4Gi&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;config: Config {&lt;br/&gt;    resource: r&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 KCL v0.4.5 版本之前，执行上述代码 (main.k) 会得到非预期的配置值，是因为 KCL 编译器错误地优化了如下形式等效合并配置块&lt;/p&gt;&lt;pre&gt;&lt;code&gt;config: Config {&lt;br/&gt;    resource: r&lt;br/&gt;    resource: Resource {&lt;br/&gt;        cpu = 2&lt;br/&gt;        memory = &quot;4Gi&quot;&lt;br/&gt;    }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;KCL v0.4.5 版本更新后，修正了不正确配置合并顺序，可以执行 main.k 并获得预期的 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;r:&lt;br/&gt;  cpu: 4&lt;br/&gt;  memory: 8Gi&lt;br/&gt;config:&lt;br/&gt;  resource:&lt;br/&gt;    cpu: 4&lt;br/&gt;    memory: 8Gi&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多详情请参考 KCL Issue #422&lt;/p&gt;&lt;h3&gt;&lt;span&gt;配置 if 表达式类型不匹配错误优化&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;config: {&lt;span&gt;&quot;A&quot;&lt;/span&gt;|&lt;span&gt;&quot;B&quot;&lt;/span&gt;: int} = {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;        A = &lt;span&gt;&quot;2&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 KCL v0.4.5 版本之前，对于配置 if 表达式，执行上述代码会得到预期的配置值导致 Type Unsoundness 问题，是因为 KCL 编译器错误地没有检查出 A 属性的值 &lt;code&gt;&quot;2&quot;&lt;/code&gt; 与声明的类型 &lt;code&gt;int&lt;/code&gt; 不匹配，KCL v0.4.5 版本更新后，修正了此类问题，可以执行上述代码可以获得预期的类型不匹配错误:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;KCL Compile Error[E2G22] : The type got is inconsistent with the type expected&lt;br/&gt;---&amp;gt; File main.k:1:1&lt;br/&gt;1 |config: {&quot;A&quot;|&quot;B&quot;: int} = {&lt;br/&gt; 1 ^  -&amp;gt; got {str(A):str(2)}&lt;br/&gt;expect {str(A)|str(B):int}, got {str(A):str(2)}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更多详情请参考 KCL Issue #389&lt;/p&gt;&lt;h3&gt;&lt;span&gt;Rule 语句校验不生效问题&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;在之前的 KCL 版本中，在使用如下 rule 规则代码时 (main.k)，&lt;code&gt;ServiceCheckRule&lt;/code&gt; 的约束代码会不生效。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;protocol KubeResourceProtocol:&lt;br/&gt;    svc: Service&lt;br/&gt;&lt;br/&gt;schema Service:&lt;br/&gt;    name: str&lt;br/&gt;&lt;br/&gt;rule ServiceCheckRule &lt;span&gt;for&lt;/span&gt; KubeResourceProtocol:&lt;br/&gt;    svc.name != &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;svc = Service {&lt;br/&gt;    name = &lt;span&gt;&quot;name&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ServiceCheckRule {&lt;br/&gt;    svc = svc&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进行改进后，我们执行上述代码，会得到一个准确的校验不通过错误:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;KCL Runtime Error[E3B17] : Schema check is failed to check condition&lt;br/&gt;---&amp;gt; File main.k:14&lt;br/&gt;14 |ServiceCheckRule { -&amp;gt; Instance check failed&lt;br/&gt;    ---&amp;gt; File main.k:8&lt;br/&gt;    8 |    svc.name != &quot;name&quot; -&amp;gt; Check failed on the condition&lt;br/&gt;Check failed on check conditions&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;配置块属性类型推导优化&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;schema Id:&lt;br/&gt;    id?: int = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;schema Config:&lt;br/&gt;    data?: {&lt;span&gt;&quot;A&quot;&lt;/span&gt;|&lt;span&gt;&quot;B&quot;&lt;/span&gt;: Id}&lt;br/&gt;&lt;br/&gt;c = Config {&lt;br/&gt;    data = {&lt;br/&gt;        A = Id()  &lt;span&gt;# v0.4.5 版本之前，此处会得到一个类型不匹配错误&lt;/span&gt;&lt;br/&gt;        B = Id()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 KCL v0.4.5 版本之前，执行上述代码会得到一个非预期的类型不匹配，是因为 KCL 编译器错误地将 &lt;code&gt;c.data.A&lt;/code&gt; 属性的类型推导为 &lt;code&gt;str&lt;/code&gt; 类型，导致与 &lt;code&gt;&quot;A&quot;|&quot;B&quot;&lt;/code&gt; 字面值联合类型不匹配错误，KCL v0.4.5 版本更新后，修正了此类问题，可以执行上述代码可以获得预期的 YAML 输出:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;c:&lt;br/&gt;  data:&lt;br/&gt;    A:&lt;br/&gt;      id: 1&lt;br/&gt;    B:&lt;br/&gt;      id: 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;赋值语句使用 schema 类型注解错误优化&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;schema Foo:&lt;br/&gt;    foo: int&lt;br/&gt;&lt;br/&gt;schema Bar:&lt;br/&gt;    bar: int&lt;br/&gt;&lt;br/&gt;foo: Foo = Bar {  &lt;span&gt;# v0.4.5 版本之前，此处会得到一个运行时类型不匹配错误&lt;/span&gt;&lt;br/&gt;    bar: &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 KCL v0.4.5 版本之前，执行上述代码会得到一个运行时类型不匹配错误，版本更新后，会将此类类型不匹配错误优化到编译时，将错误左移，更早地发现此类错误。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;KCL 模块类型使用 ?. 运算符类型错误修复&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; math&lt;br/&gt;&lt;br/&gt;data = math?.log(&lt;span&gt;10&lt;/span&gt;)  &lt;span&gt;# v0.4.5 版本之前，此处会得到一个非预期的 `math is not defined` 错误&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 KCL v0.4.5 版本之前，执行上述代码会得到一个非预期的变量未定义错误，是因为 KCL 编译器没有正确地处理 &lt;code&gt;math&lt;/code&gt; module 类型和 &lt;code&gt;?.&lt;/code&gt; 运算符结合使用的情况，版本更新后，此类问题得到修复。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;其他更新与错误修复&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;更多更新与错误修复详见：&lt;span&gt;&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/KCLVM/milestone/3&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;文档更新&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;KCL 网站 新增 KCL v0.4.5 文档内容并支持版本化语义选项，目前支持 v0.4.3, v0.4.4 和 v0.4.5 版本选择。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2733770101250744&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pQIKoiaRd0nMBF2asDd1Zsr1C7IHFVwLLRRpViba0rT8Xwl1fHqdZfyQWdKZAafMzcichfWBBP8bAicLVCu4mBITew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3358&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;社区动态&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;KCL 社区新增两名外部贡献者 @thinkrapido, @Rishav1707, 感谢他们热情并积极地参与贡献。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;感谢 @Rishav1707 基于 KCL 建立了 Rust 语言版本的 kcl-loader-rs 子项目，当前版本支持根据 KCL 文件中的 Schema 和配置定义自动生成 Rust 结构体并支持 KCL 值到 Rust 结构体值的反序列化函数。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;下一步计划&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;预计 2023 年 4 月中旬，我们将发布 KCL v0.4.6 版本，预期重点演进包括：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;KCL 语言进一步编写便利性改进，用户界面持续优化与&lt;strong&gt;体验提升，用户支持和痛点解决&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全新版本的 KCL Language Server 和 VSCode 插件，性能预计&lt;strong&gt;提升 20 倍&lt;/strong&gt;，支持代码警告和错误波浪线提示，跳转，引用查找等基础能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;针对 Kubernetes Manifests 配置管理场景痛点持续进行语言能力提升：如设计提供 Helm KCL Schema 插件以及为 kpt 工具提供 KCL SDK 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KCL 包管理工具 KPM 发布，预期支持 Git 仓库代码依赖配置与更新，代码下载等基础能力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KCL Playground 支持代码分享能力和 KCL 版本选择能力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KCL Go SDK 更多能力支持：如支持 KCL Schema 和 Go 结构体的双向转换等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KCL Python SDK 更多能力支持：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;更&lt;/span&gt;&lt;span&gt;多详情请参考 KCL v0.4.6 Milestone：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/KCLVM/milestone/4&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span/&gt;&lt;/em&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;常见问题及解答&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;详见 KCL 常见问题：&lt;span&gt;&lt;em&gt;https://kcl-lang.io/docs/user_docs/support/faq-kcl&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;其他资源&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;感谢所有 KCL 用户在此次版本更新过程中提出的宝贵的反馈与建议。更多其他资源请参考：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;KCL 网站：&lt;em&gt;&lt;span&gt;https://kcl-lang.io&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kusion 网站：&lt;em&gt;&lt;span&gt;https://kusionstack.io&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;KCL Github 仓库：&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/KCLVM/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kusion Github 仓库：&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/kusion/&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Konfig Github 仓库：&lt;span&gt;&lt;em&gt;https://github.com/KusionStack/konfig/&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;欢迎加入我们的社区进行交流 👏👏👏：&lt;em&gt;&lt;span&gt;https://github.com/KusionStack/community&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;往期内容回顾&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484408&amp;amp;idx=1&amp;amp;sn=b2de618bd48d12322f3c37965c02ab67&amp;amp;chksm=c192c794f6e54e82d4fd45b23c541730375b4209fb30a851232c5ac95edc401cdd57e3ec6a75&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;KCL 与其他 Kubernetes 配置管理工具的异同 - Helm 篇 [一个自研编程语言能做什么？(系列 3)]&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;KCL 与其他 Kubernetes 配置管理工具的异同 - Helm 篇 [一个自研编程语言能做什么？(系列 3)]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484196&amp;amp;idx=1&amp;amp;sn=2fff6d51485f09efb58b54a42ce7e494&amp;amp;chksm=c192c748f6e54e5ed4b9b9fd1c3f1672b50f7b57657baf0d79535e6429a640cb58909b7cb55f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;KCL 与其他 Kubernetes 配置管理工具的异同 - Kustomize 篇 [一个自研编程语言能做什么？(系列 2)]&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;KCL 与其他 Kubernetes 配置管理工具的异同 - Kustomize 篇 [一个自研编程语言能做什么？(系列 2)]&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484046&amp;amp;idx=1&amp;amp;sn=79d064d38db3e28ffd19d6ef862dcb40&amp;amp;chksm=c192c6e2f6e54ff4d17650b52b04a7aaa16c8e1143c615b67f56f825913e3c5c09cc64276d03&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;[用一个自研的编程语言能做什么? (系列文章 1)] KCL - 让 Kubernetes 资源清单管理更容易&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;[用一个自研的编程语言能做什么? (系列文章 1)] KCL - 让 Kubernetes 资源清单管理更容易&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484114&amp;amp;idx=1&amp;amp;sn=5a9804fdad265871586f20dd777a47d3&amp;amp;chksm=c192c6bef6e54fa8c3a384343a783c0d8dd0e1502e12153561b3f4baefb4a6de7774562726b4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;KCL v0.4.4 发布 - 支持自定义 YAML 输出，Python SDK，安装体积缩减，报错信息优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;KCL v0.4.4 发布 - 支持自定义 YAML 输出，Python SDK，安装体积缩减，报错信息优化&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484397&amp;amp;idx=1&amp;amp;sn=5eb00e7d47ab83cfe26c4e2b9d346d56&amp;amp;chksm=c192c781f6e54e9782ac00dd1fb57a009811e724ed77335584a7d7c604381f0f4bc338d38ae5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Hi，Everybody，Kusion v0.7.3 发布啦&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Hi，Everybody，Kusion v0.7.3 发布啦&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484398&amp;amp;idx=1&amp;amp;sn=816f268089722f57d8fa24ace894bfa2&amp;amp;chksm=c192c782f6e54e948bfaa3288f2fa25ee21aac4210f884956afb3ee3110e7eddef26ea049675&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;性能提升 40 倍！我们用 Rust 重写了自己的项目&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;性能提升 40 倍！我们用 Rust 重写了自己的项目&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484404&amp;amp;idx=1&amp;amp;sn=0acff093b0b9ae86c464448eb2dbed25&amp;amp;chksm=c192c798f6e54e8e6a804ebb7d7d7709043055a66a90f7546c88f875cfd6c4ec2a16efdfd3a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DevOps 前沿开源技术解读——平台工程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;DevOps 前沿开源技术解读——平台工程&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pQIKoiaRd0nOfiaaQNYDuTZgS9RJ9nh5LLoluNSaUCvwyouIicATBbn1VqZKaGCpavMj18b2fYpWwDtz04Gs2xiakw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyMDM5Mjk2Mw==&amp;amp;mid=2247484404&amp;amp;idx=1&amp;amp;sn=0acff093b0b9ae86c464448eb2dbed25&amp;amp;chksm=c192c798f6e54e8e6a804ebb7d7d7709043055a66a90f7546c88f875cfd6c4ec2a16efdfd3a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DevOps 前沿开源技术解读——平台工程&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>410e9f7625f7689103bf7111900dd19d</guid>
<title>《Spring 核心技术》第 5 章：三万字深度解析 @Import 注解</title>
<link>https://toutiao.io/k/y3yhvlc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：冰河&lt;br/&gt;星球：http://m6z.cn/6aeFbs&lt;br/&gt;博客：https://binghe.gitcode.host&lt;br/&gt;文章汇总：https://binghe.gitcode.host/md/all/all.html&lt;br/&gt;源码地址：https://github.com/binghe001/spring-annotation-book/tree/master/spring-annotation-chapter-05&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;沉淀，成长，突破，帮助他人，成就自我。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大家好，我是冰河~~&lt;/strong&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「本章难度」&lt;/strong&gt;：★★★★☆&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「本章重点」&lt;/strong&gt;：进一步学习并掌握@Import注解向Spring IOC容器中注入Bean的示例与流程，从源码级别彻底掌握@Import注解在Spring底层的执行流程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节目录如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;学习指引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注解说明&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用案例&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;引入普通类案例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入实现了ImportSelector接口的类案例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入实现了ImportBeanDefinitionRegistrar接口的类案例&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;源码时序图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源码解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总结&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;思考&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VIP服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、学习指引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Import注解是什么？&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想深入学习一项技术并不是一朝一夕就能够完成的，它需要我们花费大量的时间和精力，塌下心来深入研究，从不知道，到了解，再到熟悉，最后到精通，这需要一个不断深入研究，不断实践的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学习Spring亦是如此，要想掌握好Spring的核心技术，同样需要塌下心来不断研究和实践。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、注解说明&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;关于@Import注解的一点点说明~~&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Import注解可以将第三方包中的类对象注入到IOC容器中。使用Spring开发业务系统时，@Import注解的使用频率不及@Bean注解，@Import注解往往在一些中间件或者框架项目中使用的比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Spring底层，也大量使用了@Import注解来向IOC容器中注入Bean对象。当然，如果在开发业务系统时，也可以使用@Import注解向IOC容器中注入Bean对象。@Import注解相比于@Bean注解来讲，在使用上会更加灵活。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 注解源码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Import注解只能标注到类或其他注解上，通常与配置类一起使用的，使用此注解引入的类上可以不再使用@Configuration，@Component等注解标注。本节，就对@Import注解的源码进行简单的剖析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Import注解的源码详见：org.springframework.context.annotation.Import，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * Since: 3.0&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; Chris Beams&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; Juergen Hoeller&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Import {&lt;br/&gt; Class&amp;lt;?&amp;gt;[] value();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从@Import源码的注释可以看出，@Import是Spring从3.0版本开始提供的注解，注解中只有一个Class数组类型的value属性。含义如下所示。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;value：Class数组类型，用于指定其他配置类的字节码，支持指定多个配置类。另外，使用value属性指定的有一定的条件，必须是普通类、实现了ImportSelector接口的类和实现了ImportBeanDefinitionRegistrar接口的类。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：@Import注解只能标注到类上。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 注解使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用Spring进行开发时，如果涉及到的配置项比较多，要是将所有的配置项都写到一个类里，则配置结构和配置内容将会变得非常杂乱，如果此时使用@Import注解，则可以将配置项进行分类管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，如果在项目中需要引入第三方的类，并且需要将这些类的对象注入到IOC容器中，也可以使用@Import注解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、使用案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Import注解案例实战~~&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Import注解可以引入三种类，分别如下所示。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;引入普通类，将Bean对象注入到IOC容器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入实现了ImportSelector接口的类，将selectImports()方法返回的Bean数组注入到IOC容器，但是实现了ImportSelector接口的类对象本身不会被注册到IOC容器中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入实现了ImportBeanDefinitionRegistrar接口的类，使用registerBeanDefinitions()方法中的BeanDefinitionRegistry对象注入BeanDefinition对象到IOC容器中，但是实现了ImportBeanDefinitionRegistrar接口的类对象本身不会被注册到IOC容器中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 引入普通类案例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节，主要实现使用@Import注解实现引入普通类，并且将Bean对象注入到IOC容器中的案例。具体实现步骤如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）新建User类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;User类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.bean.User，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long userId;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;    &lt;span&gt;//#############省略getter/serrer方法############&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，User类就是一个普通的类对象，后续会通过@Import注解引入User类，并且将User类的对象注入到IOC容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）新建Spring配置类ImportConfig&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportConfig类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.config.ImportConfig，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;(value = {User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，ImportConfig类主要是Spring的配置类，会在ImportConfig类上标注@Configuration注解和@Import注解，并且会通过@Import注解引入User类，将User类的对象注入到IOC容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）新建ImportTest类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportTest类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.ImportTest，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        AnnotationConfigApplicationContext context = &lt;span&gt;new&lt;/span&gt; AnnotationConfigApplicationContext(ImportConfig&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        String[] definitionNames = context.getBeanDefinitionNames();&lt;br/&gt;        Arrays.stream(definitionNames).forEach((definitionName) -&amp;gt; System.out.println(definitionName));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，ImportTest类主要是案例的测试类，在ImportTest类的main()方法中，主要打印了Bean定义的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）运行ImportTest类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行ImportTest类的main()方法，输出的结果信息如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&lt;br/&gt;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerFactory&lt;br/&gt;importConfig&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.User&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，以&lt;code&gt;org.springframework&lt;/code&gt;包命名的Bean是Spring内部的Bean。另外，可以看到，结果信息中也输出了ImportConfig类的Bean名称和User类的Bean名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：使用@Import注解可以引入普通的类，并且能够将类对象注入到Spring容器中。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 引入实现了ImportSelector接口的类案例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节，主要实现使用@Import注解引入实现了ImportSelector接口的类，将selectImports()方法返回的Bean数组注入到IOC容器中的案例。具体的实现步骤如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意：本节实现的案例是在3.1节的基础上实现的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）新建ImportSelectorBean类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportSelectorBean类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.bean.ImportSelectorBean，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportSelectorBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;//########省略getter/setter方法#########&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，ImportSelectorBean类是一个普通的类，ImportSelectorBean类的对象后续会通过ImportSelector接口的selectImports()注入到IOC容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）新建MyImportSelector类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyImportSelector类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.selector.MyImportSelector，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportSelector&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportSelector&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{ImportSelectorBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;()}&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，MyImportSelector类实现了ImportSelector接口，并实现了ImportSelector接口的selectImports()方法，在selectImports()中返回了包含ImportSelectorBean类的全类名的Spring数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）修改ImportConfig类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportConfig类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.config.ImportConfig，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;(value = {User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在ImportConfig类上标注的@Import注解的value属性中，新增MyImportSelector类的Class对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）运行ImportTest类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行ImportTest类的main()方法，输出的结果信息如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&lt;br/&gt;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerFactory&lt;br/&gt;importConfig&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.User&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.ImportSelectorBean&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在输出的结果信息中，除了有Spring内部的Bean对象的名称、ImportConfig类的Bean对象名称和User类的Bean对象名称外，还输出了ImportSelectorBean类的Bean对象名称。但是，并没有输出实现了ImportSelector接口的MyImportSelector类的Bean对象的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：使用@Import注解可以引入实现了ImportSelector接口的类，将selectImports()方法返回的Bean数组注入到IOC容器中，但是实现了ImportSelector接口的类对象本身不会被注册到IOC容器中。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 引入实现了ImportBeanDefinitionRegistrar接口的类案例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节，主要实现使用@Import注解引入实现了ImportBeanDefinitionRegistrar接口的类，使用registerBeanDefinitions()方法中的BeanDefinitionRegistry对象注入BeanDefinition对象到IOC容器中的案例。具体实现步骤如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）新增ImportBeanDefinitionRegistrarBean类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportBeanDefinitionRegistrarBean类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.bean.ImportBeanDefinitionRegistrarBean，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrarBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt; &lt;span&gt;//#########省略getter/setter方法############&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，ImportBeanDefinitionRegistrarBean类就是一个普通的类，后续会通过ImportBeanDefinitionRegistrar接口的实现类实现的registerBeanDefinitions()方法将ImportBeanDefinitionRegistrarBean类的Bean对象注入到IOC容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）新增MyImportBeanDefinitionRegistrar类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyImportBeanDefinitionRegistrar类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.registrar.MyImportBeanDefinitionRegistrar，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String beanName = ImportBeanDefinitionRegistrarBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;        BeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(ImportBeanDefinitionRegistrarBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        registry.registerBeanDefinition(beanName, beanDefinition);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，MyImportBeanDefinitionRegistrar类实现了ImportBeanDefinitionRegistrar接口，并实现了ImportBeanDefinitionRegistrar接口的registerBeanDefinitions()方法。在registerBeanDefinitions()方法中，获取ImportBeanDefinitionRegistrarBean类的全类名作为注入到IOC容器中的Bean名称。接下来，调用RootBeanDefinition类的构造方法传入ImportBeanDefinitionRegistrarBean类的Class对象创建BeanDefinition对象。最终，调用registry的registerBeanDefinition()方法将创建的BeanDefinition对象注入到IOC容器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）修改ImportConfig类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ImportConfig类的源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.config.ImportConfig，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Import&lt;/span&gt;(value = {User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;MyImportSelector&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;MyImportBeanDefinitionRegistrar&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;})&lt;br/&gt;@&lt;span&gt;Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ImportConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在ImportConfig类上标注的@Import注解的value属性中，新增了实现了ImportBeanDefinitionRegistrar接口的MyImportBeanDefinitionRegistrar类的Class对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（4）运行ImportTest类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行ImportTest类的main()方法，输出的结果信息如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;org.springframework.context.annotation.internalConfigurationAnnotationProcessor&lt;br/&gt;org.springframework.context.annotation.internalAutowiredAnnotationProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerProcessor&lt;br/&gt;org.springframework.context.event.internalEventListenerFactory&lt;br/&gt;importConfig&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.User&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.ImportSelectorBean&lt;br/&gt;io.binghe.spring.annotation.chapter05.bean.ImportBeanDefinitionRegistrarBean&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在输出的结果信息中，除了Spring内部的Bean名称、ImportConfig类的Bean名称、User类的Bean名称和ImportSelectorBean类的Bean名称外，还输出了ImportBeanDefinitionRegistrarBean类的名称。但是并没有输出实现了ImportBeanDefinitionRegistrar接口的MyImportBeanDefinitionRegistrar类的Bean名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;说明：使用@Import注解能够引入实现了ImportBeanDefinitionRegistrar接口的类，使用registerBeanDefinitions()方法中的BeanDefinitionRegistry对象注入BeanDefinition对象到IOC容器中，但是实现了ImportBeanDefinitionRegistrar接口的类对象本身不会被注册到IOC容器中。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、源码时序图&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;结合时序图理解源码会事半功倍，你觉得呢？&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本节，就以源码时序图的方式，直观的感受下@Import注解在Spring源码层面的执行流程。@Import注解在Spring源码层面的执行流程如图5-1~5-3所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwEUsNXjBpOJbIOlSWwn9blZo2Dzbce5uZc3q1YjHmkLeP7OWElynMMvLe7btmjSo4a0QWSViaQDE3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图5-1&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.64375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwEUsNXjBpOJbIOlSWwn9blZLO9C7Bvt2HpicXgBcYNePL4mFJOVsuO3cQbAqCjUeaVYfyUwBZKgeKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图5-2&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwEUsNXjBpOJbIOlSWwn9blZcvH2dvjC2GAcctmPHBaNiasHlXytJFbWQYZmY0Eb8lticnztwrbwlI1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;图5-3&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由图5-1~图5-3可以看出，@Import注解在Spring源码层面的执行流程会涉及到ImportTest类、AnnotationConfigApplicationContext类、AbstractApplicationContext类、PostProcessorRegistrationDelegate类、ConfigurationClassPostProcessor类、ConfigurationClassParser类、MyImportSelector类、ConfigurationClassBeanDefinitionReader类、ImportBeanDefinitionRegistrar类、MyImportBeanDefinitionRegistrar类和DefaultListableBeanFactory类。具体的源码执行细节参见源码解析部分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、源码解析&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;源码时序图整清楚了，那就整源码解析呗！&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Import注解在Spring源码层面的执行流程，结合源码执行的时序图，会理解的更加深刻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）运行案例程序启动类&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;案例程序启动类源码详见：spring-annotation-chapter-05工程下的io.binghe.spring.annotation.chapter05.ImportTest，运行ImportTest类的main()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ImportTest类的main()方法中调用了AnnotationConfigApplicationContext类的构造方法，并传入了ImportConfig类的Class对象来创建IOC容器。接下来，会进入AnnotationConfigApplicationContext类的构造方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）解析AnnotationConfigApplicationContext类的AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... componentClasses)构造方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.AnnotationConfigApplicationContext#AnnotationConfigApplicationContext(Class&amp;lt;?&amp;gt;... componentClasses)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt;... componentClasses)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;();&lt;br/&gt;    register(componentClasses);&lt;br/&gt;    refresh();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在上述构造方法中，调用了refresh()方法来刷新IOC容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）解析AbstractApplicationContext类的refresh()方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.support.AbstractApplicationContext#refresh()。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;refresh&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException, IllegalStateException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.startupShutdownMonitor) {&lt;br/&gt;        &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;            invokeBeanFactoryPostProcessors(beanFactory);&lt;br/&gt;           &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt; (BeansException ex) {&lt;br/&gt;            &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;        }&lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;refresh()方法是Spring中一个非常重要的方法，很多重要的功能和特性都是通过refresh()方法进行注入的。可以看到，在refresh()方法中，调用了invokeBeanFactoryPostProcessors()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）解析AbstractApplicationContext类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;invokeBeanFactoryPostProcessors&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!NativeDetector.inNativeImage() &amp;amp;&amp;amp; beanFactory.getTempClassLoader() == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {&lt;br/&gt;        beanFactory.addBeanPostProcessor(&lt;span&gt;new&lt;/span&gt; LoadTimeWeaverAwareProcessor(beanFactory));&lt;br/&gt;        beanFactory.setTempClassLoader(&lt;span&gt;new&lt;/span&gt; ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在AbstractApplicationContext类的invokeBeanFactoryPostProcessors()方法中调用了PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）解析PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;beanfactorypostprocessor&gt;beanFactoryPostProcessors)方法&lt;/beanfactorypostprocessor&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;beanfactorypostprocessor&gt;beanFactoryPostProcessors)。&lt;/beanfactorypostprocessor&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于方法的源码比较长，这里，只关注当前最核心的逻辑，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;invokeBeanFactoryPostProcessors&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;    List&amp;lt;BeanDefinitionRegistryPostProcessor&amp;gt; currentRegistryProcessors = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.&lt;/span&gt;&lt;br/&gt;    String[] postProcessorNames =&lt;br/&gt;        beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String ppName : postProcessorNames) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (beanFactory.isTypeMatch(ppName, PriorityOrdered&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;            processedBeans.add(ppName);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    sortPostProcessors(currentRegistryProcessors, beanFactory);&lt;br/&gt;    registryProcessors.addAll(currentRegistryProcessors);&lt;br/&gt;    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());&lt;br/&gt;    currentRegistryProcessors.clear();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.&lt;/span&gt;&lt;br/&gt;    postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String ppName : postProcessorNames) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;            currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;            processedBeans.add(ppName);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    sortPostProcessors(currentRegistryProcessors, beanFactory);&lt;br/&gt;    registryProcessors.addAll(currentRegistryProcessors);&lt;br/&gt;    invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());&lt;br/&gt;    currentRegistryProcessors.clear();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; reiterate = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (reiterate) {&lt;br/&gt;        reiterate = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String ppName : postProcessorNames) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!processedBeans.contains(ppName)) {&lt;br/&gt;                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;                processedBeans.add(ppName);&lt;br/&gt;                reiterate = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        sortPostProcessors(currentRegistryProcessors, beanFactory);&lt;br/&gt;        registryProcessors.addAll(currentRegistryProcessors);&lt;br/&gt;        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup());&lt;br/&gt;        currentRegistryProcessors.clear();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//############省略其他代码##############&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在PostProcessorRegistrationDelegate类的invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;beanfactorypostprocessor&gt;beanFactoryPostProcessors)方法中，BeanDefinitionRegistryPostProcessor的实现类在执行逻辑上会有先后顺序，并且最终都会调用invokeBeanDefinitionRegistryPostProcessors()方法。&lt;/beanfactorypostprocessor&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）解析PostProcessorRegistrationDelegate类的invokeBeanDefinitionRegistryPostProcessors(Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors(Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;invokeBeanDefinitionRegistryPostProcessors&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry, ApplicationStartup applicationStartup)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {&lt;br/&gt;        StartupStep postProcessBeanDefRegistry = applicationStartup.start(&lt;span&gt;&quot;spring.context.beandef-registry.post-process&quot;&lt;/span&gt;)&lt;br/&gt;            .tag(&lt;span&gt;&quot;postProcessor&quot;&lt;/span&gt;, postProcessor::toString);&lt;br/&gt;        postProcessor.postProcessBeanDefinitionRegistry(registry);&lt;br/&gt;        postProcessBeanDefRegistry.end();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在invokeBeanDefinitionRegistryPostProcessors()方法中，会循环遍历postProcessors集合中的每个元素，调用postProcessBeanDefinitionRegistry()方法注册Bean的定义信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）解析ConfigurationClassPostProcessor类的postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanDefinitionRegistry&lt;/span&gt;&lt;span&gt;(BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//##########省略其他代码###################&lt;/span&gt;&lt;br/&gt;    processConfigBeanDefinitions(registry);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在postProcessBeanDefinitionRegistry()方法中，会调用processConfigBeanDefinitions()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）解析ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions(BeanDefinitionRegistry registry)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里，重点关注方法中的如下逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processConfigBeanDefinitions&lt;/span&gt;&lt;span&gt;(BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//############省略其他代码#################&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Parse each @Configuration class&lt;/span&gt;&lt;br/&gt;    ConfigurationClassParser parser = &lt;span&gt;new&lt;/span&gt; ConfigurationClassParser(&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.metadataReaderFactory, &lt;span&gt;this&lt;/span&gt;.problemReporter, &lt;span&gt;this&lt;/span&gt;.environment,&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.resourceLoader, &lt;span&gt;this&lt;/span&gt;.componentScanBeanNameGenerator, registry);&lt;br/&gt;    &lt;br/&gt;    Set&amp;lt;BeanDefinitionHolder&amp;gt; candidates = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;(configCandidates);&lt;br/&gt;    Set&amp;lt;ConfigurationClass&amp;gt; alreadyParsed = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(configCandidates.size());&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        StartupStep processConfig = &lt;span&gt;this&lt;/span&gt;.applicationStartup.start(&lt;span&gt;&quot;spring.context.config-classes.parse&quot;&lt;/span&gt;);&lt;br/&gt;        parser.parse(candidates);&lt;br/&gt;        parser.validate();&lt;br/&gt;        &lt;span&gt;//############省略其他代码#################&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.reader.loadBeanDefinitions(configClasses);&lt;br/&gt;        alreadyParsed.addAll(configClasses);&lt;br/&gt;        processConfig.tag(&lt;span&gt;&quot;classCount&quot;&lt;/span&gt;, () -&amp;gt; String.valueOf(configClasses.size())).end();&lt;br/&gt;        &lt;span&gt;//############省略其他代码#################&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (!candidates.isEmpty());&lt;br/&gt;    &lt;span&gt;//############省略其他代码#################&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在processConfigBeanDefinitions()方法中，创建了一个ConfigurationClassParser类型的对象parser，并且调用了parser的parse()方法来解析类的配置信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（9）解析ConfigurationClassParser类的parse(Set&lt;beandefinitionholder&gt;configCandidates)方法&lt;/beandefinitionholder&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassParser#parse(Set&lt;beandefinitionholder&gt;configCandidates)，重点关注如下代码片段&lt;/beandefinitionholder&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(Set&amp;lt;BeanDefinitionHolder&amp;gt; configCandidates)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (BeanDefinitionHolder holder : configCandidates) {&lt;br/&gt;        BeanDefinition bd = holder.getBeanDefinition();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (bd &lt;span&gt;instanceof&lt;/span&gt; AnnotatedBeanDefinition) {&lt;br/&gt;                parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//###############省略其他代码###############&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionStoreException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; ex;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionStoreException(&lt;br/&gt;                &lt;span&gt;&quot;Failed to parse configuration class [&quot;&lt;/span&gt; + bd.getBeanClassName() + &lt;span&gt;&quot;]&quot;&lt;/span&gt;, ex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.deferredImportSelectorHandler.process();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在ConfigurationClassParser类的parse(Set&lt;beandefinitionholder&gt;configCandidates)方法中，调用了类中的另一个parse()方法。&lt;/beandefinitionholder&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（10）解析ConfigurationClassParser类的parse(AnnotationMetadata metadata, String beanName)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassParser#parse(AnnotationMetadata metadata, String beanName)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(AnnotationMetadata metadata, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    processConfigurationClass(&lt;span&gt;new&lt;/span&gt; ConfigurationClass(metadata, beanName), DEFAULT_EXCLUSION_FILTER);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，上述parse()方法的实现比较简单，直接调用了processConfigurationClass()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（11）解析ConfigurationClassParser类的processConfigurationClass(ConfigurationClass configClass, Predicate&lt;string&gt;filter)方法&lt;/string&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass(ConfigurationClass configClass, Predicate&lt;string&gt;filter)。&lt;/string&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processConfigurationClass&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass, Predicate&amp;lt;String&amp;gt; filter)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//###############省略其他代码####################&lt;/span&gt;&lt;br/&gt;    SourceClass sourceClass = asSourceClass(configClass, filter);&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        sourceClass = doProcessConfigurationClass(configClass, sourceClass, filter);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (sourceClass != &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.configurationClasses.put(configClass, configClass);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在processConfigurationClass()方法中，会通过do-while()循环获取配置类和其父类的注解信息，SourceClass类中会封装配置类上注解的详细信息。在在processConfigurationClass()方法中，调用了doProcessConfigurationClass()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（12）解析ConfigurationClassParser类的doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;string&gt;filter)方法&lt;/string&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass, Predicate&lt;string&gt;filter)，重点关注如下代码片段。&lt;/string&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; SourceClass &lt;span&gt;doProcessConfigurationClass&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;    ConfigurationClass configClass, SourceClass sourceClass, Predicate&amp;lt;String&amp;gt; filter)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//#############省略其他代码#############&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Process any @Import annotations&lt;/span&gt;&lt;br/&gt;    processImports(configClass, sourceClass, getImports(sourceClass), filter, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//#############省略其他代码#############&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// No superclass -&amp;gt; processing is complete&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在doProcessConfigurationClass()方法中，会调用processImports()方法来解析@Import注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（13）解析ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;sourceclass&gt;importCandidates, Predicate&lt;string&gt;exclusionFilter, boolean checkForCircularImports)方法。&lt;/string&gt;&lt;/sourceclass&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassParser#processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;sourceclass&gt;importCandidates, Predicate&lt;string&gt;exclusionFilter, boolean checkForCircularImports)。&lt;/string&gt;&lt;/sourceclass&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processImports&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass, SourceClass currentSourceClass,&lt;br/&gt;                            Collection&amp;lt;SourceClass&amp;gt; importCandidates, Predicate&amp;lt;String&amp;gt; exclusionFilter,&lt;br/&gt;                            &lt;span&gt;boolean&lt;/span&gt; checkForCircularImports)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//################省略其他代码#################&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.importStack.push(configClass);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (SourceClass candidate : importCandidates) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// Candidate class is an ImportSelector -&amp;gt; delegate to it to determine imports&lt;/span&gt;&lt;br/&gt;                Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                ImportSelector selector = ParserStrategyUtils.instantiateClass(candidateClass, ImportSelector&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                Predicate&amp;lt;String&amp;gt; selectorFilter = selector.getExclusionFilter();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (selectorFilter != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    exclusionFilter = exclusionFilter.or(selectorFilter);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (selector &lt;span&gt;instanceof&lt;/span&gt; DeferredImportSelector) {&lt;br/&gt;                    &lt;span&gt;this&lt;/span&gt;.deferredImportSelectorHandler.handle(configClass, (DeferredImportSelector) selector);&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());&lt;br/&gt;                    Collection&amp;lt;SourceClass&amp;gt; importSourceClasses = asSourceClasses(importClassNames, exclusionFilter);&lt;br/&gt;                    processImports(configClass, currentSourceClass, importSourceClasses, exclusionFilter, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// Candidate class is an ImportBeanDefinitionRegistrar -&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// delegate to it to register additional bean definitions&lt;/span&gt;&lt;br/&gt;                Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;                ImportBeanDefinitionRegistrar registrar =&lt;br/&gt;                    ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;,&lt;br/&gt;                                                         &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;                configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// Candidate class not an ImportSelector or ImportBeanDefinitionRegistrar -&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// process it as an @Configuration class&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.importStack.registerImport(&lt;br/&gt;                    currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());&lt;br/&gt;                processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (BeanDefinitionStoreException ex) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; ex;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (Throwable ex) {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanDefinitionStoreException(&lt;br/&gt;            &lt;span&gt;&quot;Failed to process import candidates for configuration class [&quot;&lt;/span&gt; +&lt;br/&gt;            configClass.getMetadata().getClassName() + &lt;span&gt;&quot;]: &quot;&lt;/span&gt; + ex.getMessage(), ex);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.importStack.pop();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在processImports()方法中，如果使用@Import注解引入的是实现了ImportSelector接口的类，则执行的是&lt;code&gt;if (candidate.isAssignable(ImportSelector.class))&lt;/code&gt;条件的逻辑。如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是&lt;code&gt; else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))&lt;/code&gt;条件的逻辑，否则执行的是&lt;code&gt;else&lt;/code&gt;条件的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，执行&lt;code&gt;if (candidate.isAssignable(ImportSelector.class))&lt;/code&gt;条件的逻辑时，会调用ImportSelector接口的selectImports()方法获取要注入到IOC容器中的Bean名称数组，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String[] importClassNames = selector.selectImports(currentSourceClass.getMetadata());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用ImportSelector接口的selectImports()方法时，就会调用案例程序中的MyImportSelector类的selectImports()方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（14）解析MyImportSelector类的selectImports(AnnotationMetadata importingClassMetadata)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：io.binghe.spring.annotation.chapter05.selector.MyImportSelector#selectImports(AnnotationMetadata importingClassMetadata)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; String[] selectImports(AnnotationMetadata importingClassMetadata) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; String[]{ImportSelectorBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;()}&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在MyImportSelector类的selectImports()方法中，会返回包含ImportSelectorBean类的全类名的String数组，后续会将ImportSelectorBean类的Bean对象注入IOC容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（15）回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;sourceclass&gt;importCandidates, Predicate&lt;string&gt;exclusionFilter, boolean checkForCircularImports)方法。&lt;/string&gt;&lt;/sourceclass&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则执行的是&lt;code&gt; else if (candidate.isAssignable(ImportBeanDefinitionRegistrar.class))&lt;/code&gt;条件的逻辑，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (candidate.isAssignable(ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)) &lt;/span&gt;{&lt;br/&gt;    Class&amp;lt;?&amp;gt; candidateClass = candidate.loadClass();&lt;br/&gt;    ImportBeanDefinitionRegistrar registrar =&lt;br/&gt;        ParserStrategyUtils.instantiateClass(candidateClass, ImportBeanDefinitionRegistrar&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;environment&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;resourceLoader&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;registry&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    configClass.addImportBeanDefinitionRegistrar(registrar, currentSourceClass.getMetadata());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在上述代码逻辑中会调用configClass的addImportBeanDefinitionRegistrar()方法来添加ImportBeanDefinitionRegistrar对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（16）解析ConfigurationClass类的addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClass#addImportBeanDefinitionRegistrar(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;addImportBeanDefinitionRegistrar&lt;/span&gt;&lt;span&gt;(ImportBeanDefinitionRegistrar registrar, AnnotationMetadata importingClassMetadata)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.importBeanDefinitionRegistrars.put(registrar, importingClassMetadata);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在addImportBeanDefinitionRegistrar()方法中，会将传入的registrar参数作为Key，importingClassMetadata参数作为Value存储importBeanDefinitionRegistrars结构中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，importBeanDefinitionRegistrars结构的定义如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; importBeanDefinitionRegistrars = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，importBeanDefinitionRegistrars是一个LinkedHashMap对象，也就是说，会将ImportBeanDefinitionRegistrar对象和AnnotationMetadata对象的映射关系存入一个LinkedHashMap对象中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（17）再次回到ConfigurationClassParser类的processImports(ConfigurationClass configClass, SourceClass currentSourceClass, Collection&lt;sourceclass&gt;importCandidates, Predicate&lt;string&gt;exclusionFilter, boolean checkForCircularImports)方法。&lt;/string&gt;&lt;/sourceclass&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果@Import注解引入的类既没有实现ImportSelector接口，又没有实现ImportBeanDefinitionRegistrar接口，则执行&lt;code&gt;else&lt;/code&gt;逻辑，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.importStack.registerImport(&lt;br/&gt;        currentSourceClass.getMetadata(), candidate.getMetadata().getClassName());&lt;br/&gt;    processConfigurationClass(candidate.asConfigClass(configClass), exclusionFilter);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;else&lt;/code&gt;逻辑中，会按照解析@Configuration注解的逻辑执行，有关@Configuration注解的执行流程，可以参见第1章的内容，这里不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在processImports()方法中，如果@Import注解引入的类实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的话，最终还是会执行processImports()方法的&lt;code&gt;else&lt;/code&gt;逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（18）回到ConfigurationClassPostProcessor类的processConfigBeanDefinitions(BeanDefinitionRegistry registry)方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ConfigurationClassPostProcessor类的processConfigBeanDefinitions()方法中，执行完ConfigurationClassParser类的parse()方法后，会执行ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions()方法，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;this&lt;/span&gt;.reader.loadBeanDefinitions(configClasses);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（19）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitions(Set&lt;configurationclass&gt;configurationModel)方法&lt;/configurationclass&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitions(Set&lt;configurationclass&gt;configurationModel)，如下所示。&lt;/configurationclass&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadBeanDefinitions&lt;/span&gt;&lt;span&gt;(Set&amp;lt;ConfigurationClass&amp;gt; configurationModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    TrackedConditionEvaluator trackedConditionEvaluator = &lt;span&gt;new&lt;/span&gt; TrackedConditionEvaluator();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (ConfigurationClass configClass : configurationModel) {&lt;br/&gt;        loadBeanDefinitionsForConfigurationClass(configClass, trackedConditionEvaluator);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在loadBeanDefinitions()方法中，会循环遍历传入的configurationModel集合，并调用loadBeanDefinitionsForConfigurationClass()方法处理遍历的每个元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（20）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadBeanDefinitionsForConfigurationClass&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//################省略其他代码######################&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (configClass.isImported()) {&lt;br/&gt;        registerBeanDefinitionForImportedConfigurationClass(configClass);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (BeanMethod beanMethod : configClass.getBeanMethods()) {&lt;br/&gt;        loadBeanDefinitionsForBeanMethod(beanMethod);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    loadBeanDefinitionsFromImportedResources(configClass.getImportedResources());&lt;br/&gt;    loadBeanDefinitionsFromRegistrars(configClass.getImportBeanDefinitionRegistrars());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在loadBeanDefinitionsForConfigurationClass()方法中，如果@Import注解引入的是普通的类，或者是实现了ImportSelector接口的类，则会执行&lt;code&gt;if (configClass.isImported())&lt;/code&gt;条件的逻辑，此时会调用registerBeanDefinitionForImportedConfigurationClass()方法向IOC容器中注入配置类的BeanDefinition信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（21）解析ConfigurationClassBeanDefinitionReader类的registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#registerBeanDefinitionForImportedConfigurationClass(ConfigurationClass configClass)，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitionForImportedConfigurationClass&lt;/span&gt;&lt;span&gt;(ConfigurationClass configClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//###############省略其他代码#################&lt;/span&gt;&lt;br/&gt;    BeanDefinitionHolder definitionHolder = &lt;span&gt;new&lt;/span&gt; BeanDefinitionHolder(configBeanDef, configBeanName);&lt;br/&gt;    definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, &lt;span&gt;this&lt;/span&gt;.registry);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.registry.registerBeanDefinition(definitionHolder.getBeanName(),definitionHolder.getBeanDefinition());&lt;br/&gt;    configClass.setBeanName(configBeanName);&lt;br/&gt; &lt;span&gt;//###############省略其他代码#################&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在registerBeanDefinitionForImportedConfigurationClass()方法中会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终，会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（22）回到ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果@Import注解引入的是实现了ImportBeanDefinitionRegistrar接口的类，则在loadBeanDefinitionsForConfigurationClass()方法中调用loadBeanDefinitionsForConfigurationClass()方法时，会通过configClass的getImportBeanDefinitionRegistrars()方法获取第（16）步保存信息的LinkedHashMap对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（23）解析ConfigurationClass类的getImportBeanDefinitionRegistrars()方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClass#getImportBeanDefinitionRegistrars()。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; &lt;span&gt;getImportBeanDefinitionRegistrars&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.importBeanDefinitionRegistrars;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（24）再次ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsForConfigurationClass(ConfigurationClass configClass, TrackedConditionEvaluator trackedConditionEvaluator)方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在loadBeanDefinitionsForConfigurationClass()会调用loadBeanDefinitionsFromRegistrars()方法从实现了ImportBeanDefinitionRegistrar接口的类中加载Bean定义信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（25）解析ConfigurationClassBeanDefinitionReader类的loadBeanDefinitionsFromRegistrars(Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; registrars)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsFromRegistrars(Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; registrars)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadBeanDefinitionsFromRegistrars&lt;/span&gt;&lt;span&gt;(Map&amp;lt;ImportBeanDefinitionRegistrar, AnnotationMetadata&amp;gt; registrars)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    registrars.forEach((registrar, metadata) -&amp;gt; registrar.registerBeanDefinitions(metadata, &lt;span&gt;this&lt;/span&gt;.registry, &lt;span&gt;this&lt;/span&gt;.importBeanNameGenerator));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在loadBeanDefinitionsFromRegistrars()方法中，会遍历传入的registrars，并调用每个registrar的registerBeanDefinitions()方法注册BeanDefinition信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（26）解析ImportBeanDefinitionRegistrar接口的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：org.springframework.context.annotation.ImportBeanDefinitionRegistrar#registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry,BeanNameGenerator importBeanNameGenerator)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    registerBeanDefinitions(importingClassMetadata, registry);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，registerBeanDefinitions()方法是ImportBeanDefinitionRegistrar接口的一个默认方法，并在方法中调用了另一个registerBeanDefinitions()方法。其中，调用的这个registerBeanDefinitions()方法就是我们自己写的案例中实现了ImportBeanDefinitionRegistrar接口的MyImportBeanDefinitionRegistrar类中的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（27）解析MyImportBeanDefinitionRegistrar类的registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码详见：io.binghe.spring.annotation.chapter05.registrar.MyImportBeanDefinitionRegistrar#registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    String beanName = ImportBeanDefinitionRegistrarBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getName&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;    BeanDefinition beanDefinition = &lt;span&gt;new&lt;/span&gt; RootBeanDefinition(ImportBeanDefinitionRegistrarBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    registry.registerBeanDefinition(beanName, beanDefinition);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在registerBeanDefinitions()方法中，最终会调用DefaultListableBeanFactory类的registerBeanDefinition()方法向IOC容器中注入BeanDefinition信息。最终，会将BeanDefinition信息保存到DefaultListableBeanFactory类的beanDefinitionMap中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，整个@Import注解在Spring源码层面的执行流程分析完毕。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Import注解讲完了，我们一起总结下吧！&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章，首先介绍了@Import注解的源码和使用场景，并列举了使用@Import注解向IOC容器中注入Bean对象的三种案例。接下来，详细分析了@Import注解的源码时序图和@Import注解在Spring源码层面的执行流程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、思考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;既然学完了，就开始思考几个问题吧？&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于@Import注解，通常会有如下几个经典面试题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.在ConfigurationClassParser类的processImports()中，如果@Import注解引入的是普通类或者引入的是实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的类，最终还是会执行processImports()方法的&lt;code&gt;else&lt;/code&gt;逻辑。那么，如果@Import注解引入的是实现了ImportSelector接口，并且没有实现DeferredImportSelector接口的类，最终是如何执行&lt;code&gt;else&lt;/code&gt;逻辑的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.@Import注解的三种案例在Spring底层的源码执行流程分别是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.使用@Import注解向IOC容器中注入Bean与使用@Bean注解有什么区别？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.在你自己负责的项目中，会在哪些场景下使用@Import注解向IOC容器中注入Bean？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.你从Spring的@Import注解的设计中得到了哪些启发？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;八、VIP服务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「强烈推荐阅读：《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247507869&amp;amp;idx=1&amp;amp;sn=4378abc2e18afecff84c45a6a7b0f951&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;原来大厂面试官也会在这里偷偷学习！&lt;/a&gt;》，如果文中优惠券过期，可长按或扫码下面优惠券二维码加入星球。」&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2hHcUic5FEwH6LPiaiaxWRiaEAOAHn1Lu0s6qPkBF7EJPNFCOCwRF0SKMOcBibfaOjRibqpy1gN2daqVSgm7kfpqdgPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「冰河技术」&lt;/strong&gt; 知识星球《SpringCloud Alibaba实战》从零搭建并开发微服务项目已完结，《RPC手撸专栏》已经更新120+篇文章，已提交120+项目工程，120+项目源码Tag分支，并将源码的获取方式放到了知识星球中，同时在微信上创建了专门的知识星球群，冰河会在知识星球上和星球群里解答球友的提问。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;星球提供的服务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冰河整理了星球提供的一些服务，如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入星球，你将获得：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.学习从零开始手撸可用于实际场景的高性能、可扩展的RPC框架项目&lt;br/&gt;2.学习SpringCloud Alibaba实战项目—从零开发微服务项目&lt;br/&gt;3.学习高并发、大流量业务场景的解决方案，体验大厂真正的高并发、大流量的业务场景&lt;br/&gt;4.学习进大厂必备技能：性能调优、并发编程、分布式、微服务、框架源码、中间件开发、项目实战&lt;br/&gt;5.提供站点 https://binghe.gitcode.host 所有学习内容的指导、帮助&lt;br/&gt;6.GitHub：https://github.com/binghe001/BingheGuide - 非常有价值的技术资料仓库，包括冰河所有的博客开放案例代码&lt;br/&gt;7.提供技术问题、系统架构、学习成长、晋升答辩等各项内容的回答&lt;br/&gt;8.定期的整理和分享出各类专属星球的技术小册、电子书、编程视频、PDF文件&lt;br/&gt;9.定期组织技术直播分享，传道、授业、解惑，指导阶段瓶颈突破技巧&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何加入星球&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;链接&lt;/strong&gt;：打开链接 http://m6z.cn/6aeFbs 加入星球。&lt;br/&gt;&lt;strong&gt;回复&lt;/strong&gt;：在公众号 &lt;strong&gt;「冰河技术」&lt;/strong&gt; 回复 &lt;strong&gt;「星球」&lt;/strong&gt; 领取优惠券加入星球。&lt;br/&gt;&lt;strong&gt;特别提醒：&lt;/strong&gt;苹果用户进圈或续费，请加微信 &lt;strong&gt;「hacker_binghe」&lt;/strong&gt; 扫二维码，或者去公众号 &lt;strong&gt;「冰河技术」&lt;/strong&gt; 回复 &lt;strong&gt;「星球」&lt;/strong&gt; 扫二维码加入星球。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，我们下期见~~&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>