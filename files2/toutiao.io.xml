<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d19bf178049b2fa977e222291b4c373e</guid>
<title>优质网站同好者周刊（第 081 期） | 倾城博客</title>
<link>https://toutiao.io/k/xqcapfc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界。此周刊，将汇聚过去一周&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城&lt;/a&gt;所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见&lt;a href=&quot;https://nicelinks.site/about?utm_source=weekly&quot;&gt;关于倾城&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：本周刊&lt;strong&gt;每周五&lt;/strong&gt;生成，首发于个人微信公众号&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI5MDIwMzM2Mg==&amp;amp;action=getalbum&amp;amp;album_id=1530765143352082433&amp;amp;scene=173&amp;amp;from_msgid=2650641087&amp;amp;from_itemidx=1&amp;amp;count=3#wechat_redirect&quot;&gt;晚晴幽草轩&lt;/a&gt;、博客&lt;a href=&quot;https://www.jeffjade.com&quot;&gt;晚晴幽草轩&lt;/a&gt;，以及&lt;a href=&quot;https://forum.lovejade.cn/&quot;&gt;悠然宜想亭&lt;/a&gt;社区；此一键生成脚本基于 &lt;a href=&quot;https://nicelinks.site/post/602d30aad099ff5688618591&quot;&gt;Deno&lt;/a&gt; 编写，并在 Github 开源：&lt;a href=&quot;https://github.com/nicejade/nicelinks-weekly&quot;&gt;nicejade/nicelinks-weekly&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E6%88%AA%E5%9B%BE&quot;&gt;&lt;code&gt;截图&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E6%89%A9%E5%B1%95&quot;&gt;&lt;code&gt;扩展&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/Chrome&quot;&gt;&lt;code&gt;Chrome&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;TinySnap is a production-ready screenshot extension tool created for everyone, especially creators, developers, and marketers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/tinysnap.app.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - TinySnap: A Production-Ready Screenshot Extension Tool for Everyone&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://tinysnap.app/&quot;&gt;TinySnap&lt;/a&gt; 是为每个人，特别是创造者、开发者和营销者，而创建的可生产的&lt;strong&gt;屏幕截图扩展&lt;/strong&gt;工具；基于 TinySnap 可告别无聊的截图！你也不需要花哨的设计技能，只需简单地制作屏幕截图，然后将其变成迷人的图形。所要做的就是选择你想要的，调整 TinySnap &lt;strong&gt;预览&lt;/strong&gt;（支持修改外边距、内边距、圆角弧度、阴影、渐变背景、边框、图像比例、位置等），然后你就可以保存或分享。TinySnap 完全免费使用，但如果您需要额外的功能，请升级到 TinySnap Pro。免费版本支持以下功能：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;无限截图；&lt;/li&gt;&lt;li&gt;复制到剪贴板或保存到本地存储；&lt;/li&gt;&lt;li&gt;编辑和注释屏幕截图；&lt;/li&gt;&lt;li&gt;为屏幕截图添加渐变背景；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;TinySnap 与 &lt;a href=&quot;https://nicelinks.site/post/63060e34d3028e784afedaed&quot;&gt;Xnapper&lt;/a&gt; 在功能和设计上有很多相似之处，只不过前者基于浏览器扩展，后者是 Mac 原生应用（免费版本有产品商水印）。如果您要截取浏览器上的图片，TinySnap 是蛮不错的选择。值得一提的是该作者——&lt;a href=&quot;https://nicelinks.site/redirect?url=https://twitter.com/LuoBaishun&quot;&gt;@LuoBaishun&lt;/a&gt; 今年刚才开始尝试做&lt;strong&gt;独立产品&lt;/strong&gt;，受 Indiehackers 社区的熏陶，在尝试 build in public；他还创作另一款作品：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://heyform.net/&quot;&gt;HeyForm&lt;/a&gt;。如果您想了解更多，可移步至 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://tinysnap.app/#faq&quot;&gt;TinySnap 常见问题&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/63109b3d02966b0ec183b140&quot;&gt;倾城之链 - TinySnap: A Production-Ready Screenshot Extension Tool for Everyone&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E5%8F%91%E7%8E%B0&quot;&gt;&lt;code&gt;发现&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%AD%A6%E4%B9%A0&quot;&gt;&lt;code&gt;学习&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E4%BA%BA%E6%96%87&quot;&gt;&lt;code&gt;人文&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关键字&lt;/strong&gt;：千篇国学, 汉语字典, 汉语词典, 成语大全&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;千篇国学，云集汉语字典, 汉语词典, 成语大全等经典内容的网站。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/www.qianp.com.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - 千篇国学 · 万卷经典&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.qianp.com/&quot;&gt;千篇国学&lt;/a&gt;，有「汉语字典」, 「汉语词典」,「 成语大全」三个板块儿：&lt;/p&gt;&lt;p&gt;&lt;code&gt;汉语字典&lt;/code&gt; 收录简繁汉字共 8 万多个，囊括新华字典中所有汉字。新华字典可在线查询汉字的拼音、笔画数、五笔、仓颉、郑码、电码、汉字笔顺、四角号码、UNICODE、汉字方言、汉英互译、词性变化、康熙字典解释、说文解字、English 等。&lt;/p&gt;&lt;p&gt;&lt;code&gt;汉语词典&lt;/code&gt; 收录成语近 40 万条，提供近义词、反义词、名词、动词、形容词、副词等诸多成语查询，以及成语组词、成语解释、成语拼音、注音、繁体等。&lt;/p&gt;&lt;p&gt;&lt;code&gt;成语大全&lt;/code&gt;（成语词典在线查询）收录四字成语等 4 万多条，提供成语解释、成语用法、成语出处、成语歇后语、成语谜语、成语故事大全、成语接龙、近义词、反义词等查询。&lt;/p&gt;&lt;p&gt;在这里，您可以学到很多很多；就成语而言，有成语组词、成语组合、成语结构、成语字数、成语接龙.....汉语字典，可了解到二叠字、 三叠字（品 pǐn 森 sēn 晶 jīng 焱 yàn 麤 cū 刕 lí 劦 xié 厵 yuán 姦 jiān 叒 ruò）、 四叠字（燚 yì 叕 zhuó 朤 lǎng 茻 mǎng 㵘 màn）、网络流行汉字（巭 gū 孬 nāo 嫑 biáo 嘦 jiào 䨻 bèng）等，不仅可以知道具体读音、部首、释义以及康熙字典中说明。此外&lt;a href=&quot;https://nicelinks.site/redirect?url=https://www.qianp.com/&quot;&gt;千篇国学&lt;/a&gt; 还提供搜索功能，输入「汉字、拼音、五笔」等均可。如果您想对某些成语、词语、汉字感兴趣或了解更多，千篇国学是值得使用的网站。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6310b06902966b0ec183b142&quot;&gt;倾城之链 - 千篇国学 · 万卷经典&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/SVG&quot;&gt;&lt;code&gt;SVG&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%81%9A%E5%90%88&quot;&gt;&lt;code&gt;聚合&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;A fun collection of free SVG generators for gradients, patterns, shapes, textures &amp;amp; cool backgrounds. Plus, some more color tools for web designers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/fffuel.co.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Free SVG generators, color tools &amp;amp; web design tools&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;： &lt;a href=&quot;https://nicelinks.site/redirect?url=https://fffuel.co/&quot;&gt;fffuel&lt;/a&gt; 是用于渐变、图案、纹理、形状和背景的颜色工具和免费 SVG 生成器的集合。该网站集成了非常多工具，诸如：调色板生成器、颜色选择器、流体 SVG 渐变、发光的 SVG 形状、表情制作器、网格状渐变、粒状梯度发生器、SVG 波发生器、手绘 SVG 绘图工具、噪声纹理生成器、SVG 渐变圆形图案、旋转圆圈图案、旋转几何图案、赛博朋克风格的背景、五彩纸屑发生器、SVG箭头制造商、模糊背景生成器、爆裂线条图案、野生波浪 SVG 形状...... 凡此种种，多达数十种。&lt;/p&gt;&lt;p&gt;🚀 在这里，您会找到一系列完全&lt;strong&gt;免费的 SVG 制作&lt;/strong&gt;工具，用于创建炫酷的背景、无缝图案、渐变、纹理、形状和斑点。直接在网络上或您最喜欢的设计应用程序中，使用生成的矢量图案。&lt;/p&gt;&lt;p&gt;🤹‍♂️ fffuel 上的所有 SVG 创建工具都允许您轻松自定义最终结果，以便生成的图形独一无二，并与您的其余设计无缝匹配。&lt;/p&gt;&lt;p&gt;✨ SVG 是 Scalable Vector Graphics（可扩展的矢量图形） 的缩写，在网络上使用 SVG 有很多好处。例如，SVG 可以缩放到任何大小而不会损失视觉质量，它们可以稍后通过调整下划线标记进行编辑，并且它们通常可以比已保存为 PNG 或 JPEG 等光栅格式的图像更轻巧。&lt;/p&gt;&lt;p&gt;🔧 如果您需要将生成的 SVG 转换为 PNG，您可以使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://fffuel.co/rrrasterize/&quot;&gt;SVG 到 PNG 转换工具&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;🖼️ 如果你想使用 SVG 作为背景图案，你可以使用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://fffuel.co/eeencode/&quot;&gt;base64 编码器&lt;/a&gt; ，这样你就可以在你的 CSS 中添加背景图片。&lt;/p&gt;&lt;p&gt;🎨 另外，fffuel 还创建了一些工具，来帮助转换颜色代码或为您的设计挑选漂亮的颜色。例如，试用 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://fffuel.co/cccolor/&quot;&gt;颜色选择器&lt;/a&gt; 或 &lt;a href=&quot;https://nicelinks.site/redirect?url=https://fffuel.co/pppalette/&quot;&gt;调色板生成器&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/6310950c02966b0ec183b13e&quot;&gt;倾城之链 - Free SVG generators, color tools &amp;amp; web design tools&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/AI&quot;&gt;&lt;code&gt;AI&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%9B%BE%E7%89%87&quot;&gt;&lt;code&gt;图片&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E8%AE%BE%E8%AE%A1&quot;&gt;&lt;code&gt;设计&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Transform your imagination into stunning digital art with Photosonic - the AI art generator. With its creative suggestions, this Writesonic&#x27;s AI image generator can help unleash your inner artist and share your creations with the world.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/photosonic.ai.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - Photosonic AI Art Generator | Create Unique Images with AI&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://photosonic.ai/&quot;&gt;Photosonic&lt;/a&gt; 是一款 AI 工具，可让您从想象中创造出令人惊叹的图像。 只需输入几句话来描述您想看到的内容，Photosonic 就会在几秒钟内为您生成。 无需设计技能或 Photoshop。 现在它支持免费试用（每天每台机器限制 10 次）。在 Photosonic 创始人 Sam 看来，Photosonic 不仅是一个有趣的玩具，而且是内容创建、营销、教育、娱乐等的强大工具。您可以使用 Photosonic 来：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;✅ 使用与您的信息相匹配的醒目视觉效果为您的博客帖子、社交媒体帖子、新闻通讯和登录页面增添趣味；&lt;/li&gt;&lt;li&gt;✅ 为您的个人或专业项目（例如书籍封面、海报）生成独特的原创艺术品, 标志, 壁纸, 以及更多；&lt;/li&gt;&lt;li&gt;✅ 探索您的创造力，并通过风格、主题、颜色和效果的无限可能性来表达自己；&lt;/li&gt;&lt;li&gt;✅ 通过使用 Photosonic 可视化不同的主题、概念、文化和历史来学习和教授它们；&lt;/li&gt;&lt;li&gt;✅ 通过生成您的图像来获得乐趣和放松最喜欢的角色、场景、动物、地点以及您能想象到的任何其他内容；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Photosonic 可以处理从简单到复杂、从抽象到现实、从自然到奇幻的各种输入。它还可以组合多个输入并生成以连贯和谐的方式将它们混合在一起的图像。我们使用简单直观的界面构建了 Photosonic，使其易于使用且令人愉快。您还可以通过单击按钮下载和共享图像。Photosonic 是基于网络的，可以在任何设备和浏览器上运行。&lt;/p&gt;&lt;p&gt;🤩 Photosonic 目前 &lt;strong&gt;100% 免费使用&lt;/strong&gt;，因为他们仍处于测试阶段，该团队希望从早期用户那里获得尽可能多的反馈和建议。在未来，他们还计划添加更多功能和改进，例如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;✅ 使用不同的过滤器、调整和转换自定义和编辑您的图像；&lt;/li&gt;&lt;li&gt;✅ 在您自己的画廊中保存和组织您的图像并随时访问它们；&lt;/li&gt;&lt;li&gt;✅ 创建和加入社区的 Photosonic 用户并发现、喜欢和评论他们的图像；&lt;/li&gt;&lt;li&gt;✅ 将 Photosonic 与其他平台和工具集成，例如 Writesonic、WordPress、Medium、Canva 等。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Writesonic 在其官网写道：Writesonic 使命是让每个人都能以闪电般的速度制作高质量、高性价比的内容。Writesonic 的目标是通过让每个人都可以使用人工智能，来彻底改变人们的写作方式。&lt;/p&gt;&lt;p&gt;有输入多个不同内容，来测试了下 Writesonic；虽然说它生成出的内容，并没有达到针对真人的那种预期；但不得不说，它很强大，准确理解的我的意图，并快速绘制出来（展示 3 个）；当然在我看来，某些结果还是比较粗糙丑陋，需要继续改进提升。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/630df696ef3e2232e50c9e71&quot;&gt;倾城之链 - Photosonic AI Art Generator | Create Unique Images with AI&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标签&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/tags/%E8%BF%9C%E7%A8%8B&quot;&gt;&lt;code&gt;远程&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E9%85%B7%E5%B7%A5%E4%BD%9C&quot;&gt;&lt;code&gt;酷工作&lt;/code&gt;&lt;/a&gt; · &lt;a href=&quot;https://nicelinks.site/tags/%E5%88%86%E4%BA%AB&quot;&gt;&lt;code&gt;分享&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The World&#x27;s Best City Guides For Remote Workers &amp;amp; Digital Nomads.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://oss.nicelinks.site/wenomad.so.png?x-oss-process=style/png2jpg&quot; alt=&quot;倾城之链 - WeNomad - A Digital Nomad Community Learning Resource&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐语&lt;/strong&gt;：&lt;a href=&quot;https://nicelinks.site/redirect?url=https://wenomad.so/&quot;&gt;WeNomad&lt;/a&gt;，远程工作者和数字游牧民的城市指南。与领先的网站进行比较，WeNomad 没有捏造的信息，没有付费墙，更准确的数据，更详细的指南和更多评论。&lt;/p&gt;&lt;p&gt;如果您逛下 WeNomad 网站，就会发现它所提供的信息，至少非常之齐全。比如：夜生活、远程游牧人气 &amp;amp; 社区、天气、wifi 速度 and 可靠性、犯罪与安全等方面都会涉及；此外，还会较为全面地列出优缺点、特色照片等。当然，该网站支持用户自由评论。&lt;/p&gt;&lt;p&gt;WeNomad 的创建，是作者出于对“远程工作者城市指南”空间中领先网站上，不可靠且有时是捏造的信息的极度失望。作者已经厌倦了在互联网和论坛上搜索有见地的信息，所以，他组建了一个团队来汇编你发现和搬到你会喜欢的城市所需的一切。即 WeNomad。如果您对远程工作，尤其是全球范围内，相信 WeNomad 是值得关注的网站。&lt;/p&gt;&lt;p&gt;── 出自&lt;a href=&quot;https://nicelinks.site/post/630df173ef3e2232e50c9e6f&quot;&gt;倾城之链 - WeNomad - A Digital Nomad Community Learning Resource&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对倾城之链感兴趣的朋友，可通过 Web，小程序，快应用等渠道进行访问(后续将支持更多，如 VsCode 插件，Chrome 扩展等)。您有任何问题，欢迎随时向我们反馈（您可以通过官网反馈渠道，或添加如下客服微信），🤲 。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot; alt=&quot;倾城之链 - 客服微信&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;本期文末寄语&quot;&gt;&lt;a href=&quot;#%E6%9C%AC%E6%9C%9F%E6%96%87%E6%9C%AB%E5%AF%84%E8%AF%AD&quot; aria-label=&quot;本期文末寄语 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;本期文末寄语&lt;/h2&gt;&lt;p&gt;“成功的最终决定因素是思想的‘大小’，而绝对不是一个人的身高、体重、家庭背景和学历等条件。思想的大小决定了我们能够走多远。这里面最为关键的一点，就是我们要摒弃人类自贬的弱点，你首先要看得起你自己。因为，你们远比想象中的自己要伟大得多。因此，&lt;strong&gt;不要局限于自己的思想，更不要看轻自己。&lt;/strong&gt;”── 《洛克菲勒写给儿子的 38 封信 · 其二》&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://nicelinks.site/?utm_source=weekly&quot;&gt;倾城之链&lt;/a&gt;作为一个开放平台，旨在云集全球&lt;strong&gt;优秀网站&lt;/strong&gt;，探索互联网中更广阔的世界；在这里，你可以轻松发现、学习、分享更多有用或有趣的事物。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/250/h/250/interlace/1/ignore-error/1&quot; alt=&quot;小程序码 - 倾城之链&quot;/&gt;&lt;/p&gt;&lt;h2 id=&quot;您可能感兴趣的文章&quot;&gt;&lt;a href=&quot;#%E6%82%A8%E5%8F%AF%E8%83%BD%E6%84%9F%E5%85%B4%E8%B6%A3%E7%9A%84%E6%96%87%E7%AB%A0&quot; aria-label=&quot;您可能感兴趣的文章 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; version=&quot;1.1&quot; viewbox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;您可能感兴趣的文章&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bab85422300871ec38fe001c09abf23a</guid>
<title>公司40k招的架构师写的API网关选型总结，就是牛逼！</title>
<link>https://toutiao.io/k/kyi9yzt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;什么是网关&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关设计思路&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关设计重点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关设计注意事项&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量网关&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务网关&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见网关对比&lt;/section&gt;&lt;/li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gdxAJ6zQsUYfldc9KVnrcQSOpyXRZEVepgnN1Ykwcia3wuOHibVmnRkSUNjygD8GZMLUCuCgdjn0EF6VibajENJrQ/640?wx_fmt=png&quot; data-w=&quot;22&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;本文准备围绕七个点来讲网关，分别是网关的基本概念、网关设计思路、网关设计重点、流量网关、业务网关、常见网关对比，对基础概念熟悉的朋友可以根据目录查看自己感兴趣的部分。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.972972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xuz7cCrSxHUr4F6rIJJmUyiaCTDRkk8vhJocsm8Boar8kRkaicGNLVaY5y2RWVy1h5sV9tfDvvjOYwTmHMnKsxQw/640?wx_fmt=png&quot; data-w=&quot;74&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一、什么是网关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网关，很多地方将网关比如成门， 没什么问题， 但是需要区分网关与网桥的区别：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;网关通俗理解&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据网关的特性，举个例子:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;假如你要去找集团老板(这儿只是举个例子)， 大家都知道老板肯定不是谁想见就能见的， 也怕坏人嘛， 那么你去老板所在的办公楼，假如是集团总部， 大楼这个门就充当了网关的角色， 大门一般都有看门员 ，看门员会做哪些事情呢?&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先所有想见老板的人肯定都得从这个门进(&lt;span&gt;统一入口&lt;/span&gt; )， 这个门相当于将办公室和外界隔离了，主要为了保护里面的安全以及正常工作， 来到这个门之后， 门卫肯定会让你出示相关证件(&lt;span&gt;鉴权检验&lt;/span&gt; )， 意思就是判断你要见老板这个请求是否合理， 如果不合理直接就拒绝了， 让你回家等消息 ， 如果鉴权之后， 发现你找老板其实只是为了和他谈谈两元店的生意， 门卫会跟你说这个用不着找老板， 你去集团投资部就行了(&lt;span&gt;动态路由 ， 将请求路由到不同的后端集群中&lt;/span&gt;)， 此时会对你进行一些包装 ，例如给你出具一个访问证类似的，然后告诉你路该怎么走，等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看看，网关的作用是不是就是这三个， 最终目的就是减少你与集团的耦合，具体到计算机上就是减少客户端与服务端的耦合，如果没有网关意味着所有请求都会直接调用服务器上的资源，这样耦合太强了，服务器出了问题，客户端会直接报错， 例如老板换工作的地方了，如果没有网关你直接去原来的地方找， 肯定会被告知老板不在这儿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么需要网关&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用单体应用程序架构时，客户端（Web 或移动端）通过向后端应用程序发起一次 REST 调用来获取数据。负载均衡器将请求路由给 N 个相同的应用程序实例中的一个。然后应用程序会查询各种数据库表，并将响应返回给客户端。微服务架构下，单体应用被切割成多个微服务，如果将所有的微服务直接对外暴露，势必会出现安全方面的各种问题，另外内外耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;客户端可以直接向每个微服务发送请求，其问题主要如下：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端需求和每个微服务暴露的细粒度 API 不匹配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分服务使用的协议不是Web友好协议。可能使用 Thrift 二进制 RPC，也可能使用 AMQP 消息传递协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务难以重构。如果合并两个服务，或者将一个服务拆分成两个或更多服务，这类重构就非常困难了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的各个服务直接暴露给客户端调用势必会引起各种问题。同时，服务端的各个服务可扩展和伸缩性很差。API 网关是微服务架构中的基础组件，位于接入层之下和业务服务层之上，如前所述的这些功能适合在 API 网关实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;网关与服务器集群&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到我们服务器上，下面图介绍了网关(Gateway)作用，可知 Gateway 方式下的架构，可以细到为每一个服务的实例配置一个自己的 Gateway，也可以粗到为一组服务配置一个，甚至可以粗到为整个架构配置一个接入的 Gateway。&lt;/span&gt;&lt;span&gt;于是，整个系统架构的复杂度就会变得简单可控起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165929203539823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYibMYH4HomaAcKMMMPzvWJc6y00kNnDYBFiaKD1THOuuDCbjhicXca6THA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图展示了一个多层 Gateway 架构，其中有一个总的 Gateway 接入所有的流量(&lt;span&gt;流量网关 &lt;/span&gt;)，并分发给不同的子系统，还有第二级 Gateway 用于做各个子系统的接入 Gateway(&lt;span&gt;业务网关 &lt;/span&gt;)。可以看到，网关所管理的服务粒度可粗可细。通过网关，我们可以把分布式架构组织成一个星型架构，由网络对服务的请求进行路由和分发。下面来聊聊好的网关应该具备哪些功能，也就是网关设计模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;二、网关设计思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个网关需要有以下的功能:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 请求路由&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;网关一定要有请求路由的功能。这样一来，对于调用端来说，也是一件非常方便的事情。因为调用端不需要知道自己需要用到的其它服务的地址，全部统一地交给 Gateway 来处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 服务注册&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了能够代理后面的服务，并把请求路由到正确的位置上，网关应该有服务注册功能，也就是后端的服务实例可以把其提供服务的地址注册、取消注册。&lt;/span&gt;&lt;span&gt;一般来说，注册也就是注册一些 API 接口。&lt;/span&gt;&lt;span&gt;比如，HTTP 的 Restful 请求，可以注册相应 API 的 URI、方法、HTTP 头。&lt;/span&gt;&lt;span&gt;这样，Gateway 就可以根据接收到的请求中的信息来决定路由到哪一个后端的服务上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 负载均衡&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为一个网关可以接收多个服务实例，所以网关还需要在各个对等的服务实例上做负载均衡策略。&lt;/span&gt;&lt;span&gt;简单点就是直接 Round-Robin 轮询，复杂点的可以设置上权重进行分发，再复杂一点还可以做到 session 粘连。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. 弹力设计&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、&lt;/span&gt;&lt;span&gt;监视等都可以实现进去。&lt;/span&gt;&lt;span&gt;这样，同样可以像 Service Mesh 那样，让应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5. 安全方面&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事情，比如：灰度发布、API聚合、API编排。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;三、网关设计重点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;网关设计重点主要是三个， 高性能、高可用、高扩展:&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. 高性能&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;技术设计上，网关不应该也不能成为性能的瓶颈。&lt;/span&gt;&lt;span&gt;对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。&lt;/span&gt;&lt;span&gt;网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I/O 来确保后端延迟不会导致应用程序中出现性能问题。&lt;/span&gt;&lt;span&gt;C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I/O Completion Port 的异步 IO 模型，Java 下如 Netty、Spring Reactor 的 NIO 框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. 高可用&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。&lt;/span&gt;&lt;span&gt;网关如果没有设计，就会成变一个单点故障。&lt;/span&gt;&lt;span&gt;因此，一个好的网关至少要做到以下几点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群化&lt;/strong&gt; 。网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务化&lt;/strong&gt; 。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持续化 &lt;/strong&gt;。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. 高扩展&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;&lt;span&gt;网关需要承接所有的业务流量和请求，所以一定会有或多或少的业&lt;/span&gt;&lt;span&gt;务逻辑。&lt;/span&gt;&lt;span&gt;而我们都知道，业务逻辑是多变和不确定的。&lt;/span&gt;&lt;span&gt;比如，需要在网关上加入一些和业务相关的东西。&lt;/span&gt;&lt;span&gt;因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。&lt;/span&gt;&lt;span&gt;当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;另外，在运维方面 ，网关应该有以下几个设计原则。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务松耦合，协议紧耦合 。在业务设计上，网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用监视，提供分析数据 。网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用弹力设计保护后端服务 。网关上一定要实现熔断、限流、重试和超时等弹力设计。如果一个或多个服务调用花费的时间过长，那么可接受超时并返回一部分数据，或是返回一个网关里的缓存的上一次成功请求的数据。你可以考虑一下这样的设计。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DevOps 。因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。这个软件需要经过精良的测试，包括功能和性能的测试，还有浸泡测试。还需要有一系列自动化运维的管控工具。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;四、网关设计注意事项&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。这里多说一句，网关处理的静态内容应该靠近用户（应该放到 CDN 上），而网关和此时的动态服务应该靠近后端服务。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关也需要做容量扩展，所以需要成为一个集群来分担前端带来的流量。这一点，要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。&lt;/section&gt;&lt;section&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，因为网关是为用户请求和后端服务的桥接装置，所以需要考虑一些安全方面的事宜。具体如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;加密数据 &lt;/strong&gt;。可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;校验用户的请求&lt;/strong&gt; 。一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。但是，我们需要权衡一下，网关是否需要校验用户的输入。因为这样一来，网关就需要从只关心协议头，到需要关心协议体。而协议体中的东西一方面不像协议头是标准的，另一方面解析协议体还要耗费大量的运行时间，从而降低网关的性能。对此，我想说的是，看具体需求，一方面如果协议体是标准的，那么可以干；另一方面，对于解析协议所带来的性能问题，需要做相应的隔离。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检测异常访问 &lt;/strong&gt;。网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;五、流量网关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量网关，顾名思义就是控制流量进入集群的网关，有很多工作需要在这一步做，对于一个服务集群，势必有很多非法的请求或者无效的请求，这时候要将请求拒之门外，降低集群的流量压力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7321212121212122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYRlMCXRIofa8eywlV45QyQD3Vb2NeLxMoNgl9Xce4ZISkk7WeE0X1Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定&lt;/span&gt;&lt;span&gt;义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图所示的架构模型——流量网关。&lt;/span&gt;&lt;span&gt;流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。&lt;/span&gt;&lt;strong&gt;Kong 就是典型的流量网关。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面是kong的架构图，来自官网：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8998144712430427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYWcOnabagFzfSjmy0gp5nz7UtEGgI0kMBScpZt1UdQDYZeVQibBuTaqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;这里需要补充一点的是，业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作，所以这两者之间并没有严格的界线。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;六、业务网关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个单体应用被拆分成许许多多的微服务应用后，也带来了一些问题。一些与业务非强相关的功能，比如权限控制、日志输出、数据加密、熔断限流等，每个微服务应用都需要，因此存在着大量重复的代码实现。而且由于系统的迭代、人员的更替，各个微服务中这些功能的实现细节出现了较大的差异，导致维护成本变高。另一方面，原先单体应用下非常容易做的接口管理，在服务拆分后没有了一个集中管理的地方，无法统计已存在哪些接口、接口定义是什么、运行状态如何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关就是为了解决上述问题。作为微服务体系中的核心基础设施，一般需要具备接口管理、协议适配、熔断限流、安全防护等功能，各种开源的网关产品（比如 zuul）都提供了优秀高可扩展性的架构、可以很方便的实现我们需要的一些功能、比如鉴权、日志监控、熔断限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与流量网关相对应的就是业务网关，业务网关更靠近我们的业务，也就是与服务器应用层打交道，那么有很多应用层需要考虑的事情就可以依托业务网关，例如在线程模型、协议适配、熔断限流，服务编排等。下面看看业务网关体系结构:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5492341356673961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYF59icd0j3Hs491bkqpMEElWkscFOM4TNRfIQSg2Juv6bY3ic2VBSSPOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图片来自:业务网关&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;落地&lt;/span&gt;&lt;span&gt;实践&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;从这个图中可以看出业务网关主要职责以及所做的事情， 目前业务网关比较成熟的 API 网关框架产品有三个 分别是:&lt;strong&gt;Zuul1、Zuul2 和 SpringCloud Gateway&lt;/strong&gt;， 后面再进行对比。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;七、常见网关对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然对比，就先宏观上对各种网关有一个了解，后面再挑一些常用的或者说应用广泛的详细了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目前常见的开源网关大致上按照语言分类有如下几类：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Nginx+lua&lt;/strong&gt; ：OpenResty、Kong、Orange、Abtesting gateway 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Java&lt;/strong&gt; ：Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、Dromara soul 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt; ：Janus、fagongzi、Grpc-gateway&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Dotnet&lt;/strong&gt; ：Ocelot&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;NodeJS&lt;/strong&gt; ：Express Gateway、Micro Gateway&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;按照使用数量、成熟度等来划分，主流的有 4个：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OpenResty&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zuul/Zuul2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Gateway&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1. OpenResty&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关连接: 官网、B站、Github&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty是一个流量网关，根据前面对流量网关的介绍就可以知道流量网关的职责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty基于 Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 最早是顺应 OpenAPI 的潮流做的，所以 Open 取自“开放”之意，而Resty便是 REST 风格的意思。虽然后来也可以基于 ngx_openresty 实现任何形式的 web service 或者传统的 web 应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说 Nginx 不再是一个简单的静态网页服务器，也不再是一个简单的反向代理了。第二代的 openresty 致力于通过一系列 nginx 模块，把nginx扩展为全功能的 web 应用服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 是用户驱动的项目，后来也有不少国内用户的参与，从 openresty.org 的点击量分布上看，国内和国外的点击量基本持平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ngx_openresty 目前有两大应用目标：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用目的的 web 应用服务器。在这个目标下，现有的 web 应用技术都可以算是和 OpenResty 或多或少有些类似，比如 Nodejs， PHP 等等。ngx_openresty 的性能（包括内存使用和 CPU 效率）算是最大的卖点之一。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nginx 的脚本扩展编程，用于构建灵活的 Web 应用网关和 Web 应用防火墙。有些类似的是 NetScaler。其优势在于 Lua 编程带来的巨大灵活性。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2. Kong&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;相关连接: 官网、Github&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kong基于OpenResty开发，也是流量层网关， 是一个云原生、快速、可扩展、分布式的Api 网关。&lt;/span&gt;&lt;span&gt;继承了OpenResty的高性能、易扩展性等特点。&lt;/span&gt;&lt;span&gt;Kong通过简单的增加机器节点，可以很容易的水平扩展。&lt;/span&gt;&lt;span&gt;同时功能插件化，可通过插件来扩展其能力。&lt;/span&gt;&lt;span&gt;而且在任何基础架构上都可以运行。&lt;/span&gt;&lt;span&gt;具有以下特性：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供了多样化的认证层来保护Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可对出入流量进行管制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了可视化的流量检查、监视分析Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够及时的转换请求和相应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供log解决方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可通过api调用Serverless 函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kong解决了什么问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;当我们决定对应用进行微服务改造时，应用客户端如何与微服务交互的问题也随之而来，毕竟服务数量的增加会直接导致部署授权、负载均衡、通信管理、分析和改变的难度增加。&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;面对以上问题，API GATEWAY是一个不错的解决方案，其所提供的访问限制、安全、流量控制、分析监控、日志、请求转发、合成和协议转换功能，可以解放开发者去把精力集中在具体逻辑的代码，而不是把时间花费在考虑如何解决应用和其他微服务链接的问题上。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;图片来自Kong官网:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6813559322033899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmY7g8ruuA7aVl46Fiaj1GNJ6hTU3Pqt04PceIDT4PKmodKgMae5HBCrXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到Kong解决的问题。专注于全局的Api管理策略，全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kong的优点以及性能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;在众多 API GATEWAY 框架中，Mashape 开源的高性能高可用API网关和API服务管理层——KONG（基于 NGINX+Lua）特点尤为突出，它可以通过插件扩展已有功能，这些插件（使用 lua 编写）在API请求响应循环的生命周期中被执行。于此同时，KONG本身提供包括 HTTP 基本认证、密钥认证、CORS、TCP、UDP、文件日志、API请求限流、请求转发及 NGINX 监控等基本功能。目前，Kong 在 Mashape 管理了超过 15，000 个 API，为 200，000 开发者提供了每月数十亿的请求支持。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Kong架构&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Kong提供一些列的服务，这就不得不谈谈内部的架构:&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.257602862254025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYDqSu3WrmemHac5zYHcxpQJbDPxRickiaPBib6k9bnkPBbiaCaHTvlljxVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;559&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先最底层是基于Nginx， Nginx是高性能的基础层， 一个良好的负载均衡、反向代理器，然后在此基础上增加Lua脚本库，形成了OpenResty，拦截请求， 响应生命周期，可以通过Lua编写脚本，所以插件比较丰富。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Kong的一些插件库以及如何配置,可以参考简书:开源API网关系统（Kong教程）入门到精通&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3. Zuul1.0&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Zuul是所有从设备和web站点到Netflix流媒体应用程序后端请求的&lt;/span&gt;&lt;span&gt;前门。&lt;/span&gt;&lt;span&gt;作为一个边缘服务应用程序，Zuul被构建来支持动态路由、监视、弹性和安全性。&lt;/span&gt;&lt;span&gt;它还可以根据需要将请求路由到多个Amazon自动伸缩组。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul使用了一系列不同类型的过滤器，使我们能够快速灵活地将功能应用到服务中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;过滤器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器是Zuul的核心功能。它们负责应用程序的业务逻辑，可以执行各种任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Type ：通常定义过滤器应用在哪个阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Async ：定义过滤器是同步还是异步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Execution Order ：执行顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Criteria ：过滤器执行的条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Action ：如果条件满足，过滤器执行的动作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul提供了一个动态读取、编译和运行这些过滤器的框架。过滤器之间不直接通信，而是通过每个请求特有的RequestContext共享状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;下面是Zuul的一些过滤器:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Incoming&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Incoming过滤器在请求被代理到Origin之前执行。&lt;/span&gt;&lt;span&gt;这通常是执行大部分业务逻辑的地方。&lt;/span&gt;&lt;span&gt;例如:认证、动态路由、速率限制、DDoS保护、指标。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Endpoint&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Endpoint过滤器负责基于incoming过滤器的执行来处理请求。&lt;/span&gt;&lt;span&gt;Zuul有一个内置的过滤器（ProxyEndpoint），用于将请求代理到后端服务器，因此这些过滤器的典型用途是用于静态端点。&lt;/span&gt;&lt;span&gt;例如:健康检查响应，静态错误响应，404响应。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Outgoing&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Outgoing过滤器在从后端接收到响应以后执行处理操作。&lt;/span&gt;&lt;span&gt;通常情况下，它们更多地用于形成响应和添加指标，而不是用于任何繁重的工作。&lt;/span&gt;&lt;span&gt;例如:存储统计信息、添加/剥离标准标题、向实时流发送事件、gziping响应。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;过滤器类型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面是与一个请求典型的生命周期对应的标准的过滤器类型：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;PRE ：路由到Origin之前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ROUTING ：路由到Origin期间执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;POST ：请求被路由到Origin之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ERROR ：发生错误的时候执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些过滤器帮助我们执行以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;身份验证和安全性&lt;/strong&gt; ：识别每个资源的身份验证需求，并拒绝不满足它们的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控 &lt;/strong&gt;：在边缘跟踪有意义的数据和统计数据，以便给我们一个准确的生产视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;动态路由&lt;/strong&gt; ：动态路由请求到不同的后端集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;压力测试&lt;/strong&gt; ：逐渐增加集群的流量，以评估性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流&lt;/strong&gt; ：为每种请求类型分配容量，并丢弃超过限制的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;静态响应处理&lt;/strong&gt; ：直接在边缘构建一些响应，而不是将它们转发到内部集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Zuul 1.0 请求生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525229357798165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYxtaiaw6051S9ic6X7M9mlEl4eQA4icJEuMDfIXoKicl2dlia7XF1jLl6RBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Netflix宣布了通用API网关Zuul的架构转型。&lt;/span&gt;&lt;span&gt;Zuul原本采用同步阻塞架构，转型后叫作Zuul2，采用异步非阻塞架构。&lt;/span&gt;&lt;span&gt;Zuul2和Zuul1在架构方面的主要区别在于，Zuul2运行在异步非阻塞的框架上，比如Netty。&lt;/span&gt;&lt;span&gt;Zuul1依赖多线程来支持吞吐量的增长，而Zuul 2使用的Netty框架依赖事件循环和回调函数。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Zuul2.0&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Zuul 2.0 架构图&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8235294117647058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYxzxic5VG0HpXiae0OrBXicQm5wbUSKhHeWibEoQOktpabkYMmWyzIguuvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上图是Zuul2的架构，和Zuul1没有本质区别，两点变化：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;前端用Netty Server代替Servlet，目的是支持前端异步。后端用Netty Client代替Http Client，目的是支持后端异步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;过滤器换了一下名字，用Inbound Filters代替Pre-routing Filters，用Endpoint Filter代替Routing Filter，用Outbound Filters代替Post-routing Filters。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Inbound Filters&lt;/span&gt; ：路由到 Origin 之前执行，可以用于身份验证、路由和装饰请求&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Endpoint Filters &lt;/span&gt;：可用于返回静态响应，否则内置的ProxyEndpoint过滤器将请求路由到Origin&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Outbound Filters&lt;/span&gt; ：从Origin那里获取响应后执行，可以用于度量、装饰用户的响应或添加自定义header&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种类型的过滤器：sync 和 async。因为Zuul是运行在一个事件循环之上的，因此从来不要在过滤中阻塞。如果你非要阻塞，可以在一个异步过滤器中这样做，并且在一个单独的线程池上运行，否则可以使用同步过滤器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;上文提到过Zuul2开始采用了异步模型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;优势&lt;/span&gt;&lt;/strong&gt; 是异步非阻塞模式启动的线程很少，基本上一个CPU core上只需启一个事件环处理线程，它使用的线程资源就很少，上下文切换(Context Switch)开销也少。非阻塞模式可以接受的连接数大大增加，可以简单理解为请求来了只需要进队列，这个队列的容量可以设得很大，只要不超时，队列中的请求都会被依次处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;不足&lt;/strong&gt;&lt;/span&gt; ，异步模式让编程模型变得复杂。一方面Zuul2本身的代码要比Zuul1复杂很多，Zuul1的代码比较容易看懂，Zuul2的代码看起来就比较费劲。另一方面异步模型没有一个明确清晰的请求-&amp;gt;处理-&amp;gt;响应执行流程(call flow)，它的流程是通过事件触发的，请求处理的流程随时可能被切换断开，内部实现要通过一些关联id机制才能把整个执行流再串联起来，这就给开发调试运维引入了很多复杂性，比如你在IDE里头调试异步请求流就非常困难。另外ThreadLocal机制在这种异步模式下就不能简单工作，因为只有一个事件环线程，不是每个请求一个线程，也就没有线程局部的概念，所以对于CAT这种依赖于ThreadLocal才能工作的监控工具，调用链埋点就不好搞(实际可以工作但需要进行特殊处理)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总体上&lt;/strong&gt;&lt;/span&gt;，异步非阻塞模式比较适用于IO密集型(IO bound)场景，这种场景下系统大部分时间在处理IO，CPU计算比较轻，少量事件环线程就能处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Zuul 与 Zuul 2 性能对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;图片来源:Zuul&#x27;s Journey to Non-Blocking&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5895061728395061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYNmTe4bojfibvKH2AG0IzUibopl7CXmZ0Yib6TM6Wwic2tibbFx70uCnTv0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Netflix给出了一个比较模糊的数据，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;大致Zuul2的性能比Zuul1好20%左右&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; ，这里的性能主要指每节点每秒处理的请求数。&lt;/span&gt;&lt;span&gt;为什么说模糊呢？&lt;/span&gt;&lt;span&gt;因为这个数据受实际测试环境，流量场景模式等众多因素影响，你很难复现这个测试数据。&lt;/span&gt;&lt;span&gt;即便这个20%的性能提升是确实的，其实这个性能提升也并不大，和异步引入的复杂性相比，这20%的提升是否值得是个问题。&lt;/span&gt;&lt;span&gt;Netflix本身在其博文22和ppt11中也是有点含糊其词，甚至自身都有一些疑问的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4. Spring Cloud Gateway&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;相关链接:官网、中文官方文档&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Spring Cloud Gateway 底层使用了高性能的通信框架Netty 。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06451612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/01NCBYDP9ZfkwrnCoIlkXhdAZbvSQoo0P17WWyOtfcfypVW5ic2ibUZHEXIuYjH409ebVxiar8pn7dx5yHGpWWV8A/640?wx_fmt=png&quot; data-w=&quot;310&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;SpringCloud Gateway 特征&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;模板&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;SpringCloud官方，对SpringCloud Gateway 特征介绍如下：&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;（1）基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;（2）集成 Hystrix 断路器&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;（3）集成 Spring Cloud DiscoveryClient&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;（4）Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters&lt;/p&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;（5）具备一些网关的高级功能：动态路由、限流、路径重写&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从以上的特征&lt;/span&gt;&lt;span&gt;来说，和Zuul的特征差别不大。&lt;/span&gt;&lt;span&gt;SpringCloud Gateway和Zuul主要的区别，还是在底层的&lt;/span&gt;&lt;span&gt;通信框架上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;简单说明一下上文中的三个术语：&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Filter （过滤器）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Route （路由）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关配置的基本组成模块，和Zuul的路由配置模块类似。一个Route模块 由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Predicate （断言）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。断言的 输入类型是一个 ServerWebExchange。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;几种网关的对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5711135611907387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLa1OqhOypg77tOXkP2ShEmYTs8LQicleIib4JLm1zmHw9RQ8GlscbQQrSQt7SoCSI5EeHIv7SnqAOEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16ad21a63b5cafeaef320026172e2de8</guid>
<title>掌握这些 SpringBoot 启动扩展点，已经超过 90% 的人了</title>
<link>https://toutiao.io/k/snq08kt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我非常喜欢这种自动装配的机制，所以在自己开发中间件和公共依赖工具的时候也会用到这个特性。让使用者以最小的代价接入。想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然了解了bean的各个生命周期也能促进我们加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网上搜索spring扩展点，发现很少有博文说的很全的，只有一些常用的扩展点的说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在这篇文章里，我总结了几乎Spring &amp;amp; Springboot所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.可扩展的接口启动调用顺序图&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是我整理的spring容器中Bean的生命周期内所有可扩展的点的调用顺序，下面会一个个分析&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0141666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eukZ9J6BEiafibggpqA4ewlw5D5eO47mcIibpetzgvibGTvHeDyI4YTBibWqNDjmwwtvKwHMl1dbDp9VazuvoSj5EGw/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.jpg&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.ApplicationContextInitializer&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.context.ApplicationContextInitializer&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是整个spring容器在刷新之前初始化&lt;code&gt;ConfigurableApplicationContext&lt;/code&gt;的回调接口，简单来说，就是在容器刷新之前调用此类的&lt;code&gt;initialize&lt;/code&gt;方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestApplicationContextInitializer&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextInitializer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initialize&lt;/span&gt;&lt;span&gt;(ConfigurableApplicationContext applicationContext)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[ApplicationContextInitializer]&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在启动类中用&lt;code&gt;springApplication.addInitializers(new TestApplicationContextInitializer())&lt;/code&gt;语句加入&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件配置&lt;code&gt;context.initializer.classes=com.example.demo.TestApplicationContextInitializer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring SPI扩展，在spring.factories中加入&lt;code&gt;org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.BeanDefinitionRegistryPostProcessor&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口在读取项目中的&lt;code&gt;beanDefinition&lt;/code&gt;之后执行，提供一个补充的扩展点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：你可以在这里动态注册自己的&lt;code&gt;beanDefinition&lt;/code&gt;，可以加载classpath之外的bean&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestBeanDefinitionRegistryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanDefinitionRegistryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanDefinitionRegistry&lt;/span&gt;&lt;span&gt;(BeanDefinitionRegistry registry)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.BeanFactoryPostProcessor&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.config.BeanFactoryPostProcessor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口是&lt;code&gt;beanFactory&lt;/code&gt;的扩展接口，调用时机在spring在读取&lt;code&gt;beanDefinition&lt;/code&gt;信息之后，实例化bean之前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的&lt;code&gt;beanDefinition&lt;/code&gt;的元信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[BeanFactoryPostProcessor]&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.InstantiationAwareBeanPostProcessor&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口继承了&lt;code&gt;BeanPostProcess&lt;/code&gt;接口，区别如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;BeanPostProcess&lt;/code&gt;接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：&lt;span&gt;&lt;strong&gt;实例化阶段&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;初始化阶段&lt;/strong&gt;&lt;/span&gt;，下面一起进行说明，按调用顺序为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;：实例化bean之前，相当于new这个bean之前&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;：实例化bean之后，相当于new这个bean之后&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;postProcessPropertyValues&lt;/code&gt;：bean已经实例化完成，在属性注入时阶段触发，&lt;code&gt;@Autowired&lt;/code&gt;,&lt;code&gt;@Resource&lt;/code&gt;等注解原理基于此方法实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;：初始化bean之前，相当于把bean注入spring上下文之前&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;：初始化bean之后，相当于把bean注入spring上下文之后&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestInstantiationAwareBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InstantiationAwareBeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessBeforeInstantiation&lt;/span&gt;&lt;span&gt;(Class&amp;lt;?&amp;gt; beanClass, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;postProcessAfterInstantiation&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; PropertyValues &lt;span&gt;postProcessPropertyValues&lt;/span&gt;&lt;span&gt;(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; pvs;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.SmartInstantiationAwareBeanPostProcessor&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该扩展接口有3个触发点方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;predictBeanType&lt;/code&gt;：该触发点发生在&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用&lt;code&gt;BeanFactory.getType(name)&lt;/code&gt;时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;determineCandidateConstructors&lt;/code&gt;：该触发点发生在&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;getEarlyBeanReference&lt;/code&gt;：该触发点发生在&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestSmartInstantiationAwareBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SmartInstantiationAwareBeanPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) &lt;span&gt;throws&lt;/span&gt; BeansException {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; beanClass;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, String beanName) &lt;span&gt;throws&lt;/span&gt; BeansException {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getEarlyBeanReference&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot;&lt;/span&gt; + beanName);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.BeanFactoryAware&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.BeanFactoryAware&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为&lt;code&gt;setBeanFactory&lt;/code&gt;，可以拿到&lt;code&gt;BeanFactory&lt;/code&gt;这个属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 &lt;code&gt;BeanFactory&lt;/code&gt;，在这个时候，可以对每个bean作特殊化的定制。也或者可以把&lt;code&gt;BeanFactory&lt;/code&gt;拿到进行缓存，日后使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestBeanFactoryAware&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryAware&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanFactory&lt;/span&gt;&lt;span&gt;(BeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestBeanFactoryAware] &quot;&lt;/span&gt; + beanFactory.getBean(TestBeanFactoryAware&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;getClass&lt;/span&gt;().&lt;span&gt;getSimpleName&lt;/span&gt;())&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.ApplicationContextAwareProcessor&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.context.support.ApplicationContextAwareProcessor&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4816666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/eukZ9J6BEiafibggpqA4ewlw5D5eO47mcIXC6oaBuiaM5ZZTovCU9YIyUZt7Ay3icxJFicFJEFSfrW8qs1dr0tE9NNA/640?wx_fmt=jpeg&quot; data-type=&quot;other&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.png&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。&lt;strong&gt;所以这里应该来说是有6个扩展点&lt;/strong&gt;，这里就放一起来说了&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EnvironmentAware&lt;/code&gt;：用于获取&lt;code&gt;EnviromentAware&lt;/code&gt;的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;EmbeddedValueResolverAware&lt;/code&gt;：用于获取&lt;code&gt;StringValueResolver&lt;/code&gt;的一个扩展类， &lt;code&gt;StringValueResolver&lt;/code&gt;用于获取基于&lt;code&gt;String&lt;/code&gt;类型的properties的变量，一般我们都用&lt;code&gt;@Value&lt;/code&gt;的方式去获取，如果实现了这个Aware接口，把&lt;code&gt;StringValueResolver&lt;/code&gt;缓存起来，通过这个类去获取&lt;code&gt;String&lt;/code&gt;类型的变量，效果是一样的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourceLoaderAware&lt;/code&gt;：用于获取&lt;code&gt;ResourceLoader&lt;/code&gt;的一个扩展类，&lt;code&gt;ResourceLoader&lt;/code&gt;可以用于获取classpath内所有的资源对象，可以扩展此类来拿到&lt;code&gt;ResourceLoader&lt;/code&gt;对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ApplicationEventPublisherAware&lt;/code&gt;：用于获取&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;的一个扩展类，&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;可以用来发布事件，结合&lt;code&gt;ApplicationListener&lt;/code&gt;来共同使用，下文在介绍&lt;code&gt;ApplicationListener&lt;/code&gt;时会详细提到。这个对象也可以通过spring注入的方式来获得。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MessageSourceAware&lt;/code&gt;：用于获取&lt;code&gt;MessageSource&lt;/code&gt;的一个扩展类，&lt;code&gt;MessageSource&lt;/code&gt;主要用来做国际化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ApplicationContextAware&lt;/code&gt;：用来获取&lt;code&gt;ApplicationContext&lt;/code&gt;的一个扩展类，&lt;code&gt;ApplicationContext&lt;/code&gt;应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时&lt;code&gt;ApplicationContext&lt;/code&gt;也实现了&lt;code&gt;BeanFactory&lt;/code&gt;，&lt;code&gt;MessageSource&lt;/code&gt;，&lt;code&gt;ApplicationEventPublisher&lt;/code&gt;等接口，也可以用来做相关接口的事情。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;10.BeanNameAware&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.BeanNameAware&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;之前，这个类的触发点方法只有一个：&lt;code&gt;setBeanName&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanNameAware&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;NormalBean constructor&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setBeanName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[BeanNameAware] &quot;&lt;/span&gt; + name);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;11.@PostConstruct&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;javax.annotation.PostConstruct&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了&lt;code&gt;@PostConstruct&lt;/code&gt;，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;之后，&lt;code&gt;InitializingBean.afterPropertiesSet&lt;/code&gt;之前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;NormalBean constructor&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[PostConstruct] NormalBeanA&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;12.InitializingBean&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.InitializingBean&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个类，顾名思义，也是用来初始化bean的。&lt;code&gt;InitializingBean&lt;/code&gt;接口为bean提供了初始化方法的方式，它只包括&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;之前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InitializingBean&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[InitializingBean] NormalBeanA&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;13.FactoryBean&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.FactoryBean&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个&lt;code&gt;org.springframework.bean.factory.FactoryBean&lt;/code&gt;的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。&lt;code&gt;FactoryBean&lt;/code&gt;接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个&lt;code&gt;FactoryBean&lt;/code&gt;的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，&lt;code&gt;FactoryBean&lt;/code&gt;开始支持泛型，即接口声明改为&lt;code&gt;FactoryBean&amp;lt;T&amp;gt;&lt;/code&gt;的形式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿&lt;code&gt;ProxyFactoryBean&lt;/code&gt;的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestFactoryBean&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;FactoryBean&lt;/span&gt;&amp;lt;&lt;span&gt;TestFactoryBean&lt;/span&gt;.&lt;span&gt;TestFactoryInnerBean&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; TestFactoryBean.&lt;span&gt;TestFactoryInnerBean &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[FactoryBean] getObject&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TestFactoryBean.TestFactoryInnerBean();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; getObjectType() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; TestFactoryBean.TestFactoryInnerBean&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isSingleton&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestFactoryInnerBean&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;14.SmartInitializingSingleton&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.SmartInitializingSingleton&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口中只有一个方法&lt;code&gt;afterSingletonsInstantiated&lt;/code&gt;，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;之后。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestSmartInitializingSingleton&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;SmartInitializingSingleton&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterSingletonsInstantiated&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestSmartInitializingSingleton]&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;15.CommandLineRunner&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.boot.CommandLineRunner&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个接口也只有一个方法：&lt;code&gt;run(String... args)&lt;/code&gt;，触发时机为整个项目启动完毕后，自动执行。如果有多个&lt;code&gt;CommandLineRunner&lt;/code&gt;，可以利用&lt;code&gt;@Order&lt;/code&gt;来进行排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestCommandLineRunner&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;CommandLineRunner&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[TestCommandLineRunner]&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;16.DisposableBean&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.beans.factory.DisposableBean&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个扩展点也只有一个方法：&lt;code&gt;destroy()&lt;/code&gt;，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行&lt;code&gt;applicationContext.registerShutdownHook&lt;/code&gt;时，就会触发这个方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展方式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NormalBeanA&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;DisposableBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[DisposableBean] NormalBeanA&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;17.ApplicationListener&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.springframework.context.ApplicationListener&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;准确的说，这个应该不算spring&amp;amp;springboot当中的一个扩展点，&lt;code&gt;ApplicationListener&lt;/code&gt;可以监听某个事件的&lt;code&gt;event&lt;/code&gt;，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来罗列下spring主要的内置事件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ContextRefreshedEvent&lt;/p&gt;&lt;p&gt;ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在&lt;code&gt;ConfigurableApplicationContext&lt;/code&gt;接口中使用 &lt;code&gt;refresh()&lt;/code&gt;方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，&lt;code&gt;ApplicationContext&lt;/code&gt;容器已就绪可用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ContextStartedEvent&lt;/p&gt;&lt;p&gt;当使用 &lt;code&gt;ConfigurableApplicationContext&lt;/code&gt; （ApplicationContext子接口）接口中的 start() 方法启动 &lt;code&gt;ApplicationContext&lt;/code&gt;时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ContextStoppedEvent&lt;/p&gt;&lt;p&gt;当使用 &lt;code&gt;ConfigurableApplicationContext&lt;/code&gt;接口中的 &lt;code&gt;stop()&lt;/code&gt;停止&lt;code&gt;ApplicationContext&lt;/code&gt; 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ContextClosedEvent&lt;/p&gt;&lt;p&gt;当使用 &lt;code&gt;ConfigurableApplicationContext&lt;/code&gt;接口中的 &lt;code&gt;close()&lt;/code&gt;方法关闭 &lt;code&gt;ApplicationContext&lt;/code&gt; 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RequestHandledEvent&lt;/p&gt;&lt;p&gt;这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;18.最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从这些spring&amp;amp;springboot的扩展点当中，大致可以窥视到整个bean的生命周期。在业务开发或者写中间件业务的时候，可以合理利用spring提供给我们的扩展点，在spring启动的各个阶段内做一些事情。以达到自定义初始化的目的。此篇总结，如果有错误或者疏漏的地方，恳请指正。&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;47&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;作者：铂赛东&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链接：https://www.jianshu.com/p/38d834db7413&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7716722fcd0fafbaf3eb326cb88b7743</guid>
<title>不再写 Python for 循环</title>
<link>https://toutiao.io/k/i3jtfpa</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从我开始探索 Python 中惊人的语言功能已经有一段时间了。一开始，我给自己一个挑战，目的是让我练习更多的 Python 语言功能，而不是使用其他编程语言的编程经验。这让事情变得越来越有趣！代码变得越来越简洁，代码看起来更加结构化和规范化。下面我将会介绍这些好处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常如下使用场景中会用到 for 循环：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在一个序列来提取一些信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从一个序列生成另一个序列。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写 for 已成习惯。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，Python 已经有很多工具可以帮助你完成这些工作，你只需要转移你的思路，并以不同的角度来思考它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过避免编写 for 循环，你可以获得什么好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;较少的代码量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更好的代码可读性&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;更少的缩进（对 Python 还是很有意义的）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下下面的代码结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; ...:&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; ...:&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ...:&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;except&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，我们正在处理多层嵌套的代码，这很难阅读。这个例子使用了多层嵌套的代码。我在这段代码中发现它无差别使用缩进把管理逻辑（with, try-except）和业务逻辑（for, if）混在一起。如果你遵守只对管理逻辑使用缩进的规范，那么核心业务逻辑应该立刻脱离出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;扁平结构比嵌套结构更好&quot; - The Zen of Python&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;可以使用的已有的工具来替换 for 循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. List Comprehension / Generator 表达式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个简单的例子。如果你想将一个数组转换为另一个数组：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;result = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; item_list:&lt;br/&gt;    new_item = do_something_with(item)&lt;br/&gt;    result.append(item)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢 MapReduce，你也可以使用 map，或者 Python 中的 List Comprehension：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;result = [do_something_with(item) &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; item_list]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，如果您只想迭代数组中的元素，也可以使用一样的代码 Generator Expression。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;result = (do_something_with(item) &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; item_list)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 函数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您想要将一个数组映射成另外数组，只需调用 map 函数，就可以用一个更高级、更实用的编程方式解决这个问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;doubled_list = map(&lt;span&gt;lambda&lt;/span&gt; x: x * &lt;span&gt;2&lt;/span&gt;, old_list)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要将序列减少为单个，请使用 reduce&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; reduce&lt;br/&gt;summation = reduce(&lt;span&gt;lambda&lt;/span&gt; x, y: x + y, numbers)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，许多 Python 内置函数都会使用 iterables：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a = list(range(&lt;span&gt;10&lt;/span&gt;))&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;a&lt;br/&gt;[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;all(a)&lt;br/&gt;&lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;any(a)&lt;br/&gt;&lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;max(a)&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;min(a)&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;list(filter(bool, a))&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;set(a)&lt;br/&gt;{&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;dict(zip(a,a))&lt;br/&gt;{&lt;span&gt;0&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;: &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;: &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sorted(a, reverse=&lt;span&gt;True&lt;/span&gt;)&lt;br/&gt;[&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;str(a)&lt;br/&gt;&lt;span&gt;&#x27;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;sum(a)&lt;br/&gt;&lt;span&gt;45&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Extract Functions or Generators&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述两种方法是很好的处理更简单的逻辑。更复杂的逻辑怎么样？作为程序员，我们编写函数来抽离出复杂的业务。相同的想法适用于此。如果你是这样写的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;results = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; item_list:&lt;br/&gt;    &lt;span&gt;# setups&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# condition&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# processing&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# calculation&lt;/span&gt;&lt;br/&gt;    results.append(result)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然你对一个代码块添加了太多的责任。相反，我建议你做：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;process_item&lt;/span&gt;&lt;span&gt;(item)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# setups&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# condition&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# processing&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# calculation&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;br/&gt;results = [process_item(item) &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; item_list]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果换成嵌套函数会如何&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;results = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;10&lt;/span&gt;):&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(i):&lt;br/&gt;        results.append((i, j))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换成 List Comprehension 来实现是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;results = [(i, j)&lt;br/&gt;           &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;           &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(i)]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的代码块需要记录一些内部状态&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# finding the max prior to the current item&lt;/span&gt;&lt;br/&gt;a = [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;results = []&lt;br/&gt;current_max = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; a:&lt;br/&gt;    current_max = max(i, current_max)&lt;br/&gt;    results.append(current_max)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# results = [3, 4, 6, 6, 6, 9, 9, 9, 9, 9]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 generator 来实现这一点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;max_generator&lt;/span&gt;&lt;span&gt;(numbers)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    current_max = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; numbers:&lt;br/&gt;        current_max = max(i, current_max)&lt;br/&gt;        &lt;span&gt;yield&lt;/span&gt; current_max&lt;br/&gt;&lt;br/&gt;a = [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;results = list(max_generator(a))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;读者可能要问 “等等！你在 generator 中用到 for 循环，作弊啊！别急，再看看下面的代码。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不要自己写。itertools 会帮你实现了&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个模块很简单。我相信这个模块在大多数场景中可以替换你原先的 for 循环。例如，最后一个例子可以重写为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt; accumulate&lt;br/&gt;a = [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;resutls = list(accumulate(a, max))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，如果要迭代组合序列，则需要使用&lt;code&gt;product()，   permutations()，   combinations()。&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在大多数情况下，您都不需要编写 for 循环。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你应该避免编写 for 循环，这样会有更好的代码可读性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9cc866c1d32afb5542d8a8ddef6a4fee</guid>
<title>前端抢饭碗系列之初识Docker容器化部署</title>
<link>https://toutiao.io/k/msyssih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;随着容器化技术盛行，Docker在前端领域也有着越来越广泛的应用；传统的前端部署方式需要我们将项目打包生成一系列的静态文件，然后上传到服务器，配置nginx文件；如果我们使用容器化部署，将部署操作都命令化，集中成一个脚本就可以完成原来复杂的部署过程。本文从Docker基础开始，来认识Docker的各种命令操作。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2MjcxNTQ0Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/jQmwTIFl1V0dLQzNJW15CVaCoNjposvTpccciaj05o5nPiaqfLRRfTQiaYFYPN41Etrrqt8jPOWukPmJWt3lYxwuA/0?wx_fmt=png&quot; data-nickname=&quot;全栈修仙之路&quot; data-alias=&quot;FerRoad&quot; data-signature=&quot;专注分享 TS、Vue3、前端架构和源码解析等技术干货。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;docker简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Docker&lt;/code&gt;是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFD2xY08nroehq8ddHEmwFia8AX2h6N0DIvwGBGV0yndPG70dibSECRAtw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Docker Logo&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker的英文翻译是码头工人，码头工人一般搬运的都是集装箱（Container），集装箱最大的成功在于其产品的标准化以及由此建立的一整套运输体系。在一艘几十万吨的巨轮上，装满了各种各样满载的集装箱，彼此之间不会相互影响；因此其本身就有&lt;code&gt;标准化&lt;/code&gt;、&lt;code&gt;集约化&lt;/code&gt;的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从Docker的logo我们也能看出，Docker的思想来自于集装箱；各个应用程序相当于不同的&lt;code&gt;集装箱&lt;/code&gt;，每个应用程序有着不同的应用环境，比如python开发的应用需要服务器部署一套python的开发环境，nodejs开发的应用需要服务器部署nodejs的环境，不同环境之间有可能还会彼此冲突，Docker可以帮助我们隔离不同的环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些同学于是就想到了，这不是虚拟机干的活么。是的，虚拟机可以很好的帮我们隔离各个环境，我们可以在windows上运行macos、ubuntu等虚拟机，也可以在macos上安装windows的虚拟机；不过传统的虚拟机技术是虚拟一整套硬件后，在其上运行完整的操作系统，在该系统上再运行所需应用进程，这样导致一台电脑只能运行数量较少的虚拟机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是Docker使用的容器技术比虚拟机更加的轻便和快捷。容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便，下图比较了两者的区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7016806722689075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFu4bUKfZmBFIpMCCmMZXYx53yjMLKVkOOThY56ic67mAp11w0ZxgWEVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Docker和虚拟机的区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比总结：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;容器&lt;/th&gt;&lt;th&gt;虚拟机&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;启动&lt;/td&gt;&lt;td&gt;秒级&lt;/td&gt;&lt;td&gt;分钟级&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;硬盘使用&lt;/td&gt;&lt;td&gt;一般为 MB&lt;/td&gt;&lt;td&gt;一般为 GB&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;系统资源&lt;/td&gt;&lt;td&gt;&lt;code&gt;0~5%&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;5~15%&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能&lt;/td&gt;&lt;td&gt;接近原生&lt;/td&gt;&lt;td&gt;弱于原生&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;系统支持量&lt;/td&gt;&lt;td&gt;单机支持上千个容器&lt;/td&gt;&lt;td&gt;一般几十个&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Docker优势&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker有以下优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;更高效的利用系统资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更快速的启动时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致的运行环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;持续交付和部署&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更轻松的迁移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更轻松的维护和扩展&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker通常用于如下场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;web应用的自动化打包和发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动化测试和持续集成、发布；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在服务型环境中部署和调整数据库或其他的后台应用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基本概念&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Docker中有三个基本概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;镜像（Image）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;容器（Container）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;仓库（Repository）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了Docker的基本概念，我们就理解了Docker的整个生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来弄懂&lt;code&gt;镜像&lt;/code&gt;的概念，Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有装系统经验的童鞋，可以把Docker镜像理解为一个操作系统的镜像（ISO文件），它是一个固定的文件，从一个镜像中，我们可以装到很多电脑上，变成一个个的操作系统（相当于容器），每个系统都是相同的，不过可以选择定制化安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和系统镜像不同的是，Docker镜像并不是像ISO文件那样整体打包成一个文件的，而是设计成了&lt;code&gt;分层存储&lt;/code&gt;的架构，它并不是由一个文件组成，而是由多层文件联合组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建镜像时，会一层层的构建，前面一层是后面一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次是&lt;code&gt;容器&lt;/code&gt;的概念，从编程的角度看，镜像和容器的关系更像是类和实例的关系；从一个镜像可以启动一个或者多个容器；镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFS0zTtjqCZlOTDWIhJqjqIw5JK7V4Us9h97LUeu0Lsl3vp10SDntp7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;容器和镜像的关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为&lt;code&gt;容器存储层&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3382084095063985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARF0WcZxDKncZNicMuMsGy5MtogHuNdIJsExv1C1bDnSBSsO3VpzJT2H9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;容器存储层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后是&lt;code&gt;仓库（Repository）&lt;/code&gt;的概念，我们构建一个镜像后，可以在本地运行，但是如果我们想要给网络上的其他用户使用，就要一个集中存储和分发镜像的服务器，仓库就是这样一个工具，有点类似Github。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像仓库Repository是同一类镜像的集合，包含了不同tag（标签）的Docker镜像，比如&lt;code&gt;ubuntu&lt;/code&gt;是仓库的名称，它里面有不同的tag，比如&lt;code&gt;16.04&lt;/code&gt;、&lt;code&gt;18.04&lt;/code&gt;，我们从镜像仓库中来获取镜像时可以通过&lt;code&gt;&amp;lt;仓库名&amp;gt;:&amp;lt;标签&amp;gt;&lt;/code&gt;的格式来指定具体版本的镜像，比如&lt;code&gt;ubuntu18.04&lt;/code&gt;；如果忽略标签，用&lt;code&gt;latest&lt;/code&gt;作为默认标签。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;镜像&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面介绍过，镜像是Docker的三个基本组件之一；运行容器需要本地有相应的镜像，如果没有会从远程仓库下载；那么我们来看下如何操作镜像。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查找镜像&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从&lt;code&gt;Docker Hub&lt;/code&gt;来搜索镜像&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker search ubuntu&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查找结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4290375203915171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFblbVMtDmEu2h0o1o4GgN8XE1t57kNyCXtO1PnKKLMiapu4AB3YyKyNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Docker查找镜像&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查找的列表中包含了以下几个字段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NAME: 镜像仓库源的名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DESCRIPTION: 镜像的描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;STARS: 类似Github里面的 star。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;OFFICIAL: 是否docker官方发布&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AUTOMATED: 自动构建。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;获取镜像&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要获取镜像，可以通过&lt;code&gt;docker pull&lt;/code&gt;命令，它的格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker pull &amp;lt;repository&amp;gt;:&amp;lt;tag&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是以ubuntu为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker pull ubuntu:16.04&lt;br/&gt;&lt;br/&gt;16.04: Pulling from library/ubuntu&lt;br/&gt;58690f9b18fc: Pull complete&lt;br/&gt;b51569e7c507: Pull complete&lt;br/&gt;da8ef40b9eca: Pull complete&lt;br/&gt;fb15d46c38dc: Pull complete&lt;br/&gt;Digest: sha256:0f71fa8d4d2d4292c3c617fda2b36f6dabe5c8b6e34c3dc5b0d17d4e704bd39c&lt;br/&gt;Status: Downloaded newer image &lt;span&gt;for&lt;/span&gt; ubuntu:16.04&lt;br/&gt;docker.io/library/ubuntu:16.04&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到最后一行&lt;code&gt;docker.io&lt;/code&gt;显示这是从官方仓库拉取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从下载过程我们可以看出我们上面说的分层存储的概念，即镜像是由多层存储构成；下载也是一层层的去下载，而不是单独一个文件；因此如果下载中有某个层已经被其他镜像下载过，则会显示&lt;code&gt;Already exists&lt;/code&gt;。下载过程中给出了每一层的ID的前12位，下载结束后给出镜像完整的&lt;code&gt;sha256&lt;/code&gt;摘要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker的镜像仓库分为官方仓库和非官方，官方的镜像就是从&lt;code&gt;Docker Hub&lt;/code&gt;拉取的；如果想要从第三方的镜像仓库获取，可以在仓库名称前加上仓库的服务地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker pull &amp;lt;Docker Registry地址:端口号&amp;gt;&amp;lt;repository&amp;gt;:&amp;lt;tag&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;列出镜像&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过下面的命令，我们可以列出本地已经下载的镜像：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker image ls&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行命令出现以下列表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3040604343720491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFOI5dj18iaOeVkX5ehpnUbbqxiaLvFdmbRo5xx6ZOo2HrH5KVlzoZ7p9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1059&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;列出镜像&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表包含了&lt;code&gt;仓库名&lt;/code&gt;、&lt;code&gt;标签&lt;/code&gt;、&lt;code&gt;镜像ID&lt;/code&gt;、&lt;code&gt;创建时间&lt;/code&gt;和&lt;code&gt;所占用空间&lt;/code&gt;；我们看到有两个&lt;code&gt;mongo&lt;/code&gt;的镜像，不过两个镜像有不同的标签。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ls命令&lt;/code&gt;默认会列出所有的镜像，但是当本地镜像比较多的时候不方便查看，有时候我们希望列出部分的镜像，除了可以通过linux的grep命令，还可以在&lt;code&gt;ls命令&lt;/code&gt;后面跟上参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker image ls mongo&lt;br/&gt;&lt;br/&gt;REPOSITORY    TAG           IMAGE ID       CREATED         SIZE&lt;br/&gt;mongo         latest        dfda7a2cf273   2 months ago    693MB&lt;br/&gt;mongo         4.0           e305b5d51c0a   2 months ago    430MB&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;删除镜像&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;rm命令&lt;/code&gt;删除本地镜像：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker image rm [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; ...]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者简写为&lt;code&gt;rmi&lt;/code&gt;命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker rmi [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; ...]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;&amp;lt;镜像&amp;gt;&lt;/code&gt;，可以是&lt;code&gt;镜像短ID&lt;/code&gt;、&lt;code&gt;镜像长ID&lt;/code&gt;、&lt;code&gt;镜像名&lt;/code&gt;或者&lt;code&gt;镜像摘要&lt;/code&gt;；&lt;code&gt;docker image ls&lt;/code&gt;列出来的已经是短ID了，我们还可以取前三个字符进行删除；比如我们想要删除上面的&lt;code&gt;mongo:4.0&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker rmi e30&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建镜像&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了使用官方的镜像，我们可以构建自己的镜像；一般都在其他的镜像基础上进行构建，比如node、nginx等；构建镜像需要用到&lt;code&gt;Dockerfile&lt;/code&gt;，它是一个文本文件，文本内容包含了一条条构建镜像所需的指令和说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在一个空白目录新建一个&lt;code&gt;Dockerfile&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir mynginx&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; mynginx/&lt;br/&gt;touch Dockerfile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们向&lt;code&gt;Dockerfile&lt;/code&gt;写入以下内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;FROM nginx&lt;br/&gt;RUN &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;&amp;lt;h1&amp;gt;Hello, This is My Nginx&amp;lt;/h1&amp;gt;&#x27;&lt;/span&gt; &amp;gt; /usr/share/nginx/html/index.html&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的Dockerfile很简单，就两个命令：FROM和RUN，我们在Dockerfile里面对命令进行详细的介绍；我们使用&lt;code&gt;build&lt;/code&gt;命令构建镜像，它的格式为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker build [选项] &amp;lt;上下文路径/URL/-&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们在Dockerfile所在的目录执行命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker build -t mynginx:v3 .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行命令，我们看到镜像也是按照Dockerfile里面的步骤，分层进行构建的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20361083249749248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFibZPria7GrFEF7FtPJIZMJmMSSF701jDTpCHYux2IBE3dy2JQs8ib7dLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;构建镜像&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建成功后，我们列出所有的镜像就能看到刚刚构建的mynginx了。在上面的命令中，我们发现最后有一个&lt;code&gt;.&lt;/code&gt;，它表示了当前目录，如果不写这个目录会报错提示；如果对应上面的格式，它其实就是&lt;code&gt;上下文路径&lt;/code&gt;，那这个上下文路径是做什么用的呢？要理解这个路径的作用，我们首先要来理解Docker的架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker是一个典型的C/S架构的应用，它可以分为&lt;code&gt;Docker客户端&lt;/code&gt;（平时敲的Docker命令）和&lt;code&gt;Docker服务端&lt;/code&gt;（Docker守护进程）。Docker客户端通过REST API和服务端进行交互，docker客户端每发送一条指令，底层都会转化成REST API调用的形式发送给服务端，服务端处理客户端发送的请求并给出响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此表面上看我们好像在本机上执行各种Docker的功能，实际上都是都是在Docker服务端完成的，包括Docker镜像的构建、容器创建、容器运行等工作都是Docker服务端来完成的，Docker客户端只是承担发送指令的角色。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5211970074812967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFbAPdaFtPwJibLX4xrNthrhg0P1ewI6jzVSIhmt9agXvtSdiboicWF20Aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1604&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Docker架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了Docker的架构就很容器理解Docker构建镜像的工作原理了，它的流程大致如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;执行build命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker客户端会将构建命令后面指定的上下文路径下的所有文件打包成一个tar包，发送给Docker服务端;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Docker服务端收到客户端发送的tar包，然后解压，根据Dockerfile里面的指令进行镜像的分层构建；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此上下文路径本质上就是指定服务端上Dockerfile中指令工作的目录；比如我们在Dockerfile中经常需要拷贝代码到镜像中去，因此会这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;COPY ./package.json /app/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要复制的package.json文件，并不一定在docker build命令执行的目录下，也不一定是在Dockerfile文件同级目录下，而是docker build命令指定的&lt;code&gt;上下文路径&lt;/code&gt;目录下的package.json。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;容器&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍了镜像，我们到了Docker第三个核心概念了：容器。容器是镜像的运行时的实例，我们可以从一个镜像上启动一个或多个容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对容器的管理包括创建、启动、停止、进入、导入导出和删除等，我们分别来看下每个操作的具体命令以及效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;创建启动容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建并启动一个容器用的命令是&lt;code&gt;docker run&lt;/code&gt;，它后面有时候会带上有很长很长的选项，不过其基本的语法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run [选项] 镜像名称 [命令] [参数...]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以带上一些常见的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-d：容器在后台运行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-t：为容器重新分配一个伪输入终端，通常与-i同时使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-i：以交互模式运行容器，通常与-t同时使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-P：随机端口映射&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-p：指定端口映射&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--name：为容器指定一个名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-e：设置环境变量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--dns：指定容器使用的DNS服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-m：设置容器使用内存最大值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--link：链接另一个容器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-v：绑定卷&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--rm：退出容器后删除该容器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个hello world容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run hello-world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5131729667812142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFtia6poscqry3QspGKg7Prdr5oGCLJWcYiaMcMsoXhDibrXctF4Hrh7aUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;873&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;运行hello world&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样创建的容器只能看到一堆的打印说明，我们不能对容器进行任何操作，我们可以加上&lt;code&gt;-it&lt;/code&gt;选项（-i和-t的简写），来让Docker分配一个终端给这个容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -it ubuntu:18.04 /bin/bash&lt;br/&gt;root@fdb133227c9a:/&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;root@fdb133227c9a:/&lt;span&gt;# ls&lt;/span&gt;&lt;br/&gt;root@fdb133227c9a:/&lt;span&gt;# exit&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在容器内部进行操作了，退出终端可以使用&lt;code&gt;exit&lt;/code&gt;命令或者&lt;code&gt;ctrl+d&lt;/code&gt;；我们退出容器后如果查看运行中的容器，发现并没有任何容器信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们都是需要让容器在后台运行，因此我们加上&lt;code&gt;-d&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -itd ubuntu:18.04 /bin/bash&lt;br/&gt;ad4d11b6d3b6a2a37fc702345a09fa0a5671f5b3943def7963994535e8600f7b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;容器不再以命令行的方式呈现了，而是直接丢出一长串的数字字母组合，这是容器的唯一id；再用&lt;code&gt;ps&lt;/code&gt;命令查看运行状态的容器，看到我们的容器已经在后台默默运行了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07677784770295784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFias2sYA0899tWxebYOO7zicpQtBSSMmY4GhickOgicr9yLq2ibfib1E1yniaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1589&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;容器后台运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用&lt;code&gt;run&lt;/code&gt;命令创建容器时，Docker在后台进行了如下的操作：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;检查本地是否存在指定的镜像，不存在就从 registry 下载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用镜像创建并启动一个容器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分配一个文件系统，并在只读的镜像层外面挂载一层可读写层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从地址池配置一个 ip 地址给容器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行用户指定的应用程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行完毕后容器被终止&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;终止容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用stop命令来终止容器的运行；如果容器中的应用终结或者报错时，容器也会自动终止；我们可以使用&lt;code&gt;ps&lt;/code&gt;命令查看到的容器短id来终止对应的容器：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker stop ad4d11b6d3b6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于终止状态的容器，&lt;code&gt;ps&lt;/code&gt;命令已经不能看到它了，我们可以加上&lt;code&gt;-a&lt;/code&gt;选项（表示所有）来查看，它的STATUS已经变成了&lt;code&gt;Exited&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker ps -a&lt;br/&gt;CONTAINER ID   IMAGE         COMMAND       CREATED        STATUS                PORTS  &lt;br/&gt;ad4d11b6d3b6   ubuntu:16.04  &lt;span&gt;&quot;/bin/bash&quot;&lt;/span&gt;   2 hours ago    Exited (0) 2 minutes ago&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;终止状态的容器我们可以使用&lt;code&gt;docker start [容器id]&lt;/code&gt;来让它重新进入启动状态，运行中的容器我们也可以使用&lt;code&gt;docker restart [容器id]&lt;/code&gt;让它重新启动。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;进入容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们会需要进入容器进行一些操作，比如进入nginx容器进行平滑重启，我们可以使用&lt;code&gt;docker attach&lt;/code&gt;或者&lt;code&gt;docker exec&lt;/code&gt;进入，不过推荐使用&lt;code&gt;exec&lt;/code&gt;命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先看下如果使用&lt;code&gt;attach&lt;/code&gt;命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker attach ad4d11b6d3b6&lt;br/&gt;root@ad4d11b6d3b6:/&lt;span&gt;# exit&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们从终端exit后，整个容器会停止；而使用&lt;code&gt;exec&lt;/code&gt;命令不会导致容器停止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只使用&lt;code&gt;-i&lt;/code&gt;参数，由于没有分配伪终端，界面没有我们熟悉的Linux命令提示符，但是执行命令仍然可以看到运行结果；当使用&lt;code&gt;-i&lt;/code&gt;和&lt;code&gt;-t&lt;/code&gt;参数时，才能看到我们常见的Linux命令提示符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker &lt;span&gt;exec&lt;/span&gt; -i ad4d11b6d3b6 bash&lt;br/&gt;ls&lt;br/&gt;bin&lt;br/&gt;boot&lt;br/&gt;dev&lt;br/&gt;etc&lt;br/&gt;home&lt;br/&gt;lib&lt;br/&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;br/&gt;/&lt;br/&gt;&lt;br/&gt;$ docker &lt;span&gt;exec&lt;/span&gt; -it ad4d11b6d3b6 bash&lt;br/&gt;root@ad4d11b6d3b6:/&lt;span&gt;# exit&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，我们进入的容器需要是运行状态，如果不是运行状态，则会报错：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Error response from daemon: Container ad4d11b6d3b6 is not running&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查看容器日志&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要对容器运行过程进行一些监测，查看它的运行过程记录的日志情况，以及是否报错等等；使用&lt;code&gt;logs&lt;/code&gt;命令获取容器的日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker logs ad4d11b6d3b6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它还支持以下几个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-f : 跟踪日志输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--since :显示某个开始时间的所有日志&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-t : 显示时间戳&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--tail :仅列出最新N条容器日志&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;logs&lt;/code&gt;命令会展示从容器启动以来的所有日志，如果容器运行时间久，会列出非常多的日志，我们可以加&lt;code&gt;tail&lt;/code&gt;参数仅展示最新的日志记录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 列出最新的10条日志&lt;/span&gt;&lt;br/&gt;$ docker logs --tail=10 ad4d11b6d3b6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于已经创建的容器，我们可以使用&lt;code&gt;inspect&lt;/code&gt;来查看容器的底层基础信息，包括容器的id、创建时间、运行状态、启动参数、目录挂载、网路配置等等；另外，该命令也能查看docker镜像的信息，它的格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker inspect [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; ...]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;inspect支持以下选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;-f :指定返回值的模板文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-s :显示总的文件大小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--type :为指定类型返回JSON。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行后，会通过JSON格式显示容器的基本信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07677784770295784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VsDWOHv25bd2CgA3bWV3xmZtMPrDyARFias2sYA0899tWxebYOO7zicpQtBSSMmY4GhickOgicr9yLq2ibfib1E1yniaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1589&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;容器后台运行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这么大段的文字，我们想要获取对我们有用的信息十分的麻烦；除了用grep进行过滤外（万物皆可grep），我们还可以通过&lt;code&gt;-f&lt;/code&gt;参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 获取容器名&lt;/span&gt;&lt;br/&gt;docker inspect -f {{.Name}} &amp;lt;容器ID&amp;gt;&lt;br/&gt;&lt;span&gt;# 获取容器目录挂载信息&lt;/span&gt;&lt;br/&gt;docker inspect -f {{.NetworkSettings.Mounts}} &amp;lt;容器ID&amp;gt;&lt;br/&gt;&lt;span&gt;# 获取容器网络设置的相关信息&lt;/span&gt;&lt;br/&gt;docker inspect -f {{.NetworkSettings}} &amp;lt;容器ID&amp;gt;&lt;br/&gt;&lt;span&gt;# 获取容器的 IP 的相关信息&lt;/span&gt;&lt;br/&gt;docker inspect -f {{.NetworkSettings.IPAddress}} &amp;lt;容器ID&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;删除容器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个容器我们不想再使用了，可以使用&lt;code&gt;rm&lt;/code&gt;命令来删除：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker rm ad4d11b6d3b6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要删除一个运行中的容器，可以添加&lt;code&gt;-f&lt;/code&gt;参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker rm -f ad4d11b6d3b6&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据管理&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面介绍到容器是保持无状态化的，就是&lt;code&gt;随用随删&lt;/code&gt;，并不会保留数据记录；在使用docker的时候，经常会用到一些需要保留数据的容器，比如mysql、mongodb，往往需要对容器中的数据进行持久化；或者在多个容器之间进行数据共享，这就涉及到了容器的数据管理，主要有两种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据卷（Data Volumes）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;挂载主机目录 (Bind mounts)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据卷&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;数据卷&lt;/code&gt;是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据卷可以在容器之间共享和重用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对数据卷的修改会立马生效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对数据卷的更新，不会影响镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据卷默认会一直存在，即使容器被删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们创建一个数据卷：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker volume create my-vol&lt;br/&gt;my-vol&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;ls&lt;/code&gt;可以列出我们本地所有的数据卷：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker volume ls&lt;br/&gt;DRIVER    VOLUME NAME&lt;br/&gt;&lt;span&gt;local&lt;/span&gt;     my-vol&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;命令也可以查看我们数据卷的具体信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker volume inspect my-vol&lt;br/&gt;[&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;&quot;CreatedAt&quot;&lt;/span&gt;: &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Driver&quot;&lt;/span&gt;: &lt;span&gt;&quot;local&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Labels&quot;&lt;/span&gt;: {},&lt;br/&gt;        &lt;span&gt;&quot;Mountpoint&quot;&lt;/span&gt;: &lt;span&gt;&quot;/data/programs/docker/volumes/my-vol/_data&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span&gt;&quot;my-vol&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Options&quot;&lt;/span&gt;: {},&lt;br/&gt;        &lt;span&gt;&quot;Scope&quot;&lt;/span&gt;: &lt;span&gt;&quot;local&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动容器时，使用&lt;code&gt;--mount&lt;/code&gt;将数据卷挂载在容器的目录里（可以有多个挂载点）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -d -P --name web --mount &lt;span&gt;source&lt;/span&gt;=my-vol,target=/usr/share/nginx/html nginx&lt;br/&gt;&lt;span&gt;# 通过-v简写形式&lt;/span&gt;&lt;br/&gt;$ docker run -d -P --name web -v my-vol:/usr/share/nginx/html nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们借助上面的inspect命令查看容器的挂载信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker inspect -f &lt;span&gt;&quot;{{.Mounts}}&quot;&lt;/span&gt; web&lt;br/&gt;[{volume my-vol /data/programs/docker/volumes/my-vol/_data /usr/share/nginx/html &lt;span&gt;local&lt;/span&gt; z &lt;span&gt;true&lt;/span&gt; }]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;数据卷&lt;/code&gt;是被设计用来持久化数据的，它的生命周期独立于容器；因此即使我们将容器删除了，数据卷的数据依然还是存在的，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的&lt;code&gt;数据卷&lt;/code&gt;，我们可以在删除容器的时候使用&lt;code&gt;docker rm -v&lt;/code&gt;命令同时删除数据卷，或者手动来删除：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker volume rm my-vol&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无主的数据卷可能会占据很多空间，要清理请使用以下命令（谨慎使用！）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker volume prune&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;挂载目录&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现上面&lt;code&gt;数据卷&lt;/code&gt;挂载的目录都是在docker的安装路径下，不利于我们进行维护，我们可以直接挂载自定义的目录。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -d -P --name web --mount &lt;span&gt;source&lt;/span&gt;=/home/nginx,target=/usr/share/nginx/html nginx&lt;br/&gt;&lt;span&gt;# 通过-v简写形式&lt;/span&gt;&lt;br/&gt;$ docker run -d -P --name web -v /home/nginx:/usr/share/nginx/html nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;挂载的本地目录的路径必须是&lt;code&gt;绝对路径&lt;/code&gt;，不能是相对路径。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本地路径如果不存在，会自动生成。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认挂载的主机目录的默认权限是&lt;code&gt;读写&lt;/code&gt;，可以通过增加&lt;code&gt;readonly&lt;/code&gt;指定为&lt;code&gt;只读&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ docker run -d -P --name web -v /home/nginx:/usr/share/nginx/html:ro nginx&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加readonly后，如果我们在容器内的&lt;code&gt;/usr/share/nginx/html&lt;/code&gt;目录下修改文件或者新建文件就会报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，如果我们挂载本地目录，需要保证挂载的目录下面有程序运行所需要的文件，比如这里nginx容器需要在我们在本地目录/home/nginx下有index.html文件，如果没有的话会报403错误。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊了这么多Docker的知识你学会如何使用Docker命令了吗？关注我，带你了解更多好玩的前端内容。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>