<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e7c0e5d4882eca7b08357e501003bf0b</guid>
<title>重磅出击，20 张图带你彻底了解 ReentrantLock 加锁解锁的原理</title>
<link>https://toutiao.io/k/jyfkfs8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;点击“阿Q说代码”，关注，设为星标&lt;/center&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;每日技术干货，第一时间送达！&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽大家好，我是阿Q。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近是上班忙项目，下班带娃，忙的不可开交，连摸鱼的时间都没有了。今天趁假期用&lt;strong&gt;图解&lt;/strong&gt;的方式从&lt;strong&gt;源码&lt;/strong&gt;角度给大家说一下&lt;code&gt;ReentrantLock&lt;/code&gt;加锁解锁的全过程。系好安全带，发车了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单使用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊它的源码之前，我们先来做个简单的使用说明。当我在&lt;code&gt;IDEA&lt;/code&gt;中创建了一个简单的&lt;code&gt;Demo&lt;/code&gt;之后，它会给出以下提示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09851694915254237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpPBhg9teBc79RAt13jsfx2pna3LEdkvS8c5jUVUafakicrIFibLLKPQOwzyibsk4icCBjogcm4qWLn3IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1888&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;提示文字&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用阻塞等待获取锁的方式中，必须在&lt;code&gt;try&lt;/code&gt;代码块之外，并且在加锁方法与&lt;code&gt;try&lt;/code&gt;代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在&lt;code&gt;finally&lt;/code&gt;中无法解锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、如果在&lt;code&gt;lock&lt;/code&gt;方法与&lt;code&gt;try&lt;/code&gt;代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、如果&lt;code&gt;lock&lt;/code&gt;方法在&lt;code&gt;try&lt;/code&gt;代码块之内，可能由于其它方法抛出异常，导致在&lt;code&gt;finally&lt;/code&gt;代码块中，&lt;code&gt;unlock&lt;/code&gt;对未加锁的对象解锁，它会调用&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;tryRelease&lt;/code&gt;方法（取决于具体实现类），抛出&lt;code&gt;IllegalMonitorStateException&lt;/code&gt;异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、在&lt;code&gt;Lock&lt;/code&gt;对象的&lt;code&gt;lock&lt;/code&gt;方法实现中可能抛出&lt;code&gt;unchecked&lt;/code&gt;异常，产生的后果与说明二相同。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;java.concurrent.LockShouldWithTryFinallyRule.rule.desc&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还举了两个例子，正确案例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock lock = &lt;span&gt;new&lt;/span&gt; XxxLock();&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;lock.lock();&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    doSomething();&lt;br/&gt;    doOthers();&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    lock.unlock();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误案例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock lock = &lt;span&gt;new&lt;/span&gt; XxxLock();&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 如果在此抛出异常，会直接执行 finally 块的代码&lt;/span&gt;&lt;br/&gt;    doSomething();&lt;br/&gt;    &lt;span&gt;// 不管锁是否成功，finally 块都会执行&lt;/span&gt;&lt;br/&gt;    lock.lock();&lt;br/&gt;    doOthers();&lt;br/&gt;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    lock.unlock();&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AQS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的案例中加锁调用的是&lt;code&gt;lock()&lt;/code&gt;方法，解锁用的是&lt;code&gt;unlock()&lt;/code&gt;方法，而通过查看源码发现它们都是调用的内部静态抽象类&lt;code&gt;Sync&lt;/code&gt;的相关方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;abstract static class Sync extends AbstractQueuedSynchronizer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sync &lt;/code&gt;是通过继承&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;来实现的，没错，&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;就是&lt;code&gt;AQS&lt;/code&gt;的全称。&lt;code&gt;AQS&lt;/code&gt;内部维护着一个&lt;code&gt;FIFO&lt;/code&gt;的双向队列（&lt;code&gt;CLH&lt;/code&gt;），&lt;code&gt;ReentrantLock&lt;/code&gt;也是基于它来实现的，先来张图感受下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5121042830540037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pHjNyqyUzooc9ZmbJ15vnaCSBM63hnIXLgYkbibnmEOvwZx7PSmlJPyQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Node 属性&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//此处是 Node 的部分属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//排他锁标识&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//如果带有这个标识，证明是失效了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//具有这个标识，说明后继节点需要被唤醒&lt;/span&gt;&lt;br/&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//Node对象存储标识的地方&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; waitStatus;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//指向上一个节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Node prev;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//指向下一个节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Node next;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//当前Node绑定的线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;volatile&lt;/span&gt; Thread thread;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;//返回前驱节点即上一个节点，如果前驱节点为空，抛出异常&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;final&lt;/span&gt; Node &lt;span&gt;predecessor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{&lt;br/&gt;  Node p = prev;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (p == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于里边的&lt;code&gt;waitStatus&lt;/code&gt;属性，我们需要做个解释：&lt;strong&gt;（非常重要）&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CANCELLED(1)：当前节点取消获取锁。当等待超时或被中断(响应中断)，会触发变更为此状态，进入该状态后节点状态不再变化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SIGNAL(-1)：后面节点等待当前节点唤醒；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CONDITION(-2)：&lt;code&gt;Condition&lt;/code&gt;中使用，当前线程阻塞在&lt;code&gt;Condition&lt;/code&gt;，如果其他线程调用了&lt;code&gt;Condition&lt;/code&gt;的&lt;code&gt;signal&lt;/code&gt;方法，这个结点将从等待队列转移到同步队列队尾，等待获取同步锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PROPAGATE(-3)：共享模式，前置节点唤醒后面节点后，唤醒操作无条件传播下去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;0：中间状态，当前节点后面的节点已经唤醒，但是当前节点线程还没有执行完成；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;AQS 属性&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 头结点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node head;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 尾结点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; Node tail;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//0-&amp;gt;1 拿到锁，大于0 说明当前已经有线程占用了锁资源&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们先简单了解下&lt;code&gt;AQS&lt;/code&gt;的构造以帮助大家更好的理解&lt;code&gt;ReentrantLock&lt;/code&gt;，至于深层次的东西先不做展开！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加锁&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对&lt;code&gt;AQS&lt;/code&gt;的结构有了基本了解之后，我们正式进入主题——加锁。从源码中可以看出锁被分为&lt;strong&gt;公平锁&lt;/strong&gt;和&lt;strong&gt;非公平锁&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40091743119266054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pgeX5C1jibmET92ZYicT4Z93t0E6gXxWl31WIsIMzrZm6uQ3aoBaQyiaMA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 公平锁代码&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 非公平锁代码&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;        setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步查看代码发现非公平锁似乎包含公平锁的逻辑，所以我们就从“非公平锁”开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;非公平锁&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//通过 CAS 的方式尝试将 state 从0改为1，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果返回 true，代表修改成功，获得锁资源;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//如果返回false，代表修改失败，未获取锁资源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;        &lt;span&gt;// 将属性exclusiveOwnerThread设置为当前线程，该属性是AQS的父类提供的&lt;/span&gt;&lt;br/&gt;        setExclusiveOwnerThread(Thread.currentThread());&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;compareAndSetState()&lt;/code&gt;：底层调用的是&lt;code&gt;unsafe&lt;/code&gt;的&lt;code&gt;compareAndSwapInt&lt;/code&gt;，该方法是原子操作；&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个线程（&lt;code&gt;t1&lt;/code&gt;、&lt;code&gt;t2&lt;/code&gt;）在竞争锁资源，线程1获取锁资源之后，执行&lt;code&gt;setExclusiveOwnerThread&lt;/code&gt;操作，设置属性值为当前线程&lt;code&gt;t1&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4702702702702704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pEMmXYa0YJaVFhPF2Eic2dlXqM9E9H3OVsyOVQiarGMQ0MDKUWljSSh4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;370&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，当&lt;code&gt;t2&lt;/code&gt;想要获取锁资源，调用&lt;code&gt;lock()&lt;/code&gt;方法之后，执行&lt;code&gt;compareAndSetState(0, 1)&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，会走&lt;code&gt;else&lt;/code&gt;执行&lt;code&gt;acquire()&lt;/code&gt;方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;方法查看&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;accquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// tryAcquire 再次尝试获取锁资源，如果尝试成功，返回true，尝试失败返回false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        &lt;span&gt;// 走到这，代表获取锁资源失败，需要将当前线程封装成一个Node，追加到AQS的队列中&lt;/span&gt;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        &lt;span&gt;// 线程中断&lt;/span&gt;&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;accquire()&lt;/code&gt;中涉及的方法比较多，我们将进行拆解，一个一个来分析，顺序：&lt;code&gt;tryAcquire() -&amp;gt; addWaiter() -&amp;gt; acquireQueued()&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 tryAcquire() 方法&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//AQS中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//AQS 是基类，具体实现在自己的类中实现，我们去查看“非公平锁”中的实现&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//ReentrantLock 中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; nonfairTryAcquire(acquires);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;nonfairTryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取当前线程&lt;/span&gt;&lt;br/&gt; &lt;span&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;br/&gt; &lt;span&gt;//获取AQS 的 state &lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; c = getState();&lt;br/&gt; &lt;span&gt;// 如果 state 为0，代表尝试再次获取锁资源&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;// 步骤同上：通过 CAS 的方式尝试将 state 从0改为1，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//如果返回 true，代表修改成功，获得锁资源;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//如果返回false，代表修改失败，未获取锁资源&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (compareAndSetState(&lt;span&gt;0&lt;/span&gt;, acquires)) {&lt;br/&gt;   &lt;span&gt;//设置属性为当前线程&lt;/span&gt;&lt;br/&gt;   setExclusiveOwnerThread(current);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;//当前占有锁资源的线程是否是当前线程，如果是则证明是可重入操作&lt;/span&gt;&lt;br/&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) {&lt;br/&gt;  &lt;span&gt;//将 state + 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; nextc = c + acquires;&lt;br/&gt;  &lt;span&gt;//为什么会小于 0 呢？因为最大值 + 1 后会将符号位的0改为1 会变成负数(可参考Integer.MAX_VALUE + 1)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;// overflow&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;//加1后小于0，超出锁可重入的最大值，抛异常&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;//设置 state 状态&lt;/span&gt;&lt;br/&gt;  setState(nextc);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程1已经获取到了锁，此时&lt;code&gt;state&lt;/code&gt;为1，所以不走&lt;code&gt;nonfairTryAcquire()&lt;/code&gt;的&lt;code&gt;if&lt;/code&gt;。又因为当前是线程2，不是占有当前锁的线程1，所以也不会走&lt;code&gt;else if&lt;/code&gt;，即&lt;code&gt;tryAcquire()&lt;/code&gt;方法返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 addWaiter() 方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;走到本方法中，代表获取锁资源失败。&lt;code&gt;addWaiter()&lt;/code&gt;将没有获取到锁资源的线程甩到队列的尾部。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;addWaiter&lt;/span&gt;&lt;span&gt;(Node mode)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//创建 Node 类，并且设置 thread 为当前线程，设置为排它锁&lt;/span&gt;&lt;br/&gt; Node node = &lt;span&gt;new&lt;/span&gt; Node(Thread.currentThread(), mode);&lt;br/&gt; &lt;span&gt;// 获取 AQS 中队列的尾部节点&lt;/span&gt;&lt;br/&gt; Node pred = tail;&lt;br/&gt; &lt;span&gt;// 如果 tail == null，说明是空队列，&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 不为 null，说明现在队列中有数据，&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;// 将当前节点的 prev 指向刚才的尾部节点，那么当前节点应该设置为尾部节点&lt;/span&gt;&lt;br/&gt;  node.prev = pred;&lt;br/&gt;  &lt;span&gt;// CAS 将 tail 节点设置为当前节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(pred, node)) {&lt;br/&gt;   &lt;span&gt;// 将之前尾节点的 next 设置为当前节点&lt;/span&gt;&lt;br/&gt;   pred.next = node;&lt;br/&gt;   &lt;span&gt;// 返回当前节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; enq(node);&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; node;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;tail&lt;/code&gt;不为空，即队列中有数据时，我们来图解一下&lt;code&gt;pred!=null&lt;/code&gt;代码块中的代码。初始化状态如下，&lt;code&gt;pred&lt;/code&gt;指向尾节点，&lt;code&gt;node&lt;/code&gt;指向新的节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5639344262295082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pK24dh2HXmuaX0ib4l3gptj34aYl6lLv2GyP83dYVX9ic68ycI78NDNAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;node.prev = pred;&lt;/code&gt;将&lt;code&gt;node&lt;/code&gt;的前驱节点设置为&lt;code&gt;pred&lt;/code&gt;指向的节点&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5517241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pg322lJ6Ht8v7ChiaGRjDsa8uObjQ0CfX9od2cjIx957IMEoKCt7XNnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1218&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;compareAndSetTail(pred, node)&lt;/code&gt;通过&lt;code&gt;CAS&lt;/code&gt;的方式尝试将当前节点&lt;code&gt;node&lt;/code&gt;设置为尾结点，此处我们假设设置成功，则&lt;code&gt;FIFO&lt;/code&gt;队列的&lt;code&gt;tail&lt;/code&gt;指向&lt;code&gt;node&lt;/code&gt;节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5475223395613322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pOwXUliaGvl5u3CPnaDzOWx4Tcfp7c882KiaicljNjVSxjxFbweGmAwRuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1231&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pred.next = node;&lt;/code&gt;将&lt;code&gt;pred&lt;/code&gt;节点的后继节点设置为&lt;code&gt;node&lt;/code&gt;节点，此时&lt;code&gt;node&lt;/code&gt;节点成功进入&lt;code&gt;FIFO&lt;/code&gt;队列尾部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5646586345381526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pGKibxvmluEgZnLZicDgq1eyL3AiaamnT3QOPLko8nolibG9c6eEzJgiaRxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而当&lt;code&gt;pred&lt;/code&gt;为空，即队列中没有节点或将&lt;code&gt;node&lt;/code&gt;节点设置为尾结点失败时，会走&lt;code&gt;enq()&lt;/code&gt;方法。我们列举的例子就符合&lt;code&gt;pred&lt;/code&gt;为空的情况，就让我们以例子为基础继续分析吧。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//现在没人排队，我是第一个 || 前边CAS失败也会进入这个位置重新往队列尾巴去塞&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Node &lt;span&gt;enq&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//死循环&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;  &lt;span&gt;//重新获取tail节点&lt;/span&gt;&lt;br/&gt;  Node t = tail;&lt;br/&gt;  &lt;span&gt;// 没人排队，队列为空&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;// 初始化一个 Node 为 head，而这个head 没有意义&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt; Node()))&lt;br/&gt;    &lt;span&gt;// 将头尾都指向了这个初始化的Node，第一次循环结束&lt;/span&gt;&lt;br/&gt;    tail = head;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 有人排队，往队列尾巴塞&lt;/span&gt;&lt;br/&gt;   node.prev = t;&lt;br/&gt;   &lt;span&gt;// CAS 将 tail 节点设置为当前节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (compareAndSetTail(t, node)) {&lt;br/&gt;    &lt;span&gt;//将之前尾节点的 next 设置为当前节点&lt;/span&gt;&lt;br/&gt;    t.next = node;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; t;&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入死循环，首先会走&lt;code&gt;if&lt;/code&gt;方法的逻辑，通过&lt;code&gt;CAS&lt;/code&gt;的方式尝试将一个新节点设置为&lt;code&gt;head&lt;/code&gt;节点，然后将&lt;code&gt;tail&lt;/code&gt;也指向新节点。可以看出队列中的头节点只是个初始化的节点，没有任何意义。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.574487895716946&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pXETtXibjDQMYusCF8OSdeJFywFdyo0WR3XjYjKKNQLe8WDoPWL3lMzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1074&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续走死循环中的代码，此时&lt;code&gt;t&lt;/code&gt;不为&lt;code&gt;null&lt;/code&gt;，所以会走&lt;code&gt;else&lt;/code&gt;方法。将&lt;code&gt;node&lt;/code&gt;的前驱节点指向&lt;code&gt;t&lt;/code&gt;，通过&lt;code&gt;CAS&lt;/code&gt;方式将当前节点&lt;code&gt;node&lt;/code&gt;设置为尾结点，然后将&lt;code&gt;t&lt;/code&gt;的后继节点指向&lt;code&gt;node&lt;/code&gt;。此时线程2的节点就被成功塞入&lt;code&gt;FIFO&lt;/code&gt;队列尾部。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6016949152542372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pyibKScicqpShhDYKBfwWrHSJWGa5lCqa90G2M0miaOTcgt7VSQLvA7Guw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看 acquireQueued()方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将已经在队列中的&lt;code&gt;node&lt;/code&gt;尝试去获取锁否则挂起。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;acquireQueued&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;// 获取锁资源的标识,失败为 true，成功为 false&lt;/span&gt;&lt;br/&gt; &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 线程中断的标识，中断为 true，不中断为 false&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;   &lt;span&gt;// 获取当前节点的上一个节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;   &lt;span&gt;//p为头节点，尝试获取锁操作&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;    setHead(node);&lt;br/&gt;    p.next = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 将获取锁失败标识置为false&lt;/span&gt;&lt;br/&gt;    failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;// 获取到锁资源，不会被中断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// p 不是 head 或者 没拿到锁资源，&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;    &lt;span&gt;// 基于 Unsafe 的 park方法，挂起线程&lt;/span&gt;&lt;br/&gt;    parkAndCheckInterrupt())&lt;br/&gt;    interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (failed)&lt;br/&gt;   cancelAcquire(node);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里又出现了一次死循环，首先获取当前节点的前驱节点p，如果p是头节点(头节点没有意义)，说明&lt;code&gt;node&lt;/code&gt;是&lt;code&gt;head&lt;/code&gt;后的第一个节点，此时当前获取锁资源的线程1可能会释放锁，所以线程2可以再次尝试获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设获取成功，证明拿到锁资源了，将&lt;code&gt;node&lt;/code&gt;节点设置为&lt;code&gt;head&lt;/code&gt;节点，并将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;pre&lt;/code&gt;和&lt;code&gt;thread&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。因为拿到锁资源了，&lt;code&gt;node&lt;/code&gt;节点就不需要排队了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将头节点p的&lt;code&gt;next&lt;/code&gt;置为&lt;code&gt;null&lt;/code&gt;，此时p节点就不在队列中存在了，可以帮助&lt;code&gt;GC&lt;/code&gt;回收(可达性分析)。&lt;code&gt;failed&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;，表明获取锁成功；&lt;code&gt;interrupted&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，则线程不会中断。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2p6Th6NW86sGRdwk9gOrjx63bHRhqrwzHOLAjTDVVBZco7qoa44FbKYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1050&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果p不是&lt;code&gt;head&lt;/code&gt;节点或者没有拿到锁资源，会执行下边的代码，因为我们的线程1没有释放锁资源，所以线程2获取锁失败，会继续往下执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//该方法的作用是保证上一个节点的waitStatus状态为-1（为了唤醒后继节点）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;shouldParkAfterFailedAcquire&lt;/span&gt;&lt;span&gt;(Node pred, Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//获取上一个节点的状态,该状态为-1，才会唤醒下一个节点。&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; ws = pred.waitStatus;&lt;br/&gt; &lt;span&gt;// 如果上一个节点的状态是SIGNAL即-1，可以唤醒下一个节点，直接返回true&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws == Node.SIGNAL)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;// 如果上一个节点的状态大于0，说明已经失效了&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// 将node 的节点与 pred 的前一个节点相关联，并将前一个节点赋值给 pred&lt;/span&gt;&lt;br/&gt;   node.prev = pred = pred.prev;&lt;br/&gt;  } &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;); &lt;span&gt;// 一直找到小于等于0的&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 将重新标识好的最近的有效节点的 next 指向当前节点&lt;/span&gt;&lt;br/&gt;  pred.next = node;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 小于等于0，但是不等于-1，将上一个有效节点状态修改为-1&lt;/span&gt;&lt;br/&gt;  compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;只有节点的状态为-1，才会唤醒后一个节点，如果节点状态未设置，默认为0。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图解一下&lt;code&gt;ws&amp;gt;0&lt;/code&gt;的过程，因为&lt;code&gt;ws&amp;gt;0&lt;/code&gt;的节点为失效节点，所以&lt;code&gt;do...while&lt;/code&gt;中会重复向前查找前驱节点，直到找到第一个&lt;code&gt;ws&amp;lt;=0&lt;/code&gt;的节点为止，将&lt;code&gt;node&lt;/code&gt;节点挂到该节点上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.611965811965812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2piaOhg4jjiaUUv4HpfRt8VEo90Qv8aROA6LIeWpdnCWKtUndcSQmEppFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的&lt;code&gt;pred&lt;/code&gt;是头结点且未设置状态，所以状态为0，会走&lt;code&gt;else&lt;/code&gt;。通过&lt;code&gt;CAS&lt;/code&gt;尝试将&lt;code&gt;pred&lt;/code&gt;节点的&lt;code&gt;waitStatus&lt;/code&gt;设置为-1，表明&lt;code&gt;node&lt;/code&gt;节点需要被&lt;code&gt;pred&lt;/code&gt;唤醒。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6170009551098377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pcoxEbW5zPHyqDOE7DPElqmiawJQfrMoFU0MuwAVf6tsRjjP4JgxP34A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1047&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;，继续执行&lt;code&gt;acquireQueued()&lt;/code&gt;中的死循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤和上边一样，&lt;code&gt;node&lt;/code&gt;的前驱节点还是&lt;code&gt;head&lt;/code&gt;，继续尝试获取锁。如果线程1释放了锁，线程2就可以拿到，返回&lt;code&gt;true&lt;/code&gt;；否则继续调用&lt;code&gt;shouldParkAfterFailedAcquire()&lt;/code&gt;，因为上一步已经将前驱结点的&lt;code&gt;ws&lt;/code&gt;设置为-1了，所以直接返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法，通过&lt;code&gt;UNSAFE.park();&lt;/code&gt;方法阻塞当前线程2。等以后执行&lt;code&gt;unpark&lt;/code&gt;方法的时候，如果&lt;code&gt;node&lt;/code&gt;是头节点后的第一个节点，会进入&lt;code&gt;acquireQueued()&lt;/code&gt;方法中走&lt;code&gt;if (p == head &amp;amp;&amp;amp; tryAcquire(arg))&lt;/code&gt;的逻辑获取锁资源并结束死循环。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;查看cancelAcquire()方法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法执行的机率约等于0，为什么这么说呢？因为针对&lt;code&gt;failed&lt;/code&gt;属性，只有&lt;code&gt;JVM&lt;/code&gt;内部出现问题时，才可能出现异常，执行该方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// node 为当前节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;cancelAcquire&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt; node.thread = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;// 上一个节点&lt;/span&gt;&lt;br/&gt; Node pred = node.prev;&lt;br/&gt; &lt;span&gt;// 节点状态大于0，说明节点失效&lt;/span&gt;&lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  node.prev = pred = pred.prev;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 将第一个不是失效节点的后继节点声明出来&lt;/span&gt;&lt;br/&gt; Node predNext = pred.next;&lt;br/&gt; &lt;span&gt;// 节点状态变为失效&lt;/span&gt;&lt;br/&gt; node.waitStatus = Node.CANCELLED;&lt;br/&gt; &lt;span&gt;// node为尾节点，cas设置pred为尾节点&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {&lt;br/&gt;  &lt;span&gt;//cas将pred的next设置为null&lt;/span&gt;&lt;br/&gt;  compareAndSetNext(pred, predNext, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ws;&lt;br/&gt;  &lt;span&gt;// 中间节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 如果上一个节点不是head 节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (pred != head &amp;amp;&amp;amp;&lt;br/&gt;   ((ws = pred.waitStatus) == Node.SIGNAL ||&lt;br/&gt;    &lt;span&gt;// 前边已经判断了大于0的操作，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// pred 是需要唤醒后继节点的，所以当 waitStatus 不为 -1 时，需要将 pred 节点的 waitStatus 设置为 -1 &lt;/span&gt;&lt;br/&gt;    (ws &amp;lt;= &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;&lt;br/&gt;   pred.thread != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;   Node next = node.next;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (next != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; next.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// CAS 尝试将 pred 的 next 指向当前节点的 next&lt;/span&gt;&lt;br/&gt;    compareAndSetNext(pred, predNext, next);&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;// head 节点，唤醒后继节点&lt;/span&gt;&lt;br/&gt;   unparkSuccessor(node);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  node.next = node; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行到&lt;code&gt;while&lt;/code&gt;时找到前驱节点中最近的有效节点，把当前节点&lt;code&gt;node&lt;/code&gt;挂到有效节点后边，可以过滤掉当前节点前的失效节点。声明出有效节点的第一个后继无效节点&lt;code&gt;predNext&lt;/code&gt;，并把当前的&lt;code&gt;node&lt;/code&gt;节点状态设置为失效状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4808219178082192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pcKWLnKoEh33VAmssQQqeRXZHua57kN08fSUP1BObsiabRxVVcLN5vcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;730&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;if&lt;/code&gt;中的操作：如果当前节点是尾节点，&lt;code&gt;CAS&lt;/code&gt;尝试将最近的有效节点设置为尾节点，并将尾节点的&lt;code&gt;next&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3598901098901099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pazKPf17j7RyjZVplaCcv8bOkVqfPBavYiawhshybAMwPgHic4LSu6tiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1092&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;else&lt;/code&gt;中的操作：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;code&gt;pred&lt;/code&gt;节点不是头结点即中间节点，并且&lt;code&gt;pred&lt;/code&gt;的&lt;code&gt;waitStatus&lt;/code&gt;为-1或者&lt;code&gt;waitStatus&amp;lt;=0&lt;/code&gt;，为了让&lt;code&gt;pred&lt;/code&gt;节点能唤醒后继节点，需要设置为-1，并且&lt;code&gt;pred&lt;/code&gt;节点的线程不为空。获取&lt;code&gt;node&lt;/code&gt;节点的后继节点，如果后继节点有效，&lt;code&gt;CAS&lt;/code&gt;尝试将&lt;code&gt;pred&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;指向&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;next&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2698289269051322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2p9kZicgQriauOUbSbf6BUtRYFtTFPedG3CyicjZGIcMegU4R4HmOxjHsicw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当其他节点来找有效节点的时候走当前&lt;code&gt;node&lt;/code&gt;的&lt;code&gt;prev&lt;/code&gt;这条线，而不是再一个一个往前找，可以提高效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是头结点则唤醒后继节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;next&lt;/code&gt;指向自己。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解锁&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;释放锁是不区分公平锁和非公平锁的，释放锁的核心是将&lt;code&gt;state&lt;/code&gt;由大于 0 的数置为 0。废话不多说，直接上代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//释放锁方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; sync.release(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//尝试释放锁资源，如果释放成功，返回true&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;br/&gt;  Node h = head;&lt;br/&gt;  &lt;span&gt;// head 不为空且 head 的 ws 不为0（如果为0，代表后边没有其他线程挂起）&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;// AQS的队列中有 node 在排队，并且线程已经挂起&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;// 需要唤醒被挂起的 Node&lt;/span&gt;&lt;br/&gt;   unparkSuccessor(h);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 代表释放一次没有完全释放&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果释放锁成功，需要获取&lt;code&gt;head&lt;/code&gt;节点。如果头结点不为空且&lt;code&gt;waitStatus&lt;/code&gt;不为0，则证明有&lt;code&gt;node&lt;/code&gt;在排队，执行唤醒挂起其他&lt;code&gt;node&lt;/code&gt;的操作。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;查看tryRelease()方法&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryRelease&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; releases)&lt;/span&gt; &lt;/span&gt;&lt;span&gt;{&lt;br/&gt; &lt;/span&gt;&lt;span&gt;//获取当前锁的状态，先进行减1操作，代表释放一次锁资源&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c = getState() - releases;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;//如果释放锁的线程不是占用锁的线程，直接抛出异常&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.currentThread() != getExclusiveOwnerThread())&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();&lt;br/&gt; &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; free = &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;// 如果 c 为0 ，代表锁完全释放了，如果不为0，代表锁之前重入了，一次没释放掉，等待下次再次执行时，再次判断&lt;/span&gt;&lt;span&gt;&lt;br/&gt; &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (c == &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;// 释放锁标志为 true，代表完全释放了&lt;/span&gt;&lt;span&gt;&lt;br/&gt;  free = &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;  &lt;/span&gt;&lt;span&gt;// 将占用互斥锁的标识置为 null&lt;/span&gt;&lt;span&gt;&lt;br/&gt;  setExclusiveOwnerThread(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;// 设置 state 状态&lt;/span&gt;&lt;span&gt;&lt;br/&gt; setState(c);&lt;br/&gt; &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;&lt;br/&gt;}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的例子中线程1占用锁资源，线程1释放锁之后，&lt;code&gt;state&lt;/code&gt;为0。进入&lt;code&gt;if&lt;/code&gt;操作，将释放标志更新为&lt;code&gt;true&lt;/code&gt;，将&lt;code&gt;FIFO&lt;/code&gt;队列的&lt;code&gt;exclusiveOwnerThread&lt;/code&gt;标志置为&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5366079703429101&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pZYdxaoOTX1y38TicBhpDDgm3P3DsuRiaC7kk7nEAZfSzGUSUwb4G2DVQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;查看unparkSuccessor()方法&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于唤醒&lt;code&gt;AQS&lt;/code&gt;中被挂起的线程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 注意当前的 node 节点是 head 节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unparkSuccessor&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//获取 head 的状态&lt;/span&gt;&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; ws = node.waitStatus;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;// CAS 将 node 的 ws 设置为0，代表当前 node 接下来会舍弃&lt;/span&gt;&lt;br/&gt;  compareAndSetWaitStatus(node, ws, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 获取头节点的下一个节点&lt;/span&gt;&lt;br/&gt; Node s = node.next;&lt;br/&gt; &lt;span&gt;// 如果下一个节点为null 或者 下一个节点为失效节点，需要找到离 head 最近的有效node&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;  s = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// 从尾节点开始往前找不等于null且不是node的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.prev)&lt;br/&gt;   &lt;span&gt;// 如果该节点有效，则将s节点指向t节点&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    s = t;&lt;br/&gt; }&lt;br/&gt;  &lt;span&gt;// 找到最近的node后，直接唤醒&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;  LockSupport.unpark(s.thread);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;问题解析：为什么要从尾结点往前查找呢？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在&lt;code&gt;addWaiter&lt;/code&gt;方法中是先给&lt;code&gt;prev&lt;/code&gt;指针赋值，最后才将上一个节点的&lt;code&gt;next&lt;/code&gt;指针赋值，为了避免防止丢失节点或者跳过节点，必须从后往前找。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们举例中&lt;code&gt;head&lt;/code&gt;节点的状态为&lt;code&gt;-1&lt;/code&gt;，通过&lt;code&gt;CAS&lt;/code&gt;的方式将&lt;code&gt;head&lt;/code&gt;节点的&lt;code&gt;waitStatus&lt;/code&gt;设置为0。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6102514506769826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pOCBpJLJ0sBHiaZWLLibje87Znicia24v9Rl7tZaV6bz9wDMZ4ETBu2BG5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1034&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的头结点的后继节点是线程2所在的节点，不为&lt;code&gt;null&lt;/code&gt;，所以这边会执行&lt;code&gt;unpark&lt;/code&gt;操作，从上边的&lt;code&gt;acquireQueued()&lt;/code&gt;内的&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法继续执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;parkAndCheckInterrupt&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    LockSupport.park(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;//返回目标线程是否中断的布尔值:中断返回true，不中断返回false，且返回后会重置中断状态为未中断&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Thread.interrupted();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为线程2未中断，所以返回&lt;code&gt;false&lt;/code&gt;。继续执行&lt;code&gt;acquireQueued()&lt;/code&gt;中的死循环&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;    &lt;span&gt;// 获取当前节点的上一个节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;    &lt;span&gt;//p为头节点，尝试获取锁操作&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;        setHead(node);&lt;br/&gt;        p.next = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 将获取锁失败标识置为false&lt;/span&gt;&lt;br/&gt;        failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 获取到锁资源，不会被中断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// p 不是 head 或者 没拿到锁资源，&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;        &lt;span&gt;// 基于 Unsafe 的 park方法，挂起线程&lt;/span&gt;&lt;br/&gt;        parkAndCheckInterrupt())&lt;br/&gt;        interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时p是头节点，且能获取锁成功，将&lt;code&gt;exclusiveOwnerThread&lt;/code&gt;设置为线程2，即线程2 获取锁资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将&lt;code&gt;node&lt;/code&gt;节点设置为&lt;code&gt;head&lt;/code&gt;节点，并将&lt;code&gt;node&lt;/code&gt;节点的&lt;code&gt;pre&lt;/code&gt;和&lt;code&gt;thread&lt;/code&gt;设置为&lt;code&gt;null&lt;/code&gt;。因为拿到锁资源了，&lt;code&gt;node&lt;/code&gt;节点就不需要排队了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将头节点p的&lt;code&gt;next&lt;/code&gt;置为&lt;code&gt;null&lt;/code&gt;，此时p节点就不在队列中存在了，可以帮助&lt;code&gt;GC&lt;/code&gt;回收(可达性分析)。&lt;code&gt;failed&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;，表明获取锁成功；&lt;code&gt;interrupted&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;，则线程不会中断。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7521367521367521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2puqyW9XU80hIsibda5MhdvZRnXNsAjXlkpnwDiaP7rUwzxFojHmfmZIDg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;936&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;为什么被唤醒的线程要调用Thread.interrupted()清除中断标记&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上边的方法可以看出，当&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;时，即&lt;code&gt;Thread.interrupted()&lt;/code&gt;方法返回了&lt;code&gt;true&lt;/code&gt;，也就是该线程被中断了。为了让被唤醒的线程继续执行后续获取锁的操作，就需要让中断的线程像没有被中断过一样继续往下执行，所以在返回中断标记的同时要清除中断标记，将其设置为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;清除中断标记之后不代表该线程不需要中断了，所以在&lt;code&gt;parkAndCheckInterrupt()&lt;/code&gt;方法返回&lt;code&gt;true&lt;/code&gt;时，要自己设置一个中断标志&lt;code&gt;interrupted = true&lt;/code&gt;，为的就是当获取到锁资源执行完相关的操作之后进行中断补偿，故而需要执行&lt;code&gt;selfInterrupt()&lt;/code&gt;方法中断线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们加锁解锁的图解过程了。最后我们再来说一下公平锁和非公平锁的区别。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;区别&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边已经说过了，似乎非公平锁包含了公平锁的全部操作。打开公平锁的代码，我们发现&lt;code&gt;accquire()&lt;/code&gt;方法中只有该方法的实现有点区别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8236040609137056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPBhg9teBc79RAt13jsfx2pibtvDzPzQG1odBkib7PrsgC0f8riaJQTQpq7u0vjbfyJncE0MlPB6EBBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hasQueuedPredecessors()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;时才会尝试获取锁资源。该方法代码实现如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasQueuedPredecessors&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Node t = tail; &lt;br/&gt;    Node h = head;&lt;br/&gt;    Node s;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; h != t &amp;amp;&amp;amp;&lt;br/&gt;        ((s = h.next) == &lt;span&gt;null&lt;/span&gt; || s.thread != Thread.currentThread());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;h==t&lt;/code&gt;时，队列为空，表示没人排队，可以获取锁资源；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;队列不为空，头结点有后继节点不为空且s节点获取锁的线程是当前线程也可以获取锁资源，代表锁重入操作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是我们的全部内容了，我们在最后再做个总结：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码使用要合乎规范，避免加锁成功后，在&lt;code&gt;finally&lt;/code&gt;中无法解锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;理解&lt;code&gt;AQS&lt;/code&gt;的&lt;code&gt;FIFO&lt;/code&gt;队列以及&lt;code&gt;Node&lt;/code&gt;的相关属性，尤其注意&lt;code&gt;waitStatus&lt;/code&gt;的状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用图加深对非公平锁源码的理解；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31427bc13e77fa17f0aa374d289eb27a</guid>
<title>我画了 42 张图爆肝 Nacos 源码，跟着看一遍保证大家都学废了</title>
<link>https://toutiao.io/k/6s1twtt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;「 &lt;/strong&gt;关注&lt;/span&gt;&lt;span&gt;&lt;strong&gt;“石杉的架构笔记”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大厂架构经验&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;倾囊相授&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;strong&gt;」&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1J6IbIcPCLbJbVwpE6KkQ3uSdUskKzrUSMYhGU1tKgaSdvUvXOicExwsSQjoiaIxA2av43tbR9mmjlibQaiaeunhOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文章来源：【公众号：&lt;/span&gt;&lt;span&gt;CodeFox&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GHDOauYyUGbiaHXGx1ib5UxkKzSNtpMzY5tbbGdibG7icBSxlH783x1YTF0icAv8MWrmanB4u5qjyKfmYo1dDf7YbA/640?wx_fmt=gif&quot; data-w=&quot;100&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家好，这篇文章跟大家聊下 SpringCloudAlibaba 中的微服务组件 Nacos。&lt;/span&gt;&lt;span&gt;Nacos 既能做注册中心，又能做配置中心，这篇文章主要来聊下做配置中心时 client 端的一些设计，主要从源码层面进行分析，相信看完这篇文章你对 Nacos client 端的工作原理应该有比较深刻的了解。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;SpringCloud 应用启动拉去配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们之前写过一篇文章，介绍了一些 Spring 提供的扩展机制。其中说到了 &lt;strong&gt;ApplicationContextInitializer&lt;/strong&gt;，该扩展是在上下文准备阶段（prepareContext），容器刷新之前做一些初始化工作，比如我们常用的配置中心 client 基本都是继承该初始化器，在容器刷新前将配置从远程拉到本地，然后封装成 PropertySource 放到 Environment 中供使用。&lt;/p&gt;&lt;p&gt;在 SpringCloud 场景下，SpringCloud 规范中提供了 PropertySourceBootstrapConfiguration 继承 ApplicationContextInitializer，另外还提供了个 PropertySourceLocator，二者配合完成配置中心的接入。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.958904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVuS86eYnAKicqZtzgDDsnAJ90H96KMQeWgKibCfKiccFA4mtiafpSjLvhxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;从上述截图可以看出，在 PropertySourceBootstrapConfiguration 这个单例对象初始化的时候会将 Spring 容器中所有的 PropertySourceLocator 实现注入进来。然后在 initialize 方法中循环所有的 PropertySourceLocator 进行配置的获取，从这儿可以看出 SpringCloud 应用是支持我们引入多个配置中心实现的，获取到配置后调用 insertPropertySources 方法将所有的 PropertySource（封装的一个个配置文件）添加到 Spring 的环境变量 environment 中。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33719704952581664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVaKbszAEibpZiciazLAVxah619tjj1UlmOjVbHJErIep50SV4Ro9dz981w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图展示了在 spring-cloud-starter-alibaba-nacos-config 包提供的自动装配类中进行了 NacosPropertySourceLocator 的定义，该类继承自上述说的 PropertySourceLocator，重写了 locate 方法进行配置的读取。&lt;/p&gt;&lt;p&gt;我们来分析下 NacosPropertySourceLocator，locate 方法只提取了主要流程代码，可以看到 Nacos 启动会加载以下三种配置文件，也就是我们在 bootstrap.yml 文件里配置的扩展配置 extension-configs、共享配置 shared-configs 以及应用自己的配置，加载到配置文件后会封装成 NacosPropertySource 返回。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4268867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVzIYX5ytGyibuP7zQib2Yv1kwhet9nt0UUa5gaX2cAd1OicVuDwsUvR57w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; PropertySource&amp;lt;?&amp;gt; locate(Environment env) {&lt;br/&gt;        &lt;span&gt;// 生成 NacosConfigService 实例，后续配置操作都是围绕该类进行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ConfigService&lt;/span&gt; &lt;span&gt;configService&lt;/span&gt; = nacosConfigManager.getConfigService();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == configService) {&lt;br/&gt;            log.warn(&lt;span&gt;&quot;no instance of config service found, can&#x27;t load config from nacos&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; &lt;span&gt;timeout&lt;/span&gt; = nacosConfigProperties.getTimeout();&lt;br/&gt;        &lt;span&gt;// 配置获取（使用 configService）、配置封装、配置缓存等操作&lt;/span&gt;&lt;br/&gt;        nacosPropertySourceBuilder = &lt;span&gt;new&lt;/span&gt; NacosPropertySourceBuilder(configService,&lt;br/&gt;                timeout);&lt;br/&gt;        &lt;span&gt;CompositePropertySource&lt;/span&gt; &lt;span&gt;composite&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; CompositePropertySource(&lt;br/&gt;                NACOS_PROPERTY_SOURCE_NAME);&lt;br/&gt;        loadSharedConfiguration(composite);&lt;br/&gt;        loadExtConfiguration(composite);&lt;br/&gt;        loadApplicationConfiguration(composite, dataIdPrefix, nacosConfigProperties, env);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; composite;&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;loadApplicationConfiguration 加载应用配置时，同时会加载以下三种配置，分别是&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 不带扩展名后缀，application&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 带扩展名后缀，application.yml&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 带环境，带扩展名后缀，application-prod.yml&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;并且从上到下，优先级依次增高&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong/&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6292725679228747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVXylL6RS4yojytPZF0sYWf56q6R0knRgKt9gg8DOTqzPhAWiavqficpqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1141&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;加载的核心方法是 loadNacosDataIfPresent -&amp;gt; loadNacosPropertySource&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3842887473460722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVeqlCiajwStUxYDYO4uhibRQxJBaIFzyibKRhJVbsiaVnxey4QkMQ9AQ2NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;build 方法调用 loadNacosData 获取配置，然后封装成 NacosPropertySource，并且将该对象缓存到 NacosPropertySourceRepository 中，后续会用到。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3415559772296015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVwydUdEl9eOYneJmF0BsFyyK9TwZDriaVxtKbqk8EaqNliak6KmWJaATw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23814773980154355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVd7kMyBuL3JF1CJC5FVLgCcJsLaibGiabgHBFzX88ibYvddwgePohEjq7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;loadNacosData 方法中会将实际配置加载请求委托给 configService 去做，然后解析返回的字符串，解析器实现了 PropertySourceLoader 接口，支持 yml、properties、xml、json 这几种。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7071197411003236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVicprCwNiac2kuD4ytz61PSW7EVzfx7sCXFN3DwhnoEOVURLYO4wfpsWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;getConfig 方法会调用到 getConfigInner 方法，通过 namespace, dataId, group 唯一定位一个配置文件&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 首先获取本地缓存文件的配置内容，如果有直接返回&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 如果步骤 1 从本地没找到相应配置文件，开始从远处拉去，Nacos 2.0 以上版本使用 Grpc 协议进行远程通信，1.0 及以下使用 Http 协议进行远程通信，我们这边以 1.x 为例来解读&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7729166666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVSicD7b2UnlmfbFa53LpZ1eKF1ySTMZTpItpSCWT0XoD21rCKcCYdpgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;getServerConfig 方法会构造最终的 http 请求参数进行调用，如果返回 ok，则将返回内容写入到本地缓存文件中，并进行返回。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8301620859760395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKKJeAmoAgSIL2As8Ziah3fJcfNaOmYHWRq6ibFXAQHUoLqHIHgqic8D1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1419&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;至此，在项目启动的时候（上下文准备阶段）我们就拉到了远程 Nacos 中的配置，并且封装成 NacosPropertySource 放到了 Spring 的环境变量里。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;监听器注册&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;上面章节我们说了服务启动的时候从远程 Nacos 服务端拉到配置，这个章节我们来说下配置变动怎么实时通知到客户端，首先需要注册监听器。&lt;/p&gt;&lt;p&gt;主要看 NacosContextRefresher 类，该类会监听服务启动发布的 ApplicationReadyEvent 事件，然后进行配置监听器的注册。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7611940298507462&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVmzjghRNHyxHgdQsuZEj2AFdg2xGACuCEKR5O0xqqwhqOhQnAemiaMNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;registerNacosListenersForApplications 方法里会进行判断，如果自动刷新机制是开启的，则进行监听器注册。上个章节我们说到了会将拉到的配置缓存到 NacosPropertySourceRepository 中， 这儿就从缓存中获取所有的配置，然后循环进行监听器注册（如果配置文件中配置 refresh 字段为 false，则不注册监听器）。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVBdBd3n0xMjIibG9pQ0WaqQDFnLNz5r4ibhtp7kyl3q2YrkXDBWWN9Bjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们可以看到，监听器是以 dataId + groupId + namespace 为维度进行注册的，监听器的主要操作就三步。&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. REFRESH_COUNT ++，在上述说的 loadNacosPropertySource 方法有用到&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 往 NacosRefreshHistory#records 中添加一条刷新记录&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. 发布一个 RefreshEvent 事件，该事件是 SpringCloud 提供的，主要就是用来做环境变更刷新用的&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6911447084233261&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVS2Cd6O1uNwbgNEKNibVCRKECicv68udbZDJicicH9ex3qb94ickib3uc0Nxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注册操作经过 ConfigService，在 ClientWorker 中处理，这块会创建一个 CacheData 对象，该对象主要就是用来管理监听器的，也是非常重要的一个类。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38177874186550975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVoh5Clbho2nVIml1JSq4k5PEQoFx7RSNnaQDomycUQEtrguuFwADhpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;CacheData 中字段如下图，ManagerListenerWrap 对 Listener 做层包装，内部会保存 listener、上次变更的 content 以及 md5（用来判断配置有没有变更用）。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4104401228249744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVTWIKnArwgWD218PA9bKKribJeX2eISdf4tDCJ5gCD2gbmMwJqTjpzKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7438650306748467&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVNa9BTxbkGTGibRahfpVvM3XT1xGHxDicrAnCmEQPotP99HVQMvb4QK8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;并且在 addCacheDataIfAbsent 方法中会将刚才创建的 CacheData 缓存到 ClientWorker 中的一个 Map 中，后续会用到。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2682926829268293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVwOXpvrluN1scqm8jzNOU7ibVnZfSRZBPLDUNJK2cERvrAgsOPrrCwvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，在服务启动后向每一个需要支持热更新的配置都注册了一个监听器，用来监听远程配置的变动，以及做相应的处理&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;配置热更新&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面章节我们讲了服务启动的时候从远程 Nacos 服务端拉到配置，以及服务启动后对需要支持热更新的配置都注册了一个监听器，这个章节我们来说下配置变动后具体是怎么处理的。&lt;/p&gt;&lt;p&gt;回到上述说过的 NacosPropertySourceLocator 的 locate 方法看看，该方法首先会获取一个 ConfigService。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39567430025445294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVeSlYBnicAicNeGG6bec1QCdbcpoMHa6iblZh5EpTYvILuzXarVLbgccjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;NacosConfigManager 中会进行一个 ConfigService 单例对象的创建，创建流程最终会委托给 ConfigFactory，使用反射方式创建一个 NacosConfigService 的实例对象，NacosConfigService 是一个很核心的类，配置的获取，监听器的注册都需要经此。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48662041625371655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVgOZlsPn1xsSSBajl9AEGwKll4Sl72uiasBL6QflEYT3DFLc251EaiaeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1009&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们看下 NacosConfigService 的构造函数，会去创建一个 ClientWorker 类的对象，这个类是实现配置热更新的核心类。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42528735632183906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVp5VPaDsOa3sOGgemKdvVZOY6eYKZLPHFI6SrvQ8ClgGdAUMb1mf0JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;870&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ClientWorker 的构造函数里会去创建两个线程池，executor 会每隔 10ms 进行一次配置变更的检查，executorService 主要是用来处理长轮询请求的。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.920314253647587&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVibeJNGcMErvlRfc1fOwKc2u4ClSs4PzO2S7a1o4YmWYickpHaqztiaPxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;891&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;checkConfigInfo 方法中会创建一个长轮询任务丢到 executorService 线程池中去处理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47085201793721976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVMTB3amtvl9FfHE9USIsVHZoqibVDGO3D7df1S0KerBeRTMgNfmK2mUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;LongPollingRunnable 的 run 方法代码有点多，主要流程如下：&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 获取上个章节中说到的缓存 cacheMap，然后遍历，判断如果该配置使用的是本地缓存模式，则调用 checkListenerMd5 去检查读到的本地缓存文件中内容的 Md5 跟上次更新的 Md5 是不是一样，不一样则调用 safeNotifyListener 去通知监听器处理，并且更新 listenerWrap 中的 content、Md5&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6317241379310344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVkaFjZ3jbVcVYcX6hMk351OnsDicG1nwALDRHDQBxkOX9O6hzrDog3pA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. checkUpdateDataIds 该方法中，会将所有的 dataId 按定义格式拼接出一个字符串，构造一个长轮询请求，发给服务端，Long-Pulling-Timeout 超时时间默认 30s，如果服务端没有配置变更，则会保持该请求直到超时，有配置变更则直接返回有变更的 dataId 列表。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6905286343612335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVPPPFDqb9micuqKfJrlTOH4kjFHdh7sGrBq86AXkMicq0AJrDPy5VXU6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1. 拿到第二步有变更的 dataId 后会调用 getServerConfig 获取最新的配置内容，然后遍历调用 checkListenerMd5 去检查最新拉取的配置内容的 Md5 跟上次更新的 Md5 是不是一样，不一样则调用 safeNotifyListener 去通知监听器处理，并且更新 listenerWrap 中的 content、Md5&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6696629213483146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVRdlm9Dnvp773YA1QMAuiblKsIwwiaewzBfcndAMuM83bGTVGBNZcVcqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;checkListenerMd5 方法如下，主要就是判断两个 md5 是不是相同，不同则调用 safeNotifyListener 处理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25949367088607594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVn9T4H91icaLfNqPUhcLOQBzj96QzlS6RiaE327ibko4XupfNLMbI8cuJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;790&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;safeNotifyListener 方法主要就是调用监听器的 receiveConfigInfo 方法，然后更新监听器包装器中的 lastContent、lastCallMd5 字段。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8957894736842106&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVjkO92az6NEOUmQ87X7aaw5PKvpWkI9OOSia6NiblQQlJ0d3oMUmoibR9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;950&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;监听器要执行的方法我们上面也已经讲过了，这边再贴下截图，主要就是发布 RefreshEvent 事件。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6380434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVr0pno3XVRcDu1F8ZTdUDlIw6ZRTyazQMaC6QF8LOAseel0qHcfpGVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，Nacos 的处理流程已经结束了，RefreshEvent 事件主要由 SpringCloud 相关类来处理。&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;RefreshEvent 事件处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;RefreshEvent 事件会由 RefreshEventListener 来处理，该 listener 含有一个 ContextRefresher 的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7460484720758693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKg2khnphUeBgNpUVpHP0tuUAsfleRb2J6RVp2DA7HfpAtqPXoEg2Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;949&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如下图所示，refreshEnvironment 会去刷新 Spring 环境变量，实际上是交给 updateEnvironment 方法去做的刷新，具体刷新思想就是重新创建一个 Spring 容器，然后将这个新容器中的环境信息设置到原有的 Spring 环境中。拿到所有变化的配置项后，发布一个环境变化的 EnvironmentChangeEvent 事件。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4802494802494803&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVUZiaEC1oggzA1sv3pBOkjcTibMPOrPe7YzV6hWAtyQlHmA8NXA5dwPZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7754459601259182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVjfETff9ibicvpK3iaJMG2dWpMeRUxuq8CkpdJhxNicZz4eDmlHp2KCV7Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;953&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;ConfigurationPropertiesRebinder 会监听 EnvironmentChangeEvent 事件，监听到事件后会对所有的标注有 ConfigurationProperties 注解的配置类进行销毁后重新初始化的操作，完之后我们的配置类中的属性就是最新的了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7336065573770492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVFZw8giagr5T8iarLOw92hL60QNia6CSTtXNt2X9icia1ov5K77Ie9F1U3jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7626774847870182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxV4x5anmTb6Vyh6uic9XPAA8SHllicQNiatczEmORk2pPoK61rfa13EOJ6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里我们说到了会对标有 ConfigurationProperties 注解的配置类进行 rebind，那对于普通组件类里标有 @Value 注解的属性要怎么生效呢？这个其实需要配合 @RefreshScope 注解来生效的。&lt;/p&gt;&lt;p&gt;我们继续回到上述的 refresh() 方法，接着会有一步 refreshAll 的操作，会调用父类的 destroy 方法。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2900763358778626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVKwxBZ9QN6mzg4FGHH2YC1veLjruuiaksibaAn044GtNv1ketbS1n1Cww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23439667128987518&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVccwok8o41licleZ9NdV40SOag0WmxXp5GAJNP93pMz7XuPCRoCT1O6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;父类就是 GenericScope，我们知道 Spring 中的 Bean 是有Scope 的概念的，Spring 默认 Scope 有单例和原型两种，同时提供了 Scope 扩展接口，通过实现该接口我们可以定义自己的 Scope。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6775631500742942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVzORrlJJhmW1tibwvEAKPTlNufjfdfDW7iaHsLzEALFvbVrjK4q2ZGQxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;通过doGetBean 方法可以看出，这些自定义 Scope 类型对象的管理会交给相应的 Scope 实现去管理。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8311068702290076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVyBluk9ib0CAjvRfiaKf1iaAaMZGBhQYK0RyL4skIYLpSsBSehhtfcsDgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;SpringCloud 实现的 RefreshScope 就是用来在运行时动态刷新 Bean 用的，RefreshScope 继承 GenericScope，提供 get 和 destroy 方法。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28955866523143164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVp7cksicbpGC2qPEZmQ8ScOTh3M3bc6hxV3bKNYpGesb7HgvMopjDQoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;GenericScope 内部有一个 cache，用来保存所有该 Scope 类型的对象。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2790202342917998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxV2EKoEP5NVZLs3oJ5uXj7gkzunlYibcBOY9uvPNtbra5IbDTxULZ7fgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;939&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;回到主线，所以在 refreshAll 中调用 super.destroy 方法时会将该 scope 的这些 Bean 都销毁掉，在下次 get 的时候在重新创建 Bean，新创建的 Bean 就有了我们最新的配置。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9163591635916359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVARRkPUsGAVaF5K6Y0KMzLfSCmwuB0OwTnoH0cJd6lEajRh6gaaKhzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.310752688172043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/MT0dU22BS4ndD8zxwAP34SlX2j2upiaxVrE8Jv1yd5AErQvaYVkcvicX6ia0vqy1Ok6Ss8dFDYemcyygagqNpMMWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;至此，我们就实现了配置热更新的效果了。&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;h2&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;文章从服务启动时的配置拉取，服务启动后的配置监听器注册，以及配置变动后的热更新实现三个方面从源码层面解析了整个的原理，希望对大家有所帮助。&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;336&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;160&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>516a33a2e6a5d63b3f6ed3e15fbe9677</guid>
<title>独立开发变现周刊（第 80 期）：Notion 页面转成网站客服小部件，月收入 5K 美金</title>
<link>https://toutiao.io/k/72jynd0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;strong&gt;分享独立开发、产品变现相关内容，每周五发布。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;(合集：https://ezindie.com/weekly )&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;1、algorithm-visualizer: 可视化算法交互式在线平台&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;2、liKeYun_Huoma: 这是一套开源、免费、可上线运营的活码系统。&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;3、ntfy: 开源的基于http的发布-订阅通知服务&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;4、可逆打码工具&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;5、闪击PPT: 让PPT更高效地分享&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;6、将Notion页面转化成客服小部件工具，月收入5K美金&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1、algorithm-visualizer: 可视化算法交互式在线平台&lt;/h2&gt;&lt;p&gt;通过可视化方式，学习算法变得容易得多。这是一个开源项目，Github上有40K的Star。有在线网站可以学习常用的算法，可视化的效果，右侧是实际的算法代码。对于理解算法非常有帮助。有对算法不熟悉的同学建议实际体验下，感受下算法之美。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtZ5YLzgOBjXA0V9Sr0HhOoHquFN6DibCofdqsJxtAyPFII2Xf3q0Tw4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;p&gt;交互式算法平台&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;2、liKeYun_Huoma: 这是一套开源、免费、可上线运营的活码系统。&lt;/h2&gt;&lt;p&gt;使用场景是，微信官方群二维码有效期是7天，7天后二维码过期无法扫码进群，或者是群人数满200人就无法扫码进群。如果我们在推广的时候，群满人或者过期了，别人还想进群，我们将会失去很多推广效果，所以有了群活码，可以在不更换链接和二维码的前提下，达到持续扫码进群的效果。&lt;/p&gt;&lt;p&gt;前端框架：自写UI + Bootstrap+jQuery&lt;/p&gt;&lt;p&gt;后端框架：php+mySql&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6567567567567567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtgzw53dg8n3f8levGkiaibjN2vEsIeyRNtTF8LsMWpzfZMXGXH6GfAaXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6567567567567567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtG5qMhvo2sTvszwD3a4VWj8Hicia2wkEjTIqvrndt5DaIbftQMUbo2zicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;&lt;p&gt;群活码开源地址&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;3、ntfy: 开源的基于http的发布-订阅通知服务&lt;/h2&gt;&lt;p&gt;ntfy是一个简单的基于http的发布-订阅通知服务。它允许你从任何一台电脑通过脚本发送通知到你的手机或桌面，完全不需要注册或付费。如果您想运行自己的程序，它也是开源的。&lt;/p&gt;&lt;p&gt;在ntfy.sh上运行了一个免费版本。还有一个开源的Android应用程序(见谷歌Play或F-Droid)和一个开源的iOS应用程序(见app Store)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6877040261153428&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLttILk1wyzFaLbQDZIZ0byQGpNrTDicI91PZlImmcicKeWCw8I4asupL1w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;919&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6763925729442971&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtp41wXVyMOwJnsCpxaTlNz3KocJicPeXZKKegXqOavbTwtoZJ6fMAzOg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1131&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42685185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtG8kH6g7g7zd6pgtw1dA393LZQjxUrWCPURhbiaXAqCUbbVrO3ibnfmUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;ntfy开源项目地址&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;4、可逆打码工具&lt;/h2&gt;&lt;p&gt;我们经常遇到打马赛克的图片，其实反向思考下，基于这个场景还可以实现一种有意思的工具。&lt;/p&gt;&lt;p&gt;可逆打码，对照片的某个部分打上马赛克，并且设置一个密码。对方可以用软件打开这张带有马赛克的照片，输入正确的密码，点击解码，就能恢复原图。&lt;/p&gt;&lt;p&gt;在将包含隐私的照片传递给对方时，通常会对照片进行打码处理，但通常方法添加的马赛克破坏了照片的像素数据，难以准确恢复。&lt;/p&gt;&lt;p&gt;采用本软件对照片进行打码后，只需提供正确的密码，即可无损对打码区域进行解码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3747300215982721&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtTfCll8LZsBU4ROdsdcwr3zR4MfMJsSoT57HbRiabdiceOHpPmM4NO6Rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;926&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7253176930596286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtfLzzuiaqT1EXPXk8ckcUBRDpBn8grsZntJrfiabm61RJdTou8o1WC0TA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;p&gt;可逆打码介绍&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;5、闪击PPT: 让PPT更高效地分享&lt;/h2&gt;&lt;p&gt;闪击PPT可以在线轻松制作PPT，不用在设计上花太多时间也能制作精美的PPT效果。同时在线制作的PPT也更容易分享给别人查看。这个产品刚开始公测，是副业群里小伙伴的作品，在此推荐给大家想体验尝鲜。&lt;/p&gt;&lt;p&gt;产品特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;不让用户做设计&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;辅助用户进行出文字稿创作&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;让PPT像网络文章一样分享、沉淀&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;辅助用户演讲&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;适用人群和场景：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5335968379446641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtkLWQUicEZoEEuBBetM1X8Uj4icU17BhJgSGhhNq950fBrhkwicZqdSQSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2024&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过预置的模板可以快速开始，还有一些漂亮的模板图片、图表等。能实时预览效果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5335968379446641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtg01XJEedy7XyQvpSdTdicRSYoPxfqT2OqPRMmVuMk6f3oWNCe9ry2xw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2024&quot;/&gt;&lt;/p&gt;&lt;p&gt;闪击PPT在线体验&lt;sup&gt;[5]&lt;/sup&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;6、将Notion页面转化成客服小部件工具，月收入5K美金&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39871794871794874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtz2FicJ9ib8sYQNr9TjYcSQQrmFsPoWwcmzgra8ktOOW58QheEAsXrkXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1560&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家好!我叫Sobe，是多个自主开发且盈利产品的独立创始人，这些产品都在我的公司七度实验室(Seven Degrees Labs)下运行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5223529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtic5ymbMkPibEb1ggQNq5820yXpg1dQR7ibfMkEdxCKPYMHWic2pWnCZ0MQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;我现在花了大部分时间研究的最成功的产品叫做HelpKit，它把Notion Page变成了一个专业的知识库。HelpKit是在尽可能短的时间内创建知识库、帮助中心或文档页面的完美工具。它由内容管理系统提供动力:Notion。你可以在Notion中编写帮助文章，而HelpKit将负责其余的工作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4548872180451128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtCickaFHUHKYDJRQRm6hf83Z2ia2Ps4eERnjqibtKgQsWv9pIGVzr3K3zw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2128&quot;/&gt;&lt;/p&gt;&lt;p&gt;你还可以在你的网站上嵌入一个小部件，以在网站上提供嵌入的客户支持。HelpKit也是完全可定制的，有分析和第三方集成，并优化了SEO，使搜索引擎很容易找到你的网站。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49113233287858116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtFMQcvDSkYhYPYWTuWaI1KiaX7BStFcdZu7TZNic4X6KibSVkXTkyd8sPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2199&quot;/&gt;&lt;/p&gt;&lt;p&gt;当我最初创建HelpKit时，我的目标是将其发展到大约3K美元的月收入，这将让我能够全职从事独立开发。HelpKit现在是5K美金，超过了这个目标2000美元，所以我非常感激能够创建一家有价值的小公司，同时能够随时随地工作。&lt;/p&gt;&lt;h3&gt;你是怎么想到这个想法的?&lt;/h3&gt;&lt;p&gt;在创建HelpKit之前，我正在开发一些移动应用程序和另一个SaaS产品。每当我开发一个新产品时，我发现自己需要一个服务台工具，因为我知道，作为一个独立创始人，处理客户支持可能会成为一项巨大的时间投资。此外，客户喜欢立即得到他们的问题的答案，而不必等待几个小时或几天的响应。&lt;/p&gt;&lt;p&gt;与此同时，我意识到我已经在Notion中记录了我的整个业务。你知道吗?我突然意识到，我是否可以在Notion中编写我的帮助文章(这是我喜欢的!)，然后将它们公开到一个看起来像适当的专业知识库的网站上，以便我可以轻松地定制并与客户分享?&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5381165919282511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLt0fbHop0xhhxSfYwaQuyFaUibMDUpex2mhQjV7J9gLy5RD0L4KicdCXug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2007&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然，我可以发布一个独立的Notion页面，但由于多种原因，比如Notion URL、分散品牌链接和缺乏可定制性，这可能会让客户觉得不专业。此外，它应该感觉类似于Intercom或Zendesk等工具。由于我找不到正确的FAQ软件解决方案，我创建了HelpKit。&lt;/p&gt;&lt;h3&gt;介绍下第一个产品的设计、原型和制造过程&lt;/h3&gt;&lt;p&gt;“令人惊讶的是，仅仅通过公开分享的过程，就为你的SaaS获得了第一批客户。没有付费广告，没有疯狂的成长技巧，只是真诚地分享你创建的故事。”&lt;/p&gt;&lt;p&gt;我并没有立即将这个想法付诸行动，因为我从之前失败的项目中学到，每个想法在一开始都让人觉得光鲜亮丽，但最终可能并不是最好的选择。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtIAEU7dQTmKJMibYy44r7cz6B8tb3TIjlEka9MlAwTGiaIGBL10hNOfLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;我的想法是把这个想法在我的脑子里再留一两个月，如果我仍然认为这个想法值得追求，我就会尝试一下。两个月过去了，我一直在想这个问题。如果把所有的客户支持都写在Notion中，而大部分业务文档都保存在这里，那该有多好?此外，员工可以轻松进入并帮助编写内容，而不需要学习另一个编辑器和软件工具。这似乎是一种增值。&lt;/p&gt;&lt;p&gt;所以我决定试一试，但并没有真正做这个产品。我想在制作之前验证这个想法。我使用Figma，创建了一些产品外观的模型，然后快速创建了一个登录页面，其中包含以折扣价预订一年HelpKit的选项，以测试是否有人有兴趣使用Notion建立帮助中心并购买它。&lt;/p&gt;&lt;p&gt;2021年7月，我在推特上向我的300名粉丝发布了这个页面。考虑到我当时的粉丝数很低，我并没有抱太大期望，但幸运的是，Notion社区的成员开始感兴趣，并在一夜之间获得了100名粉丝。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtItNRWTtIOnc3blI1pcjib07paHhyMDQ2v14T2OiaNRQwXhXGC7Z0HhIw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;我向自己承诺，如果我得到10个预购订单，我就制作这个产品。但整个星期都没有人预定。我不断发布和分享更新，最后在接下来的一周我收到了前两份预订订单。又一个星期过去了，但不幸的是没有新的预订。&lt;/p&gt;&lt;p&gt;我开始有点怀疑，但后来有一天，我看到了这封惊人的邮件，发件人注意到了HelpKit并喜欢它。邮件很长。我花了十多分钟来阅读它，有这么多的建议和支持。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLteTlj3sTPHBdmhuyR1X5rgeK6S8StT1lqGrMIUPXaRpb2lib7PgmXB2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;尽管我没有达到预定10份的目标，但单是这封邮件的价值就超过了这个数字。这是一个我不认识的人，他相信HelpKit有很大的潜力。所以，我决定全力以赴，在30天内打造出第一个MVP。&lt;/p&gt;&lt;h3&gt;描述启动业务的过程&lt;/h3&gt;&lt;p&gt;在正式发布HelpKit的时候，我已经开始了公开构建分享，分享了几十条推特记录我构建MVP的过程，并完全透明地公布了所有关于HelpKit的数据。&lt;/p&gt;&lt;p&gt;当我在Twitter上宣布第一个完全运行的MVP和改进的登陆页面时，这对我帮助很大。正如你所看到的，发布推文非常成功，最终吸引了首批注册用户。令人惊讶的是，仅仅通过公开分享构建的过程，就获得了第一批客户。没有付费广告，没有疯狂的成长技巧，只是真诚地分享你创建过程的故事。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtOprR93fic19tmibDr7VC85fayNmsDBAYeU6nmXIqOAsTnzqR8dEViavPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h3&gt;是什么有效地吸引和留住了客户?&lt;/h3&gt;&lt;p&gt;HelpKit的营销策略在不断发展，我也在尝试最好的增长策略。在早期，有两种截然不同的策略对我非常有效。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4699738903394256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtOPlWXy6y3Xs2Lp5nYS2B6anYB4kfCuExKlsnIR9sFYGpwI0ibWrxWqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2298&quot;/&gt;&lt;/p&gt;&lt;p&gt;第一个是在Reddit和Indiehackers等平台上分享我公开构建的故事。我在IndieHackers发布的两篇文章进入了网站首页的Top milestone通讯和Top Stories版块。&lt;/p&gt;&lt;p&gt;第二个是我所说的“工程即营销”。这个想法很简单;为目标用户创建免费的有用工具。直到两个月前，Notion还没有一个简单的图表块。你可以创建复杂的数据库，但不能拥有内容的简单表视图。我发现了一个方法，可以使用数学方程和LaTeX符号来创建外观漂亮的简单表。&lt;/p&gt;&lt;p&gt;从头开始创建LaTeX代码是一项非常繁琐和无聊的任务，因此我决定构建一个简单而自由的表生成器，以便Notion用户可以轻松地生成他们的表，而不必纠结于复杂的LaTeX符号。在Notion社区中，还没有一个简单的图表能解决这个众所周知的问题，有无数的Reddit、Twitter和Facebook帖子要求这样做。我把它称为Notion Simple Table，这样我就可以从别人的SEO里收益，因为已经在那里，也正是人们正在搜索的关键字。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtctJ2BnLzwoTPPMXd6jxytiaGx9icLXx2ZL45Xj5JQ6bKicSK8O2m0pczw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了Twitter上的观众，我还制作了一个简短的解释视频，并去寻找Notion社区的用户。我给这篇文章起了个名字:“如何在Notion中创建一个简单的表”，然后社区就开始喜欢它了。为人们提供他们真正想要的工具是一种很棒的感觉。你不会相信我收到过多少“你是上帝派来的”的评论。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtmcQ1GLGH4kBTicG9xHqHPBxvk72ZicBdOZ0yHtIXqPE0c4POxJnIr8mQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtmcQ1GLGH4kBTicG9xHqHPBxvk72ZicBdOZ0yHtIXqPE0c4POxJnIr8mQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;“选择一个正在成长的利基市场的产品创意，利用这个利基市场的自然增长来发展你的产品。”&lt;/p&gt;&lt;p&gt;此外，HelpKit的另一个增长因素是支持两种不同的布局。除了有各种各样用例的帮助中心布局之外，文档页面布局是专门为那些希望创建更多文档站点的公司设计的，比如知识库，如软件文档或API文档站点。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtxnWhM36SWUN5BUGfXvjF0alFdU7cL20EXwBnj3CNtmvqVQcQWq8qJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h3&gt;你的未来的计划是什么样的?&lt;/h3&gt;&lt;p&gt;现在我完全享受着流浪的生活方式。我现在住在印度尼西亚的巴厘岛，我身边有一个很棒的独立黑客社区。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtbto0CGCI09EFnIKfgd0pLQ0PzVyMQ51iayJ0S8uY6Q0E0b8XViah4ibibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;HelpKit目前正在为150多家使用Notion构建知识库的公司提供服务。从下图中你可以看到，用户似乎很喜欢HelpKit，甚至我最喜欢的youtuber Thomas Frank也是个很开心的用户。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtn4KA87lkQp0njgpVTXCaYzyYmoQBGYbOoKjKZQht3rOGYFbmWY0rpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;h3&gt;通过创业，你学到了什么特别有用或有益的东西吗?&lt;/h3&gt;&lt;p&gt;去年，当我在里斯本河上乘船旅行时，我遇到了一位独立黑客，他告诉我在增长的利基市场上做东西与在衰退或停滞的利基市场上做东西的概念。他的观点是，创建一个成功的产品并不一定是非常困难的，许多独立黑客都是搬起石头砸自己的脚，在一个自然很难营销的类别中开发产品。&lt;/p&gt;&lt;p&gt;这短短的10分钟的演讲彻底改变了我对寻找商业创意和开发产品的看法。他的意思是，你应该选择一个正在成长的利基市场的产品创意，并利用这个利基市场的有机增长来发展你的产品。想象一下，就像你在航行，风对你有利，把你推向目标，而不是远离目标。我认为，对于创始人来说，在现有生态系统的基础上开始创建一个成功的业务是一个很好的开始，是值得冒潜在风险的。&lt;/p&gt;&lt;p&gt;试着亲自去了解最初的几个客户，让他们喜欢上你的产品。这将极大地帮助你获得更好、更诚实的反馈。与此同时，它也会让你的客户更能原谅你，如果你碰巧在一开始犯了一些错误。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5623529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtoxNajNs6ssVlfchHZUyPEAfnAEBKwwAcibBkIapVTqVibB42JGZDRyxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;p&gt;我必须承认，HelpKit的发展有时感觉有点慢。然而，回想起来，在一开始，缓慢的增长可以让你完善产品，填补缺失的部分或解决早期客户的小问题。毕竟，比起风投支持的初创公司，这就是独立黑客的最大优势，不是吗?我们可以让我们的产品增长得慢一些，在这个过程中改进它们，并从稳步增长的客户群中一步一步地学习。&lt;/p&gt;&lt;h3&gt;对其他想要起步或刚刚起步的创业者有什么建议?&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40253565768621236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtVcdIbv8mUiciaNcRnW42Pa4C8frfNlpvfSQJugvdznx2QeXEOvbMI5fw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1262&quot;/&gt;&lt;/p&gt;&lt;p&gt;在早期，我接触过许多大公司，他们向我寻求目前还没有可用的功能。每当有这样的请求时，我都会试着和他们打个简短的电话，谈谈他们的痛点。虽然你一开始会认为这些请求的功能对他们来说是一个亮点，但大多数情况下不是这样的。在了解你和你的未来计划之后，他们会很乐意注册的。&lt;/p&gt;&lt;p&gt;“花太多时间在那些难获取的用户身上，是不值得的。你应该寻找那些有你想要解决的问题的客户。不要把目标锁定在那些太辛苦、不想花钱、对与初创公司合作不感兴趣的早期客户上，他们其实没有问题，只是觉得自己将来可能会遇到问题。”&lt;/p&gt;&lt;p&gt;彼得·莱斯说他建造的95%的东西都失败了。成为一名独立黑客是一场数字游戏。你做得越多，你就做得越好，你就会获得更多的技能。&lt;/p&gt;&lt;p&gt;你需要一个规律，并长时间坚持下去。制定你的例行公事，承认一些暂时的牺牲并坚持下去，我相信你会成功的。最后，把去健身房当成你的工作。作为一名创始人，要求很高 —— 身体上和精神上都是如此。我怎么强调运动如何帮助我保持健康的平衡都不为过。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;”你应该选择一个正在成长的利基市场的产品创意，并利用这个利基市场的增长来发展你的产品。想象一下，就像你在航行，风对你有利，把你推向目标，而不是远离目标。&lt;/strong&gt;&lt;/span&gt;“&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;交互式算法平台: https://github.com/algorithm-visualizer/algorithm-visualizer&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;群活码开源地址: https://github.com/likeyun/liKeYun_Huoma&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ntfy开源项目地址: https://github.com/binwiederhier/ntfy&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可逆打码介绍: https://lzn1007.wordpress.com/cn/%e5%8f%af%e9%80%86%e6%89%93%e7%a0%81/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;闪击PPT在线体验: https://ppt.sankki.com/editor?mode=demo&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649284690&amp;amp;idx=1&amp;amp;sn=dfc6a01d89714f82a55f8911f7a2ac36&amp;amp;chksm=bf2021538857a84509a26fa495a22283f9bf29c3c4e70c8db1be3b937992f16f1604527be4e0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;独立开发变现周刊（第79期）：一个产品页面流灵感网站，每月4.5K美元&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第79期）：一个产品页面流灵感网站，每月4.5K美元&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649284655&amp;amp;idx=1&amp;amp;sn=2ff6974b281a46092b68323e9c88ccc4&amp;amp;chksm=bf20212e8857a838bcf1afa5328e6b561037d6cef86d1e0dae636a128163de71c2274e4910c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;独立开发变现周刊（第78期）：建立一个佣金网站，每月赚4万美元&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第78期）：建立一个佣金网站，每月赚4万美元&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4010582010582011&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/G4umk62oPLqxplJYrINXumqtVdQcxYLtztgN2kZoYgTAbQCTEAkKmiaHicw4eTppCJfz4CibHYl3DTPlE2GmSXpxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;加入知识星球，和我一起做自己产品的独立变现，内有独家资料&lt;/span&gt;&lt;br/&gt;&lt;span&gt;星球内分享最新个人实战思考和经验&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee0e5ef8336bc1ddc8642839df3816d2</guid>
<title>万字图文讲透数据库缓存一致性问题</title>
<link>https://toutiao.io/k/1exlsmh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;span&gt;点个关注👆跟腾讯工程师学技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10084033613445378&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe94NkoG8ic4cxAHXIAeNJugn2C3ibibg0zRygM6XpWUCFCS2jFyBK9J6WPBv8hzQFpnNHoneSEGMe8mqQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; data-w=&quot;1071&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10899182561307902&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDWibXoicOmWRPWDtKd4KicjNbOybYFjuxwAMrXNWs2cE6DjLKhzDwE48IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1468&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;导语|&lt;/span&gt; &lt;/span&gt;&lt;span&gt;缓存合理使用确提升了系统的吞吐量和稳定性，然而这是有代价的。这个代价便是缓存和数据库的一致性带来了挑战，本文将针对最常见的cache-aside策略下如何维护缓存一致性彻底讲透。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;但&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;客观上，我们的业务规模&lt;/span&gt;&lt;span&gt;很可能要求着更高的 QPS，有些业务的规模本身就非常大，也有些业务会遇到一些流量高峰，比如电商会遇到大促的情况。&lt;/span&gt;&lt;/section&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而这时候大部分的流量实际上都是读请求，而且大部分数据也是没有那么多变化的，如热门商品信息、微博的内容等常见数据就是如此。此时，缓存就是我们应对此类场景的利器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08148148148148149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;缓存的意义&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所谓缓存，实际上就是用空间换时间，准确地说是用更高速的空间来换时间，从而整体上提升读的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;何为更高速的空间呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更快的存储介质。通常情况下，如果说数据库的速度慢，就得用更快的存储组件去替代它，目前最常见的就是Redis（内存存储）。Redis 单实例的读 QPS 可以高达 10w/s，90% 的场景下只需要正确使用 Redis 就能应对。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就近使用本地内存。就像 CPU 也有高速缓存一样，缓存也可以分为一级缓存、二级缓存。即便 Redis 本身性能已经足够高了，但访问一次 Redis 毕竟也需要一次网络 IO，而使用本地内存无疑有更快的速度。不过单机的内存是十分有限的，所以这种一级缓存只能存储非常少量的数据，通常是最热点的那些 key 对应的数据。这就相当于额外消耗宝贵的服务内存去换取高速的读取性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08148148148148149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;引入缓存后的一致性挑战&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用空间换时间，意味着数据同时存在于多个空间。最常见的场景就是数据同时存在于 Redis 与 MySQL 上（为了问题的普适性，后面举例中若没有特别说明，缓存均指 Redis 缓存）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，最权威最全的数据还是在 MySQL 里的。而万一 Redis数据没有得到及时的更新（例如数据库更新了没更新到Redis），就出现了数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大部分情况下，只要使用了缓存，就必然会有不一致的情况出现，只是说这个不一致的时间窗口是否能做到足够的小。有些不合理的设计可能会导致数据持续不一致，这是我们需要改善设计去避免的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的一致性实际上对于本地缓存也是同理的，例如数据库更新后没有及时更新本地缓存，也是有一致性问题的，下文统一以Redis缓存作为引子讲述，实际上处理本地缓存原理基本一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（一）缓存不一致性无法客观地完全消灭&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为什么我们几乎没办法做到缓存和数据库之间的强一致呢？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理想情况下，我们需要在数据库更新完后把对应的最新数据同步到缓存中，以便在读请求的时候能读到新的数据而不是旧的数据（脏数据）。但是很可惜，由于数据库和 Redis 之间是没有事务保证的，所以我们无法确保写入数据库成功后，写入 Redis 也是一定成功的；即便 Redis 写入能成功，在数据库写入成功后到 Redis 写入成功前的这段时间里，Redis 数据也肯定是和 MySQL 不一致的。如下两图所示：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7667844522968198&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDjuald3fWYEiaCKDZ84tTkAYBaG4SLicEcYuFT4O75icGgZSxuQjGVA7Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无法事务保持一致&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说这个时间窗口是没办法完全消灭的，除非我们付出极大的代价，使用分布式事务等各种手段去维持强一致，但是这样会使得系统的整体性能大幅度下降，甚至比不用缓存还慢，这样不就与我们使用缓存的目标背道而驰了吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;不过虽然无法做到强一致，但是我们能做到的是缓存与数据库达到最终一致，而且不一致的时间窗口我们能做到尽可能短，按照经验来说，如果能将时间优化到 1ms 之内，这个一致性问题带来的影响我们就可以忽略不计。&lt;/span&gt;&lt;/section&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35962145110410093&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyD1629nYc12ZjrgVbH8d4qFjW8KGB7sicSVTfqM8rJiaZnMliaqQXHgzh3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;更新缓存的手段&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通常情况&lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;我们在&lt;/span&gt;&lt;span&gt;处理查询&lt;/span&gt;&lt;span&gt;请求的&lt;/span&gt;&lt;span&gt;时候，使用缓存的逻辑如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; = queryDataRedis(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; ==&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt; = queryDataMySQL(key); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;!=&lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说优先查询缓存，查询不到才查询数据库。如果这时候数据库查到数据了，就将缓存的数据进行更新。这是我们常说的cache aside的策略，也是最常用的策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑是正确的，而一致性的问题一般不来源于此，而是出现在处理写请求的时候。所以我们简化成最简单的写请求的逻辑，此时你可能会面临多个选择，究竟是直接更新缓存，还是失效缓存？而无论是更新缓存还是失效缓存，都可以选择在更新数据库之前，还是之后操作。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这样就演变出 4 个策略：更新数据库后更新缓存、更新数据库前更新缓存、更新数据库后删除缓存、更新数据库前删除缓存。下面我们来分别讲述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（一）更新数据库后更新缓存的不一致问题&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一种常见的操作是，设置一个过期时间，让写请求以数据库为准，过期后，读请求同步数据库中的最新数据给缓存。那么在加入了过期时间后，是否就不会有问题了呢？并不是这样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家设想一下这样的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如这里有一个计数器，把数据库自减 1，原始数据库数据是 100，同时有两个写请求申请计数减一，假设线程 A 先减数据库成功，线程 B 后减数据库成功。那么这时候数据库的值是 98，缓存里正确的值应该也要是 98。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是特殊场景下，你可能会遇到这样的情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 和线程 B 同时更新这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先 A 后 B&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;更新缓存时顺序是先 B 后 A&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果我们的代码逻辑还是更新数据库后立刻更新缓存的数据，那么——&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;powershell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就可能出现：数据库的值是 100-&amp;gt;99-&amp;gt;98，但是缓存的数据却是 100-&amp;gt;98-&amp;gt;99，也就是数据库与缓存的不一致。而且这个不一致只能等到下一次数据库更新或者缓存失效才可能修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table align=&quot;left&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库为98&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存数据为98&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存数据为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为99，但是实际上数据库的值已经是98，数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，如果更新Redis本身是失败的话，两边的值固然也是不一致的，这个前文也阐述过，几乎无法根除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/article&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8894472361809045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyD66JhRse8ousJOZCLKN0gU6g65uWeW0j6hLj2kZAbhPPL2Sibkhuialkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（二）更新数据库前更新缓存的不一致问题&lt;/span&gt;&lt;/p&gt;&lt;article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那你可能会想，这是否表示，我应该先让缓存更新，之后再去更新数据库呢？类似这样：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedis(key, &lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这样操作产生的问题更是显而易见的，因为我们无法保证数据库的更新成功，万一数据库更新失败了，你缓存的数据就不只是脏数据，而是错误数据了。&lt;/span&gt;&lt;/p&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9209876543209876&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDMHedlaqeQDJxkNhtVUWWvEE1vWibcbEFhUvwbvxjUCqp2kVVdNTXC8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;你可能会想，是否我在更新数据库失败的时候做 Redis 回滚的操作能够解决呢？这其实也是不靠谱的，因为我们也不能保证这个回滚的操作 100% 被成功执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时，在写写并发的场景下，同样有类似的一致性问题&lt;/span&gt;&lt;span&gt;，请看以下情况：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;article&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程 A 和线程 B 同时更新同这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更新缓存的顺序是先 A 后 B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先 B 后 A&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子。线程 A 希望把计数器置为 0，线程 B 希望置为 1。而按照以上场景，缓存确实被设置为 1，但数据库却被设置为 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存为0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存为1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库为1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库数据为0&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为1，但是实际上数据库的值是0，数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以通常情况下，更新缓存再更新数据库是我们应该避免使用的一种手段。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;br/&gt;&lt;h1&gt;&lt;span&gt;（三）更新数据库前删除缓存的问题&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如果采取删除缓存的策略呢？也就是说我们在更新数据库的时候失效对应的缓存，让缓存在下次触发读请求时进行更新，是否会更好呢？同样地，针对在更新数据库前和数据库后这两个删除时机，我们来比较下其差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最直观的做法，我们可能会先让缓存失效，然后去更新数据库，代码逻辑如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedis(key);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的逻辑看似没有问题，毕竟删除缓存后即便数据库更新失败了，也只是缓存上没有数据而已。然后并发两个写请求过来，无论怎么样的执行顺序，缓存最后的值也都是会被删除的，也就是说在并发写写的请求下这样的处理是没问题的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而，这种处理在读写并发的场景下却存在着隐患。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是刚刚更新计数的例子。例如现在缓存的数据是 100，数据库也是 100，这时候需要对此计数减 1，减成功后，数据库应该是 99。如果这之后触发读请求，缓存如果有效的话，里面应该也要被更新为 99 才是正确的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么思考下这样的请求情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 更新这个数据的同时，线程 B 读取这个数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 成功删除了缓存里的老数据，这时候线程 B 查询数据发现缓存失效&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程 A 更新数据库成功&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;1.读取缓存数据，缓存缺失，从数据库读取数据100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库中的数据X的值为99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将数据100的值写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，在读写并发的场景下，一样会有不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这种场景，有个做法是所谓的“延迟双删策略”，就是说，既然可能因为读请求把一个旧的值又写回去，那么我在写请求处理完之后，等到差不多的时间延迟再重新删除这个缓存值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程C（新的读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程D（新的读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T5&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;sleep(N)&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缓存存在，读取到缓存旧值100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;其他线程可能在双删成功前读到脏数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T6&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T7&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;缓存缺失，从数据库读取数据的最新值（99）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种解决思路的关键在于对 N 的时间的判断，如果 N 时间太短，线程 A 第二次删除缓存的时间依旧早于线程 B 把脏数据写回缓存的时间，那么相当于做了无用功。而 N 如果设置得太长，那么在触发双删之前，新请求看到的都是脏数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（四）更新数据库后删除缓存&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那如果我们把更新数据库放在删除缓存之前呢，问题是否解决？我们继续从读写并发的场景看下去，有没有类似的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程C（读请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新主库 X = 99（原值 X = 100）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读取数据，查询到缓存还有数据，返回100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程C实际上读取到了和数据库不一致的数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;查询缓存，缓存缺失，查询数据库得到当前值99&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T5&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将&lt;/span&gt;&lt;span&gt;99写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，大体上，采取先更新数据库再删除缓存的策略是没有问题的，仅在更新数据库成功到缓存删除之间的时间差内——[T2,T3)的窗口 ，可能会被别的线程读取到老值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在开篇的时候我们说过，缓存不一致性的问题无法在客观上完全消灭，因为我们无法保证数据库和缓存的操作是一个事务里的，而我们能做到的只是尽量缩短不一致的时间窗口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在更新数据库后删除缓存这个场景下，不一致窗口仅仅是 T2 到 T3 的时间，内网状态下通常不过 1ms，在大部分业务场景下我们都可以忽略不计。因为大部分情况下一个用户的请求很难能再1ms内快速发起第二次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是真实场景下，还是会有一个情况存在不一致的可能性，这个场景是读线程发现缓存不存在，于是读写并发时，读线程回写进去老值。并发情况如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时间&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程A（写请求）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程B（读请求--缓存不存在场景）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T1&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;查询缓存，缓存缺失，查询数据库得到当前值100&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T2&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新主库 X = 99（原值 X = 100）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T3&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;T4&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;将100写入缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;此时缓存的值被显式更新为100，但是实际上数据库的值已经是99了&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，这个不一致场景出现条件非常严格，因为并发量很大时，缓存不太可能不存在；如果并发很大，而缓存真的不存在，那么很可能是这时的写场景很多，因为写场景会删除缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以待会我们会提到，写场景很多时候实际上并不适合采取删除策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;（五）总结四种更新策略&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;终上所述，我们对比了四个更新缓存的手段，做一个总结对比，其中应对方案也提供参考，具体不做展开，如下表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;策略&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;潜在问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应对方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库+更新缓存&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A未更新完缓存之前，线程B的读请求会短暂读到旧值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;可以忽略&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，数据库和缓存数据不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新缓存+更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;无并发&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A还未更新完缓存但是更新数据库可能失败&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;利用MQ确认数据库更新成功（较复杂）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+写&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;更新缓存的顺序是先A后B，但更新数据库时顺序是先B后A&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作很重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;删除缓存值+更新数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写请求的线程A删除了缓存在更新数据库之前，这时候读请求线程B到来，因为缓存缺失，则把当前数据读取出来放到缓存，而后线程A更新成功了数据库&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;延迟双删（但是延迟的时间不好估计，且延迟的过程中依旧有不一致的时间窗口）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;&lt;p&gt;&lt;span&gt;更新数据库+删除缓存值&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读（缓存命中）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;线程A完成数据库更新成功后，尚未删除缓存，线程B有并发读请求会读到旧的脏数据&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;可以忽略&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;写+读（缓存不命中）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;读请求不命中缓存，写请求处理完之后读请求才回写缓存，此时缓存不一致&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;分布式锁（操作重）&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从一致性的角度来看，采取更新数据库后删除缓存值，是更为适合的策略。因为出现不一致的场景的条件更为苛刻，概率相比其他方案更低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么是否更新缓存这个策略就一无是处呢？不是的！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除缓存值意味着对应的 key 会失效，那么这时候读请求都会打到数据库。如果这个数据的写操作非常频繁，就会导致缓存的作用变得非常小。而如果这时候某些 Key 还是非常大的热 key，就可能因为扛不住数据量而导致系统不可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3665943600867679&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDE1oYyJic1e5ibyWB7rntUV6wtTZhSiao8YMRKXexSzjyo1aMz8L50Sib4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;删除策略频繁的缓存失效导致读请求无法利用缓存&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以做个简单总结，足以适应绝大部分的互联网开发场景的决策：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对大部分读多写少场景，建议选择更新数据库后删除缓存的策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对读写相当或者写多读少的场景，建议选择更新数据库后更新缓存的策略。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最终一致性如何保证？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存设置过期时间&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一个方法便是我们上面提到的，当我们无法确定 MySQL 更新完成后，缓存的更新/删除一定能成功，例如 Redis 挂了导致写入失败了，或者当时网络出现故障，更常见的是服务当时刚好发生重启了，没有执行这一步的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这些时候 MySQL 的数据就无法刷到 Redis 了。为了避免这种不一致性永久存在，使用缓存的时候，我们必须要给缓存设置一个过期时间，例如 1 分钟，这样即使出现了更新 Redis 失败的极端场景，不一致的时间窗口最多也只是 1 分钟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是我们最终一致性的兜底方案，万一出现任何情况的不一致问题，最后都能通过缓存失效后重新查询数据库，然后回写到缓存，来做到缓存与数据库的最终一致。&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F9gEWETfj769ZEnnF4YHYbm1UBFpYldG1ibl6E9owa0M3yRB40WtEqLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何减少缓存删除/更新的失败？&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;万一删除缓存这一步因为服务重启没有执行，或者 Redis 临时不可用导致删除缓存失败了，就会有一个较长的时间（缓存的剩余过期时间）是数据不一致的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们有没有什么手段来减少这种不一致的情况出现呢？这时候借助一个可靠的消息中间件就是一个不错的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为消息中间件有 ATLEAST-ONCE 的机制，如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8088803088803089&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDbhKBOIj2FNXuTYicyU1K5jITpzSkTrpKv19YcPzj1XPwPWrU6ZdmGWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们把删除 Redis 的请求以消费 MQ 消息的手段去失效对应的 Key 值，如果 Redis 真的存在异常导致无法删除成功，我们依旧可以依靠 MQ 的重试机制来让最终 Redis 对应的 Key 失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而你们或许会问，极端场景下，是否存在更新数据库后 MQ 消息没发送成功，或者没机会发送出去机器就重启的情况？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个场景的确比较麻烦，如果 MQ 使用的是 RocketMQ，我们可以借助 RocketMQ 的事务消息，来让删除缓存的消息最终一定发送出去。而如果你没有使用 RocketMQ，或者你使用的消息中间件并没有事务消息的特性，则可以采取消息表的方式让更新数据库和发送消息一起成功。事实上这个话题比较大了，我们不在这里展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FibDz8VdeMtTPP6QGg7Qg03rhEzsPz8nRZlEVnmBdT96EyJFHfMz0iavQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;如何处理复杂的多缓存场景？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些时候，真实的缓存场景并不是数据库中的一个记录对应一个 Key 这么简单，有可能一个数据库记录的更新会牵扯到多个 Key 的更新。还有另外一个场景是，更新不同的数据库的记录时可能需要更新同一个 Key 值，这常见于一些 App 首页数据的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以一个数据库记录对应多个 Key 的场景来举例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如系统设计上我们缓存了一个粉丝的主页信息、主播打赏榜 TOP10 的粉丝、单日 TOP 100 的粉丝等多个信息。如果这个粉丝注销了，或者这个粉丝触发了打赏的行为，上面多个 Key 可能都需要更新。只是一个打赏的记录，你可能就要做：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateMySQL();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedisKey1();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;updateRedisKey2();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;deleteRedisKey3();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这就涉及多个 Redis 的操作，每一步都可能失败，影响到后面的更新。甚至从系统设计上，更新数据库可能是单独的一个服务，而这几个不同的 Key 的缓存维护却在不同的 3 个微服务中，这就大大增加了系统的复杂度和提高了缓存操作失败的可能性。最可怕的是，操作更新记录的地方很大概率不只在一个业务逻辑中，而是散发在系统各个零散的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这个场景，解决方案和上文提到的保证最终一致性的操作一样，就是把更新缓存的操作以 MQ 消息的方式发送出去，由不同的系统或者专门的一个系统进行订阅，而做聚合的操作。如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4594240837696335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDk6GxakNUd7Gia5VOXPs9s3Vj7aO1YEUuEB2SsM5lM7ASr6oPia19LeYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1528&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不同业务系统订阅MQ消息单独维护各自的缓存Key&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47368421052631576&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDtHXHmQb1SH28bWzquewVMDecoAS9cecdGs7pueIDVXeY1A8aCjjYDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;专门更新缓存的服务订阅MQ消息维护所有相关Key的缓存操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97wd1kjBtWzys9nG2SWzoiabw5V7EdjQsD9xVByPSSQwIdCa4YpoKGZCP5ZbMK6SBl0eqVapQznw0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;通过订阅MySQL binlog的方式处理缓存&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面讲到的 MQ 处理方式需要业务代码里面显式地发送 MQ 消息。还有一种优雅的方式便是订阅 MySQL 的 binlog，监听数据的真实变化情况以处理相关的缓存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如刚刚提到的例子中，如果粉丝又触发打赏了，这时候我们利用 binlog 表监听是能及时发现的，发现后就能集中处理了，而且无论是在什么系统什么位置去更新数据，都能做到集中处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前业界类似的产品有 Canal，具体的操作图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4147651006711409&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDs4B8jltwmUAamAoTO76ZDaib3ibspONEHfucuToF46g95RaX41CQMoKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用Canel订阅数据库binlog变更从而发出MQ消息，让一个专门消费者服务维护所有相关Key的缓存操作&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到这里，针对大型系统缓存设计如何保证最终一致性，我们已经从策略、场景、操作方案等角度进行了细致的讲述，希望能对你起到帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;点击下方空白 ▼ 查看明日开发者黄历&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDM3RtYXiaicydYd6oAnjecFFekk7QdwJd3v4e33liaTcEYMIic1GBWtEfMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 375 138&quot; opacity=&quot;1&quot;&gt;&lt;svg&gt;&lt;svg&gt;&lt;rect fill=&quot;rgb(254, 254, 254)&quot; x=&quot;0%&quot; y=&quot;0%&quot;/&gt;&lt;/svg&gt;&lt;svg x=&quot;32.80%&quot; y=&quot;335.53%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;summer&lt;/p&gt;&lt;p&gt;time&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;svg x=&quot;61.07%&quot; y=&quot;26.18%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;2022&lt;/p&gt;&lt;p&gt;/&lt;/p&gt;&lt;p&gt;07.23&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;svg x=&quot;22.93%&quot; y=&quot;280.89%&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; styel=&quot;vertical-align: middle; max-width: 100%;&quot;&gt;&lt;foreignobject&gt;&lt;p&gt;&lt;/p&gt;&lt;/foreignobject&gt;&lt;/svg&gt;&lt;/svg&gt;&lt;animate fill=&quot;freeze&quot; attributename=&quot;opacity&quot; begin=&quot;click&quot; from=&quot;1&quot; to=&quot;0&quot; dur=&quot;1&quot; restart=&quot;never&quot;/&gt;&lt;animate fill=&quot;freeze&quot; attributename=&quot;width&quot; begin=&quot;click + 1s&quot; from=&quot;1&quot; to=&quot;0&quot; dur=&quot;0.01&quot; restart=&quot;never&quot;/&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0599455&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe955YQIYia0ZAfHTHlbdfNjyDzmCVibvoCq3NNLJp0pObVR8AcFNFCgxLJj7QKZ5MEZZ7ecic8TVS3dMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;注：本文基于本人博客https://jaskey.github.io/blog/2022/04/14/cache-consistency/&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt; 作者个人邮箱jaskeylin@apache.org，微信：JaskeyLam&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/article&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea04e8714b59113d0a3aff2598dc1b42</guid>
<title>你可能不知道的 JavaScript APIs</title>
<link>https://toutiao.io/k/nq5ow3p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近，看到一些好用但不太常用的JS API，觉得挺不错的，分享给大家。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Page Visibility API&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Web Share API&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broadcast Channel API&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Internationalization API&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们来看下应该在哪里使用它们，以及如何使用它们。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page Visibility API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个APi 可以让我们知道用户何时离开了页面。准确地说，只要页面的可见性状态发生变化，无论是用户最小化、最大化窗口还是切换标签，该API都会触发一个事件 &lt;code&gt;visibilitychange&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在过去，我不得不使用一些黑科技来确认用户是否切换了标签或最小化了窗口。最流行的是使用&lt;code&gt;blur&lt;/code&gt;和&lt;code&gt;foucs&lt;/code&gt;浏览器事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;window.addEventListener(&lt;span&gt;&quot;focus&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt; () {&lt;br/&gt;    // User is back on the page&lt;br/&gt;    // Do Something&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;window.addEventListener(&lt;span&gt;&quot;blur&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt; () {&lt;br/&gt;    // User left the page&lt;br/&gt;    // Do Something&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码可以工作，但不像预期的那样。因为&lt;code&gt;blur&lt;/code&gt;事件是在页面失去焦点时触发的，所以当用户点击搜索栏、警报对话框、控制台或窗口边框时，它就会被触发。所以，&lt;code&gt;blur&lt;/code&gt;和&lt;code&gt;foucs&lt;/code&gt;只告诉我们页面是否被激活，但不告诉我们页面的内容是否被隐藏或可见。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;案例&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，我们希望使用 Page Visibility API，在用户没有看到页面时停止不必要的进程，或者执行一些后台操作。可以下面这几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当用户离开页面时，暂停视频、轮播图或动画。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;停止一些实时获取数据的API&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送一些用户信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何使用它？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Page Visibility API 有两个属性和一个事件来访问页面可见性状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;document.hidden&lt;/strong&gt;它是全局可用的，而且是只读的。尽量避免使用它，因为它现在已经被废弃了，但是当被访问时，如果页面是隐藏的，它将返回 &lt;code&gt;true&lt;/code&gt;，如果是可见的，它将返回 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Document.visibilityState （只读属性）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回document的可见性，即当前可见元素的上下文环境。由此可以知道当前文档 (即为页面) 是在背后，或是不可见的隐藏的标签页，或者 (正在) 预渲染。可用的值如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;&#x27;visible&#x27;&lt;/code&gt; : 此时页面内容至少是部分可见。即此页面在前景标签页中，并且窗口没有最小化。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;&#x27;hidden&#x27; &lt;/code&gt;: 此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于 &#x27;锁屏状态&#x27;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;&#x27;prerender&#x27;&lt;/code&gt; : 页面此时正在渲染中，因此是不可见的 (considered hidden for purposes of document.hidden). 文档只能从此状态开始，永远不能从其他值变为此状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;visibilitychange&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当其选项卡的内容变得可见或被隐藏时，会在文档上触发 &lt;code&gt;visibilitychange&lt;/code&gt; (能见度更改) 事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;document.addEventListener(&lt;span&gt;&quot;visibilitychange&quot;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (document.visibilityState === &lt;span&gt;&quot;visible&quot;&lt;/span&gt;) {&lt;br/&gt;        // page is visible&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        // page is hidden&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Web Share API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web Share API 它可以让我们访问操作系统的本地共享机制，这对移动用户特别有用。通过这个API，可以分享文本、链接和文件，而不需要创建自己的分享机制或使用第三方的机制。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用案例&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用它来分享网页上的内容到社交媒体上，或者把它复制到用户的剪贴板上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何使用它？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络共享API给了我们两个接口来访问用户的共享系统。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;navigator.canShare(data);&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对 &lt;code&gt;Navigator.share()&lt;/code&gt; 的调用成功，则 Web Share API 的 &lt;code&gt;Navigator.canShare()&lt;/code&gt; 方法将返回 &lt;code&gt;true&lt;/code&gt;。&lt;code&gt;data&lt;/code&gt; 包含要共享的数据的对象，该对象要与 &lt;code&gt;Navigator.share()&lt;/code&gt; 方法传递的数据相匹配。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;navigator.share(data)&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Navigator.share()&lt;/code&gt; 方法通过调用本机的共享机制作为 Web Share API 的一部分。如果不支持 Web Share API，则此方法为 &lt;code&gt;undefined&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;data&lt;/code&gt; 包含要共享的数据的对象。必须至少指定以下字段之一。可用选项包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;url: 要共享的 URL（ USVString ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;text: 要共享的文本（ USVString ）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;title: 要共享的标题（ USVString）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;files: 要共享的文件（“FrozenArray”）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法将会返回一个 Promise。一旦用户完成分享，这个 promise 将会接受。如果指定的共享数据格式不正确，promise 将会立即拒绝；如果用户取消了分享，promise 也会拒绝。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事例&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;navigator.share({&lt;br/&gt;  title: document.title,&lt;br/&gt;  text: &lt;span&gt;&#x27;Hello World&#x27;&lt;/span&gt;,&lt;br/&gt;  url: &lt;span&gt;&#x27;https://developer.mozilla.org&#x27;&lt;/span&gt;,&lt;br/&gt;}); // 分享 MDN 的 URL&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Broadcast Channel API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Broadcast Channel API&lt;/strong&gt; 可以实现同 源 下浏览器不同窗口，Tab 页，&lt;code&gt;frame&lt;/code&gt; 或者 iframe 下的 浏览器上下文 (通常是同一个网站下不同的页面) 之间的简单通讯。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const broadcast = new BroadcastChannel(&lt;span&gt;&quot;new_channel&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;BroadcastChannel&lt;/strong&gt; 接口非常简单。通过创建一个 &lt;code&gt;BroadcastChannel&lt;/code&gt; 对象，一个客户端就加入了某个指定的频道。只需要向 构造函数 传入一个参数：频道名称。如果这是首次连接到该广播频道，相应资源会自动被创建。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发送消息&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在发送消息就很简单了，只需要调用 BroadcastChannel 对象上的 &lt;code&gt;postMessage()&lt;/code&gt; 方法即可。该方法的参数可以是任意对象。最简单的例子就是发送 DOMString 文本消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;broadcast.postMessage(&lt;span&gt;&quot;Example message&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不只是 DOMString，任意类型的对象都可以被发送。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;断开连接&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过调用 BroadcastChannel 对象的 &lt;code&gt;close()&lt;/code&gt; 方法，可以离开频道。这将断开该对象和其关联的频道之间的联系，并允许它被垃圾回收。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 断开频道连接&lt;br/&gt;bc.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Internationalization API&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开发一个网页或应用程序时，需要将其内容翻译成其他语言以覆盖更广泛的受众是非常常见的。然而，仅仅将你的网页文本翻译成你所需要的任何语言，并不足以使你的内容对讲该语言的人可用，因为像日期、数字、单位等东西在不同国家是不同的，可能会给你的用户带来混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你想在你的网页上显示日期 &quot;2022年11月8日&quot;，如 &quot;11/8/22&quot;。根据读者的国家，这个数据可以用三种不同的方式来阅读。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;“November 8, 2022” 或者 MM/DD/YY 来自美国&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“August 11, 2022” or DD/MM/YY 来自欧洲&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“August 22, 2011” or YY/MM/DD 来自中国、日本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是国际化API（或I18n API）来解决不同语言和地区的格式问题的地方。I18n API是一个了不起的工具，有多种用途，但这里不会深入研究，以免使本文过于冗长。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何使用它？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;I18n API 使用 &lt;code&gt;locale&lt;/code&gt; 标识符来工作。&lt;code&gt;locales&lt;/code&gt; 参数必须是一个 BCP 47 语言标记的字符串，或者是一个包括多个语言标记的数组。如果 locales 参数未提供或者是 undefined，便会使用运行时默认的 locale。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 BCP 47 语言标记代表了一种语言或者区域（两者没有很大的区别）。在其最常见的格式中，它以这样的顺序囊括了这些内容：语言代码，脚本代码，和国家代码，全部由连字符分隔开。例如：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&quot;hi&quot;：印地语 (primary language)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;de-AT&quot;: 在奥地利使用的德语 (primary language with country code)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;zh-Hans-CN&quot;：在中国使用的简体中文 (primary language with script and country codes)。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更准确地说，I18n API提供了一个&lt;code&gt;Intl&lt;/code&gt;对象，它提供了精确的字符串对比、数字格式化，和日期时间格式化。&lt;code&gt;Collator&lt;/code&gt;，&lt;code&gt;NumberFormat&lt;/code&gt; 和 &lt;code&gt;DateTimeFormat&lt;/code&gt; 对象的构造函数是 &lt;code&gt;Intl&lt;/code&gt; 对象的属性。本页文档内容包括了这些属性，以及国际化使用的构造器和其他语言的方法等常见的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.Collator&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;collators 的构造函数，用于启用对语言敏感的字符串比较的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.DateTimeFormat&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于启用语言敏感的日期和时间格式的对象的构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.ListFormat&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启用对语言敏感的列表格式化的对象的构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.NumberFormat&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于启用语言敏感数字格式的对象的构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.PluralRules&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于启用多种敏感格式和多种语言语言规则的对象的构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Intl.RelativeTimeFormat&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于启用语言敏感的相对时间格式化的对象的构造函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的例子中，我们重点关注 &lt;code&gt;Intl.DateTimeFormat()&lt;/code&gt; 构造函数，以根据用户的区域设置来格式化报价的 &lt;code&gt;dateAdded&lt;/code&gt; 属性。&lt;code&gt;Intl.DateTimeFormat()&lt;/code&gt; 构造函数需要两个参数：定义日期格式化惯例的 &lt;code&gt;locale&lt;/code&gt; 字符串和用于自定义日期格式的 &lt;code&gt;options&lt;/code&gt; 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建的 &lt;code&gt;Intl.DateTimeFormat()&lt;/code&gt; 对象有一个 &lt;code&gt;format()&lt;/code&gt; 方法，它需要两个参数：我们要格式化的Date对象和用于自定义如何显示格式化日期的 &lt;code&gt;options&lt;/code&gt; 对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const logDate = (locale) =&amp;gt; {&lt;br/&gt;    const newDate = new Date(&lt;span&gt;&quot;2022-10-24&quot;&lt;/span&gt;); // YY/MM/DD&lt;br/&gt;    const dateTime = new Intl.DateTimeFormat(locale, {timeZone: &lt;span&gt;&quot;UTC&quot;&lt;/span&gt;});&lt;br/&gt;    const formatedDate = dateTime.format(newDate);&lt;br/&gt;    console.log(formatedDate);&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;logDate(&lt;span&gt;&quot;en-US&quot;&lt;/span&gt;); // 10/24/2022&lt;br/&gt;logDate(&lt;span&gt;&quot;de-DE&quot;&lt;/span&gt;); // 24.10.2022&lt;br/&gt;logDate(&lt;span&gt;&quot;zh-TW&quot;&lt;/span&gt;); // 2022/10/24&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dateTime.format()&lt;/code&gt; 根据当地的日期格式约定改变日期。我们可以使用&lt;code&gt;navigator.language&lt;/code&gt;全局属性在报价单的日期上实现这一行为，该全局属性持有用户的首选区域设置。为此，我们将创建一个新的函数，接收一个日期字符串（&lt;code&gt;YYYY-MM-DD&lt;/code&gt;格式），并根据用户的&lt;code&gt;locale&lt;/code&gt;返回格式化的日期。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const formatDate = (dateString) =&amp;gt; {&lt;br/&gt;    const date = new Date(dateString);&lt;br/&gt;    const locale = navigator.language;&lt;br/&gt;    const dateTimeFormat = new Intl.DateTimeFormat(locale, {timeZone: &lt;span&gt;&quot;UTC&quot;&lt;/span&gt;});&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; dateTimeFormat.format(date);&lt;br/&gt;&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 Fundebug。&lt;/strong&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原文：https://www.smashingmagazine.com/2022/09/javascript-api-guide/&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>