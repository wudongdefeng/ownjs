<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>73dca3c239def320ef424008a831a674</guid>
<title>Prometheus 云原生 kubernetes 服务发现原理图解</title>
<link>https://toutiao.io/k/3070hb8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;云原生kubernetes服务发现原理图解&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上节分析了&lt;code&gt;Prometheus&lt;/code&gt;服务发现核心流程（如下图），&lt;code&gt;Discoverer&lt;/code&gt;基于不同协议发现采集点，通过&lt;code&gt;channel&lt;/code&gt;通知到&lt;code&gt;updater&lt;/code&gt;协程，然后更新到&lt;code&gt;discoveryManager&lt;/code&gt;结构体&lt;code&gt;trargets&lt;/code&gt;字段中，最终由&lt;code&gt;sender&lt;/code&gt;协程将&lt;code&gt;discoveryManager&lt;/code&gt;的&lt;code&gt;targets&lt;/code&gt;字段数据发送给&lt;code&gt;scrape&lt;/code&gt;采集模块。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycUdlxroG8YdnKcheVAFTyIx8X0x6DZz1BkYYOAhQ3UzIWoNcVYdonWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.537962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Discoverer&lt;/code&gt;定义的接口类型，不同的服务发现协议基于该接口进行实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Discoverer &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Run hands a channel to the discovery provider (Consul, DNS, etc.) through which&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// it can send updated target groups. It must return when the context is canceled.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// It should not close the update channel on returning.&lt;/span&gt;&lt;br/&gt; Run(ctx context.Context, up &lt;span&gt;chan&lt;/span&gt;&amp;lt;- []*targetgroup.Group)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;k8s协议配置&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Prometheus&lt;/code&gt;本身就是作为云原生监控出现的，所以对云原生服务发现支持具有天然优势。&lt;code&gt;kubernetes_sd_configs&lt;/code&gt; 服务发现协议核心原理就是利用&lt;code&gt;API Server&lt;/code&gt;提供的&lt;code&gt;Rest接口&lt;/code&gt;获取到云原生集群中的&lt;code&gt;POD&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;Endpoints&lt;/code&gt;、&lt;code&gt;Endpointslice&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;等对象的元数据，并基于这些信息生成&lt;code&gt;Prometheus&lt;/code&gt;采集点，并且可以随着云原生集群状态变更进行动态实时刷新。&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycj5acWzJCSCe5Ockgrkibrrlem6W3JADNicstpwIGNOLSP15hd8qt0Q0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5011574074074074&quot; data-w=&quot;864&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;kubernetes&lt;/code&gt;云原生集群的&lt;code&gt;POD&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;等对象元数据信息都被存储到&lt;code&gt;etcd&lt;/code&gt;数据库中，并通过&lt;code&gt;API Server&lt;/code&gt;组件暴露的&lt;code&gt;Rest&lt;/code&gt;接口方式提供访问或操作这些对象数据信息。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「&lt;code&gt;kubernetes_sd_configs&lt;/code&gt;配置示例：」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;job_name:&lt;/span&gt; &lt;span&gt;kubernetes-pod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;kubernetes_sd_configs:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;role:&lt;/span&gt; &lt;span&gt;pod&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;namespaces:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;names:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&#x27;test01&#x27;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;api_server:&lt;/span&gt; &lt;span&gt;https://apiserver.simon:6443&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;bearer_token_file:&lt;/span&gt; &lt;span&gt;/var/run/secrets/kubernetes.io/serviceaccount/token&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;tls_config:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ca_file:&lt;/span&gt; &lt;span&gt;/var/run/secrets/kubernetes.io/serviceaccount/ca.crt&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置说明：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;api_server&lt;/code&gt;指定&lt;code&gt;API Server&lt;/code&gt;地址，出于安全考虑，这些接口是带有安全认证的，&lt;code&gt;bearer_token_file&lt;/code&gt;和&lt;code&gt;ca_file&lt;/code&gt;则指定访问&lt;code&gt;API Server&lt;/code&gt;使用到的认证信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;role&lt;/code&gt;指定基于云原生集群中哪种对象类型做服务发现，支持&lt;code&gt;POD&lt;/code&gt;、&lt;code&gt;Service&lt;/code&gt;、&lt;code&gt;Node&lt;/code&gt;、&lt;code&gt;Endpoints&lt;/code&gt;、&lt;code&gt;Endpointslice&lt;/code&gt;、&lt;code&gt;Ingress&lt;/code&gt;六种类型；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;namespaces&lt;/code&gt;指定作用于哪个云原生命名空间下的对象，不配置则对所有的云原生命名空间生效；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「为什么没有配置api server信息也可以正常进行服务发现？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候我们并不需要配置&lt;code&gt;api server&lt;/code&gt;相关信息也可以进行服务发现，如我们将上面示例简化如下写法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;job_name:&lt;/span&gt; &lt;span&gt;kubernetes-pod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;kubernetes_sd_configs:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;role:&lt;/span&gt; &lt;span&gt;pod&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;namespaces:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;names:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&#x27;test01&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般&lt;code&gt;Prometheus&lt;/code&gt;部署在监控云原生集群上，从 &lt;code&gt;Pod&lt;/code&gt; 使用 &lt;code&gt;Kubernetes API&lt;/code&gt; 官方客户端库(&lt;code&gt;client-go&lt;/code&gt;)提供了更为简便的方法：&lt;code&gt;rest.InClusterConfig()&lt;/code&gt;。&lt;code&gt;API Server&lt;/code&gt;地址是从&lt;code&gt;POD&lt;/code&gt;的环境变量&lt;code&gt;KUBERNETES_SERVICE_HOST&lt;/code&gt;和&lt;code&gt;KUBERNETES_SERVICE_PORT&lt;/code&gt;构建出来， &lt;code&gt;token&lt;/code&gt; 以及 &lt;code&gt;ca&lt;/code&gt; 信息从&lt;code&gt;POD&lt;/code&gt;固定的文件中获取，因此这种场景下&lt;code&gt;kubernetes_sd_configs&lt;/code&gt;中&lt;code&gt;api_server&lt;/code&gt;和&lt;code&gt;ca_file&lt;/code&gt;是不需要配置的。&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycNKLEd4Gxh6SuicRW0WqT546icMTvSt0h4dvUfJchmXTmmC2xp0s7JGDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7074074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;client-go&lt;/code&gt;是&lt;code&gt;kubernetes&lt;/code&gt;官方提供的&lt;code&gt;go&lt;/code&gt;语言的客户端库，&lt;code&gt;go&lt;/code&gt;应用使用该库可以访问&lt;code&gt;kubernetes&lt;/code&gt;的&lt;code&gt;API Server&lt;/code&gt;，这样我们就能通过编程来对&lt;code&gt;kubernetes&lt;/code&gt;资源进行增删改查操作。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Informer机制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从之前分析的服务发现协议接口设计得知，了解&lt;code&gt;k8s&lt;/code&gt;服务发现协议入口在&lt;code&gt;discovery/kubernetes.go&lt;/code&gt;的&lt;code&gt;Run&lt;/code&gt;方法：&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycPmiccKZGKiamEGHmWgCWfeV3LZuqtryaqAIAVOBQQgpN8XogvLBKve2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3962962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Run&lt;/code&gt;方法中&lt;code&gt;switch&lt;/code&gt;罗列出不同&lt;code&gt;role&lt;/code&gt;的处理逻辑，刚好和配置示例中&lt;code&gt;role&lt;/code&gt;支持的六种云原生对象类型对应，只是基于不同的对象进行服务发现，基本原理都是一致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;云原生服务发现基本原理是访问&lt;code&gt;API Server&lt;/code&gt;获取到云原生集群资源对象，&lt;code&gt;Prometheus&lt;/code&gt;与&lt;code&gt;API Server&lt;/code&gt;进行交互这里使用到的是&lt;code&gt;client-go&lt;/code&gt;官方客户端里的&lt;code&gt;Informer&lt;/code&gt;核心工具包。&lt;code&gt;Informer&lt;/code&gt;底层使用&lt;code&gt;ListWatch&lt;/code&gt;机制，在&lt;code&gt;Informer&lt;/code&gt;首次启动时，会调用&lt;code&gt;List API&lt;/code&gt;获取所有最新版本的资源对象，缓存在内存中，然后再通过&lt;code&gt;Watch API&lt;/code&gt;来监听这些对象的变化，去维护这份缓存，降低&lt;code&gt;API Server&lt;/code&gt;的负载。除了&lt;code&gt;ListWatch&lt;/code&gt;，&lt;code&gt;Informer&lt;/code&gt;还可以注册自定义事件处理逻辑，之后如果监听到事件变化就会调用对应的用户自定义事件处理逻辑，这样就实现了用户业务逻辑扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Informer&lt;/code&gt;机制工作流程如下图：&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycqwu7zfdcntPlS8x0VWXTpSH5uQFtPsR3qehwib4wefYicCibfBPoHDNZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7870370370370371&quot; data-w=&quot;1080&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Informer&lt;/code&gt;机制本身比较复杂，这里先暂时不太具体说明，只需要理解&lt;code&gt;Prometheus&lt;/code&gt;使用&lt;code&gt;Informer&lt;/code&gt;机制获取和监听云原生资源对象，即上图中只有&lt;strong&gt;「绿色框部分是自定义业务逻辑」&lt;/strong&gt;，其它都是&lt;code&gt;client-go&lt;/code&gt;框架&lt;code&gt;informer&lt;/code&gt;工具包提供的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其中的关键就是注册自定义&lt;code&gt;AddFunc&lt;/code&gt;、&lt;code&gt;DeleteFunc&lt;/code&gt;和&lt;code&gt;UpdateFunc&lt;/code&gt;三种事件处理器，分别对应增、删、改操作，当触发对应操作后，事件处理器就会被回调感知到。比如云原生集群新增一个&lt;code&gt;POD&lt;/code&gt;资源对象，则会触发&lt;code&gt;AddFunc&lt;/code&gt;处理器，该处理器并不做复杂的业务处理，只是将该对象的&lt;code&gt;key&lt;/code&gt;放入到&lt;code&gt;Workqueue&lt;/code&gt;队列中，然后&lt;code&gt;Process Item&lt;/code&gt;组件作为消费端，不停从&lt;code&gt;Workqueue&lt;/code&gt;中提取数据获取到新增&lt;code&gt;POD&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;，然后交由&lt;code&gt;Handle Object&lt;/code&gt;组件，该组件通过&lt;code&gt;Indexer&lt;/code&gt;组件提供的&lt;code&gt;GetByKey()&lt;/code&gt;查询到该新增&lt;code&gt;POD&lt;/code&gt;的所有元数据信息，然后基于该&lt;code&gt;POD&lt;/code&gt;元数据就可以构建采集点信息，这样就实现&lt;code&gt;kubernetes&lt;/code&gt;服务发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「为什么需要Workqueue队列？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Resource Event Handlers&lt;/code&gt;组件注册自定义事件处理器，获取到事件时只是把对象&lt;code&gt;key&lt;/code&gt;放入到&lt;code&gt;Workerqueue&lt;/code&gt;中这种简单操作，而没有直接调用&lt;code&gt;Handle Object&lt;/code&gt;进行事件处理，这里主要是避免阻塞影响整个&lt;code&gt;informer&lt;/code&gt;框架运行。如果&lt;code&gt;Handle Object&lt;/code&gt;比较耗时放到&lt;code&gt;Resource Event Handlers&lt;/code&gt;组件中直接处理，可能就会影响到④⑤功能，所以这里引入&lt;code&gt;Workqueue&lt;/code&gt;类似于&lt;code&gt;MQ&lt;/code&gt;功能实现解耦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉了上面&lt;code&gt;Informer机制&lt;/code&gt;，下面以&lt;code&gt;role=POD&lt;/code&gt;为例结合&lt;code&gt;Prometheus&lt;/code&gt;源码梳理下上面流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、创建和&lt;code&gt;API Server&lt;/code&gt;交互底层使用的&lt;code&gt;ListWatch&lt;/code&gt;工具；&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycLkmSTlOg7h6pMI4P1ZyYtzvFZWELBUEGRFUW8hsb0gcsiarwCyqspVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5420560747663551&quot; data-w=&quot;1070&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、基于&lt;code&gt;ListWatch&lt;/code&gt;创建&lt;code&gt;Informer&lt;/code&gt;；&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCyczfrE2Gj0woGlia5YoCKlZdMzuvYoZmlPTMYzIbOKMySEC9MNafqS0WA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.07420924574209246&quot; data-w=&quot;822&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、注册资源事件，分别对应资源创建、资源删除和资源更新事件处理；&lt;/p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCyc2ssFWGQIxJLiaVHuGiaDcS5QYY8UCWFbd3ZclV5Dn2vKIZv8fibEibG17w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6065022421524664&quot; data-w=&quot;892&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这里的 &lt;code&gt;podAddCount&lt;/code&gt;、&lt;code&gt;podDeleteCount&lt;/code&gt;和&lt;code&gt;podUpdateCount&lt;/code&gt;分别对应下面三个指标序列，指标含义也比较明显：&lt;/p&gt;&lt;p&gt;&lt;code&gt;prometheus_sd_kubernetes_events_total(role=&quot;pod&quot;, event=&quot;add&quot;)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;prometheus_sd_kubernetes_events_total(role=&quot;pod&quot;, event=&quot;delete&quot;)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;prometheus_sd_kubernetes_events_total(role=&quot;pod&quot;, event=&quot;update&quot;)&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;role&lt;/code&gt;标识资源类型，包括：&lt;code&gt;&quot;endpointslice&quot;, &quot;endpoints&quot;, &quot;node&quot;, &quot;pod&quot;, &quot;service&quot;, &quot;ingress&quot;&lt;/code&gt;五种类型；&lt;/p&gt;&lt;p&gt;&lt;code&gt;event&lt;/code&gt;标识事件类型，包括：&lt;code&gt;&quot;add&quot;, &quot;delete&quot;, &quot;update&quot;&lt;/code&gt;三种类型。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、事件处理，&lt;code&gt;AddFunc&lt;/code&gt;、&lt;code&gt;DeleteFunc&lt;/code&gt;和&lt;code&gt;UpdateFunc&lt;/code&gt;注册的事件处理逻辑一样，处理逻辑也比较简单：就是获取资源对象&lt;code&gt;key&lt;/code&gt;，并将其写入到&lt;code&gt;Workqueue&lt;/code&gt;中；&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3482642777155655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCyczpDfMaw87EUcgibxuL7MD0uzhwOfibNblKYTMbmibdFOib8zRnFIicUCQ9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;对于&lt;code&gt;POD&lt;/code&gt;资源，这里的&lt;code&gt;key&lt;/code&gt;就是：&lt;code&gt;namespace/pod_name&lt;/code&gt;格式，比如&lt;code&gt;key=test01/nginx-deployment-5ffc5bf56c-n2pl8&lt;/code&gt;。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、给&lt;code&gt;Workqueue&lt;/code&gt;注册一个无限循环处理逻辑，就能持续从&lt;code&gt;Workqueue&lt;/code&gt;中取出&lt;code&gt;key&lt;/code&gt;进行处理；&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7490740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycibeJZHZG6LrRPAqDmjwEdWWXdkJjsaZC9icCtaDbeEwJSslYiblvF6YNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;针对&lt;code&gt;Pod&lt;/code&gt;里的每个&lt;code&gt;Container&lt;/code&gt;上的每个&lt;code&gt;port&lt;/code&gt;，都会生成一个对应采集点&lt;code&gt;target&lt;/code&gt;，其中&lt;code&gt;__address__&lt;/code&gt;就是&lt;code&gt;PodIP&lt;/code&gt;+&lt;code&gt;port&lt;/code&gt;组合。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、最后启动&lt;code&gt;Informer&lt;/code&gt;，让整个流程运转起来；&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10860655737704918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCyc935C3Mo2ozND1zRILR46icU1dWUicrfVzP0mBSTYNew9JtOP7Sht4XnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;488&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/O2TDJPu7cb34AsmIHZKBMxJibn7lTXCycpuRf1d0hFzm3AJNAKraMKLaiabvz2LtA8BXEpoyCcSOPrZD0EONFoyA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「更多云原生监控运维知识，请关注公众号：Reactor2020」&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f9d20e6d53dabd706cd18c91aacf6609</guid>
<title>ChatGPT 真的可以让流浪地球的丫丫 “复活”</title>
<link>https://toutiao.io/k/29qnui2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-10 col-sm-12&quot;&gt;
            &lt;h1&gt; ChatGPT 真的可以让流浪地球的丫丫 “复活”&lt;/h1&gt;
            &lt;hr/&gt;
            &lt;p&gt;作者: 康凯森&lt;/p&gt;
            &lt;p&gt;日期: 2023-03-12&lt;/p&gt;
            &lt;p&gt;分类: &lt;a href=&quot;../tag/chatgpt.html&quot; target=&quot;_blank&quot;&gt;chatgpt&lt;/a&gt;&lt;/p&gt;
            &lt;hr/&gt;
            


&lt;h2 id=&quot;一-流浪地球2中的yy&quot;&gt;一 流浪地球2中的YY&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/yaya.png&quot; alt=&quot;yaya&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流浪地球2中图恒宇利用超级计算机制造了数字生命丫丫，并最终拯救了整个人类，看这部影片时，还感觉数字生命可能离我们还比较遥远，可能需要很多年才能变成现实，但是最近随着对一些 ChatGPT 应用的粗浅思考，感觉数字生命已经离我们人类不是很遥远，至少初级版的丫丫现在就可以制造出原型。&lt;/p&gt;
&lt;h2 id=&quot;二-如何利用-chatgpt-和-ai-工具“复活”丫丫&quot;&gt;二 如何利用 ChatGPT 和 AI 工具“复活”丫丫&lt;/h2&gt;
&lt;h3 id=&quot;21-chatgpt-赋予丫丫思想，性格，说话风格，记忆&quot;&gt;2.1 ChatGPT 赋予丫丫思想，性格，说话风格，记忆&lt;/h3&gt;
&lt;p&gt;现在公开版的 ChatGPT 是基于大规模数据集预先训练好的模型，所以还不够个性化，但是 ChatGPT 是可以利用额外输入进行训练的，让其足够个性化。 原理可以参考：&lt;a href=&quot;https://github.com/openai/openai-cookbook/blob/main/examples/Question_answering_using_embeddings.ipynb&quot;&gt;Question_answering_using_embeddings&lt;/a&gt;, 通俗版解释可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s/EYGnSBPmVNzY2_KTSlubZQ&quot;&gt;ChatGPT：未来，你会被淘汰吗？&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;大家只需要理解，你给 ChatGPT 一个 PDF 文件，一个网页链接，ChatGPT 就可以理解输入的内容，对输入的内容进行总结，解释你的疑问，和你进行对话。&lt;/p&gt;
&lt;p&gt;进一步，我们如果把一个人在社交媒体上所有的聊天记录，他创作过的所有文章，图片，视频输入给 ChatGPT，ChatGPT 基本就可以学习到这个人的性格，说话风格，思考问题的方式。&lt;/p&gt;
&lt;p&gt;如果这样还不够准确，我们还可以把这个人看过的书籍，电影，成长经历等也输入给 ChatGPT，也就是说，让 ChatGPT 经历一遍这个人的教育，成长过程，让 ChatGPT 更懂这个人。&lt;/p&gt;
&lt;p&gt;如果这样还不够准确呢？你还可以像教育孩子一样，在和 ChatGPT 不断交流互动的过程中，不断训练他，告诉它什么是对的，什么是错的。&lt;/p&gt;
&lt;h3 id=&quot;22-whisper-让丫丫理解语音&quot;&gt;2.2 Whisper 让丫丫理解语音&lt;/h3&gt;
&lt;p&gt;Whisper 将语音转换给文本， 输入给 ChatGPT，语音识别技术已经很成熟了，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;23-elevenlabs-赋予丫丫语言能力&quot;&gt;2.3 ElevenLabs 赋予丫丫语言能力&lt;/h3&gt;
&lt;p&gt;ElevenLabs 可以生成语音，关键是可以定制化语音，也就是说你想要谁的语音，都可以定制，这个技术也比较成熟了，就不赘述了。&lt;/p&gt;
&lt;h3 id=&quot;24-midjourney-赋予丫丫形象&quot;&gt;2.4 Midjourney 赋予丫丫形象&lt;/h3&gt;
&lt;p&gt;Midjourney 等AI 绘画工具的绘画能力已经超过人类, 效果十分逆天, 大家可以自行体验。 &lt;/p&gt;
&lt;h2 id=&quot;三-丫丫-demo-show&quot;&gt;三 丫丫 Demo Show&lt;/h2&gt;
&lt;p&gt;目前我们只需要几百行代码，就可以构建出一个极简的 Demo 原型，接收人类的语音输入，ChatGPT 进行处理，并最终语音进行输出。我用网上的开源代码简单改了改，试了下。 这个应用的代码本身也是用 ChatGPT 写出来的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-1.png&quot; alt=&quot;12-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-2.png&quot; alt=&quot;12-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16786259781472/12-3.png&quot; alt=&quot;12-3&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四-丫丫类应用畅想&quot;&gt;四 丫丫类应用畅想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;寄托对逝者的思念：这也是丫丫在流浪地球电影中的本来作用&lt;/li&gt;
&lt;li&gt;私密倾诉：你可以制造一个你期望的人物和形象，然后和其进行私密聊天&lt;/li&gt;
&lt;li&gt;完美代替 Siri, 小冰，小度，小艺等语音助手&lt;/li&gt;
&lt;li&gt;在电影，电视剧，综艺节目等中引入一个有性格，有思想的虚拟人物&lt;/li&gt;
&lt;li&gt;游戏中的 NPC：玩家可以和 NPC 进行真实的互动，真正可以左右游戏的剧情&lt;/li&gt;
&lt;li&gt;成人应用和产业的全面升级&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;五-总结&quot;&gt;五 总结&lt;/h2&gt;
&lt;p&gt;目前这类个性化数字生命产品的大规模应用，我理解最大的障碍可能有两点：一个是成本，就是目前个性化训练的成本还是偏高；另一个就是数据隐私和安全，我们如何确保在网络世界里面我们的数据隐私不被泄露，甚至反过来伤害我们。&lt;/p&gt;

            &lt;hr/&gt;
            &lt;h3&gt;欢迎体验 免费 极速 无需翻墙的 ChatGPT&lt;/h3&gt;
            &lt;p&gt;&lt;a href=&quot;https://chat.bcmeng.com/&quot; target=&quot;_blank&quot;&gt;chat.bcmeng.com&lt;/a&gt;&lt;/p&gt;
            &lt;h3&gt;欢迎来知识星球和我交流&lt;/h3&gt;
            
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6de3366a21616cd9b1935a8f00e0ba1a</guid>
<title>浅谈 Kafka</title>
<link>https://toutiao.io/k/rxrrgf3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东科技 徐拥&lt;/p&gt;

&lt;h1&gt;入门&lt;/h1&gt;

&lt;h2&gt;1、什么是kafka?&lt;/h2&gt;

&lt;p&gt;apache Kafka is a distributed streaming platform. What exactly dose that mean?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-22Jtx0VcbUpPmiWcU.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Apache Kafka 是消息引擎系统，也是一个分布式流处理平台（Distributed Streaming Platform）&lt;/p&gt;

&lt;h2&gt;2、kafka全景图：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-23l6EiUjbO7wefuNY.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3、Kafka的版本演进：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-23NQEfKZPj7Z9ZIIr.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-26ANbXnBrbO6hP10eR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4、kafka选型:&lt;/h2&gt;

&lt;p&gt;Apache Kafka：也称社区版 Kafka。优势在于迭代速度快，社区响应度高，使用它可以让你有更高的把控度；缺陷在于仅提供基础核心组件，缺失一些高级的特性。（如果你仅仅需要一个消息引擎系统亦或是简单的流处理应用场景，同时需要对系统有较大把控度，那么我推荐你使用 Apache Kafka）&lt;/p&gt;

&lt;p&gt;Confluent Kafka ：Confluent 公司提供的 Kafka。优势在于集成了很多高级特性且由 Kafka 原班人马打造，质量上有保证；缺陷在于相关文档资料不全，普及率较低，没有太多可供参考的范例。（如果你需要用到 Kafka 的一些高级特性，那么推荐你使用 Confluent Kafka。）&lt;/p&gt;

&lt;p&gt;CDH/HDP Kafka：大数据云公司提供的 Kafka，内嵌 Apache Kafka。优势在于操作简单，节省运维成本；缺陷在于把控度低，演进速度较慢。（如果你需要快速地搭建消息引擎系统，或者你需要搭建的是多框架构成的数据平台且 Kafka 只是其中一个组件，那么我推荐你使用这些大数据云公司提供的 Kafka）&lt;/p&gt;

&lt;h2&gt;5、Kafka的基本概念：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-2710okuwPbjRFpspd10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6、Kafka的基本结构：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-27vXrCxEsmw9ULaPY.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;7、Kafka的集群结构：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-28AObChdjhewcHqNI.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;8、kafka的应用场景(用户注册/异步)：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-28TWOlj8JVcyqqXhu.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;9、kafka队列模式---点对点：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-29CSi3YckohCdK63X.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;10、kafka队列模式---发布/订阅：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-29jHAMnKmnRDqNWif.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;11、kafka构成角色：&lt;/h2&gt;

&lt;h3&gt;1、broker：&lt;/h3&gt;

&lt;p&gt;消息格式: 主题 - 分区 - 消息 、主题下的每条消息只会保存在某一个分区中，而不会在多个分区中被保存多份&lt;/p&gt;

&lt;p&gt;这样设计的原因是：不使用多topic做负载均衡，意义在于对业务屏蔽该逻辑。业务只需要对topic进行发送，指定负载均衡策略即可 同时 topic分区是实现负载均衡以及高吞吐量的关键&lt;/p&gt;

&lt;p&gt;Topic的创建流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-31gSYeRvLtLrYRtRe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、Producer：&lt;/h3&gt;

&lt;p&gt;发送消息流程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-35RQDxubChniY6eMg.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、Consumer：&lt;/h3&gt;

&lt;p&gt;Kafka消费者对象订阅主题并接收Kafka的消息，然后验证消息并保存结果。Kafka消费者是消费者组的一部分。一个消费者组里的消费者订阅的是同一个主题，每个消费者接收主题一部分分区的消息。消费者组的设计是对消费者进行的一个横向伸缩，用于解决消费者消费数据的速度跟不上生产者生产数据的速度的问题，通过增加消费者，让它们分担负载，分别处理部分分区的消息&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-35t33lQyxQsMO3hQha.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4、Consumer Group：&lt;/h3&gt;

&lt;p&gt;它是kafka提供的具有可扩展且可容错的消费者机制&lt;/p&gt;

&lt;p&gt;特性：&lt;/p&gt;

&lt;p&gt;1、 Consumer Group下可以有一个或多个 Consumer实例；&lt;/p&gt;

&lt;p&gt;2、在一个Katka集群中，Group ID标识唯一的一个Consumer Group;&lt;/p&gt;

&lt;p&gt;3、 Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的 某个Consumer实例消费。&lt;/p&gt;

&lt;p&gt;Consumer Group 两大模型：&lt;/p&gt;

&lt;p&gt;1、如果所有实例都属于同一个Group，那么它实现的是消息队列模型；&lt;/p&gt;

&lt;p&gt;2、如果所有实例分别属于不同的GrouD，那么它实现的就是发布/订阅模型。&lt;/p&gt;

&lt;h2&gt;12、Kafka的工作流程：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-36WpTSBX3aWjhpeln.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;13、Kafka常用命令：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-38dx10vVjFaJlOaM10F.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;进阶&lt;/h1&gt;

&lt;h2&gt;14、Kafka的文件存储机制—log：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-38nCwbM52rJw52c6b38r.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;15、Kafka的文件存储机制—分片/索引：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-11-15CEalWwbhc3VYeJi.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;16、Kafka的文件存储机制—index/log：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-396xy107lRrw10w3IG6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;17、kafka 如何支持百万QPS？&lt;/h2&gt;

&lt;h4&gt;顺序读写 :&lt;/h4&gt;

&lt;p&gt;生产者写入数据和消费者读取数据都是顺序读写的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-39kKaWvi639vyFQdK8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;Batch Data（数据批量处理）：&lt;/h4&gt;

&lt;p&gt;当消费者（consumer）需要消费数据时，首先想到的是消费者需要一条，kafka发送一条，消费者再要一条kafka再发送一条。但实际上 Kafka 不是这样做的，Kafka 耍小聪明了。Kafka 把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候 Kafka 直接把文件发送给消费者。比如说100万条消息放在一个文件中可能是10M的数据量，如果消费者和Kafka之间网络良好，10MB大概1秒就能发送完，既100万TPS，Kafka每秒处理了10万条消息。&lt;/p&gt;

&lt;h4&gt;MMAP（内存映射文件）：&lt;/h4&gt;

&lt;p&gt;MMAP也就是内存映射文件，在64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的 Page 来实现文件到物理内存的直接映射，完成映射之后对物理内存的操作会被同步到硬盘上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-41oY6b4110scQ9qlsRo.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过MMAP技术进程可以像读写硬盘一样读写内存（逻辑内存），不必关心内存的大小，因为有虚拟内存兜底。这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。也有一个很明显的缺陷，写到MMAP中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush 的时候才把数据真正的写到硬盘。&lt;/p&gt;

&lt;h4&gt;Zero Copy（零拷贝）：&lt;/h4&gt;

&lt;p&gt;如果不使用零拷贝技术，消费者（consumer）从Kafka消费数据，Kafka从磁盘读数据然后发送到网络上去，数据一共发生了四次传输的过程。其中两次是 DMA 的传输，另外两次，则是通过 CPU 控制的传输。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44nWpVwp6BRWIn6R9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：从硬盘上将数据读到操作系统内核的缓冲区里，这个传输是通过 DMA 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：从内核缓冲区里面的数据复制到分配的内存里面，这个传输是通过 CPU 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第三次传输&lt;/strong&gt;：从分配的内存里面再写到操作系统的 Socket 的缓冲区里面去，这个传输是由 CPU 搬运的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第四次传输&lt;/strong&gt;：从 Socket 的缓冲区里面写到网卡的缓冲区里面去，这个传输是通过 DMA 搬运的。&lt;/p&gt;

&lt;p&gt;实际上在kafka中只进行了两次数据传输，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44Q19s6oNOoiEaZr6z.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一次传输&lt;/strong&gt;：通过 DMA从硬盘直接读到操作系统内核的读缓冲区里面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第二次传输&lt;/strong&gt;：根据 Socket 的描述符信息直接从读缓冲区里面写入到网卡的缓冲区里面。&lt;/p&gt;

&lt;p&gt;我们可以看到同一份数据的传输次数从四次变成了两次，并且没有通过 CPU 来进行数据搬运，所有的数据都是通过 DMA 来进行传输的。没有在内存层面去复制（Copy）数据，这个方法称之为零拷贝（Zero-Copy）。&lt;/p&gt;

&lt;p&gt;无论传输数据量的大小，传输同样的数据使用了零拷贝能够缩短 65%的时间，大幅度提升了机器传输数据的吞吐量，这也是Kafka能够支持百万TPS的一个重要原因&lt;/p&gt;

&lt;h2&gt;18、压缩：&lt;/h2&gt;

&lt;h3&gt;特性：&lt;/h3&gt;

&lt;p&gt;节省网络传输带宽以及 Kafka Broker 端的磁盘占用。&lt;/p&gt;

&lt;h4&gt;生产者配置 ：&lt;/h4&gt;

&lt;p&gt;compression.type&lt;/p&gt;

&lt;p&gt;Properties props = new Properties();&lt;/p&gt;

&lt;p&gt;props.put(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;acks&quot;, &quot;all&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);&lt;/p&gt;

&lt;p&gt;props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);&lt;/p&gt;

&lt;p&gt;// 开启GZIP压缩&lt;/p&gt;

&lt;p&gt;props.put(&quot;compression.type&quot;, &quot;gzip&quot;);&lt;/p&gt;

&lt;p&gt;Producerproducer = new KafkaProducer&amp;lt;&amp;gt;(props)&lt;/p&gt;

&lt;h4&gt;broker开启压缩：&lt;/h4&gt;

&lt;p&gt;Broker 端也有一个参数叫 compression.type 默认值为none，这意味着发送的消息是未压缩的。否则，您指定支持的类​​型：gzip、snappy、lz4或zstd。 Producer 端压缩、Broker 端保持、Consumer 端解压缩。&lt;/p&gt;

&lt;h4&gt;broker何时压缩：&lt;/h4&gt;

&lt;p&gt;情况一：Broker 端指定了和 Producer 端不同的压缩算法。（风险：可能会发生预料之外的压缩 / 解压缩操作，表现为 Broker 端 CPU 使用率飙升）&lt;/p&gt;

&lt;p&gt;想象一个对话：&lt;/p&gt;

&lt;p&gt;Producer 说：“我要使用 GZIP 进行压缩。&lt;/p&gt;

&lt;p&gt;Broker 说：“不要，我这边接收的消息必须使用配置的 lz4 进行压缩&lt;/p&gt;

&lt;p&gt;情况二： Broker 端发生了消息格式转换 （风险：涉及额外压缩/解压缩，且 Kafka 丧失 Zero Copy 特性）&lt;/p&gt;

&lt;p&gt;Kafka 共有两大类消息格式，社区分别称之为 V1 版本和 V2 版本&lt;/p&gt;

&lt;p&gt;为了兼容老版本的格式，Broker 端会对新版本消息执行向老版本格式的转换。这个过程中会涉及消息的解压缩和重新压缩&lt;/p&gt;

&lt;h4&gt;消息何时解压缩：&lt;/h4&gt;

&lt;p&gt;Consumer：收到到压缩过的消息会解压缩还原成之前的消息。&lt;/p&gt;

&lt;p&gt;broker：收到producer的消息 压缩算法和自己的不一致/兼容新老版本的消息格式&lt;/p&gt;

&lt;h4&gt;压缩算法对比：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-44mofpyPt8XdgDacc.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以 Kafka 为例,吞吐量方面：LZ4 &amp;gt; Snappy &amp;gt; zstd 和 GZIP；压缩比方面，zstd &amp;gt; LZ4 &amp;gt; GZIP &amp;gt; Snappy；&lt;/p&gt;

&lt;p&gt;具体到物理资源，使用 Snappy 算法占用的网络带宽最多，zstd 最少，这是合理的，毕竟 zstd 就是要提供超高的压缩比；&lt;/p&gt;

&lt;p&gt;在 CPU 使用率方面，各个算法表现得差不多，只是在压缩时 Snappy 算法使用的 CPU 较多一些，而在解压缩时 GZIP 算法则可能使用更多的 CPU；&lt;/p&gt;

&lt;h2&gt;19、Exactly-Once（ACK应答机制）：&lt;/h2&gt;

&lt;h4&gt;1、At Least Once&lt;/h4&gt;

&lt;p&gt;最少发送一次，Ack级别为-1，保证数据不丢失&lt;/p&gt;

&lt;h4&gt;2、At Most Once&lt;/h4&gt;

&lt;p&gt;最多发送一次，Ack级别为1，保证数据不重复&lt;/p&gt;

&lt;h4&gt;3、幂等性&lt;/h4&gt;

&lt;p&gt;保证producer发送的数据在broker只持久化一条&lt;/p&gt;

&lt;h4&gt;4、Exactly Once（0.11版本）&lt;/h4&gt;

&lt;p&gt;At Least Once + 幂等性 = Exactly Once&lt;/p&gt;

&lt;p&gt;要启用幂等性，只需要将Producer的参数中 enable.idompotence设置为 true即可。 Kafka的幂等性实现其实就是将原来下游需要做的去重放在了数据上游。&lt;/p&gt;

&lt;h2&gt;20、producer如何获取metadata：&lt;/h2&gt;

&lt;p&gt;1：在创建KafkaProducer实例时 第一步：生产者应用会在后台创建并启动一个名为Sender的线程，&lt;/p&gt;

&lt;p&gt;2：该Sender线程开始运行时，首先会创建与Broker的连接。 第二步：此时不知道要连接哪个Broker，kafka会通过METADATA请求获取集群的元数据，连接所有的Broker。&lt;/p&gt;

&lt;p&gt;3：Producer 通过 metadata.max.age.ms定期更新元数据，在连接多个broker的情况下，producer的InFlightsRequests中维护着每个broker的等待回复消息的队列，等待数量越少说明broker处理速度越快，负载越小，就会发到哪个broker上&lt;/p&gt;

&lt;h2&gt;21、kafka真的会丢消息吗？&lt;/h2&gt;

&lt;h3&gt;kafka最优配置：&lt;/h3&gt;

&lt;h4&gt;Producer：&lt;/h4&gt;

&lt;p&gt;如果是Java客户端 建议使用 producer.send(msg, callback) ，callback（回调）它能准确地告诉你消息是否真的提交成功了。&lt;/p&gt;

&lt;p&gt;设置 acks = all。acks 是 Producer 的参数，如果设置成 all，需要所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。&lt;/p&gt;

&lt;p&gt;设置 retries 为一个较大的值。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &amp;gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。&lt;/p&gt;

&lt;h4&gt;Consumer：&lt;/h4&gt;

&lt;p&gt;消息消费完成再提交。Consumer 端有个参数 enable.auto.commit，最好把它设置成 false，并采用手动提交位移的方式。&lt;/p&gt;

&lt;h4&gt;broker ：&lt;/h4&gt;

&lt;p&gt;设置 unclean.leader.election.enable = false。它控制的是哪些 Broker 有资格竞选分区的 Leader。如果一个 Broker 落后原先的 Leader 太多，那么它一旦成为新的 Leader，必然会造成消息的丢失。故一般都要将该参数设置成 false，即不允许这种情况的发生。&lt;/p&gt;

&lt;p&gt;设置 replication.factor &amp;gt;= 3,目前防止消息丢失的主要机制就是冗余。&lt;/p&gt;

&lt;p&gt;设置 min.insync.replicas &amp;gt; 1,控制的是消息至少要被写入到多少个副本才算是“已提交”。设置成大于 1 可以提升消息持久性。在实际环境中千万不要使用默认值 1。 确保 replication.factor &amp;gt; min.insync.replicas。如果两者相等，那么只要有一个副本挂机，整个分区就无法正常工作了。我们不仅要改善消息的持久性，防止数据丢失，还要在不降低可用性的基础上完成。推荐设置成 replication.factor = min.insync.replicas + 1。&lt;/p&gt;

&lt;h2&gt;22、kafka Replica：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-45j45rFFVXnQKGPe6q.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本质就是一个只能追加写消息的提交日志。根据 Kafka 副本机制的定义，同一个分区下的所有副本保存有相同的消息序列，这些副本分散保存在不同的 Broker 上，从而能够对抗部分 Broker 宕机带来的数据不可用&lt;/p&gt;

&lt;h4&gt;3个特性：&lt;/h4&gt;

&lt;p&gt;第一，在 Kafka 中，副本分成两类：领导者副本（Leader Replica）和追随者副本（Follower Replica）。每个分区在创建时都要选举一个副本，称为领导者副本，其余的副本自动称为追随者副本。&lt;/p&gt;

&lt;p&gt;第二，Kafka 的副本机制比其他分布式系统要更严格一些。在 Kafka 中，追随者副本是不对外提供服务的。这就是说，任何一个追随者副本都不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理，或者说，所有的读写请求都必须发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。&lt;/p&gt;

&lt;p&gt;第三，当领导者副本挂掉了，或者说领导者副本所在的 Broker 宕机时，Kafka 依托于监控功能能够实时感知到，并立即开启新一轮的领导者选举，从追随者副本中选一个作为新的领导者。老 Leader 副本重启回来后，只能作为追随者副本加入到集群中。&lt;/p&gt;

&lt;h4&gt;意义： 方便实现“Read-your-writes”&lt;/h4&gt;

&lt;p&gt;（1）含义：当使用生产者API向Kafka成功写入消息后，马上使用消息者API去读取刚才生产的消息。 （2）如果允许追随者副本对外提供服务，由于副本同步是异步的，就可能因为数据同步时间差，从而使客户端看不到最新写入的消息。 B ：方便实现单调读（Monotonic Reads） （1）单调读：对于一个消费者用户而言，在多处消息消息时，他不会看到某条消息一会存在，一会不存在。 （2）如果允许追随者副本提供读服务，由于消息是异步的，则多个追随者副本的状态可能不一致。若客户端每次命中的副本不同，就可能出现一条消息一会看到，一会看不到&lt;/p&gt;

&lt;h2&gt;23、ISR（In-Sync Replica Set）LEO&amp;amp;HW 机制：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-466NUv9odkxoJwRBE.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HW(High Watermark)是所有副本中最小的LEO。&lt;/p&gt;

&lt;p&gt;比如： 一个分区有3个副本，一个leader，2个follower。producer向leader写了10条消息，follower1从leader处拷贝了5条消息，follower2从leader处拷贝了3条消息，那么leader副本的LEO就是10，HW=3；follower1副本的LEO就是5&lt;/p&gt;

&lt;p&gt;HW作用：保证消费数据的一致性和副本数据的一致性 通过HW机制。leader处的HW要等所有follower LEO都越过了才会前移&lt;/p&gt;

&lt;p&gt;ISR： 所有与leader副本保持一定程度同步的副本（包括leader副本在内）组成ISR（In-Sync Replicas）&lt;/p&gt;

&lt;h4&gt;1、Follower故障：&lt;/h4&gt;

&lt;p&gt;当follower挂掉之后，会被踢出ISR；&lt;/p&gt;

&lt;p&gt;当follower恢复后，会读取本地磁盘记录的HW，然后截掉HW之后的部分，从HW开始从leader继续同步数据，当该follower的LEO大于等于该partition的HW的时候，就是它追上leader的时候，会被重新加入到ISR中&lt;/p&gt;

&lt;h4&gt;2、Leader故障：&lt;/h4&gt;

&lt;p&gt;当leader故障之后，会从follower中选出新的leader，为保证多个副本之间的数据一致性，其余的follower会将各自HW之后的部分截掉（新leader如果没有那部分数据 follower就会截掉造成数据丢失），重新从leader开始同步数据，但是只能保证副本之间的数据一致性，并不能保证数据不重复或丢失。&lt;/p&gt;

&lt;h2&gt;24、Consumer分区分配策略：&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-46tJNocSIO10PCpGU6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;自定义分区策略：&lt;/h4&gt;

&lt;p&gt;你需要显式地配置生产者端的参数partitioner.class。这个参数该怎么设定呢？方法很简单，在编写生产者程序时，你可以编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner接口。这个接口也很简单，只定义了两个方法：partition()和close()，通常你只需要实现最重要的 partition 方法&lt;/p&gt;

&lt;p&gt;int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster){&lt;/p&gt;

&lt;p&gt;List&lt;partitioninfo&gt; partitions = cluster.partitionsForTopic(topic);&lt;/partitioninfo&gt;&lt;/p&gt;

&lt;p&gt;//随机&lt;/p&gt;

&lt;p&gt;//return ThreadLocalRandom.current().nextInt(partitions.size());&lt;/p&gt;

&lt;p&gt;//按消息键保序策略&lt;/p&gt;

&lt;p&gt;//return Math.abs(key.hashCode()) % partitions.size();&lt;/p&gt;

&lt;p&gt;//指定条件&lt;/p&gt;

&lt;p&gt;return partitions.stream().filter(Predicate(指定条件))).map(PartitionInfo::partition).findAny().get();&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;h2&gt;25、kafka中一个不为人知的topic：&lt;/h2&gt;

&lt;h4&gt;consumer_offsets：&lt;/h4&gt;

&lt;p&gt;老版本的Kafka会把位移信息保存在Zk中 ，但zk不适用于高频的写操作，这令zk集群性能严重下降，在新版本中将位移数据作为一条条普通的Kafka消息，提交至内部主题（_consumer_offsets）中保存，实现高持久性和高频写操作。&lt;/p&gt;

&lt;p&gt;位移主题每条消息内容格式：Group ID，主题名，分区号&lt;/p&gt;

&lt;p&gt;当Kafka集群中的第一个Consumer程序启动时，Kafka会自动创建位移主题。也可以手动创建 分区数依赖于Broker端的offsets.topic.num.partitions的取值，默认为50 副本数依赖于Broker端的offsets.topic.replication.factor的取值，默认为3&lt;/p&gt;

&lt;h4&gt;思考：&lt;/h4&gt;

&lt;p&gt;只要 Consumer 一直启动着，它就会无限期地向位移主题写入消息，就算没有新消息进来 也会通过定时任务重复写相同位移 最终撑爆磁盘？&lt;/p&gt;

&lt;p&gt;Kafka 提供了专门的后台线程定期地巡检待 Compact 的主题，看看是否存在满足条件的可删除数据，这个后台线程叫 Log Cleaner，对相同的key只保留最新的一条消息。&lt;/p&gt;

&lt;h2&gt;26、Consumer Group Rebalance：&lt;/h2&gt;

&lt;h4&gt;术语简介：&lt;/h4&gt;

&lt;p&gt;Rebalance ：就是让一个 Consumer Group 下所有的 Consumer 实例就如何消费订阅主题的所有分区达成共识的过程。&lt;/p&gt;

&lt;p&gt;Coordinator：它专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。&lt;/p&gt;

&lt;p&gt;Consumer 端应用程序在提交位移时，其实是向 Coordinator 所在的 Broker 提交位移。同样地，当 Consumer 应用启动时，也是向 Coordinator 所在的 Broker 发送各种请求，然后由 Coordinator 负责执行消费者组的注册、成员管理记录等元数据管理操作。&lt;/p&gt;

&lt;p&gt;如何确定Coordinator位置 ：partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount) 比如（abs(627841412 % 50)=12 Coordinator就在 partitionId=12的Leader 副本所在的 Broker）。&lt;/p&gt;

&lt;h4&gt;Rebalance的危害：&lt;/h4&gt;

&lt;p&gt;Rebalance 影响 Consumer 端 TPS 这期间不会工作&lt;/p&gt;

&lt;p&gt;Rebalance 很慢 Consumer越多 Rebalance时间越长&lt;/p&gt;

&lt;p&gt;Rebalance 效率不高 需要所有成员参与&lt;/p&gt;

&lt;h4&gt;触发 Rebalance场景：&lt;/h4&gt;

&lt;p&gt;组成员数量发生变化&lt;/p&gt;

&lt;p&gt;订阅主题数量发生变化&lt;/p&gt;

&lt;p&gt;订阅主题的分区数发生变化&lt;/p&gt;

&lt;h4&gt;如何避免 Rebalance：&lt;/h4&gt;

&lt;p&gt;设置 session.timeout.ms = 15s （session连接时间 默认10）&lt;/p&gt;

&lt;p&gt;设置 heartbeat.interval.ms = 2s（心跳时间）&lt;/p&gt;

&lt;p&gt;max.poll.interval.ms （取决你一批消息处理时长 默认5分钟）&lt;/p&gt;

&lt;p&gt;要保证 Consumer 实例在被判定为“dead”之前，能够发送至少 3 轮的心跳请求，即 session.timeout.ms &amp;gt;= 3 * heartbeat.interval.ms。&lt;/p&gt;

&lt;h2&gt;27、Kafka 拦截器：&lt;/h2&gt;

&lt;p&gt;Kafka 拦截器分为生产者拦截器和消费者拦截器，可以应用于包括客户端监控、端到端系统性能检测、消息审计等多种功能在内的场景。&lt;/p&gt;

&lt;p&gt;例：生产者Interceptor&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-03-06-10-47HQ1010RnGZGRYiXPx.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;部分图文资料地址&lt;/p&gt;

&lt;p&gt;-- 极客时间 Kafka 核心技术与实战&lt;/p&gt;

&lt;p&gt;--google&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>770313a345ab45d13e84b1e582fde733</guid>
<title>网易二面：CPU 狂飙 900%，该怎么处理？</title>
<link>https://toutiao.io/k/uazuhjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是不才陈某~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;星球&lt;/a&gt;&lt;span&gt;一位小伙伴面试了 网易，遇到了一个 性能类的面试题：CPU飙升900%，该怎么处理？&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;星球&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可惜的是，以上的问题，这个小伙没有回答理想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最终，导致他网易之路，终止在二面，非常可惜&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;首先，说明一下问题：CPU飙升200% 以上是生产容易发生的场景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景:1：MySQL进程飙升900%&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在使用MySQL过程，想必都有遇到过CPU突然过高，或者达到200%以上的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库执行查询或数据修改操作时，系统需要消耗大量的CPU资源维护从存储系统、内存数据中的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量大并且大量SQL性能低的情况下，比如字段是没有建立索引，则会导致快速CPU飙升，如果还开启了慢日志记录，会导致性能更加恶化。生产上有MYSQL 飙升900% 的恶劣情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景2：Java进程飙升900%&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说Java 进程不做大量 CPU 运算，正常情况下，CPU 应该在 100~200% 之间，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，一旦高并发场景，要么走到了死循环，要么就是在做大量的 GC,  容易出现这种 CPU 飙升的情况，CPU飙升900%，是完全有可能的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他场景：其他的类似进程飙升900%的场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如Redis、Nginx等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陈某提示：大家介绍场景的时候，就说自己主要涉及了两个场景， Java进程飙升900%、MySQL进程飙升900%两种场景，其实，这两个场景就足够讲半天了， 其他的，使用规避技巧规避一下就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景一：MySQL进程CPU飙升到900%，怎么处理？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定位过程：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用top 命令观察，确定是mysqld导致还是其他原因。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;处理过程：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;kill 掉这些线程(同时观察 cpu 使用率是否下降)， 一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;进行相应的调整(比如说加索引、改 sql、改内存参数)&lt;/p&gt;&lt;p&gt;index 是否缺失，如果是，则  建立索引。也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等；关注公z号：码猿技术专栏，回复关键词：1111 获取阿里内部Java性能调优手册&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;优化的过程，往往不是一步完成的，而是一步一步，执行一项优化措辞，再观察，再优化。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景1的真实案例：MySQL数据库优化的真实案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;陈某提示：以下案例，来自互联网。大家参考一下，准备一个自己的案例。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本问题亲身经历过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前开发同事编写的SQL语句，就导致过线上CPU过高，MySQL的CPU使用率达到900%+，通过优化最后降低到70%~80%。下面说说个人在这个过程中的排查思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们要对问题定位而不是盲目的开启什么 慢日志，在并发量大并且大量SQL性能低的情况下，开启慢日志无意是将MySQL推向崩溃的边缘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时遇到这个情况，分析了当前的数据量、索引情况、缓存使用情况。目测数据量不大，也就几百万条而已。接下来就去定位索引、缓存问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;经过询问，发现很多查询都是走MySQL，没有用到缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;既然没有用到缓存，则是大量请求全部查询MySQL导致。通过下面的命令查看:&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;processlist&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现类似很多相同的SQL语句，一直处于query状态中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;form&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; user_code = &lt;span&gt;&#x27;xxxxx&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步分析可能是 user_code 字段没有索引导致。接着查询user表的索引情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;show&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;form&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发现这个字段是没有建立索引。增加索引之后，该条SQL查询能够正常执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、没隔一会，又发生大量的请求超时问题。接着进行分析，发现是开启了 慢日志查询。大量的SQL查询语句超过慢日志设置的阀值，于是将慢日志关闭之后，速度瞬间提升。CPU的使用率基本保持在300%左右。但还不是理想状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、紧接着将部分实时查询数据的SQL语句，都通过缓存(redis)读写实现。观察一段时间后，基本维持在了70%~80%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结：其实本次事故的解决很简单，就是添加索引与缓存结合使用。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不推荐在这种CPU使用过高的情况下进行慢日志的开启。因为大量的请求，如果真是慢日志问题会发生日志磁盘写入，性能贼低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接通过MySQL show processlist命令查看，基本能清晰的定位出部分查询问题严重的SQL语句，在针对该SQL语句进行分析。一般可能就是索引、锁、查询大量字段、大表等问题导致。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再则一定要使用缓存系统，降低对MySQL的查询频次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于内存调优，也是一种解决方案。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;场景2展开：Java进程CPU飙升到900%，怎么处理？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定位过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU飙升问题定位的一般步骤是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先通过top指令查看当前占用CPU较高的进程PID；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看当前进程消耗资源的线程PID：top -Hp PID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过print命令将线程PID转为16进制，根据该16进制值去打印的堆栈日志内查询，查看该线程所驻留的方法位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过jstack命令，查看栈信息，定位到线程对应的具体代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分析代码解决问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;处理过程：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果是空循环，或者空自旋。&lt;/p&gt;&lt;p&gt;处理方式：可以使用Thread.sleep或者加锁，让线程适当的阻塞。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在循环的代码逻辑中，创建大量的新对象导致频繁GC。比如，从mysql查出了大量的数据，比如100W以上等等。&lt;/p&gt;&lt;p&gt;处理方式：可以减少对象的创建数量，或者，可以考虑使用 对象池。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;其他的一些造成CPU飙升的场景，比如  selector空轮训导致CPU飙升 。&lt;/p&gt;&lt;p&gt;处理方式：参考Netty源码，无效的事件查询到了一定的次数，进行 selector 重建。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java的CPU 飙升700%优化的真实案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;陈某提示：以下案例，来自互联网。大家参考一下，准备一个自己的案例。&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近负责的一个项目上线，运行一段时间后发现对应的进程竟然占用了700%的CPU，导致公司的物理服务器都不堪重负，频繁宕机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么,针对这类java进程CPU飙升的问题，我们一般要怎么去定位解决呢？、&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;采用top命令定位进程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录服务器，执行top命令，查看CPU占用情况，找到进程的pid&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;top&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2898148148148148&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsU2tVM8dOsJibl2SCB7OHhpMXGPKsUsR5ZZNaSxKtVBGhzSaJibD8lYicQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很容易发现，PID为29706的java进程的CPU飙升到700%多，且一直降不下来，很显然出现了问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用top -Hp命令定位线程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 top -Hp命令（为Java进程的id号）查看该Java进程内所有线程的资源占用情况（按shft+p按照cpu占用进行排序，按shift+m按照内存占用进行排序）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处按照cpu排序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;top -Hp 23602&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26481481481481484&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsq1qkRyxmOLicmKvSImHqqJD49yKIGxHY7p1ANhUuILpR1kRgFbGUgvw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很容易发现，多个线程的CPU占用达到了90%多。我们挑选线程号为30309的线程继续分析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用jstack命令定位代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.线程号转换5为16进制&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;printf “%x\n” 命令（tid指线程的id号）将以上10进制的线程号转换为16进制：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;printf &quot;%x\n&quot;  30309&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09907407407407408&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHs1fDmlmNLgGNEu6uX4Mq7gpXQvLCo4AsAHiaV1jGHAe2e3WXMK4qpxkQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换后的结果分别为7665，由于导出的线程快照中线程的nid是16进制的，而16进制以0x开头，所以对应的16进制的线程号nid为0x7665&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.采用jstack命令导出线程快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用dk自带命令jstack获取该java进程的线程快照并输入到文件中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; jstack -l 进程ID &amp;gt; ./jstack_result.txt &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令（为Java进程的id号）来获取线程快照结果并输入到指定文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstack -l 29706 &amp;gt; ./jstack_result.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.根据线程号定位具体代码&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在jstack_result.txt 文件中根据线程好nid搜索对应的线程描述&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat jstack_result.txt |grep -A 100  7665&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18703703703703703&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHskfKlGEOf6lL1ZMF0yEiapmNg4QLMOTsAc3DqKlMkcfBibUUgKhLLOGIg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据搜索结果，判断应该是ImageConverter.run()方法中的代码出现问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这里也可以直接采用&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstack &amp;lt;pid&amp;gt; |grep -A 200 &amp;lt;nid&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定位具体代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$jstack &lt;span&gt;44529&lt;/span&gt; |grep -A &lt;span&gt;200&lt;/span&gt; ae24&lt;br/&gt;&lt;span&gt;&quot;System Clock&quot;&lt;/span&gt; #&lt;span&gt;28&lt;/span&gt; daemon prio=&lt;span&gt;5&lt;/span&gt; os_prio=&lt;span&gt;0&lt;/span&gt; tid=&lt;span&gt;0x00007efc19e8e800&lt;/span&gt; nid=&lt;span&gt;0xae24&lt;/span&gt; waiting on condition [&lt;span&gt;0x00007efbe0d91000&lt;/span&gt;]&lt;br/&gt;   java.lang.Thread.State: TIMED_WAITING (sleeping)&lt;br/&gt;    at java.lang.Thread.sleep(Native Method)&lt;br/&gt;    at java.lang.Thread.sleep(Thread.java:&lt;span&gt;340&lt;/span&gt;)&lt;br/&gt;    at java.util.concurrentC.TimeUnit.sleep(TimeUnit.java:&lt;span&gt;386&lt;/span&gt;)&lt;br/&gt;    at com.*.order.Controller.OrderController.detail(OrderController.java:&lt;span&gt;37&lt;/span&gt;)  &lt;span&gt;//业务代码阻塞点&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析代码解决问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是ImageConverter.run()方法中的部分核心代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/存储minicap的socket连接返回的数据   (改用消息队列存储读到的流数据) ，设置阻塞队列长度，防止出现内存溢出&lt;br/&gt;&lt;span&gt;//全局变量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; BlockingQueue&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt; dataQueue = &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&lt;span&gt;byte&lt;/span&gt;[]&amp;gt;(&lt;span&gt;100000&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//消费线程&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//long start = System.currentTimeMillis();&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (isRunning) {&lt;br/&gt;        &lt;span&gt;//分析这里从LinkedBlockingQueue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (dataQueue.isEmpty()) {&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buffer = device.getMinicap().dataQueue.poll();&lt;br/&gt;       &lt;span&gt;int&lt;/span&gt; len = buffer.length;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在while循环中，不断读取堵塞队列dataQueue中的数据，如果数据为空，则执行continue进行下一次循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不为空，则通过poll()方法读取数据，做相关逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初看这段代码好像每什么问题，但是如果dataQueue对象长期为空的话，这里就会一直空循环，导致CPU飙升。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果解决呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析LinkedBlockingQueue阻塞队列的API发现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//取出队列中的头部元素，如果队列为空则调用此方法的线程被阻塞等待，直到有元素能被取出，如果等待过程被中断则抛出InterruptedException&lt;/span&gt;&lt;br/&gt;&lt;span&gt;E &lt;span&gt;take&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//取出队列中的头部元素，如果队列为空返回null&lt;/span&gt;&lt;br/&gt;&lt;span&gt;E &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种取值的API，显然take方法更时候这里的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码修改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt; (isRunning) {&lt;br/&gt;   &lt;span&gt;/* if (device.getMinicap().dataQueue.isEmpty()) {&lt;br/&gt;        continue;&lt;br/&gt;    }*/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;];&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        buffer = device.getMinicap().dataQueue.take();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;……&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重启项目后，测试发现项目运行稳定，对应项目进程的CPU消耗占比不到10%。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.287962962962963&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xlgvgPaib7WOKzrSSLzfB5yGN8uD3zCHsuQUr7MK2zNausticsJ4V54NvKj4UqxgJysRZFUA12ntrh7Otoib8P3bQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：技术自由圈&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后说一句（别白嫖，求关注）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;陈某每一篇文章都是精心输出，如果这篇文章对你有所帮助，或者有所启发的话，帮忙&lt;span&gt;点赞&lt;/span&gt;、&lt;span&gt;在看&lt;/span&gt;、&lt;span&gt;转发&lt;/span&gt;、&lt;span&gt;收藏&lt;/span&gt;，你的支持就是我坚持下去的最大动力！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外陈某的&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&amp;amp;mid=2247523057&amp;amp;idx=1&amp;amp;sn=32b42c6b0ac41b48785b7c0d24ce344a&amp;amp;chksm=fcf7453ccb80cc2a4a6cf38d5b9ab0354f09f270418bf4ff5eeb832b020aedabd561979b712d&amp;amp;token=1260267649&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;知识星球&lt;/a&gt;开通了，公众号回复关键词：&lt;span&gt;知识星球&lt;/span&gt; 获取限量&lt;span&gt;30元&lt;/span&gt;优惠券加入只需&lt;span&gt;89&lt;/span&gt;元，一顿饭钱，但是星球回馈的价值却是巨大，目前更新了&lt;span&gt;Spring全家桶实战系列&lt;/span&gt;、&lt;span&gt;亿级数据分库分表实战&lt;/span&gt;、&lt;span&gt;DDD微服务实战专栏&lt;/span&gt;、&lt;span&gt;我要进大厂、Spring，Mybatis等框架源码、架构实战22讲&lt;/span&gt;等....每增加一个专栏价格将上涨20元&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0398148148148147&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rBvqdy8J18dlib7KepGcvuW08g7COtYpQvVoZzRtQFLgaW1GxibV1vsWMQ27S4wsOlt1ySoh3uEAeIw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注公众号：【码猿技术专栏】，公众号内有超赞的粉丝福利，回复：加群，可以加入技术讨论群，和大家一起讨论技术，吹牛逼！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2be83f847845a2dfc191540d7c97353</guid>
<title>基于 TDesign 风格的 Blazor 企业级 UI 组件库</title>
<link>https://toutiao.io/k/5sftg5p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;32&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;欢迎加入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941843&amp;amp;idx=2&amp;amp;sn=b0c227cd42c2742affb0d46f1f5e686a&amp;amp;chksm=b1bb1b0686cc921049983cb46655a014f8bfb6c160e5a053e6e24234b09239f6465dbf02a725&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍.Net编程学习小圈子‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;.Net编程学习小圈子&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;，跟着学习路线，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;一起打卡交流学习。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;作为一名Web开发人员，开发前端少不了使用JavaScript，而Blazor就是微软推出的基于.net平台交互式客户 Web UI 框架，可以使用C#替代JavaScript，减少我们的技术栈、降低学习前端的成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而采用Blazor开发，少不了需要封装UI控件，所以今天给大家推荐一套基于&lt;span&gt;TDesign风格的Blazor企业级UI组件库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;项目简介&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;这是一套基于 TDesign 的 Blazor 企业级组件库，TDesign是腾讯内部经过多年提炼总结的，其UI漂亮、通用性较强，使用该框架，可以避免我们重复造轮子，帮助我们快速的完成项目的开发与交付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;项目特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、支持.Net 6、.Net 7；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、使用C#开发，可以直接调用.Net丰富的类库；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、基于TDesign风格，UI效果、交互体验都是非常好的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、可以与.Net MFC、Razor无缝的对接；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、支持主流的浏览器，IE只支持11+的版本，而且只支持服务端模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;项目结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.585278276481149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYcUh9RVjm4EjaGvvemBuxOVDScxUlTicuw5aaWQngYibyoIudZdQ4Cqgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;557&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文档项目&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.138235294117647&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYjK9dbC9IGVAwsEDhSLyicIzJPAybKIm9mtt4c1hMZYu3aJSwIFas7hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ServerSide服务端模式、WebAssembly客户端模式。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引入必要的样式、Js文件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.726148409893993&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYaNj9NlQ7Z43alzA9nvznlycUMCoBTA7L0YTInIzkB1tpXsz4XPIkCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;App.razor：增加组件&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43795620437956206&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYK3q3Vk5zxVRL0vIhRnzHp7TgEOc0SPTCQ7Z6vjVRGVV5yYGiadso1GQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;959&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;部分UI组件效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;按钮风格&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7413333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDY9nVlfPrppSTkRkl6OIfSQcKuQzIXH8XA4GGseCyf7v1qo2NO2k0ANA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;375&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;表单风格&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6820276497695853&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYOIK9hHqoEqNxbmvQictSQzSyMQEtN9P9Skb50cKE5ibicNkn4GmaX0yhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;选项卡&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40481927710843374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYZQrr8qKI28Wu3fL1wUa06Pxtt8ykAvVjpeZfe65AFGND7p8Shic4yibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;415&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;菜单导航&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.302504816955684&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYpLicjKrnibKAyJyq1eh6ibg8EOa79UVekVGmLgSrombk4u6LoZFe3yRSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;519&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.17671232876712328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDY4aX6slpOalhmicFlvahJaezict6MJEMicibYqf4rF01kFB1JD8xKdBhW7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;730&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;表格&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.43203230148048455&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDY2BmHWNficVhPXlpxR7DGjmiaHt7lnYMric4PgoXW0JIAu4yNT4VmX37ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;提示框&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4904891304347826&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYI5RGKbgfZibg9ScuRugvLdX0Jiav9Z4GblRrmzChibyL6ZicsKyZ4cA1rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对话框&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44630404463040446&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaqZJ7sPDhREhtBwiawSWzUDYfIUXFBnJWiauspF8Nz9klR3zzRjh7GDdH9LBcWVAr7tPTXtQTvIdwug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息通知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1602564102564104&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/r2zZqeGibAiaicrnicSXYJktvU8OTUibUXzI0HBiboxiayJlP7yZjwFYuGicHEp9XcLH8X6m4ZApD9HibetrVkdV7icCsEIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;468&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/AchievedOwner/TDesignBlazor&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; End -&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;欢迎加入 &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941843&amp;amp;idx=2&amp;amp;sn=b0c227cd42c2742affb0d46f1f5e686a&amp;amp;chksm=b1bb1b0686cc921049983cb46655a014f8bfb6c160e5a053e6e24234b09239f6465dbf02a725&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍.Net编程学习小圈子‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;&lt;span&gt;.Net编程学习小圈子&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt; &lt;span&gt;，获取海量的编程学习资源、学习路线，和大家一起打卡、分享编程知识、共同进步。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分享一套.NetCore从入门到精通视频教程&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击下方公众号卡片，关注我&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;回复“&lt;/span&gt;&lt;span&gt;888&lt;/span&gt;&lt;span&gt;”，免费领取&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5MDE5MDM5NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/tJJDa2wmJiaoiaJkdNNMfIKwQBC4fGYyxicqesxYXOCOOnGtiaibfu39oV4XbCUt6JewstuFjGQtjvzhX7hiaweZeYFA/0?wx_fmt=png&quot; data-nickname=&quot;编程乐趣&quot; data-alias=&quot;zhaobiaonews&quot; data-signature=&quot;专注分享.NET和.NET Core编程知识、有趣热门的开源项目。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;0&quot; data-origin_num=&quot;123&quot; data-isban=&quot;0&quot; data-weui-theme=&quot;light&quot; data-biz_account_status=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941870&amp;amp;idx=1&amp;amp;sn=acecf6d00bf12267ccfc7b7686224f4b&amp;amp;chksm=b1bb1b3b86cc922da197f2ddda1d85bf2707f67ebcdad9df514de8f74e96b829365d6afe921b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于.NET Core内置浏览器窗体应用程序界面框架&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;基于.NET Core内置浏览器窗体应用程序界面框架&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941445&amp;amp;idx=1&amp;amp;sn=9076498ed390894062a70b68b33c716e&amp;amp;chksm=b1bb1d9086cc9486842aef6577e8460cc9e6bf63f1809f03966be8cc12f9f1477849df4eebf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐一个Dapper扩展CRUD基本操作的开源库&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;推荐一个Dapper扩展CRUD基本操作的开源库&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941114&amp;amp;idx=1&amp;amp;sn=5bdba0e5811a9c37162b6e15a49ed9b0&amp;amp;chksm=b1bb1c2f86cc9539df97f886fd44a0fe438db4d604f08a576baa8eb67fcc04270add0db1c40d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一款统计摸鱼时长的开源项目&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;一款统计摸鱼时长的开源项目&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941358&amp;amp;idx=1&amp;amp;sn=6f7e68f6cac726c6742d4b0939d086e4&amp;amp;chksm=b1bb1d3b86cc942d680b10effe5054178da4b1d247b11a5c68bec6758c88de6a9fdf90b5c5be&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;基于.Net Core开发的支付SDK，简化支付功能开发&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;基于.Net Core开发的支付SDK，简化支付功能开发&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE5MDM5NA==&amp;amp;mid=2449941180&amp;amp;idx=1&amp;amp;sn=f8f6294d00c4a74e78c47ae38e177506&amp;amp;chksm=b1bb1ce986cc95ff653e023a108cbf752d2902e3e55bc74eccd72d7358ef6bc41b0961ef0952&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一个.Net简单、易用的配置文件操作库&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;一个.Net简单、易用的配置文件操作库&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得好看 点个在看👇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>