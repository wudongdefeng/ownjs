<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>25595eeeb439f808ba717c5046bbe5e8</guid>
<title>精华推荐 |【深入浅出Spring原理及实战】「原理分析专题」从源码和架构设计角度深入剖析BeanPostProcessor的原理和运作机制_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/foquo0z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;__0&quot;/&gt;🍃 前提概要&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;Spring具有很好的扩展性，但是这个扩展它的这个扩展性体现在哪里呢&lt;/strong&gt;？而我们要说的&lt;strong&gt;BeanPostProcessor&lt;/strong&gt;就是对Spring扩展性优秀的表现之一。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;_BeanPostProcessor_4&quot;/&gt;🍃 BeanPostProcessor的作用&lt;/h2&gt; 
 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;其操作对象为：已经实例化且进行了属性填充，待初始化的Bean实例&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;__12&quot;/&gt;🍃 源码分析&lt;/h2&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessor&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  
   &lt;span class=&quot;token annotation punctuation&quot;&gt;@Nullable&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
   &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   
   &lt;span class=&quot;token annotation punctuation&quot;&gt;@Nullable&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
   &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
 
&lt;h2&gt;&lt;a id=&quot;__40&quot;/&gt;🍃 如何使用&lt;/h2&gt; 
&lt;p&gt;BeanPostProcessorDemo代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessorDemo&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;DefaultListableBeanFactory&lt;/span&gt; beanFactory &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultListableBeanFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;XmlBeanDefinitionReader&lt;/span&gt; reader &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;XmlBeanDefinitionReader&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanFactory&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        reader&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;loadBeanDefinitions&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;spring-bean-post-processor.xml&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        beanFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addBeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserBeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt; user &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; beanFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;user&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Data&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; userName&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt; age&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beforeMessage&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; afterMessage&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;初始化:&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setUserName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;小明&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAge&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;UserBeanPostProcessor&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bean &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;初始化前:&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setBeforeMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;初始化前信息&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; 
&lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bean &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;初始化后:&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;User&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;setAfterMessage&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;初始化后信息&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;其他的省略…&lt;/p&gt; 
&lt;p&gt;运行之后打印结果如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;初始化前:User(userName=null, age=null, beforeMessage=null, afterMessage=null)
初始化:User(userName=null, age=null, beforeMessage=初始化前信息, afterMessage=null)
初始化后:User(userName=小明, age=18, beforeMessage=初始化前信息, afterMessage=null)
User(userName=小明, age=18, beforeMessage=初始化前信息, afterMessage=初始化后信息)
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面的代码很简单就是创建基础的容器，因为我这个里面用的是BeanFactory，BeanFactory作为基础容器是这里我采用手动将BeanPostProcessor注册到容器中去的。&lt;br/&gt; 同时也可以采用扫描或者定义的方式生成到容器中。&lt;/p&gt; 
&lt;p&gt;&lt;strong&gt;下面分析打印结果：&lt;/strong&gt;&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;初始化前:User(userName=null, age=null, beforeMessage=null, afterMessage=null)&lt;br/&gt; 该结果是postProcessBeforeInitialization方法中输出的内容，这个时候User实例还只是进行了实例化，还未进行到初始化步骤，&lt;strong&gt;所以所有的属性都为null,说明该方法确实是初始化执行的。&lt;/strong&gt;——&lt;strong&gt;（此时的初始化指的是bean对象的init方法）&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;初始化:User(userName=null, age=null, beforeMessage=初始化前信息, afterMessage=null)&lt;br/&gt; &lt;strong&gt;该结果为自定义的初始化方法initMethod方法中输出的内容，这个时候User实例真正初始化，而beforeMessage中中的值正是我们在postProcessBeforeInitialization设置的&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;初始化后:User(userName=小明, age=18, beforeMessage=初始化前信息, afterMessage=null)&lt;br/&gt; &lt;strong&gt;该结果是postProcessAfterInitialization中输出内容，从打印结果可以看出它的确是在自定义initMethod后。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;h2&gt;&lt;a id=&quot;__Spring_119&quot;/&gt;🍃 Spring的生命周期&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Spring中Bean总体上来说可以分为四个周期：&lt;strong&gt;实例化、属性赋值、初始化、销毁&lt;/strong&gt;。而BeanPostProcessor则是在初始化阶段的前后执行。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt;首先看&lt;strong&gt;AbstractAutowireCapableBeanFactory&lt;/strong&gt;中&lt;strong&gt;doCreateBean&lt;/strong&gt;方法，该方法实际就是&lt;strong&gt;创建指定Bean&lt;/strong&gt;的方法。 
  &lt;ul&gt;&lt;li&gt;其中三个重要的方法调用如下：&lt;strong&gt;createBeanInstance、populateBean、initializeBean&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;这三个方法分别代表了Spring Bean中的实例化、属性赋值和初始化三个生命周期。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;strong&gt;BeanPostProcessor是在初始化前后调用&lt;/strong&gt;，&lt;strong&gt;所以我们查看initializeBean中的方法详情即可&lt;/strong&gt;。该方法详情如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initializeBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token annotation punctuation&quot;&gt;@Nullable&lt;/span&gt; 
&lt;span class=&quot;token class-name&quot;&gt;RootBeanDefinition&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   
   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getSecurityManager&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token class-name&quot;&gt;AccessController&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;doPrivileged&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PrivilegedAction&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token function&quot;&gt;invokeAwareMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getAccessControlContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token function&quot;&gt;invokeAwareMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   
   &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; wrappedBean &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mbd &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isSynthetic&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      
      wrappedBean &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyBeanPostProcessorsBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;wrappedBean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      
      &lt;span class=&quot;token function&quot;&gt;invokeInitMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; wrappedBean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Throwable&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanCreationException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mbd &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getResourceDescription&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
            beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Invocation of init method failed&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mbd &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isSynthetic&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      
      wrappedBean &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyBeanPostProcessorsAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;wrappedBean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
   beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; wrappedBean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;从上面的源码可以看出首先是处理部分Aware相关接口，然后接着就是处理BeanPostProcessor中的postProcessBeforeInitialization方法，该方法详情如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyBeanPostProcessorsBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; existingBean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; existingBean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   
   &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessor&lt;/span&gt; processor &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getBeanPostProcessors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; processor&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      
   
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;该方法就是执行postProcessBeforeInitialization回调的详情内容，从该实现可以知道，BeanPostProcessor可以有多个，而且会按照顺序依次处理。&lt;strong&gt;如果只要其中的任意一个返回null，则后续的BeanPostProcessor的postProcessBeforeInitialization将不会再处理了。&lt;/strong&gt;&lt;/p&gt; 
&lt;p&gt;接着就是执行初始化方法，即invokeInitMethods方法被调用。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;invokeInitMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token annotation punctuation&quot;&gt;@Nullable&lt;/span&gt; 
&lt;span class=&quot;token class-name&quot;&gt;RootBeanDefinition&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Throwable&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; isInitializingBean &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bean &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;InitializingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isInitializingBean &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mbd &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;||&lt;/span&gt; 
   &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isExternallyManagedInitMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;afterPropertiesSet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;logger&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isTraceEnabled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         logger&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; beanName &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; 
 &lt;span class=&quot;token string&quot;&gt;&quot;&#x27;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getSecurityManager&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;AccessController&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;doPrivileged&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PrivilegedExceptionAction&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
               &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InitializingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
               &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getAccessControlContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PrivilegedActionException&lt;/span&gt; pae&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; pae&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InitializingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;afterPropertiesSet&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   
   &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;mbd &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;NullBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; initMethodName &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getInitMethodName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;StringUtils&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hasLength&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initMethodName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;isInitializingBean &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;afterPropertiesSet&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initMethodName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
            &lt;span class=&quot;token operator&quot;&gt;!&lt;/span&gt;mbd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isExternallyManagedInitMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;initMethodName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token function&quot;&gt;invokeCustomInitMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; mbd&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;applyBeanPostProcessorsAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; existingBean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; existingBean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessor&lt;/span&gt; processor &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getBeanPostProcessors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; current &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; processor&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;result&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;current &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
      result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; current&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; result&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;&lt;strong&gt;该方法与applyBeanPostProcessorsBeforeInitialization几乎就是相同的，不同的在于它执行的是postProcessAfterInitialization。至此Spring Bean的初始化也就完成了&lt;/strong&gt;。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f1142e12bf23bb05ab0f456649eef8a0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;_PostConstruct_259&quot;/&gt;🍃 @PostConstruct的支持&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;通过上面了解了Spring Bean生命周期中初始化的过程，但是实际上Spring对于JSR250也支持，例如对@PostConstruct注解的支持，但是在之前的源码中并没有发现Spring Bean的初始化过程中有所体现。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;这里面的秘密就是我们的BeanPostProcessor了。&lt;/p&gt; 
&lt;p&gt;在Spring中有一个&lt;strong&gt;CommonAnnotationBeanPostProcessor&lt;/strong&gt;类，这个类的注释中有说到这个类就是用来对JSR250及其他一些规范的支持。&lt;/p&gt; 
&lt;p&gt;下面我就通过这个类的源码来说明Spring是如何通过BeanPostProcessor来实现对@PostContruct的支持。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ccd42475897b4a5dbecb9ba4970e3b9c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;从上图中我们可以看出，CommonAnnotationBeanPostProcessor并没有直接对BeanPostProcessor有所实现，它继承InitDestroyAnnotationBeanPostProcessor该类，而对@PostConstruct的实现主要在该类中。&lt;br/&gt; &lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/475f5e4562375196d8fe0b37112693ba.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;而对BeanPostProcessor的实现代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   
   &lt;span class=&quot;token class-name&quot;&gt;LifecycleMetadata&lt;/span&gt; metadata &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;findLifecycleMetadata&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bean&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      
      metadata&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;invokeInitMethods&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;InvocationTargetException&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanCreationException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Invocation of init method failed&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getTargetException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Throwable&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;token keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanCreationException&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;beanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;Failed to invoke init method&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ex&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;对BeanPostProcessor的实现主要在before方法中，该方法主要就是两部分内容，第一部分主要是信息封装到LifecycleMetadata中，便于后面第二步的执行相关初始化方法。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;通过上面的方法实现我们知道了，Spring对JSR250的实现借助于BeanPostProcessor来实现的。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessorDemo2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;DefaultListableBeanFactory&lt;/span&gt; beanFactory &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultListableBeanFactory&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;AbstractBeanDefinition&lt;/span&gt; beanDefinition &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; 
&lt;span class=&quot;token class-name&quot;&gt;BeanDefinitionBuilder&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;genericBeanDefinition&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBeanDefinition&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        beanFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;registerBeanDefinition&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;person&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;beanDefinition&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;CommonAnnotationBeanPostProcessor&lt;/span&gt; commonAnnotationBeanPostProcessor 
&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;CommonAnnotationBeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        beanFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addBeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;commonAnnotationBeanPostProcessor&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt; person &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; beanFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;person&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Person&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@PostConstruct&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;annotationInitMethod&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;@PostConstruct&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;上面的代码比较简单，我们定义一个Person并使用@PostConstruct标记出它的初始化方法，然后我们创建BeanFactory，并创建Person的BeanDefinition将其注册到BeanFactory（与读取配置文件一样），然后我们创建&lt;strong&gt;CommonAnnotationBeanPostProcessor&lt;/strong&gt;并将其添加到BeanFactory中。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;最后打印结果打印出@PostConstruct。如果我们将下面这句代码注释。&lt;/li&gt;&lt;li&gt;beanFactory.addBeanPostProcessor(commonAnnotationBeanPostProcessor);&lt;/li&gt;&lt;li&gt;再次执行可以发现，@PostConstruct将会失效，且最后不会打印出结果。&lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;__340&quot;/&gt;🍃 顺序性&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;BeanPostProcessor是可以注册多个的，在AbstractBeanFactory内部通过List变量beanPostProcessors来存储BeanPostProcessor。而在执行时是按照List中BeanPostProcessor的顺序一个个执行的，所以我们在想容器中添加BeanPostProcessor时需要注意顺序。如果我们不是通过手动添加（大多数时候不是）时，而是在代码或者配置文件中定义多个BeanPostProcessor时，我们可以通过实现Ordered接口来控制它的顺序。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;BeanPostProcessor依赖的Bean不会执行BeanPostProcessor&lt;br/&gt; BeanPostProcessor依赖的Bean是不会执行BeanPostProcessor的，这是因为在创建BeanPostProcessor之所依赖的Bean就需要完成初始化，而这个时候BeanPostProcessor都还未完初始化完成。&lt;/p&gt; 
&lt;hr/&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;此外我们需要了解点：@PostConstruct 执行点(beforeInitialization) 要早于 afterProperitesSet(invokeInitMethod-1) 早于对应的Bean定义的initMethod（invokeinitiMethod-2）方法的执行。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;实例代码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;App3&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt; context &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; 
&lt;span class=&quot;token class-name&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;com.buydeem.beanpostprocessor&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;App3&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        context&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;refresh&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token annotation punctuation&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token annotation punctuation&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token annotation punctuation&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;MyBeanPostProcessor&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanPostProcessor&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ClassA&lt;/span&gt; classA&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;postProcessBeforeInitialization&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; beanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeansException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;MyBeanPostProcessor&quot;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;bean&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; bean&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;strong&gt;最后ClassA是不会打印出来的，而ClassB是会被打印出来。因为MyBeanPostProcessor依赖ClassA实例&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;__389&quot;/&gt;🍃 总结&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Spring中BeanPostProcessor的子接口或实现类有很多种，例如。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;strong&gt;InstantiationAwareBeanPostProcessor&lt;/strong&gt;、&lt;strong&gt;MergedBeanDefinitionPostProcessor&lt;/strong&gt;、&lt;strong&gt;DestructionAwareBeanPostProcessor等等&lt;/strong&gt;。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;这些接口分别处在Spring Bean生命周期的不同阶段，而他们的功能与BeanPostProcessor都类似，都是为了给Spring Bean各个声明周期提供扩展点。&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>091b14855423c759387ce01cf25c1e4a</guid>
<title>相较于RocketMQ的事务消息，本地消息表才是真正的王者</title>
<link>https://toutiao.io/k/ccnbfle</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 概览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，系统间的通信除了大家所熟知的 RPC 外，基于 MQ 的异步通信也越来越流行，已经成为基础设施的重要组成部分。而 MQ 的引入对系统间的数据一致性提出了新的挑战，逐渐成为系统稳定性的一大隐患。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1. 背景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1. 业务挑战&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;未接触过分布式的同学可能对其没有概念，当我们引入 MQ 后，MQ 与数据库操作存在一致性要求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单例子，一个业务操作中存在 “更新DB” 和 “发送 MQ” 两个动作，具体如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2651162790697674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPr4DPwJiah4V0JNo0Vu7nsRFianGq47sgRvTapdbBk7XH797uZIXjNpNrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot; title=&quot;biz_common.png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果流程正常结束，变更保存到 DB，Message 成功发送至 MQ，就不存在不一致的情况。但，如果中间发生异常，一致性就没有了保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在如下这个示例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9565217391304348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPrOrWS7UzL7TFYNqGsmEuHP9QVpeqrtHCg79gG7PfHoicYR6uFib0Q9QNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot; title=&quot;biz_error1.png&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;更新 DB 和 发送 MQ 被包在一个数据库事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在事务提交前，发送 MQ 之后出现了异常，将触发数据库事务回滚，此时&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;结果便是 Consumer 成功获取 Message 并进行业务处理，而 DB 回滚业务操作已经失败，下游处理了一个本不存在的变更。&lt;/section&gt;&lt;/li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们换个思路，数据库事务只对 DB 更新进行保护，示例如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9869281045751634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPrFJtyjibicWb0lstvkAkZgLbzvy5xttYgqjx0EDZZMWM75elggjaXwwDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot; title=&quot;biz_error2.png&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;仅将 数据库变更 包在一个数据库事务里；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在事务提交后，发送MQ 前出现了异常，此时&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;数据库变更已经成功持久化到 DB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而MQ发送失败，下游业务无法获取变更消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;最终导致丢失变更，未成功触发下游的正常业务；&lt;/section&gt;&lt;/li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有更复杂的场景，示例如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9194444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPrlRZvFGIQtkPdvqydNgFBfibIOpHrOKdaXflZ0LgrCqjD5n7iaZHYEdFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot; title=&quot;biz_fz_2.png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库变更 和 发送MQ 交替出现，又该如何保障其一致性呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2. 事务消息&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;众所周知，RocketMQ 提供事务消息机制，以完成业务操作与消息发送的一致性。但在实际使用过程中，复杂的 API 将逻辑切分的稀碎，增加了业务理解的难度，在实际开发中很少使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务消息整体流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28005115089514065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPrLWtpJlEaCnz8aQ8lvkMRyDA6lafu0T9B85uyOSaZkicCtiaGBUvsWagg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot; title=&quot;rocketmq.png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者将半事务消息发送至 RocketMQ Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocketMQ Broker 将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息暂不能投递，为半事务消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者开始执行本地事务逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者根据检查得到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。&lt;/section&gt;&lt;/li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保一致性，整个流程变得好复杂，不仅仅是流程，API 使用也晦涩难懂，示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransactionProducer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; MQClientException, InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 通过监听器在本地事务中处理业务逻辑，对异常发现进行检测并恢复状态&lt;/span&gt;&lt;br/&gt;        TransactionListener transactionListener = &lt;span&gt;new&lt;/span&gt; TransactionListenerImpl();&lt;br/&gt;        TransactionMQProducer producer = &lt;span&gt;new&lt;/span&gt; TransactionMQProducer(&lt;span&gt;&quot;please_rename_unique_group_name&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 为 Producer 设置监听器&lt;/span&gt;&lt;br/&gt;        producer.setTransactionListener(transactionListener);&lt;br/&gt;        producer.start();&lt;br/&gt;&lt;br/&gt;        String[] tags = &lt;span&gt;new&lt;/span&gt; String[] {&lt;span&gt;&quot;TagA&quot;&lt;/span&gt;, &lt;span&gt;&quot;TagB&quot;&lt;/span&gt;, &lt;span&gt;&quot;TagC&quot;&lt;/span&gt;, &lt;span&gt;&quot;TagD&quot;&lt;/span&gt;, &lt;span&gt;&quot;TagE&quot;&lt;/span&gt;};&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Message msg =&lt;br/&gt;                    &lt;span&gt;new&lt;/span&gt; Message(&lt;span&gt;&quot;TopicTest&quot;&lt;/span&gt;, tags[i % tags.length], &lt;span&gt;&quot;KEY&quot;&lt;/span&gt; + i,&lt;br/&gt;                        (&lt;span&gt;&quot;Hello RocketMQ &quot;&lt;/span&gt; + i).getBytes(RemotingHelper.DEFAULT_CHARSET));&lt;br/&gt;                &lt;span&gt;// 发送事务消息&lt;/span&gt;&lt;br/&gt;                SendResult sendResult = producer.sendMessageInTransaction(msg, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;                System.out.printf(&lt;span&gt;&quot;%s%n&quot;&lt;/span&gt;, sendResult);&lt;br/&gt;&lt;br/&gt;                Thread.sleep(&lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (MQClientException | UnsupportedEncodingException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100000&lt;/span&gt;; i++) {&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        producer.shutdown();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TransactionListenerImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;TransactionListener&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; AtomicInteger transactionIndex = &lt;span&gt;new&lt;/span&gt; AtomicInteger(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Integer&amp;gt; localTrans = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;// 在本地事务中执行业务逻辑，根据返回结果决定二次确认结果&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LocalTransactionState &lt;span&gt;executeLocalTransaction&lt;/span&gt;&lt;span&gt;(Message msg, Object arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; value = transactionIndex.getAndIncrement();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; status = value % &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;            localTrans.put(msg.getTransactionId(), status);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; LocalTransactionState.UNKNOW;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 网络出现异常后，未收到二次确认，对业务进行fan&#x27;cha&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; LocalTransactionState &lt;span&gt;checkLocalTransaction&lt;/span&gt;&lt;span&gt;(MessageExt msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            Integer status = localTrans.get(msg.getTransactionId());&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != status) {&lt;br/&gt;                &lt;span&gt;switch&lt;/span&gt; (status) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; LocalTransactionState.UNKNOW;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; LocalTransactionState.COMMIT_MESSAGE;&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; LocalTransactionState.ROLLBACK_MESSAGE;&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; LocalTransactionState.COMMIT_MESSAGE;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; LocalTransactionState.COMMIT_MESSAGE;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单看代码很难理解，简单画了张图，具体如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.947242206235012&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYPrTia3M9030e5UBToIyPCXhibvrKPXM9KOo8fN1ZkjCwg4RSiaLYaQBRxsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot; title=&quot;code.png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其核心部分就是 &lt;code&gt;TransactionListener&lt;/code&gt; 实现，其他部分与正常的消息发送基本一致，&lt;code&gt;TransactionListener&lt;/code&gt; 主要完成：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;执行本地事务，也就是业务操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行结果检测，通过反查业务数据，决定消息的后续处理策略；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使用事务消息，我们不得不在&lt;code&gt;TransactionListener&lt;/code&gt;中编写进行大量的适配逻辑，增加研发成本，同时由于逻辑被拆分到多处，也增加了代码的理解成本。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;RocketMQ 的事务消息通过回查方式对消息进行补充，是一个非常好的设计理念。但，其 API 过于复杂，在实际开发中很少使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2. 目标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不要 RocketMQ 的复杂性，还要 RocketMQ 的一致性，另一个优秀的替代方案便是本地消息表。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;保障消息发送与业务操作之间的强一致；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供简单通用 API，降低使用门槛；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供简洁配置方法，降低接入成本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供补偿策略，保障至少一次发送；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 快速入门&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1. 环境准备&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，在 pom 中引入 lego-starter&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.geekhalo.lego&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;lego-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.1.12-reliable_message_sender-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，在数据库中新增本地消息表，具体sql如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; test_message&lt;br/&gt;(&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt;           &lt;span&gt;bigint&lt;/span&gt; auto_increment primary &lt;span&gt;key&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    orderly      &lt;span&gt;tinyint&lt;/span&gt;      &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;是否为顺序消息&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    topic        &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)  &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;MQ topic&#x27;&lt;/span&gt;,&lt;br/&gt;    sharding_key &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;ShardingKey，用于选择不同的 partition&#x27;&lt;/span&gt;,&lt;br/&gt;    tag          &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;128&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;Message Tag 信息&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    msg_id       &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)  &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;Msg ID 只有发送成功后才有数据&#x27;&lt;/span&gt;,&lt;br/&gt;    msg_key      &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;64&lt;/span&gt;)  &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;MSG Key，用于查询数据&#x27;&lt;/span&gt;,&lt;br/&gt;    msg          longtext     &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;要发送的消息&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    retry_time   &lt;span&gt;tinyint&lt;/span&gt;      &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;重试次数&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;status&lt;/span&gt;       &lt;span&gt;tinyint&lt;/span&gt;      &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;发送状态:0-初始化，1-发送成功，2-发送失败&#x27;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    create_time  datetime     &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    update_time  datetime     &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;index&lt;/span&gt; idx_update_time_status(update_time, &lt;span&gt;status&lt;/span&gt;)&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要一个执行消息发送逻辑的 &lt;code&gt;MessageSender&lt;/code&gt;，为了测试方便，先进行 Mock，具体如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestMessageSender&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MessageSender&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; error = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Message&amp;gt; messages = Lists.newArrayList();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;send&lt;/span&gt;&lt;span&gt;(Message message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;receive message {}&quot;&lt;/span&gt;, message);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.error){&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.messages.add(message);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; String.valueOf(RandomUtils.nextLong());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;clean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.messages.clear();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;markError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.error = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;cleanError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.error = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，新建 &lt;code&gt;LocalTableBasedReliableMessageConfiguration&lt;/code&gt; 对本地消息表进行配置，具体如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LocalTableBasedReliableMessageConfiguration&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LocalTableBasedReliableMessageConfigurationSupport&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; DataSource dataSource;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MessageSender messageSender;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; DataSource &lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.dataSource;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;messageTable&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;test_message&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; MessageSender &lt;span&gt;createMessageSend&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.messageSender;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;继承自 &lt;code&gt;LocalTableBasedReliableMessageConfigurationSupport&lt;/code&gt;，由父类完成基本配置；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现 &lt;code&gt;DataSource dataSource()&lt;/code&gt; 方法，返回业务数据源（备注：必须与业务使用同一个数据源）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现 &lt;code&gt;String messageTable()&lt;/code&gt; 方法，配置本地消息表表名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实现 &lt;code&gt;MessageSender createMessageSend()&lt;/code&gt; 方法，返回 &lt;code&gt;MessageSender&lt;/code&gt; 实例，执行真正的消费发送；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，完成了所有配置工作，可以使用相关API进行消息处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ReliableMessageSender#send&lt;/code&gt; 在业务方法中使用，执行可靠消息发送；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ReliableMessageCompensator#compensate&lt;/code&gt; 周期性调度，对未发送或发送失败的消息进行补充；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2. 正常发送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;reliableMessageSender&lt;/code&gt; 的 send 方法执行可靠消息发送，具体如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testSuccess&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    Message message = buildMessage();&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageSender.send(message);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@Transactional&lt;/code&gt; 注解保障 业务逻辑 和 消费发送 在同一个事物中进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试用例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testTestSuccess&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSenderService.testSuccess();&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Message&amp;gt; messages = &lt;span&gt;this&lt;/span&gt;.testMessageSender.getMessages();&lt;br/&gt;    Assertions.assertTrue(CollectionUtils.isNotEmpty(messages));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在方法成功执行后，&lt;code&gt;TestMessageSender&lt;/code&gt; 收到消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3. 异常回滚&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务执行失败，事务自动发生回滚，不会触发消息发送。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    Message message = buildMessage();&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageSender.send(message);&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑和 &lt;code&gt;testSuccess&lt;/code&gt; 基本一致，只是在执行最后抛出 &lt;code&gt;RuntimeException&lt;/code&gt;，触发事务回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testTestError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; error = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.testMessageSenderService.testError();&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;        error = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Assertions.assertTrue(error);&lt;br/&gt;&lt;br/&gt;    List&amp;lt;Message&amp;gt; messages = &lt;span&gt;this&lt;/span&gt;.testMessageSender.getMessages();&lt;br/&gt;    Assertions.assertTrue(CollectionUtils.isEmpty(messages));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务回滚，&lt;code&gt;TestMessageSender&lt;/code&gt; 未收到消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4. 直接发送（不建议）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 &lt;code&gt;ReliableMessageSender#send &lt;/code&gt;未运行在事务内，方法调用时会直接发送消息，不能做到业务操作和消息发送的强一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testNoTransaction&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    Message message = buildMessage();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageSender.send(message);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testNoTransactionError&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 业务逻辑&lt;/span&gt;&lt;br/&gt;    Message message = buildMessage();&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageSender.send(message);&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之前代码相比，只是移除了 &lt;code&gt;@Transaction&lt;/code&gt; 注解，导致方法无法受到事务的保护。
测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testNoTransaction&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSenderService.testNoTransaction();&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        List&amp;lt;Message&amp;gt; messages = &lt;span&gt;this&lt;/span&gt;.testMessageSender.getMessages();&lt;br/&gt;        Assertions.assertTrue(CollectionUtils.isNotEmpty(messages));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSender.clean();&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; error = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.testMessageSenderService.testNoTransactionError();&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt; (Exception e){&lt;br/&gt;        error = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Assertions.assertTrue(error);&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        List&amp;lt;Message&amp;gt; messages = &lt;span&gt;this&lt;/span&gt;.testMessageSender.getMessages();&lt;br/&gt;        Assertions.assertTrue(CollectionUtils.isNotEmpty(messages));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论成功还是失败，&lt;code&gt;TestMessageSender&lt;/code&gt; 都收到了消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5. 消息补偿&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 MQ 服务器不可用导致消息发送失败，不应该影响正常的业务逻辑。而是周期性对未发送或发送失败的消息进行补充，及执行重新发送逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;loadAndSend&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 处理消费表中待发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageCompensator.compensate(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;120&lt;/span&gt;), &lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 进行 error 标记， MessageSender 发送请求直接失败&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSender.markError();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++){&lt;br/&gt;        &lt;span&gt;// 执行业务逻辑，业务逻辑不受影响&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.testMessageSenderService.testSuccess();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 清理 error 标记，MessageSender 正常发送&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSender.cleanError();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;// 检测消息表中存在待处理的任务&lt;/span&gt;&lt;br/&gt;        List&amp;lt;LocalMessage&amp;gt; localMessages = localMessageRepository.loadNotSuccessByUpdateGt(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;60&lt;/span&gt;), &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;        Assertions.assertEquals(&lt;span&gt;10&lt;/span&gt;, localMessages.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 对消息进行补充处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageCompensator.compensate(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;60&lt;/span&gt;), &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;//  由于时间限制，未处理消息表的任务&lt;/span&gt;&lt;br/&gt;        List&amp;lt;LocalMessage&amp;gt; localMessages = localMessageRepository.loadNotSuccessByUpdateGt(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;60&lt;/span&gt;), &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;        Assertions.assertEquals(&lt;span&gt;10&lt;/span&gt;, localMessages.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 等待时间超时&lt;/span&gt;&lt;br/&gt;    TimeUnit.SECONDS.sleep(&lt;span&gt;15&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.testMessageSender.clean();&lt;br/&gt;    &lt;span&gt;// 对消息进行补充处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.reliableMessageCompensator.compensate(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;60&lt;/span&gt;), &lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;//  成功处理消息表的待处理任务&lt;/span&gt;&lt;br/&gt;        List&amp;lt;LocalMessage&amp;gt; localMessages = localMessageRepository.loadNotSuccessByUpdateGt(DateUtils.addSeconds(&lt;span&gt;new&lt;/span&gt; Date(), -&lt;span&gt;60&lt;/span&gt;), &lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;        Assertions.assertEquals(&lt;span&gt;0&lt;/span&gt;, localMessages.size());&lt;br/&gt;&lt;br/&gt;        List&amp;lt;Message&amp;gt; messages = &lt;span&gt;this&lt;/span&gt;.testMessageSender.getMessages();&lt;br/&gt;        Assertions.assertTrue(CollectionUtils.isNotEmpty(messages));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试用例中可以得出几个结论：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息发送异常不影响正常的业务逻辑；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;未避免刚插入的消息被补偿逻辑消费，近10秒内的消息不会进行自动补充；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;消息成功发送后，消息表状态被更新，从而避免重复发送；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 设计&amp;amp;扩展&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1. 核心设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;整体架构如下：&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4878048780487805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudGkFvTE2XzicbiaqN8ibSFYProdmGibSNS89LTWy8z6kwxQe3y2KUtA2wziaIzzfDKibVNibcSsBnw6uytg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot; title=&quot;overview.png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务操作流程如下：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;应用程序接收外部业务请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行业务逻辑，将业务对象变更保存的业务表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;构建事件对象，将事件对象插入到本地消息表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提交本地事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;触发发送流程，调用 MQ 的发送接口，发送消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息成功发送后，更新消息表的状态，并补写 msgId；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;最终结果：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;本地事务提交失败，业务表和消息表的变更被回滚，不会触发发送逻辑；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地事务提交成功，消息发送失败，后台定时器会进行自动补偿；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;补偿流程如下：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Timer 周期性触发补偿逻辑；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从消息表中加载未发送或发送失败的消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用发送接口，将消息发送至 MQ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统发送成功后，更新消息表的状态；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2. 合理使用 TransactionSynchronizationManager&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;TransactionSynchronizationManager&lt;/code&gt; 是 Spring 框架提供的一种 事务同步机制，通过 &lt;code&gt;registerSynchronization&lt;/code&gt; 方法可以向 &lt;code&gt;TransactionSynchronizationManager&lt;/code&gt; 注册自定义逻辑，在事务操作的不同阶段调用不同的回调函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lego 就是通过该机制重写 &lt;code&gt;afterCommit&lt;/code&gt; 方法，在事务成功提交后，触发消息发送逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;addCallbackOrRunTask&lt;/span&gt;&lt;span&gt;(SendMessageTask sendMessageTask)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (TransactionSynchronizationManager.isSynchronizationActive()) {&lt;br/&gt;        &lt;span&gt;// 添加监听器，在事务提交后触发后续任务&lt;/span&gt;&lt;br/&gt;        TransactionSynchronization transactionSynchronization = &lt;span&gt;new&lt;/span&gt; TransactionSynchronizationAdapter(){&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterCommit&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                sendMessageTask.run();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);&lt;br/&gt;        log.info(&lt;span&gt;&quot;success to register synchronization for message {}&quot;&lt;/span&gt;, sendMessageTask.getLocalMessage());&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 没有可以事务，直接触发后续任务&lt;/span&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;No Transaction !!! begin to run task for message {}&quot;&lt;/span&gt;, sendMessageTask.getLocalMessage());&lt;br/&gt;        sendMessageTask.run();&lt;br/&gt;        log.info(&lt;span&gt;&quot;No Transaction !!! success to run task for message {}&quot;&lt;/span&gt;, sendMessageTask.getLocalMessage());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 项目信息&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目仓库地址：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://gitee.com/litao851025/lego&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目文档地址：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://gitee.com/litao851025/lego/wikis/support/reliable-message&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00a6e1d6986f7bdfa032794f016e738e</guid>
<title>bilibili分布式数据库演进之道</title>
<link>https://toutiao.io/k/w18rcuv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;一、业务场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在开始讲解之前，我先为大家介绍一下B站的业务场景。B站的业务大体上可以分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、点播类业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点播类业务就是大家经常看的视频以及稿件之类相关的业务，这类数据使用场景的特点有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、直播类业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直播类业务对应B站的S12、跨晚、拜年祭等，有以下几个特点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据一致性要求较高&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;热点数据，如S12的主播房间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;平时流量中等，大型直播流量会呈现爆炸性增长&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可用性要求高&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、游戏类业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、电商类业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如B站本身的会员购，这类业务的要求如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据一致性要求较高&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;热点数据，集中在秒杀场景及热门番剧&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;平时流量中等，热门番剧及商品会呈现爆炸性增长&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可用性要求高&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;5、支付类业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;二、架构演进&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;介绍完B站的业务场景之后，接下来是B站整体数据库的架构演进历史。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、1.0阶段&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHbl8GOIS8RXdJXXdxTAro52tPEhwHa8Mwk8XuDlZjib1nEEdslDAoSQw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.0阶段对于所有互联网公司而言，其实都有类似的架构——简单的主从，所有流量集中在一个主库上。另外，与以前使用的商业数据库类似场景——单实例多库。这种架构在公司刚起步的时候是比较方便的，便于业务的快速迭代，但是随着流量的增长，会出现以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）单机的性能瓶颈&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务器的CPU、内存、存储的限制我们不可能一直垂直升级，从而出现了我们第一个架构演进的小版本——读写分离和一主多从，此场景有两个核心要求：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;满足以上两个要求的场景可以很好地规避因MySQL主从复制存在的延迟所带来的问题，同时又可以满足业务快速增长带来的流量压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）各业务互相影响&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着业务的发展，各个业务之间的互相影响推动了我们架构的第二个小版本出现——按照业务库进行迁移拆分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHRiaJhVjibYKeoFNaNiaWzjsKwWCvMxap6b7vVoV0edDPDb6ECgUOknVPQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于读写分离和业务库维度的拆分还是无法避免各个功能模块的互相影响。在这种情况下，架构1.0阶段的第三个小版本应运而生——基于业务的功能维度进行拆分，将一个X库拆分为n个库，拆分完之后分布在不同的实例。在每个不同的实例下，我们会有不同数量的从库支撑业务的流量增长，以满足大部分场景的业务需求。现在B站也有很多业务采用类似的架构，通过进行垂直业务拆分满足我们的业务增长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、2.0阶段&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHNpt8JibEwXqpbIrRHjY9Y1hmspQbRT6x6zQWTl2bz8NUhRtsmviaIKqA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构2.0阶段——水平拆分。成熟、稳定、定制的Proxy是水平拆分的利器，而一个符合要求的Proxy是需要时间进行打磨。为满足业务的快速发展，我们选择在业务层实现，也就是我们在代码层实现路由，虽然配置时会比较繁琐，但能够满足大部分业务场景，很多互联网公司也有类似的阶段。在业务侧进行水平拆分之后，我们其实面临着一个新的问题——&lt;strong&gt;跨实例查询&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、3.0阶段&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）第一个阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEH6TvuusCqHjnaajWYialHGkCYHETicF0oG94qJYhHZnc4sHSTGyff2Zug/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入B站演进的3.0阶段，我们引入了TiDB，将之前业务层面的分片数据通过TiDB本身的DTS同步到TiDB集群，从而满足了大部分业务的查询需求。同时我们在部分场景的业务下直接尝试使用TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入TiDB之后，基于B站的特点，我们对其进行了本地化定制。由于TiDB Server是无状态的，而官方对于如何路由到每个节点也没有一个通用的解决方案。因此我们结合 B站的基础平台能力，将TiDB Server全部在PaaS上进行容器化，同时把我们的服务发现能力和TiDB Server进行整合，并对相应语言的SDK进行改造，从而实现了TiDB Server的负载均衡，解决了TiDB Server本身的瓶颈，如：故障切换、业务快速感知节点变化、连接数等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）第二个阶段&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHXw5BmeCbic6C2raibuI9agSe1ribFkHysUUpJgOAyzwibMjppQRKUjHibBA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了3.0的第二个阶段，我们已经把Proxy打磨为一个很成熟的产品，同时为满足支撑了异地多活的场景，我们还定制了DTS，把我们数据库的部署从同城多活直接做到了异地多活，也就是两地三中心的架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，在DTS方面，我们也基于B站本身技术栈的特点做了大量的定制，与其它公司开源的组件有部分不同。例如冲突检测，我们提供了多种可选择的规则，包括基于特定字段的以及全字段匹配的，同时对于冲突字段数据的R数据处理，我们一般会有两种途径：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，在主从切换的时候，由于两地三中心要保证数据可以进行来回切换，切换期间虽然是全局进行，但是一些边缘场景下仍然会存在数据冲突的问题。所以我们也提供了一个在主从切换下数据冲突以及相关信息的打捞队列，实现二次处理的功能，这也是我们中间 DTS提供的一个能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;Proxy的能力与各家主流的功能是类似的，都能够支持读写分离、分库分表、限流、黑白名单等。对于Proxy的部署，我们采取了两种方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;三、架构设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来为大家介绍的是B站对于不同数据量的场景的架构设计理念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、大型直播活动&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体概括起来有以下四种类型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）高并发写入&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高并发写入考验的是主库的写入能力和从库的复制能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）高并发查询&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高并发查询一般都会引入缓存的能力，缓存主要涉及以下几种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）实时排序&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时排序最直观的场景就是观众在直播间刷礼物的时候展示出来的名次，为保证时效性以及顺序，我们一般会采用Redis有序集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）预期外突发流量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预期外突发流量对于我们而言考验的主要是应用层的快速扩容以及如何对流量进行削峰，同时保证数据库比较平稳地写入，也就是异步写入的场景。今年最明显的预期外突发流量场景是佩洛西事件，比我们平常的流量大了将近5倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、电商大促&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体上归纳下来有以下几个特点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）秒杀场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;秒杀场景主要涉及合适的选型和请求最简化。基于公司的基建进行定制，才可以实现最好的性能和体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）订单&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;订单有很明显的冷热数据特征。一般情况下，我们的订单会被进行一年前、两年前以及实时订单的不同拆分。这块对于数据库而言考验的是数据的归档及查询能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）库存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库存与秒杀场景存在一定关联，但并不是完全相关。秒杀场景会涉及到库存，但是库存在平常也会一直使用，因此两者不能进行强挂钩。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;库存场景主要在于保证减库存的准确性，以及减少用户端在访问时可能存在的冲突，另外是一致性的问题，也就是在秒杀和减库存时不能出现超卖的情况，避免对商家造成亏本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）流量削峰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流量削峰与大型直播赛事遇到的突发流量是不同的，因为这一部分流量是我们已知的，已经预估好会有多少流量，因此我们一般会进行队列处理以及做分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了大型直播赛事和电商大促两个典型场景，我们做了一部分数据库架构设计以及与应用端的联动。下面介绍我们真正进行数据库架构设计时，需要考虑哪些关键点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、数据&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先需要考虑数据，按照我们数据类型的使用场景，我们可以将数据分为以下三种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）配置型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;配置型类似于我们的数据字典以及一些权限配置，特点包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果需要对配置型数据进行高并发访问，只需要加缓存即可，不需要做过多处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）日志型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日志型数据包括交易流水、订单状态等，我认为日志型数据也可以称为流水型数据，特点包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;量大：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;无法避免，因为我们需要记录中间各部状态；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;无事务依赖：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们后续进行的更多是查询而很少更改；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;写多读少：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;读的比例一般是写的几十分之一。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）状态型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据量：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;与业务有关，状态型数据可以理解为我们的订单，以及直播场景里刷礼物的扣减情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;事务强依赖：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;必须保证用户下单成功之后的库存扣减，以及用户给主播打赏之后平台的扣减和主播收到的礼物；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;读多写多：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;与用户的进程挂钩，写和读的场景都比较多。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，对于数据一般通过数据量、事务和读写请求三个维度进行判断，从而对数据进行规整和梳理，对比上述我列出的三种数据类型，可以得出数据的特定类型。有了数据类型之后，我们就可以考虑进行下一个阶段，即业务对数据库的要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、业务&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务对数据库选型的要求相对而言比较多，包括事务、性能、扩缩容、高可用、迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对事务的要求需要基于数据类型进行判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一些业务对耗时比较敏感，也就是性能要求比较高，要求必须在多少毫秒以内将数据结果反馈回来。那么在进行数据库选型时，我们需要考虑该数据库能否承载这么高的性能反应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）扩缩容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果业务要上一个新业务，要考虑满足一年至两年的增长的需求，因此数据库的扩缩容能力非常重要。如果之前申请的数据量比较大，但是业务发展没有达到预期，那么数据库需要缩容，所以这一方面对于数据库选型也是有要求的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）高可用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用需要进行取舍，如果要保证数据的强一致性，以及性能的稳定性，必须舍弃一部分东西，具体要与业务沟通和协调，从而保证实际效果符合业务要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）迁移&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;迁移不仅是业务代码的改造，从A类数据库迁到B类数据库还需要考虑数据库的迁移成本，以及能否支撑同构和异构。对于业务而言，业务更多考虑的是迁移带来的业务改造成本，一般业务会比较喜欢协议无变更、基础操作语法不变的平滑迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;5、数据库&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库我们要考虑的关键点有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你想要强事务依赖，可以用传统型数据库，以及现有的NewSQL，比如TiDB、OceanBase等。如果不考虑事务，数据库选择会更多，比如Redis、MongoDB，主要取决于具体的使用场景和数据库要承担的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一种数据库的性能不同，以关系型数据库和非关系型数据库为例，MongoDB和MySQL两者的性能差别是很大的，依然取决于数据库要承担的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）扩缩容、高可用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扩缩容和高可用不需要进行过多的解释，因为高可用是DBA选择数据库的硬性要求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）迁移&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一部分的迁移与业务的迁移存在差异，业务的迁移主要考虑业务改造成本，数据库的迁移需要考虑以下三点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据是否一致&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据迁移时是否有增量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据迁移会对业务产生什么影响&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果业务允许直接一刀切，那么方案则比较简单；如果业务要求无损，那么如何评估方案也是需要大家进行考量的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）备份/还原&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果可能出现数据需要恢复的场景，则必须考虑备份/还原的能力。我们一般会更倾向于做物理备份，因为物理备份还原比较快，但是一些数据库没有提供物理备份的能力，如MongoDB。Redis我们也不会做持续化的备份，因为会导致性能的严重下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6）容灾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;容灾是第一部分B站数据库架构演进我们提到的两地三中心和同城多活需要具备的一个能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7）稳定性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库的要求是能够平稳地对外提供服务，因此稳定性非常关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8）成本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不可能为了保证性能无限地往数据库里加机器，因为成本会很高。同时需要考虑开源数据库和商业数据库的选择，在一定程度上商业数据库的性能比同等规格的开源数据库更好，但是需要考虑维护成本和二次定制化能力的成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9）定制化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;商业数据库有时不会让我们做更多的定制化开发，但是这会给我们的上下游依赖带来一个问题，因为大部分场景我们会依赖于类似MySQL的binlog，下游的刷缓存能力以及大数据的实时数仓能力都需要依靠binlog去往下游，也就是CDC能力。那么这一方面也是数据库选型需要进行评估的重要能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;6、策略&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）多维度综合考虑&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库架构选型并不是从一个维度考虑的，每个数据库有自身的使用场景和特点，因此数据库架构选型需要从多个维度综合考虑，包括数据的维度、业务的真实诉求、DBA团队能提供的数据库能力，以及公司对于数据库的支撑能力，主要是公司其他团队如开发和平台类支撑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）满足未来三到五年需求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库架构例如扩缩容能力，必须满足未来3～5年的需求，而不是频繁地迭代和更新，否则对业务而言是有损的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）稳定为主&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库需要平稳运行，而不是天天宕机，因此数据库架构选型需要以稳定为主。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHzXwvmn2ALVwE1V7Yn8DayaElGqUAXBnjFYOrpPp5EcQQo5mEGJMN3Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图的右侧是目前B站的数据库团队使用的数据库占比，可以看出：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总体来说，B站的数据库特点是Redis和MySQL为主，其它数据库主要是基于我们的使用场景进行选择和提供。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;四、稳定性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天主要是想向大家介绍B站万亿级数据库选型与架构设计实践，所以需要考虑数据库如何提供稳定性能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、高可用&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHDwSIoKP9fwCoEbcetv5Bk0eMpXicic2T6MgvOAxSfAkSwZN0f5C2CGpA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在提供稳定性方面，主要是如何保证数据库高可用。BRM是我们基于B站的业务特点自研的MySQL高可用组件，在该架构上我们提供了两个功能节点Leader和Follower，能够对集群内的所有节点进行管理和探活。不管在哪个节点进行注册，我们都可以将其注册到整个集群。因为内部有一个网关会把所有请求转发到主节点，同时再分发到剩下的Follower节点上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Leader和Follower都参与投票决策，用以规避因网络抖动问题导致BRM误判数据库不可用，然后由Leader节点根据投票结果判断该节点到底是否宕机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;整体概括起来，我们自研的BRM会有以下六个核心功能：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、预警&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;保证系统的平稳运行，也涉及到预警的能力。对于数据库的预警，真正比较具有可预测性和可观察性的是慢查询。数据库的CPU和IO之类的也可以作为参考，但是会存在一定的误判，所以我们的方案是针对慢查询，并且做了一套慢查询预警体系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHna0b0v3cOwiaHffWyiaibJIAggxia0pp4uHRPw40h3FdeGINibDJDC3qLaw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先对于DB层的慢查询，我们做了&lt;strong&gt;流式的采集上报和实时分析&lt;/strong&gt;。在实时分析之后，可能会存在误报的情况，因为如果集群在常态情况下，每天固定某个时刻都会出现比如100条慢查询，那么此时是否该报，其实这本身是一个业务某个时间点的特定行为，不会影响整体行为，所以需要将其屏蔽。针对这一方面，我们引入多次线性回归，通过多次线性回归实现了对偶发性的抖动的过滤，不同业务级别环比倍数、持续性增长（未到阈值倍数，但持续增长或存在）慢查询的预警，并且基于规则引擎实现自定义处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、Proxy&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHwaNkgzkOOcLyxWTpe28Mz9A4CCeicx4TCCPlRlLsOpX52FmBjNB1N9w/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过对Proxy的大量使用，我们可以实现针对某个数据库、某个服务、某类SQL指纹进行&lt;/span&gt;&lt;strong&gt;&lt;span&gt;拦截、限流、熔断&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，以阻止某些异常流量打崩数据的场景，也可以做比较轻松状态下的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;读写分离&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们也可以做&lt;/span&gt;&lt;strong&gt;&lt;span&gt;多机房路由&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，将机动架构下的数据流量转发到主库，同时能够动态发现拓扑结构的变化，新增或删除从库以及节点的变化都比较易于发现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时我们可以去做更精细化的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Sidecar模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，从而减少业务技术与能力，通过Sidecar模式使用Proxy，可以满足大家在大量场景下的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、多活&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHULwM9uqpQgOwOa5nCKmibHNExLHs5yIcdNHbq4HYNnzwbv6BRoyI1Og/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多活是为了保证在一个机房挂掉之后，我们可以有另外的机房支撑这一方面的能力，我前面讲到的Proxy、BRM以及DTS等都是用于满足多活的诉求。通过多活我们可以保证最大能力的冗灾，同时对用户的影响达到最小，当一个机房挂掉之后，影响的用户可能只有一部分，快速将用户全部导流到另外一个机房可以为用户提供平稳的使用体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;五、效率&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后是自动化效率的问题，不管是TiDB这种原生的分布式数据库还是我们基于Proxy和业务层自研的分布式数据库能力，同时比如Redis这种超大规模集群，我们现在经常会超过Redis本身的上限，因gossip通信机制，如果节点数量过大会导致节点间的心跳请求将带宽占满，所以我们的自动化如何提供效率？以下是自动化运维演进的方向：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHP1Obhz9IicEhVQibZMURV0orVYUaWTrYAYVUZRuE1JCH7KckUJ6EcSBQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前我们仍然处于自动化运维的阶段，自动化平台能力的核心有四个方面，分别是资源管理研发自助、运维操作和风险管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;325&quot; data-ratio=&quot;0.7140522875816994&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8bBj4icaLlibyzic76AtnMOiaEHq0S1s9XG63etg5zwhYia8c2icib7CichR3MuRJqW4Oqvl6axJjUgxJ7mKQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动化运维平台&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、资源管理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;资源管理简单理解就是资源如何进行分配，有多个维度：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、研发自助&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;日常情况下，研发有很多事情需要做，例如查询、导入、加字段以及健康检查等。资源申请指的是我们办了一些比较简单的常规业务，他们可以基于我们前面讲到的策略进行匹配后选择数据库。到DBA审核的时候，我们会评估他们写入的内容是否合理，保证不会出现由于架构设计失败引发重构的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、运维操作&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群管理、实例管理和数据管理是一些比较日常的运维操作，整体上由平台化进行支撑，大部分可以通过自动化解决，不需要人工进行管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、风险管理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;风险管理包括监控与告警、健康度报表以及接入信息脱敏和存储信息脱敏。B站涉及到电商和支付方面，需要对一些数据和用户信息进行大量的脱敏，通过数据扫描保证数据的合规。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是我们自动化平台的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;Q&amp;amp;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Q1：异地多活架构下支持同时多写吗？怎么解决写入冲突的问题？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;现在我们做的异地多活架构会提供同时多写的能力，有两个维度进行判断，一个维度是基于特定字段，特定字段可以基于实践也可以基于业务维度，另一个维度是通过全字段匹配判断数据是否冲突。如果冲突则需要下游的处理能力，也就是需要业务方判断，我们是把数据打到DataBus，由业务判断这一部分数据如何处理。如果确定好之后，我们会提供一个接口，让业务按照DTS模式写入到对端数据库，从而保证数据的回环复制。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40d2eeb0e68704eb921deaccc3c8121e</guid>
<title>深入浅出Seata的AT模式</title>
<link>https://toutiao.io/k/1dzs6cv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;单个掉队，导致集体被动摆烂；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、业务背景&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在分布式架构中，事务管理是个无法避开的复杂问题，虽然有多种解决方案，但是需要根据业务去选择合适的；&lt;/p&gt;&lt;p&gt;从个人最近几年的实践经验来看，Seata组件的AT模式比较常用，本文从实际的案例出发，来深入分析该模式的原理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45493934142114384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWMBqGNV4o5YGBHNyAbMKBYPQJ3q2OxPec4xfgU3Lvwckf3369MaktSgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先创建一个全局事务管理的接口，这里是在Facade服务中开启全局事务；&lt;/p&gt;&lt;p&gt;请求经过三个微服务，并且各个服务都进行数据源的操作，然后模拟链路成功和异常的情况，来分析不同状态的逻辑实现；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、Seata架构&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、核心组件&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWM66E0n0xMjNA7RXCawFFqFFdUIotXJy60Rgibh4z50eSrZn9rF0lCL3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;三大组件&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;即Transaction Coordinator，维护全局和分支事务的状态，驱动全局事务提交或回滚。&lt;/p&gt;&lt;p&gt;即Transaction Manager，定义全局事务的范围，开始事务、提交事务，回滚事务。&lt;/p&gt;&lt;p&gt;即Resource Manager，管理分支事务处理的资源，向TC注册分支事务，报告分支事务的状态，驱动分支事务提交或回滚。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;基础交互&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;TC是需要独立部署的服务，TM和RM是集成在服务中，三大组件相互协作，共同完成分布事务的管理；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、AT模式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;事务模型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AT是Seata默认的模式，需要基于支持本地ACID事务的关系型数据库；Java应用，通过JDBC访问数据库；基于案例流程，先分析AT的事务模型；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9793322734499205&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWMOyPg8Wgl1lgyRt1AevIBaggpor6mjibJUJcyWRJZkYhVDWY1iblnLBUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/p&gt;&lt;p&gt;2.1 TM负责定义全局事务的边界，向TC申请，开启一个全局事务；&lt;/p&gt;&lt;p&gt;2.2 全局事务创建成功后，生成全局唯一的XID；&lt;/p&gt;&lt;p&gt;2.3 XID会在微服务请求链路上下文中传播；&lt;/p&gt;&lt;p&gt;2.4 RM向TC注册分支事务，并归属到XID对应的全局事务进行调度；&lt;/p&gt;&lt;p&gt;2.5 TM向TC发起相应XID的全局事务提交或回滚决议；&lt;/p&gt;&lt;p&gt;2.6 TC完成对XID管理的全部分支事务提交或回滚的调度；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;核心机制&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4245901639344262&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWM4nfo91hkS5OWMuMMDmqZ7M2ynYFxibG7sQM7jAhmJdAcQclTwaRewpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1220&quot;/&gt;&lt;/p&gt;&lt;p&gt;执行阶段：每个微服务的请求完成后，基于本地数据库的事务能力，保证业务数据和回滚日志在同一个本地事务中提交，快速释放连接和对资源的锁定；&lt;/p&gt;&lt;p&gt;完成阶段：全局提交时分支事务已经完成提交，会清理回滚日志，快速结束流程；全局回滚基于XID和BranchID查询回滚日志，完成数据回滚；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;数据源代理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWMASy52bmStv6uAObR68q9JS03DPx5z4ff8Gic7bdPGwNqamxlS3Dia3gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在AT模式中，应用需要使用Seata组件中的JDBC代理数据源DataSourceProxy，实现对真正目标数据源的代理访问；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、案例分析&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、流程分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;案例的简单描述&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.317741935483871&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWM6nPQxXicS40bQBKqIHywz0TppsnUCspogIL01iatMj01H9iau9XTzIC8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;在案例中涉及三个服务，Facade服务开启全局事务，然后分别请求Account和Quartz服务的更新接口，通过Quartz接口是否抛异常来调试AT模式的原理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.78671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWM1MWjW2spdXicYPofw0fLiaOEGDOulAV5H0YR0J7Mtr6UoicTv7JWscic1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从实际的请求执行来说，绝大多数的请求都是可以执行成功的，而AT模式的异步化提交极大限度的顾及全局事务的效率问题，少数失败的情况也可以通过回滚日志进行反向补偿；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、写隔离&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;上述流程分析AT模式的原子性，即多个分支事务要么都成功要么都失败，接下来分析多个事务中的全局锁隔离机制，先看写隔离，假设TX1先开始；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.75546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWML7UFqbrGuwKZURicSzicnHoHChuPYNXWQzaqrsYBZPQ70OMXSdsjJJ5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TX1逻辑&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TX1开始本地事务，拿到本地锁，然后执行更新操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX1本地事务提交前，需要先获取全局锁，否则无法提交；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX1获取全局锁并提交，释放本地锁，但未释放全局锁；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;TX2逻辑&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TX2此时开始本地事务，拿到本地锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX2执行本地事务提交前，尝试获取全局锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于全局锁被TX1持有，TX2会重试等待全局锁；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;假设TX1全局提交&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TX1如果全局事务提交，会释放全局锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX2获取全局锁成功，执行本地事务提交；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;假设TX1全局回滚&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TX1如果全局事务回滚，要重新获取数据的本地锁，进行回滚的补偿动作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX2如果仍在等待全局锁，并且还持有本地锁，TX1事务回滚失败，会不断的重试；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当TX2等待全局锁超时，会放弃全局锁并回滚本地事务，释放本地锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TX1最终获取数据的本地锁，完成回滚动作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在该过程中，TX1在结束前一直持有全局锁，TX2获取不到全局锁无法对相同的数据执行更新动作，所以避免了脏写的问题；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、读隔离&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;在数据库本地隔离级别为读已提交或以上的基础上，Seata的AT模式默认全局隔离级别是读未提交；如果需要全局的读已提交，可以通过&lt;code&gt;SELECT FOR UPDATE&lt;/code&gt;语句的代理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWMMWVlk1f0NpiciaWqABiaKqp4woqe82Fscic05XML1Afx1DKhrjicBDUESjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;该语句的执行也需要获取全局锁，如果全局锁被TX1持有，TX2会释放本地锁，查询会被阻塞并进行重试，拿到全局锁读取成功后返回；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、对比XA模式&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;XA是一个分布式事务分段提交协议；事务管理器即TM：作为全局事务的调度者，负责整个事务中本地资源的提交和回滚；本地资源管理器即RM：大部分关系型数据库都实现了XA接口；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBqB28CU8NoeLRyXCymqmWMENtcic0P934NZHb0D9AdDA4wfVia4ecUa0hQHGgm3pbI4naraLvq9mag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;TM先向所有的参与事务的RM发送确认请求，根据确认的结果，判断是调用RM的commit提交还是rollback回滚；&lt;/p&gt;&lt;p&gt;XA具有强一致性，在2段提交的过程中，会持有资源的锁，如果是在交易下单等复杂链路中，并且并发量很高，会存在长事务风险，XA无法满足该类高并发的场景；&lt;/p&gt;&lt;p&gt;而在Seata的AT模式中，在服务执行完成后，直接进行RM提交和资源释放，提供了对CAP理论相对平衡的解决方案，并且没有侵入业务工程；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a37e2fc35872166a819eb6da62a1fff</guid>
<title>面试官：MySQL 中 varchar(n) 中 n 最大取值为多少？</title>
<link>https://toutiao.io/k/xjo2olt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NzU5NTIwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxpY5pHeUUaicHSaqaylBb25Rbib0ocE4ZmXWdicS9tbGvFc9qvbiaNDibKKvuFYqlUdSW6VicXhoLNHfMQ/0?wx_fmt=png&quot; data-nickname=&quot;捡田螺的小男孩&quot; data-alias=&quot;&quot; data-signature=&quot;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是田螺。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天&lt;span&gt;聊聊：MySQL 中 varchar(n) 中 n 最大取值为多少？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前置知识&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要回答这个问题，首先我们得先知道 MySQL 存储一条记录的格式长什么样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以  Compact 行格式作为例子，它长这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2405821917808219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVKQI5jp7Lsd7FTNLS9m3JpsRWegTXj6JxeBVwLRZonLIHQbXWwsgEjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2336&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里&lt;strong&gt;重点讲讲记录的额外信息&lt;/strong&gt;，它包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于存储一行记录中每个变长字段的长度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设数据库表中有 2 个 varchar(10) 类型的字段，分别为 a 和 b，且数据库表的字符集为 ascii 字符集（1 个字符占用 1 字节）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么a和b字段的数据值的长度分别只需要用1字节表示就行了，因为1字节能表示最大的字节数是 255，而 varchar(10) 类型的字段最大允许存储的字节数是 10 字节，所以只需要用 1 字节表示变长字段的长度就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这种情况下的 「变长字段长度列表」所占用的字节数 = 1 字节 + 1字节 = 2 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;「变长字段长度列表」不是必须的，如果数据库表没有变长字段，比如字段类型都是int，那么行格式中就不需要&lt;span&gt;「变长字段长度列表」。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于标记一行记录中字段值为 NULL 的字段，二进制位的值为 1 时，代表该字段的值为NULL，二进制位的值为 0 时，代表该字段的值不为 NULL。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 &lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表中允许为 NULL 值的记录的个数小于等于 8 个，那么 NULL 值列表就会用 1 字节表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果如果表中允许为 NULL 值的记录的个数大于8 并且小于等于 16，那么 NULL 值列表就会用 2 字节表示，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，如果表中有字段允许为 &lt;span&gt;NULL，那么&lt;span&gt;「&lt;/span&gt;&lt;span&gt;NULL 值列表&lt;/span&gt;&lt;span&gt;」至少占用 1 字节空间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;「&lt;span&gt;NULL 值列表&lt;/span&gt;」&lt;/span&gt;&lt;span&gt;不是必须的，如果&lt;/span&gt;&lt;span&gt;数据库表中的字段都定义成 NOT NULL，那么&lt;span&gt;行格式中就&lt;/span&gt;&lt;span&gt;不需要&lt;/span&gt;&lt;span&gt;「&lt;span&gt;NULL 值列表&lt;/span&gt;」。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录头信息中包含的内容很多，比如记录的删除标记位，指向下一条记录的指针等等，不是本文问题的重点，所以我就不细讲了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;varchar(n) 中 n 最大取值为多少？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要清楚一点，&lt;strong&gt;MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，一行记录除了 TEXT、BLOBs 类型的列，限制最大为 65535 字节，&lt;strong&gt;注意是一行的总长度，不是一列&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 ascii 字符集， 1 个字符占用 1 字节，那么  varchar(100) 意味着最大能允许存储 100 字节的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;单字段的情况&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们知道了，一行记录最大只能存储 65535 字节的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不着急说结论，我们先来做个实验验证一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;test&lt;/span&gt; ( &lt;br/&gt;&lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;65535&lt;/span&gt;)  &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt; = &lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; = &lt;span&gt;ascii&lt;/span&gt; ROW_FORMAT = &lt;span&gt;COMPACT&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看能不能成功创建一张表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15930902111324377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVq0ghMcczC6NUj5okaGnPus7YI43P9fwt5KE2vEdxiceSSbT9tzhUFDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果显示，创建失败了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从报错信息就可以知道&lt;strong&gt;一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说&lt;strong&gt;一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead  占用的字节数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为我们存储字段类型为 varchar(n)  的数据时，其实分成了三个部分来存储：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;真实数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实数据占用的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NULL 标识，如果不允许为NULL，这部分不需要&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本次案例中，「NULL 值列表」所占用的字节数是多少？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我创建表的时候，字段是允许为 NULL 的，所以&lt;strong&gt;会用 1 字节来表示「NULL 值列表」&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本次案例中，「变长字段长度列表」所占用的字节数是多少？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，&lt;strong&gt;在数据库表只有一个 varchar(n)  字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 =  65535 - 2 - 1 = 65532&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来测试看看  varchar(65533)  是否可行？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11194029850746269&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVqDiaiaP0NjhajlhQjCicyAZS8SEWvp2QgK0oxJdJ7Sg6EIkIjuh43lA5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1876&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，还是不行，接下来看看 varchar(65532)  是否可行？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08766233766233766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVic5xLXpI1jYCF4ZvsewkYibRZ8jjFqK70B3E7eXz0IyrhKB71awTh0Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1848&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n)  最多能存储的数据计算方式就不一样了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 UTF-8 字符集下，一个字符串最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面所说的只是针对于一个字段的计算方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;多字段的情况&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &amp;lt;= 65535&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里举个多字段的情况的例子。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40830945558739257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVKKEk1Z7Rl1plqKEb5e6UUdJnIzlM6I9IavHdtxowSefG9kzmnRY2Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实验结果：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2980349344978166&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdMgIq99PeF57DFRg6z7XJVWGYYSD7kVQXJha2EDlpbl1FQMz1wia3ibjHWibWVy797a8mwY8EkEfn1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1832&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;varchar(n) 中 n 最大取值为多少？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一张表只有一个 varchar(n)  字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &amp;lt;= 65535。&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg3NzU5NTIwNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpxpY5pHeUUaicHSaqaylBb25Rbib0ocE4ZmXWdicS9tbGvFc9qvbiaNDibKKvuFYqlUdSW6VicXhoLNHfMQ/0?wx_fmt=png&quot; data-nickname=&quot;捡田螺的小男孩&quot; data-alias=&quot;&quot; data-signature=&quot;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-templateid=&quot;list&quot; data-traceid=&quot;884ada36-d903-45c3-a4a6-fba5f85e5f93&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;137_221282671900012207801683&quot; data-appuin=&quot;3875664301&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:8,&amp;quot;pid&amp;quot;:&amp;quot;137_221282671900012207801683&amp;quot;,&amp;quot;biz_uin&amp;quot;:&amp;quot;3875664301&amp;quot;,&amp;quot;trace_id&amp;quot;:&amp;quot;884ada36-d903-45c3-a4a6-fba5f85e5f93&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;137_221282671900012207801683&amp;quot;,&amp;quot;source_id&amp;quot;:37,&amp;quot;source_name&amp;quot;:&amp;quot;爱逛&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://pcm-img.zhls.qq.com/productcenter-097cfe63--1013790-2196423008332235581/92540481612112022/38080945729fbdafd010ff19c6489328.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;志高电动剃须刀男士剃胡刮胡刀智能充电式迷你干湿两用便携胡水洗&amp;quot;,&amp;quot;current_price&amp;quot;:10600,&amp;quot;first_category_id&amp;quot;:&amp;quot;8&amp;quot;,&amp;quot;product_label_name_list&amp;quot;:[],&amp;quot;select_tag_name_list&amp;quot;:[],&amp;quot;appuin&amp;quot;:&amp;quot;3875664301&amp;quot;,&amp;quot;isNewCpsKOL&amp;quot;:1,&amp;quot;templateId&amp;quot;:&amp;quot;list&amp;quot;}&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>