<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>40bbf068af1070daf6dcb782297831db</guid>
<title>五大模型揭秘深度学习用于时序预测的最新进展</title>
<link>https://toutiao.io/k/ej101yr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;引言&lt;/h2&gt;

&lt;p&gt;在以往的时序预测中，大部分使用的是基于统计和机器学习的一些方法。然而，由于深度学习在时间序列的预测中表现并不是很好，且部分论文表述，在训练时间方面，用 Transformer、Informer 、Logtrace 等模型来做时间序列预测的效果甚至不如通过多层感知机与线性回归做加权。&lt;/p&gt;

&lt;p&gt;基于以上背景，近年来，学术界针对时间序列的特点，设计了一系列的深度学习架构模型。本篇文章将介绍 N-BEATS、N-BEATSx、N-HiTS、FEDformer 以及 DeepTiMe 五个最新深度学习架构模型。&lt;/p&gt;

&lt;h2&gt;模型介绍&lt;/h2&gt;

&lt;p&gt;N-BEATS 与 N-BEATSx 是加拿大一家公司最先提出。N-HiTS 是在 N-BEATS 的基础上做了一些改进。FEDformer 是由阿里达摩院发表一个基于傅立叶变换和小波变换用于深度模型做提取特征工作的模型。DeepTiMe 是利用元学习的思想，在非常简单的神经网络上结合随机傅立叶特征即可取得很好的预测效果。&lt;/p&gt;

&lt;h3&gt;N-BEATS&lt;/h3&gt;

&lt;p&gt;在时间序列预测当中，算法大致分为基于回归与基于分解两大类。N-BEATS 则是一种基于时间序列分解的算法。&lt;/p&gt;

&lt;p&gt;基于学界以及工业界的应用经验，在时间序列预测中，分解算法会更加鲁棒。因此，如何将上述分解思想应用与深度学习之中，是这篇文章的一个重要出发点，另一个出发点则是解决针对深度学习在做时间序列预测时所面临的可解释性不强等问题。&lt;/p&gt;

&lt;p&gt;下图为 N-BEATS 模型的整体网络架构。可以明显看出 N-BEATS 属于分类模型，即该模型是将神经网分成单个 Stack。如图所示， N-BEATS 模型的神经网络被分成了 M 个 Stack，每一个 Stack 两个输出值，一个向右传递值和一个向下传递值。最终，汇总每一个 Stack 向右传递的值便作为该模型的综合输出。此时，每一个 Stack 输出结果便可以看成每一个 Stack 上时间序列预测的结果。此外，每一个 Stack 由很多个 Block 组成，Block 与 Block 之间连接方式为残差连接，每个 Block 使用的是全连接神经网络。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a99605ab58f43f289caa21dd56b4140%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为解决深度学习在做时间序列预测时可解释性不强的问题，该模型作者采用了两种方法。如下图所示，假设该模型只设计两个 Stack，一个 Stack 用于输出该模型的趋势，另一个 Stack 用于输出该模型的周期。在 Stack 用于输出趋势时，该 Stack 输出的值作为多样式的系数，随后用该多样式函数来拟合它的趋势。相对来说，这种方法是较为原始的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e23a9120a3f34067b0bc06e81dac7782%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在Stack 用于输出周期时，该 Stack 输出的值作为傅立叶级数的系数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/173d02bb6463413ba2785264930ce7a2%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后，将上述两个值加起来，即可得到整个网络的输出。反之，如果预测趋势出现问题，则有可能为第一个 Stack 出问题，如果预测周期出现问题，则有可能是第二个 Stack 出问题。&lt;/p&gt;

&lt;p&gt;下图为 N-BEATS 模型在 M4、M3 以及其他数据集上的一些表现。可以看出， 相比与深度学习、时间序列等其他模型，N-BEATS 模型在部分指标下的结果是较为显著的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5da422db89c3458cbff8407592782ea0%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;N-BEATSx&lt;/h3&gt;

&lt;p&gt;由于 N-BEATS 只能进行单指标时间序列预测的问题，因此，N-BEATSx 在 N-BEATS 的基础上对神经网络做了部分改动以实现多指标时间序列预测。即在预测过程中，输入的值不局限于时间序列，也可以是外部变量，以此实现多对一的预测。如下图所示，N-BEATSx 模型的网络架构与 N-BEATS 基本一致，没有出现额外的变化。即 N-BEATSx 可以理解为加了外部变量的 N-BEATS。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d19aee5d4a46c0a56f26788b3f448b%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如下图所示，左侧是未输入外部变量的 N-BEATS，残差较大。右侧是加了外部变量的 N-BEATSx，预测结果更准确。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de1d47bc63b543009d011b0f3f80eafb%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;N-HiTS&lt;/h3&gt;

&lt;p&gt;N-HiTS 与前两个模型的网络结构一致，不同点在于在 Stack 方面，N-HiTS 是通过多重采样的方式将时间序列分成高频和低频。若时间序列如下图左上角所示，例如，可以通过每隔100个点采样一次的方式得到低频采样信息。为实现与其他时间序列对齐并各个预测结果相加，随后做插值。此外，如需获取高频采样信息，只需将采集频次提高即可。&lt;/p&gt;

&lt;p&gt;信息采集完成后，传递至每个 Stack 中，随后进行预测。如果发现预测趋势出现问题，则可通过分析低频、高频信息的方式定位问题根源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47748fcb836c4be3844eb7b22203322a%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为 N-HiTS 模型预测结果对比图，可明显看出好于 Informer、Autoformer 以及 ARIMA 等模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ec67b1e46844c4eb349e360ba3da71c%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为 N-HiTS 模型的计算复杂度与空间复杂度。可看出基于 N-HiTS、N-BEATS 以及 N-BEATSx 的时间复杂度要远远低于 Transformer 等模型的复杂度。且在空间复杂度上面， N-HiTS 模型甚至比N-BEATS 模型还要低一些。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62a18afd294d4251a125a9bf5748f029%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;FEDformer&lt;/h3&gt;

&lt;p&gt;FEDformer 模型主要采用了 Transformer 模型的结构，在此基础上提出了两个创新点。第一个创新点是频率增强捕捉机制，第二个创新点是基于频率增强的注意力机制。频率增强捕捉机制与频率增强的注意力机制有傅立叶变换和小波变换两个版本。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3d4435c4e254ecdab14dff1d100e7d8%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为傅立叶变换实现的版本。首先将原始时域上的输入序列投影到频域；随后再在频域上进行随机采样；其次进行频域补全，频域补全过程与频域采样相对，为了使得信号能够还原回原始的长度，需要对频域采样未被采到的频率点补零；最后进行投影回时域，因为上述补全操作，投影回频域的信号和之前的输入信号维度完全一致。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9f4445719144219bf0260fbb9483e0f%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;DeepTiMe&lt;/h3&gt;

&lt;p&gt;DeepTiMe 模型利用了元学习模型的思想，是一个基于 Time-Index 的模型。下图为 DeepTiMe 模型网络架构，DeepTiMe 也利用了随机傅立叶特征。首先传递一个 Time-Index 告知今天是几号，随后预测出yt。上述便是 DeepTiMe 模型网络整体输入输出流程。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5efb73e27c924a37b019a706bce895ef%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为未使用语言模型和使用语言学习（DeepTiMe）的对比图，可看出，使用 DeepTiMe 模型的预测效果明显高于未使用 DeepTiMe 模型的预测效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44c7dd32491849009c9786975af66658%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为使用 DeepTiMe 模型预测线性、三次多项式等模型的预测结果，可以看出 DeepTiMe 模型在该方面的预测结果也较为精准。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f26a6f5dd0184559aec56a5ac0e08e13%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图为 DeepTiMe 模型与其他模型预测结果对比。在多指标预测当面，DeepTiMe 模型好于 N-HiTS 模型与 FEDformer 模型以及其他 Former 类模型。在单指标预测中，N-HiTS 模型则好于 DeepTiMe 模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1d1e9c67cef48198775d4a21e2af449%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;开源项目推荐&lt;/h1&gt;

&lt;p&gt;云智慧已开源数据可视化编排平台 FlyFish 。通过配置数据模型为用户提供上百种可视化图形组件，零编码即可实现符合自己业务需求的炫酷可视化大屏。 同时，飞鱼也提供了灵活的拓展能力，支持组件开发、自定义函数与全局事件等配置， 面向复杂需求场景能够保证高效开发与交付。&lt;/p&gt;

&lt;p&gt;如果喜欢我们的项目，请不要忘记点击下方代码仓库地址，在 &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;Gitee&lt;/a&gt;&lt;/strong&gt; 仓库上点个 Star，我们需要您的鼓励与支持。此外，即刻参与 FlyFish 项目贡献成为 FlyFish Contributor 的同时更有万元现金等你来拿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;https://github.com/CloudWise-OpenSource/FlyFish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;https://gitee.com/CloudWise/fly-fish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【飞鱼】加入 AIOps 社区飞鱼开发者交流群，与 FlyFish 项目 PMC 面对面交流～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f767f325fae54f28aff064405c11c9d7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>63814e15a547aa3540772cd9f9607cc6</guid>
<title>Darknet 中的学习率调整策略</title>
<link>https://toutiao.io/k/o466hbz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;导语&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Darknet&lt;/span&gt;是一个比较小众的开源深度学习框架，与目前主流的深度学习框架不同的是，该框架由C语言实现，对于新手来说有一定的学习难度。但是即便这样，也挡不住我们使用该框架的热情（也可能是迫不得已），因为大名鼎鼎的目标检测算法&lt;span&gt;YOLO&lt;/span&gt;（从v1~v4）就是基于该框架实现的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.531437125748503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafP7fecXHKKYWgk0I2ATnsp7IlOos8xCcGL5eeGoOyzddVTCKNKsbAxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习率&lt;/span&gt;是训练深度学习模型时设置的一个关键的超参数，其值直接决定了训练的模型是否收敛、收敛的快慢程度：如果学习率设置得过大，则可能导致模型无法收敛；设置得过小则会导致模型收敛得很慢，从而使得训练时间过长。下图形象地说明了学习率对模型训练过程的影响：图1学习率过大，导致模型无法收敛；图2学习率过小，导致训练耗时较长；图3先设置了一个合适的学习率，然后在训练过程中还会适当地减少学习率，使得模型可以很好地收敛到全局最优点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.25&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafMqSdCHhn7H1un4oqCRHF1LQ4dfqXwcmbwkrObkQVNKBpgwqYtEI62g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图片来源于网络&lt;/span&gt;&lt;/p&gt;&lt;p&gt;学习率是训练模型之前就设置好的一个超参数，在训练过程中还会基于一定的策略进行调整。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Darknet中的几种学习率调整策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;span&gt;Darknet&lt;/span&gt;中，神经网络的模型结构和训练时需要的一些超参数都是在一个&lt;span&gt;`.cfg`&lt;/span&gt;文件中指定。学习率的调整策略则是在&lt;span&gt;`.cfg`&lt;/span&gt;文件中通过&lt;span&gt;`policy=`&lt;/span&gt;进行设置，在框架的代码中，则是由&lt;span&gt;`parser.c`&lt;/span&gt;的&lt;span&gt;`get_policy()`&lt;/span&gt;函数对&lt;span&gt;`.cfg`&lt;/span&gt;文件中设定的调整策略字符串进行解析以确定本次训练所采用的学习率调整策略。&lt;span&gt;`Darknet`&lt;/span&gt;框架支持的几种学习率调整策略定义在一个名为&lt;span&gt;`learning_rate_policy`&lt;/span&gt;的枚举类型中，其中每个成员代表的调整策略的具体含义解释如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CONSTANT:  &lt;/span&gt;恒定的学习率，学习率初始值在&lt;span&gt;`.cfg`&lt;/span&gt;文件设置好后，训练过程中不会再做调整。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RANDOM:  &lt;/span&gt;也是恒定的学习率，但其值由下面的公式决定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.17890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafkfca9wIcMFdmSziclNI1VibPYM5HqF2rC5TqrVye2criaoZRFnvq3lSAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;其中，&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;为初始学习率；&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.36171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafPgbHjJqqj7AyL3VfVnfYj8ROiaO28tJKbjWdIcQw7jmQ7x3plo1nySg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;为&lt;span&gt;`0~1`&lt;/span&gt;之间的随机数；&lt;span&gt;`power`&lt;/span&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`power=`&lt;/span&gt;设置的参数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;POLY:&lt;/span&gt; 训练过程中学习率调整方式由下面公式决定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafPgLqKNMuARUmLjZ0X0icX3A6LJWA3T6nJBl1B4tRJsibg7eEqAZVY9Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;其中，&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;为初始学习率；&lt;span&gt;`batch_num`&lt;/span&gt;为当前的迭代次数；&lt;span&gt;`max_batches`&lt;/span&gt;为最大的迭代次数，该参数由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`max_batches=`&lt;/span&gt;指定；&lt;span&gt;`power`&lt;/span&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`power=`&lt;/span&gt;设置的参数。当&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.07421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafeCichkSJFrib5gsVvGgtz1k6ibdiazbwgUTgRV94tQsZXyicTiaMu6oCId7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;时，训练过程中学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaficbEVeicUStUkCGrRz77icAGqw24fe9vvSoEPia8D67aCCEvYp5cP8vzsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;STEP:&lt;/span&gt; 训练过程中学习率调整方式由下面公式决定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafticDtBasFs9FhsDQ7bVlnSx0y66s37Wu54fWvjnrgu9QFNe83fdS2PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;其中，&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;为初始学习率；&lt;span&gt;`batch_num`&lt;/span&gt;为当前的迭代次数；&lt;span&gt;`scale`&lt;/span&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`scale=`&lt;/span&gt;设置的参数;&lt;span&gt;`step`&lt;/span&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`step=`&lt;/span&gt;设置的参数。当&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.0828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafQx8WMsafRic6Jq4OTfstsQKTnx1ksERmT0Lnt4nyqcU7WnwicIznAmaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;时，训练过程中学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafOTgkLnHRzakWc42oXbMltMibmIloKmTdVk5URskzMSibRo1etIrIX85w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EXP: &lt;/span&gt; 训练过程中学习率调整方式由下面公式决定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.16953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf05bdKy8diaPSMJJ2dfOVZ1GNS6cJHWoicHpia9fXRd2SRBdicFB9GCQlgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;其中，&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;为初始学习率；&lt;span&gt;`batch_num`&lt;/span&gt;为当前的迭代次数；&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.22109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafG2MmokQB5amSmOplj91xkFOfBF72ibPJ7Fb0WHraicCVV9kVZvgoCAQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`gamma=`&lt;/span&gt;设置的参数。当&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.11953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafk4AgGcAdice7lu5zdyovAyRzTR1Qg5TXJkZ06yoNnvDcvCicS5eUvQJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;时，训练过程中学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafZZ7ok3ClXpdicBxNQy1xLy2mp7qsm8bgp2fJtCCh2MibOCpZLDNUtsnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SIG:&lt;/span&gt; 训练过程中学习率调整方式由下面公式决定&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafTdjJ3UNRNjHhmewLSNNhFRpLWgy4hjf5hNGSEthmFywVpOUKICteKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;其中，&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;为初始学习率；&lt;span&gt;`batch_num`&lt;/span&gt;为当前的迭代次数；&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.22109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafG2MmokQB5amSmOplj91xkFOfBF72ibPJ7Fb0WHraicCVV9kVZvgoCAQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`gamma=`&lt;/span&gt;设置的参数;&lt;span&gt;`step`&lt;/span&gt;是由&lt;span&gt;`.cfg`&lt;/span&gt;文件中的&lt;span&gt;`step=`&lt;/span&gt;设置的参数。当&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.08203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4FibBS7ArSic3NqGPv1P0Jr5liaYSicAicaMN4ibt5xqoDiay3OUibcPCX2OTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;时，训练过程中学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf2BpwcId1ZbSrLfcYgfQd3iaM2hibKSj4VWhT0FGDd9JqSnmE95gga3Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;STEPS: &lt;/span&gt; 一种阶段性调整策略，可以设置多个阶段，当前迭代次数达到设定值时，学习率调整为&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.18046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafwY817qCpNuAXYewJ5FNibicicXZG8X359eamymsvNoMTkJgOuZn8iaXaPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;在官方的&lt;span&gt;`yolov3.cfg`&lt;/span&gt;文件中，有如下内容：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;policy&lt;/span&gt;=steps&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;steps&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;400000&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;450000&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scales&lt;/span&gt;=.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,.&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;意思是当迭代次数达到400000时，学习率乘以0.1；当迭代次数达到450000时，学习率再乘以0.1。学习率调整曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf0ebOOB8H1l3f4OFGFRCL1vCicQCyLhfGIGYlhUa5vk1vn8sErqkzSmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习率预热&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在&lt;span&gt;Darknet&lt;/span&gt;框架中，还可以通过&lt;span&gt;`.cfg`&lt;/span&gt;文件设定一个&lt;span&gt;`burn_in`&lt;/span&gt;参数。该参数用于在训练的前期，让学习率以一定的方式从零逐渐增大到指定的初始学习率，相当于是让学习率有一段时间的“&lt;strong&gt;热身(warm up)&lt;/strong&gt;”过程，这样做的目的是避免训练初期由于初始学习率设置得过大导致训练过程出现震荡。这个阶段内，学习率的调整策略由下面的公式决定：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaficss6jut14LI7VL2xXrFq7FcZZnOaInnpmGVyw1l045IUK31xvCyuVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;当&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.0796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafGe1VEHkFYVzZxEuXsGTK0br2nweXKN00IOx0lgM5XOxXDluetkygUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;时，预热阶段学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafyOAjURj1AwLzVTccickd4NFxlvaianE6t36ibTibRxAvApks1s5icQNMoqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; 如何在Darknet中新增学习率调整策略&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上文介绍了&lt;span&gt;Darknet&lt;/span&gt;中的几种学习率调整策略，但是如果我们想用其他的策略应该怎么办呢？下面就以添加&lt;span&gt;`COSINE`&lt;/span&gt;调整策略为例说明如何在&lt;span&gt;Darknet&lt;/span&gt;中添加一种新的学习率调整策略。&lt;span&gt;`COSINE`&lt;/span&gt;调整策略的公式如下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.14765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafcDdgMUkrV0tNTLfgcEHQ280paiahzoheO2hA4LZOiaSVRdtmBxa5zPLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;其中，&lt;span/&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.34296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKaf4jQvEaibRCo9CZApS5Vr4y8elicBShjAv10lbSGBKfCd4NicaaOSKAGRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;为初始学习率；&lt;span&gt;`batch_num`&lt;/span&gt;为当前的迭代次数；&lt;span&gt;`max_batches`&lt;/span&gt;为最大迭代次数。训练过程中学习率的调整过程曲线如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dr6jv46VAWfKx9GclwAInYics8pjZQKafAD8hozXtBUUVOMoA17iblKqP5PDWu3Yw3o6f0ywdsPmy2yS898M6iahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;添加&lt;span&gt;`COSINE`&lt;/span&gt;调整策略的过程如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;/span&gt; 在&lt;span&gt;`darknet.h`&lt;/span&gt;文件中，为枚举类型&lt;span&gt;`learning_rate_policy`&lt;/span&gt;添加一个成员&lt;span&gt;`COSINE`&lt;/span&gt;：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CONSTANT, STEP, EXP, POLY, STEPS, SIG, RANDOM, COSINE&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} learning_rate_policy;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;/span&gt; 在&lt;span&gt;`parser.c`&lt;/span&gt;文件中的&lt;span&gt;`get_policy()`&lt;/span&gt;函数中添加对&lt;span&gt;`COSINE`&lt;/span&gt;调整策略的支持：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;learning_rate_policy &lt;span class=&quot;code-snippet__title&quot;&gt;get_policy&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *s)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;random&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; RANDOM;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;poly&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; POLY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;constant&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; CONSTANT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;step&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; STEP;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;exp&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; EXP;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sigmoid&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; SIG;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;steps&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; STEPS;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__built_in&quot;&gt;strcmp&lt;/span&gt;(s, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cosine&quot;&lt;/span&gt;)==&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; COSINE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;fprintf&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;stderr&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Couldn&#x27;t find policy %s, going with constant\n&quot;&lt;/span&gt;, s);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; CONSTANT;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.&lt;/span&gt; 在&lt;span&gt;`parser.c`&lt;/span&gt;文件中的&lt;span&gt;`parse_net_options()`&lt;/span&gt;函数中去解析&lt;span&gt;`.cfg`&lt;/span&gt;文件设置的参数。由于&lt;span&gt;`COSINE`&lt;/span&gt;调整策略所需的参数&lt;span&gt;`max_batches`&lt;/span&gt;已经有解析接口了，所以这里不需要额外添加。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.&lt;/span&gt; 在&lt;span&gt;`network.c`&lt;/span&gt;文件中的&lt;span&gt;`get_current_rate()`&lt;/span&gt;函数中添加一个switch分支语句，实现&lt;span&gt;`COSINE`&lt;/span&gt;调整策略：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; COSINE:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; net.learning_rate * &lt;span class=&quot;code-snippet__number&quot;&gt;0.5&lt;/span&gt; * (&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; + &lt;span class=&quot;code-snippet__built_in&quot;&gt;cos&lt;/span&gt;(batch_num *M_PI / net.max_batches));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.&lt;/span&gt; 重新编译&lt;span&gt;Darknet&lt;/span&gt;工程。编译成功后只要在&lt;span&gt;`.cfg`&lt;/span&gt;文件中设置&lt;span&gt;`policy=cosine`&lt;/span&gt;，就可以使用&lt;span&gt;`COSINE`&lt;/span&gt;学习率调整策略了。如果要添加其他的策略，参照以上方法也很容易就可以实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;学习率是训练深度学习模型过程中的一个很重要的超参数，可以通过多种方式进行调整。由于&lt;span&gt;Darknet&lt;/span&gt;框架没有学习率调整策略的相关文档，要想知道具体细节只能通过剖析源代码才能了解每个参数的含义。本文详细介绍了&lt;span&gt;Darknet&lt;/span&gt;框架中的学习率调整策略，通过公式和图形的方式阐述每种调整策略各个参数的意义和调整的过程，同时也介绍了添加新的调整策略的方法，希望对本文的读者有所帮助。&lt;/p&gt;&lt;br/&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>52931c5416d74cb0a459d15ca72942df</guid>
<title>从 Java 8 升级到 Java 17 踩坑全过程，建议收藏</title>
<link>https://toutiao.io/k/16y0ile</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2ibq0p8cfjxRlTHl0reqRwBcTwYuTvbW8SL1VImm163MGgkBZiaojCCiazEnQz49QOTicbqXAdtvoywg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;长按 &lt;/span&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;关注&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt; 此公众号，&lt;span&gt;技术干货，及时送达&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在做 Java8 到 Java17 的迁移工作，前期做了一些准备，但是在升级过程还是有些问题，太emo了，一些信息记录如下，分为几个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前人栽树后人乘凉，有需要升级的可以参考一下，避免踩坑。。。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;*编译相关*&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;JEP 320&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java11 中引入了一个提案 JEP 320: Remove the Java EE and CORBA Modules （openjdk.org/jeps/320） 提案，移除了 Java EE and CORBA 的模块，如果项目中用到需要手动引入。比如代码中用到了 &lt;code&gt;javax.annotation.*&lt;/code&gt; 下的包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class FridayAgent &lt;br/&gt;    @PreDestroy&lt;br/&gt;    public void &lt;span&gt;&lt;span&gt;destroy&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        agentClient.close();&lt;br/&gt;    }&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编译时会找不到相关的类。这是因为 Java EE 已经在 &lt;code&gt;Java 9&lt;/code&gt; 中被标记为 deprecated，Java 11 中被正式移除，可以手动引入 javax 的包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;使用了 sun.misc.* 下的包&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 sun.misc.BASE64Encoder，这个简单，替换一下工具类即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[ERROR]   symbol:   class BASE64Encoder&lt;br/&gt;[ERROR]   location: package sun.misc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netty 低版本使用了 sun.misc.*，编译错误信息如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: java.lang.NoClassDefFoundError: Could not initialize class io.netty.util.internal.PlatformDependent0&lt;br/&gt;        at io.netty.util.internal.PlatformDependent.getSystemClassLoader(PlatformDependent.java:694) ~[netty-all-4.0.42.Final.jar!/:4.0.42.Final]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/**&lt;br/&gt; * The {@link PlatformDependent} operations &lt;span&gt;which&lt;/span&gt; requires access to {@code sun.misc.*}.&lt;br/&gt; */&lt;br/&gt;final class PlatformDependent0 {&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;https://github.com/netty/netty/issues/6855&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;lombok 使用了 com.sun.tools.javac.* 下的包&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误信息如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.2:compile (default-compile) on project encloud-common: Fatal error compiling: java.lang.ExceptionInInitializerError: Unable to make field private com.sun.tools.javac.processing.JavacProcessingEnvironment$DiscoveredProcessors com.sun.tools.javac.processing.JavacProcessingEnvironment.discoveredProcs accessible: module jdk.compiler does not &quot;opens com.sun.tools.javac.processing&quot; to unnamed module&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的项目中使用 lombok，而且是低版本的话，就会出现，lombok 的原理是在编译期做一些手脚，用到了 &lt;code&gt;com.sun.tools.javac&lt;/code&gt; 下的文件，升级到最新版可以解决。ps，个人很不喜欢 lombok， 调试的时候代码和 class 对不上真的很恶心。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;&lt;br/&gt;   &amp;lt;!-- &amp;lt;version&amp;gt;1.16.4&amp;lt;/version&amp;gt;--&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;1.18.24&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;kotlin 版本限制&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们后端在很多年前就 all-in Kotlin，Kotlin 的升级也是我们的重中之重。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;[ERROR] Failed to execute goal org.jetbrains.kotlin:kotlin-maven-plugin:1.2.71:compile (compile) on project encloud-core: Compilation failure [ERROR] Unknown JVM target version: 17 [ERROR] Supported versions: 1.6, 1.8&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kotlin 在 1.6.0 版本开始支持 Java17 的字节码，低于 1.6.0 的编译会直接报错&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;废弃依赖分析&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用 &lt;code&gt;jdeps --jdk-internals --multi-release 17 --class-path . encloud-api.jar&lt;/code&gt;来做项目的依赖分析&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eHYySJKpibg3U5Cq8nTgHibcUlBfFAdr0IPLyzdvYtibfY13M5dw9TzS8Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样你就可以知道哪些库需要做升级了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;*参数迁移*&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;什么是 Unified Logging&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 领域，有广为人知的日志框架，slf4j、log4j 等，这些框架提供了统一的编程接口，让用户可以通过简单的配置实现日志输出的个性化配置，比如日志 tag、级别（info、debug 等）、上下文（线程 id、行号、时间等），在 JVM 内部之前一直缺乏这样的规范，于是出来了 Unified Logging，实现了日志格式的大一统，这就是我们接下来要介绍的重点 &lt;code&gt;Unified Logging&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接触最多的是 gc 的日志，在 java8 中，我们配置 gc 日志的参数是 &lt;code&gt;-Xloggc:/tmp/gc.log&lt;/code&gt;。在 JVM 中除了 GC，还有大量的其它相关的日志，比如线程、os 等，在新的 Unified Logging 日志中，日志输出的方式变更为了 &lt;code&gt;java -Xlog:xxx&lt;/code&gt;，GC 不再特殊只是做为日志的一种存在形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Xlog -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32037037037037036&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0e1dqYGUmPtToqTkXeKUurqchBtzsicwb8icXMzQWTqV2cejMCulfoysnQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到日志输出里，不仅有 GC 相关的日志，还有 os 线程相关的信息。事实上 java 的日志的生产者有非常多部分，比如 thread、class load、unload、safepoint、cds 等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25925925925925924&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0en3Y4BpALerHX0DYsPOYTfOPk6mBRSoK8r8pxlaOcC3pBHymCxTY2pQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归根到底，日志打印，需要回答清楚三个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;what：要输出什么信息（tag），以什么日志级别输出（level）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;where：输出到哪里（console 还是 file）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;decorators：日志如何&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;输出什么信息（selectors）&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来看 what 的部分，如何指定要输出哪些信息，这个在 JVM 内部被称之为 selectors。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 采用的是 &lt;code&gt;&amp;lt;tag-set&amp;gt;=&amp;lt;level&amp;gt;&lt;/code&gt;的形式来表示 selectors，默认情况下，tag 为&lt;code&gt;all&lt;/code&gt;，表示所有的 tag，level 为 &lt;code&gt;INFO&lt;/code&gt;，&lt;code&gt;java -Xlog -version&lt;/code&gt; 等价于下面的形式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -Xlog:all=info -version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想输出tag 为 gc，日志级别为 debug 的日志，可以用 &lt;code&gt;java -Xlog:gc=debug&lt;/code&gt; 的形式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -Xlog:gc=debug -version&lt;br/&gt;[0.023s][info][gc] Using G1&lt;br/&gt;[0.023s][debug][gc] ConcGCThreads: 3 offset 22&lt;br/&gt;[0.023s][debug][gc] ParallelGCThreads: 10&lt;br/&gt;[0.024s][debug][gc] Initialize mark stack with 4096 chunks, maximum 524288&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就输出了 tag 为 gc，级别为 debug 的日志信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里有一个比较坑的点是，这里的 tag 匹配规则是精确匹配，如果某条日志的 tag 是 &lt;code&gt;gc,metaspace&lt;/code&gt;，通过上面的规则是匹配不到的，我们可以手动指定的方式来输出。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -Xlog:gc+metaspace -version&lt;br/&gt;&lt;br/&gt;[0.022s][info][gc,metaspace] CDS archive(s) mapped at: ... size 12443648.&lt;br/&gt;[0.022s][info][gc,metaspace] Compressed class space mapped at: reserved size:...&lt;br/&gt;[0.022s][info][gc,metaspace] Narrow klass base:..., Narrow &lt;br/&gt;klass &lt;span&gt;shift&lt;/span&gt;: 0, Narrow klass range: 0x100000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 selector 也是可以进行组合的，不同的 selector 之间用逗号分隔即可。比如同时输出 &lt;code&gt;gc&lt;/code&gt; 和 &lt;code&gt;gc+metaspace&lt;/code&gt; 这两类 tag 的日志，就可以这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -Xlog:gc=debug,gc+metaspace -version&lt;br/&gt;&lt;br/&gt;[0.020s][info][gc] Using G1&lt;br/&gt;[0.020s][debug][gc] ConcGCThreads: 3 offset 22&lt;br/&gt;[0.020s][debug][gc] ParallelGCThreads: 10&lt;br/&gt;[0.020s][debug][gc] Initialize mark stack with 4096 chunks, maximum 524288&lt;br/&gt;[0.022s][info ][gc,metaspace] CDS archive(s) mapped at:&lt;br/&gt;[0.022s][info ][gc,metaspace] Compressed class space mapped at:&lt;br/&gt;[0.022s][info ][gc,metaspace] Narrow klass base: 0x0000000800000000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这么搞是很麻烦的，JVM 提供了通配符 &lt;code&gt;*&lt;/code&gt; 来解决精确匹配的问题，比如我们想要所有 tag 为 gc 的日志，可以这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -Xlog:gc*=debug -version&lt;br/&gt;&lt;br/&gt;[0.024s][debug][gc,heap] Minimum heap 8388608&lt;br/&gt;[0.024s][info ][gc     ] Using G1&lt;br/&gt;[0.024s][debug][gc,heap,coops] Heap address: 0x0000000707400000&lt;br/&gt;[0.024s][debug][gc           ] ConcGCThreads: 3 offset 22&lt;br/&gt;[0.024s][debug][gc           ] ParallelGCThreads: 10&lt;br/&gt;[0.024s][debug][gc           ] Initialize mark stack with 4096 chunks&lt;br/&gt;[0.024s][debug][gc,ergo,heap ] Expand the heap. requested expansion amount:&lt;br/&gt;[0.025s][debug][gc,heap,region] Activate regions [0, 125)[0.025s][debug][gc,ihop       ] Target occupancy update: old: 0B, new: 262144000B&lt;br/&gt;[0.025s][debug][gc,ergo,refine] Initial Refinement Zones: green: 2560&lt;br/&gt;[0.026s][debug][gc,task       ] G1 Service Thread &lt;br/&gt;[0.026s][debug][gc,task       ] G1 Service Thread (Periodic GC Task) (register)&lt;br/&gt;[0.026s][info ][gc,init       ] Version: 17.0.3+7 (release)&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只想要 INFO 级别的日志，则可以省略 level 的设置，使用 &lt;code&gt;java -Xlog:gc* -version&lt;/code&gt;即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想知道有哪些个性化的 tag 可以选择，可以用 &lt;code&gt;java -Xlog:help&lt;/code&gt; 来找到所有可用的 tag。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;阶段性小结&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4212962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eEZUXULQNgBHQ7KxG11AgSHmGacHDCghcl9BTJHoRdfnic5zszUA9EEg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二部分：输出到哪里（output）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，日志会输出到 stdout，jvm 支持以下三种输出方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言我们会把日志输出到文件中，方便后续进一步分析&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xlog:all=debug:file=/path_to_logs/app.log&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以指定日志切割的大小和方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xlog:gc*:file=/path_to_logs/app.log:filesize=104857600,filecount=5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;第三部分：日志 decorators&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每条日志除了正常的信息以外，还有不少日志相关的上下文信息，在 jvm 中被称为 &lt;code&gt;decorators&lt;/code&gt;，有下面这些可选项。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9696376101860921&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eRMas3HPAk9ic7B5zGVMuGLicwu9VHO7yuB8wia2lWupdQXoUSqfbC6ucg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1021&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如可以用 &lt;code&gt;java -Xlog:all=debug:stdout:level,tags,time,uptime,pid -version&lt;/code&gt; 选项来打印日志。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[2022-06-15T19:54:01.529+0800][0.001s][5235][info ][os,thread] Thread attached&lt;br/&gt;[2022-06-15T19:54:01.529+0800][0.001s][5235][debug][os,thread] Thread 5237 stack...&lt;br/&gt;[2022-06-15T19:54:01.529+0800][0.001s][5235][debug][perf,datacreation] &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;Unified Logging 小结&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xlog:[selectors]:[output]:[decorators][:output-options]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;selectors 是多个 tag 和 level 的组合，起到了 what（过滤器）的作用，格式为 &lt;code&gt;tag1[+tag2...][*][=level][,...]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;decorators 是日志相关的描述信息，也可以理解为上下文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;output 是输出相关的选项，一般我们会配置为输出到文件，按文件大小切割&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里补充一个知识点，就是默认值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tag：all&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;level：info&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;output：stdout&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;decorators: uptime, level, tags&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;GC 参数迁移&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 GC 相关的参数都已经收拢到 Xlog 下，以前的很多 Java8 下的参数已经被移除或者标记为过期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;PrintGCDetails&lt;/code&gt; 已经被 &lt;code&gt;-Xlog:gc*&lt;/code&gt; 取代：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintGCDetails -version&lt;br/&gt;&lt;br/&gt;[0.001s][warning][gc] -XX:+PrintGCDetails is deprecated. Will use -Xlog:gc* instead.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的标记为废弃的参数还有 &lt;code&gt;-XX:+PrintGC&lt;/code&gt; 和  &lt;code&gt;-Xloggc:&amp;lt;filepath&amp;gt;&lt;/code&gt;，迁移前后的参数如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;旧参数&lt;/th&gt;&lt;th&gt;新参数&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;-XX:+PrintGCDetails&lt;/td&gt;&lt;td&gt;-Xlog:gc*&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-XX:+PrintGC&lt;/td&gt;&lt;td&gt;-Xlog:gc&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;-Xloggc:&lt;code&gt;&amp;lt;filepath&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;-Xlog:gc:&lt;code&gt;file=&amp;lt;filepath&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，大量的 GC 的参数被移除，比如常用的参数  &lt;code&gt;-XX:+PrintTenuringDistribution&lt;/code&gt;，Java17 会拒绝启动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+PrintTenuringDistribution -version&lt;br/&gt;Unrecognized VM option &lt;span&gt;&#x27;PrintTenuringDistribution&#x27;&lt;/span&gt;&lt;br/&gt;Error: Could not create the Java Virtual Machine.&lt;br/&gt;Error: A fatal exception has occurred. Program will &lt;span&gt;exit&lt;/span&gt;.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更详细的移除的参数如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CMSDumpAtPromotionFailure,&lt;br/&gt;CMSPrintEdenSurvivorChunks,&lt;br/&gt;GlLogLevel,&lt;br/&gt;G1PrintHeapRegions, &lt;br/&gt;G1PrintRegionLivenessInfo, &lt;br/&gt;G1SummarizeConcMark,&lt;br/&gt;G1SummarizeRSetStats,&lt;br/&gt;G1TraceConcRefinement,&lt;br/&gt;G1TraceEagerReclaimHumongousObjects, &lt;br/&gt;G1TraceStringSymbolTableScrubbing,&lt;br/&gt;GCLogFileSize, NumberofGCLogFiles, &lt;br/&gt;PrintAdaptiveSizePolicy,&lt;br/&gt;PrintclassHistogramAfterFullGC,&lt;br/&gt;PrintClassHistogramBeforeFullGC,&lt;br/&gt;PrintCMSInitiationStatistics&lt;br/&gt;PrintCMSStatistics, &lt;br/&gt;PrintFLSCensus,&lt;br/&gt;PrintFLSStatistics,&lt;br/&gt;PrintGCApplicationConcurrentTime&lt;br/&gt;PrintGCApplicationStoppedTime,&lt;br/&gt;PrintGCCause,&lt;br/&gt;PrintGCDateStamps, &lt;br/&gt;PrintGCID,&lt;br/&gt;PrintGCTaskTimeStamps,&lt;br/&gt;PrintGCTimeStamps,&lt;br/&gt;PrintHeapAtGC,&lt;br/&gt;PrintHeapAtGCExtended, &lt;br/&gt;PrintJNIGCStalls,&lt;br/&gt;PrintOldPLAB&lt;br/&gt;PrintParallel0ldGCPhaseTimes, &lt;br/&gt;PrintPLAB,&lt;br/&gt;PrintPromotionFailure,&lt;br/&gt;PrintReferenceGC, &lt;br/&gt;PrintStringDeduplicationStatistics, &lt;br/&gt;PrintTaskqueue,&lt;br/&gt;PrintTenuringDistribution, &lt;br/&gt;PrintTerminationStats,&lt;br/&gt;PrintTLAB,&lt;br/&gt;TraceDynamicGCThreads,&lt;br/&gt;TraceMetadataHumongousAllocation,&lt;br/&gt;UseGCLogFileRotation,&lt;br/&gt;VerifySilently&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些移除的参数大部分都能在新的日志体系下找到对应的参数，比如 &lt;code&gt;PrintHeapAtGC&lt;/code&gt; 这个参数可以用 &lt;code&gt;-Xlog:gc+heap=debug&lt;/code&gt; 来替代&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ java -Xlog:gc+heap=debug -cp . G1GCDemo01&lt;br/&gt;&lt;br/&gt;[0.004s][debug][gc,heap] Minimum heap 8388608  Initial heap 268435456  Maximum heap &lt;br/&gt;hello, g1gc!&lt;br/&gt;[12.263s][debug][gc,heap] GC(0) Heap before GC invocations=0 (full 0):&lt;br/&gt;[12.265s][debug][gc,heap] GC(0)  garbage-first heap &lt;br/&gt;[12.265s][debug][gc,heap] GC(0)   region size 2048K, 1 young (2048K)&lt;br/&gt;[12.265s][debug][gc,heap] GC(0)  Metaspace       used 3678K&lt;br/&gt;[12.265s][debug][gc,heap] GC(0)   class space    used 300K&lt;br/&gt;[12.280s][debug][gc,heap] GC(0) Uncommittable regions after shrink: 124&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然理解起来不太直观，不过要记住 &lt;code&gt;-XX:+PrintGCApplicationStoppedTime&lt;/code&gt; 和 &lt;code&gt;-XX+PrintGCApplicationConcurrentTime&lt;/code&gt; 这两个参数一起被 &lt;code&gt;-Xlog:safepoint&lt;/code&gt; 取代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个常见的参数 &lt;code&gt;-XX:+PrintAdaptiveSizePolicy&lt;/code&gt; 被 &lt;code&gt;-Xlog:gc+ergo*=trace&lt;/code&gt; 取代，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[0.122s][debug][gc, ergo, refine] Initial Refinement Zones: green: 23, yellow:&lt;br/&gt;69, red: 115, min yellow size: 46&lt;br/&gt;[0.142s ][debug][gc, ergo, heap ] Expand the heap. requested expansion amount: 268435456B expansion amount: 268435456B&lt;br/&gt;[2.475s][trace][gc, ergo, cset] GC(0) Start choosing CSet. pending cards: 0 predicted base time: 10.00ms remaining time:&lt;br/&gt;190.00ms target pause time: 200.00ms&lt;br/&gt;[2.476s][trace][gc, ergo, cset ] GC(9) Add young regions to CSet. eden: 24 regions, survivors: 0 regions, predicted young&lt;br/&gt;region time: 367.19ms, target pause time: 200.00ms&lt;br/&gt;[2.476s ][debug][gc, ergo, cset ] GC(0) Finish choosing CSet. old: 0 regions, predicted old region time: 0.00ms, time&lt;br/&gt;remaining: 0.00&lt;br/&gt;[2.826s][debug][gc, ergo] GC(0) Running G1 Clear Card Table Task using 1 workers &lt;span&gt;for&lt;/span&gt; 1 units of work &lt;span&gt;for&lt;/span&gt; 24 regions.&lt;br/&gt;[2.827s][debug][gc, ergo] GC (0) Running G1 Free Collection Set using 1 workers &lt;span&gt;for&lt;/span&gt; collection &lt;span&gt;set&lt;/span&gt; length 24&lt;br/&gt;[2.828s][trace][gc, ergo, refine] GC(0) Updating Refinement Zones: update rs time: 0.004ms, update rs buffers: 0, update rs&lt;br/&gt;goal time: 19.999ms&lt;br/&gt;[2.829s][debug][gc, ergo, refine] GC(0) Updated Refinement Zones: green: 23, yellow: 69, red: 115&lt;br/&gt;[3.045s][trace][gc, ergo, &lt;span&gt;set&lt;/span&gt; ] GC(1) Start choosing CSet. pending cards: 5898 predicted base time: 26.69ms remaining&lt;br/&gt;time: 173.31ms target pause time: 200.00ms&lt;br/&gt;[3.045s][trace][gc, ergo, cset ] GC(1) Add young regions to Set. eden: 9 regions, survivors: 3 regions, predicted young&lt;br/&gt;region time: 457.38ms, target pause time: 200.00ms&lt;br/&gt;[3.045s][debug](gc, ergo, &lt;span&gt;set&lt;/span&gt; ] GC(1) Finish choosing CSet. old: @ regions, predicted old region time: 0.00ms, time&lt;br/&gt;remaining: 0.00&lt;br/&gt;[3.090s ][debug][gc, ergo&lt;br/&gt;] GC (1) Running G1 Clear Card Table Task using 1 workers &lt;span&gt;for&lt;/span&gt; 1 units of work &lt;span&gt;for&lt;/span&gt; 12 regions.&lt;br/&gt;[3.091s][debug][gc, ergo&lt;br/&gt;GC (1) Running G1 Free Collection Set using 1 workers &lt;span&gt;for&lt;/span&gt; collection &lt;span&gt;set&lt;/span&gt; length 12&lt;br/&gt;[3.093s][trace][gc, ergo, refine] GC(1) Updating Refinement Zones: update rs time: 2.510ms, update rs buffers: 25, update rs&lt;br/&gt;goal time: 19.999ms&lt;br/&gt;[3.093s ][debug][gc, ergo, refine] GC(1) Updated Refinement Zones: green: 25, yellow: 75, red: 125&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下这部分的源码的变迁，就可以知道确实是如此了，在 Java8 中，&lt;code&gt;PSYoungGen::resize_spaces&lt;/code&gt;代码如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eickehIHvJGrr9BqgzRSjoD9vDplHtbGYxWb7xaxedHOzfkFiaic1q8bug/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java17 中，这部分日志打印被 gc+ergo 的标签日志取代：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0e5xCYUbay0u5K68pTR76D5avctI0kMX2FUbxrNShqhbty4qiaPJtzydw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个分代 GC 中非常有用的参数 &lt;code&gt;-XX:+PrintTenuringDistribution&lt;/code&gt;，现在被 &lt;code&gt;gc+age=trace&lt;/code&gt; 取代&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的参数变迁对应表如下&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1879629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eInH1boqcWHLiaFrvEYQhQiads4qFQQzDgBnQ4NW6iaTtRiaa9BwDnVAv0w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.125&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eylwOHiazzmYNibuB4Dg6pLVmMnsRHXY1Cneq5c2NibLhskAmDo46DdIzA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.237962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0e0wfjL16Yukibia6IiaRs5jEUb1arjfNZGr7WWCqjRrnU4KTnrbSSKCyWw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3398148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0e5ynBPOYd7y0hsVbEkiaiafjb3ICLCxToP48yTb1NnGStibdeHowxhviaiag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;举例&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:+PrintGCDetails                           \  // gc*&lt;br/&gt;-XX:+PrintGCApplicationStoppedTime            \  // safepoint&lt;br/&gt;-XX:+PrintGCApplicationConcurrentTime         \  // safepoint &lt;br/&gt;-XX:+PrintGCCause                             \  // 默认会输出&lt;br/&gt;-XX:+PrintGCID                                \  // 默认会输出&lt;br/&gt;-XX:+PrintTenuringDistribution                \  // gc+age*=trace&lt;br/&gt;-XX:+PrintGCDateStamps                        \  // :time,tags,level&lt;br/&gt;-XX:+UseGCLogFileRotation                     \  // :filecount=5,filesize=10M &lt;br/&gt;-XX:NumberOfGCLogFiles=5                      \  // :filecount=5,filesize=10M &lt;br/&gt;-XX:GCLogFileSize=10M                         \  // :filecount=5,filesize=10M &lt;br/&gt;-Xloggc:/var/&lt;span&gt;log&lt;/span&gt;/`date +%FT%H-%M-%S`-gc.log   \  // -Xlog::file=/var/&lt;span&gt;log&lt;/span&gt;/%t-gc.log &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变迁后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xlog:&lt;br/&gt;  gc*, &lt;br/&gt;  safepoint, &lt;br/&gt;  gc+heap=debug, &lt;br/&gt;  gc+ergo*=trace, &lt;br/&gt;  gc+age*=trace, &lt;br/&gt;  :file=/var/&lt;span&gt;log&lt;/span&gt;/%t-gc.log &lt;br/&gt;  :time,tags,level &lt;br/&gt;  :filecount=5,filesize=10M &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;推荐的配置&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xlog:&lt;br/&gt;  // selections&lt;br/&gt;    codecache+sweep*=trace,&lt;br/&gt;    class+unload,                      // TraceClassUnloading&lt;br/&gt;    class+load,                        // TraceClassLoading&lt;br/&gt;    os+thread,&lt;br/&gt;    safepoint,                        // TraceSafepoint&lt;br/&gt;    gc*,                              // PrintGCDetails&lt;br/&gt;    gc+stringdedup=debug,             // PrintStringDeduplicationStatistics&lt;br/&gt;    gc+ergo*=trace,&lt;br/&gt;    gc+age=trace,                     // PrintTenuringDistribution&lt;br/&gt;    gc+phases=trace,&lt;br/&gt;    gc+humongous=trace,&lt;br/&gt;    jit+compilation=debug&lt;br/&gt;// output&lt;br/&gt;:file=/path_to_logs/app.log   &lt;br/&gt;// decorators               &lt;br/&gt;:level,tags,time,uptime,pid&lt;br/&gt;// output-options                &lt;br/&gt;:filesize=104857600,filecount=5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;*运行相关*&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;反射+私有 API 调用之伤&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java8 中，没有人能阻止你访问特定的包，比如 sun.misc，对反射也没有限制，只要 setAccessible(true) 就可以了。Java9 模块化以后，一切都变了，只能通过 &lt;code&gt;--add-exports&lt;/code&gt;和 &lt;code&gt;--add-opens&lt;/code&gt; 来打破模块封装&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--add-opens&lt;/code&gt; 导出特定的包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--add-opens&lt;/code&gt; 允许模块中特定包的类路径深度反射访问&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--add-opens java.base/java.lang=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.io=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.math=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.net=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.nio=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.security=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.text=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.time=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/java.util=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/jdk.internal.access=ALL-UNNAMED &lt;br/&gt;--add-opens java.base/jdk.internal.misc=ALL-UNNAMED&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;关于 GC 算法的选择&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CMS 正式退出历史舞台，G1 正式接棒，ZGC 蓄势待发。在GC 算法的选择上，目前来看 G1 还是最佳的选择，ZGC 因为有内存占用被 OS 标记过高（三倍共享内存）虚高的问题，进程可能被 OOM-killer 杀掉。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;ZGC 三倍 RES 内存&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZGC 底层用到了一个称之为染色指针的技术，使用三个视图（Marked0、Marked1 和 Remapped）来映射到同一块共享内存区域，原理如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;##include &amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;sys/mman.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;cstdio&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;##include &amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;int &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    // shm_open()函数用来打开或者创建一个共享内存区，两个进程可以通过给shm_open()函数传递相同的名字以达到操作同一共享内存的目的&lt;br/&gt;    int fd = ::shm_open(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;, O_RDWR | O_CREAT | O_EXCL, 0600);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (fd &amp;lt; 0) {&lt;br/&gt;        shm_unlink(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;);&lt;br/&gt;        perror(&lt;span&gt;&quot;shm open failed&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    size_t size = 1 * 1024 * 1024 * 1024;&lt;br/&gt;    // 创建一个共享内存后，默认大小为0，所以需要设置共享内存大小。ftruncate()函数可用来调整文件或者共享内存的大小&lt;br/&gt;    ::ftruncate(fd, size);&lt;br/&gt;    int prot = PROT_READ | PROT_WRITE;&lt;br/&gt;    // 创建共享内存后，需要将共享内存映射到调用进程的地址空间，可通过mmap()函数来完成&lt;br/&gt;    uint32_t *p1 = (uint32_t *) (mmap(nullptr, size, prot, MAP_SHARED, fd, 0));&lt;br/&gt;    uint32_t *p2 = (uint32_t *) (mmap(nullptr, size, prot, MAP_SHARED, fd, 0));&lt;br/&gt;    uint32_t *p3 = (uint32_t *) (mmap(nullptr, size, prot, MAP_SHARED, fd, 0));&lt;br/&gt;    ::close(fd);&lt;br/&gt;    *p1 = 0xcafebabe;&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr1: %p, value is 0x%x\n&quot;&lt;/span&gt;, p1, *p1);&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr2: %p, value is 0x%x\n&quot;&lt;/span&gt;, p2, *p2);&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr3: %p, value is 0x%x\n&quot;&lt;/span&gt;, p3, *p3);&lt;br/&gt;    ::getchar();&lt;br/&gt;    *p2 = 0xcafebaba;&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr1: %p, value is 0x%x\n&quot;&lt;/span&gt;, p1, *p1);&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr2: %p, value is 0x%x\n&quot;&lt;/span&gt;, p2, *p2);&lt;br/&gt;    ::&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;Address of addr3: %p, value is 0x%x\n&quot;&lt;/span&gt;, p3, *p3);&lt;br/&gt;    ::getchar();&lt;br/&gt;    munmap(p1, size);&lt;br/&gt;    munmap(p2, size);&lt;br/&gt;    munmap(p3, size);&lt;br/&gt;    shm_unlink(&lt;span&gt;&quot;/test&quot;&lt;/span&gt;);&lt;br/&gt;    std::cout &amp;lt;&amp;lt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt; &amp;lt;&amp;lt; std::endl;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以想象 p1、p2、p3 这三块内存区域就是 ZGC 中三种视图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在 linux 统计中，虽然是共享内存，但是依然会统计三次，比如 RES。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同一个应用，使用 G1 RES 显示占用 2G，ZGC 则显示占用 6G&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java -XX:+AlwaysPreTouch -Xms2G -Xmx2G -XX:+UseZGC MyTest&lt;br/&gt;java -XX:+AlwaysPreTouch -Xms2G -Xmx2G -XX:+UseG1GC MyTest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5101851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLFWa4hghy0U5fNTHGXo1g0eVfibuZyhnGEuuSyjKkt9l5VzEoZ9dgPAlvq2j0nN8hYuyKMaoUG9H7Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下面我们讨论的都是 G1 相关的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;G1 参数调整&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;不要配置新生代的大小&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个在《JVM G1 源码分析和调优》一书里有详细的介绍，有两个主要的原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;G1对内存的管理是不连续的，重新分配一个分区代价很低&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;G1 的需要根据目标停顿时间动态调整搜集的分区的个数，如果不能调整新生代的大小，那么 G1 可能不能满足停顿时间的要求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;诸如 &lt;code&gt;-Xmn, -XX:NewSize, -XX:MaxNewSize, -XX:SurvivorRatio&lt;/code&gt; 都不要在 G1 中出现，只需要控制最大、最小堆和目标暂停时间即可&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;调整 &lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt; 到合适的值&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IHOP 默认值为 45，这个值是启动并发标记的先决条件，只有当老年代内存栈总空间的 45% 之后才会启动并发标记任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;增加这个值：导致并发标记可能花费更多的时间，同时导致 YGC 和 Mixed-GC 收集时的分区数变少，可以根据整体应用占用的平均内存来设置。&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;来源：&lt;/span&gt;&lt;span&gt;juejin.cn/post/7117531586232320031&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;版权声明：此内容来源网络，版权归原作者所有。我们转载的内容，都会注明来源，除非无法确认。若有侵权，烦请告知，我们会立即删除并表示歉意。谢谢！&lt;/span&gt;&lt;/blockquote&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;PS：文章若对您有用，请帮助 &lt;strong&gt;点赞、在看、转发&lt;/strong&gt; 吧！&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;公众号：Java精选&quot; data-id=&quot;91842&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;点击卡片关注我们，更多技术干货，及时为您送达！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzU0ODk2MzE3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib178LnVu9br0VUuI4OKYwvXKpZnaGseFG3vyFJShp2VFcwVodS88CkUsNYcLDrglYLHPFoic6MJD4A/0?wx_fmt=png&quot; data-nickname=&quot;逻魔代码&quot; data-alias=&quot;lomagicode&quot; data-signature=&quot;逻魔代码，分享架构技术干货，打造有价值的经验分享社群，帮助后继者以前人的肩膀为基，建造更精妙的技术殿堂！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;&lt;p mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485467&amp;amp;idx=1&amp;amp;sn=af235ce4464f9adb2fd2038727cb3435&amp;amp;chksm=fbb65e16ccc1d70031c297626d26de452d3c294fd3ed9ac3d39b9b646a1eb1d5cc94f41a0e88&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;拒绝暴力 kill -9 ！我选择这样优雅停止 SpringBoot 服务&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;拒绝暴力 kill -9 ！我选择这样优雅停止 SpringBoot 服务&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485409&amp;amp;idx=2&amp;amp;sn=e82e7cd34d9faeee40d2022bc49f3464&amp;amp;chksm=fbb651ecccc1d8fab6f078bd79f8f7d53445f4ad7ac26055b5635670fe30927ef574e5a6a750&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;优雅地处理重复请求/并发请求&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;优雅地处理重复请求/并发请求&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485370&amp;amp;idx=1&amp;amp;sn=a5dc9c8df141cf83655c2ea0f235b09a&amp;amp;chksm=fbb651b7ccc1d8a121e32d113045a4cdfcfc550c314e4956386d899dd9c7ba649b83a31d9c7c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ULID规范解读与实现原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ULID规范解读与实现原理&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485246&amp;amp;idx=1&amp;amp;sn=4deca9c75a6aa9de9883e388916496f4&amp;amp;chksm=fbb65133ccc1d8257ae41dd8fe710d7cea93a312e6aa0f2079f4a140416dbf17f9a03866c895&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何设计一个短链接系统？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;如何设计一个短链接系统？&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b4c9d0056972b85dbc21f2bf1acb67da</guid>
<title>最适合程序员的画图工具？</title>
<link>https://toutiao.io/k/hlv8j4z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图解网站上线以来，一直有很多同学喜欢我画的图，然后很多同学就很好奇，我这些技术文章的配图是用什么工具画的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，今天就再啰嗦聊一下， 画图这件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的图解类的文章，可以说图片是灵魂之处，没有了图片，相当于失去了灵魂，技术文章本身就很枯燥，如果文章中没有几张图片，很多人看着看着就被劝退了，剩下没被劝退的估计看着看着就睡着了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，一张图片的信息，胜过几千字的解释。文字的描述都线性的，有时候解释的地方，可能看着迷糊的同学，都不知道在解释哪个问题。而画图去解释一个问题，图片里包含了很多信息，就能一目了然的知道在说什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有的读者会说自己不写文章呀，是不是没有必要了解画图了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得这是不对，画图在我们工作中其实也是有帮助的。比如，如果你想跟领导汇报一个业务流程的问题，把业务流程画出来，肯定用图的方式比用文字的方式交流起来会更有效率，更轻松些，我自己常常通过这种方式跟领导反馈问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如说，如果你参与了一个比较复杂的项目开发，你也可以把代码的流程图给画出来，不仅能帮助自己加深理解，也能帮助后面参与的同事能更快的接手这个项目，甚至如果你要晋升级别了，演讲 PTT 里的配图也是必不可少的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过很多人都是纠结用什么画图工具，其实小林觉得再烂的画图工具，只要你思路清晰，确定自己要表达出什么信息，也是能把图画好的，所以不必纠结哪款画图工具，挑一款自己画起来舒服的就行了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;画图工具&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“小林，你说的我都懂，我就是喜欢你的画图风格嘛，你就说说你用啥画的？”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没问题，直接坦白讲，我用了 2 年的画图工具是：&lt;strong&gt;draw.io&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的图解文章里的图片全是在 draw.io 这个工具画的，写了那么久的图解文章，再加上我工作中也有画图的习惯，累计也有在上面画了接近 1000+ 张图片。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择它的原因很简单，因为是免费的，而且图片的源文件可以直接保存到 Github 的，这样非常方便，相当于直接云备份到了 Github 仓库里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;draw.io 画图工具可以在线画图，或者下载应用，或者作为 visual studio code 插件来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我比较常用的方式是在线画图，就是直接在网站上画图。draw.io 一开始的画图网站地址就是直接在浏览器输入 draw.io  地址后，就会自动进入在线画图工具页面，现在它改版了， 改成重定向到官网地址了，所以现在想进入在线画图工具页面，地址是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看这个画图工具的页面长什么样子，主要分为三个区域，从左往右的顺序是「图形选择区域、绘图区域、属性设置区域」。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5897435897435898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavf7WPKNic9T7Ka5hAaASuQI0YhiaueRCJjOlvBmSibJohon9asCv0Zz0Nuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，最左边的「图形选择区域」可以选择的图案有很多种，常见的流程图、时序图、表格图都有，甚至还可以在最左下角的「更多图形」找到其他种类的图形，比如网络设备图标等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7366197183098592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavf3Fkhnwtj4UPmEDMiaicv0cXXbybmwjuym5K1nslpZ1ACuEhyhz0HroZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来，最右边「属性设置区域」可以设置文字的大小，图片颜色、线条形状等，而我最常用颜色板块是下面这三种，都是比较浅色的，这样看起来舒服些。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5617021276595745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfIGng8qTcFQFyGjSRUvouMhyAdmaAuXNSNFbxiakY3KibzM5d2XLGbf7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;235&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.538135593220339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfwQnumv4nuiay6nxrvbTk1DIp1Im77uKmz66BW01sszWKgp6PaV4mRjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;236&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;基本图形介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我常用的一个图形是圆角方块图，它的位置如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4439511653718091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfAD0vg4XIvROI5yczzuTEuP3IOcDVIXpe8ib6icVghC6wibz3WqPvIUfgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它默认的颜色过于深色，如果要在方框图中描述文字，则可能看不清楚，这时我会在最右侧的「属性设置区域」把方块颜色设置成浅色系列的。另外，还有一点需要注意的是，默认的字体大小比较小，我一般会调成 &lt;code&gt;16px&lt;/code&gt; 大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你不喜欢上图的带有「划痕」的圆角方块图形，可以选择下图中这个最简洁的圆角方框图形。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6898395721925134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfFNPnVnMQ4OcRmJjgWKcVz2xaN05UgnlDpMAkN1cRWxocC8LdlLpcQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个简洁的圆角方框图形，再搭配颜色，能组合成很多结构图，比如我用过它组成过 CPU Cache 的结构图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6649056603773585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfbEJeao9NdL4q2Fkria8S3m7qtO9wy0Ficnh1ay2OJrn6xb8Wh9LPibGFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1325&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那直角方框图形，我主要是用来组成「表格」，原因自带的表格不好看，也不方便调。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4218551461245235&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfPdWZTTLkicggZRvh8POEyt6iavNClayHbvBdSdBZlEePg08VFic4gEv1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我用直角方框图形，画过「不同层级的存储器之间的成本对比表格」。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6437054631828979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfrx3NibIfC7eU1GibIiakTS1ljgv25nwOFhmFR7Wicy6j35brkGvbU5evTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得直直的线条太死板，你可以把图片属性中的「&lt;em&gt;Comic&lt;/em&gt;」勾上，于是就会变成歪歪扭扭的效果啦，有点像手绘风格，挺多人喜欢这种风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我用过这种风格画过 TCP 三次握手流程的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8339483394833949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfM8mMA5xwSnebRyfIDpQXpndBnKX8JXYVWdjdHmq1piaiaJTCDfCh0raQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;813&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方块图形再加上菱形，就可以组合成简单程序流程图了，比如我画过「写直达」缓存更新模型的流程图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.371069182389937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfjmLnqiadrI8a0G1agBQ42BHhlWHd6Mft1zTicIopB0DNA2l6u6MpXXvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，不要小看这些基本图形，只要构思清晰，再基本的图形，也是能构成层次分明并且好看的图。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;各种组合画图&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本的图形介绍完后，相信你画一些简单程序流程图等图形是没问题的了，接下来就是各种&lt;strong&gt;图形 + 线条&lt;/strong&gt;的组合的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过一些基本的图形组合，你还可以画出时序图，时序图可以用来描述多个对象之间的交互流程，比如我画过多个线程获取互斥锁的时序图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.178147268408551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfef9eIasmuqaXqYXktp1dCp8zqSDcrPicOJwlXiaxmTbjEeqvfliaRxqIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来，为了更好表达零拷贝技术的过程，那么用图的方式会更清晰。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5913793103448276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfHpk2JbqibPlWNZr2AZ8cAiciaR0RezAmUrcI8ZpMlrWbQFUEcCs7ZSdiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以，只用一张图就描述 MySQL 执行一条 SQL 查询语句的流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717684377478192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfLGJib8AE8B8eGibjNUTUHhbFO3ia3uNP2XlQiaVgCOw3Z56bOhbF0LUDlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1261&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，draw.io 这个画图工具，不只有简单图形，还有其他自带的设备类图形。通常我都会这些设备类型的图标来画网络图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我之前画过路由器寻址的图片。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7923976608187134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfZWTygcHD9oannuUQEiaOKicJkz1fXn7QM32dULJ4r4ClEYlx1cRYZlnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;figcaption&gt;IP地址的网络号&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要说，我画过最复杂的图，那就是写 TCP 流量控制的时候，把整个交互过程 + 文字描述 + 滑动窗口状况都画出来了，现在回想起来还是觉得累人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5532837670384139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZficuzgBOOnHH0JS8nMXKiavfxTq3mamz3stu4Wo4PAMExAStvhoViaAkz1cvuXtum0WkuUhrMWfDo8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有好多好多，我就比一一列举了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;图床&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前用的图床是一套免费的图床，但是踩过坑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我发现这类免费图床用着用着就不能用了，然后每次迁移图片我都花费很多时间去搞，&lt;strong&gt;果然免费就是最贵的&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，后来我就干脆自己掏钱搞了个图床，在云厂商那买了 OSS 存储服务器，然后在加上 CDN 形成自己的图床。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前还写过我迁移图片的经历：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247511496&amp;amp;idx=1&amp;amp;sn=8f03ecc4b9c6591b80898808ee11ede7&amp;amp;chksm=f98de962cefa60743c3da2899898289bc26b4487f7a9e646689be90264bb7ca3da5c39ece9af&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;完了，小林网站的图片都挂了&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思维导图工具&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用的思维导图工具是 xmind，是国产的。他们软件的交互设计做的很不错，很简洁明了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有很多种风格选择，基本都是五彩的，整体挺好看的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXTyu4ichuHwJicktpYCuMoSbHELk3icnE5Kc5XBltpxdAibb0wYqVibzN2ag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有意思的地方，这个思维导图工具的右侧会有一些图标图片选择，比如表情图片、标签图片、进度图图片等等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5962962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXkOjwqbj2YCibnMEkWWTre7fjbKz5m9HwJZ9NdylzYvEUqicg9zYtuALQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;习惯用思维导图做笔记的同学， xmind 这个思维导图工具是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我有时会使用 Effie 这个工具来生成思维导图，它本身是一个写作的工具，但是自带一个根据文字内容生成思维导图的功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXTw6zXk1FovsoWE6BXpDN76er0cOhJp5MKKUFt51MDdzl3tDyW0sssA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码贴图工具&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想展示你的代码，又苦于源代码的样式不好看，则可以使用一个生成漂亮的代码贴图网站。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地址：&lt;strong&gt;https://carbon.now.sh&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6898148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXcDc9wAuwEw10VerbofheaYz2CBx8d735pPIGPUC0SUnzYy2CF8BUrQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导出图片后，就一张漂亮的代码展示图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXOoZfpTqF6vibkqmIm0O876S1rWbDkRnsicCWCnLpKgSI3b9YQO6yCbNw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两年下来，我感觉至少画了 &lt;code&gt;1000+&lt;/code&gt; 张图了，每一张图其实还是挺费时间的，相信画过图的朋友后，都能体会到这种感觉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但没办法，谁叫我是图解工具人呢，画图可以更好的诠释文章内容，但最重要的是，把你们吸引过来了，这是件让我非常高兴的事情，也是让我感觉画图这个事情值得认真做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文字的分享有局限性，关键还是要你自己动手摸索摸索，形成自己一套画图的方法论，练习的时候可以先从模仿画起，后面再结合工作或文章的需求画出自己心中的那个图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后罗列一下，我常用工具：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;画图工具：draw.io&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;思维导图工具：xmind&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码贴图工具：carbon&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文章编写工具：typora、语雀&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你们知道其他不错的画图工具，欢迎留言说一下。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a020283810a3e488dd96dce58d920985</guid>
<title>面试官：在 Java 中 new 一个对象的流程是怎样的？彻底被问懵了</title>
<link>https://toutiao.io/k/q557n2e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;关注Java核心技术，推送更多 Java 干货！&lt;/span&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MjMwMzg2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0O7U43sFsL7GZfHGBMl4cEv4cSQoun7RjomHCiaroWXu9h9S1TX2XQQcX6xMMrZD0ANZ0KJDWVQmpw/0?wx_fmt=png&quot; data-nickname=&quot;Java核心技术&quot; data-alias=&quot;java-core&quot; data-signature=&quot;专注分享Java核心技术干货，包括Java多线程、IO、JVM、Spring Boot、Spring Cloud、IntelliJ IDEA、Dubbo、Zookeeper、Redis、架构、微服务、消息队列、Git、面试题、最新动态等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象怎么创建，这个太熟悉了，new一下(其实还有很多途径，比如反射、反序列化、clone等，这里拿最简单的new来讲)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Dog dog = new Dog();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们总是习惯于固定语句的执行，却对于背后的实现过程缺乏认知，而理解这个过程对后面晦涩难懂的反射和代理其实会有很大帮助，所以请务必学好这块内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在看这篇文章之前，啰嗦一句：如果你死记硬背下面所说的流程等于白看，就算现在记住了，一个礼拜后呢，一个月后你又能记得多少，因为对象创建过程这个知识点平常的工作中基本不会涉及到，太底层了，背熟的知识点不经常加以运用容易遗忘，所以我的建议是什么呢，流程做到心里大概有个数，其中涉及到关键的知识点记牢就可以了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;JVM内存&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247501926&amp;amp;idx=1&amp;amp;sn=bfae8f0369187e45f6b78ee7fe341c06&amp;amp;chksm=9f22ddf2a85554e4b512353067976913167415dca2b12f6b311f1bdaa09a348b2dd6b1af54ea&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;先简单说下java虚拟机内存模型和存放内容的区别，两部分：栈内存 存放基本类型数据和对象的引用变量，数据可以直接拿来访问，速度比堆快堆内存 存放创建的对象和数组，会由java虚拟机的自动垃圾回收来管理（GC）,创建一个对象放入堆内的同时也会在栈中创建一个指向该对象堆内存中的地址引用变量，下面说的对象就是存在该内存中下面我们就按照对象生成的过程来一一讲解参与其中过程的各个概念首先有这么一个类，后面的初始化基于这个讲解：/** * @author 炜哥 * @since 2021-04-18 11:01:41 * * 执行顺序：（优先级从高到低。）静态代码块&amp;gt;构造代码块&amp;gt;构造方法&amp;gt;普通方法。 * 其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。 */public class Dog {    //默认狗狗的最大年龄是16岁    private static int dog_max_age = 16;    //狗狗的名字    private String dog_name;    {        System.out.println(&amp;quot;狗狗的构造代码块&amp;quot;);    }    static {        System.out.println(&amp;quot;狗狗的静态代码块&amp;quot;);    }    //无参构造器故意没设    //有参构造器    public Dog(String dog_name) {        this.dog_name = dog_name;    }    public void getDogInfo(){        System.out.println(&amp;quot;名字是:&amp;quot;+dog_name + &amp;quot;  年龄：&amp;quot; + dog_max_age);    }    //狗叫    public static void barking(){        System.out.println(&amp;quot;汪汪汪~~~&amp;quot;);    }}JVM生成.class文件一个java文件会在编译期间被初始化生成.class字节码文件，字节码文件是专门给JVM阅读的，我们平时吭哧吭哧写的一行行代码最终都会被编译成机器能看懂的语句，这个文件后面会被类加载器加载到内存。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;先简单说下java虚拟机内存模型和存放内容的区别，两部分：&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就按照对象生成的过程来一一&lt;span&gt;讲解参与其中过程的各个概念&lt;/span&gt;&lt;span&gt;。最新最全的 Java 面试题整理好了，点击&lt;/span&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot;&gt;&lt;span&gt;Java面试库&lt;/span&gt;&lt;/a&gt;&lt;span&gt;小程序在线刷题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247501926&amp;amp;idx=1&amp;amp;sn=bfae8f0369187e45f6b78ee7fe341c06&amp;amp;chksm=9f22ddf2a85554e4b512353067976913167415dca2b12f6b311f1bdaa09a348b2dd6b1af54ea&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;先简单说下java虚拟机内存模型和存放内容的区别，两部分：栈内存 存放基本类型数据和对象的引用变量，数据可以直接拿来访问，速度比堆快堆内存 存放创建的对象和数组，会由java虚拟机的自动垃圾回收来管理（GC）,创建一个对象放入堆内的同时也会在栈中创建一个指向该对象堆内存中的地址引用变量，下面说的对象就是存在该内存中下面我们就按照对象生成的过程来一一讲解参与其中过程的各个概念首先有这么一个类，后面的初始化基于这个讲解：/** * @author 炜哥 * @since 2021-04-18 11:01:41 * * 执行顺序：（优先级从高到低。）静态代码块&amp;gt;构造代码块&amp;gt;构造方法&amp;gt;普通方法。 * 其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。 */public class Dog {    //默认狗狗的最大年龄是16岁    private static int dog_max_age = 16;    //狗狗的名字    private String dog_name;    {        System.out.println(&amp;quot;狗狗的构造代码块&amp;quot;);    }    static {        System.out.println(&amp;quot;狗狗的静态代码块&amp;quot;);    }    //无参构造器故意没设    //有参构造器    public Dog(String dog_name) {        this.dog_name = dog_name;    }    public void getDogInfo(){        System.out.println(&amp;quot;名字是:&amp;quot;+dog_name + &amp;quot;  年龄：&amp;quot; + dog_max_age);    }    //狗叫    public static void barking(){        System.out.println(&amp;quot;汪汪汪~~~&amp;quot;);    }}JVM生成.class文件一个java文件会在编译期间被初始化生成.class字节码文件，字节码文件是专门给JVM阅读的，我们平时吭哧吭哧写的一行行代码最终都会被编译成机器能看懂的语句，这个文件后面会被类加载器加载到内存。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;首先有这么一个类，后面的初始化基于这个讲解：&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247501926&amp;amp;idx=1&amp;amp;sn=bfae8f0369187e45f6b78ee7fe341c06&amp;amp;chksm=9f22ddf2a85554e4b512353067976913167415dca2b12f6b311f1bdaa09a348b2dd6b1af54ea&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;先简单说下java虚拟机内存模型和存放内容的区别，两部分：栈内存 存放基本类型数据和对象的引用变量，数据可以直接拿来访问，速度比堆快堆内存 存放创建的对象和数组，会由java虚拟机的自动垃圾回收来管理（GC）,创建一个对象放入堆内的同时也会在栈中创建一个指向该对象堆内存中的地址引用变量，下面说的对象就是存在该内存中下面我们就按照对象生成的过程来一一讲解参与其中过程的各个概念首先有这么一个类，后面的初始化基于这个讲解：/** * @author 炜哥 * @since 2021-04-18 11:01:41 * * 执行顺序：（优先级从高到低。）静态代码块&amp;gt;构造代码块&amp;gt;构造方法&amp;gt;普通方法。 * 其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。 */public class Dog {    //默认狗狗的最大年龄是16岁    private static int dog_max_age = 16;    //狗狗的名字    private String dog_name;    {        System.out.println(&amp;quot;狗狗的构造代码块&amp;quot;);    }    static {        System.out.println(&amp;quot;狗狗的静态代码块&amp;quot;);    }    //无参构造器故意没设    //有参构造器    public Dog(String dog_name) {        this.dog_name = dog_name;    }    public void getDogInfo(){        System.out.println(&amp;quot;名字是:&amp;quot;+dog_name + &amp;quot;  年龄：&amp;quot; + dog_max_age);    }    //狗叫    public static void barking(){        System.out.println(&amp;quot;汪汪汪~~~&amp;quot;);    }}JVM生成.class文件一个java文件会在编译期间被初始化生成.class字节码文件，字节码文件是专门给JVM阅读的，我们平时吭哧吭哧写的一行行代码最终都会被编译成机器能看懂的语句，这个文件后面会被类加载器加载到内存。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * @author 炜哥&lt;br/&gt; * @since 2021-04-18 11:01:41&lt;br/&gt; *&lt;br/&gt; * 执行顺序：（优先级从高到低。）静态代码块&amp;gt;构造代码块&amp;gt;构造方法&amp;gt;普通方法。&lt;br/&gt; * 其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。&lt;br/&gt; */&lt;br/&gt;public class Dog {&lt;br/&gt;&lt;br/&gt;    //默认狗狗的最大年龄是16岁&lt;br/&gt;    private static int dog_max_age = 16;&lt;br/&gt;&lt;br/&gt;    //狗狗的名字&lt;br/&gt;    private String dog_name;&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗狗的构造代码块&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    static {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;狗狗的静态代码块&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    //无参构造器故意没设&lt;br/&gt;    //有参构造器&lt;br/&gt;    public Dog(String dog_name) {&lt;br/&gt;        this.dog_name = dog_name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void &lt;span&gt;getDogInfo&lt;/span&gt;(){&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;名字是:&quot;&lt;/span&gt;+dog_name + &lt;span&gt;&quot;  年龄：&quot;&lt;/span&gt; + dog_max_age);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    //狗叫&lt;br/&gt;    public static void &lt;span&gt;barking&lt;/span&gt;(){&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;汪汪汪~~~&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/a&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;JVM生成.class文件&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247501926&amp;amp;idx=1&amp;amp;sn=bfae8f0369187e45f6b78ee7fe341c06&amp;amp;chksm=9f22ddf2a85554e4b512353067976913167415dca2b12f6b311f1bdaa09a348b2dd6b1af54ea&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;先简单说下java虚拟机内存模型和存放内容的区别，两部分：栈内存 存放基本类型数据和对象的引用变量，数据可以直接拿来访问，速度比堆快堆内存 存放创建的对象和数组，会由java虚拟机的自动垃圾回收来管理（GC）,创建一个对象放入堆内的同时也会在栈中创建一个指向该对象堆内存中的地址引用变量，下面说的对象就是存在该内存中下面我们就按照对象生成的过程来一一讲解参与其中过程的各个概念首先有这么一个类，后面的初始化基于这个讲解：/** * @author 炜哥 * @since 2021-04-18 11:01:41 * * 执行顺序：（优先级从高到低。）静态代码块&amp;gt;构造代码块&amp;gt;构造方法&amp;gt;普通方法。 * 其中静态代码块只执行一次。构造代码块在每次创建对象是都会执行。 */public class Dog {    //默认狗狗的最大年龄是16岁    private static int dog_max_age = 16;    //狗狗的名字    private String dog_name;    {        System.out.println(&amp;quot;狗狗的构造代码块&amp;quot;);    }    static {        System.out.println(&amp;quot;狗狗的静态代码块&amp;quot;);    }    //无参构造器故意没设    //有参构造器    public Dog(String dog_name) {        this.dog_name = dog_name;    }    public void getDogInfo(){        System.out.println(&amp;quot;名字是:&amp;quot;+dog_name + &amp;quot;  年龄：&amp;quot; + dog_max_age);    }    //狗叫    public static void barking(){        System.out.println(&amp;quot;汪汪汪~~~&amp;quot;);    }}JVM生成.class文件一个java文件会在编译期间被初始化生成.class字节码文件，字节码文件是专门给JVM阅读的，我们平时吭哧吭哧写的一行行代码最终都会被编译成机器能看懂的语句，这个文件后面会被类加载器加载到内存。&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一个java文件会在编译期间被初始化生成.class字节码文件，字节码文件是专门给JVM阅读的，我们平时吭哧吭哧写的一行行代码最终都会被编译成机器能看懂的语句，这个文件后面会被类加载器加载到内存。&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4458874458874459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtwuL2icULhZw8IZUYGIscF4DmTicjHdZwXB3ibkC9xvXGJojkRu69oKMug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;类加载器加载.class文件&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《深入理解Java的虚拟机》中大概有这么一句话：在虚拟机遇到一条new的指令时，会去检查一遍在静态常量池中能否定位到一个类的符号引用 （就这个类的路径+名字），并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果不是第一次使用，那必须先执行相应的类加载过程，这个过程由类加载器来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载字面意思就可以理解成加载class文件，更准确点的说法就是会把class文件变成一个二进制流加载到内存中，即把类的描述信息加载到Metaspace，至于类加载器如何找到并把一个class文件转成IO流加载到内存中，我后面会专门写一篇关于类加载器的文章，这里就只要理解创建对象中有这么一步就行了。不过这里面有很重要的概念不得不讲：Class对象&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;知识扩展：Class对象&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;划重点，这是个非常重要的概念，理解它对于理解后面的反射和代理会有很大的帮助&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器 ClassLoader 加载class文件时，会把类里的一些数值常量、方法、类信息等加载到内存中，称之为类的元数据，最终目的是为了生成一个Class对象用来描述类，这个对象会被保存在.class文件里，可能有新手看到这里会比较懵逼，class也有对象？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，Class是个实实在在的类（用来描述类的类，比较拗口），有构造方法（ private ，意味着可以生成对象，但不能手动生成，由JVM自动创建Class对象）,类加载器会给每个java文件都创建一个Class对象，用来描述类，我画个图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.059773828756058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtono9oVcGM3GdoAGPWyVnwV2DtJhjr3DzbMm0I3hQiaMGMcP7lyumqfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;619&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//以下操作只能由jvm完成，我们手动做不了&lt;br/&gt;Class cls1 = new Class(Dog.class.getClassLoader());&lt;br/&gt;Class cls2 = new Class(Cat.class.getClassLoader());&lt;br/&gt;Class cls3 = new Class(People.class.getClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11270983213429256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtwMS97ibdq2tBn2kJdygdicdAZLKMpOEY24CvX2p9aUXabJqSzPkeHMSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;417&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Class对象除了描述对应的类之外还有什么作用呢？也可以生成对象，就是java的反射概念（通过Class实例获取类信息） 上面说了，Class类是用来描述像People.Class类的类，那么它里面肯定包含了所有能够描述该class的所有属性，比如类名、方法、接口等，我们先到Class类源码中瞄一眼：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3502202643171806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtCL9f8jWrhn9ohuttK1vtcChG5nej3CO07RDl2OSECQzqSksfM5sg0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;454&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面有个方法 &lt;code&gt;newInstance()&lt;/code&gt;，即创建对象， 我把源代码贴出来并简单解析下：&lt;span&gt;关注Java核心技术，推送更多 Java 干货！&lt;/span&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;64&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MjMwMzg2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0O7U43sFsL7GZfHGBMl4cEv4cSQoun7RjomHCiaroWXu9h9S1TX2XQQcX6xMMrZD0ANZ0KJDWVQmpw/0?wx_fmt=png&quot; data-nickname=&quot;Java核心技术&quot; data-alias=&quot;java-core&quot; data-signature=&quot;专注分享Java核心技术干货，包括Java多线程、IO、JVM、Spring Boot、Spring Cloud、IntelliJ IDEA、Dubbo、Zookeeper、Redis、架构、微服务、消息队列、Git、面试题、最新动态等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@CallerSensitive&lt;br/&gt;public T newInstance()&lt;br/&gt;    throws InstantiationException, IllegalAccessException&lt;br/&gt;    {&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (System.getSecurityManager() != null) {&lt;br/&gt;            checkMemberAccess(Member.PUBLIC, Reflection.getCallerClass(), &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (cachedConstructor == null) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (this == Class.class) {&lt;br/&gt;                throw new IllegalAccessException(&lt;br/&gt;                    &lt;span&gt;&quot;Can not call newInstance() on the Class for java.lang.Class&quot;&lt;/span&gt;&lt;br/&gt;                );&lt;br/&gt;            }&lt;br/&gt;            try {&lt;br/&gt;                Class&amp;lt;?&amp;gt;[] empty = {};&lt;br/&gt;                //声明无参构造对象&lt;br/&gt;                final Constructor&amp;lt;T&amp;gt; c = getConstructor0(empty, Member.DECLARED);&lt;br/&gt;                // Disable accessibility checks on the constructor&lt;br/&gt;                // since we have to &lt;span&gt;do&lt;/span&gt; the security check here anyway&lt;br/&gt;                // (the stack depth is wrong &lt;span&gt;for&lt;/span&gt; the Constructor&lt;span&gt;&#x27;s&lt;br/&gt;                // security check to work)&lt;br/&gt;                java.security.AccessController.doPrivileged(&lt;br/&gt;                    new java.security.PrivilegedAction&amp;lt;Void&amp;gt;() {&lt;br/&gt;                        public Void run() {&lt;br/&gt;                                c.setAccessible(true);&lt;br/&gt;                                return null;&lt;br/&gt;                            }&lt;br/&gt;                        });&lt;br/&gt;                cachedConstructor = c;&lt;br/&gt;            } catch (NoSuchMethodException e) {&lt;br/&gt;             //如果class中没有无参构造方法，那么抛InstantiationException错误&lt;br/&gt;                throw (InstantiationException)&lt;br/&gt;                    new InstantiationException(getName()).initCause(e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        Constructor&amp;lt;T&amp;gt; tmpConstructor = cachedConstructor;&lt;br/&gt;        // Security check (same as in java.lang.reflect.Constructor)&lt;br/&gt;        int modifiers = tmpConstructor.getModifiers();&lt;br/&gt;        if (!Reflection.quickCheckMemberAccess(this, modifiers)) {&lt;br/&gt;            Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();&lt;br/&gt;            if (newInstanceCallerCache != caller) {&lt;br/&gt;                Reflection.ensureMemberAccess(caller, this, null, modifiers);&lt;br/&gt;                newInstanceCallerCache = caller;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        // Run constructor&lt;br/&gt;        try {&lt;br/&gt;         //最终还是调用了无参构造器对象的newInstance方法&lt;br/&gt;            return tmpConstructor.newInstance((Object[])null);&lt;br/&gt;        } catch (InvocationTargetException e) {&lt;br/&gt;            Unsafe.getUnsafe().throwException(e.getTargetException());&lt;br/&gt;            // Not reached&lt;br/&gt;            return null;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;首先搞清楚 newInstance 两种方法区别：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Class.newInstance() &lt;/code&gt;只能够调用无参的构造函数，即默认的构造函数，我们在Class源码里也看到了其实最终还是调用了无参构造器对象 &lt;code&gt;Constructor&lt;/code&gt; 的 &lt;code&gt;newInstance&lt;/code&gt; 方法，举个栗子：Dog.class 中是没有无参构造方法，那么会直接抛出 &lt;code&gt;InstantiationException&lt;/code&gt; 异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//Dog类中只有一个dog_name的有参构造方法&lt;br/&gt;Class c = Class.forName(&lt;span&gt;&quot;com.service.ClassAnalysis.Dog&quot;&lt;/span&gt;);&lt;br/&gt;Dog dog = (Dog) c.newInstance();//直接抛InstantiationException异常&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.180349932705249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtCFZL5NMmdhnA2tysYoIT1NCECdNVrYgRxL20wOvpE5ibZfqiaWL96BCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;743&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Constructor.newInstance() &lt;/code&gt;可以根据传入的参数，调用任意构造构造函数，也可以反射私有构造器（了解就行）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//Dog类中只有一个dog_name的有参构造方法&lt;br/&gt;Constructor cs = Dog.class.getConstructor(String.class);&lt;br/&gt;Dog dog = (Dog) cs.newInstance(&lt;span&gt;&quot;小黑&quot;&lt;/span&gt;);//执行没有问题&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这里面的 &lt;code&gt;newInstance&lt;/code&gt;跟我们这次要说的 new 方法存在区别，两者创建对象的方式不同，创建条件也不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;newInstance&lt;/code&gt; 时必须要保证这类已经加载并且已经建立连接，就是已经被类记载器加载完毕，而 new 不需要&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;class对象的 &lt;code&gt;newInstance&lt;/code&gt; 方法只能用无参构造，上面已经提到了，而 new 不需要&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前者使用的是类加载机制，是一种方法，后者是创建一个新类，一种关键字&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个不能说&lt;code&gt;newInstance&lt;/code&gt; 不方便，相反它在反射、工厂设计模式、代理中发挥了重要作用，后续我也会写下代理和反射，因为理解起来确实有点绕。还有一点需要注意，不管以哪种方式创建对象，对应的Class对象都是同一个&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Dog dog1 = new Dog(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);&lt;br/&gt;Dog dog2 = new Dog(&lt;span&gt;&quot;小黑&quot;&lt;/span&gt;);&lt;br/&gt;Class c = Class.forName(&lt;span&gt;&quot;com.service.classload.Dog&quot;&lt;/span&gt;);//为了测试，加了无参构造&lt;br/&gt;Dog dog3 = (Dog) c.newInstance();&lt;br/&gt;System.out.println(dog1.getClass() == dog2.getClass());&lt;br/&gt;System.out.println(dog1.getClass() == dog3.getClass());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2775330396475771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtDGtTNMAVFuB03WicJicLg4Fnt5A167y48bIZutgfOVicLbhpiafhJV9N9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;454&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;连接和初始化&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此阶段首先为静态static变量内存中分配存储空间，设立初始值（还未被初始化）比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public static int i = 666;//被类加载器加载到内存时会执行，赋予一个初始值&lt;br/&gt;public static Integer ii = new Integer(666);//也被赋值一个初始值&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但请注意，实际上i 的初始值是0，不是666，其他基本数据类型比如boolean的初始值就是false，以此类推。如果是引用类型的成员变量 ii 那么初始值就是null。&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot; href=&quot;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;234&quot; data-backw=&quot;550&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0MLL9tg9jbibpW6dXY4OxKYicWuxmRSiaIBfCu8PiaME0EcrXFQricU3H2LtzpQJWr8ib5n2ibAzpUwPjNyQ/640?wx_fmt=png&quot; data-w=&quot;900&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Dog dog = new Dog(&lt;span&gt;&quot;旺财&quot;&lt;/span&gt;);//在这里打个断点&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行，首先会执行静态成员变量初始化，默认值是0：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32338308457711445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtbC9tV2M6yGMHLqyviaHyZejVko18bzuTEcxjh079HmgWJThOyBpa2eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有例外，如果加上了 final 修饰词那么初始值就是设定的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23785166240409208&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehtEQy0kSPSlh671hQYVuMr1vibtRanMPwyf8tubSqLuoOIs1cnzia46gwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着对已经分配存储空间的静态变量真正赋值，比如为上面的dog_max_age 赋值16，还有执行静态代码块，也就是类似下面的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;static {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;狗狗的静态代码块&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这为止，类的加载过程才算完成。&lt;span&gt;最新最全的 Java 面试题整理好了，点击&lt;/span&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe57fd7ba3fb24ae8&quot; data-miniprogram-path=&quot;pages/index/list/list&quot; data-miniprogram-nickname=&quot;Java面试库&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;0&quot;&gt;Java面试库&lt;/a&gt;&lt;span&gt;小程序在线刷题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;创建实例&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在加载类完毕后，对象的所需大小根据类信息就可以确认了，具体创建的步骤如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;先给对象分配内存（包括本类和父类的所有实例变量，不包括上面的静态变量），并设置默认值，如果有引用对象那么会在栈内存中申请一个空间用来指向的实际对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行初始化代码实例化，先初始化父类再初始化子类，赋予给定值（尊重长辈是java的传统美德）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象实例化完毕后如果存在引用对象的话还需要&lt;strong&gt;把第一步的栈对象指向到堆内存中的实际对象，&lt;/strong&gt;这样一个真正可用的对象才被创建出来。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多估计很多人都没概念，懵逼状态中，其实很简单，我们只要记住new的创建对象就两步：初始化和实例化，再给你们搞一张图:可以简单理解②③④为初始化⑤实例化（可恶，我这该死的责任感！）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8654708520179372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0NOnRkwsnnS7Spibx50wTehthmrk46GjwnlGsVOnhkyuQUniarcyntHJMu7icae868vic1zv7JYyUB2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不指望你能使劲弄懂java虚拟机底层加载创建对象的过程（其实有些步骤我都懒得讲了，因为说出来也都非常理论化，没多大意思），是想让你知道对象的诞生过程有哪几个重要概念参与了，弄懂这些概念比起单单知道对象创建的过程有意义的多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;类加载器，可以找找网上的资料，蛮多的，这块内容做个了解就行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Class类和Class对象的概念，请重点掌握，不然理解反射和动态代理很费劲，spring的源码也会难以理解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;栈内存和堆内存以及对应的基本类型和引用类型，也很重要，争取能基本理解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：blog.csdn.net/qq_16887951/article/details/115872678&lt;/span&gt;&lt;/p&gt;&lt;h4/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最近好文分享&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247505075&amp;amp;idx=1&amp;amp;sn=787d3cc229883c57318bb6cf2d7e406b&amp;amp;chksm=9f22c127a8554831b2f8a7e5dfcba94145ae543fb8ce95e224351d7765f1b1705159bb77791f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2.5W 字详解线程与锁了，面试随便问！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2.5W字详解线程与锁了，面试随便问！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;h4/&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247504982&amp;amp;idx=1&amp;amp;sn=18e322e89f949bc59e79a061b2436de5&amp;amp;chksm=9f22c1c2a85548d4541094808ead4515cab85b76f98804f9b1710b3ac2a7fcf118d92e6a98c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java Bean 转 Map 的巨坑，注意了！！！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java Bean 转 Map 的巨坑，注意了！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MjMwMzg2Nw==&amp;amp;mid=2247504551&amp;amp;idx=1&amp;amp;sn=2c1e98966d08e004567d9fc64bdfc69c&amp;amp;chksm=9f22c733a8554e25e04d626952a783e141f4872b0e5cb8e5356660d5e0bdaeec165c932d8180&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你见过哪些目瞪口呆的 Java 代码？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;你见过哪些目瞪口呆的 Java 代码？&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;更多请关注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;• &lt;strong&gt;&lt;span&gt;Java核心技术&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一个分享Java核心技术干货的公众号&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzA3MjMwMzg2Nw==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/A0bYOQcma0O7U43sFsL7GZfHGBMl4cEv4cSQoun7RjomHCiaroWXu9h9S1TX2XQQcX6xMMrZD0ANZ0KJDWVQmpw/0?wx_fmt=png&quot; data-nickname=&quot;Java核心技术&quot; data-alias=&quot;java-core&quot; data-signature=&quot;专注分享Java核心技术干货，包括Java多线程、IO、JVM、Spring Boot、Spring Cloud、IntelliJ IDEA、Dubbo、Zookeeper、Redis、架构、微服务、消息队列、Git、面试题、最新动态等。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文获取免费资料～&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>