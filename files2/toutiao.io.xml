<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0cba5a05c69bc25cdfff4647a6700138</guid>
<title>春节保卫战：腾讯百万 QPS 线上环境云压测方案解析</title>
<link>https://toutiao.io/k/ra2czkt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;h1 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10084033613445378&quot; data-w=&quot;1071&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe95czZhnamWia6rvd1aenicicPiasMmUOHHu1wyeNicNJsWGa4syzF2PoOAePZEYtZX8jicbEDRPW3KsUlOw/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;导语｜&lt;/span&gt;&lt;span&gt;春节期间腾讯大部分业务进入流量备战的紧张时刻。压测相比于监控而言，是更具主动性的筹备&lt;/span&gt;&lt;span&gt;手段。通过高负载、真实流量的预演，探测系统的瓶颈和发现风险，是服务质量保障体系的重要一环。云压测主要聚焦在压测平台的发压端基础能力构建，本文作者张&lt;/span&gt;&lt;span&gt;泽强分享云压测备战春节期间从压测模型选型、用例编写、测试数据构建到压测报表分析的压测方案。期望对你有帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template-rows=&quot;1&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1 背景与挑战&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2 解决方案&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    2.1 压测模式选型&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    2.2 压测用例编写&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    2.3 测试数据构造&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    2.4 压测报表分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3 实践案例&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    3.1 手Q春保活动&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;    3.2 视频业务容灾演练&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4 总结展望&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;01&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;背景与挑战&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;春节期间，腾讯大部分业务进入春保备战的紧张时刻。节假日高峰时间点上涨五倍十倍的用户流量，给业务稳定性带来不少的挑战。以各位熟知的QQ为例，QQ服务大规模的移动互联网用户，作为一个超大流量应用，面对逢年过节的流量洪峰是它不可忽视的问题。手Q业务每年元旦和春节的0点0分，都会有一波非常高的尖峰。读链路和写链路分不同命令字会数倍地流量飙升。而在线视频业务也面临同样的问题，通过做好容灾演习以验证在各种异常情况下的容灾容错能力，通过压测排查关键服务性能是否存在问题、找到链路性能瓶颈、明确链路服务扩容模型等任务迫在眉睫。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测相比于监控而言，是更具主动性的防备手段。通过高负载、真实流量的预演，用于探测系统的瓶颈和发现风险，是服务保障体系的重要一环。整体来看，云压测的主要应用场景包括：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一，验证新功能上线的吞吐量预期，保障系统稳定性，避免服务上线的流量瞬时击穿。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第二，老旧服务的重构改造。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在降本增效的背景下，如何降低机器的部署成本以带来显著收益，是个值得思考的问题。老旧服务大部分存在业务流量构造的难题，大部分也不存在存量的用例自动化验证机制，会带来比较大的重构挑战。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第三，发现系统瓶颈缺陷以保障大型节点系统稳定性。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;春节、元旦、618、双11等大型活动预演，提前通过全链路压测发现系统瓶颈和缺陷，按照保障目标提前进行扩容、缩容。扩容是为了直接提高系统可处理的最大吞吐量，而缩容是为了验证该服务存在冗余的资源配额，在上游的处理能力跟不上的时候，该资源是浪费的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第四，验证后台服务降级、弹性策略。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;部分业务在服务启动时存在资源预热加载、CPU使用率飙升、OOM等问题。这类问题大部分发生在业务流量比较大的情况下，平时不容易模拟，通过压测将流量线上放大能够有效的复现该场景。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;然而目前，&lt;/span&gt;&lt;span&gt;大部分业务压测是单机器、单服务、单链路的流量模拟，在容量预估场景下容易出现偏差，主要问题如下：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现有系统大部分是微服务体系，存在上下游的链路依赖，第三方的链路不能直接压测（支付、云厂商服务）。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;很多情况下整个服务的瓶颈，不在当前压测服务。而直接采用mockserver 来模拟耗时和返回业务数据，也会隐藏该服务短板。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;其次是流量构造失真问题。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;线上的用户量、关系链、请求参数的维度比较多，无法直接通过编写用例脚本（等价有限的参数构造逻辑）来模拟线上真实流量。固定化参数数据直接导致热点数据异常，也会导致压测失真，无法有效通过局部推算全局的表现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;此外，数据规模没有达到预期。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;大部分服务属于I/O密集型服务，业务瓶颈都在存储层服务，例如mysql、redis、kafka等中间件，是由于持续量变导致的质变。数据规模在翻番的情况下，上下游链路的耗时表现可能呈现出雪崩效应。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此要准确预估服务的容量，在高并发的场景下探测瓶颈和缺陷并不是简单的事情。工欲善其事，必先利其器。如何设计、实现一款好的压测工具并且给业务降低接入成本，是一件持之以恒的事情。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以前面提到的移动端QQ和在线视频为例。手Q在春节期间读链路和写链路分不同命令字会数倍的流量飙升。其中，针对只读链路可以通过集群流量调度做到读链路的压测，但是写链路的压测（主要包含 feed 发表、评论、点赞等交互）较缺乏，测试数据构造复杂，用例编写成本高，是一个亟需解决的问题；此外，云压测之前主要采用JS脚本进行场景编排，图文场景出现了内存占用高，二进制频繁进行数据深拷贝，也给压测机内存资源准备带来不少的压力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面章节我们会详细解析云压测的解决方案，最后分享其在发压端支持手Q和在线视频业务的实践案例。本文对云压测的思考和实践，供抛砖引玉。欢迎继续阅读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;02&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;解决方案&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;云&lt;/span&gt;&lt;span&gt;压测服务的目标是模拟海量用户的真实场景，全方位验证系统可用性和稳定性。简化性能测试工具，让用户更加聚焦业务和性能问题本身。从用户的使用角度，常规的压测流程主要包括以下，其中定位和分析瓶颈是最具备价值一环：&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1794871794871795&quot; data-type=&quot;png&quot; data-w=&quot;1482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4wrFEwaYgeiatl7sicjdSURlnRLAWC4s48ib25FmFHwZBiam6mBvkDWDgaQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实施路径：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过全链路压测精准评估系统上下游服务容量进行扩容、缩容，减少机器部署配额；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过压测将性能测试左移，提前定位和分析性能瓶颈，保障服务稳定性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 压测模式选型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;云压测提供并发模式和RPS (request per second)模式，无论哪种模式的目标都是给被压服务带来足够的吞吐量压力。&lt;/span&gt;&lt;span&gt;RPS模式底层也依赖并发（Virtual User）。&lt;/span&gt;&lt;span&gt;通常压测引擎通过多线程、协程模拟多个客户端同时请求，保障单位时间内的吞吐量稳定，通过梯度、手动调速调节目标流量压力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来讲讲VU和RPS的简单换算公式。其中RPS表现跟接口耗时直接相关。假设接口耗时为100ms，1个VU平均一秒能够请求10次，那么在发压机、后台服务资源充裕的前提，VU和RPS是线性递增关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49145299145299143&quot; data-type=&quot;png&quot; data-w=&quot;1404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF48oNN4WLdVonkPh8Y7wUUWvib6icLErQRp4gM9AP3CWQyCx8ibAYLeIAxQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;处在线性增长区时，响应时间（RT）基本稳定，吞吐量（RPS）随着并发用户数（VU）的增加而增加。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;三者关系符合Little定律：VU=RPS*RT。&lt;/span&gt;&lt;span&gt;随着VU增大、系统的资源利用率饱和，系统到达拐点。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;若继续增大VU，响应时间开始增大，RPS开始下降。继续增加VU，系统超负荷、进入过饱和区，此时响应时间急剧增大、RPS急剧下降。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大部分后台服务压测适用于RPS模式。该服务或功能模块一般用于满足多少吞吐量的要求，因此主要观测后台服务的处理请求速率。支持用户自定义在报表页面进行手动调速，例如用户预期是1W RPS，可自定义初始1000RPS，按照一定的阶梯（1～2的系数递增）进行调速，这样通过观测服务本身的业务指标（吞吐量、时延、错误率）和饱和度（内存、CPU使用率）即可分析业务的瓶颈。针对秒杀、元旦、春节零点等活动，需要模拟多个用户的同时并发场景的话，则可以采用并发模式，例如支持10w人同时的活动抢购。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测的并发调度下几种常见场景：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在接口耗时比较低的情况下，会出现80并发和250并发的吞吐量一致的情况，原因是发压机调度的机器规格一致并且CPU负载饱和。从下方的压测指标图可以看出，&lt;span&gt;并发数逐渐增大。当并发达到80、达到吞吐量最大值，&lt;/span&gt;后续随着并发增大，响应耗时急剧增加，而吞吐量却没有明显变化。这其实意味当前这台发压机已经达到极限，cpu、内存资源水位位于高处。随着并发数增大，该机器没有更多的处理资源，因此协程频繁上下文切换带来发压机的请求耗时的增加。压测报告的latency耗时表现失真，而服务端的耗时表现正常。当发压机的资源达到瓶颈时或者CPU使用率超过 80%，指标采集线程、协程会出现频繁CPU时钟中断，导致指标埋点采集延迟。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测报告表现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2830396475770925&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4gKnUhMQ8ibbsmsWztsAs8Y9Z9riclWG6vWnmLTzDtNVOr2g7uJu0icTDA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发压机负载表现：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3929032258064516&quot; data-type=&quot;png&quot; data-w=&quot;3100&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4ibXbHy5RKcxJFCAbaAEF7FHUjdArut0e9F4vcvbyK4VaZmIIosPlqDw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景二：压测机&amp;amp;被压服务资源充裕，RPS达不到预期目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;压测过程中，并发数配置比较充裕，发压机负载稳定，后台服务也没达到探测瓶颈，但是RPS一直上不去。值得注意的是，RPS并不等价TPS。作为发压侧，引擎能够保证每秒发出去的请求数，TPS可以理解为收到回包的时间点数据，随着不同接口的耗时变化，吞吐量抖动会比较明显，表现出来为用户设置的RPS和实际TPS有差异。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6267379679144385&quot; data-type=&quot;png&quot; data-w=&quot;935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4M379TXpAQXSsvLIwjSEibib5ibHcvDXRlS61AjTxl7rXV1ADhsRGSFy4A/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此TPS会随着耗时的变化而频繁抖动。以http协议为例，客户端完整的耗时路径包括DNS寻址-&amp;gt;建立连接-&amp;gt;请求包网络传输时间-&amp;gt;服务端处理耗时-&amp;gt;响应包网络传输耗时，因此吞吐量表现会比APM监控的耗时要长，针对高性能组件压测场景，网络往返耗时波动占整体耗时比例会更高，导致不同地域下的吞吐量表现可能相差一倍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18350848827809216&quot; data-type=&quot;png&quot; data-w=&quot;2474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4rpic7z2A82kibsM8vNKnGXeWL89ZAqc0PPMkZFbAtfKp5wQgLztWqLFg/640?wx_fmt=png&quot;/&gt; &lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2 压测用例编写&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;云压测主要面向专项测试人员（对外TOB交付压测报告）、后台研发人员（保障后台服务质量），技术运营开发者（产品上线吞吐量验收），这部分开发者的代码编写水平参差，无法通过一套方案来满足用户诉求。&lt;/span&gt;&lt;strong&gt;因此云压测提供了多种用例编写方式(低代码、JS、GO、xml)，以满足不同用户、不同场景下的适配需求。下面将分别阐述3个模式。&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.2.1 模式一：JS脚本模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JS脚本模式提供串联接口的编排模式，平台通过封装公司内的常用协议提供对应的脚本模板，业务可以基于该模板进行请求参数 DIY降低接入成本。JS是高级语言、相关开源社区活跃，语言本身解释能力比较强，针对后台单接口、通用协议具备一定的通用性，也是业内主流开源引k6主打的业务场景。其缺点也比较明显，开源协作的社区氛围下，大部分后台研发人员对JS语法和基础框架并不是特别熟悉，无法吸引更多的研发人员持续迭代。大量的私有协议适配、基础库封装&lt;/span&gt;&lt;span&gt;&lt;span&gt;会带来大量的适配工作量（goja的脚本映射），依赖平台方、需求方持续迭代，而这些私有场景的适配工作并不能直接复用提高 ROI，无法快速支持业务特定需求。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// Send a http get request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; http &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pts/http&#x27;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 协议适配模块&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; { check, sleep } &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;pts&#x27;&lt;/span&gt;; &lt;span class=&quot;code-snippet__comment&quot;&gt;// 常规编排流程封装&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;/&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// simple get request&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; resp1 = http.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;http://httpbin.org/get&#x27;&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 执行发包操作&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(resp1.body); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 日志打印用于问题定位&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// if resp1.body is a json string, resp1.json() transfer json format body to a json object&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(resp1.json());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    check(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;status is 200&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; resp1.statusCode === &lt;span class=&quot;code-snippet__number&quot;&gt;200&lt;/span&gt;); &lt;span class=&quot;code-snippet__comment&quot;&gt;// 通过断言集成业务指标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.2.2 模式二：&lt;/span&gt;Go Plugin模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;它提供Go的脚本编写方案。该方案是Go官方支持的热加载机制，对第三方依赖具备较大的局限性（无法依赖不同版本，编译环境、执行环境需要统一，存在cgo依赖），因此业界并没有大规模使用。但是云压测场景下，可以满足用户go用例编写诉求，以及通过依赖倒置注入规避第三方版本问题，现有用户场景下使用也表现成熟。复杂编排、私有协议的支持给予了用户一定的空间，引擎本身只需要保证指标埋点、并发调度符合用户设置就能满足诉求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于历史包袱，protobuf协议很多单文件上千行，接口的参数构造复杂，存在公共协议之间的嵌套。用JS或python动态语言脚本编写用例，需要通过上传所有协议文件，用json来转换protobuf二进制数据，管理目录嵌套层级。这给用户带来很大的心理负担，同时也丧失stub代码的优势，减少数据频繁转换、构造参数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// Init 从用户脚本注入底层实现，包括加载 metrics 上报插件&amp;amp;注入 otel 实现框架。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; Init = plugin.Init&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;// Run 核心脚本编写逻辑，引擎会按照压测模型执行该 Run 函数。&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Run&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 必须通过 NewRequestWithContext 传入 ctx 构造请求，否则无法展示 har 格式的采样数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    req, err := http.NewRequestWithContext(ctx, http.MethodGet, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;https://httpbin.org/get&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    resp, err := http.DefaultClient.Do(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; resp.Body.Close()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;// 自定义断言，自动上报业务指标&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    assert.True(ctx, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;status code is 200&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; resp.StatusCode == http.StatusOK&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Go Plugin复杂场景下的优势：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持插桩代码引用，无需额外上传协议文件，减少频繁数据序列化操作带来的性能损耗；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对后台开发者友好，基于go进行用例编写，可以更灵活地复杂场景编排，支持现有存量协议封装、工具库集成，提高代码复用效率；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;平台集成 HTTP、gRPC等协议指标采集，用户聚焦在用例编排，请求流量构造等场景，减少用户心智负担。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;2.2.3 模式三：&lt;/span&gt;低代码、JMeter(GUI)的编写模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;云压测面向专项测试人员、非开发出身的从业者提供了UI拖拽的方案。基于har to js的模板映射框架，用户可自定义在简单模式、脚本模式进行切换，目前支持har-&amp;gt;js的单向转换。针对http等通用标准协议，提供 request、header、config参数构造选项，降低用户的心智负担和使用云压测的门槛。而存量用例也是重要考量因素，JMeter在性能测试领域的市场占用率比较高，大部分的商业化测试软件也会支持jmx脚本压测，业务的存量测试资产转移到全新平台有脚本适配改造成本，整体的投入产出比不高。因此云压测也基于JMeter插件机制进行扩展，新增指标埋点、日志采样、线程组调度的能力，能够在一套调度平台（box、ship机制）执行不同的发压引擎，降低整体适配的复杂度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3448047650562541&quot; data-type=&quot;png&quot; data-w=&quot;3022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4MF17mViaysVMDqX9BMiarMNZXevrbfONVpXg8BvIB6ib61uicGnNRGkyxg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.3 测试数据构造&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;测试数据构造是用例编写的核心环节。常规包括测试账号管理、鉴权，脚本的配置化参数（例如视频流压测包括是否开启视频转码、白名单、长短连接等），接口参数构造（直接跟业务逻辑强相关），固定化的数据会导致压测失真。因此云压测提供了线上流量录制转用例的能力，线上录制二进制包基于协议进行协议转换为云压测支持的流量存档格式，在123容器上的实施自动化程度较高。同时也支持CSV文件上传，支持脚本按照列名读取，多个CSV文件会进行merge，默认采用行数较多的作为基准文件，从头到尾轮询读取数据处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5706713780918727&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF432mFo48hqf3MxTwAhkEK5rggForWI0lqcD1nQZichxyJ2FH3QZ6u8fw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在大容量、高并发场景下，如何保证整体的压测集群发送的流量是均匀且分散的呢？云压测提供了按照发压机进行切片的配置选项，默认会按照任务配置的pod数量进行文件分割，这样保证分配到每个发压机的测试数据不重复，引擎按照轮询机制读取数据，尽量保证不进行数据深拷贝，避免内存full gc导致抖动。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4 压测报表分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;压测报表分析是整个压测流程最具有价值的一环。为了让用户更加聚焦报表，云压测针对不同引擎、脚本提供了一致性的观测体验。基于opentelemetry标准来实现整体压测报表的数据透视，包括metrics、trace、log。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7576396206533192&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95XxFJUcbQmIxyv3fZwtJvRP5tCDm2JqRn5BeHo0BTgGBTsv105nuE3AFCWN4sFOIEszkA6rESOEg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先通过metrics来判断客户端（压测报表）、服务端（APM监控框架）的接口成功率、时延、服务的饱和度是否符合预期，最佳方案是针对特殊的自定义状态码支持业务单独断言。定位到异常的metrics数据，根据错误码筛选请求日志查看完整日志，云压测基于http har进行gRPC等私有协议字段存档格式兼容，保证所有引擎的日志观测体验一致。针对异常的日志请求数据，自定义traceID埋点进行流量染色，结合服务端本身的trace监控能力进行链路耗时排查。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3372591006423983&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4x0H0oUakACkISCkdEJNbC76h313euQesuptMgYvGzb9j7YjnYUk8xA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;采样策略符合以下的特性：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;合理选用gauge、coun&lt;/span&gt;&lt;span&gt;ter、histogram(分bucket) 优化指标聚合效率；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;log配合trace设置采样，保证脚本执行日志链路完整；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;trace&amp;amp;log默认设置合理采样比例，减少日志上报带来性能损耗。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5504761904761905&quot; data-type=&quot;png&quot; data-w=&quot;3150&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4PGSGUeGBQtQQx27n4W8RXxRVHAf0eteq90cGJyTGPDZBL0v537w6Xg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;业务自定义检查点，用于业务字段（例如业务特有bizCode等）断言：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3769589157136806&quot; data-type=&quot;png&quot; data-w=&quot;2361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4NKWjtaRV24nwMPuIaoAXicS5dzFKz3praickg64ujcdnf1H6lGqDIn3w/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于har存档日志进行请求日志采样，优先进行异常请求采样、按照请求比例（默认千千分之一）。按照trace链路进行采样，保证请求上下文完整性，用户可自定义脚本中的traceid（支持Trace Context）配合业务的APM进行异常链路耗时定位。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5568039950062422&quot; data-type=&quot;png&quot; data-w=&quot;801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4APZjkibELYN84387aAeEYkriaQjdRVfJTIKzuT0piajtfbribic4ico5LxhA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;用户日志、引擎日志打印输出，方便脚本调试、引擎问题排查定位。该日志采样策略有一定的频率限制，避免消耗过多的cpu资源，同时可以减少日志存储成本。从压测过程具备完整metrics、trace、log可观测性链路数据，针对一些bad case也有完整的排查路径。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4871685201026518&quot; data-type=&quot;png&quot; data-w=&quot;2338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4CCmOy6MEuiaU4rVD0WFVpAQ3BBjIiacwcAsXd1YDtWTyJMIXq546WiaQw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;03&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;实践案例&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.1 &lt;span&gt;手Q春保活动&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1.1 背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;目前手Q业务每年元旦和春节的0点0分，都会有一波非常高的尖峰。读链路和写链路分不同命令字会数倍地流量飙升。业务架构保障高可用，大部分都是多地部署的，针对只读链路可以通过集群流量调度做到读链路的压测。但是写链路的压测（主要包含 feed 发表、评论、点赞等交互）较缺乏，测试数据构造复杂，用例编写成本高。&lt;/span&gt;&lt;span&gt;云压测之前主要采用JS脚本进行场景编排，图文场景出现了内存占用高，二进制频繁进行数据深拷贝，给压测机内存资源准备带来不少的压力。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1.2 实施方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来讲实施方案。2023年的春保采用Go Plugin进行用例重构，复用了现有的数据编解码组件能力，极大降低了适配成本，并且由于是原生go的协程调度执行，减少了大字符、字节码变量转换带来的性能损耗，同时也避免内存 gc 带来的流量抖动。支持复用存量的协议封装、鉴权接口，无需单独维护JS引擎的转换成本。相同分片上传的接口场景下，采用Go Plugin脚本相比JS脚本的 1000 并发吞吐量提升了90%的性能表现，有效的降低业务的硬件资源使用成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95XxFJUcbQmIxyv3fZwtJvRDkL3I9FNbibyC1ibnNcDIqicmbyRIezTRHDlD88BOClmTNNMaa1T8rWhQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;3.1.3 &lt;/span&gt;业务落地效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在6-8倍的日常流量保障目标下，探测上下游的服务过载情况，提前进行扩容尽早干预；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对链路超时的现象，合理设置重试策略、超时时间，验证柔性策略是否生效，避免瞬时压力造成雪崩效应；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;支持上海、南京、广州等多个地域集群压测，最高达到10w并发数，目标RPS达到100w的吞吐量规模，支持100G级别带宽流量验证。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 视频业务容灾演习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.2.1 背景&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;演习和压测是首页链路各个服务重构后的一次整体摸底，也是2023年春节保障的提前演习。这里主要做3件事：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;容灾演习&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了验证首页接口在各种异常情况下的容灾容错能力，梳理容灾容错短板；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;压测&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了排查首页链路中的各个关键服务性能是否存在问题，找到链路性能瓶颈，明确链路服务扩容模型；&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;接入层兜底能力摸底，当首页接口故障情况下，兜底能力能否达到预期的目标&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.2.2 实施方案&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据演习计划，关注告警信息、容器负载、主被调、失败率、平均耗时等指标。从接入层通过透传流量标识进行压测流量打标，上下游链路涉及RPC调用，缓存中间件、数据库中间件、消息中间件等，整体框架需要接入统一治理服务，保障数据隔离、服务隔离。压测过程中，云压测集成了被压测服务的SLA监控，根据服务的重要程度进行等级划分，并且通过告警收敛自动进行流量降级、熔断，特性环境压测有效的减少规避事故的爆炸范围。长时间的持续高负载也会带来服务的潜在的雪崩效应，如何兼顾压测流量的饱和度和业务流量安全，是需要持续进行策略迭代优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35546875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;4096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95XxFJUcbQmIxyv3fZwtJvRh68Ycib4oiaTNz0cDpAubBN9VBL1tEpokbnqQibvpjujMKFPftFA7adhA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务容灾验证路径概述如下：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;混沌工程注入，验证接口的健壮性；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;兜底缓存策略的触发机制；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证服务降级、熔断策略的机制；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证服务的过载保护能力，具备柔性可用；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;校验业务安全管控策略、高可用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;3.2.2 业务落地成果&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证业务的弹性伸缩能力，对降级、熔断、柔性服务进行可用性验证；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 PTS 提供的 RPS 扩散模型，了解上下游服务的机器规格配比，为容量预估、机器扩容、缩容做好评估依据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;h1 data-mid=&quot;&quot;&gt;&lt;span&gt;04&lt;/span&gt;&lt;/h1&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结展望&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;云压测主要聚焦在压测平台的发压端基础能力构建，实时展示了客户端的性能指标趋势，包括并发数、RPS、latency、错误率，适配大部分HTTP、gRPC、websocket等协议，针对私有协议、信息流、视频流有go plugin的自定义埋点解决方案。目前对服务端的监控数据整合相对欠缺，用户需要频繁切换多个监控平台来观测服务的负载，针对各业务常用 APM 集成方案在规划迭代中。平台后续会围绕着性能测试自动化、智能化的目标会持续迭代。尽量减少用户手动操作的成本，通过相对自动化的解决方案来去定吞吐量、检测系统性能瓶颈，并且基于SLA标准进行流量降级、熔断能够有效的保障压测安全。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6005221932114883&quot; data-type=&quot;png&quot; data-w=&quot;1532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97jweQNJvlwiaMVuYIoE7uF4Cib4tJIFR7PvYw0OtONib1muQicPibbISrc10Iur3CH0BnPiaF05rAUvPqQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上是云压测百万级 QPS 压测解决方案和在它手Q、在线视频业务实践的全部内容，欢迎各位读者在评论区分享交流。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;-End-&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原创作者｜张泽强&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术责编｜张泽强、刘楚蓉&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你可能感兴趣的腾讯工程师作品&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;| &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247573682&amp;amp;idx=1&amp;amp;sn=40e51875d43f95967250e7e3d84a60c0&amp;amp;chksm=eaa9bae2ddde33f406ddd51a81266a8f5716853768ab228c711732602f7dd2c42da8523ff4f9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;腾讯云开发者2022年度热文盘点&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;腾讯云开发者2022年度热文盘点&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;| &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247573425&amp;amp;idx=1&amp;amp;sn=62c23667c0a69eaa75e41c36c12ca8e8&amp;amp;chksm=eaa9c5e1ddde4cf7aa0a18f5dc2461e0e1e1771fb58eb400ce63fa37ec601887038160e05eb2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;企业微信零耦合集成腾讯会议和腾讯文档插件化架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;企业微信零耦合集成腾讯会议和腾讯文档插件化架构实践&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247572437&amp;amp;idx=1&amp;amp;sn=36f22bacd82ae022d95f1236ead48001&amp;amp;chksm=eaa9c185ddde4893b68e2bbb6d35bde13cc7eaac9053562068213936a187cbef0b82bcd7451f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;7天DAU超亿级，《羊了个羊》技术架构升级实战&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;7天DAU超亿级，《羊了个羊》技术架构升级实战&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;| &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247570676&amp;amp;idx=1&amp;amp;sn=dbdef6eff7fee16efa6373f5caebfd36&amp;amp;chksm=eaa9cea4ddde47b25e60e32b5faeb0662481dd49a32f1a5f3fe8650da9264a54842a4e356318&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;国民级应用：微信是如何防止崩溃的？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;国民级应用：微信是如何防止崩溃的？&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;技术盲盒：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568617&amp;amp;idx=1&amp;amp;sn=d3409583764c4877964765a6b774b1de&amp;amp;chksm=eaa9d6b9ddde5faff511c416033948f76b056b209df76c6eb12adfea3f618422297b9b11895b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;前端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;前端&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;｜&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568512&amp;amp;idx=1&amp;amp;sn=5a2e887c0ac511e9a4fe5cd68a388e48&amp;amp;chksm=eaa9d6d0ddde5fc6376f1ffcc6e7b050fefded23d5b24c5f7b801885f509df06cd53d99f0a45&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;后端&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;后端&lt;/a&gt;&lt;span&gt;｜&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568656&amp;amp;idx=1&amp;amp;sn=98f7033418fc1fd7d019eeb18008b616&amp;amp;chksm=eaa9d740ddde5e56aa0b7df55dc2f70c65f329d37246453c2b3316356f3f84cc9f87eb6b8db4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;AI与算法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;AI与算法&lt;/a&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568672&amp;amp;idx=1&amp;amp;sn=85e4b3e1c46289058398b216edb40941&amp;amp;chksm=eaa9d770ddde5e669cfaa25c37887ae058c433e4296ca04f8ff5373184bc76d4420f1d2049a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;运维｜&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;运维&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247568677&amp;amp;idx=1&amp;amp;sn=e95255553777c53d38cb1e64c1c16432&amp;amp;chksm=eaa9d775ddde5e633a75d20eb484181c0e03cb6f8237a4141c599e4f13ad3af6748c5e8d1a9a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;工程师文化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;工程师文化&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe97ibOIthe2pvwt1H0HqX0HVJVFK9WPNQKNsibXynR5yT5S7b45uIpzN7xeZdeJIfOibPjOflZ35rKZyw/0?wx_fmt=png&quot; data-nickname=&quot;腾讯云开发者&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;2&quot; data-index=&quot;0&quot; data-origin_num=&quot;666&quot; data-isban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;🔹关注我并点亮星标🔹&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作日晚8点 看腾讯技术、学专家经验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94245&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94245&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;点赞|分享|在看 传递好技术&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3428571428571427&quot; data-w=&quot;35&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94zy8bmYPnbKTD0kTDBhW3GbAVfG1HMK2YU7rbobopxLeEulM2GREMf3LnMlkYw2yjuwop3WNcHlg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2822fc5dafcdcb34e6b2110aa27c52e5</guid>
<title>MySQL 这些底层执行原理，早已成必备了</title>
<link>https://toutiao.io/k/0flc51l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;你好，我是田哥&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Server层&lt;/code&gt;：包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;存储引擎层&lt;/code&gt;：是一个可插拔的设计，也就是我们可以随意选择具体的存储引擎。server端通过API与存储引擎进行通信，这些接口屏蔽了不同存储引擎的差异。支持 InnoDB、MyISAM、Memory 等多个存储引擎。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，借助一张《MySQL实战45讲》的图，来解释整个执行流程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhhib6a66icqHUI6FU12RmicsXbIpvKu10jiaYiaicejSyve2DllSdCBkTUY5iag/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;连接器&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端&lt;strong&gt;建立连接&lt;/strong&gt;、&lt;strong&gt;获取权限&lt;/strong&gt;、&lt;strong&gt;维持和管理连接&lt;/strong&gt;。连接命令一般是这么写的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql -h$ip -P$port -u$user -p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 TCP/IP ，命名管道和共享内存 ，Unix域套接字文件 等方式进行连接的建立。当连接到服务器时，服务器会对密码，用户名，进行验证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户名或密码不对，你就会收到一个 “Access denied for user” 的错误，然后客户端程序结束执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查询缓存&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被&lt;code&gt;直接返回给客户端&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好在 MySQL 也提供了这种“按需使用”的方式。你可以将参数 query_cache_type 设置成 OFF，关闭查询缓存。也可以用 SQL_CACHE 显式指定，像下面这个语句一样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt;&lt;span&gt;SQL_CACHE&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;；&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 8.0 版本直接将查询缓存的整块功能删掉了，也就是说 8.0 开始彻底没有这个功能了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析器&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析器先会做“&lt;code&gt;词法分析&lt;/code&gt;”。你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 从你输入的 “select” 这个关键字识别出来，这是一个查询语句。它也要把字符串 “T” 识别成 “表名T”，把字符串 “ID” 识别成 “列ID”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做完了这些识别以后，就要做“&lt;code&gt;语法分析&lt;/code&gt;”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足 MySQL 语法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的语句不对，就会收到 “You have an error in your SQL syntax” 的错误提醒，比如下面这个语句 select 少打了开头的字母 “s”。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; elect * from t where ID=1;&lt;br/&gt;ERROR 1064 (42000): You have an error in your SQL syntax; &lt;br/&gt;&lt;span&gt;check&lt;/span&gt; the &lt;span&gt;manual&lt;/span&gt; that corresponds &lt;span&gt;to&lt;/span&gt; your MySQL &lt;span&gt;server&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; the &lt;span&gt;right&lt;/span&gt;&lt;br/&gt;syntax &lt;span&gt;to&lt;/span&gt;&lt;span&gt;use&lt;/span&gt; near&lt;span&gt;&#x27;elect * from t where ID=1&#x27;&lt;/span&gt;&lt;span&gt;at&lt;/span&gt; line &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧挨着 “use near” 的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;优化器&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化器是在表里面有多个索引的时候，&lt;code&gt;决定使用哪个索引&lt;/code&gt;；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的 join：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;join&lt;/span&gt; t2 &lt;span&gt;using&lt;/span&gt;(&lt;span&gt;ID&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; t1.c=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;and&lt;/span&gt; t2.d=&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、既可以先从表 t1 里面取出 c=10 的记录的 ID 值，再根据 ID 值关联到表 t2，再判断 t2 里面 d 的值是否等于 20。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、也可以先从表 t2 里面取出 c=20 的记录的 ID 值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于 10。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;执行器&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始执行的时候，要先判断一下你对这个表 T &lt;code&gt;有没有执行查询的权限&lt;/code&gt;，如果没有，就会返回没有权限的错误，如下所示。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt;&lt;span&gt;ID&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;ERROR 1142 (42000): &lt;span&gt;SELECT&lt;/span&gt; command denied &lt;span&gt;to&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&#x27;b&#x27;&lt;/span&gt;@&lt;span&gt;&#x27;localhost&#x27;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&#x27;T&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有权限，就打开表继续执行。打开表的时候，优化器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们这个例子中的表 T 中，ID 字段&lt;code&gt;没有索引&lt;/code&gt;，那么执行器的&lt;code&gt;执行流程&lt;/code&gt;是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、调用 InnoDB 引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有&lt;code&gt;索引的执行逻&lt;/code&gt;辑也差不多，第一次调用“&lt;code&gt;取满足条件的第一行&lt;/code&gt;”这个接口 ，然后循环取“&lt;code&gt;满足条件的下一行&lt;/code&gt;”这个接口 。这些接口存储引擎已经定义好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢查询日志有个rows_examined的字段表示语句执行过程扫描了多少行，就是执行器每次调用引擎获取数据时累加的，但有时候，执行器调用一次，引擎扫描了多行，所以这个数和行数并不是完全关联的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;存储引擎&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql的存储引擎是一个可插拔的设计，server层通过设定的一些api和存储引擎交互，存储引擎去实现这些api。常见的存储引擎有InnoDB，myISAM,memory。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;64TB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行级锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多版本并发控制机制（MVCC）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持聚簇索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持数据缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持外键&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB数据库文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tb_name.frm：表格式定义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tb_name.ibd ：数据文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;myISAM&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不支持事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最小粒度锁：表级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读写相互阻塞，写入不能读，读时不能写&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持MVCC（支持多版本并发控制机制）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持聚簇索引&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持数据缓存，只支持索引缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持外键&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;崩溃恢复性较差&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;最大支持256TB存储空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读取数据较快，占用资源较少&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接记录了select count（0）的值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MyISAM引擎存储文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;tbl_name.frm: 表格式定义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tbl_name.MYD: 数据文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tbl_name.MYI: 索引文件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用场景：MySQL5.5.5前默认的数据库引擎，在只读（或者写较少）、表较小（可以接受长时间进行修复操作）的场景适用&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;memory&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Memroy表在很多场景可以发挥好的作用:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用于查找(lookup) 或者映射(mapping) 表，例如将邮编和州名映射的表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于缓存周期性聚合数据( periodically aggregated data)的结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于保存数据分析中产生的中间数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;为什么myISAM比InnoDB快？&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.myISAM只缓存了索引块，减少了缓存换入换出的频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.myISAM的表结构非聚簇索引，而InnoDB是聚簇索引，InnoDB的二级索引需要找到id回表查一级索引，而myISAM所有的索引直接指向数据行的存储位置offset。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8706766917293233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhYB2tt4Gibs4mVnLc8BRqF4QGxszXDJzZaSb0Zg3iaGZTR937mB6k6Aow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.INNODB还需要维护MVCC一致；虽然你的场景没有，但他还是需要去检查和维护，而myisam 表锁.牺牲了写性能,提高了读性能.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一条sql语句在innodb底层的执行细节，如图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6788710907704043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhh6BzTN9bhm0ehh56ica4JDtOJPQcQaiaa82iaO2rCxGbs9TaoO9ZJwibNcw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1311&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用例：将id=1 更新为 id=2&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、更新数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1-1、将id=1的信息写入回滚段 undo log 中；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1-2、undo log在系统表空间或在undo log 表空间，它本身的数据页也在缓冲池中，此时undo log的物理页数据变化也需要写 redo log ，但这不是主流程；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1-3、将缓冲池中 id=1改为 id=2；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、将数据页的变化写 redo log 中，redo log根据配置 写：批量顺序写/主动写/被动写 磁盘&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、将数据变化SQL写binlog 日志，写入备库成功通过配置决定，写入：收到数据成功/relay log成功/执行成功；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、提交事务；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是数据更新的粗略步骤。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行计划&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们首先执行一条sql：explain select * from user where id =2;，执行后可以看到执行的结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17422680412371133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhh8O6NYylmicClZmDEbVdiar73vWjKsUia1kpFh8QCLuhqmNIEFzSicdcTLQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhOIaNDgxmCU0H3XB95NHrR0UPm36y5hQpxfFa0oVWgjvuXWNZSXc6rw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;id字段&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;id表示执行select查询语句的序号，它是sql执行的顺序的标识，sql按照id从大到小执行，id相同的为一组，从上到下执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;type字段&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.6529411764705881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhhlb6NcxeauwJnzYdbGdPME8p55MxOeGiakBJ310ou2oyicRQhNCR1GJYw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「type字段表示的sql关联的类型或者说是访问的类型」&lt;/strong&gt;。从这个字段中我们可以确定这条sql查找数据库表的时候，查找记录的大概范围是怎么样的，直接就能体现sql的效率问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;type字段的类型也是有比较多，主要常见掌握的有以下几个：&lt;strong&gt;system、const 、eq_ref 、ref 、range 、index 、ALL。&lt;/strong&gt;它的性能体现是从高到低。&lt;strong&gt;system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL，&lt;/strong&gt;下面就来详细的说一说这属性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;system&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;system是const的特例，&lt;strong&gt;「表示表中只有一行记录」&lt;/strong&gt;，这个几乎不会出现，也作为了解。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;const&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;const表示通过索引一次就查找到了数据，一般const出现在&lt;strong&gt;「唯一索引或者主键索引中使用等值查询」&lt;/strong&gt;，因为表中只有一条数据匹配，所以查找的速度很快。如：&lt;strong&gt;explain select * from user where id =2;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12833675564681724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhsKKYsaR5MCeSF869bkou4pBEKZC6fc1j1kHZcj3e3nOsEW0uwJK6hw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;eq_ref&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「eq_ref表示使用唯一索引或者主键索引扫描作为表链接匹配条件，对于每一个索引键，表中只有一条记录与之匹配」&lt;/strong&gt;。例如：&lt;strong&gt;explain select * from user left join role_user on user.id = role_user.user_id left join role on role_user.role_id=role.id;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09239766081871345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhB7l5ialrsmiaTbskiaIJdy8MbSdloH3hkGIQpkR4D5fJSNbBPT0mZDv5g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ref&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref性能比eq_ref差，&lt;strong&gt;「也表示表的链接匹配条件，也就是使用哪些表字段作为查询索引列上的值」&lt;/strong&gt;。ref与eq_ref的区别就是：&lt;strong&gt;eq_ref使用的是唯一索引或者主键索引。&lt;/strong&gt;&lt;strong&gt;ref扫描后的结果可能会找到多条符合条件的行数据，本质上是一种索引访问，返回匹配的行。&lt;/strong&gt;例如：&lt;strong&gt;explain select * from user where name = &#x27;张三&#x27;;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12857142857142856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhqtBib0ziaxicsp2DzhAGOJJdjvicqfG1Pudg9PtFFtKcQvgov3Oq9aLQXw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;980&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里type为ALL，说明name这个字段没有走索引，所以我们需要给name字段添加普通索引&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17226277372262774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhvicDgbW3TJmM97phxUcorgciaxyUknQpldKKibZzduhIHluPE7ZPKclYg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在次执行，可以发现name走了普通索引。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3336724313326551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhVgFFqPcSiaArllSGOPyeWpYs3icYuuwrPpOQEJnNibmnyOX0ew82vqxBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;983&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;range&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;range使用索引来检索给定范围的行数据，一般是在where后面使用between、&amp;lt;&amp;gt;、in等查询语句就会出现range」&lt;/strong&gt;例如：&lt;strong&gt;explain select * from user where id &amp;gt; 2;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13129318854886476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhhfv3DAVwsXRXY7vV4o4oVKJdm728M06PIYA5aUxzIJlJehBK5vbGlgw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1013&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;index&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「index表示会遍历索引树」&lt;/strong&gt;，index回避ALL速度快一些，但是出现index说明需要检查自己的索引是否使用正确。例如：&lt;strong&gt;explain select id from user;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12451737451737452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhh7gQ6Hx9up0eM6FP6th8RQu4PRYeElqYMEGBoeHt4iatYruWRib5MdN9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1036&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;ALL&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「ALL与index的区别就是ALL是从硬盘中读取，而index是从索引文件中读取」&lt;/strong&gt;，ALL全表扫描意味着Mysql会从表的头到尾进行扫描，这时候表示通常需要增加索引来进行优化了，或者说是查询中并没有使用索引作为条件进行查询 例如：&lt;strong&gt;explain select * from user ;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.13533834586466165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhh7zMaficjoypIHb8GqVMzLsIuGZIZ9h8zmbjicUaicMJ76AQfZxhnWzuwA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;931&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Extra字段&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该字段显示的是sql查询的额外信息，主要有以下几种情况：&lt;strong&gt;Using index、Using where、Using temporary、Using temporary、Using join buffer、Impossible where、Select tables optimized away&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhDMuq3ibes2nqLXY4kJgaCJJrORicZS6ylK3706aJnqNWmk1tZXyichHMA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;282&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using index&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示查询的列被&lt;code&gt;索引覆盖&lt;/code&gt;，这个是查询性能比较高的体现，即所要查询的信息搜在索引里面可以得到，不用回表，索引被正确的使用 例如：&lt;strong&gt;explain select id from user where id =2;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1237721021611002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhuotjAp3bE1q5cF8KrHEPnWuEqaJqTxPGbeukqnm4lGeYnsVMdniaiaOg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1018&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如同时出现了using where，表示索引用于执行索引键值的查找；若是没有出现using where，则表示索引用于读取数据，而非执行查询的动作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using index condition&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示只用到了&lt;code&gt;索引下推&lt;/code&gt;的条件。即在组合索引中涵盖的列中覆盖了搜索条件，那么会在筛选出来前先用条件过滤一遍，再去回表，减少回表次数。具体索引下推可以去查看innodb特性章节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using where&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该属性与Using index相反，查询的列并没有被索引覆盖，where条件后面使用的是非索引的前导列，它仅仅是使用了where条件而已。例如：&lt;strong&gt;explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15628604382929642&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhibctB9sZUmgVgKmSgm6HxnHPMU5qe4d7dx6y7EJm34Qyicrv3jZJMuNQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1734&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using temporary&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「Using temporary表示使用了临时表存储中间的结果，一般在对结果排序的时候会使用临时表&lt;/strong&gt;」。例如：排序order by 和分组查询group by。例：&lt;strong&gt;explain select * from (select name from user union select name from role) a where a.name = &#x27;张三&#x27; ;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16010498687664043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhSNuRxkzFiaeEA3W3a5mfhnLDrwXiaVCQxuw8XGLTichhvpDwGNSqWpyKw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1143&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using filesort&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Using filesort表示文件排序，说明Mysql对数据使用了外部的索引进行排序，并没有使用表中的索引进行排序。例如：&lt;strong&gt;explain select * from user order by name;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12562814070351758&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhhsy1a5CwO3dEdyc3t4gMza9YFnDYQYI82qCUzy25bM1m3r1NpPIoREQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;995&quot;/&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Using join buffer&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Using join buffer表示使用连接缓存。例如：&lt;strong&gt;explain select user.* from user,role,role_user where user.id = role_user.user_id and role.id=role_user.role_id ;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14466858789625361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhsokLWssRgMR7GqCr6Qvm9RWDKn1fVx0WbYAm5ict7vmNo60WFVzZH9g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1735&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它强调在获取连接条件时，并没有使用索引，而是使用连接缓冲区来存储中间结果，若是出现该值，一般说明需要添加索引来进行优化了。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Select tables optimized away&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表示select语句没有遍历表或者索引就返回数据了。例如：&lt;strong&gt;explain select min(id) from user ;&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11500449236298294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhhNwFMknhy7Zj23NbInqsqbzmveEs9mOkpicWnckYZ1E7mSKcUVUGqRA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1113&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Extra字段中还有其它的属性，但是几乎都没见过的，不出现，所以哪些就讲解，有兴趣的可以自己去了解，这里只列出这些常见的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关键字执行过程&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;select&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; age=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;Like&lt;/span&gt;&lt;span&gt;&#x27;小%&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这样一条语句查询，如果走的是age索引，我们的执行流程是这样的。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;存储引擎在二级索引定位age=12的&lt;code&gt;第一条记录&lt;/code&gt;，回表查询到记录完整的信息，返回给server层。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server层拿到记录后，进行判断该记录name是否满足like  &#x27;小%&#x27; 的条件，如果满足就&lt;code&gt;直接返回给客户端&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是不是和我们想象的不一样，以为server层会查到所有结果，统一返回给客户端的，实际上不是，下面&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再介绍&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;server再调用api接口，找存储引擎获取满足age=12的&lt;code&gt;下一条记录&lt;/code&gt;，并且在server层判断like  &#x27;小%&#x27; 的条件，将结果返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环往复，直到获取不到下一条记录。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，mysql的结果会写入到&lt;code&gt;net_buffer&lt;/code&gt;中，这块内存的大小是参数&lt;code&gt;net_buffer_length&lt;/code&gt;决定的，默认16k。重复获取行，直到写满net_buffer就发送，然后继续写。而客户端那边对数据的聚合，是靠mysql的连接驱动来组装结果的。也就是mysql是&lt;strong&gt;边写边发&lt;/strong&gt;的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;count&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;count(0),count(*),count(字段名)有啥区别？这个是我们大家关注的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;count(0)&lt;/code&gt;相当于是要统计全表的数据，优化器会选择一个非主键索引的&lt;strong&gt;最小二级索引。&lt;/strong&gt;为啥这样呢？因为主键索引里面有记录行，会导致一页中能存储的记录行更少。而二级索引页存储了所有行的信息，只需要遍历更少的额页就能统计出我们需要的全行数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;count(字段名)&lt;/code&gt;是统计表中，该字段不&lt;code&gt;为null&lt;/code&gt;的所有记录数的总和，逻辑上就不同了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;COUNT&lt;/span&gt;(*) &lt;span&gt;FROM&lt;/span&gt; t;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在执行上述查询时，server层会&lt;strong&gt;维护一个名叫count的变量&lt;/strong&gt;，然后：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;server层向InnoDB要第一条记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB找到idx_key1的第一条二级索引记录，并返回给server层（注意：由于此时只是统计 记录数量，所以并不需要回表）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于COUNT函数的参数是 * ，MySQL会将 * 当作常数0处理。由于0并不是NULL，server层 给count变量加1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server层向InnoDB要下一条记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB通过二级索引记录的next_record属性找到下一条二级索引记录，并返回给server层。server层继续给count变量加1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;... 重复上述过程，直到InnoDB向server层返回没记录可查的消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server层将最终的count变量的值发送到客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;limit&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt; key1 &lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这条语句的意思是，以key1正序的结果中，&lt;strong&gt;跳过&lt;/strong&gt;5000行，之后&lt;strong&gt;查询1行&lt;/strong&gt;返回给客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用idx_key1执行上述查询，那么MySQL会这样处理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;server层向InnoDB要第1条记录，InnoDB从idx_key1中获取到第一条二级索引记录，然后进 行回表操作得到完整的聚簇索引记录，然后返回给server层。server层准备将其发送给客户 端，此时发现还有个 LIMIT 5000, 1 的要求，意味着符合条件的记录中的第5001条才可以真 正发送给客户端，所以在这里先做个统计，我们假设server层&lt;code&gt;维护了一个&lt;/code&gt;称作limit_count的变 量用于统计已经跳过了多少条记录，此时就应该将&lt;code&gt;limit_count&lt;/code&gt;设置为1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;server层再向InnoDB要下一条记录，InnoDB再根据二级索引记录的next_record属性找到下 一条二级索引记录，再次进行回表得到完整的聚簇索引记录返回给server层。server层在将其 发送给客户端的时候发现limit_count才是1，所以就放弃发送到客户端的操作，&lt;code&gt;将limit_count 加1&lt;/code&gt;，此时limit_count变为了2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;... 重复上述操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;直到limit_count等于5000&lt;/code&gt;的时候，server层才会真正的将InnoDB返回的完整聚簇索引记录发 送给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述过程中我们可以看到，由于MySQL中是在&lt;code&gt;实际向客户端发送记录前才会去判断LIMIT子句&lt;/code&gt; 是否符合要求，所以如果使用二级索引执行上述查询的话，意味着要进行5001次回表操作。server层在进行执行计划分析的时候会觉得执行这么多次&lt;code&gt;回表的成本太大&lt;/code&gt;了，还不如直接&lt;code&gt;全表扫描 &lt;/code&gt;+filesort快呢，所以就选择了后者执行查询。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;深翻页解决办法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;limit语句的执行效率也太低了，如果提高呢？limit的局限在于需要跳过很多没用的行，如果翻页太深，比如limit 50000，1.需要跳过50000行，那也太坑了，如何避免？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以借助主键的游标cursor。如果是对一张表的跑批，要翻页多次跑出所有的数据。我们初始方案可能是&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第一页&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第二页&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第三页&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用了游标后,每次都取最新的100条，不需要有跳过的行，具体的数据靠保存上一页的自增id cursor来定位。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第一页&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第二页&lt;/span&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; * &lt;span&gt;FROM&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;LIMIT&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;;&lt;span&gt;--第三页&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用游标的方案，一定要记得对游标列排序&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;order by&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;,age,city &lt;span&gt;from&lt;/span&gt; staff &lt;span&gt;where&lt;/span&gt; city = &lt;span&gt;&#x27;深圳&#x27;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; age &lt;span&gt;limit&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一条sql语句，看一下执行计划，会发现 Extra 这个字段的 &lt;strong&gt;Using filesort&lt;/strong&gt;表示用到排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么他是怎么排序的呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;全字段排序&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 会给每个查询线程分配一块小&lt;strong&gt;内存&lt;/strong&gt;，用于&lt;strong&gt;排序&lt;/strong&gt;的，称为 &lt;strong&gt;sort_buffer&lt;/strong&gt;。什么时候把字段放进去排序呢，其实是通过idx_city索引找到对应的数据，才把数据放进去啦。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2916666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhh7JCGZ742UvzCamUuSMicofR3cbdJvAOVAkFQW6fmUh08MjPlEESicVCw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面执行语句，整体的执行流程就是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MySQL 为对应的线程初始化&lt;strong&gt;sort_buffer&lt;/strong&gt;，放入需要查询的name、age、city字段；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;索引树idx_city&lt;/strong&gt;， 找到第一个满足 city=&#x27;深圳’条件的主键 id，也就是图中的id=9；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;到&lt;strong&gt;主键 id 索引树&lt;/strong&gt;拿到id=9的这一行数据， 取name、age、city三个字段的值，存到sort_buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;索引树idx_city&lt;/strong&gt; 拿到下一个记录的主键 id，即图中的id=13；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复步骤 3、4 直到&lt;strong&gt;city的值不等于深圳&lt;/strong&gt;为止；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面5步已经查找到了所有&lt;strong&gt;city为深圳&lt;/strong&gt;的数据，在 sort_buffer中，将所有数据根据age进行排序；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;按照排序结果取前10行返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5824074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhuAeHDFUzEmvlNZRYt9MYzcKYmFNutVGgW27Ab91WUpvI2wdBf4l5Eg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据太多，内存放不下怎么办？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;磁盘临时文件辅助排序&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，sort_buffer的大小是由一个参数控制的：&lt;strong&gt;sort_buffer_size&lt;/strong&gt;。如果要排序的数据小于sort_buffer_size，排序在&lt;strong&gt;sort_buffer&lt;/strong&gt; 内存中完成，如果要排序的数据大于sort_buffer_size，则&lt;strong&gt;借助磁盘文件来进行排序。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用了磁盘临时文件，整个排序过程又是怎样的呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;主键Id索引树&lt;/strong&gt;，拿到需要的数据，并放到&lt;strong&gt;sort_buffer内存&lt;/strong&gt;块中。当sort_buffer快要满时，就对sort_buffer中的数据排序，排完后，把数据临时放到磁盘一个小文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续回到主键 id 索引树取数据，继续放到sort_buffer内存中，排序后，也把这些数据写入到磁盘临时小文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续循环，直到取出所有满足条件的数据。最后把磁盘的临时排好序的小文件，合并成一个有序的大文件。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TPS:&lt;/strong&gt; 借助磁盘临时小文件排序，实际上使用的是&lt;strong&gt;归并排序&lt;/strong&gt;算法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;rowid 排序&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rowid 排序就是，只把查询SQL&lt;strong&gt;需要用于排序的字段和主键id&lt;/strong&gt;，放到sort_buffer中。那怎么确定走的是全字段排序还是rowid 排序排序呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上有个参数控制的。这个参数就是&lt;strong&gt;max_length_for_sort_data&lt;/strong&gt;，它表示MySQL用于排序行数据的长度的一个参数，如果单行的长度超过这个值，MySQL 就认为单行太大，就换rowid 排序。我们可以通过命令看下这个参数取值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用rowid 排序的话，整个SQL执行流程又是怎样的呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;MySQL 为对应的线程初始化&lt;strong&gt;sort_buffer&lt;/strong&gt;，放入需要排序的age字段，以及主键id；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;索引树idx_city&lt;/strong&gt;， 找到第一个满足 city=&#x27;深圳’条件的主键 id，也就是图中的id=9；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;到&lt;strong&gt;主键 id 索引树&lt;/strong&gt;拿到id=9的这一行数据， 取age和主键id的值，存到sort_buffer；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从&lt;strong&gt;索引树idx_city&lt;/strong&gt; 拿到下一个记录的主键 id，即图中的id=13；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重复步骤 3、4 直到&lt;strong&gt;city的值不等于深圳&lt;/strong&gt;为止；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前面5步已经查找到了所有city为深圳的数据，在 &lt;strong&gt;sort_buffer&lt;/strong&gt;中，将所有数据根据age进行排序；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遍历排序结果，取前10行，并按照 id 的值&lt;strong&gt;回到原表&lt;/strong&gt;中，取出city、name 和 age 三个字段返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4787037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhsbiclgDKsbjkeQibNpkibnicN0gqlCrmhRrqBZ90VP3EUMSFTn00GbXoVw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对比一下&lt;strong&gt;全字段排序&lt;/strong&gt;的流程，rowid 排序多了一次&lt;strong&gt;回表&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;优化思路&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们如何优化order by语句呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;因为数据是无序的，所以就需要排序。如果数据本身是有序的，那就不用排了。而索引数据本身是有序的，我们通过建立&lt;strong&gt;联合索引&lt;/strong&gt;，优化order by 语句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们还可以通过调整&lt;strong&gt;max_length_for_sort_data&lt;/strong&gt;等参数优化；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们可以建立联合索引&lt;strong&gt;idx_city_age&lt;/strong&gt;，这样查询的数据就不需要用到内存排序了，在索引树上就是我们想要的顺序效果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33055555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7Zhhb3DKOgiaKIElyycibZBq9jKjTKm2PrY1G2ibE1Sib85vgibiacgJp6hD09lg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247490571&amp;amp;idx=1&amp;amp;sn=e8638573ec8d720fd25da5b2b0d90ed2&amp;amp;chksm=cf21c322f8564a34461acd9811730d14d12075cf5c7438a3a11433725b9ce463fcb78e7916a1&amp;amp;token=574771970&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;order by详解&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;group by&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;explain&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; city ,&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;as&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; staff &lt;span&gt;group&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; city;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一条group by语句&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Extra 这个字段的Using temporary表示在执行分组的时候使用了&lt;strong&gt;临时表&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Extra 这个字段的Using filesort表示使用了&lt;strong&gt;排序&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;group by 怎么就使用到临时表和排序了呢？我们来看下这个SQL的执行流程&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;简单执行流程&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;explain&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; city ,&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;as&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; staff &lt;span&gt;group&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; city;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一起来看下这个SQL的执行流程哈&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建内存临时表，表里有两个字段&lt;code&gt;city&lt;/code&gt;和&lt;code&gt;num&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全表扫描staff的记录，依次取出city = &#x27;X&#x27;的记录。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;判断&lt;strong&gt;临时表&lt;/strong&gt;中是否有为 city=&#x27;X&#x27;的行，没有就插入一个记录 (X,1);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果临时表中有city=&#x27;X&#x27;的行的行，就将x 这一行的num值加 1；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;遍历完成后，再根据字段city做&lt;strong&gt;排序&lt;/strong&gt;，得到结果集返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程的执行图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44083969465648853&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhdicTdoSXwXKQ69chKO6F9lfDEKico6HbTH0NxmozXtFibzNAE5je1QHCw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1048&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;group by会默认排序，如果不希望排序，可以显示指定不排序。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;explain&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; city ,&lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;as&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; staff &lt;span&gt;group&lt;/span&gt;&lt;span&gt;by&lt;/span&gt; city &lt;span&gt;order&lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28086164043082024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhdCSFx3licOaB0PEaqQRG6X7KudiaaCYJTkjDjTkQtuSx4MficiaWaggylg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1207&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;松散索引&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要利用到松散索引扫描实现 GROUP BY，需要至少满足以下几个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GROUP BY 条件字段必须在同一个索引中最前面的连续位置（前缀索引）;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在使用GROUP BY 的同时，只能使用 MAX 和 MIN 这两个聚合函数;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果引用到了该索引中 GROUP BY 条件之外的字段条件的时候，必须以常量形式存在;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么松散索引扫描的效率会很高?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在没有WHERE子句，也就是必须经过全索引扫描的时候， 松散索引扫描需要读取的键值数量与分组的组数量一样多，也就是说比实际存在的键值数目要少很多。而在WHERE子句包含范围判断式或者等值表达式的时候， &lt;strong&gt;松散索引扫描查找满足范围条件的每个组的第1个关键字&lt;/strong&gt;，并且再次读取尽可能最少数量的关键字。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;紧凑索引&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和松散索引扫描的区别是需要读取所有满足条件的索引值，之后取数据完成操作。Extra中不显示for group-by 在 MySQL 中，首先会选择尝试通过松散索引扫描来实现 GROUP BY 操作，当发现某些情况无法满足松散索引扫描实现 GROUP BY 的要求之后，才会尝试通过紧凑索引扫描来实现。（比如GROUP BY 条件字段并不连续或者不是索引前缀部分的时候）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;临时表&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当无法找到合适的索引可以利用的时候，就不得不先读取需要的数据，然后通过临时表来完成 GROUP BY 操作。Extra：Using temporary; Using filesort&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;join&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql的join算法叫做Nested-Loop Join（嵌套循环连接）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个Nested-Loop Join有三种变种，下面分别介绍下&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Simple Nested-Loop&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法相当简单、直接。即驱动表中的每一条记录与被驱动表中的记录进行比较判断（就是个笛卡尔积）。对于两表联接来说，驱动表只会被访问一遍，但被驱动表却要被访问到好多遍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设R为驱动表，S被驱动表，用伪代码表示一下这个过程就是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;for r in R                      &lt;span&gt;# 扫描R表（驱动表）&lt;/span&gt;&lt;br/&gt;    for s in S                   &lt;span&gt;# 扫描S表（被驱动表）&lt;/span&gt;&lt;br/&gt;        if (r and s satisfy the join condition)  &lt;span&gt;# 如果r和s满足join条件&lt;/span&gt;&lt;br/&gt;            output result    &lt;span&gt;# 返回结果集&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果R有1万条数据，S有1万条数据，那么数据比较的次数1万 * 1万 =1亿次，这种查询效率会非常慢。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Index Nested-Loop&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是基于索引进行连接的算法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它要求被驱动表上有索引，可以通过索引来加速查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设R为驱动表，S被驱动表，用伪代码表示一下这个过程就是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;For r in R                  &lt;span&gt;# 扫描R表&lt;/span&gt;&lt;br/&gt;    for s in Sindex                    &lt;span&gt;# 查询S表的索引（固定3~4次IO，B+树高度）&lt;/span&gt;&lt;br/&gt;        if (s == r)                   &lt;span&gt;# 如果r匹配了索引s&lt;/span&gt;&lt;br/&gt;            output result   &lt;span&gt;# 返回结果集&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Block Nested-Loop&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个算法较Simple Nested-Loop Join的改进就在于可以减少被驱动表的扫描次数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为它使用Join Buffer来减少内部循环读取表的次数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设R为驱动表，S被驱动表，用伪代码表示一下这个过程就是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;for r in R                             &lt;span&gt;# 扫描表R&lt;/span&gt;&lt;br/&gt;    store p from R in Join Buffer    &lt;span&gt;# 将部分或者全部R的记录保存到Join Buffer中，记为p&lt;/span&gt;&lt;br/&gt;    for s in S                        &lt;span&gt;# 扫描表S&lt;/span&gt;&lt;br/&gt;        if (p and s satisfy the join condition)        &lt;span&gt;# p与s满足join条件&lt;/span&gt;&lt;br/&gt;           output result                    &lt;span&gt;# 返回为结果集&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到相比Simple Nested-Loop Join算法，Block Nested-LoopJoin算法仅多了一个所谓的Join Buffer&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么这样就能减少被驱动表的扫描次数呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图相比更好地解释了Block Nested-Loop Join算法的运行过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bdCFacfMslgZxlU2TAs52oPdVYHD7ZhhL0XicA2vIYsRGyKia5Fia8X6USR6AQ9dcdL6gwcE6G8LkXQ0ytsDJMPLA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到Join Buffer用以缓存联接需要的列（所以再次提醒我们，最好不要把*作为查询列表，只需要把我们关心的列放到查询列表就好了，这样还可以在join buffer中放置更多的记录呢，是不是这个道理哈，哈哈）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后以Join Buffer批量的形式和被驱动表中的数据进行联接比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果被驱动表的数据超过了join buffer的size，那么就会把它分成多个join buffer文件块，每条驱动表数据都和多个块数据联表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于Join Buffer&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Join Buffer会缓存所有参与查询的列而不是只有Join的列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;join_buffer_size的默认值是256K&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在选择Join算法时，会有优先级：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Index Nested-LoopJoin &amp;gt; Block Nested-Loop Join &amp;gt; Simple Nested-Loop Join&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当不使用&lt;code&gt;Index Nested-Loop Join&lt;/code&gt;的时候，默认使用&lt;code&gt;Block Nested-Loop Join&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Block Nested-Loop Join算法需要开启优化器管理配置的optimizer_switch的设置block_nested_loop为on，默认为开启。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;Join优化&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的简单介绍，可以总结出以下几种优化思路&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.用小结果集驱动大结果集，减少外层循环的数据量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.如果小结果集和大结果集连接的列都是索引列，mysql在join时也会选择用小结果集驱动大结果集，因为索引查询的成本是比较固定的，这时候外层的循环越少，join的速度便越快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.为匹配的条件增加索引：争取使用&lt;code&gt;Index Nested-Loop Join&lt;/code&gt;，减少内层表的循环次数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.增大&lt;code&gt;join buffer size&lt;/code&gt;的大小：当使用Block Nested-Loop Join时，一次缓存的数据越多，那么外层表循环的次数就越少，减少不必要的字段查询：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5.当用到Block Nested-Loop Join时，字段越少，join buffer 所缓存的数据就越多，外层表的循环次数就越少；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天就分享这么多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他MySQL干货文章：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第1篇：MySQL系列：MySQL核心知识总结&lt;br/&gt;第2篇：MySQL系列：58到家数据库30条军规解读&lt;br/&gt;第3篇：MySQL系列：MySQL中一条查询SQL、更新SQL的执行流程&lt;br/&gt;第4篇：MySQL系列：常用命令汇总（附中文解释）&lt;br/&gt;第5篇：MySQL系列：索引详情&lt;br/&gt;第6篇：MySQL系列：细说MySQL的MVCC&lt;br/&gt;第7篇：MySQL系列：聊聊MySQL的主从&lt;br/&gt;第8篇：测试一下你的SQL是否达标&lt;br/&gt;第9篇：面试SQL会有哪些题型？&lt;br/&gt;第10篇：MySQL系列：查询慢的场景、原因和解决方案&lt;br/&gt;第11篇：几款好用的MySQL开源客户端&lt;br/&gt;第12篇：MySQL连接管理、解析与优化&lt;br/&gt;第13篇：面试官喜欢问的MYSQL问题&lt;br/&gt;第14篇：万字总结 MySQL核心知识，赠送25连环炮&lt;br/&gt;第15篇：手把手教你部署一套生产级的 MySQL 数据库&lt;br/&gt;第16篇：MySQL数据库开发中的6个“避免”&lt;br/&gt;第17篇：mysql主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？&lt;br/&gt;第18篇：mysql插入数据会失败？为什么？&lt;br/&gt;第19篇：InnoDB原理篇：聊聊数据页变成索引这件事&lt;br/&gt;第20篇：InnoDB原理篇：如何用好索引&lt;br/&gt;第21篇：InnoDB原理篇：为什么使用索引会变快?&lt;br/&gt;第22篇：浅谈 MySQL InnoDB 的内存组件&lt;br/&gt;第23篇：InnoDB 对 Buffer Pool 的奇思妙想&lt;br/&gt;第24篇：Mysql的索引为什么使用B+树而不使用跳表？&lt;br/&gt;第25篇：明明加了唯一索引，为什么还是产生重复数据？&lt;br/&gt;第26篇：你知道多少种索引？&lt;br/&gt;第27篇：MySQL事务面试题&lt;br/&gt;第28篇：MySQL事务特性及原理讲解&lt;br/&gt;第29篇：两个事务并发写，能保证数据唯一吗？&lt;br/&gt;第30篇：5 分钟带你掌握MySQL 主从&lt;br/&gt;第31篇：数据库主键一定要自增吗？有哪些场景不建议自增？&lt;br/&gt;第32篇：MySQL自增主键用完报什么错？有什么建议？&lt;br/&gt;第33篇：redo log与binlog间的破事&lt;br/&gt;第34篇：拉取 binlog，自动数据同步，老板要给涨工资....&lt;br/&gt;第35篇：不会吧，还有人不知道 binlog ？&lt;br/&gt;第36篇：聊聊redo log是什么？&lt;br/&gt;第37篇：一条SQL语句在MySQL中是如何执行的？&lt;br/&gt;第38篇：为什么mysql的count()方法这么慢？&lt;br/&gt;第39篇：手把手教 | 如何设计高性能数据库表&lt;br/&gt;第40篇：大表分页查询非常慢，怎么办？&lt;br/&gt;第41篇：Mysql数据库查询好慢，除了索引，还能因为什么？&lt;br/&gt;第42篇：MySQL查询优化实战篇&lt;br/&gt;第43篇：mysql查询 limit 1000,10 和limit 10 速度一样快吗？如果我要分页，我该怎么办？&lt;br/&gt;第44篇：分库分表会带来读扩散问题？怎么解决？&lt;br/&gt;第45篇：5分钟带你掌握MySQL 主从&lt;br/&gt;第46篇：37道MySQL面试题&lt;br/&gt;第47篇：SQL优化思路+经典案例分析&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;共47篇文章&lt;/strong&gt;：文章内容直接访问地址（文末点击 &lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;直接跳转网站）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;http://woaijava.cc/category/37&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU4MDM3MDgyMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/07BicZywOVtnnDxQn6rxvT1ILgqFqasglJJURLfRfpNK8ECsmicz5Ys3mib2WickSdOpmLtkq7Pb5icvia8nG1OoSiaQw/0?wx_fmt=png&quot; data-nickname=&quot;Java后端技术全栈&quot; data-alias=&quot;jjs-2018&quot; data-signature=&quot;专注技术指导、面试辅导和技术分享，关注回复77，即可获取自研《面试小抄》和面试相关资料！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;strong&gt;77&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即可获取《面试小抄》第二版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;电子书&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;即可获取《200本后端必读书籍》&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MDM3MDgyMA==&amp;amp;mid=2247514760&amp;amp;idx=2&amp;amp;sn=f0cc0549f4fc1466aff89da4f7c1d366&amp;amp;chksm=fd551263ca229b75afba4bb2e39b7aaea2b2525e328dbd6fb9613a9a7ebb9eb1d7f77147aa28&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在线刷java面试题网站&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;推荐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;：&lt;span&gt;在线刷java面试题网站&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a936958305d2ded1354d63b9fe0be6c</guid>
<title>7000 字扫盲数仓常见术语</title>
<link>https://toutiao.io/k/4p304nt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据仓库相关术语&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据仓库&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库是一个支持管理决策的数据集合。数据是面向主题的、集成的、不易丢失的并且是时变的。数据仓库是所有操作环境和外部数据源的快照集合。它并不需要非常精确，因为它必须在特定的时间基础上从操作环境中提取出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据集市&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库只限于单个主题的区域，例如顾客、部门、地点等。数据集市在从数据仓库获取数据时可以依赖于数据仓库，或者当它们从操作系统中获取数据时就不依赖于数据仓库。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事实&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实是数据仓库中的信息单元，也是多维空间中的一个单元，受分析单元的限制。事实存储于一张表中（当使用关系数据库时）或者是多维数据库中的一个单元。每个事实包括关于事实（销售额，销售量，成本，毛利，毛利率等）的基本信息，并且与维度相关。在某些情况下，当所有的必要信息都存储于维度中时，单纯的事实出现就是对于数据仓库足够的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度是用来反映业务的一类属性，这类属性的集合构成一个维度。例如，某个地理维度可能包括国家、地区、省以及城市的级别。一个时间维度可能包括年、季、月、周、日的级别。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;级别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度层次结构的一个元素。级别描述了数据的层次结构，从数据的最高（汇总程度最大）级别直到最低（最详细）级别（如大分类-中分类-小分类-细分类）。级别仅存在于维度内。级别基于维度表中的列或维度中的成员属性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据清洗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数据仓库系统无用的或者不符合数据格式规范的数据称之为脏数据。清洗的过程就是清除脏数据的过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据采集&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库系统中后端处理的一部分。数据采集过程是指从业务系统中收集与数据仓库各指标有关的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据转换&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释业务数据并修改其内容，使之符合数据仓库数据格式规范，并放入数据仓库的数据存储介质中。数据转换包括数据存储格式的转换以及数据表示符的转换（如产品代码到产品名称的转换）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;联机分析处理(OLAP OnlineAnalytical Processing )&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OLAP是一种多维分析技术，用来满足决策用户在大量的业务数据中，从多角度探索业务活动的规律性、市场的运作趋势的分析需求，并辅助他们进行战略发展决策的制定。按照数据的存储方式分OLAP又分为ROLAP、MOLAP和HOLAP。在客户信息数据仓库CCDW的数据环境下，OLAP提供上钻、下钻、切片、旋转等在线分析机制。完成的功能包括多角度实时查询、简单的数据分析，并辅之于各种图形展示分析结果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;切片&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种用来在数据仓库中将一个维度中的分析空间限制为数据子集的技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;切块&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一种用来在数据仓库中将多个维度中的分析空间限制为数据子集的技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;星型模式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是数据仓库应用程序的最佳设计模式。它的命名是因其在物理上表现为中心实体，典型内容包括指标数据、辐射数据，通常是有助于浏览和聚集指标数据的维度。星形图模型得到的结果常常是查询式数据结构，能够为快速响应用户的查询要求提供最优的数据结构。星形图还常常产生一种包含维度数据和指标数据的两层模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;雪花模式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指一种扩展的星形图。星形图通常生成一个两层结构，即只有维度和指标，雪花图生成了附加层。实际数据仓库系统建设过程中，通常只扩展三层：维度（维度实体）、指标（指标实体）和相关的描述数据（类目细节实体）；超过三层的雪花图模型在数据仓库系统中应该避免。因为它们开始像更倾向于支持OLTP 应用程序的规格化结构，而不是为数据仓库和OLAP应用程序而优化的非格式化结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;粒度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;粒度将直接决定所构建仓库系统能够提供决策支持的细节级别。粒度越高表示仓库中的数据较粗，反之，较细。粒度是与具体指标相关的，具体表现在描述此指标的某些可分层次维的维值上。例如，时间维度，时间可以分成年、季、月、周、日等。数据仓库模型中所存储的数据的粒度将对信息系统的多方面产生影响。事实表中以各种维度的什么层次作为最细粒度，将决定存储的数据能否满足信息分析的功能需求，而粒度的层次划分、以及聚合表中粒度的选择将直接影响查询的响应时间。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;度量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;度量是业务流程节点上的一个数值。比如&lt;code&gt;销量&lt;/code&gt;，&lt;code&gt;价格&lt;/code&gt;，&lt;code&gt;成本&lt;/code&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表中的度量可分为三类：&lt;code&gt;完全可加&lt;/code&gt;，&lt;code&gt;半可加&lt;/code&gt;，&lt;code&gt;不可加&lt;/code&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;完全可加的度量是最灵活，最有用的，比如说销量，销售额等，可进行任意维度汇总；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;半可加的度量可以对某些维度汇总，但不能对所有维度汇总，差额是常见的半可加度量，它除了时间维度外，可以跨所有维度进行加法操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还有一种是完全不可加的，例如：比率。对于这类非可加度量，一种好的方法是，尽可能存储非可加度量的完全可加分量，并在计算出最终的非可加事实前，将这些分量汇总到最终的结果集中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;度量值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多维数据集中，度量值是一组值，这些值基于多维数据集的事实数据表中的一列，而且通常为数字。此外，度量值是所分析的多维数据集的中心值。即，度量值是最终用户浏览多维数据集时重点查看的数字数据（如销售、毛利、成本）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;口径&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;口径就是取数逻辑（如何取数的），比如要取的数是10岁以下儿童中男孩的平均身高，这就是统计的口径。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指标&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指标是口径的衡量值，也就是最后的结果。比如最近七天的订单量，一个促销活动的购买转化率等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个指标具体到计算实施，主要有以下几部分组成：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;指标加工逻辑，比如count ,sum, avg&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;维度&lt;/span&gt;，比如按部门、地域进行指标统计，对应sql中的group by&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务限定/修饰词&lt;/span&gt;，比如以不同的支付渠道来算对应的指标，微信支付的订单退款率，支付宝支付的订单退款率 。对应sql中的where。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，指标本身还可以衍生、派生出更多的指标，基于这些特点，可以将指标进行分类：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;原子指标：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本业务事实，没有业务限定、没有维度。比如订单表中的订单量、订单总金额都算原子指标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务方更关心的指标，是有实际业务含义，可以直接取数据的指标。比如店铺近1天订单支付金额就是一个派生指标，会被直接在产品上展示给商家看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这个指标却不能直接从数仓的统一中间层里取数（因为没有现成的事实字段，数仓提供的一般都是大宽表）。需要有一个桥梁连接数仓中间层和业务方的指标需求，于是便有了派生指标&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;派生指标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度+修饰词+原子指标。店铺近1天订单支付金额中店铺是维度，近1天是一个时间类型的修饰词，支付金额是一个原子指标；维度：观察各项指标的角度；修饰词：维度的一个或某些值，比如维度性别下，男和女就是2种修饰词。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;衍生指标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如某一个促销活动的转化率就是衍生指标，因为需要促销投放人数指标和促销订单数指标进行计算得出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;标签&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标签是人为设定的、根据业务场景需求，对目标对象运用一定的算法得到的高度精炼的特征标识。可见标签是经过人为再加工后的结果，如网红、白富美、萝莉。对于有歧义的标签，我们内部可进行标签区分，比如：苹果，我们可以定义苹果指的是水果，苹果手机才指的是手机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自然键&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由现实中已经存在的属性组成的键，它在业务概念中是唯一的，并具有一定的业务含义，比如商品ID，员工ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以数仓角度看，来自于业务系统的标识符就是自然键，比如业务库中员工的编号。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;持久键&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保持永久性不会发生变化。有时也被叫做超自然持久键。比如身份证号属于持久键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自然键和持久键区别：举个例子就明白了，比如说公司员工离职之后又重新入职，他的自然键也就是员工编号发生了变化，但是他的持久键身份证号是不变的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代理键&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是不具有业务含义的键。代理键有许多其他的称呼：无意义键、整数键、非自然键、人工键、合成键等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理键就是简单的以按照顺序序列生产的整数表示。产品行的第1行代理键为1，则下一行的代理键为2，如此进行。代理键的作用仅仅是连接维度表和事实表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;退化维度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;退化维度，就是那些看起来像是事实表的一个维度关键字，但实际上并没有对应的维度表，就是维度属性存储到事实表中，这种存储到事实表中的维度列被称为退化维度。与其他存储在维表中的维度一样，退化维度也可以用来进行事实表的过滤查询、实现聚合操作等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么究竟怎么定义退化维度呢？比如说订单id，这种量级很大的维度，没必要用一张维度表来进行存储，而我们进行数据查询或者数据过滤的时候又非常需要，所以这种就冗余在事实表里面，这种就叫退化维度，citycode这种我们也会冗余在事实表里面，但是它有对应的维度表，所以它不是退化维度。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;下钻&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是在数据分析中常见的概念，下钻可以理解成增加维的层次，从而可以由粗粒度到细粒度来观察数据，比如对产品销售情况分析时，可以沿着时间维从年到月到日更细粒度的观察数据。从年的维度可以下钻到月的维度、日的维度等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;上卷&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道了下钻，上卷就容易理解了，它俩是相逆的操作，所以上卷可以理解为删掉维的某些层，由细粒度到粗粒度观察数据的操作或沿着维的层次向上聚合汇总数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;T+0与T+1&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概念最早来自于股市。T+0和T+1交易制度是中国股市的一种交易制度，T+0交易指的是当天买入股票可当天卖出，当天卖出股票又可当天买入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大数据中：T+0代表实时处理的数据。T+1代表处理昨天的数据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据挖掘&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据挖掘是指利用复杂的模式识别技术从大量数据中找到有意义的模式、提取见解。这与我们前文讨论的使用个人数据做分析的术语“分析”密切相关。为了提取出有意义的模式，数据挖掘者使用统计学(是呀，好老的数学)、机器学习算法和人工智能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据科学家&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们谈论的是一个如此热门的职业!数据科学家们可以通过提取原始数据(难道是从前文所说的数据湖中提取的?)，处理数据，然后提出新见解。数据科学家所需具备的一些技能与超人无异：分析、统计、计算机科学、创造力、故事讲述和理解业务环境。难怪他们能获得如此高的薪水报酬。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总线架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度建模的数据仓库中，有一个概念叫&lt;span&gt;Bus Architecture&lt;/span&gt;，中文一般翻译为“&lt;span&gt;总线架构&lt;/span&gt;”。总线架构是Kimball的多维体系结构（MD）中的三个关键性概念之一，另两个是&lt;span&gt;一致性维度（Conformed Dimension）和一致性事实（Conformed Fact）&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多维体系结构（MD） 的数据仓库架构中，主导思想是&lt;span&gt;分步建立数据仓库，由数据集市组合成企业的数据仓库&lt;/span&gt;。但是，在建立第一个数据集市前，架构师首先要做的就是设计出在整个企业内具有统一解释的标准化的维度和事实，即一致性维度和一致性事实。而开发团队必须严格的按照这个体系结构来进行数据集市的迭代开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一致性维度就好比企业范围内的一组总线，不同数据集市的事实的就好比插在这组总线上的元件。这也是称之为总线架构的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际设计过程中，我们通常把总线架构列表成矩阵的形式，其中列为一致性维度，行为不同的业务处理过程，即事实，在交叉点上打上标记表示该业务处理过程与该维度相关。这个矩阵也称为总线矩阵（Bus Matrix）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线架构和一致性维度、一致性事实共同组成了Kimball的多维体系结构的基础，也建立了一套可以逐步建立数据仓库的方法论。由于总线架构是多维体系结构的核心，所以我们有时就把多维体系结构直接称为总线架构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总线矩阵&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，总线矩阵的一行会产生几个相关的事实表，由此可以从不同角度跟踪业务过程。订单业务过程可能会有行项级别的订单事务事实表和订单级别的订单快照事实表。这两种基于订单的维度模型同属于订单业务过程，这种分组称为业务过程维度模型。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、数仓概念之间关系&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实体表，事实表，维度表之间的关系&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kimball维度建模中有维度与事实，在Inmon范式建模中有实体与关系，如果我们分开两种建模方式看这些概念比较容易理解。但是目前也出现了不少混合建模方式，两种建模方式结合起来看，这些概念是不是容易记忆混乱，尤其事实表和实体表，它们之间到底有怎样区别与联系，先看下它们各自概念：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维度表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度表可以看成是用户用来分析一个事实的窗口，它里面的数据应该是对事实的各个方面描述，比如时间维度表，地域维度表，维度表是事实表的一个分析角度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事实表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表其实就是通过各种维度和一些指标值的组合来确定一个事实的，比如通过时间维度，地域组织维度，指标值可以去确定在某时某地的一些指标值怎么样的事实。事实表的每一条数据都是几条维度表的数据和指标值交汇而得到的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实体表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实体表就是一个实际对象的表，实体表放的数据一定是一条条客观存在的事物数据，比如说各种商品，它就是客观存在的，所以可以将其设计一个实体表。实时表只描述各个事物，并不存在具体的事实，所以也有人称实体表是无事实的事实表。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;举个例子：比如说手机商场中有苹果手机，华为手机等各品牌各型号的手机，这些数据可以组成一个手机实体表，但是表中没有可度量的数据。某天苹果手机卖了15台，华为手机卖了20台，这些手机销售数据属于事实，组成一个事实表。这样就可以使用日期维度表和地域维度表对这个事实表进行各种维度分析。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指标与标签的区别&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概念不同&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指标是用来定义、评价和描述特定事物的一种标准或方式。比如：新增用户数、累计用户数、用户活跃率等是衡量用户发展情况的指标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标签是人为设定的、根据业务场景需求，对目标对象运用一定的算法得到的高度精炼的特征标识。可见标签是经过人为再加工后的结果，如网红、白富美、萝莉。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构成不同&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指标名称是对事物质与量两方面特点的命名；指标取值是指标在具体时间、地域、条件下的数量表现，如人的体重，指标名称是体重，指标的取值就是120斤；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标签名称通常都是形容词或形容词+名词的结构，标签一般是不可量化的，通常是孤立的，除了基础类标签，通过一定算法加工出来的标签一般都没有单位和量纲。如将超过200斤的称为大胖子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分类不同&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照指标计算逻辑，可以将指标分为原子指标、派生指标、衍生指标三种类型；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照对事件描述内容的不同，分为过程性指标和结果性指标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照标签的变化性分为&lt;span&gt;静态标签&lt;/span&gt;和&lt;span&gt;动态标签&lt;/span&gt;；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照标签的指代和评估指标的不同，可分为&lt;span&gt;定性标签&lt;/span&gt;和&lt;span&gt;定量标签&lt;/span&gt;；&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;指标最擅长的应用是监测、分析、评价和建模。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;标签最擅长的应用是标注、刻画、分类和特征提取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特别需要指出的是，由于对结果的标注也是一种标签，所以在自然语言处理和机器学习相关的算法应用场景下，标签对于监督式学习有重要价值，只是单纯的指标难以做到的。而指标在任务分配、绩效管理等领域的作用，也是标签无法做到的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;维度和指标区别与联系&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度就是数据的观察角度，即从哪个角度去分析问题，看待问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指标就是从维度的基础上去衡算这个结果的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度一般是一个离散的值，比如时间或地域维度上每一个独立的日期或地区。因此统计时，可以把维度相同记录的聚合在一起，应用聚合函数做累加、均值、最大值、最小值等聚合计算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指标就是被聚合的通计算，即聚合运算的结果，一般是一个连续的值。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自然键与代理键在数仓的使用区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓工具箱中说维度表的唯一主键应该是代理键而不应该是自然键。有时建模人员不愿意放弃使用自然键，因为他们希望与操作型代码查询事实表，而不希望与维度表做连接操作。然而，应该避免使用包含业务含义的多维键，因为不管我们做出任何假设最终都可能变得无效，因为我们控制不了业务库的变动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以数据仓库中维度表与事实表的每个连接应该基于无实际含义的整数代理键。避免使用自然键作为维度表的主键。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;SKU与SPU&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;SPU = Standard Product Unit (标准化产品单元)&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;SKU=stock keeping unit(库存量单位)&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;SKU即库存进出计量的单位， 可以是以件、盒、托盘等为单位。&lt;/p&gt;&lt;p&gt;你想要一台iPhone13, 店员也会再继续问: 你想要什么iPhone 13? 64G 银色?128G 白色?每一台iPhone 13的毛重都是400.00g,产地也都是中国大陆，这两个属性就属于spu属性。&lt;/p&gt;&lt;p&gt;而容量和颜色,这种会影响价格和库存的(比如64G与128G的价格不同,128G白色还有货,绿色卖完了)属性就是sku属性。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;spu属性：&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1、毛重420.00 g&lt;/p&gt;&lt;p&gt;2、产地中国大陆&lt;/p&gt;&lt;h3&gt;&lt;span&gt;sku属性:&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1、容量: 16G, 64G, 128G&lt;/p&gt;&lt;p&gt;2、颜色: 银、白、玫瑰金&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;--end--&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;扫描下方二维码&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;添加好友，备注【&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;交流&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;】&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可围观朋友圈，也可私信交流&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/W5ic5oJ9K6NL2XmmReYHG5BxLCqzJgSthQaMiaDI2WribNY4hed0icr3CMNfXcicCkxDB95lOeQbOaFv1Xhlic3zvtVg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1128&quot; data-cropy1=&quot;74.55172413793103&quot; data-cropy2=&quot;1179.8620689655172&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9796296296296296&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/W5ic5oJ9K6NL2XmmReYHG5BxLCqzJgSth1wOJMYNxtPNOQKneptngURmQxASp2GJ4MQtS6bp5FjSAJsWnU6ia9Fw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f95d4438d7bdb67853a1ebeb07296722</guid>
<title>36 张图，一次性补全网络基础知识</title>
<link>https://toutiao.io/k/z91qdpp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;全栈前端精选&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;Just_FED&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;内容为王，精选为则。从前端到全栈，定期分享前端、客户端、Node、面试、职场感悟等相关高质量文章。小白的大神养成记，你我共勉！&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c913a773232ff28c923b361c727b4d3a</guid>
<title>SpringBoot 如何保证接口安全？老鸟们都是这么玩的！</title>
<link>https://toutiao.io/k/da6fvh2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是苏三。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于互联网来说，只要你系统的接口暴露在外网，就避免不了接口安全问题。如果你的接口在外网裸奔，只要让黑客知道接口的地址和参数就可以调用，那简直就是灾难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：你的网站用户注册的时候，需要填写手机号，发送手机验证码，如果这个发送验证码的接口没有经过特殊安全处理，那这个短信接口早就被人盗刷不知道浪费多少钱了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何保证接口安全呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，暴露在外网的api接口需要做到&lt;strong&gt;防篡改&lt;/strong&gt;和&lt;strong&gt;防重放&lt;/strong&gt;才能称之为安全的接口。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防篡改&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道http 是一种无状态的协议，服务端并不知道客户端发送的请求是否合法，也并不知道请求中的参数是否正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子, 现在有个充值的接口，调用后可以给用户增加对应的余额。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;http:&lt;/span&gt;/&lt;span&gt;/localhost/api&lt;/span&gt;&lt;span&gt;/user/recharge&lt;/span&gt;?user_id=&lt;span&gt;1001&lt;/span&gt;&amp;amp;amount=&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果非法用户通过抓包获取到接口参数后，修改user_id 或 amount的值就可以实现给任意账户添加余额的目的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何解决&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用https协议可以将传输的明文进行加密，但是黑客仍然可以截获传输的数据包，进一步伪造请求进行重放攻击。如果黑客使用特殊手段让请求方设备使用了伪造的证书进行通信，那么https加密的内容也会被解密。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般的做法有2种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;采用https方式把接口的数据进行加密传输，即便是被黑客破解，黑客也花费大量的时间和精力去破解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接口后台对接口的请求参数进行验证，防止被黑客篡改；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5148995148995149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKomGCEViagKJ8nibEOrCOuXp37YjGoTibibIl4qwyaxa2PZt6ib2V4Qpb14Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1443&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;步骤1：客户端使用约定好的秘钥对传输的参数进行加密，得到签名值sign1，并且将签名值也放入请求的参数中，发送请求给服务端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤2：服务端接收到客户端的请求，然后使用约定好的秘钥对请求的参数再次进行签名，得到签名值sign2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;步骤3：服务端比对sign1和sign2的值，如果不一致，就认定为被篡改，非法请求。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;防重放&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防重放也叫防复用。简单来说就是我获取到这个请求的信息之后什么也不改,，直接拿着接口的参数 &lt;code&gt;重复请求这个充值的接口&lt;/code&gt;。此时我的请求是合法的, 因为所有参数都是跟合法请求一模一样的。&lt;br/&gt;&lt;br/&gt;重放攻击会造成两种后果：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;针对插入数据库接口：重放攻击，会出现大量重复数据，甚至垃圾数据会把数据库撑爆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;针对查询的接口：黑客一般是重点攻击慢查询接口，例如一个慢查询接口1s，只要黑客发起重放攻击，就必然造成系统被拖垮，数据库查询被阻塞死。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于重放攻击一般有两种做法：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于timestamp的方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次HTTP请求，都需要加上timestamp参数，然后把timestamp和其他参数一起进行数字签名。因为一次正常的HTTP请求，从发出到达服务器一般都不会超过60s，所以服务器收到HTTP请求之后，首先判断时间戳参数与当前时间比较，是否超过了60s，如果超过了则认为是非法请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，黑客从抓包重放请求耗时远远超过了60s，所以此时请求中的timestamp参数已经失效了。如果黑客修改timestamp参数为当前的时间戳，则sign1参数对应的数字签名就会失效，因为黑客不知道签名秘钥，没有办法生成新的数字签名。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5106524633821571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKQL2eMsnqPMcXSZjUGIsAOFuG4J9unKT1ddkxaGmelkHshRNPplro3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1502&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种方式的漏洞也是显而易见，如果在60s之内进行重放攻击，那就没办法了，所以这种方式不能保证请求仅一次有效。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3218390804597701&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKW7V8ED3AUEf2fnUM7Q2aw6KzNVjfQNic3KPvSEMvM8GsH83DKIUdk3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1914&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老鸟们一般会采取下面这种方案，既可以解决接口重放问题，又可以解决接口一次请求有效的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于nonce + timestamp 的方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nonce的意思是仅一次有效的随机字符串，要求每次请求时该参数要保证不同。实际使用用户信息+时间戳+随机数等信息做个哈希之后，作为nonce参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时服务端的处理流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;去 redis 中查找是否有 key 为 &lt;code&gt;nonce:{nonce} &lt;/code&gt; 的 string&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有，则创建这个 key，把这个 key 失效的时间和验证 timestamp 失效的时间一致，比如是 60s。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有，说明这个 key 在 60s 内已经被使用了，那么这个请求就可以判断为重放请求。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49357072205736896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jEXDkwjCHn8A3Iia4zpIqaKDT8kbG9CiaIWktCicqibzAVdUYbsJTlvwTy0MqqGtmkMHRhRYDdzr6VBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2022&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方案nonce和timestamp参数都作为签名的一部分传到后端，基于timestamp方案可以让黑客只能在60s内进行重放攻击，加上nonce随机数以后可以保证接口只能被调用一次，可以很好的解决重放攻击问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来通过实际代码来看看如何实现接口的防篡改和防重放。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、构建请求头对象&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Builder&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RequestHeader&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; String sign ;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; Long timestamp ;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; String nonce;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、工具类从HttpServletRequest获取请求参数&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@UtilityClass&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HttpDataUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * post请求处理：获取 Body 参数，转换为SortedMap&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; request&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  SortedMap&amp;lt;String, String&amp;gt; &lt;span&gt;getBodyParams&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; HttpServletRequest request)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] requestBody = StreamUtils.copyToByteArray(request.getInputStream());&lt;br/&gt;        String body = &lt;span&gt;new&lt;/span&gt; String(requestBody);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; JsonUtil.json2Object(body, SortedMap&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * get请求处理：将URL请求参数转换成SortedMap&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SortedMap&amp;lt;String, String&amp;gt; &lt;span&gt;getUrlParams&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String param = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        SortedMap&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(request.getQueryString())) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            param = URLDecoder.decode(request.getQueryString(), &lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        String[] params = param.split(&lt;span&gt;&quot;&amp;amp;&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String s : params) {&lt;br/&gt;            String[] array=s.split(&lt;span&gt;&quot;=&quot;&lt;/span&gt;);&lt;br/&gt;            result.put(array[&lt;span&gt;0&lt;/span&gt;], array[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的参数放入SortedMap中对其进行字典排序，前端构建签名时同样需要对参数进行字典排序。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、签名验证工具类&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@UtilityClass&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 验证签名&lt;br/&gt;     * 验证算法：把timestamp + JsonUtil.object2Json(SortedMap)合成字符串，然后MD5&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;verifySign&lt;/span&gt;&lt;span&gt;(SortedMap&amp;lt;String, String&amp;gt; map, RequestHeader requestHeader)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String params = requestHeader.getNonce() + requestHeader.getTimestamp() + JsonUtil.object2Json(map);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; verifySign(params, requestHeader);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 验证签名&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;verifySign&lt;/span&gt;&lt;span&gt;(String params, RequestHeader requestHeader)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.debug(&lt;span&gt;&quot;客户端签名: {}&quot;&lt;/span&gt;, requestHeader.getSign());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(params)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        log.info(&lt;span&gt;&quot;客户端上传内容: {}&quot;&lt;/span&gt;, params);&lt;br/&gt;        String paramsSign = DigestUtils.md5DigestAsHex(params.getBytes()).toUpperCase();&lt;br/&gt;        log.info(&lt;span&gt;&quot;客户端上传内容加密后的签名结果: {}&quot;&lt;/span&gt;, paramsSign);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; requestHeader.getSign().equals(paramsSign);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、HttpServletRequest包装类&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignRequestWrapper&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;HttpServletRequestWrapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//用于将流保存下来&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] requestBody = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;SignRequestWrapper&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(request);&lt;br/&gt;        requestBody = StreamUtils.copyToByteArray(request.getInputStream());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ServletInputStream &lt;span&gt;getInputStream&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; ByteArrayInputStream bais = &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(requestBody);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServletInputStream() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isFinished&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isReady&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setReadListener&lt;/span&gt;&lt;span&gt;(ReadListener readListener)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; bais.read();&lt;br/&gt;            }&lt;br/&gt;        };&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; BufferedReader &lt;span&gt;getReader&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(getInputStream()));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防篡改和防重放我们会通过SpringBoot Filter来实现，而编写的filter过滤器需要读取request数据流，但是request数据流只能读取一次，需要自己实现HttpServletRequestWrapper对数据流包装，目的是将request流保存下来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、创建过滤器实现安全校验&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignFilterConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${sign.maxTime}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String signMaxTime;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//filter中的初始化参数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; initParametersMap =  &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; FilterRegistrationBean &lt;span&gt;contextFilterRegistrationBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        initParametersMap.put(&lt;span&gt;&quot;signMaxTime&quot;&lt;/span&gt;,signMaxTime);&lt;br/&gt;        FilterRegistrationBean registration = &lt;span&gt;new&lt;/span&gt; FilterRegistrationBean();&lt;br/&gt;        registration.setFilter(signFilter());&lt;br/&gt;        registration.setInitParameters(initParametersMap);&lt;br/&gt;        registration.addUrlPatterns(&lt;span&gt;&quot;/sign/*&quot;&lt;/span&gt;);&lt;br/&gt;        registration.setName(&lt;span&gt;&quot;SignFilter&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 设置过滤器被调用的顺序&lt;/span&gt;&lt;br/&gt;        registration.setOrder(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; registration;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Filter &lt;span&gt;signFilter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SignFilter();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisUtil redisUtil;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//从fitler配置中获取sign过期时间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Long signMaxTime;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String NONCE_KEY = &lt;span&gt;&quot;x-nonce-&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;        HttpServletRequest httpRequest = (HttpServletRequest) servletRequest;&lt;br/&gt;        HttpServletResponse httpResponse = (HttpServletResponse) servletResponse;&lt;br/&gt;&lt;br/&gt;        log.info(&lt;span&gt;&quot;过滤URL:{}&quot;&lt;/span&gt;, httpRequest.getRequestURI());&lt;br/&gt;&lt;br/&gt;        HttpServletRequestWrapper requestWrapper = &lt;span&gt;new&lt;/span&gt; SignRequestWrapper(httpRequest);&lt;br/&gt;        &lt;span&gt;//构建请求头&lt;/span&gt;&lt;br/&gt;        RequestHeader requestHeader = RequestHeader.builder()&lt;br/&gt;                .nonce(httpRequest.getHeader(&lt;span&gt;&quot;x-Nonce&quot;&lt;/span&gt;))&lt;br/&gt;                .timestamp(Long.parseLong(httpRequest.getHeader(&lt;span&gt;&quot;X-Time&quot;&lt;/span&gt;)))&lt;br/&gt;                .sign(httpRequest.getHeader(&lt;span&gt;&quot;X-Sign&quot;&lt;/span&gt;))&lt;br/&gt;                .build();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//验证请求头是否存在&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(StringUtils.isEmpty(requestHeader.getSign()) || ObjectUtils.isEmpty(requestHeader.getTimestamp()) || StringUtils.isEmpty(requestHeader.getNonce())){&lt;br/&gt;            responseFail(httpResponse, ReturnCode.ILLEGAL_HEADER);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;/*&lt;br/&gt;         * 1.重放验证&lt;br/&gt;         * 判断timestamp时间戳与当前时间是否操过60s（过期时间根据业务情况设置）,如果超过了就提示签名过期。&lt;br/&gt;         */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; now = System.currentTimeMillis() / &lt;span&gt;1000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (now - requestHeader.getTimestamp() &amp;gt; signMaxTime) {&lt;br/&gt;            responseFail(httpResponse,ReturnCode.REPLAY_ERROR);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//2. 判断nonce&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; nonceExists = redisUtil.hasKey(NONCE_KEY + requestHeader.getNonce());&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(nonceExists){&lt;br/&gt;            &lt;span&gt;//请求重复&lt;/span&gt;&lt;br/&gt;            responseFail(httpResponse,ReturnCode.REPLAY_ERROR);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            redisUtil.set(NONCE_KEY+requestHeader.getNonce(), requestHeader.getNonce(), signMaxTime);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; accept;&lt;br/&gt;        SortedMap&amp;lt;String, String&amp;gt; paramMap;&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (httpRequest.getMethod()){&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;GET&quot;&lt;/span&gt;:&lt;br/&gt;                paramMap = HttpDataUtil.getUrlParams(requestWrapper);&lt;br/&gt;                accept = SignUtil.verifySign(paramMap, requestHeader);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;POST&quot;&lt;/span&gt;:&lt;br/&gt;                paramMap = HttpDataUtil.getBodyParams(requestWrapper);&lt;br/&gt;                accept = SignUtil.verifySign(paramMap, requestHeader);&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                accept = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (accept) {&lt;br/&gt;            filterChain.doFilter(requestWrapper, servletResponse);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            responseFail(httpResponse,ReturnCode.ARGUMENT_ERROR);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;responseFail&lt;/span&gt;&lt;span&gt;(HttpServletResponse httpResponse, ReturnCode returnCode)&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        ResultData&amp;lt;Object&amp;gt; resultData = ResultData.fail(returnCode.getCode(), returnCode.getMessage());&lt;br/&gt;        WebUtils.writeJson(httpResponse,resultData);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;        String signTime = filterConfig.getInitParameter(&lt;span&gt;&quot;signMaxTime&quot;&lt;/span&gt;);&lt;br/&gt;        signMaxTime = Long.parseLong(signTime);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6、Redis工具类&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisTemplate&amp;lt;String, Object&amp;gt; redisTemplate;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 判断key是否存在&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key 键&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true 存在 false不存在&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;hasKey&lt;/span&gt;&lt;span&gt;(String key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.TRUE.equals(redisTemplate.hasKey(key));&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 普通缓存放入并设置时间&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key   键&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; value 值&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; time  时间(秒) time要大于0 如果time小于等于0 将设置无限期&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true成功 false 失败&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(String key, Object value, &lt;span&gt;long&lt;/span&gt; time)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (time &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                set(key, value);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 普通缓存放入&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key   键&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; value 值&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt; true成功 false失败&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(String key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            redisTemplate.opsForValue().set(key, value);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>