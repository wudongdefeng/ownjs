<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4a0e6fa00650df19efe423b54703a5e6</guid>
<title>理想汽车：从 Hadoop 到云原生的演进与思考</title>
<link>https://toutiao.io/k/0sa2v7o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry&quot;&gt;
                    
                        
                            &lt;blockquote data-block-key=&quot;o462d&quot;&gt;作者简介：聂磊，理想汽车大数据架构师， 从事大数据工作 10 年；大数据架构工作 6 年；对主流大数据技术有深入的理解；目前主要在推进大数据云原生和湖仓一体技术方案在理想汽车的落地。&lt;/blockquote&gt;&lt;h2 data-block-key=&quot;6u6fl&quot;&gt;&lt;b&gt;理想汽车在 Hadoop 时代的技术架构&lt;/b&gt;&lt;/h2&gt;&lt;p data-block-key=&quot;dn9f1&quot;&gt;首先简单回顾下大数据技术的发展，基于我个人的理解，将大数据的发展分了 4 个时期：&lt;/p&gt;&lt;p data-block-key=&quot;cf6ge&quot;&gt;第一个时期：2006 年到 2008 年。2008 年左右，Hadoop 成为了 Apache 顶级项目，并正式发布了 1.0 版本，它的基础主要是基于谷歌的三驾马车，GFS、MapReduce、BigTable 去定义的。&lt;/p&gt;&lt;p data-block-key=&quot;9i8jo&quot;&gt;第二个时期：2009 年到 2013 年阶段。雅虎、阿里、Facebook 等企业对大数据的应用越来越多。2013 年底 Hadoop 正式发布 2.0 版本。&lt;b&gt;我有幸在 2012 年的时候开始接触大数据，用 Hadoop 1.0 加 Hive 的模式体验了下，当时感觉很神奇的，大数据用几台机器就可以快速解决原来用 SQL Server 或者 MySQL 解决不了的问题。&lt;/b&gt;&lt;/p&gt;&lt;p data-block-key=&quot;f9grs&quot;&gt;第三阶段：2014 年到 2019 年，这段时间发展的非常快，期间 Spark、Flink 都成为了 Apache 顶级项目。在这个快速爬升期的过程中，我们还尝试用过 Storm，后来 Storm 就被 Flink 所替代了。&lt;/p&gt;&lt;p data-block-key=&quot;3i85i&quot;&gt;第四阶段：从 2020 年至今，2020 年 Hudi 从 Apache 毕业成为顶级项目之后，我个人理解数据湖进入到整个发展的成熟期，到了大数据的数据湖 2.0 阶段。数据湖主要三个特点，首先是统一、开放式的存储，其次是开放式的格式，以及丰富的计算引擎。&lt;/p&gt;&lt;img alt=&quot;1&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/1.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;dd9gc&quot;&gt;&lt;br/&gt;整体的发展过程中，大数据主要是有几个特点，就是大家常说的四个“V”：规模性（Volume）、高速性（Velocity）、多样性（Variety）、价值性（Value）。现在还有第五个“V”（Veracity），数据的准确性和可信赖度。数据的质量是一直被人诟病的，希望行业里能有一套标准把数据湖的质量去做提升，这个可能是数据湖 2.0 出现的标准，因为出现了 Hudi、Iceberg 这些项目，都是想把整个数据湖的管理做好。&lt;/p&gt;&lt;p data-block-key=&quot;1b9fr&quot;&gt;&lt;b&gt;个人觉得 Hadoop 是大数据的一个代名词，但是大数据并不只有 Hadoop。大数据是在发展过程中由多个组件整合之后形成的一套解决大量数据加工处理和使用的解决方案。&lt;/b&gt;这几年，大家基本上认为 Hadoop 是在走下坡路的，首先是 Hadoop 商业化公司 Cloudera 和 Hortonworks 的合并和退市，原来的商业模式无法延续；也面临着快速增长的云供应商在成本和易用性上的挑战，以及 Hadoop 本身生态系统的日益复杂。&lt;/p&gt;&lt;h3 data-block-key=&quot;3sa1n&quot;&gt;&lt;b&gt;理想汽车大数据平台当前架构&lt;/b&gt;&lt;/h3&gt;&lt;img alt=&quot;2&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/2_jwi0JFu.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;etth6&quot;/&gt;&lt;p data-block-key=&quot;2cs8j&quot;&gt;在这个阶段，理想汽车的大数据平台如上图所示。理想汽车用了很多开源的组件。&lt;/p&gt;&lt;ul&gt;&lt;li data-block-key=&quot;39s5f&quot;&gt;传输层：Kafka 和 Pulsar 。平台构建初期整体都用的 Kafka，Kafka 的云原生能力比较差，Pulsar 在设计之初就是按照云原生架构设计的，并且有一些非常适合 IoT 场景的能力，和我们的业务场景也比较匹配，所以我们近期引进了 Pulsar；&lt;/li&gt;&lt;li data-block-key=&quot;9203c&quot;&gt;存储层是 HDFS + JuiceFS；&lt;/li&gt;&lt;li data-block-key=&quot;d7iqb&quot;&gt;计算层目前的主要的计算引擎是 Spark 、Hive 和 Flink，这些计算引都是跑在现在的 Yarn 上。三个计算引擎是通过 Apache Linkis 去管理的，Linkis 是微众银行开源的，目前我们对 Linkis 用的也是比较重的；&lt;/li&gt;&lt;li data-block-key=&quot;bcha0&quot;&gt;图片的右侧数据库，第一个 MatrixDB ，它是一个商业版的时序数据库，TiDB 主打做 OLTP 和 OLAP 的混合场景，目前我们主要用它来做 TP 的场景。StarRocks 负责 OLAP 的场景；&lt;/li&gt;&lt;li data-block-key=&quot;4ttm&quot;&gt;ShardingSphere，是想要用它的 Database Plus 的概念去把底下的数据库统一的去做一个网关层的管理。目前还在探索阶段，有很多新增特性我们都很感兴趣；&lt;/li&gt;&lt;li data-block-key=&quot;2krgv&quot;&gt;Thanos 是一个云原生的监控方案，我们已经将组件、引擎和机器的监控都整合到 Thanos 方案里；&lt;/li&gt;&lt;li data-block-key=&quot;cr4nv&quot;&gt;应用层是四个主要的中台产品，包括数据应用、数据开发、数据集成和数据治理。&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-block-key=&quot;18tbj&quot;&gt;&lt;b&gt;特点&lt;/b&gt;&lt;/h3&gt;&lt;p data-block-key=&quot;aca0q&quot;&gt;大家通过大数据平台的现状可以发现一些特点：&lt;/p&gt;&lt;ul&gt;&lt;li data-block-key=&quot;9rnpe&quot;&gt;第一，&lt;b&gt;整个方案的组件是比较多的&lt;/b&gt;，用户对这些组件的依赖性强，且组件之间互相的依赖性也比较强。&lt;b&gt;建议大家在未来组件选型的时候尽量选择云原生化比较成熟的组件；&lt;/b&gt;&lt;/li&gt;&lt;li data-block-key=&quot;drmjn&quot;&gt;第二，&lt;b&gt;我们的数据是有明确的波峰波谷。&lt;/b&gt;出行场景一般都是早高峰晚高峰，周六周日人数会比较多；&lt;/li&gt;&lt;li data-block-key=&quot;4ajqu&quot;&gt;第三个特点，&lt;b&gt;我们数据的热度基本上都是最热的&lt;/b&gt;，一般只访问最近几天或者最近一周的数据。但是产生了大量的数据，有的时候可能需要大量回溯，因而数据也需要长久的保存，这样对数据的利用率就差了很多。最后，整个数据体系目前从文件层面看缺少一些有效的管理手段。从建设至今，基本上还是以 HDFS 为主，有大量的无用数据存在，造成了资源的浪费，这是我们亟待解决的问题。&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-block-key=&quot;9qhug&quot;&gt;&lt;b&gt;大数据平台的痛点&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-block-key=&quot;9dhq2&quot;&gt;第一，&lt;b&gt;组件多，部署难度高、效率低&lt;/b&gt;。围绕 Hadoop 的大数据组件有 30 多个，常用的也有 10 几个之多。有些组件之间有强依赖和弱依赖，统一的配置和管理变得非常复杂。&lt;/li&gt;&lt;li data-block-key=&quot;7ecpm&quot;&gt;第二，&lt;b&gt;机器成本和维护成本比较高&lt;/b&gt;。为了业务的稳定运行，离线和实时集群进行了分开部署。但上面提到的业务特点，我们业务波峰波谷现象明显，整体利用率不高。集群组件繁多需要专门人员管理和维护。&lt;/li&gt;&lt;li data-block-key=&quot;37f03&quot;&gt;第三，&lt;b&gt;跨平台数据共享能力&lt;/b&gt;。目前跨集群共享数据只能通过 DistCp 方式同步到其他 Hadoop 集群。无法方便快捷的同步到其他平台和服务器上。&lt;/li&gt;&lt;li data-block-key=&quot;72tvk&quot;&gt;第四，&lt;b&gt;数据的安全和隐私合规&lt;/b&gt;。基于不同的数据安全需求，普通用户通过 Ranger 进行管理，特殊安全需求只能通过构建不同集群并设置单独 VPC 策略的方式来满足，造成很多数据孤岛和维护成本。&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-block-key=&quot;a79j8&quot;&gt;&lt;b&gt;理想汽车云原生的演进与思考&lt;/b&gt;&lt;/h2&gt;&lt;p data-block-key=&quot;dnr4g&quot;/&gt;&lt;img alt=&quot;3&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/3_B31CjbL.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;3jd98&quot;/&gt;&lt;p data-block-key=&quot;cdnk3&quot;&gt;首先，先简单分享一下我个人理解的云原生：&lt;/p&gt;&lt;p data-block-key=&quot;99v5k&quot;&gt;第一，云原生是在云计算的基础上衍生出来的。现在大家用的如阿里云、 AWS、腾讯云、百度云等云厂商，最开始提供的都是 IaaS 层的技术服务，帮企业把存储、计算、网络这些这些最基础的东西封装好统一管理，企业只需要在上面申请服务器就可以了。申请了服务器之后，这些服务器还是由云厂商来管理的，也就是大家传统的上云操作。&lt;/p&gt;&lt;p data-block-key=&quot;dog0m&quot;&gt;云原生离不开云计算，笼统地说，云原生属于云计算的 PaaS 层服务，主要是面向开发者的一类应用。云原生必须在云上安装，是一种基于云计算的软件开发应用方式。&lt;b&gt;云+原生，云即云计算，原生则是摒弃传统的运维开发框架，通过容器化、DevOps，还有微服务架构实现应用弹性伸缩和自动化部署，充分利用云计算资源实现在最少的空间里做最大的事。&lt;/b&gt;也能解决我们目前大数据系统的一些痛点，比如扩展性和维护性都比较差，需要大量人力与时间等。&lt;/p&gt;&lt;img alt=&quot;4&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/4_HUoUVFk.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;4efs3&quot;/&gt;&lt;p data-block-key=&quot;2hir0&quot;&gt;上图简单列了一下云原生的几个时间点&lt;/p&gt;&lt;ul&gt;&lt;li data-block-key=&quot;b39tf&quot;&gt;第一个阶段， AWS 提出了云原生的概念，并且在 2006 年推出了 EC2，这个阶段是服务器阶段，上文提到的云计算阶段；&lt;/li&gt;&lt;li data-block-key=&quot;ap0tj&quot;&gt;第二个阶段，云化阶段，主是在开源 Docker 发布和谷歌开源了 Kuberneters 之后。Kubernetes 是一个轻便的和可扩展的开源平台，用于管理容器化应用和服务。通过 Kubernetes 能够进行应用的自动化部署和扩缩容；&lt;/li&gt;&lt;li data-block-key=&quot;bd3gv&quot;&gt;第三个阶段，2015 年的时候成立了 CNCF 基金会，在主推云原生概念，帮助云原生整体发展的更好。最后是 Knative 的开源，Knative 一个很重要的目标就是制定云原生、跨平台的 Serverless 编排标准。衍生到现在，已经是云原生 2.0 阶段，即 Serverless 这个阶段。&lt;b&gt;我个人理解大数据的发展应该也是朝着 Serverless 的方向去发展。&lt;/b&gt;比如现在 AWS 整个在线的服务基本上都做到了 Serverless。&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-block-key=&quot;84s1p&quot;&gt;&lt;b&gt;大数据云原生架构&lt;/b&gt;&lt;/h3&gt;&lt;img alt=&quot;5&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/5_UTyki31.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;enups&quot;/&gt;&lt;p data-block-key=&quot;3njt0&quot;&gt;接下来介绍一下理想汽车大数据平台在云原生化之后组件发生的变化：&lt;/p&gt;&lt;ul&gt;&lt;li data-block-key=&quot;dg38a&quot;&gt;存储层，&lt;b&gt;云原生化之后所有的存储基本上都是对象存储了&lt;/b&gt;。上面的架构图引出了 Lustre，下文会详细介绍。&lt;b&gt;大家可以理解为「云存储」这一层主要是以 JuiceFS 来管理对象存储和 Lustre 并行分布式文件系统&lt;/b&gt;（注：由于 Lustre 的单副本问题，我们目前也在考虑使用云服务商提供的并行文件系统产品）；&lt;/li&gt;&lt;li data-block-key=&quot;l7fb&quot;&gt;容器层，主要是在计算、存储、网络之上，全部都用 Kubernetes 加 Docker 来替代，所有的组件都是在这上面生长出来的；&lt;/li&gt;&lt;li data-block-key=&quot;debqs&quot;&gt;组件部分，首先是大数据计算框架，我们可能会废弃掉 Hive，直接沿用 Spark 和 Flink，通过 Hudi 去做数据湖 2.0 的底层能力支撑并逐步替换HDFS；&lt;/li&gt;&lt;li data-block-key=&quot;6ubir&quot;&gt;中间件部分，除了 Pulsar 以外还有 Kafka，目前 Kafka 的云原生化做的并不是特别好，我个人更倾向于用 Pulsar 去替换 Kafka。目前线上已经使用Linkis适配了所有Spark引擎，后面会进行Flink的适配和整合。ShardingSphere 在 5.1.2 版本刚刚支持云原生，我们会按计划进行场景验证和能力探索；&lt;/li&gt;&lt;li data-block-key=&quot;11nmr&quot;&gt;数据库层，还是 TiDB、StarRocks、MatrixDB，目前这三个数据库已经有云原生的能力，它们都支持对象存储。但这一块还没有单独去测过，我们目前用的还都是物理机。因为对于数据库来说，当前对象存储提供的IO能力还无法满足数据库的性能要求，会使得数据库的整体性能大打折扣；&lt;/li&gt;&lt;li data-block-key=&quot;idkk&quot;&gt;运维方面，由 Thanos 方案多加了一个 Loki，主要是做云原生的日志收集。但是 Loki 和 Thanos 只是其中两个，未来我理解应该会朝着阿里开源的SREWorks能力看齐，把整个的质量成本效率和安全全部都封在综合运维能力里边，这样就可以把整个的云原生管理起来；&lt;/li&gt;&lt;li data-block-key=&quot;3i2p8&quot;&gt;可观测性，云原生领域最近比较热门的概念。现在大家做的组件，有一些是在有热度之后，才开始发展云原生的，它并不是一开始生在云上，它只是后面希望长在云上。这种情况下它会遇到一些问题，第一个问题，就是没有全面的可见性的监控。我们考虑后续如何把这些组件整体的出一个方案，在所有组件上到云原生后可以有效的监控。&lt;/li&gt;&lt;/ul&gt;&lt;p data-block-key=&quot;6cste&quot;&gt;总结一下，我个人觉得大数据未来的云原生基本上就是：&lt;/p&gt;&lt;ol&gt;&lt;li data-block-key=&quot;f7acc&quot;&gt;&lt;b&gt;统一使用云原生的存储作为所有组件（包括数据库）的底层存储;&lt;/b&gt;&lt;/li&gt;&lt;li data-block-key=&quot;4h9id&quot;&gt;&lt;b&gt;所有组件都运行在容器中;&lt;/b&gt;&lt;/li&gt;&lt;li data-block-key=&quot;5mjuo&quot;&gt;&lt;b&gt;使用 Serverless 架构服务上层应用。&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-block-key=&quot;9335d&quot;&gt;但是这样也给目前的数据平台产品带来挑战，就是如何设计具备 Serverless&lt;br/&gt;能力的产品来给用户使用。&lt;/p&gt;&lt;h3 data-block-key=&quot;a7p22&quot;&gt;&lt;b&gt;大数据云原生的优势&lt;/b&gt;&lt;/h3&gt;&lt;p data-block-key=&quot;fj8i8&quot;&gt;第一点，&lt;b&gt;存算分离，弹性伸缩&lt;/b&gt;。使用物理机部署 Hadoop 之后，如果需要扩容缩容还需要去联系运营商，并且可能会有很长的周期，存算分离很好地解决了这个问题。其次是按需付费，不用购买闲置资源，目前我们整个的业务场景的数据是有波峰波谷的，波峰的时候需要准备机器，波谷的时候需要撤机器，但现在是做不到的。现在我们基本上是把所有的机器都堆到波峰，波峰的时候能满足需求，稳定不失败，但它在波谷的时候最少 12 个小时左右是闲置的，这种情况下资源也是要付费的。云原生之后我们就可以不用再为此买单了。&lt;/p&gt;&lt;p data-block-key=&quot;4p05i&quot;&gt;第二点，&lt;b&gt;自动化部署和可运维性&lt;/b&gt;。Kubernetes 是支持 DevOps 集成化的部署方案的。这样我们的组件整体可以实现快速的部署（比如通过 Helm chart），把组件运维的能力下沉到云原生平台上，这样大数据就不需要考虑组件运维场景了。&lt;/p&gt;&lt;p data-block-key=&quot;7ft6p&quot;&gt;第三点，&lt;b&gt;对象存储&lt;/b&gt;。对象存储是云计算推出的最核心最主要的产品。对象存储的好处不言而喻了，易扩展，存储空间无上下限，单价比较低，而且对象存储还分为低频存储、归档存储等多种存储类型，进一步降低存储成本，数据就可以存更长时间。同时成本可控，高可靠，操作复杂性低也都是对象存储的优势。&lt;/p&gt;&lt;p data-block-key=&quot;9rq4d&quot;&gt;第四点，&lt;b&gt;安全和合规性&lt;/b&gt;。云原生之后可以实现专用命名空间，多租户隔离，远程认证。目前我们做到的基本上都是网络层面上的隔离，HDFS的文件管理大家公认的方案是Ranger。通过 Ranger 去管理 HDFS 的目录权限，也能管理如 Hive server、HBase、Kafka 的一些权限，但是相对而言这些权限都会偏弱一些。&lt;/p&gt;&lt;p data-block-key=&quot;b3p1u&quot;&gt;还有一个方案是 Kerberos，整个大数据组件的安全性会提高很多，但是它有很多的成本，它任何一个请求都要去验证。这个方案目前我们没有使用过，和我们的集群环境和场景有关系，我们基本上都是内网的，并不对外提供服务。如果大家做的大数据项目需要对外网提供一些服务，还是需要有强认证，不然数据很容易泄露。&lt;/p&gt;&lt;h3 data-block-key=&quot;doed1&quot;&gt;&lt;b&gt;大数据云原生的难点&lt;/b&gt;&lt;/h3&gt;&lt;p data-block-key=&quot;ema2v&quot;&gt;大数据云原生的难点同样也是存在的。&lt;/p&gt;&lt;p data-block-key=&quot;590li&quot;&gt;第一，大数据相关的组件是比较多的，同时 Kubernetes 的更新比较快，组件和组件之间交叉之后，兼容性、复杂性和扩展性，都会存在问题。&lt;/p&gt;&lt;p data-block-key=&quot;8btmo&quot;&gt;第二，资源的分配和再分配。Kubernetes 是通用的容器资源调度工具，很难满足不同大数据组件的资源使用场景。大数据场景下资源使用会比较大，请求频率高，每次启动的 pod 的数又会比较多，这种情况下，目前没有什么好的方案。目前我们正在看 Fluid 这个方案，Fluid 也实现了 JuiceFS 的 runtime，这个也是我们后边要去深入调研的，Fluid 目前宣称是可以支持大数据和 AI 的，并不是只有 AI 的场景，因为大数据和 AI 的场景是比较像的，都是数据密集型的操作，Fluid 在计算效率和数据抽象管理方面是有了一些突破性的进展。&lt;/p&gt;&lt;p data-block-key=&quot;e1o42&quot;&gt;第三点，对象存储也是有一些劣势的。对象存储的劣势是元数据操作性能低、和大数据组件兼容性差、最终一致性等问题。&lt;/p&gt;&lt;p data-block-key=&quot;1vtuq&quot;&gt;最后一点，就是数据密集型应用。存算分离模式无法满足大数据、AI 等数据密集型应用在计算运行效率、数据抽象管理方面的需求。&lt;/p&gt;&lt;p data-block-key=&quot;64m84&quot;/&gt;&lt;h2 data-block-key=&quot;15uev&quot;&gt;&lt;b&gt;JuiceFS在云原生方案的探索和落地&lt;/b&gt;&lt;/h2&gt;&lt;p data-block-key=&quot;dkqub&quot;&gt;在 JuiceFS 开源之前我们就已经关注并做了一些落地的测试，开源版上线之后，我们就马上上线使用了。上线的时候也遇到了一些权限的问题和几个小的 bug，社区非常给力，快速地帮我们都解决了。&lt;/p&gt;&lt;img alt=&quot;6&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/6_JGt6FZL.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;8ek8t&quot;&gt;&lt;br/&gt;要下线 HDFS 是因为它的扩展性差，同时我们的数据量比较大，HDFS 的存储成本比较高。在存储了几批数据后，物理机的空间就不够了，而且需要的计算非常多。当时我们的业务发展还在初期，为了尽可能从数据中获得价值，我们要保留尽可能多的数据。而且 HDFS 需要三副本，我们后来改成两副本，但是两副本还是有风险的。在这个基础上，我们深度测试了 JuiceFS，测试完成之后，我们很快就把 JuiceFS 引到我们的线上环境。把一些比较大的表从 HDFS 迁移到 JuiceFS 里，缓解了我们的燃眉之急。我们对 JuiceFS 比较看重的三点：&lt;/p&gt;&lt;ul&gt;&lt;li data-block-key=&quot;cjrt6&quot;&gt;第一， &lt;b&gt;JuiceFS 是多协议兼容&lt;/b&gt;。完全兼容 POSIX、HDFS 和 S3 协议 ，目前用下来都是百分百兼容的，没有遇到任何问题。&lt;/li&gt;&lt;li data-block-key=&quot;8ack7&quot;&gt;第二，&lt;b&gt;跨云的能力&lt;/b&gt;。当企业有一定规模之后，为了避免系统性风险，都不会只使用一个云服务商。不会绑在一个云上，都会是多云操作的。这种情况下，JuiceFS 的跨云数据同步的能力就起到了作用。&lt;/li&gt;&lt;li data-block-key=&quot;4vgtq&quot;&gt;第三，&lt;b&gt;云原生的场景&lt;/b&gt;。JuiceFS 支持 CSI，目前 CSI 这个场景我们还没有用，我们基本上都是用 POSIX 去挂载的，但是使用 CSI 的方式会更简单更兼容，我们现在也正在往云原生上去发展，但整个的组件还没有真正上到 Kubernetes。&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-block-key=&quot;3q311&quot;&gt;&lt;b&gt;JuiceFS 在理想汽车的应用&lt;/b&gt;&lt;/h3&gt;&lt;h4 data-block-key=&quot;65qs2&quot;&gt;&lt;b&gt;场景 1：从 HDFS 将数据持久化到对象存储&lt;/b&gt;&lt;/h4&gt;&lt;img alt=&quot;7&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/7.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;98kqp&quot;/&gt;&lt;p data-block-key=&quot;72edc&quot;&gt;JuiceFS 开源之后，我们就开始尝试把 HDFS 上的数据同步到 JuiceFS。开始同步的时候是使用 DistCp，结合 JuiceFS 的 Hadoop SDK 同步非常方便，整体迁移比较顺利。之所以要把数据从 HDFS 迁移到 JuiceFS 上，是因为遇到了一些问题。&lt;/p&gt;&lt;p data-block-key=&quot;cmpke&quot;&gt;第一， &lt;b&gt;HDFS 的存算耦合设计扩展性差&lt;/b&gt; ，这个是没有办法解决的。我个人从一开始接触大数据的认知就是大数据是必须要部署在物理机上的，而不是在云主机。包括后来云厂商推出的各类 EMR 系统，其实是在对 Hadoop 进行封装，最近一两年这些 EMR 系统都在逐渐去 Hadoop 化。&lt;/p&gt;&lt;p data-block-key=&quot;3dtmm&quot;&gt;第二，&lt;b&gt;HDFS 难以适配云原生化&lt;/b&gt;。现在的 HDFS 很难适配云原生，因为它比较重，虽然社区一直在着重发力去做云原生，&lt;b&gt;但是我个人认为 Hadoop 的发展趋势在走下坡路，未来应该以对象存储为主&lt;/b&gt;。&lt;/p&gt;&lt;p data-block-key=&quot;epk3k&quot;&gt;第三，&lt;b&gt;对象存储也有一些弊病，它不能很好的适配 HDFS API&lt;/b&gt;，由于网络等原因性能跟本地盘比也相差很多，另外 list 目录等元数据操作也很慢。我们通过 JuiceFS 做一些加速，测下来性能非常可观，在有缓存的情况下基本上可以媲美本地盘，基于此我们快速地将当前的场景直接切换到 JuiceFS 上。&lt;/p&gt;&lt;h4 data-block-key=&quot;6mnpg&quot;&gt;&lt;b&gt;场景 2：平台级别的文件共享&lt;/b&gt;&lt;/h4&gt;&lt;p data-block-key=&quot;541qb&quot;/&gt;&lt;img alt=&quot;8&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/8.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;2g8dd&quot;/&gt;&lt;p data-block-key=&quot;f19r1&quot;&gt;我们目前的整个调度系统、实时系统、开发平台的共享文件的数据全部都是存在 HDFS 上的，后续如果要是停止使用 HDFS，需要把这些数据迁移走。目前的方案是用 JuiceFS 对接对象存储，通过应用层的服务，全部以 POSIX 的方式挂载上去，大家就可以无感地去请求 JuiceFS 里的文件。&lt;/p&gt;&lt;p data-block-key=&quot;3l6st&quot;&gt;JuiceFS 在这个场景满足了我们大部分的应用需求，但还有些小场景存在问题。最初的设想是会把 Python 环境之类的都放进去，后来发现实操难度太大，因为 Python 环境里边有大量的小文件，加载的时候还是会有问题。类似 Python 环境这种包含大量碎文件的场景还是需要存储在本地盘来操作。后续我们准备挂一块块存储，专门来做这件事。&lt;/p&gt;&lt;p data-block-key=&quot;7auli&quot;&gt;分享几个我们之前使用 HDFS 遇到的问题：&lt;/p&gt;&lt;p data-block-key=&quot;hopm&quot;&gt;第一个，&lt;b&gt;当 NameNode 压力大或 Full GC 时会有下载失败的情况&lt;/b&gt;，目前暂时没有一个完美的方案解决。我们的方案是尽量加内存，或者在下载包的时候加一些重试，避一避它的高峰期，但是这种情况下很难完全解决 HDFS 的问题，因为它终究是 Java 写的，GC 的场景是没有办法避免的。&lt;/p&gt;&lt;p data-block-key=&quot;5ah0a&quot;&gt;第二个，&lt;b&gt;在跨系统里面去使用 HDFS 的时候，比如我们有两个集群，现在要用一个集群去共享文件，基本上是不现实的&lt;/b&gt;，因为需要开通网络，来把两个集群之间打通或者应用上打通，这样安全性是没有办法保证的。目前我们基本上就是两个集群是独立各自维护自己的共享文件。现在实时平台（如 Flink 平台）已经切换到 JuiceFS 上了，目前还是非常顺利，没有遇到什么问题。&lt;/p&gt;&lt;p data-block-key=&quot;enggr&quot;&gt;第三个&lt;b&gt;，目前我们有大量的物理机部署，物理机部署都是单集群的，没有容灾的策略&lt;/b&gt;，如果哪天机房出了一些灾难性的问题，我们整个服务就不可用了。但是对象存储它本身是跨机房，是同一个 region 里面，应该都是有最少三个副本，云厂商帮我们做到了备份。后续，我们可能会发展多云，希望通过 JuiceFS 去共享一些高级别的文件、核心的数据库，包括一些核心的备份文件，在多云里面去做备份。这样就实现了多云、多 region、多地域，就可以解决现在单点容灾的问题。&lt;/p&gt;&lt;h4 data-block-key=&quot;ffdpe&quot;&gt;&lt;b&gt;场景 3：海量数据跨平台使用&lt;/b&gt;&lt;/h4&gt;&lt;img alt=&quot;9&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/9.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;ekd4n&quot;/&gt;&lt;p data-block-key=&quot;9kvc5&quot;&gt;另外一个场景，平台和平台之间全部都是通过 JuiceFS 去共享海量数据。我们这边的共享的数据中第一类是路试车的数据，路试车会有大量的视频语音图像数据上传，这些数据上传了之后会直接进到 JuiceFS 里，方便下游去做一些同步和共享，包括一些数据的筛查，再拿到 PFS 就是并行文件系统，其下面挂载的是 SSD。这样可以让 GPU 利用率更高一些，因为对象存储的能力是相对比较弱的，不然 GPU 的能力就会有大量浪费。&lt;/p&gt;&lt;p data-block-key=&quot;f04vj&quot;&gt;剩下的数据类型包括车辆上报的一些用于分析的日志，埋点数据，还有一些国家平台需要的车辆相关的信号数据，这些数据都会进到数仓里面去做一些分析。也会对这些数据做一些特征数据提取，给算法团队去做模型训练，或者做一些 NLP 的检索和其他的更多场景。&lt;/p&gt;&lt;h4 data-block-key=&quot;46eou&quot;&gt;&lt;b&gt;新场景：云原生存储加速 - Lustre 作为读缓存 （测试中）&lt;/b&gt;&lt;/h4&gt;&lt;img alt=&quot;10&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/10.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;eq0o2&quot;&gt;现在我们正在测的是另外一个场景是在对象存储层挂一个 Lustre 去给 JuiceFS 去做读缓存，通过 Lustre 的缓存来帮助 JuiceFS 来提高读取速度和缓存命中率。&lt;/p&gt;&lt;p data-block-key=&quot;a6102&quot;&gt;这样可以有一个好处是我们现在用的都是物理机，它是有物理盘的，物理盘可以用来缓存数据。但是因为计算任务在多个节点执行，缓存的命中率不太高。这是因为社区版 JuiceFS 目前还不支持 P2P 的分布式缓存，只支持单节点的本地缓存，每一个节点可能会读很多数据。这种情况下也给计算节点造成了一些磁盘的压力，因为缓存会占用一定的磁盘空间。&lt;/p&gt;&lt;p data-block-key=&quot;d8njt&quot;&gt;目前我们的方案是通过 Lustre 来作为 JuiceFS 的读缓存。具体来说是根据需要缓存的数据大小，将一个容量大概是 20~30TB 的 Lustre 文件系统挂载到计算节点本地，然后将这个 Lustre 挂载点作为 JuiceFS 的缓存目录。这种情况下 JuiceFS 读完数据之后，可以异步缓存到 Lustre 里。这个方案可以有效解决缓存命中率不高的问题，大幅度提高读取性能。&lt;/p&gt;&lt;p data-block-key=&quot;67ijs&quot;&gt;如果我们在 Spark 场景往对象存储里直接写数据的时候，会有带宽和 QPS 的限制，如果写入得太慢，上游的任务可能会发生抖动，在这种情况下可以通过 JuiceFS 的写缓存功能把数据先写到 Lustre 里，再异步写到对象存储，这个方案在某些场景下是适用的。但是有一个问题是 Lustre 并不是一个云原生的方案，它对于用户来说是有感知的，用户在启动 pod 的时候需要显式写一个命令把它挂载上去。因此后面我们也希望对 JuiceFS 做一些改造，自动去识别对象存储和 Lustre，然后自动实现一些缓存的机制，这样就不需要用户来感知 Lustre 的存在。&lt;/p&gt;&lt;p data-block-key=&quot;fat64&quot;&gt;目前这个方案的 PoC 已经完成，通过了基础测试，接下来我们会在生产环境做大量的压测，预计今年 Q3 应该可以正式上线覆盖一些边缘业务。&lt;/p&gt;&lt;h3 data-block-key=&quot;avvsj&quot;&gt;&lt;b&gt;JuiceFS 在大数据云原生的整体方案&lt;/b&gt;&lt;/h3&gt;&lt;img alt=&quot;11&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/11_CRgHx1B.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;fg4al&quot;/&gt;&lt;p data-block-key=&quot;u0v3&quot;&gt;从整体方案的架构图可以看到，目前 JuiceFS 客户端提供的三种方式我们都有用到。&lt;/p&gt;&lt;p data-block-key=&quot;56c8p&quot;&gt;如上图左半部分所示，我们会有独立的 Spark、Flink 集群，我们通过 CSI Driver 的方式将 JuiceFS 直接挂载到整个集群上，这样用户启动 Spark 和 Flink 的时候，就完全感知不到 JuiceFS 到存在了，计算任务的读写都是通过对象存储来完成。&lt;/p&gt;&lt;p data-block-key=&quot;fcduo&quot;&gt;这部分目前有一个有关 shuffle 的问题。因为 Spark 任务在计算过程中的 shuffle 阶段需要大量的数据落盘，这其间产生的大量文件读写请求对于底层存储的性能要求较高。Flink 相对来说好一些，因为它是流式的，不需要大量的落盘。未来我们希望 JuiceFS 可以直接写到 Lustre 里，但是这样就需要在 JuiceFS 里做一些改造，通过客户端集成的方式，让 JuiceFS 直接读写 Lustre，这对于用户来说就无感知了，也能提升 shuffle 阶段的读写性能。&lt;/p&gt;&lt;p data-block-key=&quot;boc32&quot;&gt;上图右半部分的应用有两个场景。&lt;/p&gt;&lt;p data-block-key=&quot;6loqa&quot;&gt;&lt;b&gt;一个是简单查询一下 JuiceFS 的数据&lt;/b&gt;，例如通过 HiveJDBC 来进行数据预览，这个场景可以通过 S3 网关访问 JuiceFS。&lt;/p&gt;&lt;p data-block-key=&quot;d1nme&quot;&gt;&lt;b&gt;第二个是大数据平台和 AI 平台联动的场景&lt;/b&gt;。比方说 AI 平台的同事在日常工作中需要经常读取样本数据、特征数据等，而这些数据通常是由大数据平台上的 Spark 或者 Flink 任务产生的，并且已经存储到了 JuiceFS 里。为了不同的平台之间能够共享数据，在 AI 平台的 pod 启动时，会通过 FUSE 的方式将 JuiceFS 直接挂载到 pod 里，这样 AI 平台的同事就可以通过 Jupyter 直接访问 JuiceFS 里的数据做一些模型的训练，而不用像传统的架构那样在不同平台之间重复拷贝数据，提高了跨团队的协作效率。&lt;/p&gt;&lt;p data-block-key=&quot;7pec1&quot;&gt;因为 JuiceFS 使用 POSIX 标准的用户、用户组进行权限控制，同时容器启动默认是 root 用户，导致权限不好管控。因此我们对 JuiceFS 做了一个改造，通过一个认证 token 来挂载文件系统，这个 token 里面包含元数据引擎的连接信息和其他一些权限控制信息。在某些需要同时访问多个 JuiceFS 文件系统的场景，我们使用 JuiceFS S3 网关并结合 IAM 策略做统一的权限管理。&lt;/p&gt;&lt;h3 data-block-key=&quot;c161e&quot;&gt;&lt;b&gt;目前使用 JuiceFS 遇到的一些难题&lt;/b&gt;&lt;/h3&gt;&lt;p data-block-key=&quot;egm9i&quot;&gt;第一点，基于用户和用户组的权限管理功能比较简单，在某些场景容器启动默认为 root 用户，权限不好管控。&lt;/p&gt;&lt;p data-block-key=&quot;2e7on&quot;&gt;第二点，关于 JuiceFS Hadoop SDK 的配置优化。目前我们对 JuiceFS Hadoop SDK 进行优化的手段主要有三个配置：&lt;code&gt;juicefs.prefetch&lt;/code&gt;、&lt;code&gt;juicefs.max-uploads&lt;/code&gt; 和 &lt;code&gt;juicefs.memory-size&lt;/code&gt;。其中在调优 &lt;code&gt;juicefs.memory-size&lt;/code&gt; 配置的过程中遇到了一些问题，这个配置的默认值是 300MB，官方的建议是 设置默认值 4 倍大小的堆外内存，也就是 1.2GB。目前我们大部分任务都是配置到 2GB 的堆外内存，但是有些任务即使配置了超过 2GB 的内存也偶尔会写入失败（HDFS 可以稳定写入）。不过这个并不一定是 JuiceFS 的问题，也有可能是 Spark 或者对象存储的原因导致。因此目前我们也在计划把 Spark 和 JuiceFS 深度适配以后，再一步一步来找原因，争取把这些坑都趟过去，在保证任务稳定的情况下把内存降下来。&lt;/p&gt;&lt;p data-block-key=&quot;8t0ev&quot;&gt;第三点，由于整体架构（JuiceFS + 对象存储 + Lustre）变得复杂，可能的故障点变多，任务的稳定性可能会有一些下降，需要其它容错机制保障。例如 Spark 任务在 shuffle write 阶段可能会有类似「lost task」这样的报错，目前还没有定位到具体的错误原因。&lt;/p&gt;&lt;p data-block-key=&quot;5idep&quot;&gt;前面提到的 JuiceFS + 对象存储 + Lustre 的架构组合一定程度上提升了读写性能，但同时也使得架构更加复杂，相应地增加了一些可能的故障点。比如说 Lustre 没有很强的容灾副本能力，如果 Lustre 突然挂了一个节点，正在运行的任务到底能不能稳定地继续读写 Lustre 里面的数据，或者 Lustre 里的数据意外丢失了，是否还能稳定的去 JuiceFS 里通过对象存储重新拉出来，这个目前是不确定的，目前我们在也在做这种灾难性的测试。&lt;/p&gt;&lt;h2 data-block-key=&quot;diacr&quot;&gt;&lt;b&gt;未来和展望&lt;/b&gt;&lt;/h2&gt;&lt;h3 data-block-key=&quot;2071m&quot;&gt;&lt;b&gt;基于 Flink + Hudi + JuiceFS 的实时数据湖方案&lt;/b&gt;&lt;/h3&gt;&lt;img alt=&quot;12&quot; class=&quot;richtext-image full-width&quot; src=&quot;https://juicedata-cms.oss-cn-hongkong.aliyuncs.com/images/12_BiQDBES.width-800.png&quot;/&gt;&lt;p data-block-key=&quot;33avn&quot;/&gt;&lt;p data-block-key=&quot;br8ab&quot;/&gt;&lt;p data-block-key=&quot;3o7ab&quot;&gt;近期我们要做的一个是 Flink+ Hudi + JuiceFS 的实时数据湖方案。上图中左边是数据源，通过 Flink 、Kafka/Pulsar，把数据实时地写到 Hudi 里，同时 Hudi 的数据会落到 JuiceFS 里替换我们目前的实时数仓。&lt;/p&gt;&lt;h3 data-block-key=&quot;9k9kh&quot;&gt;&lt;b&gt;大数据云原生的远期规划&lt;/b&gt;&lt;/h3&gt;&lt;p data-block-key=&quot;dbb0c&quot;&gt;最后，介绍一下理想汽车大数据云原生的远期规划，也是一个展望。第一点是&lt;b&gt;统一的数据管理和治理系统。我们认为数据湖 2.0 时代，最大的需要解决的问题就是把数据湖 1.0 场景中的数据沼泽的问题解决掉。&lt;/b&gt;但现在好像并没有一个比较好的统一元数据管理、数据目录管理、数据安全管控的开源产品，类似 AWS Glue、AWS Lake Formation。目前我们在做一个「起源系统」的项目，这个系统第一步就是把上面的数据库、对象存储里边所有的元数据做统一的目录管理，统一的安全管控，以及统一的数据管理，这块儿我们正摸索着往前走。&lt;/p&gt;&lt;p data-block-key=&quot;8dueg&quot;&gt;第二点是&lt;b&gt;更快、更稳定、更低成本的底层存储能力&lt;/b&gt;。目前所有的场景最大的难点是在对象存储上，对象存储的优势是稳定、低成本，同时对象存储也在持续迭代。就目前而言我觉得如果大数据云原生要发展，对象存储必须是要在确保稳定的前提下提供更好的性能。&lt;/p&gt;&lt;p data-block-key=&quot;e1bi5&quot;&gt;同时 S3 可能宣称支持强一致性了，但是目前我理解基于对象存储的架构设计，可能很难能实现强一致性，或者说它为了实现强一致性，势必要牺牲一些东西，这可能是一个需要权衡的问题。JuiceFS 原生支持强一致性，这个功能对于大数据平台来说非常友好。&lt;/p&gt;&lt;p data-block-key=&quot;82ogs&quot;&gt;第三点，&lt;b&gt;更智能、更高效、更易用的查询引擎。&lt;/b&gt;引申一下前面提到的对湖仓一体的思考，目前湖仓一体还是在发展初期 ，可能还需要经历 5~10 年的发展过程。Databricks、微软都在尝试做数据湖上的向量化 MPP 引擎，希望能把湖仓一体架构推起来。这可能是一个未来的发展方向，但是短时间内好像并没有办法用一个引擎来满足所有场景的需求。&lt;/p&gt;&lt;p data-block-key=&quot;d3rif&quot;&gt;我们目前的架构基本上是配备了所有的查询引擎，比如 Spark、Flink、关系型数据库（面向 OLTP 的场景）、时序数据库、OLAP 数据库。原则上还是谁优用谁，我们上层再通过统一的中间件去做管理。再比如 Snowflake，它现在虽然已经支持了同时查询结构化和半结构化的数据，但是未来像人工智能涉及的的非结构化数据（如图片、语音、视频）到底应该怎么支持，目前还是不太清楚。不过我认为这肯定是以后的一个发展方向，理想汽车也有类似的人工智能场景，所以我们会与各个业务方一起去探索和共建。&lt;/p&gt;&lt;p data-block-key=&quot;ct7lv&quot;&gt;最后，整个大数据发展的最终目标还是要以最低的成本、最高的性能完成数据分析，从而实现真正的商业价值。&lt;/p&gt;
                        
                    
                    &lt;/div&gt;
                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e88bc96ce26b987bc34f87c5eb23c3d5</guid>
<title>分页 + 模糊查询  有坑！</title>
<link>https://toutiao.io/k/i7yprz3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有使用过&lt;code&gt;Mysql&lt;/code&gt;的&lt;code&gt;like&lt;/code&gt;语句，进行&lt;code&gt;模糊&lt;/code&gt;查询？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有将查询结果，进行&lt;code&gt;分页&lt;/code&gt;处理？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模糊查询，加上分页处理，会有意想不到的坑，不信我们继续往下看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前提供过一个品牌查询接口，给前端品牌选择控件使用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时为了性能考虑，怕前端控件因为一次性加载太多的品牌，而导致页面卡死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，对品牌查询接口做了&lt;code&gt;分页&lt;/code&gt;处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始品牌表的数据比较少，没有出现什么问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，产品加需求了，在品牌下拉选择控件中，让用户可以输入自定义品牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户添加品牌前，需要先查一下，如果该品牌存在，则使用已有品牌。如果不存在，则新增品牌。（这里是精确匹配）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求很简单，很容易实现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，产品又加需求了，需要按名称&lt;code&gt;模糊查询&lt;/code&gt;品牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该功能上线后，使用了很长一段时间，也没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然，在不经意的某一天，这个功能却出问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到底怎么回事呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.案发现场&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某一天下午，运营找到测试反馈一个问题说：明明品牌苏三，已经存在了，但用户输入关键字：&lt;code&gt;苏三&lt;/code&gt;时，系统没有让用户直接选择已有品牌，而是添加了一个叫：苏三的自定义的品牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我过去一看，还真的有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不一会儿，就定位到原因了，初步判断是分页的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搜索关键字：苏三，竟然出现了好几页的数据，把我惊呆了，品牌表怎么多了这么多数据了。&lt;/p&gt;&lt;p&gt;我查了数据库，其实数据量并不是特别多，但有些品牌名称比较特殊，有些品牌名称是多个品牌名称拼接而成的，比如：苏三,李四 或者 苏三,李四,王五，这是一个品牌。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实是品牌名称建的不规范导致的问题，但已经没法让运营修改品牌了，只能通过技术手段解决目前的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询第一页的数据sql：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; edit_date &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.284037558685446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERn36teyP0gI6ejhibCnic2Tm76qR05OTnR4Whyh9udE5AGypTCxQays3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;我们可以看到，图中并没有等于&lt;code&gt;苏三&lt;/code&gt;这两个字的数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：为了好演示，这里给的每页大小是5，真实的场景并非如此。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询第二页的数据sql：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; edit_date &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3026634382566586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERd1dhcPO1Bx5icTOBcH5SoyldAXpouzzkGRxY5v7RqqSkhJ3oSkFUN0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;从图中看到，在第二行，出现了正好等于&lt;code&gt;苏三&lt;/code&gt;这两个字的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户搜索关键字：苏三 时，前端页面在调用品牌查询接口，&lt;code&gt;pageNo&lt;/code&gt;默认是&lt;code&gt;1&lt;/code&gt;。由于能够匹配关键字的数据太多了，第一页返回不完，需要多页才能全部返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端获取到第一页的数据后，跟关键字：苏三 做比较，发现没有等于苏三的品牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就会在下拉控件中，自动添加一个品牌：苏三，同时在右边增加&lt;code&gt;自定义标签&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就出问题了，明明苏三这个品牌是有的，但用户还能自定义一个苏三，而不是直接选择。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.思考123&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;苏三&lt;/code&gt;这个关键字，通过模糊查询可以查询出来，但由于品牌接口做了分页，全匹配的品牌：苏三，出现在第二页了，才导致问题的产生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要解决这个问题，让它出现在第一页不就OK了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，就有下面几种解决方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 方案1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分页查询品牌接口，&lt;code&gt;pageSize&lt;/code&gt;是5。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们为什么不把pageSize调大一点？比如改成：200、500等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样通过&lt;code&gt;苏三&lt;/code&gt;关键字，进行模糊查询的时候，结果基本都在第一页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能非常快速的解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个缺点就是：如果这次调大了pageSize，但后面查询关键字的品牌又出现在第二页怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可能一直改pageSize吧？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.2 方案2&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把分页查询接口的数据，拆分成两部分：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;精确查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模糊查询&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码中做处理的时候，先根据关键字&lt;code&gt;精确查询&lt;/code&gt;，即sql中使用&lt;code&gt;name=&#x27;苏三&#x27;&lt;/code&gt;，这种方式查询一次数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没查出数据，则再直接用&lt;code&gt;like &#x27;%苏三&#x27;&lt;/code&gt;进行模糊查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查出了一条数据，则把它放在返回结果集合中的第一位置。接下来，使用&lt;code&gt;like &#x27;%苏三&#x27;&lt;/code&gt;进行模糊查询的时候，再加上条件 &lt;code&gt;name &amp;lt;&amp;gt; &#x27;苏三&#x27;&lt;/code&gt;。将查出的结果，从第二个位置往后放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以拼接出你想要的集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有个缺点，就是代码耦合性太大了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.3 方案3&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前，品牌苏三在第二页，最根本的原因是使用了&lt;code&gt;edit_time&lt;/code&gt;字段进行&lt;code&gt;逆序&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，修改时间越大的越排在前面，而品牌苏三的修改时间很小，所以排在第二页了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想品牌苏三，排在第一页，修改一下排序规则，不就搞定了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以改成按：id或者name字段排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用id字段排序，不太合适，虽说用了雪花算法，但跟修改时间类似，先插入的数据，会越小。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用它排序的结果，跟使用修改时间排序差不了太多。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29086538461538464&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERmhnKaKGx8ApaaVOTOPoQDssrNo2yvfdvvr1Hdhb2h0QtJ4ibVbw2lDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;看来，只能使用name字段排序了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.如何排序？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在sql中直接对name字段，进行&lt;code&gt;升序&lt;/code&gt;或者&lt;code&gt;降序&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用name字段&lt;code&gt;降序&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;desc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3194103194103194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERVPQ5tOxgYmVNvUypwcFVPzTIHYrfgiaAzYHLrAHdUTXos9IOibroyS8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;图中并没有看到我们想要的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，使用name字段&lt;code&gt;升序&lt;/code&gt;，也可能在第一页查不出我们所想要的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到底该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如，我们有这样一种排序：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;全匹配显示在最前面，比如：苏三。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据左半部分匹配，右边按字母排序，比如：苏三1、苏三2、苏三说技术。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从中间开始匹配，比如：1苏三、2苏三。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第2步和第3步，还要根据字符长度排序，字符短的排在前面，比如：1苏三、1苏三1、苏三说技术。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们能实现上面的这种排序方式，这个问题就能完美解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起来容易，做起来难。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难道要先全匹配：&lt;code&gt;name=&#x27;苏三&#x27;&lt;/code&gt;，再有匹配：&lt;code&gt;name like &#x27;苏三%&#x27;&lt;/code&gt;，再左匹配：&lt;code&gt;name like &#x27;%苏三&#x27;&lt;/code&gt;，把查询三次的结果组装起来？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这种做法有点low。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现上面我们设想的排序方式，在&lt;code&gt;es&lt;/code&gt;中更好处理一下，但在&lt;code&gt;mysql&lt;/code&gt;中要怎么处理呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.解决方案&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们可以换一种思路，根据字符的&lt;code&gt;长度排序&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql给我们提供了很多非常有用的&lt;code&gt;函数&lt;/code&gt;，比如：&lt;code&gt;char_length&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过该函数就能获取字符长度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;char_length&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;name字段使用关键字模糊查询之后，再使用&lt;code&gt;char_length&lt;/code&gt;函数，获取name字段的字符长度，然后按长度&lt;code&gt;升序&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仅这一个骚操作，就搞定需求了：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2907801418439716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERMxWpLca0R2icErNIVSM93LSBF8dbILxgAybI7OV4k5YIjbniaYKUrl4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;我们所期待的：苏三，终于排在第一个了。同时由于该sql做了分页的，即使name字段在查询时丢失了索引，执行效率也不会太低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务上的需求搞定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但追求完美的我们，好奇，想看看第二页是什么情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;char_length&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3033175355450237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERiclyCmkdDfcItkCEQaq7xm9l5zwCQJEBToJGcsnMJNa5rH2qzsm7ia5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;并没有按照我们设想的剧本进行下去，我们之前假设的3条排序中，第2条和第3条都没有满足。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可以使用mysql中的&lt;code&gt;locate&lt;/code&gt;函数，通过它可以匹配的关键字，在字符串中的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;locate&lt;/code&gt;函数改造之后sql如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; brand &lt;span&gt;where&lt;/span&gt; &lt;span&gt;name&lt;/span&gt; &lt;span&gt;like&lt;/span&gt; &lt;span&gt;&#x27;%苏三%&#x27;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;char_length&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt;, &lt;span&gt;locate&lt;/span&gt;(&lt;span&gt;&#x27;苏三&#x27;&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;) &lt;span&gt;asc&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2825112107623318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5h9BibA7ueucXd3PAicwtd6ERIb5DCUGogmgFmj1XWialvPicOKKGBYGkdQFu829Nz4qgHhNbLLOf2dFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;完美，终于出现我们想要的结果了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还可以使用：&lt;code&gt;instr&lt;/code&gt;和&lt;code&gt;position&lt;/code&gt;函数，它们的功能跟&lt;code&gt;locate&lt;/code&gt;函数类似，在这里我就不一一介绍了，感兴趣的小伙伴可以找我私聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，&lt;code&gt;模糊查询&lt;/code&gt;和&lt;code&gt;分页&lt;/code&gt;，如果分开用，一般是没问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果它们要一起使用，一定要考虑&lt;code&gt;排序&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是按照简单的时间或者id排序，有些特殊的业务场景，没办法满足，很容易出现bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然解决上面问题，还有其他办法，比如：pageSize调大一点，或者把全匹配放到第一页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但更优的方案，是通过mysql的函数来解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过mysql提供的：&lt;code&gt;char_length&lt;/code&gt;、&lt;code&gt;locate&lt;/code&gt;、&lt;code&gt;instr&lt;/code&gt;和&lt;code&gt;position&lt;/code&gt;函数等，来实现很多复杂的排序功能。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>89d77649d6c2d7e393ab39e41beab8ea</guid>
<title>Golang 模糊测试 简明教程</title>
<link>https://toutiao.io/k/fri7256</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;1.引言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Golang1.18 引入了一个模糊测试的功能。文本萌叔将会简单介绍下这个特性。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.模糊测试&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;传送门&lt;br/&gt;比如我们编写了一个工具包来做除法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; fuzz&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Div&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a / b&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于疏忽忽略了某些边界条件。显然在上面的代码中，b不能等于0，否则会发生运行时错误。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;普通的单元测试&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestDiv&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    testcases := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;        a, b, want &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    }{&lt;br/&gt;        {&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;-6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;-2&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;-6&lt;/span&gt;, &lt;span&gt;-3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, tc := &lt;span&gt;range&lt;/span&gt; testcases {&lt;br/&gt;        result := Div(tc.a, tc.b)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; Div(tc.a, tc.b) != tc.want {&lt;br/&gt;            t.Errorf(&lt;span&gt;&quot;Div: %q, want %q&quot;&lt;/span&gt;, result, tc.want)&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于对分支条件和异常情况考虑的不周全，自测的单元测试能够正常通过。但是一旦b=0，程序将会崩溃。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;模糊测试 fuzz test&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们可以编写一个模糊测试的用例&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FuzzXxx&lt;/span&gt;&lt;span&gt;(f *testing.F)&lt;/span&gt;&lt;/span&gt; { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3743119266055046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQgVoDxrsD2C1uQzRPS3vzRdu4ianv6HY7k5Zib5yLORLL8SOicU07pbrQv4eQucPRyU5fUR3oBQUFfcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FuzzDiv&lt;/span&gt;&lt;span&gt;(f *testing.F)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    testcases := []&lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;        a, b &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;    }{&lt;br/&gt;        {&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;-6&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;},&lt;br/&gt;        {&lt;span&gt;-6&lt;/span&gt;, &lt;span&gt;-3&lt;/span&gt;},&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; _, tc := &lt;span&gt;range&lt;/span&gt; testcases {&lt;br/&gt;        &lt;span&gt;/*&lt;br/&gt;         测试组件根据我们提供的参数，反射获得参数类型&lt;br/&gt;         并试图穷举可能的取值&lt;br/&gt;        */&lt;/span&gt;&lt;br/&gt;        f.Add(tc.a, tc.b) &lt;span&gt;// Use f.Add to provide a seed corpus&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    f.Fuzz(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(t *testing.T, a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        q := Div(a, b)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; q != a/b {&lt;br/&gt;            t.Errorf(&lt;span&gt;&quot;Before: %q, after: %q&quot;&lt;/span&gt;, q, a/b)&lt;br/&gt;        }&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行模糊测试&lt;/p&gt;&lt;pre&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -fuzz=Fuzz&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行的过程中，会在当前目录下生成一个testdata目录&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(&lt;span&gt;py3_env&lt;/span&gt;) &lt;span&gt;fuzz&lt;/span&gt; &lt;span&gt;[master●●●]&lt;/span&gt; % &lt;span&gt;tree&lt;/span&gt; .&lt;br/&gt;.&lt;br/&gt;├── &lt;span&gt;fuzz&lt;/span&gt;&lt;span&gt;.go&lt;/span&gt;&lt;br/&gt;├── &lt;span&gt;fuzz_test&lt;/span&gt;&lt;span&gt;.go&lt;/span&gt;&lt;br/&gt;└── &lt;span&gt;testdata&lt;/span&gt;&lt;br/&gt;    └── &lt;span&gt;fuzz&lt;/span&gt;&lt;br/&gt;        └── &lt;span&gt;FuzzDiv&lt;/span&gt;&lt;br/&gt;            └── 378303&lt;span&gt;d09d9499e4e6c708a92079f30db6f554529fd9eb86ac9a9639481fb23d&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9264214046822743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQgVoDxrsD2C1uQzRPS3vzRdNNX4bhUMjIfTX2PbpDJM3yicEPAqoWu1gYTD3GfKcQC5QnHgBnPGBkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;897&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;上图标红的位置，提示我们是哪条测试用例没有通过&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(py3_env) fuzz [master●●●] % cat testdata/fuzz/FuzzDiv/&lt;span&gt;378303d&lt;/span&gt;09d9499e4e6c708a92079f30db6f554529fd9eb86ac9a9639481fb23d&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; test fuzz v1&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;-6&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行Div(-6, 0)时，出现了panic&lt;/p&gt;&lt;p&gt;还可以使用-fuzztime来控制模糊测试最大执行时间&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; test -fuzz=Fuzz -fuzztime &lt;span&gt;30s&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3. 参考资料&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;1.Tutorial: Getting started with fuzzing&lt;/p&gt;&lt;hr/&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.396078431372549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQgVoDxrsD2C1uQzRPS3vzRdqJtWIMpV3Nek1bRKtRrnUMLzHLpTSyiclpfmicSmfGoMQvbJJkmTK7gg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1020&quot; title=&quot;微信公众号&quot;/&gt;&lt;figcaption&gt;微信公众号&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>18b5bee8716bfc4c94226a9b920091a2</guid>
<title>Erda 开源的迷失和反思</title>
<link>https://toutiao.io/k/b9zngnl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Erda 是我从2018年初加入上家公司直到今年初离开的四年时间里一直在做的一个云原生 PaaS 平台。在开源之前，Erda 在公司内部的名字代号是 D ，在21年初改名为现在的 Erda 进行开源，并且在国内的云原生领域产生一定的影响。但可惜的是，在近期听说前公司因为&lt;span&gt;一些不可知的原因&lt;/span&gt;决定停止 Erda 的新特性开发并且毕业了一些之前的同事。在这篇文章里我将从个人的视角来聊聊 Erda 开源的一些故事。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Erda 为什么要开源？&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;在去年之前，Erda 只是公司的一个内部 PaaS 平台，Erda 平台负责支撑公司业务团队的日常研发，和跟着业务项目一起打包售卖给客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但随着公司的业务转型（想从做交付转型到做ToB产品）和融资的需求，从老板的视角，Erda 的定位不能仅仅是作为内部支撑系统，Erda 和 Erda 部门被要求去承担公司的几个产品线（ Erda、Trantor、Gaia）中第一个去做商业化的尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我觉得公司老板对开源的想法大概至少从19年就开始了，因为我19年晋升评审时老板就问了对我开源的看法相关的问题 。我猜测有几个原因&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后21年初一次部门负责人 Y 给老板的工作汇报会议上，这个会议上 Y 做的产品方案被否决了，并且老板直接提出了 Erda 开源和商业化的问题，然后就这样拍板了开源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个时候老板对 Erda 开源的支持力度还是很大的，给 Y 充足的权限招聘、也可以 Erda 自己有销售和运营。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在公司层面，营销部门的几个实习生也开始维护 Tech 公众号，在公司里有偿投稿（不过这个稿费最后意料之中的被鸽了）。扯远了。。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到故事的主题，在21年3月份 Erda 开始了轰轰烈烈的开源大业。。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Erda 对开源的定位是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我觉得在开始做开源的时候，Y 和老板都没有想清楚开源的定位是什么。可能最开始的想法就比较简单，通过开源吸引开发者和提高公司在国内 ToB 和云原生领域的知名度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时开启的还有 erda.cloud 云平台，在21年初的 OKR 目标上，制定了产品力提升、开源项目 Star 和 Cloud 用户数几个目标。&lt;/span&gt;&lt;span&gt;Y 在这个时候说的是，他会顶住老板压力，前期先不做营收只做用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个阶段的开源就是公司打的一个招牌，通过开源和运营去吸引人才，吸引开发者和潜在的用户，还有一个目的我想应该是，Erda 开源顺便也响应了国家的十四五计划，通过 Erda 拉了一波公司的估值，让公司在去年顺利拿到两轮10亿的融资。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了21年下半年，我觉得公司层面老板开始对 Erda 开源有了一些态度的转变，很明显的一个信号是公司内部其他部门对 Erda 的吐槽让老板觉得 Erda 产品能力不足，开始缩减 Erda 开源运营的经费和活动限制。&lt;/span&gt;&lt;span&gt;但是开源的牌坊已经立出去了，Y 只能让 Erda在开源上继续往前走，但这个阶段整体上对开源的投入逐渐减少，而且开始急功近利去想收割前期积累的一些有使用意向的开源社区开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一个转变是运营开始从影响力和社区运营开始转向ToB侧，对开源开始有一种让其自生自灭的态度，过度透支了开源的活力。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Erda 开源社区和运营上做过的一些尝试和反思&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;这一段我从时间线上来说，Erda 确定开源后做的一些工作&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Erda 全部代码从内部搬到 github 上面，为了开源做了一些重构和提高代码质量的措施&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参加业界大会，GopherChina、gdevops、ArchSummit 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参加了3~4次线下 meetup&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;组建运营团队，运营公众号、外部技术网站、知乎、直播等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营微信社群&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;不能否认的，这些工作对 Erda 在业界的知名度是起到了很大的正面作用。&lt;/span&gt;&lt;span&gt;但也不得不说，Erda 的开源到目前为止，还是没有起到太多的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从我的经验上看，这些活动都没有问题，也是必须要做的。相反我觉得开源没有达到预期的原因应该归结到公司态度的摇摆和团队负责人Y 对开源的认知和坚持都不够。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先说一下坚持的问题，公司高层对开源的投入产出产生质疑的时候，Y 没有能继续拿出可以说服高层的故事/说法，导致了让整个团队也产生对开源的投入质疑。但毕竟大家都是出来打工的，说服不了老板虽然很可惜，但也不是不能理解的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后说一下认知的问题。我的印象里，Y 对开源的看法一直是作为商业化的辅助，这个思路要说也不是什么问题，但问题是开源本身就是一个需要长期投入和吸引人来互动的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们不说其他人的问题，来说一下我对开源的理解。&lt;/span&gt;&lt;span&gt;开源本身确实不是公司来做只投入不考虑收益的慈善事业，不管是作为商业补充还是长期战略都没有问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但开源的核心是社区，而社区的核心是社交和互动。每一个成功的开源项目必然不是开发者或者厂商的独角戏，都需要核心开发者、贡献者、使用者一起来组成社区和维持社区的热度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从开源项目的生命周期来看，冷启动时期可能只有关注者，和一部分的尝鲜者。&lt;/span&gt;&lt;span&gt;这个阶段如果开源项目的核心成员有社区影响力，可以通过个人影响力来带动项目快速渡过。&lt;/span&gt;&lt;span&gt;这个阶段的运营动作需要持续不断的在社区和外界去曝光开源项目，Erda 之前做的大部分也是这个事情，在这个阶段我认为是没什么问题的。&lt;/span&gt;&lt;span&gt;通过持续曝光来吸引更多的开发者到自己的社区中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下一个阶段在开源项目产生一定的热度后，会有部分关注者开始转化为使用者，这个阶段开源运营需要对这些使用者提供足够好的支持，支持包括，使用文档的完善程度，issue 的响应速度，和在社群里的问题解答。&lt;/span&gt;&lt;span&gt;目前 Erda 就处在这个阶段的初期。&lt;/span&gt;&lt;span&gt;这个阶段对公司来说，是一个投入产出比很差的时间段，是要坚持投入人力和精力开始去积攒初始的深度用户。&lt;/span&gt;&lt;span&gt;在项目的初期，尝鲜使用者会相对看重项目团队对用户的支持程度。&lt;/span&gt;&lt;span&gt;运营在这个阶段要做的是更多和使用者进行交互，从使用者中挖掘使用场景(可以输出真实用户案例 or 标杆)和开始建立用户墙。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个阶段是从使用者之中转化贡献者，在上个阶段产生的深度用户中，很大概率他们会遇到开源项目不满足需求的场景，这个时候开源项目运营团队需要开始完善项目的开发设计文档，和贡献指南。&lt;/span&gt;&lt;span&gt;另一个很重要的事情是要开始考虑建设开源项目的社区管理架构（Contributor -&amp;gt; Committer / Reviewer  -&amp;gt; Maintainer/PMC ），能够让外部贡献者也能够有途径开始参与和管理开源项目。&lt;/span&gt;&lt;span&gt;对开源项目的团队，这个时候要转换心态，能够放出一部分权限给社区参与者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据我的经验，社区的贡献者之间是可以产生裂变的，一些核心的贡献者也会不遗余力去帮我们宣传推广项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，贡献者不一定是写代码，参与社区交流、写文档、和布道的都可以是贡献者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再下一个阶段，随着贡献者增多，我们可以开放小部分的 Maintainer/PMC 权限给社区（但公司可以保留过半的投票权来保证对项目的掌控，这个是没问题的），这个时候开源项目开始进入社区自治的阶段。&lt;/span&gt;&lt;span&gt;很多大型的 feature 可以让社区参与者来主导和完成开发。&lt;/span&gt;&lt;span&gt;如果在这个阶段，我们可以认为开源项目已经具备了足够的活力/影响力，我们可以借助社区的力量来让项目走得更快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那运营可以在每个阶段能够去做什么事情呢？&lt;/span&gt;&lt;span&gt;这里我认为核心就是两个事情，一个是维持开发者关系，让开发者持续&lt;/span&gt;&lt;span&gt;对开源项目产生兴趣（吸引更多的开发者、留住社区的开发者），第二个是关注每个阶段不同身份参与者的转化率。&lt;/span&gt;&lt;span&gt;但具体的做法我还没有很成熟的建议，这个也不是运营同学自己的事情，可以再思考一下。&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bda02bb267b0e9d1d960082845d62796</guid>
<title>没有几十年功力，写不出这一行“看似无用”的代码！！</title>
<link>https://toutiao.io/k/ce2ftdl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;这篇文章要从一个奇怪的注释说起，就是下面这张图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23605150214592274&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsssHtX7DPF7sFo6FVYWV7lg1SzC6ic0MretuyfkKhPb8SNX9oAkc2cYw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;699&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以不用管具体的代码逻辑，只是单单看这个 for 循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在循环里面，专门有个变量 j，来记录当前循环次数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次循环以及往后每 1000 次循环之后，进入一个 if 逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个 if 逻辑之上，标注了一个注释：prevent gc.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;prevent，这个单词如果不认识的同学记一下，考试肯定要考的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5525773195876289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPseEtMqZNuXB8eytdnO6a0sR6PmEMwoMgkzc1jYoiapVLfr33O921BicRQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;485&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个注释翻译一下就是：防止 GC 线程进行垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的实现逻辑是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5112994350282486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsp5Z9mZps5RAJiaFsPDm8vVjz6nbXYZib0BYzq35uydWD6t3U4A9C6lww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心逻辑其实就是这样一行代码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Thread.sleep(0);&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能实现 prevent gc 了？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5223880597014925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsF1xtExvf4VHTX6xAEyEqPEdWuqNmG1qopXYRhm7eBHMpIXW7sY2u6g/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;134&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懵逼吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懵逼就对了，懵逼就说明值得把玩把玩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码片段，其实是出自 RocketMQ 的源码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;org.apache.rocketmq.store.logfile.DefaultMappedFile#warmMappedFile&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8701986754966887&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsZnRpM9icMIf7y9urjPUW9WtBdZprsnvbFTwqCeusECz5moC4CNVicu5A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;755&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事先需要说明的是，我并没有找到写这个代码的人问他的意图是什么，所以我只有基于自己的理解去推测他的意图。如果推测的不对，还请多多指教。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这是 RocketMQ 的源码，但是基于我的理解，这个小技巧和 RocketMQ 框架没有任何关系，完全可以脱离于框架存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我给出的修改意见是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsSj2ctY3D6wjKhous6uyGNTOicGmeAcssY7R63NljoHg7dJBIcImJIdg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 int 修改为 long，然后就可以直接把 for 循环里面的 if 逻辑删除掉了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8181818181818182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsR6DickwibTYsYATia3icx4fZiacDeoibDrN3pKxdyXgqeHAYQvg8lsrCEyPQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;66&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一看是不是更加懵逼了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要慌，接下来，我给你抽丝剥个茧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在“剥茧”之前，我先说一下结论：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提出这个修改方案的理论立足点是 Java 的安全点相关的知识，也就是 safepoint。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官方最后没有采纳这个修改方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官方采没采纳不重要，重要的是我高低得给你“剥个茧”。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6906377204884667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsNS1LqnGUphAbvmVRpj3ySkE0tvsOZu6vZgWrJRGoWNLSKFtgHTbiaOA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;737&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;探索&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我知道这个代码片段是属于 RocketMQ 的时候，我想到的第一个点就是从代码提交记录中寻找答案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看提交者是否在提交代码的时候说明了自己的意图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我把代码拉了下来，一看提交记录是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.524074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPs8ibv6NCtQfCxb0kbkaHZZMtxB5elsjCMmkX8xGmbr5RIEWuS2CoFUGw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我就知道这里不会有答案了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个类第一次提交的时候就已经包含了这个逻辑，而且对应这次提交的代码也非常多，并没有特别说明对应的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从提交记录上没有获得什么有用的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我把目光转向了 github 的 issue，拿着关键词 prevent gc 搜索了一番。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了第一个链接之外，没有找到什么有用的信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43425925925925923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsLdul2wxZg4VqusCoyJUTicIiauPf87VHSAzibrvfbgMAYWgNs8H5UBHMg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而第一个链接对应的 issues 是这个：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/apache/rocketmq/issues/4902&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 issues 其实就是我们在讨论这个问题的过程中提出来的，也就是前面出现的修改方案：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9608355091383811&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsw4Ym237KwoC8jb9Y7Ur1DtI7eiaZbngIj30bEujhWgbrqp5gYZY7ciaQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;383&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，我想通过源码或者 github 找到这个问题权威的回答，是找不到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我又去了这个神奇的网站，在里面找到了这个 2018 年提出的问题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://stackoverflow.com/questions/53284031/why-thread-sleep0-can-prevent-gc-in-rocketmq&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2972222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsyKoecnxIOEZMNF1u39BOiao3ezc3ezkVEAmFWViauUs0G1ryIlyGiajicg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题和我们的问题一模一样，但是这个问题下面就这一个回答：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5694444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsLhia3LVfBYDhhriasia0lE8scP4Vuez1ialhZYFAdaZOZvb1wicb93F2Kcg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个回答并不好，因为我觉得没答到点上，但是没关系，我刚好可以把这个回答作为抓手，把差的这一点拉通对齐一下，给它赋能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看这个回答的第一句话：It does not（它没有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题就来了：“它”是谁？“没有”什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“它”，指的就是我们前面出现的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“没有”，是说没有防止 GC 线程进行垃圾回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个的回答说：通过调用 Thread.sleep(0) 的目的是为了让 GC 线程有机会被操作系统选中，从而进行垃圾清理的工作。它的副作用是，可能会更频繁地运行 GC，毕竟你每 1000 次迭代就有一次运行 GC 的机会，但是好处是可以防止长时间的垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，这个代码是想要“触发”GC，而不是“避免”GC，或者说是“避免”时间很长的 GC。从这个角度来说，程序里面的注释其实是在撒谎或者没写完整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是 prevent gc，而是对 gc 采取了“打散运行，削峰填谷”的思想，从而 prevent long time gc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是你想想，我们自己编程的时候，正常情况下从来也没冒出过“这个地方应该触发一下 GC”这样想法吧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们知道，Java 程序员来说，虚拟机有自己的 GC 机制，我们不需要像写 C 或者 C++ 那样得自己管理内存，只要关注于业务代码即可，并没有特别注意 GC 机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么本文中最关键的一个问题就来了：&lt;strong&gt;为什么这里要在代码里面特别注意 GC，想要尝试“触发”GC 呢？&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.18562874251497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsLTOichkX0CUdWhTkJLz6PiaXpyWWB2bQsnrjWpbYuFrTvSLfl8YDHP5A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;167&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先说答案：safepoint，安全点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于安全点的描述，我们可以看看《深入理解 JVM 虚拟机(第三版)》的 3.4.2 小节：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4671890303623898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsp97RZpCpaoZcbqo6cmSqc8fP7TKBhEemxcicquBibnGBvZPJJeLwILhA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1021&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意书里面的描述：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换言之：没有到安全点，是不能 STW，从而进行 GC 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在你的认知里面 GC 线程是随时都可以运行的。那么就需要刷新一下认知了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，让我们把目光放到书的 5.2.8 小节：由安全点导致长时间停顿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面有这样一段话：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2819767441860465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsJPeXO8SUELfQJDt8YzCyicK7rzHXhIA7lub2XIdpvQlqNa9iaj4sIwZA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1032&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把划线的部分单独拿出来，你仔细读一遍：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;是 HotSpot 虚拟机为了避免安全点过多带来过重的负担，对循环还有一项优化措施，认为循环次数较少的话，执行时间应该也不会太长，所以使用 int 类型或范围更小的数据类型作为索引值的循环默认是不会被放置安全点的。这种循环被称为可数循环（Counted Loop），相对应地，使用 long 或者范围更大的数据类型作为索引值的循环就被称为不可数循环（Uncounted Loop），将会被放置安全点。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意思就是在可数循环（Counted Loop）的情况下，HotSpot 虚拟机搞了一个优化，就是等循环结束之后，线程才会进入安全点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反过来说就是：循环如果没有结束，线程不会进入安全点，GC 线程就得等着当前的线程循环结束，进入安全点，才能开始工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是可数循环（Counted Loop）？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;书里面的这个案例来自于这个链接：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://juejin.cn/post/6844903878765314061
HBase 实战：记一次 Safepoint 导致长时间 STW 的踩坑之旅&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有时间，我建议你把这个案例完整的看一下，我只截取问题解决的部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5018867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPs1oic5IZTTEzkx9N30oB7aw87sOflULuStyxcibPZQSKp2t5amnh11J5w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截图中的 while(i &amp;lt; end) 就是一个可数循环，由于执行这个循环的线程需要在循环结束后才进入 Safepoint，所以先进入 Safepoint 的线程需要等待它。从而影响到 GC 线程的运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，修改方案就是把 int 修改为 long。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理就是让其变为不可数循环（Uncounted Loop），从而不用等循环结束，在循环期间就能进入 Safepoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们再把目光拉回到这里：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5082417582417582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsOBoepdTVLlPuTwFfTonwnyfuC9QdgCrJ0EqmyzsPph1FIfE9HL6HGQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个循环也是一个可数循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread.sleep(0) 这个代码看起来莫名其妙，但是我是不是可以大胆的猜测一下：故意写这个代码的人，是不是为了在这里放置一个 Safepoint 呢，以达到避免 GC 线程长时间等待，从而加长 stop the world 的时间的目的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我接下来只需要找到 sleep 会进入 Safepoint 的证据，就能证明我的猜想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你猜怎么着？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来是想去看一下源码，结果啪的一下，在源码的注释里面，直接找到了：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/tip/src/share/vm/runtime/safepoint.cpp&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2703703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsCvghvvOU27Or0612aRy9lQHG740OhnyvMHsvw0vdAEZQjfucQjibFnw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注释里面说，在程序进入 Safepoint 的时候， Java 线程可能正处于框起来的五种不同的状态，针对不同的状态有不同的处理方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我想一个个的翻译的，但是信息量太大，我消化起来有点费劲儿，所以就不乱说了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要聚焦于和本文相关的第二点：Running in native code。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;When returning from the native code, a Java thread must check the safepoint _state to see if we must block.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一句话，就是答案，意思就是一个线程在运行 native 方法后，返回到 Java 线程后，必须进行一次 safepoint 的检测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我在知乎看到了 R 大的这个回答，里面有这样一句，也印证了这个点：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://www.zhihu.com/question/29268019/answer/43762165&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6685185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsjsdQdD1VQmYj881N6BHnJwtw739Hcj07Eu5f9qicVckpEqJrzrnxGCQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么接下来，就是见证奇迹的时刻了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21871713985278654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsXcVS6gvibrwOFe7vz4OJeiadywxOoZ6xUl8gWwgia1nib20NOdNHgCYPpw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 R 大的说法：正在执行 native 函数的线程看作“已经进入了 safepoint”，或者把这种情况叫做“在 safe-region 里”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sleep 方法就是一个 native 方法，你说巧不巧？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，到这里我们可以确定的是：调用 sleep 方法的线程会进入 Safepoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我还找到了一个 2013 年的 R 大关于类似问题讨论的帖子：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://hllvm-group.iteye.com/group/topic/38232?page=2&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2855759922555663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsVSMu8ZQiahQmErYmiaVRUJv4mVHN8Jva6ZiaQ4y26EmLCRxDhYCqHiaKpg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1033&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就直接点名道姓的指出了：Thread.sleep(0).&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这让我想起以前有个面试题问：Thread.sleep(0) 有什么用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时我就想：这题真难（S）啊（B）。现在发现原来是我道行不够，小丑竟是我自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还真的是有用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;实践&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面其实说的都是理论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一部分我们来拿代码实践跑上一把，就拿我之前分享过的《真是绝了！这段被 JVM 动了手脚的代码！》文章里面的案例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AtomicInteger num = &lt;span&gt;new&lt;/span&gt; AtomicInteger(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        Runnable runnable=()-&amp;gt;{&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000000000&lt;/span&gt;; i++) {&lt;br/&gt;                num.getAndAdd(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            System.out.println(Thread.currentThread().getName()+&lt;span&gt;&quot;执行结束!&quot;&lt;/span&gt;);&lt;br/&gt;        };&lt;br/&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(runnable);&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(runnable);&lt;br/&gt;        t1.start();&lt;br/&gt;        t2.start();&lt;br/&gt;        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;num = &quot;&lt;/span&gt; + num);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个代码，你直接粘到你的 IDEA 里面去就能跑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照代码来看，主线程休眠 1000ms 后就会输出结果，但是实际情况却是主线程一直在等待 t1,t2 执行结束才继续执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5498392282958199&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsQqRVvicic2f3IlHP8d44I9J9KI3Gxqic2163osnicIS1L20d788criazpOA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;311&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个循环就属于前面说的可数循环（Counted Loop）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个程序发生了什么事情呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.启动了两个长的、不间断的循环（内部没有安全点检查）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.主线程进入睡眠状态 1 秒钟。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.在 1000 ms 之后，JVM 尝试在 Safepoint 停止，以便 Java 线程进行定期清理，但是直到可数循环完成后才能执行此操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.主线程的 Thread.sleep 方法从 native 返回，发现安全点操作正在进行中，于是把自己挂起，直到操作结束。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当我们把 int 修改为 long 后，程序就表现正常了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0205696202531647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsPJtpg5KTEIacSSibelibibT8CQAuL1SicbolA5hgbfyI5ibkwyvlwZOVCAQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;632&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受到 RocketMQ 源码的启示，我们还可以直接把它的代码拿过来：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2696456086286594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsSuMhCGiaHVg6tYxv1pOb8kibuZoLTEKBWpgEoETX4AppNfqOoguNy3cA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;649&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，即使 for 循环的对象是 int 类型，也可以按照预期执行。因为我们相当于在循环体中插入了 Safepoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我通过&lt;strong&gt;不严谨的方式&lt;/strong&gt;测试了一下两个方案的耗时：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsNRwicAEbVLG9p6YibCyHU2LeTlo4YKhriaHB5TCgTmD0W0NwwvmkORmvg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的机器上运行了几次，时间上都差距不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是要论逼格的话，还得是右边的 prevent gc 的写法。没有二十年功力，写不出这一行“看似无用”的代码！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;额外提一句&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再说一个也是由前面的 RocketMQ 的源码引起的一个思考：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8224543080939948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsAiamY27lFbO7lXB0XDFY5jCQwib4H7iaZ8Hk3g1fw7OcsZky7jqic6jYHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;766&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法是在干啥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预热文件，按照 4K 的大小往 byteBuffer 放 0，对文件进行预热。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;byteBuffer.put(i, (byte) 0);&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么我会对这个 4k 的预热比较敏感呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去年的天池大赛有这样的一个赛道：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://tianchi.aliyun.com/competition/entrance/531922/information&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7129629629629629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsHDlfA9qmXTSqialUYZPFnibaWylticuY2WXJmIOUqtvJ6tXOH6SoVfh0Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有两个参赛选大佬都提到了“文件预热”的思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把链接放在下面了，有兴趣的可以去细读一下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://tianchi.aliyun.com/forum/postDetail?spm=5176.12586969.0.0.13714154spKjib&amp;amp;postId=300892&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2490740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsl3XE6b0XPdibsA7gYV3TaNYBAUqMOibCUribdW1ZOWRcKm0iaCINBYMbug/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsQriaIdfsjokKC6cQPtylXRlz0v7beaCzy1jC0WoDmrhOoX3Pe1BnxBg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://tianchi.aliyun.com/forum/postDetail?spm=5176.21852664.0.0.4c353a5a06PzVZ&amp;amp;postId=313716&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3675925925925927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ELQw2WCMgt0XR1d7OdySjSexwkxKyxPsIrauqbZPBEqibdNCmibXKWgc17u3iaK4gjRUaPUmNfaa6SvCmibM4iboBKg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本文的技术部分就到这里啦。&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651518974&amp;amp;idx=1&amp;amp;sn=38f3a7f53f81cdc02055b69023c17f55&amp;amp;chksm=bd259b818a5212973597341eca6bc2c70504551a6568ff07c0008db973801a81ad1bc6e5ff7b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;分布式系统中的时间&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;分布式系统中的时间&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651519102&amp;amp;idx=1&amp;amp;sn=b1fc420d394e32f1df2917ca41672c15&amp;amp;chksm=bd2594018a521d17782356c8c98a46bedb54cc1795aa87e3f4f2567f9bc4e215d3f6818ee00d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;用小白都能看懂的大白话告诉你：什么是分布式计算系统？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;用小白都能看懂的大白话告诉你：什么是分布式计算系统？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651517516&amp;amp;idx=1&amp;amp;sn=c9ff2e2c6c6e12917aa1aaa50d957c2e&amp;amp;chksm=bd259e338a52172567bca96bf9e4959e0aa4b314d07356b867eca9f33d37aabc336e82cfbd0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;记一次自定义 Redis 分布式锁导致的故障&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;记一次自定义 Redis 分布式锁导致的故障&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>