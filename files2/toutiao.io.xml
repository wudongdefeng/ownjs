<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>08b96984840ba01b293f6672f70643ae</guid>
<title>​打造企业自己代码规范 IDEA 插件（中）</title>
<link>https://toutiao.io/k/i8p0zo4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一些基本概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在开始独立研发公司自己的代码规范检查规则之前，先介绍一些相关的基本概念。&lt;/span&gt;&lt;span&gt;阿里巴巴代码规范&lt;/span&gt;&lt;span&gt;&lt;span&gt;很多规则其实都是基于开源框架&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;进行的研发。&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;用官方的话语介绍来说：&lt;/span&gt;&lt;span&gt;PMD&lt;/span&gt;&lt;span&gt;是一个源代码分析器。它可以发现常见的编程缺陷，如未使用的变量、空&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;块、不必要的对象创建等。它支持多种语言。它可以用自定义规则进行扩展。它使用&lt;/span&gt;&lt;span&gt;JavaCC&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;Antlr&lt;/span&gt;&lt;span&gt;将源文件解析为&lt;/span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;抽象语法树（&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;span&gt;），并对其运行规则以查找冲突。规则可以用&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt;&lt;span&gt;编写，也可以使用&lt;/span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;查询&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;。开源代码库：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;https://github.com/pmd/pmd&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里涉及到一个很关键的概念——&lt;span&gt;AST&lt;/span&gt;抽象语法树&lt;span&gt;(Abstract Syntax Tree)&lt;/span&gt;。&lt;span&gt;AST&lt;/span&gt;运用场景其实非常多，日常我们研发过程中错误提示、代码高亮、代码格式化、代码转译等等实现的基础都基于&lt;span&gt;AST&lt;/span&gt;。简单说，会通过词法分析和语法分析将代码转化成一种类似树样层次结构来进行描述，当然这种描述可以用&lt;span&gt;XML&lt;/span&gt;格式。文字描述比较抽象，不妨看一个“&lt;span&gt;hello world&lt;/span&gt;”的具体&lt;span&gt;AST&lt;/span&gt;语法树（&lt;span&gt;Java 1.8&lt;/span&gt;），这样就很容易进行理解了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5510388437217706&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuZLNeN6KTJLe5aI0lalUf6Xku31gibZUH4W3LHWZyZErtwyHJ75uicjWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;另外一个概念&lt;/span&gt;&lt;span&gt;XPath &lt;/span&gt;&lt;span&gt;是一门在&lt;/span&gt;&lt;span&gt;XML &lt;/span&gt;&lt;span&gt;文档中查找信息的语言。本身和代码解析没有关系，但当&lt;/span&gt;&lt;span&gt;AST&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;格式描述时，&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;能够很好完成对相关节点进行查找。两者的结合就能进行违规代码的检查，这就是&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;规则代码规范检查基本原理。此外，与其配套的&lt;/span&gt;&lt;span&gt;PMD-Designer&lt;/span&gt;&lt;span&gt;规则可视化工具也很好用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;例如阿里巴巴代码规范中 &lt;/span&gt;&lt;span&gt;PackageNamingRule &lt;/span&gt;&lt;span&gt;就是非常典型的&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;规则。包名只能由小写字母、数字来组成，具体的&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; XPATH = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;//PackageDeclaration/Name&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;[not (matches(@Image, &#x27;^[a-z0-9]+(\\.[a-z][a-z0-9]*)*$&#x27;))]&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;下面先写个规则的例子来感受下自定义规则具体的操作；从&lt;span&gt;检查代码中&lt;/span&gt;&lt;span&gt;System.out &lt;/span&gt;&lt;span&gt;类似的日志输出开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Example &lt;/span&gt;&lt;span&gt;：检查代码中&lt;/span&gt;&lt;span&gt;System.out &lt;/span&gt;&lt;span&gt;类似的日志输出。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤一，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;运用&lt;/span&gt;&lt;span&gt;PMD-Designer &lt;/span&gt;&lt;span&gt;来辅助编写具体&lt;/span&gt;&lt;span&gt;XPath&lt;/span&gt;&lt;span&gt;的检查规则；这个工具也可以验证各种代码写法下，规则是否都能起到很好的作用。最终&lt;/span&gt;&lt;span&gt;XPath &lt;/span&gt;&lt;span&gt;具体规则如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;//Name[starts-with(@Image, &#x27;System.out.print&#x27;) &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;or starts-with(@Image, &#x27;System.err.print&#x27;)]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5893501805054152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuMLg3nKkGdKczmJ1cxAwV6wM60yfDwdp0qeIHP3kNrbCic2icQfftZ8rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤二，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;新建一个具体的规则类，继承&lt;/span&gt;&lt;span&gt;AbstractXpathRule &lt;/span&gt;&lt;span&gt;；其中&lt;/span&gt;&lt;span&gt;AbstractXpathRule &lt;/span&gt;&lt;span&gt;&lt;span&gt;本身是继承&lt;/span&gt; &lt;span&gt;PMD &lt;/span&gt;&lt;span&gt;中 &lt;/span&gt;&lt;span&gt;XPathRule&lt;/span&gt;&lt;span&gt;，主要扩展了多语言的设计。详细如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;package com.alibaba.p3c.pmd.lang.java.rule.emo;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;public class VoidSystemPrintRule extends AbstractXpathRule {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    private static final String XPATH =  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &quot;//Name[starts-with(@Image, &#x27;System.out.print&#x27;)&quot;+ &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &quot;or starts-with(@Image, &#x27;System.err.print&#x27;)]&quot;;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    public VoidSystemPrintRule() {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        setXPath(XPATH);  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        setVersion(XPATH_2_0);  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    @Override  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    public void addViolation(Object data, Node node, String arg) {  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;        ViolationUtils.addViolationWithPrecisePosition(this, node, data,  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                I18nResources.getMessage(&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;, node.getImage()));  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤三,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在&lt;span&gt;messages.xml &lt;/span&gt;和 &lt;span&gt;messages_en.xml &lt;/span&gt;分别添加检查出错后给出相关中英文提示。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;entry key=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &amp;lt;![CDATA[程序中避免直接使用 System 对相关日志信息输出]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/entry&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;——&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;entry key=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;    &amp;lt;![CDATA[Avoid using system print]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/entry&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤四,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;新建&lt;/span&gt;&lt;span&gt;emo-common.xml &lt;/span&gt;&lt;span&gt;的规则集合，并将实现的规则配置进去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;ruleset name=&quot;AlibabaJavaNaming&quot; xmlns=&quot;http://pmd.sourceforge.net/ruleset/2.0.0&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;xsi:schemaLocation=&quot;http://pmd.sourceforge.net/ruleset/2.0.0 http://pmd.sourceforge.net/ruleset_2_0_0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;description&amp;gt;EmoJavaCommonRule&amp;lt;/description&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;rule name=&quot;VoidSystemPrintRule&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;language=&quot;java&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;since=&quot;1.6&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;message=&quot;java.naming.VoidSystemPrintRule.violation.msg&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;class=&quot;com.alibaba.p3c.pmd.lang.java.rule.emo.VoidSystemPrintRule&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;priority&amp;gt;3&amp;lt;/priority&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;example&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            &amp;lt;![CDATA[&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;                System.out.println(message);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;            ]]&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/example&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/rule&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;/ruleset&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;步骤五,&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;ali-pmd.xml &lt;/span&gt;&lt;span&gt;中引入我们新加的规则集合 &lt;/span&gt;&lt;span&gt;emo-common.xml&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;&amp;lt;rule ref=&quot;rulesets/java/emo-common.xml&quot;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后运行下修改完的代码程序，效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5171480144404332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIu3bEllcPBLg4mMHxvL4MmVD0CK2aRk12cFh2WMZjzy28SA7Juvia6PWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1108&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6558265582655827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/BBtdicYK9ribib7s84I52o58IDuQciafESIuXkbiaAt6NviaJxWKS7Z4kFYXjUUQjvlVQsed1YBwhhK7VBK0TXicGkickw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1107&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综述下关键点，代码规范检查基本原理可以基于&lt;span&gt;AST&lt;/span&gt;语法树来进行实现；&lt;span&gt;AST&lt;/span&gt;结合&lt;span&gt;Xpath&lt;/span&gt;可以方便进行相关规范规则的编写；通过 &lt;span&gt;PMD-Designer &lt;/span&gt;能可视化的帮助我们实现 &lt;span&gt;XPath &lt;/span&gt;的相关代码规范规则以及验证相关规则；给出了一个例子，基于阿里开源代码规范插件源码，编写适用自己公司的代码规范的方式。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;附上相关代码github链接：https://github.com/ariesfly/emo-coding-guardian&lt;/span&gt;&lt;/em&gt;&lt;em&gt;如有遇到问题欢迎公众号私信留言&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8106761ffb102594b8b09e92b332ea71</guid>
<title>研发视角：一个需求应该怎么拆解与实现？</title>
<link>https://toutiao.io/k/27rashp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6279296875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKSppwdQmmicSPVJriaYc6C6Yh8fLYicEliaMkUhd7f70pcQ36MXS0GMJNdanYB4jboDPj6TicrFzlpIrQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研发过程中，开发同学在接到一个需求后，必须要回答两个问题：&lt;/span&gt;&lt;span&gt;做什么（WHAT）、怎么做（HOW）。&lt;/span&gt;&lt;span&gt;本文就开发与测试在拆解需求时面临的共性问题，结合自己过往的经验，总结的一个实用的方法。&lt;/span&gt;&lt;span&gt;本文不讨论技术选型，仅从思考逻辑上总结应该如何拆解与实现一个给定的需求。&lt;/span&gt;&lt;span&gt;欢迎讨论。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;4&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;理解需求拆解的关注点&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以带UI的需求为示例，来看拆解需求过程中的关注点。看下图，停留20秒，思考两个问题：（1）从无到有实现以下需求对应的功能页面，需要做什么？（2）以下页面中只修改指定区域的元素，又需要做什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿﻿&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5862361937128292&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrWy37DianDdoKIc6sv2yPRpbCRF4AmH4MoHCx5BXqvmFWiaP6H71ucQSCbYzLeRSicEwUOicHUOyNlQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;上文两个问题代表两种需求类型：&lt;/span&gt;&lt;span&gt;第一个问题对应新功能的实现，第二个问题对应已有功能的修改与维护。&lt;/span&gt;&lt;span&gt;无论是新功能，还是历史功能，都需要关注如下点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;将上文提及的关注点进行抽象与分层后，会得到如下一张图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42136498516320475&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;674&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naIrWy37DianDdoKIc6sv2yPReGic7RicdobhmdSPmvMcR9JPJgMf13nFdAfgUXib4GIZkByxhxoktPUPw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿﻿&lt;/span&gt;&lt;span&gt;抽象后的架构层次图可以帮助我们理解实现的层次划分与结构设计。&lt;/span&gt;&lt;span&gt;但是，一般来说，抽象意味着抹平细节。&lt;/span&gt;&lt;span&gt;对于一个新手开发或者新手测试来说，需求实现或者测试过程，不仅要关注抽象层面的架构设计，更需要关注实现过程中的细节。&lt;/span&gt;&lt;span&gt;接下来对于上文提及到的关注点，下文会展开说明。&lt;/span&gt;&lt;span&gt;（在一个多角色的团队中，实现一个需求，不仅有自己，还有其他角色的开发、测试、PD、运营、数据等，理解关注细节才能保障交付质量）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;60&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;通过关注点看实现需求要做些什么&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h3 data-cangjie-key=&quot;63&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点1：需要多少UI&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;要绘制多少UI组件、要增加多少UI页面，首先取决于“需求文档（PRD）”、“视觉交互设计稿”。&lt;/span&gt;&lt;span&gt;对于开发来说，请重视需求评审、视觉交互评审。&lt;/span&gt;&lt;span&gt;对于质量良好的需求文档或者视觉设计稿，文档中给出的UI组件/页面范围一般就是开发要实现的UI范围；&lt;/span&gt;&lt;span&gt;对于质量差的需求甚至是一句话的需求，UI范围则需要研发“梳理确定”。&lt;/span&gt;&lt;span&gt;无论需求文档或视觉设计稿质量如何，研发人员在需求评审、视觉交互评审、技术设计、编码实现过程中都需重点关注“异常逻辑”。&lt;/span&gt;&lt;span&gt;什么是异常逻辑？&lt;/span&gt;&lt;span&gt;比如，一个查询类的需求，“查询结果为空”“查询时无网络”这类场景就属于“异常逻辑”。&lt;/span&gt;&lt;span&gt;很多时候，新手容易出问题或者遗漏的地方就是异常逻辑的处理与显示。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;需求拆解阶段，关注UI如何实现的同时，也请务必关注UI的展示对象，包括：&lt;/span&gt;&lt;span&gt;图片与多媒体内容（CDN图片、OSS图片文件、base64编码后的图片）、文案（文案的长度、多语言翻译的来源）、RTL（Right to Left）适配。&lt;/span&gt;&lt;span&gt;已一个支持17种语言甚至是更多语言的海外APP开发为示例，这些内容虽不影响开发进度，但是会影响需求在交付时的质量、或者是到了需求实现后期补作业。&lt;/span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实操方法：需求拆解的时，对于UI范围，可以拆解出如下内容用于辅助后续研发实现：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UI范围：&lt;/span&gt;&lt;span&gt;功能页面范围、页面状态及状态的变化逻辑、界面的异常逻辑态等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面元素的拆解：&lt;/span&gt;&lt;span&gt;列表元素、卡片元素、动画元素、UI特效等（这个也是沉淀通用组件的依据）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;UI展示的对象：&lt;/span&gt;&lt;span&gt;文案的范围、多语言翻译的来源、RTL适配的范围、图片、短视频等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点2：数据从哪里来？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;93&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;这里的数据是包括用户直接感知的数据与富媒体内容流，也包括用户不感知但是用于支撑功能的研发类型的数据。数据的来源包括：网络数据、本地存储的数据、内存数据。不同的数据类型，需求实现的处理有差异，例如：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络数据：&lt;/span&gt;&lt;span&gt;需求拆解时候重点关注接口文档、接口名称、接口返回的数据字段（包括字段类型、范围、字段名称等等）、接口对应的团队或具体的开发、接口的上下游链路（示例：&lt;/span&gt;&lt;span&gt;搜索的接口会涉及广告、算法等）、接口测试与联调方式等。&lt;/span&gt;&lt;span&gt;对于新手，需求拆解的时候还需要确认：&lt;/span&gt;&lt;span&gt;数据网关类型（MTOP网关、Node编排后的数据、Web网站对应的数据网关等），明确网络数据调度所用的域名（比如，部分APP交易功能的域名与非交易功能的域名是分开的，调度方式也会有差异）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;本地存储数据：&lt;/span&gt;&lt;span&gt;需求拆解阶段，要明确本地存储数据还是自己负责还是使用他人的能力。&lt;/span&gt;&lt;span&gt;如果是自己负责则需要进一步判断数据是写本地数据库，还是写本地文件；&lt;/span&gt;&lt;span&gt;如果是他人负责，数据的读写方式与接口是什么。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存数据：&lt;/span&gt;&lt;span&gt;需求拆解重点关注内存数据的读写方式，数据使用后的释放方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;富媒体内容流：&lt;/span&gt;&lt;span&gt;图片、短视频、直播等多媒体流。&lt;/span&gt;&lt;span&gt;需求拆解时关注这些内容存储的形式（以图片为示例：&lt;/span&gt;&lt;span&gt;图片是CDN的URL，还是OSS的文件地址或者ID，甚至是base64处理后的编码结果）；&lt;/span&gt;&lt;span&gt;同时还需要判断这些展示能力是已有的还是需要新引入等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;总结来说，“数据从哪里来”很好记忆，但是，在真实的研发过程中，“数据从哪里来”往往是研发过程中最容易出问题的地方。&lt;/span&gt;&lt;span&gt;以网络数据为例，典型的问题有：&lt;/span&gt;&lt;span&gt;联调环境不稳定、接口返回的字段未遵守约定、接口上下游数据链路不通导致无法测试等。&lt;/span&gt;&lt;span&gt;即使需求完成并且交付上线，也还是会有各类问题，比如：&lt;/span&gt;&lt;span&gt;引入了新CDN导致现有的图片/短视频加载过程的优化策略不支持，导致线上反馈性能或者是稳定性问题等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;对于“数据从哪里来”，在拆解需求的时候，一定要关注到每一个字段。&lt;/span&gt;&lt;span&gt;这么强调，既因为这个点既影响实际投入工作量，还特别影响交付的需求的可用性与质量。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;进行需求拆解的时候，围绕数据从哪里来，可以拆解出以下内容：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点3：数据与UI如何关联？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;141&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;“数据要到哪里去，怎么去”，也可以理解为数据绑定。对于有一定复杂度的需求，“数据与UI如何关联”很大程度上会决定这个功能的实现与维护难易。需求拆解的时候，无论是选择MVC、MVP、还是MVVM，数据绑定这个过程比较考验开发人员的设计能力。我个人将数据绑定总结为如下几种：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单向数据绑定：&lt;/span&gt;&lt;span&gt;数据变化自动驱动UI刷新，代码实现会体现为各种Observer或者Observable等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;双向数据绑定：&lt;/span&gt;&lt;span&gt;数据改变的同时使视图刷新，而视图改变也可以同时改变数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无所谓数据绑定，数据关联到UI是过程式的编程，体现为：&lt;/span&gt;&lt;span&gt;加载数据、加载成功手工代码上屏等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;当然，以上总结是简化后的总结。&lt;/span&gt;&lt;span&gt;对于新功能，建议需求拆解的时候，反复理解所需的数据源、充分理解UI范围，结合控制逻辑，仔细提取关键特征后，充分设计后再进行编码等操作。&lt;/span&gt;&lt;span&gt;设计的时候多借鉴团队内或行业内的最佳实践。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;对于维护类型的需求，特别是有浓重祖传特质的功能（比如2013年功能迭代至2022年&lt;/span&gt;&lt;span&gt;的需求），则要花点时间理解原有的关联关系，这个很有可能是一个不大不小的难点。&lt;/span&gt;&lt;span&gt;比如，有的历史功能在实现的时候，数据与UI的关系是通过EventBus/消息广播类的事件触发；&lt;/span&gt;&lt;span&gt;还有的功能数据在独立进程加载，加载完成后通过进程间通信再通过事件通知机制绑定数据到UI。&lt;/span&gt;&lt;span&gt;总结来说，部分历史功能在最开始的实现，会用到各种酷爽的方案，但是到了后期维护，这类酷爽方法则会以一种超长技术链路或者拗口的技术链路呈现给维护者，变成一座需要咬牙才能翻阅的“山”。&lt;/span&gt;&lt;span&gt;本质上来说，编码不是人与机器的交流，而是人与人之间通过写作的交流。&lt;/span&gt;&lt;span&gt;对于一个维护性质的功能，掌握原有关系的一种方式就是植入各种测试性的代码辅助自己理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;拆解时，数据与UI关联，可拆解出的内容（数据与UI的关联，建议将“克制”作为自己的原则）：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;功能的数据流转与逻辑流程图&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码设计、数据关系流转设计等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据状态变化、UI刷新时机等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关联所用的绑定能力、数据变化后的通知机制等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点4：用户行为响应&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;189&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;相对于上文提及的三个点，这一点相对容易。对于带UI的需求，按照如下范围拆解与实现即可：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;归纳需求文档或设计文档中的用户行动点，包括：&lt;/span&gt;&lt;span&gt;点击、上下滑动、左右滑动、长按、开锁屏、虚实键盘响应、缩放手势等等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;行动点的常见处理：&lt;/span&gt;&lt;span&gt;页面跳转、tips/toast/弹窗等展示、动画处理、界面缩放、界面关闭等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需约定的接口或规范：&lt;/span&gt;&lt;span&gt;页面跳转的schema/传参、二三方能力唤起的方式等&lt;/span&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点5：用户行为采集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;207&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;也就是收集用户行为的数据，简称“数据埋点”。比如，用户点击按钮、进入页面、在某区域停留一定时长之类的行为数据。这些行为数据是产品、数据、BI等角色关心并用于分析用户特征的数据。用户行为采集与用户行为响应密切相关。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据埋点作为独立的关注点强调，是因为即使研发在每个需求都会与“页面点”“点击点”“曝光点”“自定义事件点”打交道，同时也是最容易出问题的地方，问题示例：：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;strong&gt;&lt;span&gt;实操方法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;研发人员在拆解需求的时候，针对用户行为采集，check以下点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需求是否需要采集埋点数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;点的名称是否符合产品/数据等消费方的要求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参数范围与参数值是否有要求&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;需求完成后，数据采集谁验证？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关注点6：发布后，如何运维与监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-cangjie-key=&quot;243&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-3&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;线上一旦出问题，开发或测试可以用什么工具或者方法进行排查分析。这就涉及到：需求如何发布、交付后的功能如何监控、开发过程中是否要提前布点以支撑排查分析工具的使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;功能发布形式有多种，例如：&lt;/span&gt;&lt;span&gt;灰度、Beta、A/B测试形式发布、动态配置下发、直接全量等。&lt;/span&gt;&lt;span&gt;不同发布形式对于功能发布之初的观测有差异，要支撑不同的发布形式，具体的实现也有差异：&lt;/span&gt;&lt;span&gt;比如，通过Google Play进行APP灰度测试不需要开发人员针对功能做额外处理；&lt;/span&gt;&lt;span&gt;以A/B测试形式上线的功能则需要在编码之初就要考虑通过什么平台能力进行，同时还需要编写对应代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;关于如何监控：&lt;/span&gt;&lt;span&gt;需要区分是技术指标监控，还是业务类指标的监控。&lt;/span&gt;&lt;span&gt;不同的监控范围，在需求拆解的时候就要决定哪个平台进行，比如：&lt;/span&gt;&lt;span&gt;业务类的指标可以在xflush平台上进行（需求拆解时要考虑数据回流xflush是已有的能力，还是需要新建能力）；&lt;/span&gt;&lt;span&gt;性能类指标可以在魔兔/iTrace上观测；&lt;/span&gt;&lt;span&gt;研发问题的排查可以通过SLS进行，还可以自建排查能力。&lt;/span&gt;&lt;span&gt;监控虽可以跟随功能的交付逐步补充完善，考虑需求的完整性，建议是在需求拆解的时候明确监控范围与形式。&lt;/span&gt;&lt;span&gt;毕竟，实现监控也是需要工作量的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;上线后有哪些工具可以用于排查分析问题，在需求实现的时候就需要将能力预置好的。&lt;/span&gt;&lt;span&gt;例如，对于“用户下单”这类容错较低的需求，研发在需求实现过程中如果没有写入足够的日志，一旦线上用户反馈“同一个产品在同一个时间下两个订单”，大概率这个问题就是无头无解问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;span&gt;总结来说：&lt;/span&gt;&lt;span&gt;需求发布到线上后如何运维与监控，研发人员在拆解需求的时候需要思考明白：&lt;/span&gt;&lt;span&gt;需求发布形式、上线后期望的监控方式、出问题时可用的排查方式与与排查数据。&lt;/span&gt;&lt;span&gt;这些明确后，具体的实现，很容易通过历史功能、咨询、查资料等方式学习到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/section&gt;&lt;h2 data-cangjie-key=&quot;276&quot; data-cangjie-leaf-block=&quot;true&quot; data-type=&quot;heading-2&quot;&gt;&lt;section&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/section&gt;&lt;/h2&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;无论是开发还是测试，对于新手来说，都可以尝试基于“需要多少UI”、“数据从哪里来”、“数据与UI如何关联”、“用户行为响应”、“用户行为采集”、“发布后，如何运维与监控”六个方面进行需求拆解，并且根据拆解后的内容进行需求实现或者是需求测试。这个方法也适用于去分析其他功能的实现。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个方法是基于有UI的需求进行的总结，还有更多的需求是无UI的：比如，从某个位置同步数据到指定位置并且提供给到其他场景使用；再比如，研发需要一套新的路由框架或需要一套新的资源调度框架。这类需求的拆解与本文总结的方法有相同点，也有不同点，避免本文冗长，不铺开陈述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上方法，是我个人在工作过程中，在接手需求的时候，用来判断需求影响范围、评估合作方、评估工作量的方法。欢迎实践、欢迎讨论，欢迎补充与更正。&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;明日预告：9月29日18:00精品文章&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;strong&gt;&lt;span&gt;&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;阿里云刘伟光：剖析企业数字化的降“本”增效&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不见不散～&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GTS云巧乘风者征文大赛上线！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;10月10日前投稿GTS云巧乘风者征文活动，获得38元天猫超市卡！（数量有限）文章内容不限于云巧，只要运用了【组装式应用的理念】就可以投稿！更有机会获得888元猫超卡和天猫精灵Sound～&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;云巧及组装式应用理念是什么？云巧是“组装式应用”理念的落地，助力大家提升交付速度，提高交付质量，降低用工成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;点击阅读原文查看详情。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5a14f84fc3d6715b776b90781e58e46c</guid>
<title>C++20 协程初探</title>
<link>https://toutiao.io/k/pmpq60v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2159406858202039&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe94QeANounecCYXmibLibjDT9FyppKGsIuLKTF79kZWAibun7RiaHIO3IFFNJOjIs1jvGoIicMiagIeJDiaqg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span&gt;本文推选自腾讯云开发者社区-【技思广益 · 腾讯技术人原创集】专栏。该专栏是腾讯云开发者社区为腾讯技术人与广泛开发者打造的分享交流窗口。栏目邀约腾讯技术人分享原创的技术积淀，与广泛开发者互启迪共成长。&lt;span&gt;本文作者是&lt;/span&gt;腾讯后台开发工程师杨良聪。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;协程(coroutine)是在执行过程中可以被挂起，在后续可以被恢复执行的函数。&lt;/span&gt;&lt;span&gt;在C++20中，当一个函数内部出现了co_await、co_yield、co_return中的任何一个时，这个函数就是一个协程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37886340977068794&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMp7RbD6oSqXZhN2oh9fDszUf39yKHFJBlia9PISicTepIHBBhNBKzfMkdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;C++20协程的一个简单的示例代码:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_ret&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt; number_generator(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; begin, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; count) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;number_generator invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; i=begin; i&amp;lt;count; ++i) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        co_yield i;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* argv[])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; g = number_generator(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;begin to run!&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(!g.resume()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;got number:&quot;&lt;/span&gt; &amp;lt;&amp;lt; g.get() &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;coroutine done, return value:&quot;&lt;/span&gt; &amp;lt;&amp;lt; g.get() &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;69814fe855114dcb26db6b58da84c1d71&quot;&gt;&lt;span&gt;number_generator内出现了co_yield和co_return所以这不是一个普通的函数，而是一个协程，每当程序执行到第4行co_yield i；时，协程就会挂起，程序的控制权会回到调用者那里，直到调用者调用resume方法，此时会恢复到上次协程yield的地方，继续开始执行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FiaZYIGick0nWJJXC1lSLI8zy2asbcicfNgvgJXexvB9rOnicPxbKFdEibPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;e98c58c6c958b0d9ef0ac044d6fa0a36&quot;&gt;&lt;span&gt;Promise&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6095e05d98ce4bfa80ac8a7ea434be6b2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;6095e05d98ce4bfa80ac8a7ea434be6b2&quot;&gt;&lt;span&gt;number_generator的返回类型是coro_ret&amp;lt;int&amp;gt;，而协程本身的代码中并没有通过return返回这个类型的数据，这就是C++20里实现协程的一个关键点: 协程的返回类型T中，必须有T::promise_type这个类型定义，这个类型要实现几个接口。还是先看代码:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;template&lt;/span&gt; &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;typename&lt;/span&gt; T&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;coro_ret&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;promise_type&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; handle_type = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::coroutine_handle&amp;lt;promise_type&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  handle_type coro_handle_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;promise_type&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        promise_type() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;promise constructor invoded.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ~promise_type() = &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;get_return_object&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;get_return_object invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_ret&amp;lt;T&amp;gt;{handle_type::from_promise(*&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;)};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;initial_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;initial_suspend invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;return_void&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;return void invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;yield_value&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; T&amp;amp;amp; v)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;yield_value invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return_data_ = v;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;final_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;noexcept&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;final_suspend invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::suspend_always{};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unhandled_exception&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;unhandled_exception invoked.&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;endl&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;code-snippet__built_in&quot;&gt;exit&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        T return_data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    coro_ret(handle_type h)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            : coro_handle_(h)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ~coro_ret()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (coro_handle_)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            coro_handle_.destroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!coro_handle_.done()) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            coro_handle_.resume();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.done();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.done();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;T &lt;span class=&quot;code-snippet__title&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; coro_handle_.promise().return_data_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;coro_ret是个自定义的结构，为了能作为协程的返回值，需要定义一个promise_type&lt;/span&gt;&lt;span&gt;。这个类型需要实现如下的接口:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F812pnpTVKsrLmlcKHlIuuBvuwqeIqmOLOsD9nTpkow7FlAh45LKRLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;2a1c319a0a54e82b1a058d0854b565c8&quot;&gt;&lt;span&gt;协程相关对象&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f067af2c4b008df27e776c96c9341dfe2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;f067af2c4b008df27e776c96c9341dfe2&quot;&gt;&lt;span&gt;可以看出promise类的工作主要是两个:一是定义协程的执行流程，主要接口是initial_suspend，final_suspend，二是负责协程和调用者之间的数据传递，主要接口是yield_value和return_value。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;877205f4205ef82ec98d8e6145bd48b93&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;877205f4205ef82ec98d8e6145bd48b93&quot;&gt;&lt;span&gt;std::coroutine_handle&amp;lt;promise_type&amp;gt;是协程的控制句柄类，最重要的接口是promise、resume，前者可以获得协程的promise对象，后者可以恢复协程的运行。此外还有destroy接口，用来销毁协程实例，done接口用于返回协程是否已经结束运行。通过std::coroutine_handle&amp;lt;promise_type&amp;gt;::from_promise()方法，可以从promise实例获得对应的handle。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8a60ea4a2c809b06f49b4d87f499995f2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8a60ea4a2c809b06f49b4d87f499995f2&quot;&gt;&lt;span&gt;coro_ret中其他几个接口resume，done和get_data不是必须的，只是为了方便使用而存在。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d47e93b0a53a92f34b8afbeaea56aee32&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d47e93b0a53a92f34b8afbeaea56aee32&quot;&gt;&lt;span&gt;总结一下，&lt;/span&gt;&lt;span&gt;一个协程与这几个对象关联在一起&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是个在堆上分配的内部对象，没有暴露给开发者，是用来保存协程内相关数据和状态的，具体来说就是:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9Fl62j5eylelCcZwNOEv5HRg9xicSj2KIwvdQMPbwiau3eqyIUpKbjQ6nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;ae6dba70cd0182bd0e5016f2dabcd3be&quot;&gt;&lt;span&gt;协程&lt;/span&gt;&lt;span&gt;的创建&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;3.426470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpjB5D44WOnEZplBd1qpGic0KniclAjoELJ3hGKk4Omtg600DGNz0VvWaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9FPB6mZB01WGXHsGUE2UYENHAJNeKa8y0qwiajZdfHR5lvk4rjnrQabwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;2d3673083b483abecdb1ed3918817fec&quot;&gt;&lt;span&gt;临时总结&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d4a807228836477b997d30c0991686d63&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d4a807228836477b997d30c0991686d63&quot;&gt;&lt;span&gt;要在c++20里实现一个协程，需要定义一个协程的返回类型T，这个T内需要定义一个promise_type的类型，这个类型要实现几个指定的接口，这样就足够了。这样，要开发一个包含异步操作的协程，代码的结构大致会是这样的:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_return&amp;lt;T&amp;gt; logic() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    some_async_oper();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_yield xxx&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result = get_async_oper_result()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     do_some_thing(result)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     co_return&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; co_ret = logic();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt;(&lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; result = get_async_result();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (result) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          co_ret.resume()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d3723338a79436c9283461efa45c5ac51&quot;&gt;&lt;span&gt;可以看到，在协程内部，发起异步操作和获取结果，被yield分割为了两步，和同步代码还是有着明显的区别。这时，co_await就可以发挥它的作用了，使用了co_await后的协程代码会是这样的&lt;/span&gt;&lt;/p&gt;&lt;pre/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;coro_return&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;logic&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    auto result = &lt;span class=&quot;code-snippet__function&quot;&gt;co_await &lt;span class=&quot;code-snippet__title&quot;&gt;some_async_oper&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do_some_thing(result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;5ddd9dec80b8bde4c4adb06f5129a2b91&quot;&gt;&lt;span&gt;这样就和同步代码就基本没有区别了，除了这个co_await&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b1ac4c98199a6df54a56b17db40c96e24&quot;&gt;&lt;span&gt;co_await最常见的使用方式为auto ret=co_await expr，co_await后跟一个表达式，整个语句的执行过程有多种情况，是比较复杂的。这里描述的是简化版本，主要是简化了promise.await_transform的作用，以及awaitable对象，可以点击下面链接&lt;/span&gt;&lt;span&gt;看完整的描述。&lt;span&gt;这&lt;/span&gt;&lt;span&gt;里假定协程的prom&lt;/span&gt;&lt;span&gt;ise_type没有实现await_transform方法。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://en.cppreference.com/w/cpp/language/coroutines&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.720626631853786&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpguy3iaThVxaIhGXrPia847EibY9nAJlXiaaG0eIxaaqzD4sydpQz88ib24Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用代码表达，是这样：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (!awaiter.await_ready())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt; = &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::experimental::coroutine_handle&amp;lt;P&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt; =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;decltype&lt;/span&gt;(awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p)));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;suspend-coroutine&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::is_void_v&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt;&amp;gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;-to-caller-&lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt;-resumer&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;static_assert&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::is_same_v&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;await_suspend_result_t&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;&amp;gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_suspend() must return &#x27;void&#x27; or &#x27;bool&#x27;.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (awaiter.await_suspend(&lt;span class=&quot;code-snippet__keyword&quot;&gt;handle_t&lt;/span&gt;::from_promise(p)))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;-to-caller-&lt;span class=&quot;code-snippet__keyword&quot;&gt;or&lt;/span&gt;-resumer&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;resume-point&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; awaiter.await_resume();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a7b87b6154d6b6116a89737320efacf32&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a7b87b6154d6b6116a89737320efacf32&quot;&gt;&lt;span&gt;以封装一个socket的connect操作为例，我们希望能像这样在协程中去connect一个tcp地址:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;coro_ret&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&amp;gt; connect_addr_example(io_service&amp;amp;amp; service, &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt;* ip, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int16_t&lt;/span&gt; port)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    coroutine_tcp_client client;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; connect_ret = co_await client.connect(ip, port, &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, service);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;client.connect return:%d\n&quot;&lt;/span&gt;, connect_ret);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (connect_ret)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;connect failed, coroutine return\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        co_return &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    do_something_with_connect(client);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    co_return &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;span&gt;那么需要做的事情是&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;2649846b94e17f735e75069edf4f80231&quot;&gt;&lt;span&gt;第5行中的client.connect首先发起一个异步连接的请求(设置socket为noneblock，然后connect, 并把socket和自己的指针加入epoll)，返回的类型需要是一个awaiter，也就是要实现这三个接口:await_ready、await_suspend和await_resume&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_ready中，判断连接是否已经建立了(某些情况下connect会立刻成功返回)，或者出错了(比如给connect传了非法的参数)，此时需要返回true，协程就完全不会挂起。其他情况需要返回false，让协程挂起&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_suspend中，可以保存下传入的协程句柄，然后直接返回true。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在await_resume中，判断下连接的结果，成功返回0，其他情况返回错误码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协程外的主循环里，使用epoll进行轮询，当对应的句柄有事件时(成功连接、超时、出错)，就取出对应的client指针，设置好连接的结果，并resume协程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;9027a0165ea3e249ec69dbe1982877611&quot;&gt;&lt;span&gt;大致的代码如下:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;connect_awaiter&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        coroutine_tcp_client&amp;amp; tcp_client_;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_ready&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; status = tcp_client_.status();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt;(status)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; ERROR:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: status error invalid, should not suspend!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; CONNECTED:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: already connected, should not suspend!\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_ready: status:%d, return false.\n&quot;&lt;/span&gt;, status);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_suspend&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;std&lt;/span&gt;::coroutine_handle&amp;lt;&amp;gt; awaiting)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;await_suspend invoked.\n&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tcp_client_.handle_ = awaiting;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;await_resume&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; ret = tcp_client_.status() == CONNECTED ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;awati_resume invoked, ret:%d\n&quot;&lt;/span&gt;, ret);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; ret;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;3c413281ce0e6425754993cc3b29f0202&quot;&gt;&lt;span&gt;了解了co_await之后，可以回头看一下之前的内容，前面多次出现的std::suspend_never和std::suspend_always就是两个预定义好的awaiter，也有那三个接口的定义，有兴趣的同学可以看看对应的源代码。promise对象的initial_suspend、final_suspend、yield_value返回的都是awaiter，实际上系统执行的是 co_await promise.initial_suspend() ，co_yield实际上执行的是 co_await promise.yield_value() 。如果有需要，也可以返回自定义的awaiter。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08148148148148149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94QeANounecCYXmibLibjDT9F9gEWETfj769ZEnnF4YHYbm1UBFpYldG1ibl6E9owa0M3yRB40WtEqLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;03b104d231d83a3fe7925664fc7b65e4&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看出C++20给出了一个非常灵活、有很强大可定制性的协程机制，但缺少基本的库支持，连写一个最简单的协程都需要开发者付出不少理解和学习的成本，目前的状态只能说是打了一个的地基，在C++23中，为协程提供库的支持是重要的目标之一，可以拭目以待。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/section&gt;&lt;h3 data-lines=&quot;1&quot; data-sign=&quot;8a78f98238875951e8f8dff55d866b57&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h1 msthash=&quot;200785&quot; msttexthash=&quot;25598833&quot;&gt;&lt;span&gt;1.协程 （C++20）&lt;/span&gt;&lt;/h1&gt;&lt;h1 itemprop=&quot;name headline&quot; msthash=&quot;1355575&quot; msttexthash=&quot;48227790&quot;&gt;&lt;span&gt;2.C++ 协程：了解运算符co_await&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;3.C++20即将到来的coroutine能否与Golang的goroutine媲美？&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe95Yft4YCFicTVdU1icGRQPiaMpLxmVg5ia6uIWRscbIrbKnn8j33pxsd3fCmw3XNDgibsU1exzfB1Bfm1g/640?wx_fmt=png&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;杨良聪&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，毕业于华中科技大学，目前负责欢乐斗地主后端开发工作，有丰富的后台开发经验。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247545128&amp;amp;idx=1&amp;amp;sn=4dbacff04dbfb71f0675be0fa1cc1923&amp;amp;chksm=eaa82b78dddfa26e560d058f101f51480e98fc2bf72385addd6f7e2833266e0ea49734faa6e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;GooseFS 在云端数据湖存储上的降本增效实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;GooseFS 在云端数据湖存储上的降本增效实践&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247545128&amp;amp;idx=2&amp;amp;sn=1dfadea0ac7abbfc771ad6a4c9bd0249&amp;amp;chksm=eaa82b78dddfa26ea8eaa74a684b05d98410221f25230a937dc7fb91dd3188f7405cd604ad1e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;新周期重构地产与物业数智化价值，TVP行业大使有话说&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;新周期重构地产与物业数智化价值，TVP行业大使有话说&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247544545&amp;amp;idx=1&amp;amp;sn=52424da68159c07a8260c6cef2bd2d01&amp;amp;chksm=eaa834b1dddfbda7b514c402b36ede3277be26fb05453d3fb2f8cfb99f0320a4d5faff7ed2ed&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;轻松上手！手把手带你掌握从Context到go设计理念&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;轻松上手！手把手带你掌握从Context到go设计理念&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247544454&amp;amp;idx=1&amp;amp;sn=8bf9a22c3402c9f07e248c038b09f3a5&amp;amp;chksm=eaa834d6dddfbdc02478b4f7ae87640cd2e2e705eba517eaa1bfd0458895f63e40e71c2d44aa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入浅出带你走进Redis！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;深入浅出带你走进Redis！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe940MSFL1oCgmdY94xonPZxOZqHFPx02lrZBs8SHygWCrAU9Fs3sYiap0kiaubmtBLZetqLAlQVsUb5Q/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;👇&lt;/span&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;「阅读原文」&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;注册成为社&lt;/span&gt;&lt;span&gt;区创作者，认识大咖，打造你的技术影响力！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>64d029970d76b5e1b2edf57da439a1a3</guid>
<title>1.3w 字，一文详解死锁</title>
<link>https://toutiao.io/k/cpuopkj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方停止执行，以取得系统资源，但是没有一方提前退出，就称为死锁。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6460554371002132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmADlLgGMVtju1L72obicjJsoUVDIkORVCz6Po9llajtEEpiaFqpGYAlTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.死锁演示&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁的形成分为两个方面，一个是使用内置锁 synchronized 形成的死锁，另一种是使用显式锁 Lock 实现的死锁，接下来我们分别来看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 死锁 synchronized 版&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object lockA = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Object lockB = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 先获取锁 A&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 尝试获取锁 B&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 先获取锁 B&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 尝试获取锁 A&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41688654353562005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWNw06AfA6YYPMcibDJ9UsBw8tk6fhdVnibKf27nIhOY5ruHcFW1PG4rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 死锁 Lock 版&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DeadLockByReentrantLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41688654353562005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWNw06AfA6YYPMcibDJ9UsBw8tk6fhdVnibKf27nIhOY5ruHcFW1PG4rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.死锁产生原因&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上示例，我们可以得出结论，要产生&lt;strong&gt;死锁需要满足以下 4 个条件&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;互斥条件&lt;/strong&gt;：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;请求和保持条件&lt;/strong&gt;：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不可剥夺条件&lt;/strong&gt;：指运算单元已获得的资源，在未使用完之前，不能被剥夺。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;环路等待条件&lt;/strong&gt;：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有以上 4 个条件同时满足，才会造成死锁问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.死锁排查工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果程序出现死锁问题，可通过以下 4 种方案中的任意一种进行分析和排查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 jstack&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在使用 jstack 之前，先要通过 jps 得到运行程序的进程 ID，使用方法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6194444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA3QaQWB4jZMFNhMjvuPwLfvvyWicbP3jEDypmKIny407dB7OHvZMYdyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;“jps -l”可以查询本机所有的 Java 程序，jps（Java Virtual Machine Process Status Tool）是 Java 提供的一个显示当前所有 Java 进程 pid 的命令，适合在 linux/unix/windows 平台上简单查看当前 Java 进程的一些简单情况，“-l”用于输出进程 pid 和运行程序完整路径名（包名和类名）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了进程 ID（PID）之后，我们就可以使用“jstack -l PID”来发现死锁问题了，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7745358090185677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAabvmyOjnDpMp6KALrrI1ib0UcUQcnmm1iaUwSrXAVicZA9LTvlfcFLMDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;jstack 用于生成 Java 虚拟机当前时刻的线程快照，“-l”表示长列表（long），打印关于锁的附加信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS：可以使用 jstack -help 查看更多命令使用说明。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 jconsole&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 jconsole 需要打开 JDK 的 bin 目录，找到 jconsole 并双击打开，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAOxHZ25JWwsRZCThOeuG3n6IF1CO2pnul211zaQMxd55vx45hLbKU3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6953703703703704&quot; data-w=&quot;1080&quot;/&gt;然后选择要调试的程序，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA2LdjK4R8KvlvcTvvyPrP2FnnhB4KVawVUuEQtpUwuzrhn5gib2f85Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后点击连接进入，选择“不安全的连接”进入监控主页，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAcbqu64dB7NaW3aWGpKmeLtFYBd8TNJtVp1DXibFpMOfYx51ZY765LeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAI97AjUVA3Wz9LkPP40EmHb5yUr7FjW2bVDibAdqHHUVRCu6ky42GdSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后切换到“线程”模块，点击“检测死锁”按钮，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAtzoA9uevcSAoDIpZ9BOkkdr8VIAvFuhSrIrJOHdgTAg5G1iap9JKmeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;之后稍等片刻就会检测出死锁的相关信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAenPE43qnS8qdjiaI6equszPqsWZ3xkc4ick3dRCfQmnpEJibXcYGrJXGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 jvisualvm&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jvisualvm 也在 JDK 的 bin 目录中，同样是双击打开：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA2lnQfdLDgDEZEJ5lSLn0sRV7R45gbMCRG98gtNYGn4hvZs0YLQadhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6953703703703704&quot; data-w=&quot;1080&quot;/&gt;稍等几秒之后，jvisualvm 中就会出现本地的所有 Java 程序，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA8SSQovwJwKIxEOE1hlNUMVG2EgPtjT6ING2P0IhD581ic5jp3w2ziapw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;双击选择要调试的程序：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6181506849315068&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAIKiaeogwiclesYGBaicVicKZkibKoCNVduHF3mQwgvWMJ4q6jOEU7UnQeYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2336&quot;/&gt;单击鼠标进入“线程”模块，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAaRv8wldSVEMDa5chlBoKgVNUnN0DNT73DASC4Ac5cwc2R9sYA0CyVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;从上图可以看出，当我们切换到线程一栏之后就会直接显示出死锁信息，之后点击“线程 Dump”生成死锁的详情信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA6ltTBqQXUiacRGBtR65RTptAibn02DibLUte7hprOCibXoEWVvwLZbS7mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6185185185185185&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 jmc&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmc 是 Oracle Java Mission Control 的缩写，是一个对 Java 程序进行管理、监控、概要分析和故障排查的工具套件。它也是在 JDK 的 bin 目录中，同样是双击启动，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6953703703703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAU6A7Yicia7YT7uoSGnemEnIzoZESTXPJNd62uQjrBAyDCl0NibQrAG8WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;jmc 主页信息如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmANfC5BF035qc964qL44pJfvKQ4FSE9iagHyq1Zib8qcL2JNgqaWxTicsKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;之后选中要排查的程序，右键“启动 JMX 控制台”查看此程序的详细内容，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6515580736543909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAb56Ly9Zpzul29f4NbZiaqDibwvaVibyYsgfhRgUNPlmoZQrWCLAricibWVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmA0icrzw7icLWqb2KClL3NQOHFciafToiboicMqtYwVkbMdESoVvbZBo7JyLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;然后点击“线程”，勾中“死锁检测”就可以发现死锁和死锁的详情信息，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAYm6icJuP9JnxUA0ZqiacBjNRX69FFib3IGHRRZznMic2PoV6mY9tCOIMug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1380&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.死锁解决方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 死锁解决方案分析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们来分析一下，产生死锁的 4 个条件，哪些是可以破坏的？哪些是不能被破坏的？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥条件：系统特性，不能被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求和保持条件：可以被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不可剥夺条件：系统特性，不能被破坏。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;环路等待条件：可以被破坏。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述分析，我们可以得出结论，我们只能通过破坏请求和保持条件或者是环路等待条件，从而来解决死锁的问题，那上线，我们就先从破坏“环路等待条件”开始来解决死锁问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 解决方案1：顺序锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的顺序锁指的是通过有顺序的获取锁，从而避免产生环路等待条件，从而解决死锁问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有使用顺序锁时，程序的执行可能是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6460554371002132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmADlLgGMVtju1L72obicjJsoUVDIkORVCz6Po9llajtEEpiaFqpGYAlTRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;线程 1 先获取了锁 A，再获取锁 B，线程 2 与 线程 1 同时执行，线程 2 先获取锁 B，再获取锁 A，这样双方都先占用了各自的资源（锁 A 和锁 B）之后，再尝试获取对方的锁，从而造成了环路等待问题，最后造成了死锁的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们只需要将线程 1 和线程 2 获取锁的顺序进行统一，也就是线程 1 和线程 2 同时执行之后，都先获取锁 A，再获取锁 B，执行流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0923482849604222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAKSzO7Smo3OmLiaWHVA4FaBtJh1nrqn76YYrxZSH4L6FGtOBF65mu4iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;758&quot;/&gt;因为只有一个线程能成功获取到锁 A，没有获取到锁 A 的线程就会等待先获取锁 A，此时得到锁 A 的线程继续获取锁 B，因为没有线程争抢和拥有锁 B，那么得到锁 A 的线程就会顺利的拥有锁 B，之后执行相应的代码再将锁资源全部释放，然后另一个等待获取锁 A 的线程就可以成功获取到锁资源，执行后续的代码，这样就不会出现死锁的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序锁的实现代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Object lockA = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Object lockB = &lt;span&gt;new&lt;/span&gt; Object(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (lockA) {&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (lockB) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5751633986928104&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAEAVGBq0M7rnOxXictCml63iccu23A7Ia3h738bGGEN643DufUS4BjMcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;918&quot;/&gt;从上述执行结果可以看出，程序并没有出现死锁的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 解决方案2：轮询锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询锁是通过打破“请求和保持条件”来避免造成死锁的，它的实现思路简单来说就是通过轮询来尝试获取锁，如果有一个锁获取失败，则释放当前线程拥有的所有锁，等待下一轮再尝试获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轮询锁的实现需要使用到 ReentrantLock 的 tryLock 方法，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上程序的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8703296703296703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAdPciams7e43Zju1N6HL7CGmNeOT7yjNgcnkgfpLhebMPkPOA7iaJ63Bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;从上述结果可以看出，以上代码也没有出现死锁的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.4 轮询锁优化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用轮询锁虽然可以解决死锁的问题，但并不是完美无缺的，比如以下这些问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.1 问题1：死循环&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上简易版的轮询锁，如果遇到有一个线程一直霸占或者长时间霸占锁资源的情况，就会导致这个轮询锁进入死循环的状态，它会尝试一直获取锁资源，这样就会造成新的问题，带来不必要的性能开销，具体示例如下。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;反例&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 如果此处代码未执行，线程 2 一直未释放锁资源&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// lockB.unlock(); &lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmASibUaDRFvZ8zrdfNhPJiaxmw5t1KqfY8vmiaAVNxlpASDn7NLHPnucCCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;2.9918367346938775&quot; data-w=&quot;490&quot;/&gt;从上述结果可以看出，线程 1 轮询锁进入了死循环的状态。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;优化版&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对以上死循环的情况，我们可以改进的思路有以下两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;添加最大次数限制：如果经过了 n 次尝试获取锁之后，还未获取到锁，则认为获取锁失败，执行失败策略之后终止轮询（失败策略可以是记录日志或其他操作）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加最大时长限制：如果经过了 n 秒尝试获取锁之后，还未获取到锁，则认为获取锁失败，执行失败策略之后终止轮询。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上策略任选其一就可以解决死循环的问题，出于实现成本的考虑，我们可以采用轮询最大次数的方式来改进轮询锁，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                    lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 线程 2 忘记释放锁资源&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;// lockB.unlock(); // 释放锁&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     *&lt;br/&gt;     * maxCount：最大轮询次数&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 轮询次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAOsUTCiarn4ictmmUaic3v6853JzZicf7thKlBKAUHZfnulKszYAB0776Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;从以上结果可以看出，当我们改进之后，轮询锁就不会出现死循环的问题了，它会尝试一定次数之后终止执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4.2 问题2：线程饿死&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以上的轮询锁的轮询等待时间是固定时间，如下代码所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 等待 1s 再尝试获取（轮询）锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在特殊情况下会造成线程饿死的问题，也就是轮询锁一直获取不到锁的问题，比如以下示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;反例&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                        lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 等待一秒之后继续执行&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 循环次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 等待 0.1s(获取锁需要的时间)&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一秒再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;3.0347222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAWpt9S5dIFeZEKSeQ0wCwaZRSHJyPrVPMicrfwBRvs91cHFNa3cGrEsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;从上述结果可以看出，线程 1（轮询锁）一直未成功获取到锁，造成这种结果的原因是：线程 1 每次轮询的等待时间为固定的 1s，而线程 2 也是相同的频率，每 1s 获取一次锁，这样就会导致线程 2 会一直先成功获取到锁，而线程 1 则会一直处于“饿死”的情况，执行流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7983539094650205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAicdBygnNOUXI62gicyIwgjXlTbKxeEib8W9NLnSZ95y1PQJmVggJqY2HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;优化版&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们可以将轮询锁的固定等待时间，&lt;strong&gt;改进为固定时间 + 随机时间的方式&lt;/strong&gt;，这样就可以避免因为获取锁的频率一致，而造成轮询锁“饿死”的问题了，具体实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.Random;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.Lock;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReentrantLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SolveDeadLockExample&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Random rdm = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lockA = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 A&lt;/span&gt;&lt;br/&gt;        Lock lockB = &lt;span&gt;new&lt;/span&gt; ReentrantLock(); &lt;span&gt;// 创建锁 B&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 1(使用轮询锁)&lt;/span&gt;&lt;br/&gt;        Thread t1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;// 调用轮询锁&lt;/span&gt;&lt;br/&gt;                pollingLock(lockA, lockB, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t1.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 创建线程 2&lt;/span&gt;&lt;br/&gt;        Thread t2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    lockB.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;线程 2:等待获取 A...&quot;&lt;/span&gt;);&lt;br/&gt;                        lockA.lock(); &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 2:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                        }&lt;br/&gt;                    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                        lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;// 等待一秒之后继续执行&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        Thread.sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        t2.start(); &lt;span&gt;// 运行线程&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 轮询锁&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pollingLock&lt;/span&gt;&lt;span&gt;(Lock lockA, Lock lockB, &lt;span&gt;int&lt;/span&gt; maxCount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 循环次数计数器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (lockA.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 A!&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 等待 0.1s(获取锁需要的时间)&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:等待获取 B...&quot;&lt;/span&gt;);&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (lockB.tryLock()) { &lt;span&gt;// 尝试获取锁&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:获取到锁 B!&quot;&lt;/span&gt;);&lt;br/&gt;                        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                            lockB.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                            System.out.println(&lt;span&gt;&quot;线程 1:释放锁 B.&quot;&lt;/span&gt;);&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                    lockA.unlock(); &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;                    System.out.println(&lt;span&gt;&quot;线程 1:释放锁 A.&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 判断是否已经超过最大次数限制&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count++ &amp;gt; maxCount) {&lt;br/&gt;                &lt;span&gt;// 终止循环&lt;/span&gt;&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;轮询锁获取失败,记录日志或执行其他失败策略&quot;&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// 等待一定时间(固定时间 + 随机时间)之后再继续尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                Thread.sleep(&lt;span&gt;300&lt;/span&gt; + rdm.nextInt(&lt;span&gt;8&lt;/span&gt;) * &lt;span&gt;100&lt;/span&gt;); &lt;span&gt;// 固定时间 + 随机时间&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码的执行结果如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.108695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HrWw6ZuXCsjJpvG1c1Vc2WclEcAvGCmAKBibFoVl4y1CRVyxCicIBOH5RVkrZHmIewsyw8QEA6stkqh6Uibf70xJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;从上述结果可以看出，线程 1（轮询锁）加入随机等待时间之后就不会出现线程饿死的问题了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了死锁的概念，以及产生死锁的 4 个条件，排查死锁可以通过本文提供的 4 种工具中的任意一种来检测，从易用性和性能方面来考虑，推荐使用 jconsole 或 jvisualvm，最后我们介绍了死锁问题的两种解决方案：顺序锁和轮询锁。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;---END---&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9b75dd111b0b1e7106fd2a3463ca6c86</guid>
<title>Go 语言官方依赖注入工具 Wire 使用指北</title>
<link>https://toutiao.io/k/kvhb66e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// dal/user.go&lt;br/&gt;&lt;br/&gt;func (u *UserDal) Create(ctx context.Context, data *UserCreateParams) error {&lt;br/&gt;    db := mysql.GetDB().Model(&amp;amp;entity.User{})&lt;br/&gt;    user := entity.User{&lt;br/&gt;      Username: data.Username,&lt;br/&gt;      Password: data.Password,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; db.Create(&amp;amp;user).Error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// service/user.go&lt;br/&gt;func (u *UserService) Register(ctx context.Context, data *schema.RegisterReq) (*schema.RegisterRes, error) {&lt;br/&gt;   params := dal.UserCreateParams{&lt;br/&gt;      Username: data.Username,&lt;br/&gt;      Password: data.Password,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   err := dal.GetUserDal().Create(ctx, params)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   registerRes := schema.RegisterRes{&lt;br/&gt;      Msg: &lt;span&gt;&quot;register success&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;registerRes, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段代码里，层级依赖关系为 service -&amp;gt; dal -&amp;gt; db，上游层级通过 &lt;code&gt;Getxxx&lt;/code&gt;实例化依赖。但在实际生产中，我们的依赖链比较少是垂直依赖关系，更多的是横向依赖。即我们一个方法中，可能要多次调用&lt;code&gt;Getxxx&lt;/code&gt;的方法，这样使得我们代码极不简洁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，我们的依赖都是写死的，即依赖者的代码中写死了被依赖者的生成关系。当被依赖者的生成方式改变，我们也需要改变依赖者的函数，这极大的增加了修改代码量以及出错风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们用&lt;code&gt;依赖注入&lt;/code&gt;的方式对代码进行改造：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// dal/user.go&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserDal struct{&lt;br/&gt;    DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewUserDal(db *gorm.DB) *UserDal{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;UserDal{&lt;br/&gt;        DB: db&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (u *UserDal) Create(ctx context.Context, data *UserCreateParams) error {&lt;br/&gt;    db := u.DB.Model(&amp;amp;entity.User{})&lt;br/&gt;    user := entity.User{&lt;br/&gt;      Username: data.Username,&lt;br/&gt;      Password: data.Password,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; db.Create(&amp;amp;user).Error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// service/user.go&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserService struct{&lt;br/&gt;    UserDal *dal.UserDal&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewUserService(userDal dal.UserDal) *UserService{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;UserService{&lt;br/&gt;        UserDal: userDal&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (u *UserService) Register(ctx context.Context, data *schema.RegisterReq) (*schema.RegisterRes, error) {&lt;br/&gt;   params := dal.UserCreateParams{&lt;br/&gt;      Username: data.Username,&lt;br/&gt;      Password: data.Password,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   err := u.UserDal.Create(ctx, params)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   registerRes := schema.RegisterRes{&lt;br/&gt;      Msg: &lt;span&gt;&quot;register success&quot;&lt;/span&gt;,&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;registerRes, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// main.go &lt;br/&gt;db := mysql.GetDB()&lt;br/&gt;userDal := dal.NewUserDal(db)&lt;br/&gt;userService := dal.NewUserService(userDal)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上编码情况中，我们通过将 db 实例对象注入到 dal 中，再将 dal 实例对象注入到 service 中，实现了层级间的依赖注入。解耦了部分依赖关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在系统简单、代码量少的情况下上面的实现方式确实没什么问题。但是项目庞大到一定程度，结构之间的关系变得非常复杂时，手动创建每个依赖，然后层层组装起来的方式就会变得异常繁琐，并且容易出错。这个时候勇士 wire 出现了！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Wire Come&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 简介&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wire 是一个轻巧的 Golang 依赖注入工具。它由 Go Cloud 团队开发，通过自动生成代码的方式在编译期完成依赖注入。它不需要反射机制，后面会看到， Wire 生成的代码与手写无异。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 快速使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wire 的安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/google/wire/cmd/wire&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的命令会在 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 中生成一个可执行程序 &lt;code&gt;wire&lt;/code&gt;，这就是代码生成器。可以把&lt;code&gt;$GOPATH/bin&lt;/code&gt; 加入系统环境变量 &lt;code&gt;$PATH&lt;/code&gt; 中，所以可直接在命令行中执行 &lt;code&gt;wire&lt;/code&gt; 命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们在一个例子中看看如何使用 &lt;code&gt;wire&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们有这样的三个类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Message string&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Channel struct {&lt;br/&gt;    Message Message&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; BroadCast struct {&lt;br/&gt;    Channel Channel&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三者的 init 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewMessage() Message {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Message(&lt;span&gt;&quot;Hello Wire!&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;func NewChannel(m Message) Channel {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Channel{Message: m}&lt;br/&gt;}&lt;br/&gt;func NewBroadCast(c Channel) BroadCast {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; BroadCast{Channel: c}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 Channel 有一个 GetMsg 方法，BroadCast 有一个 Start 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func (c Channel) GetMsg() Message {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; c.Message&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (b BroadCast) &lt;span&gt;&lt;span&gt;Start&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    msg := b.Channel.GetMsg()&lt;br/&gt;    fmt.Println(msg)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果手动写代码的话，我们的写法应该是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    message := NewMessage()&lt;br/&gt;    channel := NewChannel(message)&lt;br/&gt;    broadCast := NewBroadCast(channel)&lt;br/&gt;&lt;br/&gt;    broadCast.Start()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用 &lt;code&gt;wire&lt;/code&gt;，我们需要做的就变成如下的工作了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提取一个 init 方法 InitializeBroadCast：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    b := demo.InitializeBroadCast()&lt;br/&gt;&lt;br/&gt;    b.Start()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;编写一个 wire.go 文件，用于 wire 工具来解析依赖，生成代码：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//+build wireinject&lt;br/&gt;&lt;br/&gt;package demo&lt;br/&gt;&lt;br/&gt;func InitializeBroadCast() BroadCast {&lt;br/&gt;    wire.Build(NewBroadCast, NewChannel, NewMessage)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; BroadCast{}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：需要在文件头部增加构建约束：//+build wireinject&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用 wire 工具，生成代码，在 wire.go 所在目录下执行命令：&lt;code&gt;wire gen wire.go&lt;/code&gt;。会生成如下代码，即在编译代码时真正使用的Init函数：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Code generated by Wire. DO NOT EDIT.&lt;br/&gt;&lt;br/&gt;//go:generate wire&lt;br/&gt;//+build !wireinject&lt;br/&gt;func InitializeBroadCast() BroadCast {&lt;br/&gt;    message := NewMessage()&lt;br/&gt;    channel := NewChannel(message)&lt;br/&gt;    broadCast := NewBroadCast(channel)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; broadCast&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们告诉 &lt;code&gt;wire&lt;/code&gt;，我们所用到的各种组件的 &lt;code&gt;init&lt;/code&gt; 方法（&lt;code&gt;NewBroadCast&lt;/code&gt;, &lt;code&gt;NewChannel&lt;/code&gt;, &lt;code&gt;NewMessage&lt;/code&gt;），那么 &lt;code&gt;wire&lt;/code&gt; 工具会根据这些方法的函数签名（参数类型/返回值类型/函数名）自动推导依赖关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wire.go&lt;/code&gt; 和 &lt;code&gt;wire_gen.go&lt;/code&gt; 文件头部位置都有一个 &lt;code&gt;+build&lt;/code&gt;，不过一个后面是 &lt;code&gt;wireinject&lt;/code&gt;，另一个是 &lt;code&gt;!wireinject&lt;/code&gt;。&lt;code&gt;+build&lt;/code&gt; 其实是 Go 语言的一个特性。类似 C/C++ 的条件编译，在执行 &lt;code&gt;go build&lt;/code&gt; 时可传入一些选项，根据这个选项决定某些文件是否编译。&lt;code&gt;wire&lt;/code&gt; 工具只会处理有&lt;code&gt;wireinject&lt;/code&gt; 的文件，所以我们的 &lt;code&gt;wire.go&lt;/code&gt; 文件要加上这个。生成的 &lt;code&gt;wire_gen.go&lt;/code&gt; 是给我们来使用的，&lt;code&gt;wire&lt;/code&gt; 不需要处理，故有 &lt;code&gt;!wireinject&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.3 基础概念&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Wire&lt;/code&gt; 有两个基础概念，&lt;code&gt;Provider&lt;/code&gt;（构造器）和 &lt;code&gt;Injector&lt;/code&gt;（注入器）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Provider&lt;/code&gt; 实际上就是生成组件的普通方法，这些方法接收所需依赖作为参数，创建组件并将其返回。我们上面例子的 &lt;code&gt;NewBroadCast&lt;/code&gt; 就是 &lt;code&gt;Provider&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Injector&lt;/code&gt; 可以理解为 &lt;code&gt;Providers&lt;/code&gt; 的连接器，它用来按依赖顺序调用 &lt;code&gt;Providers&lt;/code&gt; 并最终返回构建目标。我们上面例子的 &lt;code&gt;InitializeBroadCast&lt;/code&gt; 就是 &lt;code&gt;Injector&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. Wire使用实践&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面简单介绍一下 &lt;code&gt;wire&lt;/code&gt; 在飞书问卷表单服务中的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;飞书问卷表单服务的 &lt;code&gt;project&lt;/code&gt; 模块中将 handler 层、service 层和 dal 层的初始化通过参数注入的方式实现依赖反转。通过 &lt;code&gt;BuildInjector&lt;/code&gt; 注入器来初始化所有的外部依赖。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 基础使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dal 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewProjectDal(db *gorm.DB) *ProjectDal{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;ProjectDal{&lt;br/&gt;        DB:db&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectDal struct {&lt;br/&gt;   DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (dal *ProjectDal) Create(ctx context.Context, item *entity.Project) error {&lt;br/&gt;   result := dal.DB.Create(item)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.WithStack(result.Error)&lt;br/&gt;}&lt;br/&gt;// QuestionDal、QuestionModelDal...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;service 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewProjectService(projectDal *dal.ProjectDal, questionDal *dal.QuestionDal, questionModelDal *dal.QuestionModelDal) *ProjectService {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;projectService{&lt;br/&gt;      ProjectDal:       projectDal,&lt;br/&gt;      QuestionDal:      questionDal,&lt;br/&gt;      QuestionModelDal: questionModelDal,&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectService struct {&lt;br/&gt;   ProjectDal       *dal.ProjectDal&lt;br/&gt;   QuestionDal      *dal.QuestionDal&lt;br/&gt;   QuestionModelDal *dal.QuestionModelDal&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (s *ProjectService) Create(ctx context.Context, projectBo *bo.ProjectCreateBo) (int64, error) {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;handler 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewProjectHandler(srv *service.ProjectService) *ProjectHandler{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;ProjectHandler{&lt;br/&gt;        ProjectService: srv&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectHandler struct {&lt;br/&gt;   ProjectService *service.ProjectService&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (s *ProjectHandler) CreateProject(ctx context.Context, req *project.CreateProjectRequest) (resp *&lt;br/&gt;project.CreateProjectResponse, err error) {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;injector.go 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewInjector()(handler *handler.ProjectHandler) *Injector{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;Injector{&lt;br/&gt;        ProjectHandler: handler&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Injector struct {&lt;br/&gt;   ProjectHandler *handler.ProjectHandler&lt;br/&gt;   // components，others...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 wire.go 中如下定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// +build wireinject&lt;br/&gt;&lt;br/&gt;package app&lt;br/&gt;&lt;br/&gt;func BuildInjector() (*Injector, error) {&lt;br/&gt;   wire.Build(&lt;br/&gt;      NewInjector,&lt;br/&gt;&lt;br/&gt;      // handler&lt;br/&gt;      handler.NewProjectHandler,&lt;br/&gt;&lt;br/&gt;      // services&lt;br/&gt;      service.NewProjectService,&lt;br/&gt;      // 更多service...&lt;br/&gt;&lt;br/&gt;      //dal&lt;br/&gt;      dal.NewProjectDal,&lt;br/&gt;      dal.NewQuestionDal,&lt;br/&gt;      dal.NewQuestionModelDal,&lt;br/&gt;      // 更多dal...&lt;br/&gt;&lt;br/&gt;      // db&lt;br/&gt;      common.InitGormDB,&lt;br/&gt;      // other components...&lt;br/&gt;   )&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; new(Injector), nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 &lt;code&gt;wire gen ./internal/app/wire.go&lt;/code&gt; 生成 wire_gen.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// Code generated by Wire. DO NOT EDIT.&lt;br/&gt;&lt;br/&gt;//go:generate wire&lt;br/&gt;//+build !wireinject&lt;br/&gt;&lt;br/&gt;func BuildInjector() (*Injector, error) {&lt;br/&gt;   db, err := common.InitGormDB()&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt;   }&lt;br/&gt;   &lt;br/&gt;   projectDal := dal.NewProjectDal(db)&lt;br/&gt;   questionDal := dal.NewQuestionDal(db)&lt;br/&gt;   questionModelDal := dal.NewQuestionModelDal(db)&lt;br/&gt;   projectService := service.NewProjectService(projectDal, questionDal, questionModelDal)&lt;br/&gt;   projectHandler := handler.NewProjectHandler(projectService)&lt;br/&gt;   injector := NewInjector(projectHandler)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; injector, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main.go 中加入初始化 injector 的方法 &lt;code&gt;app.BuildInjector&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;injector, err := BuildInjector()&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; err != nil {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;//project服务启动&lt;br/&gt;svr := projectservice.NewServer(injector.ProjectHandler, logOpt)&lt;br/&gt;svr.Run()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，如果你运行时，出现了 &lt;code&gt;BuildInjector&lt;/code&gt; 重定义，那么检查一下你的 &lt;code&gt;//+build wireinject&lt;/code&gt; 与 &lt;code&gt;package app&lt;/code&gt; 这两行之间是否有空行，这个空行必须要有！见https://github.com/google/wire/issues/117&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 高级特性&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.1 NewSet&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NewSet&lt;/code&gt; 一般应用在初始化对象比较多的情况下，减少 &lt;code&gt;Injector&lt;/code&gt; 里面的信息。当我们项目庞大到一定程度时，可以想象会出现非常多的 Providers。&lt;code&gt;NewSet&lt;/code&gt; 帮我们把这些 Providers 按照业务关系进行分组，组成 &lt;code&gt;ProviderSet&lt;/code&gt;（构造器集合），后续只需要使用这个集合即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// project.go&lt;br/&gt;var ProjectSet = wire.NewSet(NewProjectHandler, NewProjectService, NewProjectDal)&lt;br/&gt;&lt;br/&gt;// wire.go&lt;br/&gt;func BuildInjector() (*Injector, error) {&lt;br/&gt;   wire.Build(InitGormDB, ProjectSet, NewInjector)&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; new(Injector), nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.2 Struct&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述例子的 &lt;code&gt;Provider&lt;/code&gt; 都是函数，除函数外，结构体也可以充当 &lt;code&gt;Provider&lt;/code&gt; 的角色。&lt;code&gt;Wire&lt;/code&gt; 给我们提供了&lt;strong&gt;结构构造器&lt;/strong&gt;（Struct Provider）。结构构造器创建某个类型的结构，然后用参数或调用其它构造器填充它的字段。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// project_service.go&lt;br/&gt;// 函数provider&lt;br/&gt;func NewProjectService(projectDal *dal.ProjectDal, questionDal *dal.QuestionDal, questionModelDal *dal.QuestionModelDal) *ProjectService {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &amp;amp;projectService{&lt;br/&gt;      ProjectDal:       projectDal,&lt;br/&gt;      QuestionDal:      questionDal,&lt;br/&gt;      QuestionModelDal: questionModelDal,&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 等价于&lt;br/&gt;wire.Struct(new(ProjectService), &lt;span&gt;&quot;*&quot;&lt;/span&gt;) // &lt;span&gt;&quot;*&quot;&lt;/span&gt;代表全部字段注入&lt;br/&gt;&lt;br/&gt;// 也等价于&lt;br/&gt;wire.Struct(new(ProjectService), &lt;span&gt;&quot;ProjectDal&quot;&lt;/span&gt;, &lt;span&gt;&quot;QuestionDal&quot;&lt;/span&gt;, &lt;span&gt;&quot;QuestionModelDal&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// 如果个别属性不想被注入，那么可以修改 struct 定义:&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; App struct {&lt;br/&gt;    Foo *Foo&lt;br/&gt;    Bar *Bar&lt;br/&gt;    NoInject int `wire:&lt;span&gt;&quot;-&quot;&lt;/span&gt;`&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.3 Bind&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Bind&lt;/code&gt; 函数的作用是为了让接口类型的依赖参与 &lt;code&gt;Wire&lt;/code&gt; 的构建。&lt;code&gt;Wire&lt;/code&gt; 的构建依靠参数类型，接口类型是不支持的。&lt;code&gt;Bind&lt;/code&gt; 函数通过将接口类型和实现类型绑定，来达到依赖注入的目的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// project_dal.go&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; IProjectDal interface {&lt;br/&gt;   Create(ctx context.Context, item *entity.Project) (err error)&lt;br/&gt;   // ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectDal struct {&lt;br/&gt;   DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;var &lt;span&gt;bind&lt;/span&gt; = wire.Bind(new(IProjectDal), new(*ProjectDal))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;4.2.4 CleanUp&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造器可以提供一个清理函数(cleanup)，如果后续的构造器返回失败，前面构造器返回的清理函数都会调用。初始化 &lt;code&gt;Injector&lt;/code&gt; 之后可以获取到这个清理函数，清理函数典型的应用场景是文件资源和网络连接资源。清理函数通常作为第二返回值，参数类型为 &lt;code&gt;func()&lt;/code&gt;。当 &lt;code&gt;Provider&lt;/code&gt; 中的任何一个拥有清理函数，&lt;code&gt;Injector&lt;/code&gt; 的函数返回值中也必须包含该函数。并且 &lt;code&gt;Wire&lt;/code&gt; 对 &lt;code&gt;Provider&lt;/code&gt; 的返回值个数及顺序有以下限制：&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一个返回值是需要生成的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有 2 个返回值，第二个返回值必须是 func() 或 error&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有 3 个返回值，第二个返回值必须是 func()，而第三个返回值必须是 error&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// db.go&lt;br/&gt;func InitGormDB()(*gorm.DB, func(), error) {&lt;br/&gt;    // 初始化db链接&lt;br/&gt;    // ...&lt;br/&gt;    cleanFunc := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        db.Close()&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; db, cleanFunc, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// wire.go&lt;br/&gt;func BuildInjector() (*Injector, func(), error) {&lt;br/&gt;   wire.Build(&lt;br/&gt;      common.InitGormDB,&lt;br/&gt;      // ...&lt;br/&gt;      NewInjector&lt;br/&gt;   )&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; new(Injector), nil, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 生成的wire_gen.go&lt;br/&gt;func BuildInjector() (*Injector, func(), error) {&lt;br/&gt;   db, cleanup, err := common.InitGormDB()&lt;br/&gt;   // ...&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; injector, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;       // 所有provider的清理函数都会在这里&lt;br/&gt;       cleanup()&lt;br/&gt;   }, nil&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// main.go&lt;br/&gt;injector, cleanFunc, err := app.BuildInjector()&lt;br/&gt;defer cleanFunc()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多用法具体可以参考 wire官方指南：https://github.com/google/wire/blob/main/docs/guide.md&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.3 高阶使用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我们就用上述的这些 &lt;code&gt;wire&lt;/code&gt; 高级特性对 &lt;code&gt;project&lt;/code&gt; 服务进行代码改造：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;project_dal.go&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; IProjectDal interface {&lt;br/&gt;   Create(ctx context.Context, item *entity.Project) (err error)&lt;br/&gt;   // ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectDal struct {&lt;br/&gt;   DB *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// wire.Struct方法是wire提供的构造器，&lt;span&gt;&quot;*&quot;&lt;/span&gt;代表为所有字段注入值，在这里可以用&lt;span&gt;&quot;DB&quot;&lt;/span&gt;代替&lt;br/&gt;// wire.Bind方法把接口和实现绑定起来&lt;br/&gt;var ProjectSet = wire.NewSet(&lt;br/&gt;   wire.Struct(new(ProjectDal), &lt;span&gt;&quot;*&quot;&lt;/span&gt;),&lt;br/&gt;   wire.Bind(new(IProjectDal), new(*ProjectDal)))&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;func (dal *ProjectDal) Create(ctx context.Context, item *entity.Project) error {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-wrap=&quot;false&quot;&gt;&lt;span&gt;dal.go&lt;/span&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// DalSet dal注入&lt;br/&gt;var DalSet = wire.NewSet(&lt;br/&gt;   ProjectSet,&lt;br/&gt;   // QuestionDalSet、QuestionModelDalSet...&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;project_service.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; IProjectService interface {&lt;br/&gt;   Create(ctx context.Context, projectBo *bo.CreateProjectBo) (int64, error)&lt;br/&gt;   // ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectService struct {&lt;br/&gt;   ProjectDal       dal.IProjectDal&lt;br/&gt;   QuestionDal      dal.IQuestionDal&lt;br/&gt;   QuestionModelDal dal.IQuestionModelDal&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;func (s *ProjectService) Create(ctx context.Context, projectBo *bo.ProjectCreateBo) (int64, error) {}&lt;br/&gt;&lt;br/&gt;var ProjectSet = wire.NewSet(&lt;br/&gt;   wire.Struct(new(ProjectService), &lt;span&gt;&quot;*&quot;&lt;/span&gt;),&lt;br/&gt;   wire.Bind(new(IProjectService), new(*ProjectService)))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;service.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// ServiceSet service注入&lt;br/&gt;var ServiceSet = wire.NewSet(&lt;br/&gt;   ProjectSet,&lt;br/&gt;   // other service &lt;span&gt;set&lt;/span&gt;...&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;handler 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var ProjectHandlerSet = wire.NewSet(wire.Struct(new(ProjectHandler), &lt;span&gt;&quot;*&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; ProjectHandler struct {&lt;br/&gt;   ProjectService service.IProjectService&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (s *ProjectHandler) CreateProject(ctx context.Context, req *project.CreateProjectRequest) (resp *&lt;br/&gt;project.CreateProjectResponse, err error) {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;injector.go 伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var InjectorSet = wire.NewSet(wire.Struct(new(Injector), &lt;span&gt;&quot;*&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Injector struct {&lt;br/&gt;   ProjectHandler *handler.ProjectHandler&lt;br/&gt;   // others...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wire.go&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; // +build wireinject&lt;br/&gt;&lt;br/&gt;package app&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;func BuildInjector() (*Injector, func(), error) {&lt;br/&gt;   wire.Build(&lt;br/&gt;      // db&lt;br/&gt;      common.InitGormDB,&lt;br/&gt;      // dal&lt;br/&gt;      dal.DalSet,&lt;br/&gt;      // services&lt;br/&gt;      service.ServiceSet,&lt;br/&gt;      // handler&lt;br/&gt;      handler.ProjectHandlerSet,&lt;br/&gt;      // injector&lt;br/&gt;      InjectorSet,&lt;br/&gt;      // other components...&lt;br/&gt;   )&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; new(Injector), nil, nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;5. 注意事项&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.1 相同类型问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;wire 不允许不同的注入对象拥有相同的类型。google 官方认为这种情况，是设计上的缺陷。这种情况下，可以通过类型别名来将对象的类型进行区分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如服务会同时操作两个 Redis 实例，RedisA &amp;amp; RedisB&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func NewRedisA() *goredis.Client {...}&lt;br/&gt;func NewRedisB() *goredis.Client {...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这种情况，wire 无法推导依赖的关系。可以这样进行实现：&lt;/p&gt;&lt;pre data-wrap=&quot;false&quot;&gt;&lt;code&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; RedisCliA *goredis.Client&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RedisCliB *goredis.Client&lt;br/&gt;&lt;br/&gt;func NewRedisA() RedicCliA {...}&lt;br/&gt;func NewRedisB() RedicCliB {...}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 单例问题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖注入的本质是用单例来绑定接口和实现接口对象间的映射关系。而通常实践中不可避免的有些对象是有状态的，同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。针对这种场景我们通常设计多层的 DI 容器来实现单例隔离，亦或是脱离 DI 容器自行管理对象的生命周期。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;6. 结语&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wire 是一个强大的依赖注入工具。与 Inject 、Dig 等不同的是，Wire只生成代码而不是使用反射在运行时注入，不用担心会有性能损耗。项目工程化过程中，Wire 可以很好协助我们完成复杂对象的构建组装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 Wire 的介绍请传送至：https://github.com/google/wire&lt;/p&gt;&lt;/section&gt;&lt;p&gt;7. 关于我们&lt;/p&gt;&lt;p&gt;我们来自字节跳动飞书商业应用研发部（Lark Business Applications），目前我们在北京、深圳、上海、武汉、杭州、成都、广州、三亚都设立了办公区域。我们关注的产品领域主要在企业经验管理软件上，包括飞书 OKR、飞书绩效、飞书招聘、飞书人事等 HCM 领域系统，也包括飞书审批、OA、法务、财务、采购、差旅与报销等系统。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>