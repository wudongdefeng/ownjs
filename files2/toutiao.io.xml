<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>88307074ee4f675cef9f6af4a0de7a37</guid>
<title>聊聊 13 种锁的实现方式</title>
<link>https://toutiao.io/k/wcwg3fn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;大家好，我是Tom哥。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有很多小伙伴给我留言，分布式系统时代，线程并发，资源抢占，&quot;锁&quot; 慢慢变得很重要。那么常见的锁都有哪些？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天Tom哥就和大家简单聊聊这个话题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1、悲观锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如其名，它是指对数据修改时持保守态度，认为其他人也会修改数据。因此在操作数据时，会把数据锁住，直到操作完成。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。如果加锁的时间过长，其他用户长时间无法访问，影响程序的并发访问性，同时这样对数据库性能开销影响也很大，特别是长事务而言，这样的开销往往无法承受。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是单机系统，我们可以采用 JAVA 自带的 &lt;code&gt;synchronized&lt;/code&gt; 关键字，通过添加到方法或同步块上，锁住资源
如果是分布式系统，我们可以借助数据库自身的锁机制来实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select * from 表名 &lt;span&gt;where&lt;/span&gt; id= &lt;span&gt;#{id} for update&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用悲观锁的时候，我们要注意锁的级别，MySQL innodb 在加锁时，只有明确的指定主键或（索引字段）才会使用 &lt;code&gt;行锁&lt;/code&gt;；否则，会执行 &lt;code&gt;表锁&lt;/code&gt;，将整个表锁住，此时性能会很差。在使用悲观锁时，我们必须关闭 MySQL 数据库的自动提交属性，因为mysql默认使用自动提交模式。悲观锁适用于写多的场景，而且并发性能要求不高&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、乐观锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乐观锁，从字面意思也能猜到个大概，在操作数据时非常乐观，认为别人不会同时修改数据，因此乐观锁不会上锁
只是在 &lt;code&gt;提交更新&lt;/code&gt; 时，才会正式对数据的冲突与否进行检测。如果发现冲突了，则返回错误信息，让用户决定如何去做，&lt;code&gt;fail-fast 机制&lt;/code&gt; 。否则，执行本次操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分为三个阶段：数据读取、写入校验、数据写入。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果是单机系统&lt;/strong&gt;，我们可以基于JAVA 的 CAS来实现，CAS 是一种原子操作，借助硬件的比较并交换来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果是分布式系统&lt;/strong&gt;，我们可以在数据库表中增加一个 &lt;code&gt;版本号&lt;/code&gt; 字段，如：version&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;update 表 &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; ... , version = version +1 &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; id= &lt;span&gt;#{id} and version = #{version} &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作前，先读取记录的版本号，更新时，通过SQL语句比较版本号是否一致。如果一致，则更新数据。否则会再次读取版本，重试上面的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3、分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAVA 中的 &lt;code&gt;synchronized&lt;/code&gt; 、&lt;code&gt;ReentrantLock&lt;/code&gt; 等，都是解决单体应用单机部署的资源互斥问题。随着业务快速发展，当单体应用演化为分布式集群后，多线程、多进程分布在不同的机器上，原来的单机并发控制锁策略失效&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时我们需要引入 &lt;code&gt;分布式锁&lt;/code&gt;，解决跨机器的互斥机制来控制共享资源的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁需要具备哪些条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与单机系统一样的资源互斥功能，这是锁的基础&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能获取、释放锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具备可重入性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有锁失效机制，防止死锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非阻塞，不管是否获得锁，要能快速返回&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式多种多样，基于 &lt;code&gt;数据库&lt;/code&gt;、&lt;code&gt;Redis&lt;/code&gt;、以及 &lt;code&gt;Zookeeper&lt;/code&gt;等，这里讲下主流的基于Redis的实现方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SET key unique_value  [EX seconds] [PX milliseconds] [NX|XX]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过原子命令，如果执行成功返回 1，则表示加锁成功。注意：unique_value 是客户端生成的唯一标识，区分来自不同客户端的锁操作
解锁要特别注意，先判断 &lt;code&gt;unique_value&lt;/code&gt; 是不是加锁的客户端，是的话才允许解锁删除。毕竟我们不能删除其他客户端加的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解锁：解锁有两个命令操作，需要借助 Lua 脚本来保证原子性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 先比较 unique_value 是否相等，避免锁的误释放&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&quot;get&quot;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&quot;del&quot;&lt;/span&gt;,KEYS[1])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助 Redis 的高性能，Redis 实现分布式锁也是目前主流实现方式。但任何事情有利有弊，如果加锁的服务器宕机了，当slave 节点还没来得及数据备份，那不是别的客户端也可以获得锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，Redis 官方设计了一个分布式锁 Redlock。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基本思路&lt;/strong&gt;：让客户端与多个独立的 Redis 节点并行请求申请加锁，如果能在半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4、可重入锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可重入锁，也叫做递归锁，是指在同一个线程在调外层方法获取锁的时候，再进入内层方法会自动获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象锁或类锁内部有计数器，一个线程每获得一次锁，计数器 +1；解锁时，计数器 -1。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有多少次加锁，就要对应多少次解锁，加锁与解锁成对出现。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JAVA 中的 &lt;code&gt;ReentrantLock&lt;/code&gt; 和 &lt;code&gt;synchronized&lt;/code&gt; 都是 可重入锁。可重入锁的一个好处是可一定程度避免死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5、自旋锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁是采用让当前线程不停地在循环体内执行，当循环的条件被其他线程改变时才能进入临界区。自旋锁只是将当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度更快。但当线程数不断增加时，性能下降明显，因为每个线程都需要执行，会占用CPU时间片。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自旋锁缺点：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以设置一个 &lt;code&gt;循环时间&lt;/code&gt; 或 &lt;code&gt;循环次数&lt;/code&gt;，超出阈值时，让线程进入阻塞状态，防止线程长时间占用 CPU 资源。JUC 并发包中的 CAS 就是采用自旋锁，compareAndSet 是CAS操作的核心，底层利用&lt;code&gt;Unsafe&lt;/code&gt;对象实现的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public final int getAndAddInt(Object var1, long var2, int var4) {&lt;br/&gt;    int var5;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        var5 = this.getIntVolatile(var1, var2);&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt;(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; var5;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果内存中 var1 对象的var2字段值等于预期的 var5，则将该位置更新为新值（var5 + var4），否则不进行任何操作，一直重试，直到操作成功为止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CAS 包含了Compare和Swap 两个操作，如何保证原子性呢？CAS 是由 CPU 支持的原子操作，其原子性是在硬件层面进行控制。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别注意，CAS 可能导致 ABA 问题，我们可以引入递增版本号来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6、独享锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;独享锁，也有人叫它排他锁。无论读操作还是写操作，只能有一个线程获得锁，其他线程处于阻塞状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：读操作并不会修改数据，而且大部分的系统都是 &lt;code&gt;读多写少&lt;/code&gt;，如果读读之间互斥，大大降低系统的性能。下面的 &lt;code&gt;共享锁&lt;/code&gt; 会解决这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像JAVA 中的 &lt;code&gt;ReentrantLock&lt;/code&gt; 和 &lt;code&gt;synchronized&lt;/code&gt; 都是独享锁&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;7、共享锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享锁是指允许多个线程同时持有锁，一般用在读锁上。读锁的共享锁可保证并发读是非常高效的。读写，写读 ，写写的则是互斥的。独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantReadWriteLock，其读锁是共享锁，其写锁是独享锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;8、读锁/写锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对某个资源是读操作，那多个线程之间并不会相互影响，可以通过添加读锁实现共享。如果有修改动作，为了保证数据的并发安全，此时只能有一个线程获得锁，我们称之为 写锁。读读是共享的；而 读写、写读 、写写 则是互斥的&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;像 JAVA 中的 ReentrantReadWriteLock 就是一种 读写锁&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9、公平锁/非公平锁&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公平锁&lt;/strong&gt;：多个线程按照申请锁的顺序去获得锁，所有线程都在队列里排队，先来先获取的公平性原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：所有的线程都能得到资源，不会饿死在队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，CPU 唤醒下一个阻塞线程有系统开销&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40285714285714286&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcunshF0K1SZgUyWZlDru0hZxYlhMFbhH2ibQ6zAL3709Ix1fItIme5bg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非公平锁&lt;/strong&gt;：多个线程不按照申请锁的顺序去获得锁，而是同时以插队方式直接尝试获取锁，获取不到（插队失败），会进入队列等待（失败则乖乖排队），如果能获取到（插队成功），就直接获取到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点&lt;/strong&gt;：可以减少 CPU 唤醒线程的开销，整体的吞吐效率会高点&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点&lt;/strong&gt;：可能导致队列中排队的线程一直获取不到锁或者长时间获取不到锁，活活饿死。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 多线程并发操作，我们操作锁大多时候都是基于 &lt;code&gt;Sync&lt;/code&gt; 本身去实现的，而 Sync 本身却是 &lt;code&gt;ReentrantLock&lt;/code&gt; 的一个内部类，Sync 继承 &lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像 ReentrantLock 默认是非公平锁，我们可以在构造函数中传入 true，来创建公平锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public ReentrantLock(boolean fair) {&lt;br/&gt;    sync = fair ? new FairSync() : new NonfairSync();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;10、可中断锁/不可中断锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可中断锁：指一个线程因为没有获得锁在阻塞等待过程中，可以中断自己阻塞的状态。不可中断锁：恰恰相反，如果锁被其他线程获取后，当前线程只能阻塞等待。如果持有锁的线程一直不释放锁，那其他想获取锁的线程就会一直阻塞。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;内置锁 synchronized 是不可中断锁，而 ReentrantLock 是可中断锁。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock获取锁定有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;lock()， 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于阻塞状态，直到该线程获取锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock()， 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lockInterruptibly()，如果获取了锁定立即返回；如果没有获取锁，线程处于阻塞状态，直到获取锁或者线程被别的线程中断&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多：https://github.com/aalansehaiyang/p-java-proof/blob/master/resource/17.md&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;11、分段锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分段锁其实是一种锁的设计，目的是细化锁的粒度，并不是具体的一种锁，&lt;code&gt;对于ConcurrentHashMap&lt;/code&gt; 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConcurrentHashMap&lt;/code&gt;中的分段锁称为Segment，它即类似于HashMap（JDK7 中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当需要put元素的时候，并不是对整个HashMap加锁，而是先通过hashcode知道要放在哪一个分段中，然后对这个分段加锁，所以当多线程put时，只要不是放在同一个分段中，可支持并行插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;12、锁升级（无锁|偏向锁|轻量级锁|重量级锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JDK 1.6之前，synchronized 还是一个重量级锁，效率比较低。但是在JDK 1.6后，JVM为了提高锁的获取与释放效率对 &lt;code&gt;synchronized&lt;/code&gt; 进行了优化，引入了偏向锁和轻量级锁 ，从此以后锁的状态就有了四种：无锁、偏向锁、轻量级锁、重量级锁。这四种状态会随着竞争的情况逐渐升级，而且是不可降级。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5917721518987342&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcOfFOmF8md1ElBuK301awbmlTWgJlevkiaIswy7c2CKIr7cEbPJY3xwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁并不会对资源锁定，所有的线程都可以访问并修改同一个资源，但同时只有一个线程能修改成功。也就是我们常说的乐观锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向于第一个访问锁的线程，初次执行&lt;code&gt;synchronized&lt;/code&gt;代码块时，通过 CAS 修改对象头里的锁标志位，锁对象变成偏向锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个线程访问同步代码块并获取锁时，会在 &lt;code&gt;Mark Word&lt;/code&gt; 里存储锁偏向的线程 ID。在线程进入和退出同步块时不再通过 CAS 操作来加锁和解锁，而是检测 &lt;code&gt;Mark Word&lt;/code&gt; 里是否存储着指向当前线程的偏向锁。轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID 的时候依赖一次 CAS 原子指令即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完同步代码块后，线程并不会主动释放偏向锁。当线程第二次再执行同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里不需要重新加锁，偏向锁几乎没有额外开销，性能极高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程是不会主动释放偏向锁的。关于偏向锁的撤销，需要等待全局安全点，即在某个时间点上没有字节码正在执行时，它会先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁，恢复到无锁（标志位为01）或轻量级锁（标志位为00）的状态。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏向锁是指当一段同步代码一直被同一个线程所访问时，即不存在多个线程的竞争时，那么该线程在后续访问时便会自动获得锁，从而降低获取锁带来的消耗。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前锁是偏向锁，此时有多个线程同时来竞争锁，偏向锁就会升级为轻量级锁。轻量级锁认为虽然竞争是存在的，但是理想情况下竞争的程度很低，通过自旋方式来获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;轻量级锁的获取有两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当关闭偏向锁功能时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个线程竞争偏向锁导致偏向锁升级为轻量级锁。一旦有第二个线程加入锁竞争，偏向锁就升级为轻量级锁（自旋锁）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，不停地循环判断锁是否能够被成功获取。获取锁的操作，其实就是通过CAS修改对象头里的锁标志位。先比较当前锁标志位是否为“释放”，如果是则将其设置为“锁定”，此过程是原子性。如果抢到锁，然后线程将当前锁的持有者信息修改为自己。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程的竞争很激励，线程的自旋超过了一定次数（默认循环10次，可以通过虚拟机参数更改），将轻量级锁升级为重量级锁（依然是 CAS  修改锁标志位，但不修改持有锁的线程ID），当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。简言之，就是所有的控制权都交给了操作系统，由操作系统来负责线程间的调度和线程的状态变更。而这样会出现频繁地对线程运行状态的切换，线程的挂起和唤醒，从而消耗大量的系统资。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;13、锁优化技术（锁粗化、锁消除）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁粗化&lt;/strong&gt;就是告诉我们任何事情都有个度，有些情况下我们反而希望把很多次锁的请求合并成一个请求，以降低短时间内大量锁请求、同步、释放带来的性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：有个循环体，内部&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(int i=0;i&amp;lt;size;i++){&lt;br/&gt;    synchronized(lock){&lt;br/&gt;        ...业务处理，省略&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过锁粗化的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;synchronized(lock){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(int i=0;i&amp;lt;size;i++){&lt;br/&gt;        ...业务处理，省略&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;锁消除&lt;/strong&gt;指的是在某些情况下，JVM 虚拟机如果检测不到某段代码被共享和竞争的可能性，就会将这段代码所属的同步锁消除掉，从而到底提高程序性能的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁消除的依据是逃逸分析的数据支持，如 &lt;code&gt;StringBuffer&lt;/code&gt; 的 &lt;code&gt;append()&lt;/code&gt; 方法，或 &lt;code&gt;Vector&lt;/code&gt; 的 &lt;code&gt;add()&lt;/code&gt; 方法，在很多情况下是可以进行锁消除的，比如以下这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public String &lt;span&gt;method&lt;/span&gt;() {&lt;br/&gt;    StringBuffer sb = new StringBuffer();&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; 10; i++) {&lt;br/&gt;        sb.append(&lt;span&gt;&quot;i:&quot;&lt;/span&gt; + i);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; sb.toString();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码经过编译之后的字节码如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49471830985915494&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfvDiaBqbZYbHulzXr5XjicTcBDESiaCyC6ySCHeYzkibm32Za8ZjphCyEObNluIccictJlYrxovJDW7IA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述结果可以看出，之前我们写的线程安全的加锁的 &lt;code&gt;StringBuffer&lt;/code&gt; 对象，在生成字节码之后就被替换成了不加锁不安全的 &lt;code&gt;StringBuilder&lt;/code&gt; 对象了，原因是 &lt;code&gt;StringBuffer&lt;/code&gt; 的变量属于一个局部变量，并且不会从该方法中逃逸出去，所以我们可以使用锁消除（不加锁）来加速程序的运行。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了。&lt;/strong&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.092130518234165&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdaSEqIP60fNXXqd7e15vycGo75wsfR2yTDKxOpJaKG0BKzFod8CQxLtibu2vMp1GKBMDJRbk3rpLw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/h2&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68a43fd66abd705e530a2bf3d5d45e74</guid>
<title>MySQL 单表不要超过 2000W 行，靠谱吗？</title>
<link>https://toutiao.io/k/vke55xi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;八股文网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作为在后端圈开车的多年老司机，是不是经常听到过：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些名言民语就和 “群里只讨论技术，不开车，开车速度不要超过 120 码，否则自动踢群”，只听过，没试过，哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就把车速踩到底，干到 180 码试试…….&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://my.oschina.net/u/4090830/blog/5559454&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实验&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验一把看看… 建一张表&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; person(&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;br/&gt;    person_id &lt;span&gt;tinyint&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户id&#x27;&lt;/span&gt;,&lt;br/&gt;    person_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_create datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_modified datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;修改时间&#x27;&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;人员信息表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入一条数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; person &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&#x27;user_1&#x27;&lt;/span&gt;, &lt;span&gt;NOW&lt;/span&gt;(), &lt;span&gt;now&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 MySQL 伪列 rownum 设置伪列起始点为 1&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; (@i:=@i+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;rownum&lt;/span&gt;, person_name &lt;span&gt;from&lt;/span&gt; person, (&lt;span&gt;select&lt;/span&gt; @i:=&lt;span&gt;100&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; init; &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; @i=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行下面的 sql，连续执行 20 次，就是 2 的 20 次方约等于 100w 的数据；执行 23 次就是 2 的 23 次方约等于 800w , 如此下去即可实现千万测试数据的插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想翻倍翻倍的增加数据，而是想少量，少量的增加，有个技巧，就是在 SQL 的后面增加 where 条件，如 id &amp;gt; 某一个值去控制增加的数据量即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; person(&lt;span&gt;id&lt;/span&gt;, person_id, person_name, gmt_create, gmt_modified)&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; @i:=@i+&lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;&lt;span&gt;left&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; person_id,&lt;br/&gt;&lt;span&gt;concat&lt;/span&gt;(&lt;span&gt;&#x27;user_&#x27;&lt;/span&gt;,@i%&lt;span&gt;2048&lt;/span&gt;),&lt;br/&gt;&lt;span&gt;date_add&lt;/span&gt;(gmt_create,&lt;span&gt;interval&lt;/span&gt; + @i*&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;100&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;),&lt;br/&gt;&lt;span&gt;date_add&lt;/span&gt;(&lt;span&gt;date_add&lt;/span&gt;(gmt_modified,&lt;span&gt;interval&lt;/span&gt; +@i*&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;100&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;), &lt;span&gt;interval&lt;/span&gt; + &lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;rand&lt;/span&gt;()*&lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; signed) &lt;span&gt;SECOND&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; person;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此处需要注意的是，也许你在执行到近 800w 或者 1000w 数据的时候，会报错：The total number of locks exceeds the lock table size，这是由于你的临时表内存设置的不够大，只需要扩大一下设置参数即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;GLOBAL&lt;/span&gt; tmp_table_size =&lt;span&gt;512&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;; （512M）&lt;br/&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; innodb_buffer_pool_size= &lt;span&gt;1&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;G);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一组测试数据，这组数据是在 mysql8.0 的版本，并且是在我本机上，由于本机还跑着 idea , 浏览器等各种工具，所以并不是机器配置就是用于数据库配置，所以测试数据只限于参考。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0051724137931035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ45PQnsbR4AEU5bWeV63MMeibKeC71ySplF7VKwyrhShqJMPYDgxKFSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5920084121976866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJwibXjO8NvKicvibic5bEibibS6AyeQ9Zps19eibWoy2nx9Bt5ia00LB3Ql0Rww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这组数据似乎好像真的和标题对应，当数据达到 2000w 以后，查询时长急剧上升，难道这就是铁律吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那下面我们就来看看这个建议值 2000w 是怎么来的？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单表数量限制&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先想想数据库单表行数最大多大？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; person(&lt;br/&gt;    &lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;主键&#x27;&lt;/span&gt;,&lt;br/&gt;    person_id &lt;span&gt;tinyint&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户id&#x27;&lt;/span&gt;,&lt;br/&gt;    person_name &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_create datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;    gmt_modified datetime &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;修改时间&#x27;&lt;/span&gt;&lt;br/&gt;) &lt;span&gt;comment&lt;/span&gt; &lt;span&gt;&#x27;人员信息表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看上面的建表 sql，id 是主键，本身就是唯一的，也就是说主键的大小可以限制表的上限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果主键声明 int 大小，也就是 32 位，那么支持  2^32-1 ~~21 亿；如果是 bigint，那就是 2^62-1 （36893488147419103232），难以想象这个的多大了，一般还没有到这个限制之前，可能数据库已经爆满了！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人统计过，如果建表的时候，自增字段选择无符号的 bigint , 那么自增长最大值是 18446744073709551615，按照一秒新增一条记录的速度，大约什么时候能用完？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47919876733436056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ5cSuI591aK3E19WbHrrWfwNnibsYRxXDiaWKUPjJEoCcCxSDvT3lbZLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;表空间&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们再来看看索引的结构，对了，我们下面讲内容都是基于 Innodb 引擎的，大家都知道 Innodb 的索引内部用的是 B+ 树&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36614645858343337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJYIzmywUhcpUtMVWHtFygVPA5bViamj0lnUDOkVlE2hQhEv52Dvux9MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张表数据，在硬盘上存储也是类似如此的，它实际是放在一个叫 person.ibd （innodb data）的文件中，也叫做表空间；虽然数据表中，他们看起来是一条连着一条，但是实际上在文件中它被分成很多小份的数据页，而且每一份都是 16K。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概就像下面这样，当然这只是我们抽象出来的，在表空间中还有段、区、组等很多概念，但是我们需要跳出来看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.471976401179941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJ4mPc7cEFaqRo5UfVhQygf7HFzqpPokyUcibLzUFjLafB4ttBQgru6mQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;页的数据结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际页的内部结构像是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5765575501583949&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJibVenqMqgd8dworIOPxC6nibol2sNP1Msiaqa18tEUl7s1cfbDGsRwysw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;947&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中可以看出，一个 InnoDB 数据页的存储空间大致被划分成了 7 个部分，有的部分占用的字节数是确定的，有的部分占用的字节数是不确定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在页的 7 个组成部分中，我们自己存储的记录会按照我们指定的行格式存储到 User Records 部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在一开始生成页的时候，其实并没有 User Records 这个部分，每当我们插入一条记录，都会从 Free Space 部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到 User Records 部分，当 Free Space 部分的空间全部被 User Records 部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去申请新的页了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程的图示如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.375366568914956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJsqsPhia9VsVzE0dmzxKJTw1OzlHTQbANcgFKYT5xpEvicNAMAXECB7gQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚刚上面说到了数据的新增的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那下面就来说说，数据的查找过程，假如我们需要查找一条记录，我们可以把表空间中的每一页都加载到内存中，然后对记录挨个判断是不是我们想要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据量小的时候，没啥问题，内存也可以撑。但是现实就是这么残酷，不会给你这个局面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这问题，mysql 中就有了索引的概念，大家都知道索引能够加快数据的查询，那到底是怎么个回事呢？下面我就来看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引的数据结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 mysql 中索引的数据结构和刚刚描述的页几乎是一模一样的，而且大小也是 16K,。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在索引页中记录的是页 (数据页，索引页) 的最小主键 id 和页号，以及在索引页中增加了层级的信息，从 0 开始往上算，所以页与页之间就有了上下层级的概念。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48558558558558557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJtufeRkPy7ldHgkBtRC2KUtfSRZqcdrd3gkQUbmw1YubI1DNPE6bibuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这个图之后，是不是有点似曾相似的感觉，是不是像一棵二叉树啊，对，没错！它就是一棵树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只不过我们在这里只是简单画了三个节点，2 层结构的而已，如果数据多了，可能就会扩展到 3 层的树，这个就是我们常说的 B+ 树，最下面那一层的 page level =0, 也就是叶子节点，其余都是非叶子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0617283950617284&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJbOUrteLtJbMUemysXicIqkriaUCbCPUepDNVk3lNvTVL8bcccsia2O1Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上图中，我们是单拿一个节点来看，首先它是一个非叶子节点（索引页），在它的内容区中有 id 和 页号地址两部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;id ：对应页中记录的最小记录 id 值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页号：地址是指向对应页的指针；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而数据页与此几乎大同小异，区别在于数据页记录的是真实的行数据而不是页地址，而且 id 的也是顺序的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;单表建议值&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就以 3 层，2 分叉（实际中是 M 分叉）的图例来说明一下查找一个行数据的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4824242424242424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJk58cx4v6TOno59eWiaMzSM5asBjSqsK3vxAWMggajMDJHMpQs5DBxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1650&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说我们需要查找一个 id=6 的行数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;因为在非叶子节点中存放的是页号和该页最小的 id，所以我们从顶层开始对比，首先看页号 10 中的目录，有 [id=1, 页号 = 20],[id=5, 页号 = 30], 说明左侧节点最小 id 为 1，右侧节点最小 id 是 5。6&amp;gt;5, 那按照二分法查找的规则，肯定就往右侧节点继续查找；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到页号 30 的节点后，发现这个节点还有子节点（非叶子节点），那就继续比对，同理，6&amp;gt;5 &amp;amp;&amp;amp; 6&amp;lt;7, 所以找到了页号 60；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到页号 60 之后，发现此节点为叶子节点（数据节点），于是将此页数据加载至内存进行一一对比，结果找到了 id=6 的数据行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述的过程中发现，我们为了查找 id=6 的数据，总共查询了三个页，如果三个页都在磁盘中（未提前加载至内存），那么最多需要经历三次的磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，图中的页号只是个示例，实际情况下并不是连续的，在磁盘中存储也不一定是顺序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们大概已经了解了表的数据是怎么个结构了，也大概知道查询数据是个怎么的过程了，这样我们也就能大概估算这样的结构能存放多少数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的图解我们知道 B+ 数的叶子节点才是存在数据的，而非叶子节点是用来存放索引数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，同样一个 16K 的页，非叶子节点里的每条数据都指向新的页，而新的页有两种可能&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果是叶子节点，那么里面就是一行行的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果是非叶子节点的话，那么就会继续指向新的页&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;非叶子节点内指向其他页的数量为 x&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点内能容纳的数据行数为 y&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 数的层数为 z&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图中所示，&lt;strong&gt;Total =x^(z-1) *y 也就是说总数会等于 x 的 z-1 次方 与 Y 的乘积&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4885844748858447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZd2mkomQSYKGgGoXmUibHfwJHdbdnBVRkiaA5TnQIckgz6n6Nlz749UJxOGGBLzK5cHjgnpNUtufK1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;X =？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章的开头已经介绍了页的结构，索引也也不例外，都会有 File Header (38 byte)、Page Header (56 Byte)、Infimum + Supermum（26 byte）、File Trailer（8byte）, 再加上页目录，大概 1k 左右。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就当做它就是 1K, 那整个页的大小是 16K, 剩下 15k 用于存数据，在索引页中主要记录的是主键与页号，主键我们假设是 Bigint (8 byte), 而页号也是固定的（4Byte）, 那么索引页中的一条数据也就是 12byte。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 x=15*1024/12≈1280 行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Y=？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;叶子节点和非叶子节点的结构是一样的，同理，能放数据的空间也是 15k。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是叶子节点中存放的是真正的行数据，这个影响的因素就会多很多，比如，字段的类型，字段的数量。每行数据占用空间越大，页中所放的行数量就会越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这边我们暂时按一条行数据 1k 来算，那一页就能存下 15 条，Y = 15*1024/1000  ≈15。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算到这边了，是不是心里已经有谱了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上述的公式，Total =x^(z-1) *y，已知 x=1280，y=15：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;假设 B+ 树是两层，那就是 z = 2， Total = （1280 ^1 ）*15 = 19200&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;假设 B+ 树是三层，那就是 z = 3， Total = （1280 ^2） *15 = 24576000 （约 2.45kw）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎呀，妈呀！这不是正好就是文章开头说的最大行数建议值 2000w 嘛！对的，一般 B+ 数的层级最多也就是 3 层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你试想一下，如果是 4 层，除了查询的时候磁盘 IO 次数会增加，而且这个 Total 值会是多少，大概应该是 3 百多亿吧，也不太合理，所以，3 层应该是比较合理的一个值。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;到这里难道就完了？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚在说 Y 的值时候假设的是 1K ，那比如我实际当行的数据占用空间不是 1K , 而是 5K, 那么单个数据页最多只能放下 3 条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，还是按照 z = 3 的值来计算，那 Total = （1280 ^2） *3 = 4915200 （近 500w）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 为了提高性能，会将表的索引装载到内存中，在 InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Mysql 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引结构不会影响单表最大行数，2000w 也只是推荐值，超过了这个值可能会导致 B + 树层级更高，影响查询性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;&lt;span&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;28&quot;&gt;图解系列文章：&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247507000&amp;amp;idx=1&amp;amp;sn=c045101b45dd70ec37f9b81361b09f14&amp;amp;chksm=f98d9892cefa1184ac8e278e468a8a225cd5a6f4c3dfba83ed223c5da69421041961bfb945cc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小林的网站上线啦！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;24&quot; hasload=&quot;1&quot;&gt;小林的网站上线啦！&lt;/a&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247492900&amp;amp;idx=1&amp;amp;sn=2c1d06a667b1e17e6d8caabff2bbb85b&amp;amp;chksm=f98da18ecefa28986109f13d28c1a06f304cb4d897eb2e931e79dc82d0b054ef6a9f7e1e4e91&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;小林的图解系统，大曝光！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;小林的图解系统，大曝光！&lt;/a&gt;&lt;br mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247491944&amp;amp;idx=1&amp;amp;sn=b90deba780ae3840668e21127e467b83&amp;amp;chksm=f98da5c2cefa2cd456045e9b2ed92837ed10e4a2c650f463b29ef5d7f8f4d01014d92225acad&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;不鸽了，小林的「图解网络 3.0 」发布！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;span&gt;不鸽了，小林的「图解网络 3.0 」发布！&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>069a73ca1f9f2834720ad72a805dbdd9</guid>
<title>剖析 SPI 在 Spring 中的应用</title>
<link>https://toutiao.io/k/c9o8fub</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;vivo 互联网服务器团队 - Ma Jian&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、概述&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SPI（Service Provider Interface），是Java内置的一种服务提供发现机制，可以用来提高框架的扩展性，主要用于框架的开发中，比如Dubbo，不同框架中实现略有差异，但核心机制相同，而Java的SPI机制可以为接口寻找服务实现。SPI机制将服务的具体实现转移到了程序外，为框架的扩展和解耦提供了极大的便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于SPI优秀的能力，为模块功能的动态扩展提供了很好的支撑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文会先简单介绍Java内置的SPI和Dubbo中的SPI应用，重点介绍分析Spring中的SPI机制，对比Spring SPI和Java内置的SPI以及与 Dubbo SPI的异同。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、Java SPI&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Java内置的SPI通过java.util.ServiceLoader类解析classPath和jar包的META-INF/services/目录 下的以接口全限定名命名的文件，并加载该文件中指定的接口实现类，以此完成调用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 Java SPI&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;先通过代码来了解下Java SPI的实现&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① 创建服务提供接口&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; jdk.spi;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DataBaseSPI&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;dataBaseOperation&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② 创建服务提供接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实现类1&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package jdk.spi.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import jdk.spi.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MysqlDataBaseSPIImpl implements DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;Operate Mysql database!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实现类2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package jdk.spi.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import jdk.spi.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class OracleDataBaseSPIImpl implements DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;Operate Oracle database!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;③ 在项目META-INF/services/目录下创建jdk.spi.DataBaseSPI文件&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.17671517671517672&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0NMqCsG5ibGdQ0ooXRXdGC2w4coX8vib9V7QbRiaYeoibu3asxicr22qg4Tw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;jdk.spi.DataBaseSPI&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;jdk.spi.impl.MysqlDataBaseSPIImpl&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;jdk.spi.impl.OracleDataBaseSPIImpl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;④ 运行代码： &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;JdkSpiTest#main()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package jdk.spi;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java.util.ServiceLoader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class JdkSpiTest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String args[]){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 加载jdk.spi.DataBaseSPI文件中DataBaseSPI的实现类(懒加载)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ServiceLoader&amp;lt;DataBaseSPI&amp;gt; dataBaseSpis = ServiceLoader.load(DataBaseSPI.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // ServiceLoader实现了Iterable，故此处可以使用for循环遍历加载到的实现类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for(DataBaseSPI spi : dataBaseSpis){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            spi.dataBaseOperation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;⑤ 运行结果：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Operate Mysql database!!!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Operate Oracle database!!!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 源码分析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;上述实现即为使用Java内置SPI实现的简单示例，ServiceLoader是Java内置的用于查找服务提供接口的工具类，通过调用load()方法实现对服务提供接口的查找(严格意义上此步并未真正的开始查找，只做初始化)，最后遍历来逐个访问服务提供接口的实现类。  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述访问服务实现类的方式很不方便，如：无法直接使用某个服务，需要通过遍历来访问服务提供接口的各个实现，到此很多同学会有疑问：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在分析源码之前先给出答案：两个都是的；Java内置的SPI机制只能通过遍历的方式访问服务提供接口的实现类，而且服务提供接口的配置文件也只能放在META-INF/services/目录下。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ServiceLoader部分源码&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ServiceLoader&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;S&lt;/span&gt;&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Iterable&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;S&lt;/span&gt;&amp;gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; String PREFIX = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;META-INF/services/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; Class&amp;lt;S&amp;gt; service;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; ClassLoader loader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; AccessControlContext acc;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; LinkedHashMap&amp;lt;String,S&amp;gt; providers = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; LazyIterator lookupIterator;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; &lt;span&gt;从源码中可以发现：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ServiceLoader类本身实现了Iterable接口并实现了其中的iterator方法，iterator方法的实现中调用了LazyIterator这个内部类中的方法，解析完服务提供接口文件后最终结果放在了Iterator中返回，并不支持服务提供接口实现类的直接访问。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;所有服务提供接口的对应文件都是放置在META-INF/services/目录下，final类型决定了PREFIX目录不可变更。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;所以Java内置的SPI机制思想是非常好的，但其内置实现上的不足也很明显。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、Dubbo SPI&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Dubbo SPI沿用了Java SPI的设计思想，但在实现上有了很大的改进，不仅可以直接访问扩展类，而且在访问的灵活性和扩展的便捷性都做了很大的提升。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 基本概念&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;① 扩展点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;一个Java接口，等同于服务提供接口，需用@SPI注解修饰。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;② 扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;扩展点的实现类。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;③ 扩展类加载器：ExtensionLoader&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;类似于Java SPI的ServiceLoader，主要用来加载并实例化扩展类。一个扩展点对应一个扩展加载器。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;④ Dubbo扩展文件加载路径&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Dubbo框架支持从以下三个路径来加载扩展类：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/dubbo/internal&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/dubbo&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/services&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dubbo框架针对三个不同路径下的扩展配置文件对应三个策略类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三个路径下的扩展配置文件并没有特殊之处，一般情况下：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;⑤ 扩展配置文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;和Java SPI不同，Dubbo的扩展配置文件中扩展类都有一个名称，便于在应用中引用它们。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;如：Dubbo SPI扩展配置文件&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;adaptive&lt;/span&gt;=org.apache.dubbo.common.compiler.support.AdaptiveCompiler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;jdk&lt;/span&gt;=org.apache.dubbo.common.compiler.support.JdkCompiler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;javassist&lt;/span&gt;=org.apache.dubbo.common.compiler.support.JavassistCompiler&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 Dubbo SPI&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; &lt;span&gt;先通过代码来演示下 Dubbo SPI 的实现。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① 创建扩展点(即服务提供接口)&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;扩展点&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; dubbo.spi;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; org.apache.dubbo.common.extension.SPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SPI&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DataBaseSPI&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;dataBaseOperation&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② 创建扩展点实现类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;扩展类1&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; dubbo.spi.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; dubbo.spi.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MysqlDataBaseSPIImpl&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DataBaseSPI&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;dataBaseOperation&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Dubbo SPI Operate Mysql database!!!&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;扩展类2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package dubbo.spi.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import dubbo.spi.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class OracleDataBaseSPIImpl implements DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;Dubbo SPI Operate Oracle database!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;③在项目META-INF/dubbo/目录下创建dubbo.spi.DataBaseSPI文件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1469387755102041&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0SvWNLVXCBzTCcWgV8ciczVTcEricldOyibS6WBj4ECW4ZcrjgotWNrdWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;dubbo.spi.DataBaseSPI&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#扩展实例名称=扩展点实现类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mysql = dubbo.spi.impl.MysqlDataBaseSPIImpl&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;oracle = dubbo.spi.impl.OracleDataBaseSPIImpl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;PS:文件内容中，等号左边为该扩展类对应的扩展实例名称，右边为扩展类(内容格式为一行一个扩展类，多个扩展类分为多行)&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;④&lt;span&gt; 运行代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;DubboSpiTest#main()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package dubbo.spi;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.apache.dubbo.common.extension.ExtensionLoader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class DubboSpiTest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String args[]){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 使用扩展类加载器加载指定扩展的实现&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ExtensionLoader&amp;lt;DataBaseSPI&amp;gt; dataBaseSpis = ExtensionLoader.getExtensionLoader(DataBaseSPI.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 根据指定的名称加载扩展实例(与dubbo.spi.DataBaseSPI中一致)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DataBaseSPI spi = dataBaseSpis.getExtension(&quot;mysql&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        spi.dataBaseOperation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DataBaseSPI spi2 = dataBaseSpis.getExtension(&quot;oracle&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        spi2.dataBaseOperation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;⑤ 运行结果：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Dubbo SPI Operate Mysql database!!!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Dubbo SPI Operate Oracle database!!!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;从上面的代码实现直观来看，Dubbo SPI在使用上和Java SPI比较类似，但也有差异。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;相同：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;扩展点即服务提供接口、扩展即服务提供接口实现类、扩展配置文件即services目录下的配置文件 三者相同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;都是先创建加载器然后访问具体的服务实现类，包括深层次的在初始化加载器时都未实时解析扩展配置文件来获取扩展点实现，而是在使用时才正式解析并获取扩展点实现(即懒加载)。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;不同：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;扩展点必须使用@SPI注解修饰(源码中解析会对此做校验)。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dubbo中扩展配置文件每个扩展(服务提供接口实现类)都指定了一个名称。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; Dubbo SPI在获取扩展类实例时直接通过扩展配置文件中指定的名称获取，而非Java SPI的循环遍历，在使用上更灵活。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3  源码分析&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;以上述的代码实现作为源码分析入口，了解下Dubbo SPI是如何实现的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ExtensionLoader&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① 通过ExtensionLoader.getExtensionLoader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(Classtype)创建对应扩展类型的扩展加载器。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#getExtensionLoader()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static &amp;lt;T&amp;gt; ExtensionLoader&amp;lt;T&amp;gt; getExtensionLoader(Class&amp;lt;T&amp;gt; type) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (type == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Extension type == null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 校验当前类型是否为接口&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (!type.isInterface()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Extension type (&quot; + type + &quot;) is not an interface!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 接口上是否使用了@SPI注解&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (!withExtensionAnnotation(type)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Extension type (&quot; + type +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &quot;) is not an extension, because it is NOT annotated with @&quot; + SPI.class.getSimpleName() + &quot;!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 从内存中读取该扩展点的扩展类加载器&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ExtensionLoader&amp;lt;T&amp;gt; loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 内存中不存在则直接new一个扩展&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (loader == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader&amp;lt;T&amp;gt;(type));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        loader = (ExtensionLoader&amp;lt;T&amp;gt;) EXTENSION_LOADERS.get(type);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return loader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;getExtensionLoader()方法中有三点比较重要的逻辑：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; 判断当前type类型是否为接口类型。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当前扩展点是否使用了@SPI注解修饰。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;EXTENSION_LOADERS为ConcurrentMap类型的内存缓存，内存中存在该类型的扩展加载器则直接使用，不存在就new一个并放入内存缓存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;再看下new ExtensionLoader(type)源码&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#ExtensionLoader()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 私有构造器&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private ExtensionLoader(Class&amp;lt;?&amp;gt; type) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     this.type = type;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 创建ExtensionFactory自适应扩展&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     objectFactory = (type == ExtensionFactory.class ? null : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;重点：&lt;/strong&gt;构造方法为私有类型，即外部无法直接使用构造方法创建ExtensionLoader实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每次初始化ExtensionLoader实例都会初始化type和objectFactory ，type为扩展点类型；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;objectFactory 为ExtensionFactory类型。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② 使用getExtension()获取指定名称的扩展类实例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;getExtension为重载方法，分别为&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getExtension(String name)和&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getExtension(String name, boolean wrap)，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getExtension(String name)方法最终调用的还是getExtension(String name, boolean wrap)方法。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#getExtension()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public T getExtension(String name) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 调用两个参数的getExtension方法，默认true表示需要对扩展实例做包装&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     return getExtension(name, true);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; public T getExtension(String name, boolean wrap) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (StringUtils.isEmpty(name)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Extension name == null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (&quot;true&quot;.equals(name)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return getDefaultExtension();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 获取Holder实例，先从ConcurrentMap类型的内存缓存中取，没值会new一个并存放到内存缓存中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // Holder用来存放一个类型的值，这里用于存放扩展实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    final Holder&amp;lt;Object&amp;gt; holder = getOrCreateHolder(name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 从Holder读取该name对应的实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Object instance = holder.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (instance == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       // 同步控制&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       synchronized (holder) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          instance = holder.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          // double check&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          if (instance == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             // 不存在扩展实例则解析扩展配置文件，实时创建&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             instance = createExtension(name, wrap);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             holder.set(instance);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     return (T) instance;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Holder类：这里用来存放指定扩展实例&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;③ 使用createExtension()创建扩展实例&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#createExtension()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 部分createExtension代码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private T createExtension(String name, boolean wrap) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 先调用getExtensionClasses()解析扩展配置文件，并生成内存缓存，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 然后根据扩展实例名称获取对应的扩展类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Class&amp;lt;?&amp;gt; clazz = getExtensionClasses().get(name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   if (clazz == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       throw findException(name);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       // 根据扩展类生成实例并对实例做包装(主要是进行依赖注入和初始化)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       // 优先从内存中获取该class类型的实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       T instance = (T) EXTENSION_INSTANCES.get(clazz);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       if (instance == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           // 内存中不存在则直接初始化然后放到内存中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           instance = (T) EXTENSION_INSTANCES.get(clazz);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       // 主要是注入instance中的依赖&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       injectExtension(instance);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       ......&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;createExtension()方法：创建扩展实例，方法中EXTENSION_INSTANCES为ConcurrentMap类型的内存缓存，先从内存中取，内存中不存在重新创建；其中一个核心方法是getExtensionClasses()：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#getExtensionClasses()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; getExtensionClasses() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 优先从内存缓存中读&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; classes = cachedClasses.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (classes == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 采用同步手段解析配置文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (cachedClasses) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // double check&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            classes = cachedClasses.get();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (classes == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // 正式开始解析配置文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                classes = loadExtensionClasses();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                cachedClasses.set(classes);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return classes;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;cachedClasses为Holder&amp;lt;map&amp;lt;string, class&amp;gt;&amp;gt;类型的内存缓存，getExtensionClasses中会优先读内存缓存，内存中不存在则采用同步的方式解析配置文件，最终在loadExtensionClasses方法中解析配置文件，完成从扩展配置文件中读出扩展类：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;ExtensionLoader#loadExtensionClasses()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 在getExtensionClasses方法中是以同步的方式调用，是线程安全&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; loadExtensionClasses() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // 缓存默认扩展名称&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   cacheDefaultExtensionName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Map&amp;lt;String, Class&amp;lt;?&amp;gt;&amp;gt; extensionClasses = new HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   // strategies策略类集合，分别对应dubbo的三个配置文件目录&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   for (LoadingStrategy strategy : strategies) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.overridden(), strategy.excludedPackages());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      loadDirectory(extensionClasses, strategy.directory(), type.getName().replace(&quot;org.apache&quot;, &quot;com.alibaba&quot;), strategy.preferExtensionClassLoader(), strategy.overridden(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           strategy.excludedPackages());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   return extensionClasses;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;源码中的strategies即static volatile LoadingStrategy[] strategies数组，通过Java SPI从META-INF/services/目录下加载配置文件完成初始化，默认包含三个类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分别对应dubbo的三个目录：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/dubbo/internal&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/dubbo&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;META-INF/services&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述的源码分析只是对Dubbo SPI做了简要的介绍，Dubbo中对SPI的应用很广泛，如：序列化组件、负载均衡等都应用了SPI技术，还有很多SPI功能未做分析，比如：自适应扩展、Activate活性扩展等  等，感兴趣的同学可以更深入的研究。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、Spring SPI&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring SPI沿用了Java SPI的设计思想，但在实现上和Java SPI及Dubbo SPI也存在差异，Spring通过spring.handlers和spring.factories两种方式实现SPI机制，可以在不修改Spring源码的前提下，做到对Spring框架的扩展开发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;4.1 基本概念&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;类似于Java SPI的ServiceLoader，负责解析spring.handlers配置文件，生成namespaceUri和NamespaceHandler名称的映射，并实例化NamespaceHandler。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;自定义标签配置文件；Spring在2.0时便引入了spring.handlers，通过配置spring.handlers文件实现自定义标签并使用自定义标签解析类进行解析实现动态扩，内容配置如：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http\://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http\://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http\://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;spring.handlers实现的SPI是以namespaceUri作为key，NamespaceHandler作为value，建立映射关系，在解析标签时通过namespaceUri获取相应的NamespaceHandler来解析&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;类似于Java SPI的ServiceLoader，负责解析spring.factories，并将指定接口的所有实现类实例化后返回。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring在3.2时引入spring.factories，加强版的SPI配置文件，为Spring的SPI机制的实现提供支撑，内容配置如：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# PropertySource Loaders&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;org.springframework.boot.env.PropertySourceLoader=\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;org.springframework.boot.env.PropertiesPropertySourceLoader,\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;org.springframework.boot.env.YamlPropertySourceLoader&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# Run Listeners&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;org.springframework.boot.SpringApplicationRunListener=\org.springframework.boot.context.event.EventPublishingRunListener&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;spring.factories实现的SPI是以接口的全限定名作为key，接口实现类作为value，多个实现类用逗号隔开，最终返回的结果是该接口所有实现类的实例集合&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Java SPI从/META-INF/services目录加载服务提供接口配置，而Spring默认从META-INF/spring&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;.handlers和META-INF/spring.factories目录加载配置，其中META-INF/spring.handlers的路径可以通过创建实例时重新指定，而META-INF/spring.factories固定不可变。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;4.2 spring.handlers&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;首先通过代码初步介绍下spring.handlers实现。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2.1 spring.handlers SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① 创建NameSpaceHandler&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;MysqlDataBaseHandler&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.handlers;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.config.BeanDefinition;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.ParserContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.w3c.dom.Element;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// 继承抽象类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MysqlDataBaseHandler extends NamespaceHandlerSupport {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void init() {   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public BeanDefinition parse(Element element, ParserContext parserContext) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;MysqlDataBaseHandler!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OracleDataBaseHandler &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.handlers;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.config.BeanDefinition;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.NamespaceHandlerSupport;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.ParserContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.w3c.dom.Element;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class OracleDataBaseHandler extends NamespaceHandlerSupport {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void init() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public BeanDefinition parse(Element element, ParserContext parserContext) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;OracleDataBaseHandler!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② 在项目META-INF/目录下创建spring.handlers文件：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3225108225108225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0ugmCWd2E3CMm6ziapOEz66MyVpupYCXFTCoy6Ae52xBhKzn9CZ5tyHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;文件内容：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;spring.handlers&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#一个namespaceUri对应一个handler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http\://www.mysql.org/schema/mysql=spring.spi.handlers.MysqlDataBaseHandler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http\://www.oracle.org/schema/oracle=spring.spi.handlers.OracleDataBaseHandler&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;③ 运行代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringSpiTest#main()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.beans.factory.xml.NamespaceHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class SpringSpiTest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String args[]){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // spring中提供的默认namespace URI解析器&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        DefaultNamespaceHandlerResolver resolver = new DefaultNamespaceHandlerResolver();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 此处假设nameSpaceUri已从xml文件中解析出来，正常流程是在项目启动的时候会解析xml文件，获取到对应的自定义标签&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 然后根据自定义标签取得对应的nameSpaceUri&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String mysqlNameSpaceUri = &quot;http://www.mysql.org/schema/mysql&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        NamespaceHandler  handler = resolver.resolve(mysqlNameSpaceUri);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 验证自定义NamespaceHandler，这里参数传null，实际使用中传具体的Element&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        handler.parse(null, null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String oracleNameSpaceUri = &quot;http://www.oracle.org/schema/oracle&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        handler = resolver.resolve(oracleNameSpaceUri);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        handler.parse(null, null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;④  运行结果：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MysqlDataBaseHandler!!!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;OracleDataBaseHandler!!!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;上述代码通过解析spring.handlers实现对自定义标签的动态解析，以NameSpaceURI作为key获取具体的NameSpaceHandler实现类，这里有别于Java SPI，其中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;是NamespaceHandlerResolver接口的默认实现类，用于解析自定义标签。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver.resolve(String namespaceUri)方法以namespaceUri作为参数，默认加载各jar包中的META-INF/spring.handlers配置文件，通过解析spring.handlers文件建立NameSpaceURI和NameSpaceHandler的映射。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;加载配置文件的默认路径是META-INF/spring.handlers，但可以使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver(ClassLoader, String)构造方法修改，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver有多个重载方法。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver.resolve(String namespaceUri)方法主要被&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BeanDefinitionParserDelegate的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;parseCustomElement()和&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;decorateIfRequired()方法中调用，所以spring.handlers SPI机制主要用在bean的扫描和解析过程中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4.2.2 源码分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;下面从上述代码开始深入源码了解spring handlers方式实现的SPI是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① DefaultNamespaceHandlerResolver.resolve()&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法本身是根据namespaceUri获取对应的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;namespaceHandler对标签进行解析，核心源码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver#resolve()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public NamespaceHandler resolve(String namespaceUri) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 1、核心逻辑之一：获取namespaceUri和namespaceHandler映射关系&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Map&amp;lt;String, Object&amp;gt; handlerMappings = getHandlerMappings();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 根据namespaceUri参数取对应的namespaceHandler全限定类名or NamespaceHandler实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Object handlerOrClassName = handlerMappings.get(namespaceUri);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (handlerOrClassName == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 2、handlerOrClassName是已初始化过的实例则直接返回&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    else if (handlerOrClassName instanceof NamespaceHandler) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return (NamespaceHandler) handlerOrClassName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String className = (String) handlerOrClassName;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            ///3、使用反射根据namespaceHandler全限定类名加载实现类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Class&amp;lt;?&amp;gt; handlerClass = ClassUtils.forName(className, this.classLoader);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (!NamespaceHandler.class.isAssignableFrom(handlerClass)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                throw new FatalBeanException(&quot;Class [&quot; + className + &quot;] for namespace [&quot; + namespaceUri +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        &quot;] does not implement the [&quot; + NamespaceHandler.class.getName() + &quot;] interface&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 3.1、初始化namespaceHandler实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 3.2、 初始化，不同的namespaceHandler实现类初始化方法逻辑有差异&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            namespaceHandler.init();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 4、将初始化好的实例放入内存缓存中，下次解析到相同namespaceUri标签时直接返回，避免再次初始化&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            handlerMappings.put(namespaceUri, namespaceHandler);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return namespaceHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }catch (ClassNotFoundException ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new FatalBeanException(&quot;NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    namespaceUri + &quot;] not found&quot;, ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }catch (LinkageError err) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new FatalBeanException(&quot;Invalid NamespaceHandler class [&quot; + className + &quot;] for namespace [&quot; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    namespaceUri + &quot;]: problem with handler class file or dependent class&quot;, err);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第1步：&lt;/strong&gt;源码中getHandlerMappings()是比较核心的一个方法，通过懒加载的方式解析spring.handlers并返回namespaceUri和NamespaceHandler的映射关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第2步：&lt;/strong&gt;根据namespaceUri返回对应的NamespaceHandler全限定名或者具体的实例(是名称还是实例取决于是否被初始化过，若是初始化过的实例会直接返回) &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第3步&lt;/strong&gt;是NamespaceHandler实现类的全限定名，通过上述源码中的第3步，使用反射进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第4步&lt;/strong&gt;将初始化后的实例放到handlerMappings内存缓存中，这也是第2步为什么可能是NamespaceHandler类型的原因。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;看完resolve方法的源码，再看下resolve方法在Spring中调用场景，大致可以了解spring.handlers的使用场景：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2731707317073171&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm06U8aj4akFXWEztX4jQFQz4crJic7zS8VcJ8xofLDQABBOvYicR0FKE9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;820&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;可以看到resolve()主要用在标签解析过程中，主要被在BeanDefinitionParserDelegate的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;parseCustomElement和decorateIfRequired方法中调用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② resolve()源码中核心逻辑之一便是调用的getHandlerMappings()，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在getHandlerMappings()中实现对各个jar包中的META-INF/spring.handlers文件的解析，如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;DefaultNamespaceHandlerResolver#getHandlerMappings()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private Map&amp;lt;String, Object&amp;gt; getHandlerMappings() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Map&amp;lt;String, Object&amp;gt; handlerMappings = this.handlerMappings;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 使用线程安全的解析逻辑，避免在并发场景下重复的解析，没必要重复解析&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 这里在同步代码块的内外对handlerMappings == null作两次判断很有必要，采用懒汉式初始化&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (handlerMappings == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        synchronized (this) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            handlerMappings = this.handlerMappings;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // duble check&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (handlerMappings == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (logger.isDebugEnabled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    logger.debug(&quot;Loading NamespaceHandler mappings from [&quot; + this.handlerMappingsLocation + &quot;]&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 加载handlerMappingsLocation目录文件，handlerMappingsLocation路径值可变，默认是META-INF/spring.handlers&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    Properties mappings =&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            PropertiesLoaderUtils.loadAllProperties(this.handlerMappingsLocation, this.classLoader);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    if (logger.isDebugEnabled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                        logger.debug(&quot;Loaded NamespaceHandler mappings: &quot; + mappings);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 初始化内存缓存&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    handlerMappings = new ConcurrentHashMap&amp;lt;String, Object&amp;gt;(mappings.size());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 将加载到的属性合并到handlerMappings中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    CollectionUtils.mergePropertiesIntoMap(mappings, handlerMappings);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 赋值内存缓存&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    this.handlerMappings = handlerMappings;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }catch (IOException ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    throw new IllegalStateException(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                            &quot;Unable to load NamespaceHandler mappings from location [&quot; + this.handlerMappingsLocation + &quot;]&quot;, ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return handlerMappings;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;源码中this.handlerMappings是一个Map类型的内存缓存，存放解析到的namespaceUri以及NameSpaceHandler实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getHandlerMappings()方法体中的实现使用了线程安全方式，增加了同步逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过阅读源码可以了解到Spring基于spring.handlers实现SPI逻辑相对比较简单，但应用却比较灵活，对自定义标签的支持很方便，在不修改Spring源码的前提下轻松实现接入，如Dubbo中定义的各种Dubbo标签便是很好的利用了spring.handlers。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Spring提供如此灵活的功能，那是如何应用的呢？下面简单了解下parseCustomElement()。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;resolve作为工具类型的方法，被使用的地方比较多，这里仅简单介绍在&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BeanDefinitionParserDelegate.parseCustomElement()中的应用。   &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;BeanDefinitionParserDelegate#parseCustomElement()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 获取标签的namespaceUri&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     String namespaceUri = getNamespaceURI(ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 首先获得DefaultNamespaceHandlerResolver实例在再以namespaceUri作为参数调用resolve方法解析取得NamespaceHandler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     if (handler == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         return null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     // 调用NamespaceHandler中的parse方法开始解析标签&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;parseCustomElement作为解析标签的中间方法，再看下parseCustomElement的调用情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.06340579710144928&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm09Q2J8ruUYvuQMAmZSBY0vuM0soTQR7X1WUVjMKX5JbvMyrGW0puDFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1104&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在parseBeanDefinitions()中被调用，再看下parseBeanDefinitions的源码&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;DefaultBeanDefinitionDocumentReader#parseBeanDefinitions()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // spring内部定义的标签为默认标签，即非spring内部定义的标签都不是默认的namespace&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (delegate.isDefaultNamespace(root)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        NodeList nl = root.getChildNodes();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (int i = 0; i &amp;lt; nl.getLength(); i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Node node = nl.item(i);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (node instanceof Element) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                Element ele = (Element) node;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                // root子标签也做此判断&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (delegate.isDefaultNamespace(ele)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    parseDefaultElement(ele, delegate);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }else{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    // 子标签非spring默认标签(即自定义标签)也走parseCustomElement来解析&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    delegate.parseCustomElement(ele);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }else {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 非spring的默认标签(即自定义的标签)走parseCustomElement来解析&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        delegate.parseCustomElement(root);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;到此就很清晰了，调用前判断是否为Spring默认标签，不是默认标签调用parseCustomElement来解析，最后调用resolve方法。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2.3 小节&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring自2.0引入spring.handlers以后，为Spring的动态扩展提供更多的入口和手段，为自定义标签的实现提供了强力支撑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多文章在介绍Spring SPI时都重点介绍spring.factories实现，很少提及很早就引入的spring.handlers，但通过个人的分析及与Java SPI的对比，spring.handlers也是一种SPI的实现，只是基于xml实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比于Java SPI，基于spring.handlers实现的SPI更加的灵活，无需遍历，直接映射，更类似于Dubbo SPI的实现思想，每个类指定一个名称(只是spring.handlers中是以namespaceUri作为key，Dubbo配置中是指定的名称作为key)。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;4.3  spring.factories&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;同样先以测试代码来介绍spring.factories实现SPI的逻辑。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3.1 spring.factories SPI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;① 创建DataBaseSPI接口&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.factories;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public interface DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;② 创建DataBaseSPI接口的实现类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;MysqlDataBaseImpl &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#实现类1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.factories.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import spring.spi.factories.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MysqlDataBaseImpl implements DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;Mysql database test!!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;MysqlDataBaseImpl&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#实现类2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.factories.impl;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import spring.spi.factories.DataBaseSPI;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class OracleDataBaseImpl implements DataBaseSPI {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public void dataBaseOperation() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;Oracle database test!!!!&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;③ 在项目META-INF/目录下创建spring.factories文件：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3225108225108225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0ugmCWd2E3CMm6ziapOEz66MyVpupYCXFTCoy6Ae52xBhKzn9CZ5tyHw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;462&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;文件内容&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;spring.factories&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#key是接口的全限定名，value是接口的实现类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;spring.spi.factories.DataBaseSPI = spring.spi.factories.impl.MysqlDataBaseImpl,spring.spi.factories.impl.OracleDataBaseImpl&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;④ 运行代码&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringSpiTest#main()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package spring.spi.factories;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import java.util.List;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import org.springframework.core.io.support.SpringFactoriesLoader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class SpringSpiTest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String args[]){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 调用SpringFactoriesLoader.loadFactories方法加载DataBaseSPI接口所有实现类的实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        List&amp;lt;DataBaseSPI&amp;gt; spis= SpringFactoriesLoader.loadFactories(DataBaseSPI.class, Thread.currentThread().getContextClassLoader());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 遍历DataBaseSPI接口实现类实例&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for(DataBaseSPI spi : spis){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            spi.dataBaseOperation();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;⑤ 运行结果&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Mysql database test!!!!&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Oracle database test!!!!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;从上述的示例代码中可以看出spring.facotries方式实现的SPI和Java SPI很相似，都是先获取指定接口类型的实现类，然后遍历访问所有的实现。但也存在一定的&lt;strong&gt;差异&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）配置上：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Java SPI是一个服务提供接口对应一个配置文件，配置文件中存放当前接口的所有实现类，多个服务提供接口对应多个配置文件，所有配置都在services目录下；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring factories SPI是一个spring.factories配置文件存放多个接口及对应的实现类，以接口全限定名作为key，实现类作为value来配置，多个实现类用逗号隔开，仅spring.factories一个配置文件。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）实现上&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Java SPI使用了懒加载模式，即在调用ServiceLoader.load()时仅是返回了ServiceLoader实例，尚未解析接口对应的配置文件，在使用时即循环遍历时才正式解析返回服务提供接口的实现类实例；&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring factories SPI在调用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader.loadFactories()时便已解析spring.facotries文件返回接口实现类的实例(实现细节在源码分析中详解)。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3.2 源码分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;我们还是从测试代码开始，了解下spring.factories的SPI实现源码，细品spring.factories的实现方式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;测试代码入口直接调用SpringFactoriesLoader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;.loadFactories()静态方法开始解析spring&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;.factories文件，并返回方法参数中指定的接口类型，如测试代码里的DataBaseSPI接口的实现类实例。    &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader#loadFactories()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; loadFactories(Class&amp;lt;T&amp;gt; factoryClass, ClassLoader classLoader) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Assert.notNull(factoryClass, &quot;&#x27;factoryClass&#x27; must not be null&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ClassLoader classLoaderToUse = classLoader;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 1.确定类加载器&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (classLoaderToUse == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 2.核心逻辑之一：解析各jar包中META-INF/spring.factories文件中factoryClass的实现类全限定名&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;String&amp;gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (logger.isTraceEnabled()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        logger.trace(&quot;Loaded [&quot; + factoryClass.getName() + &quot;] names: &quot; + factoryNames);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;T&amp;gt;(factoryNames.size());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 3.遍历实现类的全限定名并进行实例化&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    for (String factoryName : factoryNames) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 排序&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    AnnotationAwareOrderComparator.sort(result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 4.返回实例化后的结果集&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;源码中loadFactoryNames() 是另外一个比较核心的方法，解析spring.factories文件中指定接口的实现类的全限定名，实现逻辑见后续的源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过源码中第2步解析得到实现类的全限定名后，在第3步通过instantiateFactory()方法逐个实例化实现类。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;再看loadFactoryNames()源码是如何解析得到实现类全限定名的：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader#loadFactoryNames()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static List&amp;lt;String&amp;gt; loadFactoryNames(Class&amp;lt;?&amp;gt; factoryClass, ClassLoader classLoader) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 1.接口全限定名&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    String factoryClassName = factoryClass.getName();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 2.加载META-INF/spring.factories文件路径(分布在各个不同jar包里，所以这里会是多个文件路径，枚举返回)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Enumeration&amp;lt;URL&amp;gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;String&amp;gt;();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 3.遍历枚举集合，逐个解析spring.factories文件&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        while (urls.hasMoreElements()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            URL url = urls.nextElement();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            String propertyValue = properties.getProperty(factoryClassName);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            // 4.spring.factories文件中一个接口的实现类有多个时会用逗号隔开，这里拆开获取实现类全限定名&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            for (String factoryName : StringUtils.commaDelimitedListToStringArray(propertyValue)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                result.add(factoryName.trim());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return result;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }catch (IOException ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Unable to load factories from location [&quot; +&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                FACTORIES_RESOURCE_LOCATION + &quot;]&quot;, ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;源码中第2步获取所有jar包中META-INF/spring.factories文件路径，以枚举值返回。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;源码中第3步开始遍历spring.factories文件路径，逐个加载解析，整合factoryClass类型的实现类名称。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;获取到实现类的全限定名集合后，便根据实现类的名称逐个实例化，继续看下instantiateFactory()方法的源码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader#instantiateFactory()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private static &amp;lt;T&amp;gt; T instantiateFactory(String instanceClassName, Class&amp;lt;T&amp;gt; factoryClass, ClassLoader classLoader) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    try {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 1.使用classLoader类加载器加载instanceClassName类&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Class&amp;lt;?&amp;gt; instanceClass = ClassUtils.forName(instanceClassName, classLoader);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (!factoryClass.isAssignableFrom(instanceClass)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            throw new IllegalArgumentException(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &quot;Class [&quot; + instanceClassName + &quot;] is not assignable to [&quot; + factoryClass.getName() + &quot;]&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 2.instanceClassName类中的构造方法&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Constructor&amp;lt;?&amp;gt; constructor = instanceClass.getDeclaredConstructor();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ReflectionUtils.makeAccessible(constructor);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 3.实例化&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return (T) constructor.newInstance();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    catch (Throwable ex) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        throw new IllegalArgumentException(&quot;Unable to instantiate factory class: &quot; + factoryClass.getName(), ex);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实例化方法是私有型(private)静态方法，这个有别于loadFactories和loadFactoryNames。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实例化逻辑整体使用了反射实现，比较通用的实现方式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;通过对源码的分析，Spring factories方式实现的SPI逻辑不是很复杂，整体上的实现容易理解。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring在3.2便已引入spring.factories，那spring.factories在Spring框架中又是如何使用的呢？先看下loadFactories方法的调用情况&lt;/span&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23128598848368523&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0Z9jErhokZeNydn8IEAyGsQFJUnVgI6QPeBNk3efEahWfwKWo51YUqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1042&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;从调用情况看Spring自3.2引入spring.factories SPI后并没有真正的利用起来，使用的地方比较少，然而真正把spring.factories发扬光大的，是在Spring Boot中， 简单了解下SpringBoot中的调用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;getSpringFactoriesInstances()并不是Spring框架中的方法，而是SpringBoot中SpringApplication类里定义的私有型(private)方法，很多地方都有调用，源码如下：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SpringApplication#getSpringFactoriesInstance()&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; getSpringFactoriesInstances(&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[] {});&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Class&amp;lt;?&amp;gt;[] parameterTypes, &lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;... args) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ClassLoader classLoader = getClassLoader();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Set&amp;lt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;&amp;gt; names = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;&amp;gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            SpringFactoriesLoader.loadFactoryNames(&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;, classLoader));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    List&amp;lt;T&amp;gt; instances = createSpringFactoriesInstances(&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt;, parameterTypes,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            classLoader, args, names);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    AnnotationAwareOrderComparator.sort(instances);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; instances;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在getSpringFactoriesInstances()中调用了SpringFactoriesLoader.loadFactoryNames()来加载接口实现类的全限定名集合，然后进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringBoot中除了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getSpringFactoriesInstances()方法有调用，在其他逻辑中也广泛运用着SpringFactoriesLoader中的方法来实现动态扩展，这里就不在一一列举了，有兴趣的同学可以自己去发掘。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.3.3 小节&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Spring框架在3.2引入spring.factories后并没有有效的利用起来，但给框架的使用者提供了又一个动态扩展的能力和入口，为开发人员提供了很大的自由发挥的空间，尤其是在SpringBoot中广泛运用就足以证明spring.factories的地位。spring.factories引入在 提升Spring框架能力的同时也暴露出其中的不足：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;首先，spring.factories的实现类似Java SPI，在加载到服务提供接口的实现类后需要循环遍历才能访问，不是很方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，Spring在5.0.x版本以前&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader类定义为抽象类，但在5.1.0版本之后Sping官方将&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringFactoriesLoader改为final类，类型变化对前后版本的兼容不友好。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、应用实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;介绍完Spring中SPI机制相关的核心源码，再来看看项目中自己开发的轻量版的分库分表SDK是如何利用Spring的SPI机制实现分库分表策略动态扩展的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;基于项目的特殊性并没有使用目前行业中成熟的分库分表组件，而是基于Mybatis的插件原理自己开发的一套轻量版分库分表组件。为满足不同场景分库分表要求，将其中分库分表的相关逻辑以策略模式进行抽取分离，每种分库分表的实现对应一条策略，支持使用方对分库分表策略的动态扩展，而这里的动态扩展就利用了spring.factories。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;首先给出轻量版分库分表组件流程图，然后我们针对流程图中使用到Spring SPI的地方进行详细分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3804523424878837&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0dnib8FWDky3XgNb6Z4hMiboDwsZUbqgVYjE1aBZ4kNXcT8ibh2lIKlibZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1238&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;说明：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1、上述流程图中项目启动过程中生成数据源和分库分表策略的初始化，策略初始化完成后缓存到内存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、发起数据库操作指令时，解析是否需要分库分表(流程中只给出了需要分库分表的流程)，需要则通过提取到的策略key获取对应的分库分表策略并进行分库分表，完成数据库操作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;通过上述的流程图可以看到，分库分表SDK通过spring.factories支持动态加载分库分表策略以兼容不同项目的不同使用场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中分库分表部分的策略类图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5990853658536586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt4p1JPgibfQicibjJazm8dLRm0UeqlNrtMPQicEVibWztWficMpjeCrNkibcF6lbY1575lFMyblwYTGJI9NQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;其中：ShardingStrategy和&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DBTableShardingStrategy为接口；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BaseShardingStrategy为默认实现类；DefaultStrategy和CountryDbSwitchStrategy为SDK中基于不同场景默认实现的分库分表策略。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;在项目实际使用时，动态扩展的分库分表策略只需要继承BaseShardingStrategy即可，SDK中初始化分库分表策略时通过SpringFactoriesLoader&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;.loadFactories()实现动态加载。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;SPI技术将服务接口与服务实现分离以达到解耦，极大的提升程序的可扩展性。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文重点介绍了Java内置SPI和Dubbo SPI以及Spring SPI三者的原理和相关源码；首先演示了三种SPI技术的实现，然后通过演示代码深入阅读了三种SPI的实现源码；其中重点介绍了Spring SPI的两种实现方式：spring.handlers和spring.factories，以及使用spring.factories实现的分库分表策略加载。希望通过阅读本文可以让读者对SPI有更深入的了解。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;猜你喜欢&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4768267df0e99a8ea49ae0d590b70af8</guid>
<title>Java性能优化的七个方向</title>
<link>https://toutiao.io/k/yjkn4py</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;fieldset data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;专业架构师，专注高质量架构干货分享。三高架构（高可用、高性能、高稳定）、大数据、机器学习、Java架构、系统架构、分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;因公众号更改推送规则，请点“在看”并加“星标”&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;第一时间获取精彩技术分享&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;了解了优化目标后，那接下来应该从哪些方面入手呢？本文主要侧重于理论分析，我们从整体上看一下 Java 性能优化都有哪些可以遵循的规律。本文主讲理论。关于实践，后续的文章会用较多的案例来细化本文的知识点，适合反复思考和归纳。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;概述&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;性能优化根据优化的类别，分为业务优化和技术优化。&lt;/span&gt;&lt;span&gt;业务优化产生的效果也是非常大的，但它属于产品和管理的范畴。&lt;/span&gt;&lt;span&gt;同作为程序员，在平常工作中，我们面对的优化方式，主要是通过一系列的技术手段，来完成对既定的优化目标。&lt;/span&gt;&lt;span&gt;这一系列的技术手段，我大体归纳为如图以下 7 类：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4377387318563789&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RAGlnlpXeMIOpsicUXhJnziaQLEBgRiayjARPdJ9YLIxjJnJold5qNHQndBmc79Ca4Hxd6F6Z7jA7lJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1309&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;可以看到，优化方式集中在对计算资源和存储资源的规划上。优化方法中有多种用空间换时间的方式，但只照顾计算速度，而不考虑复杂性和空间问题，也是不可取的。我们要做的，就是在照顾性能的前提下，达到资源利用的最优状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，我简要介绍一下这7个优化方向。&lt;/span&gt;&lt;span&gt;如果你感觉比较枯燥，那也没关系，我们本文的目的，就是让你的脑海里有一个总分的概念，以及对理论基础有一个整体的认识。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;1、复用优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在写代码的时候，你会发现有很多重复的代码可以提取出来，做成公共的方法。这样，在下次用的时候，就不用再费劲写一遍了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种思想就是复用。上面的描述是编码逻辑上的优化，对于数据存取来说，有同样的复用情况。无论是在生活中还是编码中，重复的事情一直在发生，如果没有复用，工作和生活就会比较累。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在软件系统中，谈到数据复用，我们首先想到的就是缓冲和缓存。注意这两个词的区别，它们的意义是完全不同的，很多同学很容易搞混，在这里简单地介绍一下。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;与之类似的，是对于对象的池化操作，比如数据库连接池、线程池等，在 Java 中使用得非常频繁。由于这些对象的创建和销毁成本都比较大，我们在使用之后，也会将这部分对象暂时存储，下次用的时候，就不用再走一遍耗时的初始化操作了。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;2、 计算优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;并行执行&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在的 CPU 发展速度很快，绝大多数硬件，都是多核。要想加快某个任务的执行，最快最优的解决方式，就是让它并行执行。并行执行有以下三种模式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第一种模式是多机，采用负载均衡的方式，将流量或者大的计算拆分成多个部分，同时进行处理。&lt;/span&gt;&lt;span&gt;比如，Hadoop 通过 MapReduce 的方式，把任务打散，多机同时进行计算。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第二种模式是采用多进程。&lt;/span&gt;&lt;span&gt;比如 Nginx，采用 NIO 编程模型，Master 统一管理 Worker 进程，然后由 Worker 进程进行真正的请求代理，这也能很好地利用硬件的多个 CPU。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;第三种模式是使用多线程，这也是 Java 程序员接触最多的。&lt;/span&gt;&lt;span&gt;比如 Netty，采用 Reactor 编程模型，同样使用 NIO，但它是基于线程的。&lt;/span&gt;&lt;span&gt;Boss 线程用来接收请求，然后调度给相应的 Worker 线程进行真正的业务计算。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像 Golang 这样的语言，有更加轻量级的协程（Coroutine），协程是一种比线程更加轻量级的存在，但目前在 Java 中还不太成熟，就不做过多介绍了，但本质上，它也是对于多核的应用，使得任务并行执行。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;变同步为异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再一种对于计算的优化，就是变同步为异步，这通常涉及编程模型的改变。同步方式，请求会一直阻塞，直到有成功，或者失败结果的返回。虽然它的编程模型简单，但应对突发的、时间段倾斜的流量，问题就特别大，请求很容易失败。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异步操作可以方便地支持横向扩容，也可以缓解瞬时压力，使请求变得平滑。同步请求，就像拳头打在钢板上；异步请求，就像拳头打在海绵上。你可以想象一下这个过程，后者肯定是富有弹性的，体验更加友好。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;惰性加载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一种，就是使用一些常见的设计模式来优化业务，提高体验，比如单例模式、代理模式等。举个例子，在绘制 Swing 窗口的时候，如果要显示比较多的图片，就可以先加载一个占位符，然后通过后台线程慢慢加载所需要的资源，这就可以避免窗口的僵死。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;3、结果集优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来介绍一下对结果集的优化。举个比较直观的例子，我们都知道 XML 的表现形式是非常好的，那为什么还有 JSON 呢？除了书写要简单一些，一个重要的原因就是它的体积变小了，传输效率和解析效率变高了，像 Google 的 Protobuf，体积就更小了一些。虽然可读性降低，但在一些高并发场景下（如 RPC），能够显著提高效率，这是典型的对结果集的优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是由于我们目前的 Web 服务，都是 C/S 模式。&lt;/span&gt;&lt;span&gt;数据从服务器传输到客户端，需要分发多份，这个数据量是急剧膨胀的，每减少一小部分存储，都会有比较大的传输性能和成本提升。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;像 Nginx，一般都会开启 GZIP 压缩，使得传输的内容保持紧凑。&lt;/span&gt;&lt;span&gt;客户端只需要一小部分计算能力，就可以方便解压。&lt;/span&gt;&lt;span&gt;由于这个操作是分散的，所以性能损失是固定的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;了解了这个道理，我们就能看到对于结果集优化的一般思路，你要尽量保持返回数据的精简。&lt;/span&gt;&lt;span&gt;一些客户端不需要的字段，那就在代码中，或者直接在 SQL 查询中，就把它去掉。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一些对时效性要求不高，但对处理能力有高要求的业务。&lt;/span&gt;&lt;span&gt;我们要吸取缓冲区的经验，尽量减少网络连接的交互，采用批量处理的方式，增加处理速度。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;结果集合很可能会有二次使用，你可能会把它加入缓存中，但依然在速度上有所欠缺。&lt;/span&gt;&lt;span&gt;这个时候，就需要对数据集合进行处理优化，采用索引或者 Bitmap 位图等方式，加快数据访问速度。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;4、资源冲突优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在平常的开发中，会涉及很多共享资源。这些共享资源，有的是单机的，比如一个 HashMap；有的是外部存储，比如一个数据库行；有的是单个资源，比如 Redis 某个 key 的Setnx；有的是多个资源的协调，比如事务、分布式事务等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现实中的性能问题，和锁相关的问题是非常多的。大多数我们会想到数据库的行锁、表锁、Java 中的各种锁等。在更底层，比如 CPU 命令级别的锁、JVM 指令级别的锁、操作系统内部锁等，可以说无处不在。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只有并发，才能产生资源冲突。也就是在同一时刻，只能有一个处理请求能够获取到共享资源。解决资源冲突的方式，就是加锁。再比如事务，在本质上也是一种锁。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照锁级别，锁可分为乐观锁和悲观锁，乐观锁在效率上肯定是更高一些；按照锁类型，锁又分为公平锁和非公平锁，在对任务的调度上，有一些细微的差别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对资源的争用，会造成严重的性能问题，所以会有一些针对无锁队列之类的研究，对性能的提升也是巨大的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;5、算法优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算法能够显著提高复杂业务的性能，但在实际的业务中，往往都是变种。由于存储越来越便宜，在一些 CPU 非常紧张的业务中，往往采用空间换取时间的方式，来加快处理速度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;算法属于代码调优，代码调优涉及很多编码技巧，需要使用者对所使用语言的 API 也非常熟悉。有时候，对算法、数据结构的灵活使用，也是代码优化的一个重要内容。比如，常用的降低时间复杂度的方式，就有递归、二分、排序、动态规划等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个优秀的实现，比一个拙劣的实现，对系统的影响是非常大的。比如，作为 List 的实现，LinkedList 和 ArrayList 在随机访问的性能上，差了好几个数量级；又比如，CopyOnWriteList 采用写时复制的方式，可以显著降低读多写少场景下的锁冲突。而什么时候使用同步，什么时候是线程安全的，也对我们的编码能力有较高的要求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这部分的知识，就需要我们在平常的工作中注意积累，后面的课时中，也会挑比较重要的知识点穿插讲解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;6、高效实现&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在平时的编程中，尽量使用一些设计理念良好、性能优越的组件。比如，有了 Netty，就不用再选择比较老的 Mina 组件。而在设计系统时，从性能因素考虑，就不要选 SOAP 这样比较耗时的协议。再比如，一个好的语法分析器（比如使用 JavaCC），其效率会比正则表达式高很多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总之，如果通过测试分析，找到了系统的瓶颈点，就要把关键的组件，使用更加高效的组件进行替换。在这种情况下，适配器模式是非常重要的。这也是为什么很多公司喜欢在现有的组件之上，再抽象一层自己的；而当在底层组件进行切换的时候，上层的应用并无感知。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;7、JVM 优化&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为 Java 是运行在 JVM 虚拟机之上，它的诸多特性，就要受到 JVM 的制约。对 JVM 虚拟机进行优化，也能在一定程度上能够提升 JAVA 程序的性能。如果参数配置不当，甚至会造成 OOM 等比较严重的后果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前被广泛使用的垃圾回收器是 G1，通过很少的参数配置，内存即可高效回收。CMS 垃圾回收器已经在 Java 14 中被移除，由于它的 GC 时间不可控，有条件应该尽量避免使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;JVM 性能调优涉及方方面面的取舍，往往是牵一发而动全身，需要全盘考虑各方面的影响。所以了解 JVM 内部的一些运行原理，还是特别重要的，它有益于我们加深对代码更深层次的理解，帮助我们书写出更高效的代码。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YK9e7vHy9IQATwibKVicOpXZibX8VOvBrnF39NdpXQMwdpyIgN0ibicEwRdge0mXthxjHagHgwpWhrsibvMZFibaQC6vQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;小结&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2857142857142858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orc2J6rib40bATuJM23UiaHQ0tsVpvjgyuhk7To5zFqb2fyL9pCr1U7hfeKJELCht0KxWnuias6TLibMdcRhM7QhyQ/640?wx_fmt=png&quot; data-w=&quot;14&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上就是代码优化的 7 个大方向，我们通过简要的介绍，让大家对性能优化的内容有了大体的了解。这7大方向是代码优化的最主要方向，当然，性能优化还包含数据库优化、操作系统优化、架构优化等其他一些内容，这些不是我们的重点，在后面的文章中，我们也只做简要的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;/pre&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：农民工老王&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：tomcat.blog.csdn.net/article/details/123361799&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，仅供分享学习，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56385c2ec12acb2e796cb0590c37dca0</guid>
<title>作为Gopher，你知道Go的注释即文档应该怎么写吗？</title>
<link>https://toutiao.io/k/ua2cujf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Go一直奉行“注释即文档”的概念，在代码中针对各种public内容进行注释之后，这些注释也就是对应内容的文档，这称为GoDoc。那么作为gopher，你知道GoDoc应该怎么写吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-pid=&quot;lP2sWhv_&quot;&gt;&lt;span&gt;刚入门Go开发时，在开源项目的主页上我们经常可以看到这样的一个徽章：&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;lP2sWhv_&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXLLqe0sOJAMDyrL3nlYp1FmNwrQeJekvIWicEpsBxOYc9bqOcwzF1qnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;90&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;8A2iWO3W&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;8A2iWO3W&quot;&gt;&lt;span&gt;点击徽章，就可以打开&lt;/span&gt;&lt;span&gt;https://pkg.go.dev/&lt;/span&gt;&lt;span&gt;的网页，网页中给出了这个开源项目所对应的Go文档。在刚接触Go的时候，我曾一度以为，pkg.go.dev上面的文档是需要开发者上传并审核的——要不然那些文档咋都显得那么专业呢。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;YMlVNl0k&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;YMlVNl0k&quot;&gt;&lt;span&gt;然而当我写自己的轮子时，慢慢的我就发现并非如此。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;YMlVNl0k&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;YMlVNl0k&quot;&gt;&lt;span&gt;划重点&lt;/span&gt;&lt;span&gt;：在pkg.go.dev上的文档，都是Go自动从开源项目的工程代码中爬取、格式化后展现出来的。换句话说，每个人都可以写自己的GoDoc并且展示在pkg.go.dev上，只需要遵从GoDoc的格式标准即可，也不需要任何审核动作。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;zU0aZWxT&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;zU0aZWxT&quot;&gt;&lt;span&gt;本文章的目的是通过例子，简要说明GoDoc的格式，让读者也可以自己写一段高大上的godoc。以下内容以我自己的&lt;/span&gt;&lt;span&gt;jsonvalue&lt;/span&gt;&lt;span&gt;（https://github.com/Andrew-M-C/go.jsonvalue）&lt;/span&gt;&lt;span&gt;包为例子。其对应的GoDoc在&lt;/span&gt;&lt;span&gt;这里&lt;/span&gt;&lt;span&gt;（https://pkg.go.dev/github.com/Andrew-M-C/go.jsonvalue）&lt;/span&gt;&lt;span&gt;。读者可以点开，并与代码中的内容做参考对比。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;zU0aZWxT&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、什么是GoDoc&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;hmFRYEyh&quot;&gt;&lt;span&gt;顾名思义，GoDoc就是Go语言的文档。在实际应用中，godoc可能可以指以下含义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-pid=&quot;CzCHuERw&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;CzCHuERw&quot;&gt;&lt;span&gt;目前的godoc和pkgsite有两个作用，一个是用来本地调试自己的GoDoc显示效果；另一个是在无法科学上网的时候，用来本地搭建GoDoc服务器之用。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;CzCHuERw&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、godoc命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;tI_DtUnM&quot;&gt;&lt;span&gt;我们从工具命令开始讲起吧。在2019年之前，Go使用的是godoc这个工具来格式化和展示Go代码中自带的文档。现在这个命令已经不再包含于Go工具链中，而需要额外安装:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go &lt;span class=&quot;code-snippet__keyword&quot;&gt;get&lt;/span&gt; -v golang.org/x/tools/cmd/godoc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;godoc命令有多种模式和参数，这里我们列出最常用和最简便的模式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cd&lt;/span&gt; XXXX; &lt;span class=&quot;code-snippet__attribute&quot;&gt;godoc&lt;/span&gt; -http=:&lt;span class=&quot;code-snippet__number&quot;&gt;6060&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中XXXX是包含go.mod的一个仓库目录。假设XXX是我的&lt;/span&gt;&lt;span&gt;jsonvalue&lt;/span&gt;&lt;span&gt;（https://github.com/Andrew-M-C/go.jsonvalue）&lt;/span&gt;&lt;span&gt;库的本地目录，根据go.mod，这个库的地址是github.com/Andrew-M-C/go.jsonvalue，那么我就可以在浏览器中打开&lt;/span&gt;&lt;span&gt;http://${IP}:${PORT}/pkg/github.com/Andrew-M-C/go.jsonvalue/&lt;/span&gt;&lt;span&gt;，就可以访问我的jsonvalue库的GoDoc页面了，如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8008241758241759&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuX0muo9zRB4wdmt4I4ZEw2kXfeg82te9XuiayykicGa6FcvYqqnku6XT0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、pkgsite命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正如前文所说，现在Go官方维护和使用的是pkg.go.dev，因此本文主要说明pkgsite的用法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前的pkgsite要求Go 1.18版，因此请把Go版升级到&lt;/span&gt;&lt;span&gt;1.18&lt;/span&gt;&lt;span&gt;。然后我们需要安装pkgsite:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; install golang.org/x/pkgsite/cmd/pkgsite&lt;span class=&quot;code-snippet__variable&quot;&gt;@latest&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后和godoc类似:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;cd&lt;/span&gt; XXXX; &lt;span class=&quot;code-snippet__attribute&quot;&gt;pkgsite&lt;/span&gt; -http=:&lt;span class=&quot;code-snippet__number&quot;&gt;6060&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一样用jsonvalue举例。浏览器的地址与godoc类似，但是少了“pkg/”&lt;/span&gt;&lt;span&gt;，页面如下图所示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5614754098360656&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXbdCnJicc57M7TI2wMmg21X7ibP7vwhCGNspuIHXUT7PrR0ze2BCwRBOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、pkg.go.dev内容&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;47127876326af06c2f88f445be155d94&quot;&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;（一）总体内容&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于笔者在&lt;/span&gt;&lt;span&gt;jsonvalue&lt;/span&gt;&lt;span&gt;中对GoDoc玩得比较多，因此还是以这个库为例子。我们打开pkg.go.dev中相关包的主页，可以看到这些内容:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5915300546448088&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXwaYo4c7d52iaug5aEkFYblCT8neJ0YAm1LOav9CLzZRtZNvxvyD7TSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A-当前package的完整路径。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;B-当前package的名称，其中的module表示这是一个符合go module的包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C-当前package的一些基础信息，包括最新版本、发布时间、证书、依赖的包数量（包括系统包）、被引用的包数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;D-如果当前package包含README文件，则展示README文件的内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;E-当前package内的comment as document文档内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;F-当前package的文件列表，可以点击快速浏览。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;G-当前package的子目录列表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你的README (markdown格式) 有子标题，那么pkgsite会生成 README 下的二级目录索引。Markdown的格式在本文就不予说明，相信码农们都耳熟能详了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）Documentation&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;让我们点开Documentation，一个完整的package，可能包含以下这些内容:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9359430604982206&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXlic2Pn3ia33DcHVV9ciaPtpg3bIgv9O5ncZbYp45N03EICXHkaNtBPuzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;372&quot; data-ratio=&quot;0.33985330073349634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXOTB43yqEeSFicXqaM0T6J8C822efDx4f7sNDyiaQoWqsdtR3TyrQv0sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实Documentation的内容，就是GoDoc。Go秉承“注释即文档”的理念，其中pkg.go.dev、godoc和pkgsite都使用同一套GoDoc格式，三者都按照该格式从文档的注释中提取，并生成文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面我们具体来说明一下GoDoc的语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、GoDoc语法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在GoDoc中，当前package的所有可导出类型，都会在pkg.go.dev页面中展示出来，即便某个可导出类型没有任何的注释，GoDoc也会将这个可导出内容的原型展示出来——当然了，我们应该时时刻刻记住：所有的可导出内容，都应该写好注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GoDoc支持//和/* ... */两种模式的注释符。但是笔者还是推荐使用//，这也是目前的注释符主流，而且大部分IDE也都支持一键将多行文本直接转为注释（比如Mac的VsCode，使用command+/）。虽然/* */在多行注释中非常方便，但一旦看到这个，总觉得好像是上古时代的代码 (狗头)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（一）绑定GoDoc与指定类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于任意一个可导出内容，紧跟着代码定义上方一行的注释，都会被视为该内容的GoDoc，从而被提取出来。比如说：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type SomeTypeA &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;{&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type SomeTypeB &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;{&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type SomeTypeC &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;{&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个类型在pkgsite页面上的展示效果是这样的:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4793388429752066&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXNBeMibKE3poU03Yp3eKibneFACrxscpibrH0mub9GiaSOZzTAeoEAhLr2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，请读者注意，按照Go官方的推荐，代码注释的第一个单词，应该是被注释的内容本身。比如前文中，SomeTypeA的注释应该是// SomeTypeA开头。下文开始将会统一使用这一规范。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）换行（段落）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读者可以注意到，前文中的所有有效注释，我都换了一行；但是在pkgsite的页面展示中，并没有&lt;/span&gt;&lt;span&gt;发生换行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，在注释中如果只是单纯的一个换行另写注释的话，在页面是不会将其当作&lt;/span&gt;&lt;span&gt;新的一段&lt;/span&gt;&lt;span&gt;来看待的，GoDoc的逻辑，也仅仅渲染完这一行之后，再&lt;/span&gt;&lt;span&gt;加一个空格&lt;/span&gt;&lt;span&gt;，然后继续渲染下一行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果要在同一个注释块中新加一个段落，那么我们需要插入一行空注释，如下:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SomeNewLine&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; error {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4226044226044226&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXXtr7Htonp656WKdkgvgMdY28fI6GMwv1RzNA6YXZCVib7iay45XpQgyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;407&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;（三）内嵌代码&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有需要的话，我们可以在注释中内嵌一小段代码，代码会被独立为一个段落，并且使用等宽字符展示。比如下面的一个例子:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;IntsElem&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ints []&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, index &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(value, actualIndex &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7428998505231689&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXL7GSDzWiaZsCRAPgtFflwn5LibdhY6CDzptGdodVbMtjibaaOKo9ZvPGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt;：在注释块中，如果部分注释行符合以下标准之一，则视为代码块:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;普通注释和代码块之间可以不用专门的空注释行，但个人建议还是加上比较好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;六、Overview部分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Documentation中的Overview部分，是整个package的说明，这种类型的注释，被称为“包注释”。包注释是写在go文件最开始的package xxx上面。虽然GoDoc没有限制、但是Go官方建议包注释应当以// Package xxx开头作为文本的主语。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果在一个package中，有多个文件都包含了包注释，那么GoDoc会按照文件的字典序，依次展示这些文件中的包注释。但这样可能会带来混乱，因此一个package我们应当&lt;/span&gt;&lt;span&gt;只在一个文件&lt;/span&gt;&lt;span&gt;中写包注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般而言，我们可以选择以下的文件写包注释：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;七、弃用代码声明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go所使用的版本号是vX.Y.Z的模式，按照官方的思想，每当package升级时，尽量不要升级大版本X值，这也同时代表着，本次升级是完全向前兼容的。但是实际上，我们在做一些小版本或中版本升级时，有些函数/类型可能不再推荐使用。此时，GoDoc提供了一个关键字Deprecated:，作为整个注释块的第一个单词，比如我们可以这么写:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ElemAt&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ints []&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, index &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对deprecated的内容，pkgsite一方面会在目录中标识出来：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.27520435967302453&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXiadv5sndQrq2KgOqnnric7E34srwFlGLLdWYcHUqffhibXhvSCib72NFeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;367&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，在正文中，也会刻意用灰色字体低调展示，并且隐藏注释正文，需要点开才能显示:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31547619047619047&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXkBxqy8fvCnkz5M9NelsJPt1AI2muFcJhQp99BoPQkwNFAia1pdueibnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42936802973977695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXnlXBrAVqzbsJdHxjmfVjsX0o3qX8gibgd1sX2ViaBDf984vamkDEXwCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;538&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;八、代码示例文档&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读者如果看我jsonvalue的&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;span&gt;（https://pkg.go.dev/github.com/Andrew-M-C/go.jsonvalue#Set.At）&lt;/span&gt;&lt;span&gt;，在At()函数下，除了上文提到的文档正文之外，还有五个代码示例:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1630434782608696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXnWTsMiafe3nhHHKAYe8QzGxWLVpS4OAFV1Lib9EzDJz28l6elic0DHZrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，文档中的代码示例又应该如何写呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们应该新建至少一个文件，专门用来存放示例代码。比如我就把示例代码写在了&lt;/span&gt;&lt;span&gt;example_jsonvalue_test.go&lt;/span&gt;&lt;span&gt;（https://github.com/Andrew-M-C/go.jsonvalue/blob/master/example_jsonvalue_test.go）&lt;/span&gt;&lt;span&gt;文件中。这个文件的package名&lt;/span&gt;&lt;span&gt;不得&lt;/span&gt;&lt;span&gt;与当前包名相同，而应该命名为包名_test的格式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，需要注意的是，示例代码文件也属于单元测试文件的内容，当执行go test的时候，示例文件也会纳入测试逻辑中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;（一）示例代码的声明&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何声明一个示例代码，这里我举两个例子。首先是在At()函数下名为“Example (1)”的示例。在&lt;/span&gt;&lt;span&gt;代码&lt;/span&gt;&lt;span&gt;（https://github.com/Andrew-M-C/go.jsonvalue/blob/master/example_jsonvalue_test.go#L112）&lt;/span&gt;&lt;span&gt;中，我把这个函数命名为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ExampleSet_At_1&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ......&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个函数命名有几个部分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;368&quot; data-ratio=&quot;0.47336561743341404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXLKNABaOW1gH0GgMRpH9TehxyeaUibYsgSZPqPfP2xp9D5DIJYJ4wPKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;826&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，示例代码中应该包含标准输出内容，这样便于读者了解执行情况。标准输出内容在函数内的最后，采用//Output: 单独起一行开头，剩下的每一行标准输出写一行注释。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相对应地，如果你想要给（不属于任何一个类型的）函数写示例的话，则去掉上文中关于“类型”的字段；如果你不需要示例的额外说明符，则去掉“额外说明”字段。比如说，我给类型Opt写的&lt;/span&gt;&lt;span&gt;示例&lt;/span&gt;&lt;span&gt;（https://pkg.go.dev/github.com/Andrew-M-C/go.jsonvalue#example-Opt）&lt;/span&gt;&lt;span&gt;就只有一个，在&lt;/span&gt;&lt;span&gt;代码&lt;/span&gt;&lt;span&gt;（https://github.com/Andrew-M-C/go.jsonvalue/blob/master/example_jsonvalue_test.go#L43）&lt;/span&gt;&lt;span&gt;中，只有一行：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ExampleOpt&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ........&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-pid=&quot;urq2DLCG&quot;&gt;&lt;span&gt;甚至连示例说明都没有。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;18XfcGAo&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;18XfcGAo&quot;&gt;&lt;span&gt;如果一个元素包含多个例子，那么godoc会按照字母序对示例及其相应的说明排序。这也就是为什么我干脆在At()函数中，示例标为一二三四五的原因，因为这是我希望读者阅读示例的顺序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;（二）在官网上发布GoDoc&lt;/span&gt;&lt;/h2&gt;&lt;p data-pid=&quot;zcbjOZKc&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;zcbjOZKc&quot;&gt;&lt;span&gt;好了，当你写好了自己的GoDoc之后，总不是自己看自己自娱自乐吧，总归是要发布出来给大家看的。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;qXmkhr1w&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;qXmkhr1w&quot;&gt;&lt;span&gt;其实发布也很简单：当你将包含了godoc的代码push之后（比如发布到github上），就可以在浏览器中输入&lt;/span&gt;&lt;span&gt;https://pkg.go.dev/${package&lt;/span&gt;&lt;span&gt;路径名}。比如jsonvalue的Github路径（也等同于import路径）为github.com/Andrew-M-C/go.jsonvalue，因此输入&lt;/span&gt;&lt;span&gt;（https://pkg.go.dev/github.com/Andrew-M-C/go.jsonvalue）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;PVzBBFL5&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;PVzBBFL5&quot;&gt;&lt;span&gt;如果这是该页面第一次进入，那么pkg.go.dev会首先获取、解析和更新代码仓库中的文档内容，并且格式化之后展示。在pkg.go.dev中，如果能够找到package的最新的tag版本，那么会列出tag（而不是主干分支）上的GoDoc。&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;7RFVYiOk&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;7RFVYiOk&quot;&gt;&lt;span&gt;接下来更重要的是，把这份官网GoDoc的链接，附到你自己的README中。我们可以进入pkg.go.dev的徽章&lt;/span&gt;&lt;span&gt;生成页&lt;/span&gt;&lt;span&gt;（‍‍‍‍‍‍‍‍https://pkg.go.dev/badge/‍）&lt;/span&gt;&lt;/p&gt;&lt;p data-pid=&quot;lFZIQI_9&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;lFZIQI_9&quot;&gt;&lt;span&gt;输入仓库地址就可以看到相应的徽标的链接了。有html和markdown格式任君选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4089012517385257&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96kvUiciaBDtysB0TyYb38EuXcDOjfZPv160mjoSBrDd8N3F2Yia38PhL0F3mAlurzDf3WVicSorIiaxHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 data-lines=&quot;1&quot; data-sign=&quot;381759e8570981ca8c2525ac43ac6e29&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;1.万字长文解读pkg.go.dev的设计和实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.pkg.go.dev源码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（ 转载须取得作者同意，未经许可，禁止二次转载 ）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96SRqf4rwjRZ7TstUgZ6cGKx9ZRexVj1drFu08iazan3pfh6rzHiau2ZsibJtUOfVSnIHwnic2vdlSBVA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1190&quot; data-cropy1=&quot;396.66666666666663&quot; data-cropy2=&quot;1609.3333333333333&quot; data-fileid=&quot;100043716&quot; data-ratio=&quot;1.0176470588235293&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96D9DZQ9GNR0xO99zOSKJShS94uRQuafQprgbibJ7YqxZgByDAMPVewXFxxPqUjmaWibZAWjUTcnaOA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1190&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;张敏&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;腾讯高级后台工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯高级后台工程师，在电子和互联网行业深耕多年，拥有丰富的嵌入式和云服务后台开发经验，个人博客共有过百篇文章，云+社区Top50原创作者，技术创作101第二季讲师，现负责腾讯产品后台开发。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>