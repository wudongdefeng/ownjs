<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>31be97703c45fb6d1e27f144dde10c16</guid>
<title>数据同步 Gossip 协议原理与应用场景介绍</title>
<link>https://toutiao.io/k/ofebmur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作者：京东物流 冯鸿儒 &lt;/p&gt;

&lt;h1&gt;1 简介&lt;/h1&gt;

&lt;p&gt;Gossip是一种p2p的分布式协议。它的核心是在去中心化结构下，通过将信息部分传递，达到全集群的状态信息传播，传播的时间收敛在O（Log（N））以内，其中N是节点的数量。基于gossip协议，可以构建出状态一致的各种解决方案。&lt;br/&gt;
一些常见的分布式协议如二阶段提交协议和 Raft 算法，你发现它们都需要全部节点或者大多数节点正常运行，才能稳定运行。而Gossip即使只有一个节点可用也能提供服务。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;1.1 适用场景&lt;/h2&gt;

&lt;p&gt;适用于AP 场景的数据一致性处理：分布式数据库中节点同步数据使用（如Apache Cassandra、Redis Cluster）；&lt;br/&gt;
其他场景如信息扩散、集群成员身份确认、故障探测等（如Consul）。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;1.2 优势&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;  学习成本：实现简单&lt;/li&gt;
&lt;li&gt;  扩展性：允许节点的任意增加和减少，新增节点的状态 最终会与其他节点一致。&lt;/li&gt;
&lt;li&gt;  容错：任意节点的宕机和重启都不会影响 Gossip 消息的传播，具有天然的分布式系统容错特性。可以在一定程度上避免网络分割带来的问题。&lt;/li&gt;
&lt;li&gt;  去中心化：无需中心节点，所有节点都是对等的，任意节点无需知道整个网络状况，只要网络连通，任意节点可把消息散播到全网。&lt;/li&gt;
&lt;li&gt;  性能：指数级一致性收敛。消息会以“一传十的指数级速度”在网络中传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。&lt;br/&gt;
Gossip协议的最大的好处是，即使集群节点的数量增加，每个节点的负载也不会增加很多，几乎是恒定的。如Consul管理的集群规模能横向扩展到数千个节点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;1.3 劣势&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;  消息延迟：节点随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网；不可避免的造成消息延迟。&lt;/li&gt;
&lt;li&gt;  消息冗余：节点定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤；不可避免的引起同一节点消息多次接收，增加消息处理压力。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;2 细节介绍&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.1 传播方式&lt;/h2&gt;

&lt;p&gt;Gossip 协议的消息传播方式主要有两种：Anti-Entropy(反熵传播)和 Rumor-Mongering(谣言传播)。&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;2.1.1 反熵传播&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  定义：反熵（指消除不同节点中数据的差异，提升节点间数据的相似度，降低熵值）。反熵传播：以固定的概率传播所有的数据，可用来避免因为UDP数据包丢失或者新节点的加入而导致的集群元数据不一致问题。&lt;/li&gt;
&lt;li&gt;  过程：集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。&lt;/li&gt;
&lt;li&gt;  适用场景：执行反熵时，相关的节点都是已知的，而且节点数量不能太多，如果是一个动态变化或节点数比较多的分布式环境（比如在 DevOps 环境中检测节点故障，并动态维护集群节点状态），这时反熵就不适用了。&lt;/li&gt;
&lt;li&gt;  缺点：消息数量非常庞大，且无限制；通常只用于新加入节点的数据初始化。可以通过引入校验和（Checksum）等机制，降低需要对比的数据量和通讯消息等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d049754043634711a9652f16014171f7%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;2.1.2 谣言传播&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  定义：当一个节点有了新数据后，这个节点变成活跃状态，并周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。&lt;/li&gt;
&lt;li&gt;  过程：消息只包含最新 update，谣言消息在某个时间点之后会被标记为 removed，并且不再被传播。&lt;/li&gt;
&lt;li&gt;  当一个新节点A连接到Gossip集群内的某个节点B时，A节点会将自己的信息发送给B节点，然后B节点会在集群中随机选取几个未被传染的节点，向他们广播A节点的信息（首次传染），集群中的其他节点收到A节点的信息后，又会像B节点那样广播A节点的信息给其他未被传染的节点（二次传染）。直至多次传染后，集群所有节点都收到了A节点的信息，同步完成。&lt;/li&gt;
&lt;li&gt;  适用场景：适合动态变化的分布式系统。&lt;/li&gt;
&lt;li&gt;  缺点：系统有一定的概率会不一致，通常用于节点间数据增量同步。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c650cb5033048e09fb19aa7e2132604%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.2 通信方式&lt;/h2&gt;

&lt;p&gt;Gossip 协议最终目的是将数据分发到网络中的每一个节点。根据不同的具体应用场景，网络中两个节点之间存在三种通信方式：推送模式、拉取模式、Push/Pull。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据&lt;/li&gt;
&lt;li&gt;  Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地&lt;/li&gt;
&lt;li&gt;  Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;2.3 执行示例&lt;/h2&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;2.3.1 状态的传播&lt;/h3&gt;

&lt;p&gt;以Gossip协议同步状态的思路类似于流言的传播,如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a05910d0e3e4992b7718ea8882c3b75%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;A节点率先知道了某个流言（msg），它首先将此信息传播到集群中的部分节点（比如相邻的两个节点）B和C，后者再将其传递到它们所选择的“部分”节点，例如B选择了D和E，C选择了将流言传播到B和F。以此类推，最终来自于A的这条流言在3轮交互后被传播到了集群中的所有节点。&lt;br/&gt;
在分布式系统的实践中，这个“流言”可能是：某个节点所感知到的关于其它节点是否宕机的认识；也可能是数据水平拆分的缓存集群中，关于哪些hash桶分布在哪些节点上的信息。每个节点起初只掌握部分状态信息，不断地从其它节点收到gossip信息，每个节点逐渐地掌握到了整个集群的状态信息。因此解决了状态同步的第一个问题：全集状态的获取。&lt;br/&gt;
对于集群中出现的部分网络分割，消息也能通过别的路径传播到整个集群。如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f7d42930fe142119d2519606692b9ef%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;&quot;/&gt;2.3.2 状态的一致&lt;/h3&gt;

&lt;p&gt;状态同步的第二个问题：对于同一条状态信息，不同的节点可能掌握的值不同，也能通过基于gossip通信思路构建的协议包版本得到解决。例如水平拆分的redis缓存集群，初始状态下hash桶在各个节点的分布如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39da9835e9f14c5e87090c23f93edafe%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;此时各个节点预先通过某种协议（比如Gossip）得知了集群的状态全集，此时新加入了节点D，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f62312d5cd34383865390f36bb38206%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;D分担了C的某个hash桶，此时C/D和集群中其它节点就C所拥有哪些hash这件事发生了分歧：A/B认为C目前有6/7/8个hash桶。此时通过为gossip消息体引入版本号，使得关于C的最新状态信息（只有6/7两个桶了）在全集群达到一致。例如B收到来自A和C的gossip消息时会将版本号更新的消息（来自C的v2）更新到自己的本地副本中。&lt;br/&gt;
各个节点的本地副本保存的集群全量状态也可能用来表示各个节点的存活状态。对于部分网络分割的情况如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b973baa269494f09bf5eef6a0bfa0e46%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;例如A和C的网络断开，但A和C本身都正常运行，此时A和C互相无法通信，C会将A标记为不可用状态。对于中心化思路的协议，如果C恰好是中心节点，那么A不可用的信息将会同步到集群的所有节点上，使得这些节点将其实可用的A也标记为宕机。而基于gossip这类去中心化的协议进行接收到消息后的实现逻辑扩展（例如只有当接收到大多数的节点关于A已经宕机的消息时，才更新A的状态），最终保证A不被误判为宕机。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;3 开源软件中的应用&lt;/h1&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.1 Fabric&lt;/h2&gt;

&lt;p&gt;Fabric gossip使用push（从成员视图随机选出活跃邻居，给他们转发消息），pull（定期探测，请求遗失的消息）的方式扩散区块。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.2 Cassandra&lt;/h2&gt;

&lt;p&gt;Cassandra使用的是pull-push，这种方式是均等的，会有3次发送，但是发送完以后双方都可以更新彼此的信息。利用pull-push方式，如果A要与B节点同步，需要进行如下图的三个通信阶段。&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.3 RedisCluster&lt;/h2&gt;

&lt;p&gt;Redis Cluster 在运行时，每个实例上都会保存 Slot 和实例的对应关系（也就是 Slot 映射表），以及自身的状态信息。新节点加入、节点故障、Slot 变更等事件发生时，实例间也可以通过 gossip协议进行PING、PONG 消息的传递，完成集群状态在每个实例上的同步。&lt;br/&gt;
redisCluster默认组建集群的方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  通过cluster meet命令将一个节点跟集群中其中一个节点建立连接（此时只能被集群中这一个节点认识）&lt;/li&gt;
&lt;li&gt;  通过Gossip消息转播给其他节点，其他节点收到消息后，再通过类似meet的命令来跟对新节点建立集群连接（需要一定时间的扩散）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;使用gossip算法利用PFAIL和FAIL flags的转换和传播来判定故障&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a href=&quot;&quot;/&gt;3.4 Consul&lt;/h2&gt;

&lt;p&gt;一致性协议采用 Raft 算法,用来保证服务的高可用.&lt;br/&gt;
成员管理和消息广播 采用GOSSIP协议，支持ACL访问控制。&lt;br/&gt;
consul是建立在serf之上的，它提供了一个完整的gossip协议，用在很多地方。Serf提供了成员，故障检测和事件广播。Gossip的节点到节点之间的通信使用了UDP协议。&lt;br/&gt;
Consul的每个Agent会利用Gossip协议互相检查在线状态，本质上是节点之间互Ping，分担了服务器节点的心跳压力。如果有节点掉线，不用服务器节点检查，其他普通节点会发现，然后用Gossip广播给整个集群。&lt;/p&gt;

&lt;h1&gt;&lt;a href=&quot;&quot;/&gt;4 总结&lt;/h1&gt;

&lt;p&gt;gossip协议是很多开源中间件和区块链实现的一种底层通信机制，掌握它的原理和细节能更好的理解中间件和区块链的一些行为和分布式特性。&lt;/p&gt;

&lt;hr/&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>70059b4dd9437e8395193b1fe30a2417</guid>
<title>9 款日志采集 &amp; 管理工具对比，选型必备！</title>
<link>https://toutiao.io/k/fvalcvc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;你好，我是悟空。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;先汇总下之前写的搭建 elk日志系统相关文章&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451965505&amp;amp;idx=1&amp;amp;sn=1f87587285229e118ae40eeaa0a7a5c9&amp;amp;chksm=8d1fffdeba6876c865249f844f020b1a5f12f29bd5367486cfd5fdb84621979e79146f4dc797&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;被一位读者赶超，手摸手 Docker 部署 ELK Stack&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;1、被一位读者赶超，手摸手 Docker 部署 ELK Stack&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451963107&amp;amp;idx=1&amp;amp;sn=22df0b863365b5a0e1b5eab2bf5ce5a6&amp;amp;chksm=8d1c057cba6b8c6a8783282a470ae1c67262a5b6983ca38f4c17420a0eab728fe364d2a1557e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;深入理解 ELK 中 Logstash 的底层原理 + 填坑指南&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2、深入理解 ELK 中 Logstash 的底层原理 + 填坑指南&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;amp;mid=2451962693&amp;amp;idx=1&amp;amp;sn=96530613aaadd8240d8a5c2ab7dff49d&amp;amp;chksm=8d1c02daba6b8bcc2499861fd37aac5cfa88d616fc839cb6a7a3c003118457ac325c3dcbeb62&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;7000 字 | 20 图 | 一文带你搭建一套 ELK Stack 日志平台&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;3、20 图 | 一文带你搭建一套 ELK Stack 日志平台&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;Java架构进阶网站：passjava.cn&lt;br/&gt;&lt;/span&gt;&lt;span&gt;原文：https://sourl.cn/WmX6SD&lt;/span&gt;&lt;/p&gt;&lt;p&gt;对于日志管理当前网络上提供了大量的日志工具，今天就给大家分析总结一下这些常用工具的特点，希望对你们在选型时有所帮助，&lt;/p&gt;&lt;p&gt;如果有用记得一键三连&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1、Filebeat&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Filebeat是用于转发和集中日志数据的轻量级传送程序。作为服务器上的代理安装，Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或Logstash进行索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Filebeat的工作方式如下：启动Filebeat时，它将启动一个或多个输入，这些输入将在为日志数据指定的位置中查找。对于Filebeat所找到的每个日志，Filebeat都会启动收集器。每个收集器都读取一个日志以获取新内容，并将新日志数据发送到libbeat，libbeat会汇总事件并将汇总的数据发送到您为Filebeat配置的输出。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7819148936170213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCL60rPt3iaZLqEiaSXyprtwaGEn1WmsubeFria6OUib8Kapj93yyhCnwxuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;轻量级并且易使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块可用于常见用例（例如 Apache 访问日志）。您可以使用它们来设置 Filebeat、Ingest 和 Kibana 仪表板，只需几个命令&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;免费开源&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有限的解析和丰富功能&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、Graylog&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Graylog是一个开源的日志聚合、分析、审计、展现和预警工具。功能上和ELK类似，但又比ELK要简单，依靠着更加简洁，高效，部署使用简单的优势很快受到许多人的青睐。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6991735537190082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCP0O9yCGUvFTcpich4PKXHJqSYNrvicOH3ibIVcu93BibcDKHaFROIWpCiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个包含日志处理所有要素的软件包：收集、解析、缓冲、索引、搜索、分析。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源 ELK 堆栈无法提供的其他功能，例如基于角色的访问控制和警报&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在一个软件包中满足大多数集中式日志管理用例的需求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;轻松扩展存储 (Elasticsearch) 和获取通道&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可视化能力是有限的，至少与ELK的Kibana相比是如此&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不能使用整个ELK生态系统，因为他们不能直接访问Elasticsearch API。相反，Graylog有自己的API&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、LogDNA&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;LogDNA是日志管理领域的新成员。LogDNA可作为SaaS和内部使用，提供所有日志基础:通过syslog和HTTP(S)以及全文搜索和可视化，提供基于代理和无代理的日志收集，并提供清晰且具有竞争力的价格。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5161637931034483&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCiaf6Zz1NGFyaqS4ZQ0vRzTFd8tH7KHsxia64GP6crVG3ZPc9Z9yO2wpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用于在组织外部共享日志的嵌入式视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动解析常用日志格式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;免费：无存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收费：付费计划起价为每月每GB 1.50 美元，保留 7 天&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用于搜索日志的简单 UI，类似于 Papertrail&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易于理解的计划&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可视化能力有限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保留期取决于计划（从 7 天到 30 天）。用户数量也是如此（最便宜的计划只允许 5 个）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、ELK&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5302564102564102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCnv8d8uvDnLPtTubdoHaEdrxTAMhxibEDn4wW1cG8F7t5LhLTaw5U8bA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ELK堆栈包含了日志管理解决方案所需的大多数工具:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Log shippers：如Logstash和Filebeat&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Elasticsearch是一个可扩展的搜索引擎&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana作为搜索日志或构建可视化的UI&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它在集中日志方面非常流行，有很多关于如何在网络上使用它的教程。有一个庞大的工具生态系统，您可以在基本设置之上使用这些工具，通过警报、基于角色的访问控制等来增强它。我们将在这篇博文中详细介绍这些额外的附加功能，我们将在其中讨论 Elastic Stack 功能的替代方案。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Elasticsearch默认情况下对每个字段进行索引，使搜索速度更快&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过API和Kibana实现实时可视化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引前的数据解析和充实&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;免费和开源。一些公司提供托管 ELK 的形式，见上文。 还有 Elastic Cloud，它是云中 ELK 的一种纯粹形式，您主要需要自己管理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;可扩展的搜索引擎作为日志存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成熟的log shippers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kibana 中的 Web UI 和可视化&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在规模上，它可能变得难以维护。这就是 Sematext 提供 ELK 堆栈咨询、生产支持和培训的原因&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ELK Stack 的开源版本缺少一些功能，例如基于角色的访问控制和警报。您可以通过商业“Elastic Stack 功能”或其替代品或 Visa Open Distro for Elasticsearch 获得这些功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、Grafana Loki&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Loki 及其生态系统是 ELK 堆栈的替代方案，但它做出了不同的权衡。通过仅索引某些字段（标签），它可以具有完全不同的架构。也就是说，主要的写入组件（Ingester）会将大量日志保存在内存中，从而使最近的查询速度更快。随着块变老，它们被写入两个地方：用于标签的键值存储（例如 Cassandra）和用于块数据的对象存储（例如 Amazon S3）。当您添加数据时，它们都不需要后台维护（例如 Elasticsearch/Solr 需要合并）。&lt;br/&gt;如果您查询较旧的数据，您通常会按标签和时间范围进行过滤。这限制了必须从长期存储中检索的块的数量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.576271186440678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCLwLnJEc1QxwbqfxBTbic0ciadE4kzZ8l4QRQv0LlF2RMMk5IQgElIY6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;同一 UI 中的日志和指标 (Grafana)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Loki 标签可以与 Prometheus 标签保持一致&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;免费：免费开源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;收费：还有Grafana Cloud，提供Loki的SaaS服务(也有内部部署的选项)。价格从49美元起，包括100GB的日志存储(30天保留)和3000个度量系列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与 ELK 相比，摄取速度更快：索引更少，无需合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小存储占用：较小的索引，数据只写入一次到长期存储（通常具有内置复制）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用更便宜的存储（例如 AWS S3）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与 ELK 相比，较长时间范围内的查询和分析速度较慢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 ELK 相比，log shippers选项更少（例如 Promtail 或 Fluentd）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不如 ELK 成熟（例如更难安装）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6、Datadog&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Datadog 是一种 SaaS，最初是作为监控 (APM) 工具，后来还添加了日志管理功能。您可以通过 HTTP(S) 或 syslog，通过现有的日志传送器（rsyslog、syslog-ng、Logstash 等）或通过 Datadog 自己的代理发送日志。它的特点是 Logging without Limits™，这是一把双刃剑：更难预测和管理成本，但您可以获得即用即付定价（见下文）以及您可以存档和从存档中恢复的事实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49948717948717947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCWzxxI6knr5BCp8f453pHJ07Shhiac8rP8fJoiaicC9SA0He0P6Qvp0pPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用于解析和丰富日志的服务器端处理管道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动检测常见的日志模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以将日志归档到 AWS/Azure/Google Cloud 存储并在以后重新使用它们&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;处理起价为每月每GB 0.10 美元（例如 1GB 每天 3 美元）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理也适用于从档案中获取，尽管这里的数据是压缩的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;100 万个事件的存储起价为 1.59 美元，为期 3 天（例如，47.7 美元，1GB/天，每个 1K，存储 3 天）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;容易搜索，良好的自动完成(基于facet)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与DataDog指标和跟踪的集成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负担得起，特别是对于短期保留和/或如果你依靠存档进行一些搜索&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现场不可用。一些用户抱怨成本失控（由于定价灵活）。虽然您可以设置每日处理配额&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7、Logstash&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Logstash 是一个日志收集和处理引擎，它带有各种各样的插件，使您能够轻松地从各种来源摄取数据，将其转换并转发到定义的目的地。它与 Elasticsearch 和 Kibana 一起是 Elastic Stack 的一部分，这就是为什么它最常用于将数据传送到 Elasticsearch。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41502463054187194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCSKJjDnaSmyTEEVYJ8TvIdofymiaibicoHyaibpzhSw8munF41h5l15kqaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;许多内置的输入、过滤/转换和输出插件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灵活的配置格式:您可以添加内联脚本，包括其他配置文件等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;免费开源&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;容易开始和移动到复杂的配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;灵活:Logstash用于各种日志记录用例，甚至用于非日志记录数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写得很好的文档和大量的操作指南&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与其他日志shippers相比，资源使用率高&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与替代品相比，性能较差&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8、Fluentd&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个很好的 Logstash 替代品，Fluentd 是 DevOps 的最爱，特别是对于 Kubernetes 部署，因为它具有丰富的插件库。与 Logstash 一样，它可以将数据结构化为 JSON，并涉及日志数据处理的所有方面：收集、解析、缓冲和输出跨各种来源和目的地的数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6278026905829597&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCaM9bvicppW6LenjgFs2hL7K2yEIYxuZkw8hXtXDjiaLG0qJjtPPpm2lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;与库和Kubernetes的良好集成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大量的内置插件，很容易编写新的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;免费开源&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;良好的性能和资源使用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;良好的插件生态系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易于使用的配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;良好的文档&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解析前没有缓冲，可能会导致日志管道出现背压&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对转换数据的支持有限，就像您可以使用 Logstash 的 mutate 过滤器或 rsyslog 的变量和模板一样&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9、Splunk&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Splunk 是最早的商业日志集中工具之一，也是最受欢迎的。典型的部署是本地部署 (Splunk Enterprise)，尽管它也作为服务提供 (Splunk Cloud)。您可以将日志和指标发送到 Splunk 并一起分析它们。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5075&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9Tz1fxyDfYFf5PcdoKv7xUicCUy2rm2xUO9NC9RcaKzIS6barW8YwoWE6OiaLzX4jcm5ic2cGmooVpSjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.1 主要特点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用于搜索和分析的强大查询语言&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;搜索时字段提取（在摄取时解析之外）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动将经常访问的数据移动到快速存储，将不经常访问的数据自动移动到慢速存储&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.2 价格&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;免费：每天 500MB 数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;付费计划可应要求提供，但常见问题解答建议 1GB 的起价为 150 美元/月&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.3 优点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;成熟且功能丰富&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于大多数用例来说，良好的数据压缩(假设有有限的索引，正如推荐的那样)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志和度量在一个屋檐下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;9.4 缺点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;贵&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于较长的时间范围，查询速度较慢(建议使用有限的索引)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用于度量存储的效率低于专注于监控的工具&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8 年互联网开发经验，擅长微服务、分布式、架构设计。目前在一家大型上市公司从事基础架构和性能优化工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InfoQ 签约作者、蓝桥签约作者、阿里云专家博主、51CTO 红人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎加入悟空的私密星球，提供 PassJava项目答疑、微服务知识答疑、面试修改等。（&lt;span&gt;下方扫码加入）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2047872340425532&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ2xvxrsJDRuhkZxFiac1CaMVhnz07Rsdrznrt7VYhMfbiciaaSOic5Gtm7VQRhQztFdZRgPOaz86sZNbg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;悟空的多个技术专题&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;33 篇 SpringCloud 实战，回复&lt;span&gt;PDF&lt;/span&gt;获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8 篇分布式算法文章，回复&lt;span&gt;分布式&lt;/span&gt;获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7 篇JVM 专项训练，回复&lt;span&gt;JVM&lt;/span&gt;获取。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;Elasticsearch 筋斗云版蓝皮书1.0，回复&lt;/span&gt;&lt;span&gt;ES&lt;/span&gt;&lt;span&gt;获取&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试必备资料，关注即可获取。↓↓&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-id=&quot;MzU3NzU5NTg5Mg==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/GfOyjHGwCoN5Ky9IZgsdyZgM3lbEC5Ixe3ZgxBu5MdzvjWFyC7uqrsffcyhtrD8r8t0qicxbGmNxKYr4l4mANKQ/0?wx_fmt=png&quot; data-nickname=&quot;面试突击&quot; data-alias=&quot;PassJava1&quot; data-signature=&quot;大厂面试突击，专注分享面试题，如计算机基础、计算机网络、Java后端、前端Vue。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot; data-index=&quot;0&quot; data-origin_num=&quot;15&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;我是悟空，努力变强，变身超级赛亚人！&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e131ed30f7262d017b4958dc0aa689ef</guid>
<title>聊一聊，我对 DDD 的关键理解</title>
<link>https://toutiao.io/k/au0do6l</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context wx_tap_card js_wx_tap_highlight&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                  
                  &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;阿里技术&lt;/strong&gt;
                                          &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                      &lt;p class=&quot;original_primary_desc&quot;&gt;阿里技术官方号，阿里的硬核技术、前沿创新、开源项目都在这里。&lt;/p&gt;
                                      &lt;/div&gt;
                  &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                &lt;/a&gt;
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b47a945456cc6072975951eade90d8ee</guid>
<title>解读 Java 云原生实践中的内存问题</title>
<link>https://toutiao.io/k/23by4f8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;mQseWA1n&quot;&gt;Java 凭借着自身活跃的开源社区和完善的生态优势，在过去的二十几年一直是最受欢迎的编程语言之一。步入云原生时代，蓬勃发展的云原生技术释放云计算红利，推动业务进行云原生化改造，加速企业数字化转型。&lt;/p&gt;&lt;p data-pid=&quot;JLGJot5F&quot;&gt;然而 Java 的云原生转型之路面临着巨大的挑战，Java 的运行机制和云原生特性存在着诸多矛盾。企业借助云原生技术进行深层次成本优化，资源成本管理被上升到前所未有的高度。公有云上资源按量收费，用户对资源用量十分敏感。在内存使用方面，基于 Java 虚拟机的执行机制使得任何 Java 程序都会有固定的基础内存开销，相比 C++/Golang 等原生语言，Java 应用占用的内存巨大，被称为“内存吞噬者”，因此 Java 应用上云更加昂贵。并且应用集成到云上之后系统复杂度增加，普通用户对云上 Java 应用内存没有清晰的认识，不知道如何为应用合理配置内存，出现 OOM 问题时也很难排障，遇到了许多问题。&lt;/p&gt;&lt;p data-pid=&quot;1jCaPpd4&quot;&gt;为什么堆内存未超过 Xmx 却发生了 OOM？怎么理解操作系统和JVM的内存关系？为什么程序占用的内存比 Xmx 大不少，内存都用在哪儿了？为什么线上容器内的程序内存需求更大？本文将 EDAS 用户在 Java 应用云原生化演进实践中遇到的这些问题进行了抽丝剥茧的分析，并给出云原生 Java 应用内存的配置建议。&lt;/p&gt;&lt;h2&gt;背景知识&lt;/h2&gt;&lt;h2&gt;K8s 应用的资源配置&lt;/h2&gt;&lt;p data-pid=&quot;z0646Mci&quot;&gt;云原生架构以 K8s 为基石，应用在 K8s 上部署，以容器组的形态运行。K8s 的资源模型有两个定义，资源请求（request）和资源限制（limit），K8s 保障容器拥有 request数量的资源，但不允许使用超过limit数量的资源。以如下的内存配置为例，容器至少能获得 1024Mi 的内存资源，但不允许超过 4096Mi，一旦内存使用超限，该容器将发生OOM，而后被 K8s 控制器重启。 &lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; spec:
  containers:
  - name: edas
    image: alibaba/edas
    resources:
      requests:
        memory: &quot;1024Mi&quot;
      limits:
        memory: &quot;4096Mi&quot;
    command: [&quot;java&quot;, &quot;-jar&quot;, &quot;edas.jar&quot;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;容器 OOM&lt;/h2&gt;&lt;p data-pid=&quot;ZxOhLbM9&quot;&gt;对于容器的 OOM 机制，首先需要来复习一下容器的概念。当我们谈到容器的时候，会说这是一种沙盒技术，容器作为一个沙盒，内部是相对独立的，并且是有边界有大小的。容器内独立的运行环境通过 Linux的Namespace 机制实现，对容器内 PID、Mount、UTS、IPD、Network 等 Namespace 进行了障眼法处理，使得容器内看不到宿主机 Namespace 也看不到其他容器的 Namespace；而所谓容器的边界和大小，是指要对容器使用 CPU、内存、IO 等资源进行约束，不然单个容器占用资源过多可能导致其他容器运行缓慢或者异常。Cgroup 是 Linux 内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，也是实现容器资源约束的核心技术。容器在操作系统看来只不过是一种特殊进程，该进程对资源的使用受 Cgroup 的约束。当进程使用的内存量超过 Cgroup 的限制量，就会被系统 OOM Killer 无情地杀死。&lt;/p&gt;&lt;p data-pid=&quot;vpGrLJgQ&quot;&gt;所以，所谓的容器 OOM，实质是运行在Linux系统上的容器进程发生了 OOM。Cgroup 并不是一种晦涩难懂的技术，Linux 将其实现为了文件系统，这很符合 Unix 一切皆文件的哲学。对于 Cgroup V1 版本，我们可以直接在容器内的 /sys/fs/cgroup/ 目录下查看当前容器的 Cgroup 配置。&lt;/p&gt;&lt;p data-pid=&quot;bthEBA3M&quot;&gt;对于容器内存来说，memory.limit_in_bytes 和 memory.usage_in_bytes 是内存控制组中最重要的两个参数，前者标识了当前容器进程组可使用内存的最大值，后者是当前容器进程组实际使用的内存总和。一般来说，使用值和最大值越接近，OOM 的风险越高。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; # 当前容器内存限制量
$ cat /sys/fs/cgroup/memory/memory.limit_in_bytes
4294967296
# 当前容器内存实际用量
$ cat /sys/fs/cgroup/memory/memory.usage_in_bytes
39215104&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;JVM OOM&lt;/h2&gt;&lt;p data-pid=&quot;blT3oEIn&quot;&gt;说到 OOM，Java 开发者更熟悉的是 JVM OOM，当 JVM 因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，将会抛出 java.lang.OutOfMemoryError。按照 JVM 规范，除了程序计数器不会抛出 OOM 外，其他各个内存区域都可能会抛出 OOM。最常见的 JVM OOM 情况有几种：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;E3N1jscr&quot;&gt;java.lang.OutOfMemoryError:Java heap space 堆内存溢出。当堆内存 (Heap Space) 没有足够空间存放新创建的对象时，就会抛出该错误。一般由于内存泄露或者堆的大小设置不当引起。对于内存泄露，需要通过内存监控软件查找程序中的泄露代码，而堆大小可以通过-Xms,-Xmx等参数修改。&lt;/li&gt;&lt;li data-pid=&quot;JZAECE2A&quot;&gt;java.lang.OutOfMemoryError:PermGen space / Metaspace 永久代/元空间溢出。永久代存储对象包括class信息和常量，JDK 1.8 使用 Metaspace 替换了永久代(Permanent Generation)。通常因为加载的 class 数目太多或体积太大，导致抛出该错误。可以通过修改 -XX:MaxPermSize 或者 -XX:MaxMetaspaceSize 启动参数, 调大永久代/元空间大小。&lt;/li&gt;&lt;li data-pid=&quot;zfFfbxC5&quot;&gt;java.lang.OutOfMemoryError:Unable to create new native thread 无法创建新线程。每个 Java 线程都需要占用一定的内存空间, 当 JVM 向底层操作系统请求创建一个新的 native 线程时, 如果没有足够的资源分配就会报此类错误。可能原因是 native 内存不足、线程泄露导致线程数超过操作系统最大线程数 ulimit 限制或是线程数超过 kernel.pid_max。需要根据情况进行资源升配、限制线程池大小、减少线程栈大小等操作。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;为什么堆内存未超过 Xmx 却发生了 OOM？&lt;/h2&gt;&lt;p data-pid=&quot;IWEqeLZk&quot;&gt;相信很多人都遇到过这一场景，在 K8s 部署的 Java 应用经常重启，查看容器退出状态为exit code 137 reason: OOM Killed 各方信息都指向明显的 OOM，然而 JVM 监控数据显示堆内存用量并未超过最大堆内存限制Xmx，并且配置了 OOM 自动 heapdump 参数之后，发生 OOM 时却没有产生 dump 文件。&lt;/p&gt;&lt;p data-pid=&quot;0yxqKr5v&quot;&gt;根据上面的背景知识介绍，容器内的 Java 应用可能会发生两种类型的 OOM 异常，一种是 JVM OOM，一种是容器 OOM。JVM 的 OOM 是 JVM 内存区域空间不足导致的错误，JVM 主动抛出错误并退出进程，通过观测数据可以看到内存用量超限，并且 JVM 会留下相应的错误记录。而容器的 OOM 是系统行为，整个容器进程组使用的内存超过 Cgroup 限制，被系统 OOM Killer 杀死，在系统日志和 K8s 事件中会留下相关记录。&lt;/p&gt;&lt;p data-pid=&quot;VoAXT0TB&quot;&gt;总的来说，Java程序内存使用同时受到来自 JVM 和 Cgroup 的限制，其中 Java 堆内存受限于 Xmx 参数，超限后发生 JVM OOM；整个进程内存受限于容器内存limit值，超限后发生容器 OOM。需要结合观测数据、JVM 错误记录、系统日志和 K8s 事件对 OOM 进行区分、排障，并按需进行配置调整。&lt;/p&gt;&lt;h2&gt;怎么理解操作系统和 JVM 的内存关系？&lt;/h2&gt;&lt;p data-pid=&quot;HPdv3Eq-&quot;&gt;上文说到 Java 容器 OOM 实质是 Java 进程使用的内存超过 Cgroup 限制，被操作系统的 OOM Killer 杀死。那在操作系统的视角里，如何看待 Java 进程的内存？操作系统和 JVM 都有各自的内存模型，二者是如何映射的？对于探究 Java 进程的 OOM 问题，理解 JVM 和操作系统之间的内存关系非常重要。&lt;/p&gt;&lt;p data-pid=&quot;k5i4c17s&quot;&gt;以最常用的 OpenJDK 为例，JVM 本质上是运行在操作系统上的一个 C++ 进程，因此其内存模型也有 Linux 进程的一般特点。Linux 进程的虚拟地址空间分为内核空间和用户空间，用户空间又细分为很多个段，此处选取几个和本文讨论相关度高的几个段，描述 JVM 内存与进程内存的映射关系。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-20e117aefcacf4e97e8e3e8fc1b1c51b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;526&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-20e117aefcacf4e97e8e3e8fc1b1c51b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;526&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-20e117aefcacf4e97e8e3e8fc1b1c51b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-20e117aefcacf4e97e8e3e8fc1b1c51b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li data-pid=&quot;Vl_mvXOV&quot;&gt;代码段。一般指程序代码在内存中的映射，这里特别指出是 JVM 自身的代码，而不是Java代码。&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li data-pid=&quot;-2MlVeMP&quot;&gt;数据段。在程序运行初已经对变量进行初始化的数据，此处是 JVM 自身的数据。&lt;/li&gt;&lt;li data-pid=&quot;E4XzlbDU&quot;&gt;堆空间。运行时堆是 Java 进程和普通进程区别最大的一个内存段。Linux 进程内存模型里的堆是为进程在运行时动态分配的对象提供内存空间，而几乎所有JVM内存模型里的东西，都是 JVM 这个进程在运行时新建出来的对象。而 JVM 内存模型中的 Java 堆，只不过是 JVM 在其进程堆空间上建立的一段逻辑空间。&lt;/li&gt;&lt;li data-pid=&quot;hd2RrW8B&quot;&gt;栈空间。存放进程的运行栈，此处并不是 JVM 内存模型中的线程栈，而是操作系统运行 JVM 本身需要留存的一些运行数据。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;QeL0jnw_&quot;&gt;如上所述，堆空间作为 Linux 进程内存布局和 JVM 内存布局都有的概念，是最容易混淆也是差别最大的一个概念。Java 堆相较于 Linux 进程的堆，范围更小，是 JVM 在其进程堆空间上建立的一段逻辑空间，而进程堆空间还包含支撑 JVM 虚拟机运行的内存数据，例如 Java 线程堆栈、代码缓存、GC 和编译器数据等。&lt;/p&gt;&lt;h2&gt;为什么程序占用的内存比 Xmx 大不少，内存都用在哪了？&lt;/h2&gt;&lt;p data-pid=&quot;X8zo4HSj&quot;&gt;在 Java 开发者看来，Java 代码运行中开辟的对象都放在 Java 堆中，所以很多人会将 Java 堆内存等同于 Java 进程内存，将 Java 堆内存限制参数Xmx当作进程内存限制参数使用，并且把容器内存限制也设置为 Xmx 一样大小，然后悲催地发现容器被 OOM 了。&lt;/p&gt;&lt;p data-pid=&quot;a-rKN_vF&quot;&gt;实质上除了大家所熟悉的堆内存(Heap)，JVM 还有所谓的非堆内存(Non-Heap)，除去 JVM 管理的内存，还有绕过 JVM 直接开辟的本地内存。Java 进程的内存占用情况可以简略地总结为下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f517b9a3170a0def00e056f3c4b3c1f8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;553&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f517b9a3170a0def00e056f3c4b3c1f8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;553&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f517b9a3170a0def00e056f3c4b3c1f8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f517b9a3170a0def00e056f3c4b3c1f8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;hy3E_liH&quot;&gt;JDK8 引入了 Native Memory Tracking (NMT)特性，可以追踪 JVM 的内部内存使用。默认情况下，NMT 是关闭状态，使用 JVM 参数开启：-XX:NativeMemoryTracking=[off | summary | detail]&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; $ java -Xms300m -Xmx300m -XX:+UseG1GC -XX:NativeMemoryTracking=summary -jar app.jar&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;JL8ke7CB&quot;&gt;此处限制最大堆内存为 300M，使用 G1 作为 GC 算法，开启 NMT 追踪进程的内存使用情况。&lt;/p&gt;&lt;blockquote data-pid=&quot;yVSAkqiW&quot;&gt;注意：启用 NMT 会导致 5% -10% 的性能开销。&lt;/blockquote&gt;&lt;p data-pid=&quot;_uWh_C4h&quot;&gt;开启 NMT 后，可以使用 jcmd 命令打印 JVM 内存的占用情况。此处仅查看内存摘要信息，设置单位为 MB。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; $ jcmd &amp;lt;pid&amp;gt; VM.native_memory summary scale=MB&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;JVM 总内存&lt;/h2&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Native Memory Tracking:

Total: reserved=1764MB, committed=534MB&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;omdFpYG-&quot;&gt;NMT 报告显示进程当前保留内存为 1764MB，已提交内存为 534MB，远远高于最大堆内存 300M。保留指为进程开辟一段连续的虚拟地址内存，可以理解为进程可能使用的内存量；提交指将虚拟地址与物理内存进行映射，可以理解为进程当前占用的内存量。&lt;/p&gt;&lt;p data-pid=&quot;IH8EKWWb&quot;&gt;需要特别说明的是，NMT 所统计的内存与操作系统统计的内存有所差异，Linux 在分配内存时遵循 lazy allocation 机制，只有在进程真正访问内存页时才将其换入物理内存中，所以使用 top 命令看到的进程物理内存占用量与 NMT 报告中看到的有差别。此处只用 NMT 说明 JVM 视角下内存的占用情况。&lt;/p&gt;&lt;h3&gt;Java Heap&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Java Heap (reserved=300MB, committed=300MB)
    (mmap: reserved=300MB, committed=300MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;_ZfjPO3f&quot;&gt;Java 堆内存如设置的一样，实际开辟了 300M 的内存空间。&lt;/p&gt;&lt;h3&gt;Metaspace&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Class (reserved=1078MB, committed=61MB)
      (classes #11183)
      (malloc=2MB #19375) 
      (mmap: reserved=1076MB, committed=60MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;jnOMOlrc&quot;&gt;加载的类被存储在 Metaspace，此处元空间加载了 11183 个类，保留了近 1G，提交了 61M。&lt;/p&gt;&lt;p data-pid=&quot;2cRZDmyn&quot;&gt;加载的类越多，使用的元空间就越多。元空间大小受限于-XX:MaxMetaspaceSize（默认无限制）和 -XX:CompressedClassSpaceSize（默认 1G）。&lt;/p&gt;&lt;h3&gt;Thread&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Thread (reserved=60MB, committed=60MB)
       (thread #61)
       (stack: reserved=60MB, committed=60MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Uta4Cqqt&quot;&gt;JVM 线程堆栈也需要占据一定空间。此处 61 个线程占用了 60M 空间，每个线程堆栈默认约为 1M。堆栈大小由 -Xss 参数控制。&lt;/p&gt;&lt;h3&gt;Code Cache&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Code (reserved=250MB, committed=36MB)
     (malloc=6MB #9546) 
     (mmap: reserved=244MB, committed=30MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;D074t0x5&quot;&gt;代码缓存区主要用来保存 JIT 即时编译器编译后的代码和 Native 方法，目前缓存了 36M 的代码。代码缓存区可以通过 -XX:ReservedCodeCacheSize 参数进行容量设置。&lt;/p&gt;&lt;h3&gt;GC&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;GC (reserved=47MB, committed=47MB)
   (malloc=4MB #11696) 
   (mmap: reserved=43MB, committed=43MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;gtZMyZxx&quot;&gt;GC 垃圾收集器也需要一些内存空间支撑 GC 操作，GC 占用的空间与具体选用的 GC 算法有关，此处的 GC 算法使用了 47M。在其他配置相同的情况下，换用 SerialGC:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; GC (reserved=1MB, committed=1MB)
   (mmap: reserved=1MB, committed=1MB)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Xv9JHFPr&quot;&gt;可以看到 SerialGC 算法仅使用 1M 内存。这是因为 SerialGC 是一种简单的串行算法，涉及数据结构简单，计算数据量小，所以内存占用也小。但是简单的 GC 算法可能会带来性能的下降，需要平衡性能和内存表现进行选择。&lt;/p&gt;&lt;h3&gt;Symbol&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt; Symbol (reserved=15MB, committed=15MB)
       (malloc=11MB #113566) 
       (arena=3MB #1)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;yYTrf5RO&quot;&gt;JVM 的 Symbol 包含符号表和字符串表，此处占用 15M。&lt;/p&gt;&lt;h2&gt;非 JVM 内存&lt;/h2&gt;&lt;p data-pid=&quot;RlOqdCQk&quot;&gt;NMT 只能统计 JVM 内部的内存情况，还有一部分内存不由JVM管理。除了 JVM 托管的内存之外，程序也可以显式地请求堆外内存 ByteBuffer.allocateDirect，这部分内存受限于 -XX:MaxDirectMemorySize 参数（默认等于-Xmx）。System.loadLibrary 所加载的 JNI 模块也可以不受 JVM 控制地申请堆外内存。综上，其实并没有一个能准确估量 Java 进程内存用量的模型，只能够尽可能多地考虑到各种因素。其中有一些内存区域能通过 JVM 参数进行容量限制，例如代码缓存、元空间等，但有些内存区域不受 JVM 控制，而与具体应用的代码有关。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Total memory = Heap + Code Cache + Metaspace + Thread stacks + 
               Symbol + GC + Direct buffers + JNI + ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;为什么线上容器比本地测试内存需求更大？&lt;/h2&gt;&lt;p data-pid=&quot;CoLUV6vH&quot;&gt;经常有用户反馈，为什么相同的一份代码，在线上容器里跑总是要比本地跑更耗内存，甚至出现 OOM。可能的情况的情况有如下几种：&lt;/p&gt;&lt;h2&gt;没有使用容器感知的 JVM 版本&lt;/h2&gt;&lt;p data-pid=&quot;MlPAv-Vs&quot;&gt;在一般的物理机或虚拟机上，当未设置 -Xmx 参数时，JVM 会从常见位置（例如，Linux 中的 /proc目录下）查找其可以使用的最大内存量，然后按照主机最大内存的 1/4 作为默认的 JVM 最大堆内存量。而早期的 JVM 版本并未对容器进行适配，当运行在容器中时，仍然按照主机内存的 1/4 设置 JVM最 大堆，而一般集群节点的主机内存比本地开发机大得多，容器内的 Java 进程堆空间开得大，自然更耗内存。同时在容器中又受到 Cgroup 资源限制，当容器进程组内存使用量超过 Cgroup 限制时，便会被 OOM。为此，8u191 之后的 OpenJDK 引入了默认开启的 UseContainerSupport 参数，使得容器内的 JVM 能感知容器内存限制，按照 Cgroup 内存限制量的 1/4 设置最大堆内存量。&lt;/p&gt;&lt;h2&gt;线上业务耗费更多内存&lt;/h2&gt;&lt;p data-pid=&quot;5rh42Qvm&quot;&gt;对外提供服务的业务往往会带来更活跃的内存分配动作，比如创建新的对象、开启执行线程，这些操作都需要开辟内存空间，所以线上业务往往耗费更多内存。并且越是流量高峰期，耗费的内存会更多。所以为了保证服务质量，需要依据自身业务流量，对应用内存配置进行相应扩容。&lt;/p&gt;&lt;h2&gt;云原生 Java 应用内存的配置建议&lt;/h2&gt;&lt;ol&gt;&lt;li data-pid=&quot;t9X2UWDV&quot;&gt;使用容器感知的 JDK 版本。对于使用 Cgroup V1 的集群，需要升级至 8u191+、Java 9、Java 10 以及更高版本；对于使用 Cgroup V2 的集群，需要升级至 8u372+ 或 Java 15 及更高版本。&lt;/li&gt;&lt;li data-pid=&quot;QMvh5zC8&quot;&gt;使用 NativeMemoryTracking(NMT) 了解应用的 JVM 内存用量。NMT 能够追踪 JVM 的内存使用情况，在测试阶段可以使用 NMT 了解程序JVM使用内存的大致分布情况，作为内存容量配置的参考依据。JVM 参数 -XX:NativeMemoryTracking 用于启用 NMT，开启 NMT 后，可以使用 jcmd 命令打印 JVM 内存的占用情况。&lt;/li&gt;&lt;li data-pid=&quot;cu8Itdfs&quot;&gt;根据 Java 程序内存使用量设置容器内存 limit。容器 Cgroup 内存限制值来源于对容器设置的内存 limit 值，当容器进程使用的内存量超过 limit，就会发生容器 OOM。为了程序在正常运行或业务波动时发生 OOM，应该按照 Java 进程使用的内存量上浮 20%～30% 设置容器内存 limit。如果初次运行的程序，并不了解其实际内存使用量，可以先设置一个较大的 limit 让程序运行一段时间，按照观测到的进程内存量对容器内存 limit 进行调整。&lt;/li&gt;&lt;li data-pid=&quot;N60wsuPg&quot;&gt;OOM 时自动 dump 内存快照，并为 dump 文件配置持久化存储，比如使用 PVC 挂载到 hostPath、OSS 或 NAS，尽可能保留现场数据，支撑后续的故障排查。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;Hu4IZJ9K&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//click.aliyun.com/m/1000367867/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;原文链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;4THH1bJU&quot;&gt;&lt;b&gt;本文为阿里云原创内容，未经允许不得转载。&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0b9223fe141f7c934a8dc3939096c55e</guid>
<title>DAMS峰会定档3月：蓄力已久的技术盛会，是时候放大招了！</title>
<link>https://toutiao.io/k/fcb2akd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8ZibTdwcblF1DRiclobOhD1Mcico4mUpSNv38fLL18Bwj36Fh1CtictsNT7QYtfZIeicqT8MYDDFVIWF7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据已经成为企业的核心竞争力！谁掌控数据、更好地利用数据、实现资产化，谁就能真正抢占大数据时代高地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;中国数据智能管理峰会DAMS（Data &amp;amp; AI Management Summit）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;连续八年&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;站在数据时代前沿，汇聚BAT、京东、美团、小米、蚂蚁金服、唯品会、三大运营商、中国银联、银行证券、国家电网等近百位互联网与传统企业行业专家，分享最新数据资产与大数据的理念、趋势、管理方法和最佳实践，坚持技术干货与实践经验分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DAMS峰会已经影响了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;过万名CXO、技术总监、IT经理、数据架构师、开发和运维领域相关负责人及工程师&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，覆盖了互联网、电信、金融、交通、物流等重点行业，专题涵盖数据资产管理、数据治理、大数据、Fintech等热门领域，数十家媒体争相报道，在业内具有极大影响力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;105273&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;245:467&quot;&gt;&lt;span&gt;&lt;strong&gt;报名方式&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>