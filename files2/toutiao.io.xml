<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>856cd667d59cd74a5fff7d6e3f907692</guid>
<title>接口突然超时 10 宗罪。。。</title>
<link>https://toutiao.io/k/oc43cu5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这样的场景：我们提供的某个&lt;code&gt;API接口&lt;/code&gt;，&lt;code&gt;响应时间&lt;/code&gt;原本一直都很快，但在某个不经意的时间点，突然出现了&lt;code&gt;接口超时&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你会有点懵，到底是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天跟大家一起聊聊接口&lt;/span&gt;&lt;code&gt;突然&lt;/code&gt;&lt;span&gt;超时的10个原因，希望对你会有所帮助。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.网络异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口原本好好的，突然出现超时，最常见的原因，可能是网络出现异常了。比如：偶然的网络抖动，或者是带宽被占满了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 网络抖动&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常上网的我们，肯定遇到过这样的场景：大多数情况下我们访问某个网站很快，但偶尔会出现网页一直转圈，加载不出来的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有可能是你的网络出现了抖动，丢包了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网页请求API接口，或者接口返回数据给网页，都有可能会出现网络丢包的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;网络丢包&lt;/code&gt;可能会导致接口超时。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.1 带宽被占满&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，由于页面或者接口设计不合理，用户请求量突增的时候，可能会导致服务器的网络带宽被占满的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;服务器带宽&lt;/code&gt;指的是在一定时间内&lt;code&gt;传输&lt;/code&gt;数据的&lt;code&gt;大小&lt;/code&gt;，比如：1秒传输了10M的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户请求量突然增多，超出了1秒10M的上限，比如：1秒100M，而服务器带宽本身1秒就只能传输10M，这样会导致在这1秒内，90M数据就会延迟传输的情况，从而导致接口超时的发生。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以对于有些高并发请求场景，需要评估一下是否需要增加服务器带宽。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.线程池满了&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们调用的API接口，有时候为了性能考虑，可能会使用&lt;code&gt;线程池&lt;/code&gt;异步查询数据，最后把查询结果进行汇总，然后返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gkBWTSibwHialQQYtKbMfY7bsMJJXKydXhAoQ9862KM9Yo5rhHIQibm6YTFoza9IqEF1u8icMzrNpgMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我用到了executor，表示&lt;code&gt;自定义的线程池&lt;/code&gt;，为了防止高并发场景下，出现&lt;code&gt;线程&lt;/code&gt;过多的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果用户请求太多，线程池中已有的线程处理不过来，线程池会把多余的请求，放到&lt;code&gt;队列&lt;/code&gt;中&lt;code&gt;排队&lt;/code&gt;，等待&lt;code&gt;空闲&lt;/code&gt;线程的去处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果队列中排队的任务非常多，某次API请求一直在等待，没办法得到及时处理，就会出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，我们可以考虑是否&lt;code&gt;核心线程数&lt;/code&gt;设置太小了，或者有多种业务场景共用了同一个线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是因为核心线程池设置太小，可以将其调大一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是因为多种业务场景共用了&lt;code&gt;同一个线程池&lt;/code&gt;，可以拆分成&lt;code&gt;多个线程池&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.数据库死锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候接口超时得有点莫名其妙，特别是遇到数据库出现&lt;code&gt;死锁&lt;/code&gt;的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你提供的API接口中通过某个id更新某条数据，此时，正好线上在手动执行一个批量更新数据的sql语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该sql语句在一个事务当中，并且刚好也在更新那条数据，可能会出现死锁的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该sql语句执行时间很长，会导致API接口的那次更新数据操作，长时间被数据库锁住，没法即使返回数据，而出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你说坑不坑？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议在执行数据库批量操作前，一定要评估数据的影响范围，不要一次性更新太多的数据，不然可能会导致很多意想不到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，批量更新操作建议在用户访问少的时段执行，比如：凌晨。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.传入参数太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，偶尔的一次接口超时，是由于参数传入太多导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：根据id集合批量查询分类接口，如果传入的id集合数据量不多，传入几十个或上百个id，不会出现性能问题。毕竟id是分类表的&lt;code&gt;主键&lt;/code&gt;，可以走&lt;code&gt;主键索引&lt;/code&gt;，数据库的查找速度是非常快的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果接口调用方，一次性传入几千个，甚至几万个id，批量查询分类，也可能会出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数据库在执行sql语句之前，会评估一下耗时情况，查询条件太多，有可能走全表扫描更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这种情况下sql语句可能会丢失索引，让执行时间变慢，出现接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们在设计&lt;code&gt;批量接口&lt;/code&gt;的时候，建议要限制传入的集合的大小，比如：500。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过我们设置最大的集合大小，则接口直接返回失败，并提示给用户：&lt;code&gt;一次性传入参数过多&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;该限制一定要写到接口文档中，避免接口调用方，在生产环境调用接口失败而踩坑。要在接口开发阶段通知到位。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果接口调用方要传入的参数就是很多怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可能是需求不合理，或者系统设计有问题，我们要尽量在系统设计阶段就规避这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们重新进行系统设计改动比较大的话，有个临时的解决方案：在接口调用方中多线程分批调用该接口，最后将结果进行汇总。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.超时时间设置过短&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，建议我们在调用远程API接口时，要设置&lt;code&gt;连接超时时间&lt;/code&gt;和&lt;code&gt;读超时时间&lt;/code&gt;这两个参数，并且可以动态配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处是，可以防止调用远程API接口万一出现了性能问题，响应时间很长，把我们自己的服务拖挂的情况发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：你调用的远程API接口，要100秒才返回数据，而你设置的超时时间是100秒。这时1000个请求过来，去请求该API接口，这样会导致&lt;code&gt;tomcat线程池&lt;/code&gt;很快被占满，导致整个服务暂时不可用，至少新的请求过来，是没法即使响应的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要设置超时时间，并且超时时间还不能设置太长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量不大的业务场景，可以将这两个超时时间设置稍微长一点，比如：&lt;code&gt;连接超时时间&lt;/code&gt;为10秒，&lt;code&gt;读超时时间&lt;/code&gt;为20秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发量大的业务场景，可以设置成&lt;code&gt;秒级&lt;/code&gt;或者&lt;code&gt;毫秒级&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴为了开发方便，在多种业务场景共用这两个超时时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某一天，在并发量大的业务场景中，你将该超时时间改短了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但直接导致并发量不大的业务场景中，出现调用API接口超时的问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因此，不建议多种业务场景共用同一个&lt;code&gt;超时时间&lt;/code&gt;，最好根据并发量的不同，单独设置不同的超时时间。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.一次性返回数据太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这样的需求：我们有个job，每天定时调用第三方API查询接口，获取昨天更新的数据，然后更新到我们自己的数据库表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于第三方每天更新的数据不多，所以该API接口响应时间还是比较快的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但突然有一天，该API接口却出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看日志发现，该API接口一次性返回的数据太多，而且该数据的更新时间相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就可以断定，该API接口提供方进行了批量更新操作，修改了大量的数据，导致该问题的发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使我们在job中加了&lt;code&gt;失败重试机制&lt;/code&gt;，但由于该API一次性返回数据实在太多太多，重试也很有可能会接口超时，这样会导致一直获取不到第三方前一天最新的数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以第三方这种根据日期查询增量数据的接口，建议做成分页查询的，不然后面没准哪一天，遇到批量更新的操作，就可能出现接口超时的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 死循环&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;死循环&lt;/code&gt;也会导致接口超时？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环不应该在接口&lt;code&gt;测试阶段&lt;/code&gt;就发现了，为什么要到&lt;code&gt;生产环境&lt;/code&gt;才发现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，绝大部分死循环问题，在测试阶段可以发现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但有些无限递归隐藏的比较深，比如下面的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死循环其实有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;普通死循环&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无限递归&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 普通死循环&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了&lt;code&gt;while(true)&lt;/code&gt;的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 无限递归&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现&lt;code&gt;无限递归&lt;/code&gt;的情况。导致接口一直不能返回数据，最终会发生&lt;code&gt;堆栈溢出&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限递归的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.sql语句没走索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，有时候mysql会&lt;code&gt;选错索引&lt;/code&gt;，甚至有时会不走索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql在执行某条sql语句之前，会通过抽样统计来估算扫描行数，根据影响行数、区分度、基数、数据页等信息，最后综合评估走哪个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候传入参数1，sql语句走了索引a，执行时间很快。但有时候传入参数2，sql语句走了索引b，执行时间明显慢了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样有可能会导致API接口出现超时问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;必要时可以使用&lt;code&gt;force index&lt;/code&gt;来强制查询sql走某个索引。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.服务OOM&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前遇到过这样一种场景：一个根据id查询分类的接口，该id是&lt;code&gt;主键&lt;/code&gt;，sql语句可以走主键索引，竟然也出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我当时觉得有点不可思议，因为这个接口平均耗时只有十几毫秒，怎么可能会出现超时呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但从当时的日志看，接口响应时间有5秒，的确出现了接口超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后从&lt;code&gt;Prometheus&lt;/code&gt;的服务内存监控中，查到了OOM问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实该API接口部署的服务当时由于&lt;code&gt;OOM&lt;/code&gt;内存溢出，其实挂了一段时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时所有的接口都出现了请求超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于&lt;code&gt;K8S&lt;/code&gt;集群有&lt;code&gt;监控&lt;/code&gt;，它自动会将挂掉的服务节点&lt;code&gt;kill&lt;/code&gt;掉，并且在容器中重新部署了一个&lt;code&gt;新的服务节点&lt;/code&gt;，幸好对用户没造成太大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对OOM问题比较感兴趣，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247498590&amp;amp;idx=1&amp;amp;sn=214cab0f95ad3df24055d5d18a110a2a&amp;amp;chksm=c0e823b6f79faaa0fa0c310715c7e94a205add4b1557cdc5f13bda85ce7862232c6955e261b6&amp;amp;token=748942416&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;糟了，线上服务出现OOM了&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.在debug&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有时候需要在本地开发工具，比如：&lt;code&gt;idea&lt;/code&gt;中，直接连接测试环境的数据库，调试某个API接口的业务逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在开发环境，某些问题不太好复现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了排查某个bug，你在请求某个本地接口时，开启了&lt;code&gt;debug模式&lt;/code&gt;，一行行的跟踪代码，排查问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;走到某一行代码的时候，停留了很长一段时间，该行代码主要是更新某条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，测试同学在相关的业务页面中，操作更新了相同的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种也可能会出现数据库&lt;code&gt;死锁&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于你在idea的debug模式中，一直都没有提交事务，会导致死锁的时间变得很长，从而导致业务页面请求的API接口出现超时问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然如果你对常规的接口超时问题比较感兴趣，可以看看我的另一篇文章，里面有非常详细的介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然如果你对常规的接口超时问题比较感兴趣，可以看看我的另一篇文章《&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490731&amp;amp;idx=1&amp;amp;sn=29ed0295c7990157a3a56ba33cf7f8be&amp;amp;chksm=c0ebc443f79c4d55a2bac81744992c96f97737e5d0717ec99231f4d08f57a7f0220eafdac9c9&amp;amp;token=660773166&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊接口性能优化的11个小技巧&lt;/a&gt;&lt;span&gt;》，里面有非常详细的介绍。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a172bbe5d7a4133cca3ddf0289ad0e2</guid>
<title>美团面试：MySQL 自增主键一定是连续的吗？</title>
<link>https://toutiao.io/k/8favlia</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7620370370370371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZclQSAM41A1ZnFukibKNKGiapfQQZJOKziaehj1pZzNHTicFkDKBMhTBzjZjys2GHM2nWd3LWt5SA7y0A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;图解学习网站：&lt;/span&gt;&lt;span&gt;xiaolincoding.com&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是小林。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;美团问数据库比较多，今天分享一道美团的面试题：&lt;strong&gt;MySQL 的自增主键一定是连续的吗？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9014084507042254&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZcUgshEvNSknMBvBBn04t90v42ftpY5PSfCXnKpGicbaaiawRvxiaPcff0z66lw2RnbXIbDbC3WwutNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;284&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际上，MySQL 的自增主键并不能保证一定是连续递增的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面举个例子来看下，如下所示创建一张表：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3469945355191257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSsBiaN3ibx0tWhhbpjyQo8T8XbxLggR4GtWsaNzACbK0kWqNylfoorLHQ/640?wx_fmt=png&quot; data-w=&quot;732&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值保存在哪里？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;insert into test_pk values(null, 1, 1)&lt;/code&gt; 插入一行数据，再执行 &lt;code&gt;show create table&lt;/code&gt; 命令来看一下表的结构定义：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5522222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlShzcyORDsddElUwICr30F21IAjOAxMOO0bNCL1rtK8hxmnFaicH0XGeA/640?wx_fmt=png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述表的结构定义存放在后缀名为 &lt;code&gt;.frm&lt;/code&gt; 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 &lt;code&gt;.frm&lt;/code&gt; 文件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5231481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlScTWqJCIkj1IW8XVWiaAWRyjVXPIFX9ma5rmvqp5QwYEO2fRH6beMx7w/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述表结构可以看到，表定义里面出现了一个 &lt;code&gt;AUTO_INCREMENT=2&lt;/code&gt;，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，自增值并不会保存在这个表结构也就是 &lt;code&gt;.frm&lt;/code&gt; 文件中，不同的引擎对于自增值的保存策略不同：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）MyISAM 引擎的自增值保存在数据文件中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 &lt;code&gt;max(id)&lt;/code&gt;，然后将 &lt;code&gt;max(id)+1&lt;/code&gt; 作为这个表当前的自增值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6602972399150743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlS0HgyyZPQHnFS8bF8eIA1yB2keNPXibBF2TrVkv5DsXiccd19k2ABictPQ/640?wx_fmt=png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4412811387900356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlScGQLqBeF4EwNW2n1ic8GVrn1MzcDeDpR7OL5bGsic2MCbmiaGFKpwTEow/640?wx_fmt=png&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSPcnibHJkomqQslkzGBG2wAQTwWdXfbViaDRcm0jUqlSOrcT9UkRqlkVw/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，是在我本地 MySQL 5.x 版本的实验，实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力，也就是实现了“如果发生重启，表的自增值可以根据 redo  log 恢复为 MySQL 重启前的值”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 &lt;code&gt;insert_num&lt;/code&gt;，当前的自增值是 &lt;code&gt;autoIncrement_num&lt;/code&gt;：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;insert_num &amp;lt; autoIncrement_num&lt;/code&gt;，那么这个表的自增值不变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 &lt;code&gt;insert_num &amp;gt;= autoIncrement_num&lt;/code&gt;，就需要把当前自增值修改为新的自增值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果插入的 id 是 100，当前的自增值是 90，&lt;code&gt;insert_num &amp;gt;= autoIncrement_num&lt;/code&gt;，那么自增值就会被修改为新的自增值即 101&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一定是这样吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非也~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个奇数偶数其实是通过 &lt;code&gt;auto_increment_offset&lt;/code&gt; 和 &lt;code&gt;auto_increment_increment&lt;/code&gt; 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，上面的例子中生成新的自增值的步骤实际是这样的：从 &lt;code&gt;auto_increment_offset&lt;/code&gt; 开始，以 &lt;code&gt;auto_increment_increment&lt;/code&gt; 为步长，持续叠加，直到找到第一个大于 100  的值，作为新的自增值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 2&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSsgKOh3PPxE0GpdWWu4ce6M4REWM9E2z245FDUBh5CGYnQibUIM06SSQ/640?wx_fmt=png&quot; data-ratio=&quot;0.6874279123414071&quot; data-w=&quot;867&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我再执行一条插入 &lt;code&gt;(null,1,1)&lt;/code&gt; 的命令，很显然会报错 &lt;code&gt;Duplicate entry&lt;/code&gt;，因为我们设置了一个唯一索引字段 &lt;code&gt;a&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSMic0AoqHE1gWOvO3rvsibyZUazjiaen17HQnn0rgnUM3FDc10P9eytwjQ/640?wx_fmt=png&quot; data-ratio=&quot;0.5705824284304047&quot; data-w=&quot;1013&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为啥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来分析下这个 insert 语句的执行流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB 发现用户没有指定自增 id 的值，则获取表 &lt;code&gt;test_pk&lt;/code&gt; 当前的自增值 2；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将传入的记录改成 (2,1,1);&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将表的自增值改成 3；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，我们已经罗列了两种自增主键不连续的情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自增初始值和自增步长设置不为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一键冲突&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，事务回滚也会导致这种情况&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 3&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在表里有一行 &lt;code&gt;(1,1,1)&lt;/code&gt; 的记录，AUTO_INCREMENT = 3：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6048951048951049&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSFjZ40sUdKXibmLhFxfXJoU5ic85QcTUhrHBlVGkqu7jUorksdy5HWAEQ/640?wx_fmt=png&quot; data-w=&quot;858&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先插入一行数据 &lt;code&gt;(null, 2, 2)&lt;/code&gt;，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6144455747711088&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSZYtkzeS6Ric9s0TSCsUrhCUBZ5zSwtP8LPN8HaDKLgVicU7ZVZkQlNlA/640?wx_fmt=png&quot; data-w=&quot;983&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再去执行这样一段 SQL：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36714285714285716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSPkib5TowVXBmW7Sn6xLyEU5qMBjebODMf9VyIGhK5ONz32x2MY5ZibDg/640?wx_fmt=png&quot; data-w=&quot;700&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6041666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSy5lJTyl2e0aZ4nDXbJ9opGPz53rn2DEVzsxCExMTpwZwmov8Y7fSdA/640?wx_fmt=png&quot; data-w=&quot;432&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5811870100783875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSTT1fZlfeSFiahUAAA6JpW9MDC9KOxPcaYjYDDkrjoGOrtQTbsqCyoFw/640?wx_fmt=png&quot; data-w=&quot;893&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 &lt;code&gt;5&lt;/code&gt; 了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42035398230088494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSSShlKlck7uekokHiblibt0bPATQwNl5v3NFjVYK1FjKLSPWJaXtGx8bQ/640?wx_fmt=png&quot; data-w=&quot;904&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，这么做的主要原因是为了提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是3，之后继续执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9227906976744186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSOYOApB3cGAYCCP6Rx9AicTbUPecmQhObzhsd16EtkiadrDFYH9p0COoQ/640?wx_fmt=png&quot; data-w=&quot;1075&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了解决这个主键冲突，有两种方法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自增值不连续场景 4&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语句执行过程中，第一次申请自增 id，会分配 1 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于 &lt;code&gt;insert … select&lt;/code&gt;、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，假设我们现在这个表有下面这些数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6483931947069943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSbD7VllcMdyDCv7u5uibFE8ap8oeMwAJEIdgBkgDuwJduQNBX0zs1ZTA/640?wx_fmt=png&quot; data-w=&quot;529&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建一个和当前表 &lt;code&gt;test_pk&lt;/code&gt; 有相同结构定义的表 &lt;code&gt;test_pk2&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4083333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSeBjnYFW3cvRcK1FYeCqgicPBdkvQGnbPSgvT86wAlgCFDBptIqEfYQA/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;img&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后使用 &lt;code&gt;insert...select&lt;/code&gt; 往 &lt;code&gt;teset_pk2&lt;/code&gt; 表中批量插入数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47689075630252103&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSH2trqM0ibx9lc9E5ibicJWY9P4zdIdhRibYVhRfAdGg75k2gIoKasaQpEA/640?wx_fmt=png&quot; data-w=&quot;952&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，成功导入了数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看下 &lt;code&gt;test_pk2&lt;/code&gt; 的自增值是多少：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSoibW63prO8Gice263E406BO5yLPksw8s2PO6KPAiaCdMM4KxaicoIvFGZw/640?wx_fmt=png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上分析，是 8 而不是 6&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一次申请到了一个 id：id=1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次被分配了两个 id：id=2 和 id=3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 &lt;code&gt;insert into test_pk2 values(null,6,6)&lt;/code&gt;，实际上插入的数据就是（8,6,6)：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5954198473282443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGEDRrKUhdJJj0j170jAhFlSWJhQcdACvDcD18fMz5PhdUuwp3RkTILHJkVpW2OcX6icMn1hcEvnlqA/640?wx_fmt=png&quot; data-w=&quot;786&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下自增值不连续的四个场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自增初始值和自增步长设置不为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;唯一键冲突&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务回滚&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;批量插入（如 &lt;code&gt;insert...select&lt;/code&gt; 语句）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;历史好文：&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247508002&amp;amp;idx=1&amp;amp;sn=9a59db214082ca8810dcdcb4af43c17c&amp;amp;chksm=f98de488cefa6d9ef82f7b17e5869cc1cb36a662d41d796ee85b84a9d5ae589bbd704b3a5b0d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;告别 MVCC !&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;告别 MVCC !&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247520893&amp;amp;idx=1&amp;amp;sn=7152fa58a1d03b48cfe8ef00e90aa2ea&amp;amp;chksm=f98dd6d7cefa5fc13877a1c99dcb06d03f51cbbc9afee75d0cd87f4847566746fcced9948e54&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团三面：一直追问我， MySQL 幻读被彻底解决了吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团三面：一直追问我， MySQL 幻读被彻底解决了吗？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247520657&amp;amp;idx=2&amp;amp;sn=53805d2f47b87a96db21ae13a08dac18&amp;amp;chksm=f98dd53bcefa5c2dfab473ba0087f470da66b19c32aae853390e876850c108a7dcbf78971d44&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;美团二面：TCP 四次挥手，可以变成三次吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团二面：TCP 四次挥手，可以变成三次吗？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247521692&amp;amp;idx=2&amp;amp;sn=433b88348f214fc2608b0d3d1edc1d94&amp;amp;chksm=f98dd136cefa5820462349f51e90650db0dfb0a1bfd070dd7d608c273790c4c8f29779034aa5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL 全局锁、表级锁、行级锁，你搞清楚了吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL 全局锁、表级锁、行级锁，你搞清楚了吗？&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247523402&amp;amp;idx=2&amp;amp;sn=fc8688d2fdd8a4b458dc5b04a6719948&amp;amp;chksm=f98dd8e0cefa51f6016356a5e6cbdc07cbdc3991c1ea1d3b9201fb7c836af4e30b43d6aac013&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;面试官：MySQL 中 varchar(n) 中 n 最大取值为多少？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;面试官：MySQL 中 varchar(n) 中 n 最大取值为多少？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzUxODAzNDg4NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfTwwjfpJhXgIrYMgtVcLhQQBVb02clZfKicbxaibSTNJqXe9Zu8ydiavZKJWJAIhKcnD9hBuKU92JZQ/0?wx_fmt=png&quot; data-nickname=&quot;小林coding&quot; data-alias=&quot;CodingLin&quot; data-signature=&quot;专注图解计算机基础，让天下没有难懂的八股文！刷题网站：xiaolincoding.com&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a8561532f158007f317f29f084b547c</guid>
<title>Spring Boot 整合 ElasticSearch 案例教程</title>
<link>https://toutiao.io/k/fig8r7w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry post-inner-html hairline&quot; itemprop=&quot;articleBody&quot;&gt;
            &lt;h2 id=&quot;一、ES-的使用场景&quot;&gt;&lt;a href=&quot;#一、ES-的使用场景&quot; class=&quot;headerlink&quot; title=&quot;一、ES 的使用场景&quot;/&gt;一、ES 的使用场景&lt;/h2&gt;&lt;p&gt;简单说，ElasticSearch（简称 ES）是搜索引擎，是结构化数据的分布式搜索引擎。&lt;br/&gt;我详细的介绍了如何安装，初步使用了 IK 分词器。这里，我主要讲下 SpringBoot 工程中如何使用 ElasticSearch。&lt;/p&gt;
&lt;p&gt;运行环境：JDK 7 或 8，Maven 3.0+&lt;/p&gt;
&lt;p&gt;技术栈：SpringBoot 1.5+，ElasticSearch 2.3.2&lt;/p&gt;
&lt;span id=&quot;more&quot;/&gt;

&lt;p&gt;ES 的使用场景大致分为两块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;全文检索。加上分词（IK 是其中一个）、拼音插件等可以成为强大的全文搜索引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;日志统计分析。可以实时动态分析海量日志数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;二、运行-springboot-elasticsearch-工程&quot;&gt;&lt;a href=&quot;#二、运行-springboot-elasticsearch-工程&quot; class=&quot;headerlink&quot; title=&quot;二、运行 springboot-elasticsearch 工程&quot;/&gt;二、运行 springboot-elasticsearch 工程&lt;/h2&gt;&lt;p&gt;注意的是这里使用的是 ElasticSearch 2.3.2。是因为版本对应关系 ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Spring Boot Version (x)    Spring Data Elasticsearch Version (y)    Elasticsearch Version (z)
x &amp;lt;= 1.3.5    y &amp;lt;= 1.3.4    z &amp;lt;= 1.7.2*
x &amp;gt;= 1.4.x    2.0.0 &amp;lt;=y &amp;lt; 5.0.0**    2.0.0 &amp;lt;= z &amp;lt; 5.0.0**
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只需要你修改下对应的 pom 文件版本号&lt;/li&gt;
&lt;li&gt;下一个 ES 的版本会有重大的更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;git clone 下载工程 springboot-elasticsearch ，项目地址见 GitHub - &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/JeffLi1993/springboot-learning-example&quot;&gt;https://github.com/JeffLi1993/springboot-learning-example&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;1-后台起守护线程启动-Elasticsearch&quot;&gt;&lt;a href=&quot;#1-后台起守护线程启动-Elasticsearch&quot; class=&quot;headerlink&quot; title=&quot;1. 后台起守护线程启动 Elasticsearch&quot;/&gt;1. 后台起守护线程启动 Elasticsearch&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;cd elasticsearch-2.3.2/
./bin/elasticsearch -d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面开始运行工程步骤（Quick Start）：&lt;/p&gt;
&lt;h3 id=&quot;2-项目结构介绍&quot;&gt;&lt;a href=&quot;#2-项目结构介绍&quot; class=&quot;headerlink&quot; title=&quot;2. 项目结构介绍&quot;/&gt;2. 项目结构介绍&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;org.spring.springboot.controller - Controller 层
org.spring.springboot.repository - ES 数据操作层
org.spring.springboot.domain - 实体类
org.spring.springboot.service - ES 业务逻辑层
Application - 应用启动类
application.properties - 应用配置文件，应用启动会自动读取配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本地启动的 ES ，就不需要改配置文件了。如果连测试 ES 服务地址，需要修改相应配置&lt;/p&gt;
&lt;h3 id=&quot;3-编译工程&quot;&gt;&lt;a href=&quot;#3-编译工程&quot; class=&quot;headerlink&quot; title=&quot;3.编译工程&quot;/&gt;3.编译工程&lt;/h3&gt;&lt;p&gt;在项目根目录 springboot-elasticsearch，运行 maven 指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mvn clean install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.运行工程&lt;/p&gt;
&lt;p&gt;右键运行 Application 应用启动类（位置：/springboot-learning-example/springboot-elasticsearch/src/main/java/org/spring/springboot/Application.java）的 main 函数，这样就成功启动了 springboot-elasticsearch 案例。&lt;/p&gt;
&lt;p&gt;用 Postman 工具新增两个城市&lt;/p&gt;
&lt;p&gt;新增城市信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST http://127.0.0.1:8080/api/city
{
&quot;id&quot;:&quot;1&quot;,
&quot;provinceid&quot;:&quot;1&quot;,
&quot;cityname&quot;:&quot;温岭&quot;,
&quot;description&quot;:&quot;温岭是个好城市&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;POST http://127.0.0.1:8080/api/city
{
&quot;id&quot;:&quot;2&quot;,
&quot;provinceid&quot;:&quot;2&quot;,
&quot;cityname&quot;:&quot;温州&quot;,
&quot;description&quot;:&quot;温州是个热城市&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以打开 ES 可视化工具 head 插件：&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://localhost:9200/_plugin/head/%EF%BC%9A&quot;&gt;http://localhost:9200/_plugin/head/：&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在「数据浏览」tab，可以查阅到 ES 中数据是否被插入，插入后的数据格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;_index&quot;: &quot;cityindex&quot;,
    &quot;_type&quot;: &quot;city&quot;,
    &quot;_id&quot;: &quot;1&quot;,
    &quot;_version&quot;: 1,
    &quot;_score&quot;: 1,
    &quot;_source&quot;: {
        &quot;id&quot;: 1,
        &quot;provinceid&quot;: 1,
        &quot;cityname&quot;: &quot;温岭&quot;,
        &quot;description&quot;: &quot;温岭是个好城市&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面验证下权重分查询搜索接口的实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET http://localhost:8080/api/city/search?pageNumber=0&amp;amp;pageSize=10&amp;amp;searchContent=温岭
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据是会出现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
    {
    &quot;id&quot;: 1,
    &quot;provinceid&quot;: 1,
    &quot;cityname&quot;: &quot;温岭&quot;,
    &quot;description&quot;: &quot;温岭是个好城市&quot;
    },
    {
    &quot;id&quot;: 2,
    &quot;provinceid&quot;: 2,
    &quot;cityname&quot;: &quot;温州&quot;,
    &quot;description&quot;: &quot;温州是个热城市&quot;
    }
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从启动后台 Console 可以看出，打印出来对应的 DSL 语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; {
  &quot;function_score&quot; : {
    &quot;functions&quot; : [ {
      &quot;filter&quot; : {
        &quot;bool&quot; : {
          &quot;should&quot; : {
            &quot;match&quot; : {
              &quot;cityname&quot; : {
                &quot;query&quot; : &quot;温岭&quot;,
                &quot;type&quot; : &quot;boolean&quot;
              }
            }
          }
        }
      },
      &quot;weight&quot; : 1000.0
    }, {
      &quot;filter&quot; : {
        &quot;bool&quot; : {
          &quot;should&quot; : {
            &quot;match&quot; : {
              &quot;description&quot; : {
                &quot;query&quot; : &quot;温岭&quot;,
                &quot;type&quot; : &quot;boolean&quot;
              }
            }
          }
        }
      },
      &quot;weight&quot; : 100.0
    } ]
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为什么会出现 温州 城市呢？因为 function score query 权重分查询，无相关的数据默认分值为 1。如果想除去，设置一个 setMinScore 分值即可。&lt;/p&gt;
&lt;h3 id=&quot;三、springboot-elasticsearch-工程代码详解&quot;&gt;&lt;a href=&quot;#三、springboot-elasticsearch-工程代码详解&quot; class=&quot;headerlink&quot; title=&quot;三、springboot-elasticsearch 工程代码详解&quot;/&gt;三、springboot-elasticsearch 工程代码详解&lt;/h3&gt;&lt;p&gt;具体代码见 GitHub - &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/JeffLi1993/springboot-learning-example&quot;&gt;https://github.com/JeffLi1993/springboot-learning-example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.pom.xml 依赖&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;

    &amp;lt;!-- Spring Boot Elasticsearch 依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-data-elasticsearch&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Spring Boot Web 依赖 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- Junit --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;application.properties 配置 ES 地址&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# ES
spring.data.elasticsearch.repositories.enabled = true
spring.data.elasticsearch.cluster-nodes = 127.0.0.1:9300
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认 9300 是 Java 客户端的端口。9200 是支持 Restful HTTP 的接口。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;ES 数据操作层&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Repository
public interface CityRepository extends ElasticsearchRepository&amp;lt;City,Long&amp;gt; {

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接口只要继承 ElasticsearchRepository 类即可。默认会提供很多实现，比如 CRUD 和搜索相关的实现。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;实体类&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;@Document(indexName = &quot;cityindex&quot;, type = &quot;city&quot;)
public class City implements Serializable{

    private static final long serialVersionUID = -1L;

    /**
     * 城市编号
     */
    private Long id;

    /**
     * 省份编号
     */
    private Long provinceid;

    /**
     * 城市名称
     */
    private String cityname;

    /**
     * 描述
     */
    private String description;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;p&gt;index 配置必须是全部小写，不然会引出异常：&lt;/p&gt;
&lt;p&gt;org.elasticsearch.indices.InvalidIndexNameException: Invalid index name [cityIndex], must be lowercase&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;ES 业务逻辑层&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Service 实现类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
* 城市 ES 业务逻辑实现类
*
* Created by bysocket on 07/02/2017.
  */
  @Service
  public class CityESServiceImpl implements CityService {

  private static final Logger LOGGER = LoggerFactory.getLogger(CityESServiceImpl.class);

  @Autowired
  CityRepository cityRepository;

  @Override
  public Long saveCity(City city) {

       City cityResult = cityRepository.save(city);
       return cityResult.getId();
  }

  @Override
  public List&amp;lt;City&amp;gt; searchCity(Integer pageNumber,
  Integer pageSize,
  String searchContent) {
  // 分页参数
  Pageable pageable = new PageRequest(pageNumber, pageSize);

       // Function Score Query
       FunctionScoreQueryBuilder functionScoreQueryBuilder = QueryBuilders.functionScoreQuery()
               .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery(&quot;cityname&quot;, searchContent)),
                   ScoreFunctionBuilders.weightFactorFunction(1000))
               .add(QueryBuilders.boolQuery().should(QueryBuilders.matchQuery(&quot;description&quot;, searchContent)),
                       ScoreFunctionBuilders.weightFactorFunction(100));

       // 创建搜索 DSL 查询
       SearchQuery searchQuery = new NativeSearchQueryBuilder()
               .withPageable(pageable)
               .withQuery(functionScoreQueryBuilder).build();

       LOGGER.info(&quot;\n searchCity(): searchContent [&quot; + searchContent + &quot;] \n DSL  = \n &quot; + searchQuery.getQuery().toString());

       Page&amp;lt;City&amp;gt; searchPageResults = cityRepository.search(searchQuery);
       return searchPageResults.getContent();
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;保存逻辑很简单，这里不解释了。&lt;/p&gt;
&lt;p&gt;分页 function score query 搜索逻辑：&lt;/p&gt;
&lt;p&gt;先创建分页参数，然后用 FunctionScoreQueryBuilder 定义 Function Score Query，并设置对应字段的权重分值。城市名称 1000 分，description 100 分。&lt;/p&gt;
&lt;p&gt;然后创建该搜索的 DSL 查询，并打印出来。&lt;/p&gt;
&lt;h2 id=&quot;四、小结&quot;&gt;&lt;a href=&quot;#四、小结&quot; class=&quot;headerlink&quot; title=&quot;四、小结&quot;/&gt;四、小结&lt;/h2&gt;&lt;p&gt;实际场景还会很复杂。这里只是点睛之笔，后续大家优化或者更改下 DSL 语句就可以完成自己想要的搜索规则。&lt;/p&gt;

        &lt;/div&gt;

    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>65a73dde069bf9cc0c7e3dbd4a233f14</guid>
<title>从 B站出发，用 Chrome devTools performance 分析页面如何渲染</title>
<link>https://toutiao.io/k/0nji7d6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;quNIQ0wa&quot;&gt;页面是如何渲染的？通常会得到“解析 HTML、css 合成 Render Tree，就可以渲染了”的回答。但是具体都做了些什么，却很少有人细说，我们今天就从 Chrome 的性能工具开始，具体看看一个页面是如何进行渲染的，以及进行页面优化时需要关注哪些指标。以“老二次元”网站 bilibili 为例，我们将通过分析 performance 面板，串联起 Chrome 页面渲染流程，以及页面的部分量化指标的含义，来看页面具体是如何渲染的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;获取performance数据&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;KGtzRY5F&quot;&gt;首先，打开Chrome devTools， 选择 performace面板，点击录制按钮开始录制。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e319df4727f4c7e6ff7a8ea26e5a43b0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;968&quot; data-rawheight=&quot;279&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e319df4727f4c7e6ff7a8ea26e5a43b0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;968&quot; data-rawheight=&quot;279&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e319df4727f4c7e6ff7a8ea26e5a43b0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e319df4727f4c7e6ff7a8ea26e5a43b0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;kHkb3V7z&quot;&gt;之后为了防止我们分析页面时出现无关的干扰，我们通过以下步骤降低干扰项：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;OhXlbFNN&quot;&gt;打开 Chrome 无痕模式。&lt;/li&gt;&lt;li data-pid=&quot;DHQkHByE&quot;&gt;关闭所有在 Chrome 无痕模式下启用的拓展（如果有的话）。&lt;/li&gt;&lt;li data-pid=&quot;kaomIiw5&quot;&gt;在地址栏输入 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.bilibili.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 前，先打开 devTools，选择 performance 面板，点击录制按钮。&lt;/li&gt;&lt;li data-pid=&quot;rnsP-WeR&quot;&gt;在已经录制的情况下，地址栏回车，请求 B 站，大概 10s 后，停止录制。&lt;/li&gt;&lt;/ol&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-695fbba910616c4ace69442cfb6a2805_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;770&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-695fbba910616c4ace69442cfb6a2805_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;770&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-695fbba910616c4ace69442cfb6a2805_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-695fbba910616c4ace69442cfb6a2805_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;cNa5eVNA&quot;&gt;我们从上到下，将图分成以下几块，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6a20f8f1e84988ae777d9bc0260ca80a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;724&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-6a20f8f1e84988ae777d9bc0260ca80a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;724&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-6a20f8f1e84988ae777d9bc0260ca80a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6a20f8f1e84988ae777d9bc0260ca80a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li data-pid=&quot;J38CufaI&quot;&gt;控制面板&lt;/li&gt;&lt;li data-pid=&quot;ovCzLKJ_&quot;&gt;概览面板&lt;/li&gt;&lt;li data-pid=&quot;x5DU7bgu&quot;&gt;网络面板&lt;/li&gt;&lt;li data-pid=&quot;YSDw2rOA&quot;&gt;Web Vitals&lt;/li&gt;&lt;li data-pid=&quot;obzRom75&quot;&gt;线程面板&lt;/li&gt;&lt;li data-pid=&quot;bX_m9nKR&quot;&gt;内存面板&lt;/li&gt;&lt;li data-pid=&quot;gMSl2LZQ&quot;&gt;聚合面板&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;2rfV6TrC&quot;&gt;&lt;b&gt;控制面板&lt;/b&gt;控制面板有 4 部分内容，分别为：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;gToaQx9v&quot;&gt;disable javascript samples：启用后会隐藏一些 JS 调用栈的展示。在一些性能较弱的设备例如移动端上，可以开启这项功能。&lt;/li&gt;&lt;li data-pid=&quot;XhSodQCN&quot;&gt;Network：可以用来模拟各种网络状况。&lt;/li&gt;&lt;li data-pid=&quot;pmtJaGcd&quot;&gt;enableadvanced paint instrumention (slow)：启用后 paint 面板会显示与绘制相关事件的更详细的信息。&lt;/li&gt;&lt;li data-pid=&quot;FUy_A9Ck&quot;&gt;CPU：可以用来模拟不同的 CPU 性能。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-2f246ae75d6651ef39896c6c22ef458f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;49&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-2f246ae75d6651ef39896c6c22ef458f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;49&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-2f246ae75d6651ef39896c6c22ef458f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-2f246ae75d6651ef39896c6c22ef458f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ae7TZwiN&quot;&gt;&lt;b&gt;概览面板&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-636183f1ba667eb4f34ff9e5d211bf68_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;68&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-636183f1ba667eb4f34ff9e5d211bf68_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;68&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-636183f1ba667eb4f34ff9e5d211bf68_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-636183f1ba667eb4f34ff9e5d211bf68_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;meUowC6L&quot;&gt;概览面板是各项指标的一个概览，包含了 FPS 帧数、CPU 占用、NET 情况、内存使用情况等。简单举个例子，比如 FPS 帧数可以直观的看出 FPS 的高低，绿色代表低的部分。而 CPU 栏的黄色代表着 js，紫色代表计算样式和布局，绿色代表绘制。&lt;b&gt;网络面板&lt;/b&gt;网络面板用于展示正在请求中的各部分的组成情况。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e367c86836de2af750eaae2ce04e77b1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;80&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e367c86836de2af750eaae2ce04e77b1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;80&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e367c86836de2af750eaae2ce04e77b1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e367c86836de2af750eaae2ce04e77b1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;elsAeNd_&quot;&gt;&lt;b&gt;Web vitals&lt;/b&gt;Web vitals 是网站的 Web 体验指标，其中包括 LCP（最大内容绘制）、FID（首次输入延迟）、cls (累计布局偏移)等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-692888806f640df537372369585e0c79_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;103&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-692888806f640df537372369585e0c79_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;757&quot; data-rawheight=&quot;103&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-692888806f640df537372369585e0c79_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-692888806f640df537372369585e0c79_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;8wayGljb&quot;&gt;&lt;b&gt;线程面板&lt;/b&gt;线程面板用于展示渲染当前页面所使用到的线程，包含有 Main 线程、GPU 线程、Raster 线程、Chrome_ChildIOThread、Compositor 线程等等。其中 Main 线程，就是我们平时说的大部分 js 的运行环境，即主线程。&lt;b&gt;内存面板&lt;/b&gt;展示 js 内存、GPU 内存、节点数、监听事件数的变化。&lt;b&gt;聚合面板&lt;/b&gt;当点击主线程中的火焰图时，此面板会显示显示具体包含执行时间、执行组成、调用栈等等的信息集合。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Chrome是如何渲染页面的？&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;W7JneED4&quot;&gt;&lt;b&gt;第一个请求&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;DWJ_BlUf&quot;&gt;以第一个请求为例，我们来具体看一下 Chrome 是如何进行页面渲染的？依然是以对 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 的请求为例，来看一下 1ms 的 performance 面板，即下图中红线部分、中间 NET 栏蓝色细长条开始的部分和 Network 中水平箱线图开始的部分。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bcf1ecadecd896dadea09aa65a7f8c89_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;712&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bcf1ecadecd896dadea09aa65a7f8c89_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;712&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bcf1ecadecd896dadea09aa65a7f8c89_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bcf1ecadecd896dadea09aa65a7f8c89_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;WGVZy73l&quot;&gt;其中两边横线中间深浅色方框的部分是水平箱线图，是用来展示某部分在整体中的比例关系。比如我们看到这个长长的箱型图，通过直观感受，就能知道对前面一部分横线挺长的，蓝色部分里浅色部分很长，深色的短，右边的横线几乎看不到。那这些又分别能展示什么信息？首先，点开箱型图最下方的聚合面板（Summary），上面赫然写着：此乃页面源。欲求小破站， 终生皆让我……耗时一秒半。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3a1f850a96cbb5d5d67ae8150a42f8f1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a1f850a96cbb5d5d67ae8150a42f8f1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;884&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3a1f850a96cbb5d5d67ae8150a42f8f1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3a1f850a96cbb5d5d67ae8150a42f8f1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;W89yD1PU&quot;&gt;然后在 Network tab 里查看该请求的 timing 部分，可以得到如下图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cdcfeabc9ea641d5b7d2b458ecf1cc8d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;469&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdcfeabc9ea641d5b7d2b458ecf1cc8d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;469&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-cdcfeabc9ea641d5b7d2b458ecf1cc8d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cdcfeabc9ea641d5b7d2b458ecf1cc8d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;81HgZu2u&quot;&gt;这里的各个部分分别代表：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;TOdJjevA&quot;&gt;Queueing（排队）：浏览器会在一些情况下让请求排队等待，比如这个请求的优先级不高，有更高优先级的请求存在；在使用 HTTP/1.0 或者 HTTP/1.1 时，同域请求最大并发数量为 6 个，此时已经达到了最大值；而上图中的请求是属于最高优先级的第一个请求，即浏览器正在硬盘缓存中分配空间，从图上可以看到有 14.72ms 用于在磁盘缓存中分配空间。&lt;/li&gt;&lt;li data-pid=&quot;tVrdOB_U&quot;&gt;Stalled（停顿）：它可能会因为上述排队中的任何原因而停顿。&lt;/li&gt;&lt;li data-pid=&quot;YkGItrK0&quot;&gt;DNS lookup（DNS 查询）：解析这个域名的IP地址。需要注意的是，当我们多次访问同一域名时，这部分不会出现在 timing 中。&lt;/li&gt;&lt;li data-pid=&quot;rU14ogxC&quot;&gt;Initial connection（初始连接）：浏览器建立连接，包括 tcp 三次握手、重试以及协商 SSL。图中的紫色部分，就代表了在初始连接过程中的 SSL 协商部分。&lt;/li&gt;&lt;li data-pid=&quot;Vmg45yzQ&quot;&gt;Request sent（发送请求）：正在发送请求&lt;/li&gt;&lt;li data-pid=&quot;QBTXmKoB&quot;&gt;Waiting (TTFB) 等待第一字节时间：浏览器在等待第一个响应的字节，TTFB 即 Time To First Byte。这个时间包括一个往返的延迟和服务准备响应的时间之和。&lt;/li&gt;&lt;li data-pid=&quot;yQlMe11w&quot;&gt;Content Download （内容下载）：浏览器正在接收响应，浏览器可以通过网络或者 serviceWorker 来直接接收。这个值是读取响应体的总时间。由于网络不佳或者浏览器正在忙于执行其他工作而延迟了对响应体的读取，读取的时间可能会比预期的要长。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ORdDKxJ-&quot;&gt;这里相信已经有小伙伴注意到了，当浏览器忙于其他事情时也会让读取时间变长。也就是说，当你的 js 把主线程长期占据的时候，就会影响 content download。下图是 Network 下的对应资源的 waterfall：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3eb81872b78c655cc8cb42cd7c22b371_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3eb81872b78c655cc8cb42cd7c22b371_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;415&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3eb81872b78c655cc8cb42cd7c22b371_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3eb81872b78c655cc8cb42cd7c22b371_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;zQAmuZQ4&quot;&gt;现在我们回到最开始说的各色横条上，在水平箱线图中左上角的深蓝色小方块代表着这个请求有着更高的优先级。遇到有浅蓝色的，则表示较低优先级。同时左边横线对应 Network 面板中显示的 Request Sent之前的所有事情的时间。浅色的 bar对应 Network 中 Request Sent 和 Waiting（TTFB）的时间。深色的 bar对应 Network中Content Download 的时间。右边的横线表示等待主线程所花费的时间，在  Network 面板中没有体现。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bb7e832c9ea0335d5658deefc37b4291_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;645&quot; data-rawheight=&quot;97&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb7e832c9ea0335d5658deefc37b4291_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;645&quot; data-rawheight=&quot;97&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bb7e832c9ea0335d5658deefc37b4291_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bb7e832c9ea0335d5658deefc37b4291_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;GDvlszd4&quot;&gt;此外，可能还有些同学注意到，在蓝色箱线图上面还可以看到还有几个灰色的箱线图。不是说&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.bilibili.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt; 是页面的第一个请求吗，难道它之前还有请求？事实上，这个灰色箱线图相当于上一个页面的结束。如果我们是通过重新录制的方式记录 performance，那就会经历页面刷新的过程。而这几个灰色的其实就是页面刷新 unload 时发起的，是 bilibili 用来记录页面卸载时的一些数据。说回到箱线图，可以看到在 summary 中显示 Duration 1.08 s (822.88 ms Network transfer + 260.20 ms resource loading)。这个的意思是 260ms 的时间是在 resource loading ，这里resource loading所花费的时间其实就是箱线图右侧的那条横线，等待主线程的时间。而在 main 进程中，有横线结束的地方，可以看到解码的数据 138,933 Bytes。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-05bf15e6965a74ff7c0c5b5003e2d087_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;757&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-05bf15e6965a74ff7c0c5b5003e2d087_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;757&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-05bf15e6965a74ff7c0c5b5003e2d087_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-05bf15e6965a74ff7c0c5b5003e2d087_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;pLe7qglr&quot;&gt;这里就出现了几个问题：为什么Encode Data 33479 bytes 算下来是 33479/1024 = 32.69 k，而不是前面 Network 面板里的 33.5k ? 而且 Decode body 138993/1024 = 135.7k 也不是前面的 139k？缺少的一部分数据是什么呢？为了验证这个问题，需要清空过去所有请求记录，重新点击录制，录制完成后，导出网络请求的 HAR 文件。使用 vscdoe 打开 json 格式的 HAR 文件，寻找 GET &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.bilibili.com/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com/&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;  content-Type: text/HTML 的那个请求。经过前后的文件对比，找到了这个请求的 response content：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-5e4d3cb43e933ee16ea5d6f6f074002d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1043&quot; data-rawheight=&quot;722&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e4d3cb43e933ee16ea5d6f6f074002d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1043&quot; data-rawheight=&quot;722&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-5e4d3cb43e933ee16ea5d6f6f074002d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-5e4d3cb43e933ee16ea5d6f6f074002d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TJMbhqjT&quot;&gt;可以看到，图上的 size 有140682 字节。text则是 base64 编码的 HTML 内容，已经被 decode 过。需要注意的是，这里的 decode 不是对 base64 的 decode，是对 gzip 的 decode。而在这个 text 内容之后，还有一段如下内容：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41ecbc09f7ec66fded0887aec517daef_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;607&quot; data-rawheight=&quot;462&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-41ecbc09f7ec66fded0887aec517daef_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;607&quot; data-rawheight=&quot;462&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-41ecbc09f7ec66fded0887aec517daef_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41ecbc09f7ec66fded0887aec517daef_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;LmpZMuyu&quot;&gt;其中的 _transferSize: 35593 是网络传输的体积，即传输的体积 35593 和 decode 体积 140682。同时我们在 performance 里的主进程中的 finish loading中可以看到下图数据：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b82484fe3f6de87ff7ae57d83e7d019b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;254&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;416&quot; data-rawheight=&quot;254&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b82484fe3f6de87ff7ae57d83e7d019b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;rFpGh_-g&quot;&gt;这样一看，二者是相同的。说明这个 HTML 的传输体积就是 35593 Bytes。那为什么在 Network 面板里，我们看到的是 35.6k transferred over Network 呢？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2fb4a5ec92de3ef9edcac3446cea1b4e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;183&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2fb4a5ec92de3ef9edcac3446cea1b4e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;183&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2fb4a5ec92de3ef9edcac3446cea1b4e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2fb4a5ec92de3ef9edcac3446cea1b4e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;LTiprLEV&quot;&gt;这是因为在 Network 里展示的体积，不是除以 1024 计算的，而是除以 1000，然后四舍五入后的结果。不过 Summary 里的 pending for xxx ms，似乎是也是等待主线程的时间，但它又是如何在 performance 体现的。目前，我还没搞清楚，如果有了解的小伙伴欢迎留言讨论~ &lt;/p&gt;&lt;p data-pid=&quot;x_s8OXvd&quot;&gt;&lt;b&gt;请求其它资源&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;ewMbTA0w&quot;&gt;言归正传，我们现在获取到了 bilibili 网站的 HTML，接下来就需要对这个 HTML 进行处理。通过 response header 得到 content-type:html，此时会创建一个个渲染进程，也就是主线程的这个进程。但是可以看到在主线程中的蓝色 parse HTML 之前，已经有很多 set request 被发起了，而且这些 send request 都是 HTML 文档中的一些 js 和 css。为什么会这样呢？不应该是先解析 HTML，才能知道对哪些资源进行发起请求吗？&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8f99529d94826dc6f009d7b99f63e935_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f99529d94826dc6f009d7b99f63e935_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;138&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8f99529d94826dc6f009d7b99f63e935_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8f99529d94826dc6f009d7b99f63e935_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;2yLLk3zI&quot;&gt;在 HTML 中引入的 js，存在修改 Dom 的可能，所以浏览器一般在遇到 script 标签后，会先暂停 HTML  解析，优先 js 的下载和执行。但是下载是相对耗时的，如果因为下载时间久而卡住了页面解析，很容易导致用户体验变差，因此 Chrome 采用了一些优化策略。具体来说，就是当 Chrome 渲染引擎接收到 HTML 的字节流时候，会开启一个专门用来分析字节流中所包含 js、css 文件的预解析线程。解析到相关信息之后，预解析线程会提前开始下载这些资源文件，这样在需要使用的时候就可以直接执行，避免了下载的等待时间。但是也能观察到，在Parse HTML蓝色方块下方，还有一些 send request，这些怎么就不是提前下载的呢？我的理解是，这些资源其实都是在预解析线程下载的，尽管在时间上会存在重叠，但和主线程不属于同一个线程，所以 performance 工具会这么显示。但这又带来了另一个问题，为什么有些 js 明明在 HTML 的后面，却在前面就 send request 了，而有些 link/script 明明写在 HTML 里的前面，却在 performance 里后 send request？这是跟资源的优先级有关。比如普通的 script 标签引用的资源，普通 link 引用的资源，或是rel=prelaod 或 as=&quot;style&quot;预加载的资源，可能会被优先处理。而当资源是 prefetch，或者用 &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;//s1.hdslb.com/bfs/static/jinkela/long/font/regular.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;/&amp;gt;这种方式的，由于优先级低，就会被延后下载。一般的其他资源，则按顺序下载。回到 Network，可以看到在 www.bilibil.com 的箱线图之后，是一连串 js、css、Webp 资源需要加载的请求被发起了。把鼠标移动到这些箱线图上，会看到上面有优先级 lowest low high highest，这就表示了资源的重要程度。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-54496e9aefc236045628528c9ef13454_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-54496e9aefc236045628528c9ef13454_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;394&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-54496e9aefc236045628528c9ef13454_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-54496e9aefc236045628528c9ef13454_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;02IyS5M9&quot;&gt;那么这些资源的优先级是如何评定的？一般来说，访问域名获取的 HTML、 以及预加载资源时as=&quot;style&quot;，拥有最高优先级。普通的 &amp;lt;script&amp;gt;  、 &amp;lt;link&amp;gt; 标签、 使用preload的预加载，拥有 高优先级。使用了 async/defer 的 &amp;lt;script&amp;gt; 、as=&quot;script&quot;的预加载资源拥有低优先级。使用了 &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;//s1.hdslb.com/bfs/static/jinkela/long/font/medium.css&quot; media=&quot;print&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&amp;gt; 这种方式的，和不加 as=&quot;xxx&quot;的 prefetch 预加载，就相当于异步加载，拥有最低优先级。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;HTML Parse&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;WXa6PDZA&quot;&gt;好，到现在为止，我们已经将用到的 js、css、图片等资源下载了，然后就该进入解析 HTML 的过程了。在 Chrome 渲染引擎内部，有个 HTMLParser 的模块。HTML 解析器负责将 HTML 转化为 Dom 结构。HTML 解析器并不是等整个文档全部获取之后才开始解析，而是加载了&quot;足够&quot;的数据后，就开始解析了。在 HTML Parser 的 summary 面板里可以看到，有个Range：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.bilibili.com&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;http://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;bilibili.com&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;[0...45]。点进去看一下可以发现，定位到了 HTML 的 45 行。这也从侧面印证了解析 HTML 的过程并不是一次全部执行完的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3310b82f50fe99df1c6f72c8ac0abd30_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;856&quot; data-rawheight=&quot;544&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3310b82f50fe99df1c6f72c8ac0abd30_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;856&quot; data-rawheight=&quot;544&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3310b82f50fe99df1c6f72c8ac0abd30_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3310b82f50fe99df1c6f72c8ac0abd30_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;eX-LjNV1&quot;&gt;HTML 的解析生成 Dom 树的过程，可以参考文章（&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//medium.com/nybles/introduction-to-Dom-bee3b2dd9911&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;medium.com/nybles/intro&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;duction-to-Dom-bee3b2dd9911&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;）。简单来说就是将字节流转换成 token，然后把 token 解析成 Dom 节点并添加到 Dom 树中。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-94cc47ef5bd8384c25d03e38c68585f1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;910&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-94cc47ef5bd8384c25d03e38c68585f1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;910&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-94cc47ef5bd8384c25d03e38c68585f1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-94cc47ef5bd8384c25d03e38c68585f1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4g3t6b2b&quot;&gt;在 HTML 解析器工作过程中，会遇到 js、css 需要处理，比如蓝色条下面有黄色的 js 执行，有 parse stylesheet 的 css（这里的两个是 vendor.css 和 index.css）解析和 cssom 的构建。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e592d70907225c73f2fb0d512e482396_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;186&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e592d70907225c73f2fb0d512e482396_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;186&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e592d70907225c73f2fb0d512e482396_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e592d70907225c73f2fb0d512e482396_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xI9lFlhm&quot;&gt;当拿到了 vendor.css 和 index.css 这两个外部样式文件之后，就开始了 Recalculate Style 的过程，也就是在进行一些可能包括递归（比如想知道父容器的大小就得先知道子元素的大小）的样式计算。注意，这时候 HTML 还是没有完全解析完的，但是一旦样式计算结束，就开始 Layout过程。这里的Layout对应的是将 Dom tree 和 cssom 结合成 render tree的过程。render tree 是不包含例如&amp;lt;meta&amp;gt;、display: none这些无需展示的元素。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-6628ca96e9cd7a5ac6989a931e0d3e68_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-6628ca96e9cd7a5ac6989a931e0d3e68_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-6628ca96e9cd7a5ac6989a931e0d3e68_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-6628ca96e9cd7a5ac6989a931e0d3e68_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;分层&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;hCv3rkpT&quot;&gt;在样式计算之后，还需要经历一个pre-paint的过程，然后才能paint。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3e4652c9aec75a479ddda23260cb4ba6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;551&quot; data-rawheight=&quot;127&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-3e4652c9aec75a479ddda23260cb4ba6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;551&quot; data-rawheight=&quot;127&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-3e4652c9aec75a479ddda23260cb4ba6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3e4652c9aec75a479ddda23260cb4ba6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;3mZnnrcN&quot;&gt;以前这里叫做 update layer tree， 2022年3月份之后改成了 pre-paint。这里其实是遍历 render tree 生成 layer tree 的过程。&lt;b&gt;render tree 和 layer tree 有啥不同呢？&lt;/b&gt;render tree 是 Dom 和 cssom 结合的产物，是将计算后的样式添加到了 Dom 节点上。但是目前只是知道了节点是否可见以及可见样式，还不知道节点的精确位置和大小，这时候就需要布局。渲染引擎从　render tree　的根节点开始遍历，通过一定的规则处理后，将会得到一个 layout tree，这个 layout tree 精确的描述了每个视口内元素的位置和确切尺寸，所有的相对位置都会转变成屏幕上的绝对位置，在得知了节点是否可见、样式、位置几何信息之后，渲染引擎才有机会将 render tree　上的每个节点都转换成屏幕上的像素，这个过程也就是一般说的 绘制 paint或者栅格化 Rastering。那 layer tree 在哪儿呢？layer tree 就在栅格化的过程当中。在说栅格化之前，有必要提一下　Chrome 是如何将渲染视口内的内容的。过去　Chrome 是只在用户可视区域内进行栅格化，随着用户滚动不断滚动页面而调整栅格化区域，继续栅格化并将内容填充到缺失部分。这样的缺点是当用户快速滚动的时候，页面会有卡顿感。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;300&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;300&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-9ed512afc63c664458faf1bd42247cc0_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ZPLQXn2N&quot;&gt;而现在 Chrome 采用了一种合成 composting 的方式，将页面中的某些部分分成不同的层，分别栅格化它们，然后在合成器线程中合成。这样在页面滚动时，原材料已经有了（准备好的那些层），只需要将视口内的蹭合成为一个新帧即可。这样在用户滚动时，新帧的合成效率更高。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;450&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;720&quot; data-rawheight=&quot;450&quot; data-thumbnail=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-dd41bdf77d3be6d75425337973a6094f_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;d31GOFc7&quot;&gt;既然需要分层，那就要知道那些元素应该在哪一层里，所以渲染引擎需要按照一定规则再遍历一次 layout tree 来创建 layer tree ，这个过程也就是 pre-paint，以前叫做 update layer tree。分层也需要按照一定的规则，不是任意一个元素都可以被拎出来当做一层，主要是两个条件：&lt;/p&gt;&lt;p data-pid=&quot;t6t1TXgO&quot;&gt;页面是个二维的，但是层叠上下文属性会让　HTML　元素具有三维的概念。这些元素按照自身的属性优先级分布在垂直页面的　Z　轴之上，哪些元素拥有具体参考　MDN。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-264080dd87b218c7797ccecfd3801fa2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;749&quot; data-rawheight=&quot;541&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-264080dd87b218c7797ccecfd3801fa2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;749&quot; data-rawheight=&quot;541&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-264080dd87b218c7797ccecfd3801fa2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-264080dd87b218c7797ccecfd3801fa2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xzRmoQ0O&quot;&gt;当你实际的内容比容器还大的时候，就会出现裁剪，引擎会裁剪一部分内容显示在容器区域。一般来说，出现滚动条就会被创建为图层。满足以上任意一个条件就会被提升成单独一层。那这在 Chrome devtools 哪里可以体现呢？在 devtools -&amp;gt; 右侧三个点 -&amp;gt; more tools -&amp;gt; layers 里可以看到页面实际上被分成了许多层。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-7b42b724ef2483b2d30d33bafb649447_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;760&quot; data-rawheight=&quot;506&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-7b42b724ef2483b2d30d33bafb649447_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;760&quot; data-rawheight=&quot;506&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-7b42b724ef2483b2d30d33bafb649447_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-7b42b724ef2483b2d30d33bafb649447_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JuJg3NRO&quot;&gt;点击左侧的具体图层，可以看到详细的绘制过程。Details 里还有被提升为一层的原因composition reason。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a45f29aa161fde81be334d3366f19041_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;620&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a45f29aa161fde81be334d3366f19041_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;620&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a45f29aa161fde81be334d3366f19041_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a45f29aa161fde81be334d3366f19041_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Paint&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;H025uMlG&quot;&gt;通过前面分层，我们得知了元素的层级关系，但是还不知道同一层内元素的层级关系。一般来说，后面的内容会覆盖前面内容，但是浏览器该如何知道谁该覆盖谁呢？这就需要渲染引擎为每一个图层创建绘制记录 patint record 并确定谁先画谁后画，那么后画的肯定就会覆盖先画的。绘制记录可以看做一个单向链表  div -&amp;gt;  div -&amp;gt; p -&amp;gt; span，遍历链表即可获得绘制顺序。现在有了图层，也有了绘制记录顺序，这些信息将会被提交到合成器线程中进行绘图和合成。由于一个图层可能会非常大，超过了视口面积，那么图层就会经历一次分割过程，分割成一个个小的图块 Tile，通常是 256*256 或 512*512 大小，这些图块进行会传递给栅格化线程池。池中的栅格化线程执行栅格化任务 Raster Task，将图块生成位图 bitmap，并优先生成视口附近的位图。这个过程在performamce里叫做Rasterize Paint。栅格化过程也会使用 GPU 来加速，一般又称为快速栅格化，GPU 栅格化。这也是为什么会有些 css 里写 will-change：transfrom 或者 transform: translateZ(0)，就是为了 GPU 参与绘制。本质上是利用 will-change 和 translateZ(0) 创建了新的渲染层，从而不影响其他层级的绘制内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1bc42ada9237e069273962d22660c773_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1bc42ada9237e069273962d22660c773_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;893&quot; data-rawheight=&quot;191&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1bc42ada9237e069273962d22660c773_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1bc42ada9237e069273962d22660c773_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sCyoQv46&quot;&gt;当所有的 Tile 栅格化完毕，合成器线程收集 Draw Quads 的图块信息。Draw Quads 记录了图块在内存中的位置和在页面那个位置进行绘制。然后主线程收集这些 Draw quards 信息并合成合成器帧，并交给 GPU渲染，然后才是像素出现在屏幕之上。这个过程在 perfomrance 里是 Compositie layers。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2554d11f3fff83d2b379df50ac1a6789_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;766&quot; data-rawheight=&quot;247&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2554d11f3fff83d2b379df50ac1a6789_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;766&quot; data-rawheight=&quot;247&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2554d11f3fff83d2b379df50ac1a6789_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2554d11f3fff83d2b379df50ac1a6789_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;zFa66J8s&quot;&gt;可惜我没有在 performance 里找到更详细的信息来展示这个过程。页面渲染大概就是上述的过程，主要是结合 performance 面板串联起过去的那些知识。了解了页面渲染流程，我们该如何优化页面性能呢？又需要关注那些指标呢？&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;Gng9Rkqq&quot;&gt;&lt;b&gt;页面优化关注哪些指标&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;qpu2AKL6&quot;&gt;这个指标不是凭空创造，也不是仅凭感觉，这应该是一些明确的、可以量化的指标。Chrome devtool lightHouse 列举了 6 个指标。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-48fab2986e930b76f52964a1ec5b5840_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;797&quot; data-rawheight=&quot;316&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-48fab2986e930b76f52964a1ec5b5840_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;797&quot; data-rawheight=&quot;316&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-48fab2986e930b76f52964a1ec5b5840_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-48fab2986e930b76f52964a1ec5b5840_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xetK1QBF&quot;&gt;&lt;b&gt;FCP&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;1UM8DSd5&quot;&gt;First content paint 代表浏览器渲染出第一个 Dom content 的时间。这里的 Dom content 包括图片、非空白 canvas、svgs 等。如果你的页面里有 iframe，iframe 里的任何东西都不会被当成 Dom content。FCP 好坏标准也是随着收集到的页面数据来不断变化的，我们可以从 httparchive 地址来查看现在世界上的页面的中位数是多少。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-c96990e1c28685395312ccb913e60e84_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;749&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-c96990e1c28685395312ccb913e60e84_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;749&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-c96990e1c28685395312ccb913e60e84_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-c96990e1c28685395312ccb913e60e84_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Yy0jQ4BG&quot;&gt;根据目前的指标来看，FCP 时间可以简单的分为 3 档：0 - 1.9s，1.9s - 3s，3s以上，它们分别代表还行、很一般、不太行。当我们在某个页面中使用 LightHouse 进行评估的时候，可能会看到尽管 FCP 只有 1s，显示的也是橙色标记。LightHouse 里的得分是根据百分比来的。也就是说当你的 FCP 时间，是所有页面中的前 10%， 那么可以得到 90 分， 前 1% 可以得到 99 分，得到 90-100 分才会是绿色。其他的几个指标也是同样的评判标准。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e9bc4f85d6537032137230cf17bea812_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;816&quot; data-rawheight=&quot;358&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e9bc4f85d6537032137230cf17bea812_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;816&quot; data-rawheight=&quot;358&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e9bc4f85d6537032137230cf17bea812_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e9bc4f85d6537032137230cf17bea812_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;DwR07Z3J&quot;&gt;影响 FCP 的原因有很多，其中一个比较常见的原因是自定义字体的加载，字体文件的加载需要一定时间，在字体文件加载完成之前，不同的浏览器会采用不同的策略。edge：在字体准备好前使用系统字体Chrome：隐藏文本内容。如果 3s 后自定义字体还没准备好，则使用系统字体，直到字体准备好，然后替换字体。火狐：同 Chromesafari：隐藏文本直到字体准备好。一个简单的办法是在@font-face 演示里增加 font-display: swap&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@font-face {
  font-family: &#x27;Pacifico&#x27;;
  font-style: normal;
  font-weight: 400;
  src: url(https://fonts.gstatic.com/s/pacifico/v12/FwZY7-Qmy14u9lezJ-6H6MmBp0u-.woff2) format(&#x27;woff2&#x27;);
  font-display: swap;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;rnSpFOSx&quot;&gt;设置 swap 就是告诉浏览器是使用该字体的文本应该立即使用系统字体进行显示，当自定义字体准备就绪后，替换系统字体。或者使用 prefetch / preload 来提前获取字体相关资源。&lt;/p&gt;&lt;p data-pid=&quot;fTlYzT2E&quot;&gt;&lt;b&gt;Time to intercative&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;eHlMtyxk&quot;&gt;TTI 标记着页面多久可以进行完全交互。这里的完全交互是指：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;L7PleZa-&quot;&gt;页面已经展示了 FCP&lt;/li&gt;&lt;li data-pid=&quot;Pc5G2WWX&quot;&gt;事件处理函数已经为大部分可见页面元素进行了注册绑定&lt;/li&gt;&lt;li data-pid=&quot;Yr1T703Y&quot;&gt;页面能够在 50ms 内对用户行为进行反应&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Crw-nfPR&quot;&gt;同样我们在 httparchive  来看一下这个世界上网页 TTI 的中位数是多少。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-72e91ff91ed74344691ac77eefc7b5f2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;732&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e91ff91ed74344691ac77eefc7b5f2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;732&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-72e91ff91ed74344691ac77eefc7b5f2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-72e91ff91ed74344691ac77eefc7b5f2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;TadQNHvw&quot;&gt;降低 TTI 的常见思路是代码分割、按需加载，删除未使用代码、压缩代码、压缩网络负载、减少 JS 对主线程的长时间占用。&lt;/p&gt;&lt;p data-pid=&quot;w4HDSewL&quot;&gt;&lt;b&gt;Speed Index&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;B41t73qj&quot;&gt;这个指标代表了用户感知的可见区域的页面加载的快慢。也分成 0-3.4s 、 3.4 - 5.8、超过 5.8 三挡。但是得分也同样是跟全球网页数据来对比的。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-3e0f676082ca83357de9d783caddb12e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;304&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-3e0f676082ca83357de9d783caddb12e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;800&quot; data-rawheight=&quot;304&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-3e0f676082ca83357de9d783caddb12e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-3e0f676082ca83357de9d783caddb12e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JLraVcxr&quot;&gt;提高 speed index 的主要是通过减少 js 对主线程阻塞，让一些非必要的 js 在 Dom 渲染后再执行。&lt;/p&gt;&lt;p data-pid=&quot;18-vo7RG&quot;&gt;&lt;b&gt;Total Block Time&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;GceRRJAx&quot;&gt;总阻塞时间。这个时间是从 FCP 到 TTI 之间所有的长任务阻塞部分的时间之和。长任务是指执行时间超过 50ms 的任务，50ms 之后的时间量就是阻塞时间。&lt;/p&gt;&lt;p data-pid=&quot;zHNFUVnR&quot;&gt;既然是阻塞时间，降低 TBT 的办法就是想办法减少不必要的 js 的加载、解析和执行。拆分大型脚本，对某些非同步必要的 js 使用 defer/async 或者 prefetch/preload 、或者允许的情况下进行懒加载/延迟加载、将静态资源部署到 CDN 等等。&lt;/p&gt;&lt;p data-pid=&quot;e8C_JC9n&quot;&gt;&lt;b&gt;Largest Contentful Paint&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;XHiD2qUe&quot;&gt;最大内容绘制。记录的是视口中最大的内容元素被渲染到屏幕的时间，也大致分为 0-2.5s、2.5s-4s、超过 4s 三个大范围。&lt;/p&gt;&lt;p data-pid=&quot;8mw9m445&quot;&gt;这里的类容元素是指：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;5sT0bS1L&quot;&gt;&amp;lt;img &amp;gt;&lt;/li&gt;&lt;li data-pid=&quot;R84p8r7T&quot;&gt;&amp;lt;svg&amp;gt; 内嵌的 &amp;lt;image&amp;gt; 元素&lt;/li&gt;&lt;li data-pid=&quot;fYkHhFKy&quot;&gt;使用了封面的&amp;lt;video&amp;gt; 元素&lt;/li&gt;&lt;li data-pid=&quot;MDfgLu5b&quot;&gt;url() 加载的带背景图的元素&lt;/li&gt;&lt;li data-pid=&quot;lSs7b6xW&quot;&gt;包含文本或者其他行内文本元素子元素的块级元素&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;0mjpYMWt&quot;&gt;注意，如果元素溢出到可视区域之外，则不算 LCP。LCP 主要手4个方面的影响：&lt;/p&gt;&lt;p data-pid=&quot;cv4tShra&quot;&gt;应对方案：CDN、预加载、serviceWorker&lt;/p&gt;&lt;p data-pid=&quot;wMtY4EnE&quot;&gt;应对方案：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;r7h8Sl_Q&quot;&gt;用optimize-css-assets-Webpack-plugin、uglyifyJS之类的 Webpack 插件压缩 css、js&lt;/li&gt;&lt;li data-pid=&quot;EEtJc3rN&quot;&gt;对非必要的 js、css 延迟加载，如非必要 css 用预加载，在触发事件后再去 import xx from &#x27;xxx&#x27;。&lt;/li&gt;&lt;li data-pid=&quot;m0f9qFOC&quot;&gt;合适的情况下使用内联 css。&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li data-pid=&quot;GiT2LUuf&quot;&gt;缓慢的资源加载速度&lt;/li&gt;&lt;ul&gt;&lt;li data-pid=&quot;khbsA9lK&quot;&gt;压缩图像&lt;/li&gt;&lt;li data-pid=&quot;KLViikM-&quot;&gt;预加载重要资源&lt;/li&gt;&lt;li data-pid=&quot;sFS-OO_Z&quot;&gt;压缩文本文件 Gzip、br&lt;/li&gt;&lt;li data-pid=&quot;KZXHyN5s&quot;&gt;serviceWorker 进行缓存&lt;/li&gt;&lt;/ul&gt;&lt;li data-pid=&quot;brX3Tgtx&quot;&gt;客户端渲染&lt;/li&gt;&lt;ul&gt;&lt;li data-pid=&quot;IsjY5QXT&quot;&gt;压缩 js&lt;/li&gt;&lt;li data-pid=&quot;kSW4_WyB&quot;&gt;延迟加载未立即使用的 js&lt;/li&gt;&lt;li data-pid=&quot;EsDpa5CC&quot;&gt;尽可能减少polyfill。&quot;targets&quot;:&quot;&amp;gt;0.25%&quot;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-pid=&quot;qVAPEz1B&quot;&gt;&lt;b&gt;Cumulative Layout Shift&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;6EEJrp6n&quot;&gt;有些时候我们会遇到，初始加载时字体忽然变大/变小， 元素位置突然移动位等。CLS 就是通过测量发生偏移的频率来表示出页面的不稳定性。常见的导致 CLS 比较差的原因有：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;yYMpA7we&quot;&gt;没指定宽高的图片&lt;/li&gt;&lt;li data-pid=&quot;YfUI2HGc&quot;&gt;没有设置宽高的 iframe&lt;/li&gt;&lt;li data-pid=&quot;e8y_nJMK&quot;&gt;没有设置宽高的资源位（顶部 banner、广告等）&lt;/li&gt;&lt;li data-pid=&quot;WeetoePC&quot;&gt;前面提到的 无样式文本闪烁（FOUT， 用默认字体替换新字体）/ 不可见文本闪烁（FOIT，获取新字体前的显示不可见文本）。&amp;lt;link rel=preload&amp;gt;和font-display: optional结合使用&lt;/li&gt;&lt;li data-pid=&quot;_-OFze7L&quot;&gt;动画使用了修改 width、height、top、right、bottom、left 等属性值的方式来实现。应优先使用 css transfrom来实现动画。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;sIayUdZc&quot;&gt;以上就是目前 Chrome lighthouse 用来判断页面体验的 6 个指标。如果我们要优化页面，也应从这 6 个方面来入手，逐一改进，在现有的可量化指标下有的放矢。&lt;/p&gt;&lt;p data-pid=&quot;4pgOihcw&quot;&gt;参考资料：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.debugbear.com/blog/devtools-performance&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;debugbear.com/blog/devt&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ools-performance&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb4131454078d02a0b3234dcabcbf350</guid>
<title>MySQL 单表过亿条数据，如何优化查询速度？</title>
<link>https://toutiao.io/k/br9i097</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText css-1g0fqss&quot; options=&quot;[object Object]&quot; itemprop=&quot;text&quot;&gt;&lt;h2 data-first-child=&quot;&quot;&gt;前言&lt;/h2&gt;&lt;p data-pid=&quot;maslq6eV&quot;&gt;在高并发系统当中，针对针对过亿的大表，分库分表是必不可少的技术手段之一，同时也是BAT等大厂面试时，经常考的热门考题。&lt;/p&gt;&lt;p data-pid=&quot;9vz3mE-b&quot;&gt;你知道我们为什么要做分库分表吗？&lt;/p&gt;&lt;p data-pid=&quot;kgvNehf7&quot;&gt;这个问题要从两条线说起：垂直方向 和 水平方向。&lt;/p&gt;&lt;h2&gt;1 垂直方向&lt;/h2&gt;&lt;p data-pid=&quot;75Gml7Sy&quot;&gt;垂直方向主要针对的是业务，下面聊聊业务的发展跟分库分表有什么关系。&lt;/p&gt;&lt;h3&gt;1.1 单库&lt;/h3&gt;&lt;p data-pid=&quot;jZk3JrCI&quot;&gt;在系统初期，业务功能相对来说比较简单，系统模块较少。&lt;/p&gt;&lt;p data-pid=&quot;XRsCZDGa&quot;&gt;为了快速满足迭代需求，减少一些不必要的依赖。更重要的是减少系统的复杂度，保证开发速度，我们通常会使用单库来保存数据。&lt;/p&gt;&lt;p data-pid=&quot;PovAyFFe&quot;&gt;系统初期的数据库架构如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-d15094c903aec73536de8b7e566fc2fb_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-d15094c903aec73536de8b7e566fc2fb_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;uBVqq7C9&quot;&gt;此时，使用的数据库方案是：一个数据库包含多张业务表。用户读数据请求和写数据请求，都是操作的同一个数据库。&lt;/p&gt;&lt;h3&gt;1.2 分表&lt;/h3&gt;&lt;p data-pid=&quot;onxkSYma&quot;&gt;系统上线之后，随着业务的发展，不断的添加新功能。导致单表中的字段越来越多，开始变得有点不太好维护了。&lt;/p&gt;&lt;p data-pid=&quot;ii4POqrk&quot;&gt;一个用户表就包含了几十甚至上百个字段，管理起来有点混乱。&lt;/p&gt;&lt;p data-pid=&quot;DWohWNjN&quot;&gt;这时候该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;O30QeEqE&quot;&gt;答：分表。&lt;/p&gt;&lt;p data-pid=&quot;tmouk8K1&quot;&gt;将用户表拆分为：用户基本信息表 和 用户扩展表。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pica.zhimg.com/50/v2-867f6316764416dac8c8c3b00eb9f73c_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pica.zhimg.com/50/v2-867f6316764416dac8c8c3b00eb9f73c_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;i2sdp62U&quot;&gt;用户基本信息表中存的是用户最主要的信息，比如：用户名、密码、别名、手机号、邮箱、年龄、性别等核心数据。&lt;/p&gt;&lt;p data-pid=&quot;Zdy1LYn8&quot;&gt;这些信息跟用户息息相关，查询的频次非常高。&lt;/p&gt;&lt;p data-pid=&quot;cqNbO_kD&quot;&gt;而用户扩展表中存的是用户的扩展信息，比如：所属单位、户口所在地、所在城市等等，非核心数据。&lt;/p&gt;&lt;p data-pid=&quot;OiKYJTKF&quot;&gt;这些信息只有在特定的业务场景才需要查询，而绝大数业务场景是不需要的。&lt;/p&gt;&lt;p data-pid=&quot;or5A-C9M&quot;&gt;所以通过分表把核心数据和非核心数据分开，让表的结构更清晰，职责更单一，更便于维护。&lt;/p&gt;&lt;p data-pid=&quot;QM7ks7Ri&quot;&gt;除了按实际业务分表之外，我们还有一个常用的分表原则是：把调用频次高的放在一张表，调用频次低的放在另一张表。&lt;/p&gt;&lt;p data-pid=&quot;nkWiPPdH&quot;&gt;有个非常经典的例子就是：订单表和订单详情表。&lt;/p&gt;&lt;p data-pid=&quot;DDXsa9lV&quot;&gt;最近无意间获得一份BAT大厂大佬写的刷题笔记，一下子打通了我的任督二脉，越来越觉得算法没有想象中那么难了。&lt;/p&gt;&lt;p data-pid=&quot;uB2H7Cu4&quot;&gt;[BAT大佬写的刷题笔记，让我offer拿到手软](&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247490336%26idx%3D1%26sn%3D2f9db262746f692136cd6ce7179fc208%26source%3D41%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这位BAT大佬写的Leetcode刷题笔记，让我offer拿到手软&lt;/a&gt;)&lt;/p&gt;&lt;h3&gt;1.3 分库&lt;/h3&gt;&lt;p data-pid=&quot;tGpog2DV&quot;&gt;不知不觉，系统已经上线了一年多的时间了。经历了N个迭代的需求开发，功能已经非常完善。&lt;/p&gt;&lt;p data-pid=&quot;9uuvqhJu&quot;&gt;系统功能完善，意味着系统各种关联关系，错综复杂。&lt;/p&gt;&lt;p data-pid=&quot;GRFILWZC&quot;&gt;此时，如果不赶快梳理业务逻辑，后面会带来很多隐藏问题，会把自己坑死。&lt;/p&gt;&lt;p data-pid=&quot;AYY0Kd3h&quot;&gt;这就需要按业务功能，划分不同领域了。把相同领域的表放到同一个数据库，不同领域的表，放在另外的数据库。&lt;/p&gt;&lt;p data-pid=&quot;1nBNv5lS&quot;&gt;具体拆分过程如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-2bd3d65fb95df0fc3893ccb5fb840d53_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-2bd3d65fb95df0fc3893ccb5fb840d53_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;SGeA-NCq&quot;&gt;将用户、产品、物流、订单相关的表，从原来一个数据库中，拆分成单独的用户库、产品库、物流库和订单库，一共四个数据库。&lt;/p&gt;&lt;blockquote data-pid=&quot;bzhORS-v&quot;&gt;在这里为了看起来更直观，每个库我只画了一张表，实际场景可能有多张表。&lt;/blockquote&gt;&lt;p data-pid=&quot;WZHTwu30&quot;&gt;这样按领域拆分之后，每个领域只用关注自己相关的表，职责更单一了，一下子变得更好维护了。&lt;/p&gt;&lt;h3&gt;1.4 分库分表&lt;/h3&gt;&lt;p data-pid=&quot;1MbFJcRd&quot;&gt;有时候按业务，只分库，或者只分表是不够的。比如：有些财务系统，需要按月份和年份汇总，所有用户的资金。&lt;/p&gt;&lt;p data-pid=&quot;cJX1SPhG&quot;&gt;这就需要做：分库分表了。&lt;/p&gt;&lt;p data-pid=&quot;IF2kwZIi&quot;&gt;每年都有个单独的数据库，每个数据库中，都有12张表，每张表存储一个月的用户资金数据。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-2af63f306116af80486bee633845a252_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-2af63f306116af80486bee633845a252_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OqgKqr6S&quot;&gt;这样分库分表之后，就能非常高效的查询出某个用户每个月，或者每年的资金了。&lt;/p&gt;&lt;p data-pid=&quot;vl5GXLeU&quot;&gt;此外，还有些比较特殊的需求，比如需要按照地域分库，比如：华中、华北、华南等区，每个区都有一个单独的数据库。&lt;/p&gt;&lt;p data-pid=&quot;uPKniq_l&quot;&gt;甚至有些游戏平台，按接入的游戏厂商来做分库分表。&lt;/p&gt;&lt;h2&gt;2 水平方向&lt;/h2&gt;&lt;p data-pid=&quot;Pc9LETZA&quot;&gt;水分方向主要针对的是数据，下面聊聊数据跟分库分表又有什么关系。&lt;/p&gt;&lt;h3&gt;2.1 单库&lt;/h3&gt;&lt;p data-pid=&quot;pGQBaqvY&quot;&gt;在系统初期，由于用户非常少，所以系统并发量很小。并且存在表中的数据量也非常少。&lt;/p&gt;&lt;p data-pid=&quot;LuO5Tib_&quot;&gt;这时的数据库架构如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-d15094c903aec73536de8b7e566fc2fb_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-d15094c903aec73536de8b7e566fc2fb_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;KABiLY0X&quot;&gt;此时，使用的数据库方案同样是：一个master数据库包含多张业务表。&lt;/p&gt;&lt;p data-pid=&quot;41vMxRP5&quot;&gt;用户读数据请求和写数据请求，都是操作的同一个数据库，该方案比较适合于并发量很低的业务场景。&lt;/p&gt;&lt;h3&gt;2.2 主从读写分离&lt;/h3&gt;&lt;p data-pid=&quot;e09hn7gL&quot;&gt;系统上线一段时间后，用户数量增加了。&lt;/p&gt;&lt;p data-pid=&quot;MZ0G4Q5d&quot;&gt;此时，你会发现用户的请求当中，读数据的请求占据了大部分，真正写数据的请求占比很少。&lt;/p&gt;&lt;p data-pid=&quot;y_npZiZC&quot;&gt;众所周知，数据库连接是有限的，它是非常宝贵的资源。而每次数据库的读或写请求，都需要占用至少一个数据库连接。&lt;/p&gt;&lt;p data-pid=&quot;XDtF3XVT&quot;&gt;如果写数据请求需要的数据库连接，被读数据请求占用完了，不就写不了数据了？&lt;/p&gt;&lt;p data-pid=&quot;qjTWgq9N&quot;&gt;这样问题就严重了。&lt;/p&gt;&lt;p data-pid=&quot;OEqp8MY8&quot;&gt;为了解决该问题，我们需要把读库和写库分开。&lt;/p&gt;&lt;p data-pid=&quot;yeNcLihj&quot;&gt;于是，就出现了主从读写分离架构：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-e84ddf81fb1291a558a018c8f3aa3afb_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-e84ddf81fb1291a558a018c8f3aa3afb_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;vV1DacVW&quot;&gt;考虑刚开始用户量还没那么大，选择的是一主一从的架构，也就是常说的一个master一个slave。&lt;/p&gt;&lt;p data-pid=&quot;qju8jvt2&quot;&gt;所有的写数据请求，都指向主库。一旦主库写完数据之后，立马异步同步给从库。这样所有的读数据请求，就能及时从从库中获取到数据了（除非网络有延迟）。&lt;/p&gt;&lt;p data-pid=&quot;NRxGxX-2&quot;&gt;读写分离方案可以解决上面提到的单节点问题，相对于单库的方案，能够更好的保证系统的稳定性。&lt;/p&gt;&lt;p data-pid=&quot;FNU1GZtF&quot;&gt;因为如果主库挂了，可以升级从库为主库，将所有读写请求都指向新主库，系统又能正常运行了。&lt;/p&gt;&lt;blockquote data-pid=&quot;Ejxgnm3B&quot;&gt;读写分离方案其实也是分库的一种，它相对于为数据做了备份，它已经成为了系统初期的首先方案。&lt;/blockquote&gt;&lt;p data-pid=&quot;1gZEXgDc&quot;&gt;但这里有个问题就是：如果用户量确实有些大，如果master挂了，升级slave为master，将所有读写请求都指向新master。&lt;/p&gt;&lt;p data-pid=&quot;2G3FH-jD&quot;&gt;但此时，如果这个新master根本扛不住所有的读写请求，该怎么办？&lt;/p&gt;&lt;p data-pid=&quot;ArzTlOKo&quot;&gt;这就需要一主多从的架构了：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-45342073f254dd09817178b0f586a951_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-45342073f254dd09817178b0f586a951_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ZQ_RiWJu&quot;&gt;上图中我列的是一主两从，如果master挂了，可以选择从库1或从库2中的一个，升级为新master。假如我们在这里升级从库1为新master，则原来的从库2就变成了新master的的slave了。&lt;/p&gt;&lt;p data-pid=&quot;I8pp5sTf&quot;&gt;调整之后的架构图如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-68c809dd4d5a66c2bf1dd05722b8837c_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-68c809dd4d5a66c2bf1dd05722b8837c_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;M3OgdF_C&quot;&gt;这样就能解决上面的问题了。&lt;/p&gt;&lt;p data-pid=&quot;eqyT-jow&quot;&gt;除此之外，如果查询请求量再增大，我们还可以将架构升级为一主三从、一主四从...一主N从等。&lt;/p&gt;&lt;h3&gt;2.3 分库&lt;/h3&gt;&lt;p data-pid=&quot;Bg7eACMC&quot;&gt;上面的读写分离方案确实可以解决读请求大于写请求时，导致master节点扛不住的问题。但如果某个领域，比如：用户库。如果注册用户的请求量非常大，即写请求本身的请求量就很大，一个master库根本无法承受住这么大的压力。&lt;/p&gt;&lt;p data-pid=&quot;E9Q6YbD_&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;H16ZlaMt&quot;&gt;答：建立多个用户库。&lt;/p&gt;&lt;p data-pid=&quot;BsqhNbRv&quot;&gt;用户库的拆分过程如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-8324ac15363ad56d1e6fb6b85d8795d6_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-8324ac15363ad56d1e6fb6b85d8795d6_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;CqLbqufn&quot;&gt;在这里我将用户库拆分成了三个库（真实场景不一定是这样的），每个库的表结构是一模一样的，只有存储的数据不一样。&lt;/p&gt;&lt;h3&gt;2.4 分表&lt;/h3&gt;&lt;p data-pid=&quot;DkuVs8UQ&quot;&gt;用户请求量上来了，带来的势必是数据量的成本上升。即使做了分库，但有可能单个库，比如：用户库，出现了5000万的数据。&lt;/p&gt;&lt;p data-pid=&quot;mIrrT8i3&quot;&gt;根据经验值，单表的数据量应该尽量控制在1000万以内，性能是最佳的。如果有几千万级的数据量，用单表来存，性能会变得很差。&lt;/p&gt;&lt;p data-pid=&quot;dxBSG_jO&quot;&gt;如果数据量太大了，需要建立的索引也会很大，从小到大检索一次数据，会非常耗时，而且非常消耗cpu资源。&lt;/p&gt;&lt;p data-pid=&quot;Kd8afdgZ&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;xjyc87Me&quot;&gt;答：分表，这样可以控制每张表的数据量，和索引大小。&lt;/p&gt;&lt;p data-pid=&quot;WMneoMxU&quot;&gt;表拆分过程如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-4be693649c940e51bba9c806012d9f04_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-4be693649c940e51bba9c806012d9f04_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;QHh3bhKV&quot;&gt;我在这里将用户库中的用户表，拆分成了四张表（真实场景不一定是这样的），每张表的表结构是一模一样的，只是存储的数据不一样。&lt;/p&gt;&lt;p data-pid=&quot;FAFxztEJ&quot;&gt;如果以后用户数据量越来越大，只需再多分几张用户表即可。&lt;/p&gt;&lt;h3&gt;2.5 分库分表&lt;/h3&gt;&lt;p data-pid=&quot;K-kgqEZe&quot;&gt;当系统发展到一定的阶段，用户并发量大，而且需要存储的数据量也很多。这时该怎么办呢？&lt;/p&gt;&lt;p data-pid=&quot;QL-Z8grn&quot;&gt;答：需要做分库分表。&lt;/p&gt;&lt;p data-pid=&quot;3pJw9EHG&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-9660150f303fd9cb0b84b5748babdfec_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-9660150f303fd9cb0b84b5748babdfec_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;Q3rxhtw-&quot;&gt;图中将用户库拆分成了三个库，每个库都包含了四张用户表。&lt;/p&gt;&lt;p data-pid=&quot;93VSpoOy&quot;&gt;如果有用户请求过来的时候，先根据用户id路由到其中一个用户库，然后再定位到某张表。&lt;/p&gt;&lt;p data-pid=&quot;zB9ZvDeO&quot;&gt;路由的算法挺多的：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;EznVHlCR&quot;&gt;根据id取模，比如：id=7，有4张表，则7%4=3，模为3，路由到用户表3。  &lt;/li&gt;&lt;li data-pid=&quot;8kTHP7_c&quot;&gt;给id指定一个区间范围，比如：id的值是0-10万，则数据存在用户表0，id的值是10-20万，则数据存在用户表1。  &lt;/li&gt;&lt;li data-pid=&quot;GzMjbzI0&quot;&gt;一致性hash算法&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;k6Y1GHl9&quot;&gt;这篇文章就不过多介绍了，后面会有文章专门介绍这些路由算法的。&lt;/p&gt;&lt;h2&gt;3 真实案例&lt;/h2&gt;&lt;p data-pid=&quot;gFURK-En&quot;&gt;接下来，废话不多说，给大家分享三个我参与过的分库分表项目经历，给有需要的朋友一个参考。&lt;/p&gt;&lt;h3&gt;3.1 分库&lt;/h3&gt;&lt;p data-pid=&quot;t3YH54FV&quot;&gt;我之前待过一家公司，我们团队是做游戏运营的，我们公司提供平台，游戏厂商接入我们平台，推广他们的游戏。&lt;/p&gt;&lt;p data-pid=&quot;AEvo7HUk&quot;&gt;游戏玩家通过我们平台登录，成功之后跳转到游戏厂商的指定游戏页面，该玩家就能正常玩游戏了，还可以充值游戏币。&lt;/p&gt;&lt;p data-pid=&quot;QwH-ahU1&quot;&gt;这就需要建立我们的账号体系和游戏厂商的账号的映射关系，游戏玩家通过登录我们平台的游戏账号，成功之后转换成游戏厂商自己平台的账号。&lt;/p&gt;&lt;p data-pid=&quot;uZfGBxhs&quot;&gt;这里有两个问题：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;CCmJd-6n&quot;&gt;每个游戏厂商的接入方式可能都不一样，账号体系映射关系也有差异。  &lt;/li&gt;&lt;li data-pid=&quot;9L8RLuZi&quot;&gt;用户都从我们平台登录，成功之后跳转到游戏厂商的游戏页面。当时有N个游戏厂商接入了，活跃的游戏玩家比较多，登录接口的并发量不容小觑。  &lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;gTvqxiE4&quot;&gt;为了解决这两个问题，我们当时采用的方案是：分库。即针对每一个游戏都单独建一个数据库，数据库中的表结构允许存在差异。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-33fb205f624c56d3e3968ffb2904c683_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/50/v2-33fb205f624c56d3e3968ffb2904c683_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;akPiF3QI&quot;&gt;我们当时没有进一步分表，是因为当时考虑每种游戏的用户量，还没到大到离谱的地步。不像王者荣耀这种现象级的游戏，有上亿的玩家。&lt;/p&gt;&lt;p data-pid=&quot;tJ1vvTNM&quot;&gt;其中有个比较关键的地方是：登录接口中需要传入游戏id字段，通过该字段，系统就知道要操作哪个库，因为库名中就包含了游戏id的信息。&lt;/p&gt;&lt;h3&gt;3.2 分表&lt;/h3&gt;&lt;p data-pid=&quot;9kBC5n40&quot;&gt;还是在那家游戏平台公司，我们还有另外一个业务就是：金钻会员。&lt;/p&gt;&lt;p data-pid=&quot;odN5Qco7&quot;&gt;说白了就是打造了一套跟游戏相关的会员体系，为了保持用户的活跃度，开通会员有很多福利，比如：送游戏币、充值有折扣、积分兑换、抽奖、专属客服等等。&lt;/p&gt;&lt;p data-pid=&quot;IWRRBaqY&quot;&gt;在这套会员体系当中，有个非常重要的功能就是：积分。&lt;/p&gt;&lt;p data-pid=&quot;LGnsZIjn&quot;&gt;用户有很多种途径可以获取积分，比如：签到、充值、玩游戏、抽奖、推广、参加活动等等。&lt;/p&gt;&lt;p data-pid=&quot;HUDaTqxf&quot;&gt;积分用什么用途呢？&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;rR3s0wq3&quot;&gt;退换实物礼物  &lt;/li&gt;&lt;li data-pid=&quot;nHzep8Nb&quot;&gt;兑换游戏币  &lt;/li&gt;&lt;li data-pid=&quot;k23joXgW&quot;&gt;抽奖  &lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;d0k9SUlU&quot;&gt;说了这么多，其实就是想说，一个用户一天当中，获取积分或消费积分都可能有很多次，那么，一个用户一天就可能会产生几十条记录。&lt;/p&gt;&lt;p data-pid=&quot;MXDc7ogD&quot;&gt;如果用户多了的话，积分相关的数据量其实挺惊人的。&lt;/p&gt;&lt;p data-pid=&quot;ivXsv-Ls&quot;&gt;我们当时考虑了，水平方向的数据量可能会很大，但是用户并发量并不大，不像登录接口那样。&lt;/p&gt;&lt;p data-pid=&quot;yBb2EDj7&quot;&gt;所以采用的方案是：分表。&lt;/p&gt;&lt;p data-pid=&quot;Ua9b2RH8&quot;&gt;当时使用一个积分数据库就够了，但是分了128张表。然后根据用户id，进行hash除以128取模。&lt;/p&gt;&lt;p data-pid=&quot;ZUbK0lsX&quot;&gt;最近无意间获得一份BAT大厂大佬写的刷题笔记，一下子打通了我的任督二脉，越来越觉得算法没有想象中那么难了。&lt;/p&gt;&lt;p data-pid=&quot;7KJN0NRB&quot;&gt;[BAT大佬写的刷题笔记，让我offer拿到手软](&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkwNjMwMTgzMQ%3D%3D%26mid%3D2247490336%26idx%3D1%26sn%3D2f9db262746f692136cd6ce7179fc208%26source%3D41%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这位BAT大佬写的Leetcode刷题笔记，让我offer拿到手软&lt;/a&gt;)&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-082d6c30514ee75218778940ca7c933f_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-082d6c30514ee75218778940ca7c933f_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote data-pid=&quot;z-4LRV1Z&quot;&gt;需要特别注意的是，分表的数量最好是2的幂次方，方便以后扩容。&lt;/blockquote&gt;&lt;h3&gt;3.3 分库分表&lt;/h3&gt;&lt;p data-pid=&quot;t_gOo0MA&quot;&gt;后来我去了一家从事餐饮软件开发的公司。这个公司有个特点是在每天的中午和晚上的就餐高峰期，用户的并发量很大。&lt;/p&gt;&lt;p data-pid=&quot;h8WesqfJ&quot;&gt;用户吃饭前需要通过我们系统点餐，然后下单，然后结账。当时点餐和下单的并发量挺大的。&lt;/p&gt;&lt;p data-pid=&quot;2UjQo1Hf&quot;&gt;餐厅可能会有很多人，每个人都可能下多个订单。这样就会导致用户的并发量高，并且数据量也很大。&lt;/p&gt;&lt;p data-pid=&quot;mwswuwxf&quot;&gt;所以，综合考虑了一下，当时我们采用的技术方案是：分库分表。&lt;/p&gt;&lt;p data-pid=&quot;_jxh-RXR&quot;&gt;经过调研之后，觉得使用了当当网开源的基于jdbc的中间件框架：sharding-jdbc。&lt;/p&gt;&lt;p data-pid=&quot;ia9X8A3G&quot;&gt;当时分了4个库，每个库有32张表。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-79eea3c46699a47193f90823e7df833c_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-79eea3c46699a47193f90823e7df833c_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;4 总结&lt;/h2&gt;&lt;p data-pid=&quot;EMh_IX4O&quot;&gt;上面主要从：垂直和水平，两个方向介绍了我们的系统为什么要分库分表。&lt;/p&gt;&lt;p data-pid=&quot;Xn6yzWzF&quot;&gt;说实话垂直方向（即业务方向）更简单。&lt;/p&gt;&lt;p data-pid=&quot;ANYgY52o&quot;&gt;在水平方向（即数据方向）上，分库和分表的作用，其实是有区别的，不能混为一谈。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;KPF0ysWH&quot;&gt;分库：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。  &lt;/li&gt;&lt;li data-pid=&quot;FTbeh9os&quot;&gt;分表：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。  &lt;/li&gt;&lt;li data-pid=&quot;kYTzdPZM&quot;&gt;分库分表：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。  &lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;LzLeRECT&quot;&gt;如果在有些业务场景中，用户并发量很大，但是需要保存的数据量很少，这时可以只分库，不分表。&lt;/p&gt;&lt;p data-pid=&quot;iAl4ATGM&quot;&gt;如果在有些业务场景中，用户并发量不大，但是需要保存的数量很多，这时可以只分表，不分库。&lt;/p&gt;&lt;p data-pid=&quot;Uhr3O_r-&quot;&gt;如果在有些业务场景中，用户并发量大，并且需要保存的数量也很多时，可以分库分表。&lt;/p&gt;&lt;p data-pid=&quot;pxfbAo9m&quot;&gt;好了，今天的内容就先到这里。&lt;/p&gt;&lt;p data-pid=&quot;58e3OmdT&quot;&gt;是不是有点意犹未尽？&lt;/p&gt;&lt;p data-pid=&quot;YmG-16am&quot;&gt;没关系，其实分库分表相关内容挺多的，本文作为分库分表系列的第一弹，作为一个开胃小菜吧，分享给大家。&lt;/p&gt;&lt;p data-pid=&quot;l5M61qA6&quot;&gt;在文章末尾顺便提几个问题：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;irfJrCN6&quot;&gt;分库分表的具体实现方案有哪些？  &lt;/li&gt;&lt;li data-pid=&quot;1olGWFqZ&quot;&gt;分库分表后如何平滑扩容？  &lt;/li&gt;&lt;li data-pid=&quot;giPF_pVR&quot;&gt;分库分表后带来了哪些问题？  &lt;/li&gt;&lt;li data-pid=&quot;zCnmv0aH&quot;&gt;如何在项目中实现分库分表功能？  &lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;uAn4irs_&quot;&gt;欢迎关注，敬请期待我的下一篇文章。&lt;/p&gt;&lt;p data-pid=&quot;g74I0hqg&quot;&gt;最近无意间获得一份BAT大厂大佬写的刷题笔记，一下子打通了我的任督二脉，越来越觉得算法没有想象中那么难了。&lt;/p&gt;&lt;p data-pid=&quot;JP7-pO9q&quot;&gt;[BAT大佬写的刷题笔记，让我offer拿到手软](&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/tq4HYlL5A4qL5Aka3jFNqw&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;这位BAT大佬写的Leetcode刷题笔记，让我offer拿到手软&lt;/a&gt;)&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h3&gt;最后说一句(求关注，别白嫖我)&lt;/h3&gt;&lt;p data-pid=&quot;zWx1cxgh&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-pid=&quot;6RpwEam-&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;p data-pid=&quot;iVlxUvon&quot;&gt;最近无意间获得一份阿里大佬写的刷题笔记，一下子打通了我的任督二脉，进大厂原来没那么难。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://picx.zhimg.com/50/v2-3fcf6914c2550b87871d4ea3d1ca3270_720w.jpg?source=1940ef5c&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;770&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-a662a96d5f942a4b2b19596ccac458b1_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://picx.zhimg.com/v2-3fcf6914c2550b87871d4ea3d1ca3270_r.jpg?source=1940ef5c&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1440&quot; data-rawheight=&quot;770&quot; data-default-watermark-src=&quot;https://pica.zhimg.com/50/v2-a662a96d5f942a4b2b19596ccac458b1_720w.jpg?source=1940ef5c&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://picx.zhimg.com/v2-3fcf6914c2550b87871d4ea3d1ca3270_r.jpg?source=1940ef5c&quot; data-actualsrc=&quot;https://picx.zhimg.com/50/v2-3fcf6914c2550b87871d4ea3d1ca3270_720w.jpg?source=1940ef5c&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;z5PvvHPO&quot;&gt;链接：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//pan.baidu.com/s/1UECE5yuaoTTRpJfi5LU5TQ&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;pan.baidu.com/s/1UECE5y&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;uaoTTRpJfi5LU5TQ&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;  密码：bhbe&lt;/p&gt;&lt;p data-pid=&quot;fQvnb9Sd&quot;&gt;不会有人刷到这里还想白嫖吧？点赞对我真的非常重要！在线求赞。加个关注我会非常感激！ &lt;a class=&quot;member_mention&quot; href=&quot;https://www.zhihu.com/people/5a9414fa2a7f6b243d3c790e5d1975e7&quot; data-hash=&quot;5a9414fa2a7f6b243d3c790e5d1975e7&quot; data-hovercard=&quot;p$b$5a9414fa2a7f6b243d3c790e5d1975e7&quot;&gt;@苏三说技术&lt;/a&gt; &lt;/p&gt;&lt;/span&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>