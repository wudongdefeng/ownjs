<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c0e3dd38669749a0e8082278abfef99e</guid>
<title>网关系统就该这么设计（万能通用），稳的一批</title>
<link>https://toutiao.io/k/f4lr8a4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib2ibq0p8cfjxRlTHl0reqRwBcTwYuTvbW8SL1VImm163MGgkBZiaojCCiazEnQz49QOTicbqXAdtvoywg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;长按 &lt;/span&gt;&lt;span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;关注&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt; 此公众号，&lt;span&gt;技术干货，及时送达&lt;/span&gt;&lt;/span&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文准备围绕七个点来讲网关，分别是网关的基本概念、网关设计思路、网关设计重点、流量网关、业务网关、常见网关对比，对基础概念熟悉的朋友可以根据目录查看自己感兴趣的部分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是网关&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关，很多地方将网关比如成门， 没什么问题， 但是需要区分网关与网桥的区别，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网桥&lt;/strong&gt; 工作在数据链路层，在不同或相同类型的LAN之间存储并转发数据帧，必要时进行链路层上的协议转换。可连接两个或多个网络，在其中传送信息包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;网关&lt;/strong&gt; 是一个大概念，不具体特指一类产品，只要连接两个不同的网络都可以叫网关，网桥一般只转发信息，而网关可能进行包装。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网关通俗理解&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据网关的特性，举个例子:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如你要去找集团老板(这儿只是举个例子)， 大家都知道老板肯定不是谁想见就能见的， 也怕坏人嘛， 那么你去老板所在的办公楼，假如是集团总部， 大楼这个门就充当了网关的角色， 大门一般都有看门员 ，看门员会做哪些事情呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先所有想见老板的人肯定都得从这个门进(&lt;strong&gt;统一入口&lt;/strong&gt; )， 这个门相当于将办公室和外界隔离了，主要为了保护里面的安全以及正常工作， 来到这个门之后， 门卫肯定会让你出示相关证件(&lt;strong&gt;鉴权检验&lt;/strong&gt; )， 意思就是判断你要见老板这个请求是否合理， 如果不合理直接就拒绝了， 让你回家等消息 ， 如果鉴权之后， 发现你找老板其实只是为了和他谈谈两元店的生意， 门卫会跟你说这个用不着找老板， 你去集团投资部就行了(&lt;strong&gt;动态路由&lt;/strong&gt; ， 将请求路由到不同的后端集群中)， 此时会对你进行一些&lt;strong&gt;包装&lt;/strong&gt; ，例如给你出具一个访问证类似的，然后告诉你路该怎么走，等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看看，网关的作用是不是就是这三个， 最终目的就是减少你与集团的耦合，具体到计算机上就是减少客户端与服务端的耦合，如果没有网关意味着所有请求都会直接调用服务器上的资源，这样耦合太强了，服务器出了问题，客户端会直接报错， 例如老板换工作的地方了，如果没有网关你直接去原来的地方找， 肯定会被告知老板不在这儿。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么需要网关&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用单体应用程序架构时，客户端（Web 或移动端）通过向后端应用程序发起一次 REST 调用来获取数据。负载均衡器将请求路由给 N 个相同的应用程序实例中的一个。然后应用程序会查询各种数据库表，并将响应返回给客户端。微服务架构下，单体应用被切割成多个微服务，如果将所有的微服务直接对外暴露，势必会出现安全方面的各种问题，另外内外耦合严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端可以直接向每个微服务发送请求，其问题主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端需求和每个微服务暴露的细粒度 API 不匹配。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分服务使用的协议不是Web友好协议。可能使用 Thrift 二进制 RPC，也可能使用 AMQP 消息传递协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;微服务难以重构。如果合并两个服务，或者将一个服务拆分成两个或更多服务，这类重构就非常困难了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的各个服务直接暴露给客户端调用势必会引起各种问题。同时，服务端的各个服务可扩展和伸缩性很差。API 网关是微服务架构中的基础组件，位于接入层之下和业务服务层之上，如前所述的这些功能适合在 API 网关实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网关与服务器集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们服务器上，下面图介绍了网关(Gateway)作用，可知 Gateway 方式下的架构，可以细到为每一个服务的实例配置一个自己的 Gateway，也可以粗到为一组服务配置一个，甚至可以粗到为整个架构配置一个接入的 Gateway。于是，整个系统架构的复杂度就会变得简单可控起来。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165929203539823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJlfQq3XdzictlKNdx9en3NfxsRSVaqaiaEuuVIo9KwKEHOibzMOD5MHm8w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;904&quot;/&gt;&lt;/p&gt;&lt;section&gt;这张图展示了一个多层 Gateway 架构，其中有一个总的 Gateway 接入所有的流量(&lt;strong&gt;流量网关&lt;/strong&gt; )，并分发给不同的子系统，还有第二级 Gateway 用于做各个子系统的接入 Gateway(&lt;strong&gt;业务网关&lt;/strong&gt; )。可以看到，网关所管理的服务粒度可粗可细。通过网关，我们可以把分布式架构组织成一个星型架构，由网络对服务的请求进行路由和分发。下面来聊聊好的网关应该具备哪些功能，也就是网关设计模式。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网关设计思路&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个网关需要有以下的功能:&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 请求路由&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关一定要有请求路由的功能。这样一来，对于调用端来说，也是一件非常方便的事情。因为调用端不需要知道自己需要用到的其它服务的地址，全部统一地交给 Gateway 来处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 服务注册&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够代理后面的服务，并把请求路由到正确的位置上，网关应该有服务注册功能，也就是后端的服务实例可以把其提供服务的地址注册、取消注册。一般来说，注册也就是注册一些 API 接口。比如，HTTP 的 Restful 请求，可以注册相应 API 的 URI、方法、HTTP 头。这样，Gateway 就可以根据接收到的请求中的信息来决定路由到哪一个后端的服务上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 负载均衡&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为一个网关可以接收多个服务实例，所以网关还需要在各个对等的服务实例上做负载均衡策略。简单点就是直接 Round-Robin 轮询，复杂点的可以设置上权重进行分发，再复杂一点还可以做到 session 粘连。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 弹力设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关还可以把弹力设计中的那些异步、重试、幂等、流控、熔断、监视等都可以实现进去。这样，同样可以像 Service Mesh 那样，让应用服务只关心自己的业务逻辑（或是说数据面上的事）而不是控制逻辑（控制面）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 安全方面&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SSL 加密及证书管理、Session 验证、授权、数据校验，以及对请求源进行恶意攻击的防范。错误处理越靠前的位置就是越好，所以，网关可以做到一个全站的接入组件来对后端的服务进行保护。当然，网关还可以做更多更有趣的事情，比如：灰度发布、API聚合、API编排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;灰度发布&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关完全可以做到对相同服务不同版本的实例进行导流，还可以收集相关的数据。这样对于软件质量的提升，甚至产品试错都有非常积极的意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 聚合&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用网关可以将多个单独请求聚合成一个请求。在微服务体系的架构中，因为服务变小了，所以一个明显的问题是，客户端可能需要多次请求才能得到所有的数据。这样一来，客户端与后端之间的频繁通信会对应用程序的性能和规模产生非常不利的影响。于是，我们可以让网关来帮客户端请求多个后端的服务（有些场景下完全可以并发请求），然后把后端服务的响应结果拼装起来，回传给客户端（当然，这个过程也可以做成异步的，但这需要客户端的配合）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;API 编排&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在微服务的架构下，要走完一个完整的业务流程，我们需要调用一系列 API，就像一种工作流一样，这个事完全可以通过网页来编排这个业务流程。我们可能通过一个 DSL 来定义和编排不同的 API，也可以通过像 AWS Lambda 服务那样的方式来串联不同的 API。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网关设计重点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关设计重点主要是三个， 高性能、高可用、高扩展:&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 高性能&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在技术设计上，网关不应该也不能成为性能的瓶颈。对于高性能，最好使用高性能的编程语言来实现，如 C、C++、Go 和 Java。网关对后端的请求，以及对前端的请求的服务一定要使用异步非阻塞的 I/O 来确保后端延迟不会导致应用程序中出现性能问题。C 和 C++ 可以参看 Linux 下的 epoll 和 Windows 的 I/O Completion Port 的异步 IO 模型，Java 下如 Netty、Spring Reactor 的 NIO 框架。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 高可用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为所有的流量或调用经过网关，所以网关必须成为一个高可用的技术组件，它的稳定直接关系到了所有服务的稳定。网关如果没有设计，就会成变一个单点故障。因此，一个好的网关至少要做到以下几点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;集群化&lt;/strong&gt; 。网关要成为一个集群，其最好可以自己组成一个集群，并可以自己同步集群数据，而不需要依赖于一个第三方系统来同步数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;服务化&lt;/strong&gt; 。网关还需要做到在不间断的情况下修改配置，一种是像 Nginx reload 配置那样，可以做到不停服务，另一种是最好做到服务化。也就是说，得要有自己的 Admin API 来在运行时修改自己的配置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持续化&lt;/strong&gt; 。比如重启，就是像 Nginx 那样优雅地重启。有一个主管请求分发的主进程。当我们需要重启时，新的请求被分配到新的进程中，而老的进程处理完正在处理的请求后就退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 高扩展&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为网关需要承接所有的业务流量和请求，所以一定会有或多或少的业务逻辑。而我们都知道，业务逻辑是多变和不确定的。比如，需要在网关上加入一些和业务相关的东西。因此，一个好的 Gateway 还需要是可以扩展的，并能进行二次开发的。当然，像 Nginx 那样通过 Module 进行二次开发的固然可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，在&lt;strong&gt;运维方面&lt;/strong&gt; ，网关应该有以下几个设计原则。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务松耦合，协议紧耦合&lt;/strong&gt; 。在业务设计上，网关不应与后面的服务之间形成服务耦合，也不应该有业务逻辑。网关应该是在网络应用层上的组件，不应该处理通讯协议体，只应该解析和处理通讯协议头。另外，除了服务发现外，网关不应该有第三方服务的依赖。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应用监视，提供分析数据&lt;/strong&gt; 。网关上需要考虑应用性能的监控，除了有相应后端服务的高可用的统计之外，还需要使用 Tracing ID 实施分布式链路跟踪，并统计好一定时间内每个 API 的吞吐量、响应时间和返回码，以便启动弹力设计中的相应策略。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用弹力设计保护后端服务&lt;/strong&gt; 。网关上一定要实现熔断、限流、重试和超时等弹力设计。如果一个或多个服务调用花费的时间过长，那么可接受超时并返回一部分数据，或是返回一个网关里的缓存的上一次成功请求的数据。你可以考虑一下这样的设计。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;DevOps&lt;/strong&gt; 。因为网关这个组件太关键了，所以需要 DevOps 这样的东西，将其发生故障的概率降到最低。这个软件需要经过精良的测试，包括功能和性能的测试，还有浸泡测试。还需要有一系列自动化运维的管控工具。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网关设计注意事项&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不要在网关中的代码里内置聚合后端服务的功能，而应考虑将聚合服务放在网关核心代码之外。可以使用 Plugin 的方式，也可以放在网关后面形成一个 Serverless 服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关应该靠近后端服务，并和后端服务使用同一个内网，这样可以保证网关和后端服务调用的低延迟，并可以减少很多网络上的问题。这里多说一句，网关处理的静态内容应该靠近用户（应该放到 CDN 上），而网关和此时的动态服务应该靠近后端服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关也需要做容量扩展，所以需要成为一个集群来分担前端带来的流量。这一点，要么通过 DNS 轮询的方式实现，要么通过 CDN 来做流量调度，或者通过更为底层的性能更高的负载均衡设备。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于服务发现，可以做一个时间不长的缓存，这样不需要每次请求都去查一下相关的服务所在的地方。当然，如果你的系统不复杂，可以考虑把服务发现的功能直接集成进网关中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为网关考虑 bulkhead 设计方式。用不同的网关服务不同的后端服务，或是用不同的网关服务前端不同的客户。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，因为网关是为用户请求和后端服务的桥接装置，所以需要考虑一些安全方面的事宜。具体如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;加密数据&lt;/strong&gt; 。可以把 SSL 相关的证书放到网关上，由网关做统一的 SSL 传输管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;校验用户的请求&lt;/strong&gt; 。一些基本的用户验证可以放在网关上来做，比如用户是否已登录，用户请求中的 token 是否合法等。但是，我们需要权衡一下，网关是否需要校验用户的输入。因为这样一来，网关就需要从只关心协议头，到需要关心协议体。而协议体中的东西一方面不像协议头是标准的，另一方面解析协议体还要耗费大量的运行时间，从而降低网关的性能。对此，我想说的是，看具体需求，一方面如果协议体是标准的，那么可以干；另一方面，对于解析协议所带来的性能问题，需要做相应的隔离。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;检测异常访问&lt;/strong&gt; 。网关需要检测一些异常访问，比如，在一段比较短的时间内请求次数超过一定数值；还比如，同一客户端的 4xx 请求出错率太高……对于这样的一些请求访问，网关一方面要把这样的请求屏蔽掉，另一方面需要发出警告，有可能会是一些比较重大的安全问题，如被黑客攻击。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;流量网关&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量网关，顾名思义就是控制流量进入集群的网关，有很多工作需要在这一步做，对于一个服务集群，势必有很多非法的请求或者无效的请求，这时候要将请求拒之门外，降低集群的流量压力。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7321212121212122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJZhdzS5ERKDI4Jw9dMt1vS8ulcv1IgXbJquDOqdaVKxWkURZbXlI7uQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;825&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图所示的架构模型——流量网关。流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。&lt;strong&gt;Kong 就是典型的流量网关。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是kong的架构图，来自官网：https://konghq.com&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8998144712430427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJmQySr4jUIlmiaI81JPYvibgOcicT7OicBuCpOMO0BwuBcoNsA7lctE9KmA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要补充一点的是，业务网关一般部署在流量网关之后、业务系统之前，比流量网关更靠近业务系统。通常API网指的是业务网关。有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作，所以这两者之间并没有严格的界线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务网关&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个单体应用被拆分成许许多多的微服务应用后，也带来了一些问题。一些与业务非强相关的功能，比如权限控制、日志输出、数据加密、熔断限流等，每个微服务应用都需要，因此存在着大量重复的代码实现。而且由于系统的迭代、人员的更替，各个微服务中这些功能的实现细节出现了较大的差异，导致维护成本变高。另一方面，原先单体应用下非常容易做的接口管理，在服务拆分后没有了一个集中管理的地方，无法统计已存在哪些接口、接口定义是什么、运行状态如何。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关就是为了解决上述问题。作为微服务体系中的核心基础设施，一般需要具备接口管理、协议适配、熔断限流、安全防护等功能，各种开源的网关产品（比如 zuul）都提供了优秀高可扩展性的架构、可以很方便的实现我们需要的一些功能、比如鉴权、日志监控、熔断限流等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与流量网关相对应的就是业务网关，业务网关更靠近我们的业务，也就是与服务器应用层打交道，那么有很多应用层需要考虑的事情就可以依托业务网关，例如在线程模型、协议适配、熔断限流，服务编排等。下面看看业务网关体系结构:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5492341356673961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJ2xCIWhttyX0icicngj2UjzPJBmEB11Nhc3QeUZgkL6Wf3eDUGgNp6oZw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个途中可以看出业务网关主要职责以及所做的事情， 目前业务网关比较成熟的 API 网关框架产品有三个 分别是:Zuul1、Zuul2 和 SpringCloud Gateway， 后面再进行对比。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;常见网关对比&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然对比，就先宏观上对各种网关有一个了解，后面再挑一些常用的或者说应用广泛的详细了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前常见的开源网关大致上按照语言分类有如下几类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Nginx+lua&lt;/strong&gt; ：OpenResty、Kong、Orange、Abtesting gateway 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Java&lt;/strong&gt; ：Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、Dromara soul 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Go&lt;/strong&gt; ：Janus、fagongzi、Grpc-gateway&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Dotnet&lt;/strong&gt; ：Ocelot&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;NodeJS&lt;/strong&gt; ：Express Gateway、Micro Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照使用数量、成熟度等来划分，主流的有 5个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;OpenResty&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kong&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zuul、Zuul2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring Cloud Gateway&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. OpenResty&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty是一个流量网关，根据前面对流量网关的介绍就可以知道流量网关的指责。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty基于 Nginx与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过揉和众多设计良好的 Nginx 模块，OpenResty 有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OpenResty 最早是顺应 OpenAPI 的潮流做的，所以 Open 取自“开放”之意，而Resty便是 REST 风格的意思。虽然后来也可以基于 ngx_openresty 实现任何形式的 web service 或者传统的 web 应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说 Nginx 不再是一个简单的静态网页服务器，也不再是一个简单的反向代理了。第二代的 openresty 致力于通过一系列 nginx 模块，把nginx扩展为全功能的 web 应用服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 是用户驱动的项目，后来也有不少国内用户的参与，从 openresty.org 的点击量分布上看，国内和国外的点击量基本持平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_openresty 目前有两大应用目标：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;通用目的的 web 应用服务器。在这个目标下，现有的 web 应用技术都可以算是和 OpenResty 或多或少有些类似，比如 Nodejs， PHP 等等。ngx_openresty 的性能（包括内存使用和 CPU 效率）算是最大的卖点之一。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Nginx 的脚本扩展编程，用于构建灵活的 Web 应用网关和 Web 应用防火墙。有些类似的是 NetScaler。其优势在于 Lua 编程带来的巨大灵活性。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. Kong&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong基于OpenResty开发，也是流量层网关， 是一个云原生、快速、可扩展、分布式的Api 网关。继承了OpenResty的高性能、易扩展性等特点。Kong通过简单的增加机器节点，可以很容易的水平扩展。同时功能插件化，可通过插件来扩展其能力。而且在任何基础架构上都可以运行。具有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;提供了多样化的认证层来保护Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可对出入流量进行管制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了可视化的流量检查、监视分析Api。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够及时的转换请求和相应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供log解决方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可通过api调用Serverless 函数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong解决了什么问题&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们决定对应用进行微服务改造时，应用客户端如何与微服务交互的问题也随之而来，毕竟服务数量的增加会直接导致部署授权、负载均衡、通信管理、分析和改变的难度增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面对以上问题，API GATEWAY是一个不错的解决方案，其所提供的访问限制、安全、流量控制、分析监控、日志、请求转发、合成和协议转换功能，可以解放开发者去把精力集中在具体逻辑的代码，而不是把时间花费在考虑如何解决应用和其他微服务链接的问题上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片来自Kong官网:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5492341356673961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJ2xCIWhttyX0icicngj2UjzPJBmEB11Nhc3QeUZgkL6Wf3eDUGgNp6oZw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到Kong解决的问题。专注于全局的Api管理策略，全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong的优点以及性能&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在众多 API GATEWAY 框架中，Mashape 开源的高性能高可用API网关和API服务管理层——KONG（基于 NGINX+Lua）特点尤为突出，它可以通过插件扩展已有功能，这些插件（使用 lua 编写）在API请求响应循环的生命周期中被执行。于此同时，KONG本身提供包括 HTTP 基本认证、密钥认证、CORS、TCP、UDP、文件日志、API请求限流、请求转发及 NGINX 监控等基本功能。目前，Kong 在 Mashape 管理了超过 15，000 个 API，为 200，000 开发者提供了每月数十亿的请求支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kong提供一些列的服务，这就不得不谈谈内部的架构:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.257602862254025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJohqagKrM55X1SFV65kicYYSbPSL4DfoYPFK7kBwb1wnxGEFyGzgMWfA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;559&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先最底层是基于Nginx， Nginx是高性能的基础层， 一个良好的负载均衡、反向代理器，然后在此基础上增加Lua脚本库，形成了OpenResty，拦截请求， 响应生命周期，可以通过Lua编写脚本，所以插件比较丰富。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;关于Kong的一些插件库以及如何配置，可以参考简书:开源API网关系统（Kong教程）入门到精通：https://www.jianshu.com/p/a68e45bcadb6&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. Zuul1.0&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul是所有从设备和web站点到Netflix流媒体应用程序后端请求的前门。作为一个边缘服务应用程序，Zuul被构建来支持动态路由、监视、弹性和安全性。它还可以根据需要将请求路由到多个Amazon自动伸缩组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul使用了一系列不同类型的过滤器，使我们能够快速灵活地将功能应用到服务中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过滤器是Zuul的核心功能。它们负责应用程序的业务逻辑，可以执行各种任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Type&lt;/strong&gt; ：通常定义过滤器应用在哪个阶段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Async&lt;/strong&gt; ：定义过滤器是同步还是异步&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Execution Order&lt;/strong&gt; ：执行顺序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Criteria&lt;/strong&gt; ：过滤器执行的条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Action&lt;/strong&gt; ：如果条件满足，过滤器执行的动作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul提供了一个动态读取、编译和运行这些过滤器的框架。过滤器之间不直接通信，而是通过每个请求特有的RequestContext共享状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是Zuul的一些过滤器:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Incoming&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Incoming过滤器在请求被代理到Origin之前执行。这通常是执行大部分业务逻辑的地方。例如:认证、动态路由、速率限制、DDoS保护、指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Endpoint过滤器负责基于incoming过滤器的执行来处理请求。Zuul有一个内置的过滤器（ProxyEndpoint），用于将请求代理到后端服务器，因此这些过滤器的典型用途是用于静态端点。例如:健康检查响应，静态错误响应，404响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Outgoing&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Outgoing过滤器在从后端接收到响应以后执行处理操作。通常情况下，它们更多地用于形成响应和添加指标，而不是用于任何繁重的工作。例如:存储统计信息、添加/剥离标准标题、向实时流发送事件、gziping响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;过滤器类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是与一个请求典型的生命周期对应的标准的过滤器类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;PRE&lt;/strong&gt; ：路由到Origin之前执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ROUTING&lt;/strong&gt; ：路由到Origin期间执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;POST&lt;/strong&gt; ：请求被路由到Origin之后执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ERROR&lt;/strong&gt; ：发生错误的时候执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些过滤器帮助我们执行以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;身份验证和安全性&lt;/strong&gt; ：识别每个资源的身份验证需求，并拒绝不满足它们的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监控&lt;/strong&gt; ：在边缘跟踪有意义的数据和统计数据，以便给我们一个准确的生产视图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;动态路由&lt;/strong&gt; ：动态路由请求到不同的后端集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;压力测试&lt;/strong&gt; ：逐渐增加集群的流量，以评估性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;限流&lt;/strong&gt; ：为每种请求类型分配容量，并丢弃超过限制的请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;静态响应处理&lt;/strong&gt; ：直接在边缘构建一些响应，而不是将它们转发到内部集群&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 1.0 请求生命周期&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525229357798165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJFpicACYiao6mkImoDcCv5ibGqicppjNeNvvmI2U3eU33SpKV0kbvg7baJQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix宣布了通用API网关Zuul的架构转型。Zuul原本采用同步阻塞架构，转型后叫作Zuul2，采用异步非阻塞架构。Zuul2和Zuul1在架构方面的主要区别在于，Zuul2运行在异步非阻塞的框架上，比如Netty。Zuul1依赖多线程来支持吞吐量的增长，而Zuul 2使用的Netty框架依赖事件循环和回调函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. Zuul2.0&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zuul 2.0 架构图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8235294117647058&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJeicJ4aaZIeX5QiaF74iauBOdGMAgfGvDMDcPwwe5S8PicwT6jCubBoxI0Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图是Zuul2的架构，和Zuul1没有本质区别，两点变化：&lt;/span&gt;&lt;/section&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前端用Netty Server代替Servlet，目的是支持前端异步。后端用Netty Client代替Http Client，目的是支持后端异步。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;过滤器换了一下名字，用Inbound Filters代替Pre-routing Filters，用Endpoint Filter代替Routing Filter，用Outbound Filters代替Post-routing Filters。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Inbound Filters&lt;/strong&gt; ：路由到 Origin 之前执行，可以用于身份验证、路由和装饰请求&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Endpoint Filters&lt;/strong&gt; ：可用于返回静态响应，否则内置的ProxyEndpoint过滤器将请求路由到Origin&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Outbound Filters&lt;/strong&gt; ：从Origin那里获取响应后执行，可以用于度量、装饰用户的响应或添加自定义header&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有两种类型的过滤器：sync 和 async。因为Zuul是运行在一个事件循环之上的，因此从来不要在过滤中阻塞。如果你非要阻塞，可以在一个异步过滤器中这样做，并且在一个单独的线程池上运行，否则可以使用同步过滤器。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到过&lt;strong&gt;Zuul2开始采用了异步模型&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;优势&lt;/strong&gt; 是异步非阻塞模式启动的线程很少，基本上一个CPU core上只需启一个事件环处理线程，它使用的线程资源就很少，上下文切换(Context Switch)开销也少。非阻塞模式可以接受的连接数大大增加，可以简单理解为请求来了只需要进队列，这个队列的容量可以设得很大，只要不超时，队列中的请求都会被依次处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;不足&lt;/strong&gt; ，异步模式让编程模型变得复杂。一方面Zuul2本身的代码要比Zuul1复杂很多，Zuul1的代码比较容易看懂，Zuul2的代码看起来就比较费劲。另一方面异步模型没有一个明确清晰的请求-&amp;gt;处理-&amp;gt;响应执行流程(call flow)，它的流程是通过事件触发的，请求处理的流程随时可能被切换断开，内部实现要通过一些关联id机制才能把整个执行流再串联起来，这就给开发调试运维引入了很多复杂性，比如你在IDE里头调试异步请求流就非常困难。另外ThreadLocal机制在这种异步模式下就不能简单工作，因为只有一个事件环线程，不是每个请求一个线程，也就没有线程局部的概念，所以对于CAT这种依赖于&lt;/span&gt;ThreadLocal才能工作的监控工具，调用链埋点就不好搞(实际可以工作但需要进行特殊处理)。&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体上，异步非阻塞模式比较适用于IO密集型(IO bound)场景，这种场景下系统大部分时间在处理IO，CPU计算比较轻，少量事件环线程就能处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zuul 与 Zuul 2 性能对比&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfcJQQoZtiaCzX7AI5iazZjC02PKgwcoEiczzSz04MTibV8pUQJAba0DnOnkVpyibLlZ4o2cmYVGjribJricQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;648&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;336.6406570841889&quot; data-ratio=&quot;0.5185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJDZgWI0OUiaCPLKdkxDO5twPv46ALpic7fXCmLTp3Swd3SJFNiacs799PQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix给出了一个比较模糊的数据，&lt;strong&gt;大致Zuul2的性能比Zuul1好20%左右&lt;/strong&gt; ，这里的性能主要指每节点每秒处理的请求数。为什么说模糊呢？因为这个数据受实际测试环境，流量场景模式等众多因素影响，你很难复现这个测试数据。即便这个20%的性能提升是确实的，其实这个性能提升也并不大，和异步引入的复杂性相比，这20%的提升是否值得是个问题。Netflix本身在其博文22和ppt11中也是有点含糊其词，甚至自身都有一些疑问的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. Spring Cloud Gateway&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 2.0之前的非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Cloud Gateway 底层使用了高性能的通信框架Netty&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SpringCloud Gateway 特征&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SpringCloud官方，对SpringCloud Gateway 特征介绍如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）基于 Spring Framework 5，Project Reactor 和 Spring Boot 2.0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）集成 Hystrix 断路器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）集成 Spring Cloud DiscoveryClient&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Predicates 和 Filters 作用于特定路由，易于编写的 Predicates 和 Filters&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）具备一些网关的高级功能：动态路由、限流、路径重写&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上的特征来说，和Zuul的特征差别不大。SpringCloud Gateway和Zuul主要的区别，还是在底层的通信框架上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说明一下上文中的三个术语：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Filter&lt;/strong&gt; （过滤器）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Zuul的过滤器在概念上类似，可以使用它拦截和修改请求，并且对上游的响应，进行二次处理。过滤器为org.springframework.cloud.gateway.filter.GatewayFilter类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Route&lt;/strong&gt; （路由）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关配置的基本组成模块，和Zuul的路由配置模块类似。一个&lt;strong&gt;Route模块&lt;/strong&gt; 由一个 ID，一个目标 URI，一组断言和一组过滤器定义。如果断言为真，则路由匹配，目标URI会被访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Predicate&lt;/strong&gt; （断言）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个 Java 8 的 Predicate，可以使用它来匹配来自 HTTP 请求的任何内容，例如 headers 或参数。&lt;strong&gt;断言的&lt;/strong&gt; 输入类型是一个 ServerWebExchange。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;几种网关的对比&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5711135611907387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9mQQWOf4KRJmVRuAibP2T9cNS3ia5gl4pJeN3szRv8IKdaaM81vVAlClUZBfGDVZREpKTmAibQFuoArQlLrd0ibbRw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;来源：&lt;/span&gt;&lt;span&gt;developer.aliyun.com/article/889271&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;版权声明：此内容来源网络，版权归原作者所有。我们转载的内容，都会注明来源，除非无法确认。若有侵权，烦请告知，我们会立即删除并表示歉意。谢谢！&lt;/span&gt;&lt;/blockquote&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;PS：文章若对您有用，请帮助 &lt;strong&gt;点赞、在看、转发&lt;/strong&gt; 吧！&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;公众号：Java精选&quot; data-id=&quot;91842&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;section data-brushtype=&quot;text&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25&quot;&gt;&lt;span mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;22&quot;&gt;点击卡片关注我们，更多技术干货，及时为您送达！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzU0ODk2MzE3MA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib178LnVu9br0VUuI4OKYwvXKpZnaGseFG3vyFJShp2VFcwVodS88CkUsNYcLDrglYLHPFoic6MJD4A/0?wx_fmt=png&quot; data-nickname=&quot;逻魔代码&quot; data-alias=&quot;lomagicode&quot; data-signature=&quot;逻魔代码，分享架构技术干货，打造有价值的经验分享社群，帮助后继者以前人的肩膀为基，建造更精妙的技术殿堂！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;&lt;p mp-original-font-size=&quot;14&quot; mp-original-line-height=&quot;20&quot;&gt;往期推荐&lt;/p&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485572&amp;amp;idx=1&amp;amp;sn=34d9fd123bff27d7c1ecc035261da358&amp;amp;chksm=fbb65e89ccc1d79f7726a47c29596d68de1bbad16e43b9547463360351c6fbd54faf4caee4e7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;被裁员！从无赔偿拿到N+1的故事&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;被裁员！从无赔偿拿到N+1的故事&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485546&amp;amp;idx=1&amp;amp;sn=2f12cb634ec7898585ca6aad8624876c&amp;amp;chksm=fbb65e67ccc1d77101736e547d4454141a530b9f12d26f9b0bf5bd307769424adb3339e2a3e0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;从 Java 8 升级到 Java 17 踩坑全过程，建议收藏！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;从 Java 8 升级到 Java 17 踩坑全过程，建议收藏！&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485467&amp;amp;idx=1&amp;amp;sn=af235ce4464f9adb2fd2038727cb3435&amp;amp;chksm=fbb65e16ccc1d70031c297626d26de452d3c294fd3ed9ac3d39b9b646a1eb1d5cc94f41a0e88&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;拒绝暴力 kill -9 ！我选择这样优雅停止 SpringBoot 服务&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;拒绝暴力 kill -9 ！我选择这样优雅停止 SpringBoot 服务&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU0ODk2MzE3MA==&amp;amp;mid=2247485370&amp;amp;idx=1&amp;amp;sn=a5dc9c8df141cf83655c2ea0f235b09a&amp;amp;chksm=fbb651b7ccc1d8a121e32d113045a4cdfcfc550c314e4956386d899dd9c7ba649b83a31d9c7c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ULID规范解读与实现原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ULID规范解读与实现原理&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31d7661ceffeb2cd5918c40b07a16bef</guid>
<title>还不会日志异常检测？看完这篇文章就够了</title>
<link>https://toutiao.io/k/ee2apjn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;本篇文章将从日志异常检测面临的挑战、日志异常检测中的深度学习、以及日志异常检测算法评估和最后对日志异常检测的整体总结四个方面去讨论日志异常检测相关内容。&lt;/p&gt;

&lt;h2&gt;日志异常检测的挑战&lt;/h2&gt;

&lt;p&gt;当前，日志异常检测面临的挑战主要有以下八点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数据表示：深度学习模型接受结构化的数字形式的输入。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据不稳定：随着应用程序的发展，可能会出现不在训练数据中的新日志事件类型。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据不平衡：异常数据的数量远少于正常数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;异常多样性：异常日志的表现内容是多样的，包括序列模式、频率、相关性、到达时间等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;标签可用性：带标注的日志是稀缺的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;流处理：日志是数据流，实时检测比事后分析更符合实际需求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据量大：日志数据的生成量很大，一些系统每天产生数百万甚至数十亿的事件，这对算法的效率有要求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;模型可解释性：基于神经网络的方法通常比传统的机器学习方法具有更低的可解释性。当涉及到针对关键系统行为或安全事件做出合理决策时，理解正确和错误分类背后的原因尤其困难。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;日志异常检测中的深度学习&lt;/h2&gt;

&lt;h3&gt;预处理和特征表示&lt;/h3&gt;

&lt;p&gt;常用的对无结构的日志做预处理方式主要有两种。第一种方法是最常见的方法，利用解析器对每条日志提取唯一的事件标识符以及事件参数值，提取方式有使用已知数据集的现有模式以及使用解析算法生成模式如Drain或Spell两种方式。第二种方式是基于token，将日志拆分为单词列表，如通过空格拆分。再删除特殊字符，如数字等。&lt;/p&gt;

&lt;p&gt;需了解，深度学习最常用于揭示多个日志事件的异常模式，例如事件序列的变化或时间日志相关性。因此有必要在逻辑上将事件组织成组，然后单独或相互关联地进行分析。常见分组方式有两种，一种是滑动时间窗口，即一条日志会出现在多个窗口中；另一种是固定时间窗口，即一条日志只可能出现在一个组。后者粒度更粗，但便于计算。&lt;/p&gt;

&lt;p&gt;预处理之后，则需要进行特征表示。特征表示主要有以下三种方式：&lt;/p&gt;



&lt;p&gt;语义向量：在自然语言处理领域，通常的做法是将句子中的单词转换为语义向量，这些语义向量对基于上下文的语义（例如Word2Vec、BERT）或语言统计（例如TF-IDF）进行编码。语义编码通常通过在特定日志文件上训练深度神经网络或通过预训练模型来实现。&lt;/p&gt;

&lt;p&gt;位置编码：语义向量有时与位置嵌入结合使用基于它们在序列中的相对位置进行编码。为了将位置信息添加到编码的日志消息中，通常分别为偶数和奇数令牌索引使用正弦和余弦函数。&lt;/p&gt;



&lt;p&gt;独热编码是处理分类数据的最常用技术之一，经常应用于日志模式类型或令牌值的编码。形式上，有序列表d中的值i的一个热编码是长度为d的向量，其中第i个元素为1，所有其他元素为0。虽然大多时候将一个热编码数据直接用作神经网络的输入，但也可以将其与其他特征（如计数向量）组合，以便应用的神经网络能够识别输入并学习不同日志键的单独模型。&lt;/p&gt;



&lt;p&gt;嵌入层/矩阵：通常用于解决高维输入数据稀疏性问题。它们通常是随机初始化的参数，与分类模型一起训练，以创建日志消息的最佳向量编码。向量编码通常排列在矩阵中，使得通过将矩阵与一个热编码的日志向量相乘来获得特定日志密钥的相应向量。&lt;/p&gt;

&lt;p&gt;与语义向量的主要区别在于，嵌入层/矩阵通常不针对NLP目标进行训练，即它们不旨在学习像Word2Vec这样的词的语义；相反，仅训练嵌入层/矩阵以最小化分类网络的损失函数。还使用基于深度学习的自定义嵌入模型；我们将其输出称为深度编码嵌入（DE）。这包括基于字符、事件和序列的嵌入[42]、使用MLP和CNN的注意机制[45]以及将标签信息输入VAE[1]的令牌计数。&lt;/p&gt;



&lt;p&gt;基于深度学习的自定义嵌入模型包括基于字符、事件和序列的嵌入、使用MLP和CNN的注意机制等。&lt;/p&gt;

&lt;h3&gt;深度学习模型&lt;/h3&gt;

&lt;p&gt;设计模型前则需考虑其操作模式，操作模式主要分为以下几类：&lt;/p&gt;



&lt;p&gt;常见的深度学习模型中有 MLP、CNN，使用最多的是 RNN、LSTM、Bi-LSTM；Autoencoders 自编码器适合无监督场景，重构误差更高的是异常；GAN 则可生成式对抗网络。&lt;/p&gt;

&lt;p&gt;常见实用的损失函数主要有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cross-Entropy (CE)：交叉熵，用于多分类问题；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hyper-Sphere Objective Function (HS)：超球目标函数，到超球中心的距离即异常分数；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mean Squared Error (MSE)：均方误差，用于回归；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Kullback-Leibler Divergence (KL)：KL散度，用于衡量概率分布的损失。Marginal Likelihood (ML)：边缘似然，用处同KL；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Custom Loss Functions (CF)：自定义的损失函数。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;异常检测&lt;/h3&gt;

&lt;h4&gt;异常类型&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;离群值：离群值是指与整体日志内容不符的单条日志。常见的异常原因是：参数异常、时间异常、token序列异常。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;顺序异常：当执行路径发生变化时，会检测到顺序异常，即生成日志的应用程序执行事件的方式与以前不同。这可能涉及以前未看到的事件类型的全新序列。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;频率异常：频率异常仅考虑事件发生的数量。例如：描述文件打开和关闭的日志数量应该一样。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;统计异常：基于超出事件计数的多个对数事件的某些定量表达特性的异常。如它们的到达时间间隔或季节性发生模式。称其为统计异常，因为它们的检测通常假设事件发生随时间遵循特定的稳定分布。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;深度神经网络输出下的异常检测&lt;/h4&gt;

&lt;p&gt;通常深度神经网络的输出用于异常检测时，神经网络的输出由其最后一层中的单个节点或多个节点组成。因此，从网络中提取的结果值是数值的标量或矢量。&lt;/p&gt;

&lt;p&gt;一种可能的方案是将这些结果视为异常分数，该分数表示呈现给网络的日志事件在多大程度上表示异常。由于这些分数通常难以单独解释，因此通常有必要将其与某个阈值进行比较。在二分类（BIN）中，这种思想用于估计神经网络的输入是正常的还是异常的。对于监督方法，数值输出可以解释为输入对应于任一类的概率。对于半监督或无监督的方法，由于生成的异常分数通常不归一化，因此需要与经验确定的阈值进行比较。&lt;/p&gt;

&lt;p&gt;另一种相关方法是利用自动编码器的重建误差，自动编码器首先在低维空间中对输入数据进行编码，然后尝试将其重建为原始形式。在这种情况下，如果输入样本难以重建，即产生大的重建误差，则认为输入样本异常，因为它们不对应于训练网络的正常数据。&lt;/p&gt;

&lt;h4&gt;异常与正常数据区分&lt;/h4&gt;

&lt;p&gt;异常检测中区分异常与正常数据主要有以下两种方式：&lt;/p&gt;



&lt;h2&gt;日志异常检测算法评估&lt;/h2&gt;

&lt;p&gt;下图为是日志异常检测算法实验常用到的数据集。其中最常使用的是 HDFS、BGL、Thunderbird 和Openstack。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/49139c2b445e48c8ac3994f2db8357b6%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;异常检测方法的定量评估通常围绕着将正确检测到的异常样本数计数为真阳性（TP）、将错误检测到的非异常样本数计算为假阳性（FP）、将错误未检测到的反常样本数计为假阴性（FN）、将未正确检测到异常样本数统计为假阴性数（FN）以及正确未检测到的非异常样本作为真负（TN）。&lt;/p&gt;

&lt;p&gt;其中评价指标包括精确性（precision）、召回率（recall）、F1 值以及正确率（accuracy）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/377d2ca0aa774b1a8228acd3a7c9a32d%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下图是常用的 Benchmark 的统计，Deeplog 是最常用的基准。Deeplog 依赖于 LSTM RNN 按顺序预测即将发生的日志事件。因此，如果观测到的事件预计以低概率发生，则认为是异常。Deeplog 是第一个使用深度学习检测日志数据中的顺序异常且是开源的，因此被经常作为 Benchmark。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;



&lt;p&gt;数据不稳定性是日志异常检测面临的主要，即未知日志的出现是算法要解决的主要问题之一。解决这一问题的关键思想是将日志表示为语义向量，将其与已知日志进行比较。转移学习提供了一种解决只有少量标记数据可用的挑战的方法，其中模型在一个系统上训练，并在另一个系统中测试。其主要思想是，由神经网络学习的日志事件模式在不同领域是相似的。&lt;/p&gt;



&lt;p&gt;RNN 是应用最广泛的模型，因为它们是捕获日志数据中顺序模式的自然选择。所有常用的日志数据集里的异常经常表现为顺序发生的事件，这一事实解释了 RNN 的趋势。CNN 为 RNN 的有效替代方案，因为它们还能够提取事件相关性。由于要支持无监督学习，因此也经常使用自动编码器。&lt;/p&gt;



&lt;ol&gt;
&lt;li&gt;&lt;p&gt;直接标记日志消息，不需要任何解析器，此方法简单，但缺乏对标记的语义解释。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过解析消息并从日志事件集合（如序列、计数或统计）中提取信息。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从解析的日志事件中提取包括时间戳在内的参数。有多种方法可以将这些特征表示为深度学习模型所接收的数字向量。组成日志消息的 token 被表示为数字向量，并在其事件发生序列的上下文中考虑。大多数方法使用这些顺序特征，而频率、热编码数据和嵌入层使用较少或仅作为一个贡献特征。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;



&lt;p&gt;大部分方法都侧重于在事件序列、事件中的令牌序列或两者的组合中出现的顺序异常。只有少数方法使用事件计数或将单个日志行检测为异常值，而不考虑其发生的上下文。异常的判定通常来源于神经网络的输出。二分类或多类分类的输出直接用于报告异常。无监督/半监督方法将所有数值输出（如异常分数或重建误差）与预定义阈值进行比较，或者使用日志事件的概率分布来判定。对于特定的日志文件，通常根据经验确定这些阈值。&lt;/p&gt;



&lt;p&gt;大多数方法只使用四个数据集：HDFS、BGL、Thunderbird 和 OpenStack。评估通常基于异常序列进行，即整个日志序列被视为正常或异常，而不是单条日志。然而，长序列的一部分实际上可能代表正常的系统行为，而只有少数元素应视为异常。评估检测方法是否能够准确地确定序列的哪些部分是异常的，这对于系统操作员手动调查报告的异常也很实用。显然，这需要根据单个事件的粒度而不是以组来标记数据集。此外，几乎所有评估都依赖于 F1 等度量，这些度量在数据集高度不平衡时无法准确描述分类或检测性能。为了避免对评估结果的误解，可计算对类别不平衡更为稳健的指标，如真阴性率。&lt;/p&gt;

&lt;h2&gt;开源项目推荐&lt;/h2&gt;

&lt;p&gt;云智慧已开源数据可视化编排平台 FlyFish 。通过配置数据模型为用户提供上百种可视化图形组件，零编码即可实现符合自己业务需求的炫酷可视化大屏。 同时，飞鱼也提供了灵活的拓展能力，支持组件开发、自定义函数与全局事件等配置， 面向复杂需求场景能够保证高效开发与交付。&lt;/p&gt;

&lt;p&gt;如果喜欢我们的项目，请不要忘记点击下方代码仓库地址，在 &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;GitHub&lt;/a&gt;&lt;/strong&gt; &lt;strong&gt;/&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;Gitee&lt;/a&gt;&lt;/strong&gt; 仓库上点个 Star，我们需要您的鼓励与支持。此外，即刻参与 FlyFish 项目贡献成为 FlyFish Contributor 的同时更有万元现金等你来拿。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2FCloudWise-OpenSource%2FFlyFish&quot;&gt;https://github.com/CloudWise-OpenSource/FlyFish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee 地址：&lt;/strong&gt; &lt;strong&gt;&lt;a href=&quot;https://gitee.com/CloudWise/fly-fish&quot;&gt;https://gitee.com/CloudWise/fly-fish&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【飞鱼】加入 AIOps 社区飞鱼开发者交流群，与 FlyFish 项目 PMC 面对面交流～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cefb57ead65b4ad28a9684332a69a970%7Etplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>de817787163e4bf3bce47e03405dd589</guid>
<title>「云原生时代的 Java 虚拟机」针对于 GraalVM 的技术知识脉络的重塑和探究</title>
<link>https://toutiao.io/k/asjh7gh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;GraalVM__0&quot;/&gt;GraalVM 背景&lt;/h3&gt; 
&lt;p&gt;新、旧编程语言的兴起躁动，说明必然有其需求动力所在，譬如互联网之于JavaScript、人工智能之于Python，微服务风潮之于Golang等等。大家都清楚不太可能有哪门语言能在每一个领域都尽占优势，Java已是距离这个目标最接近的选项，但若“天下第一”还要百尺竿头更进一步的话，似乎就只能忘掉Java语言本身，踏入无招胜有招的境界。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;更进一步提升JVM上运行的程序的性能&lt;/li&gt;&lt;li&gt;通过预编译（ahead-of-time）编译Java程序为原生可执行程序&lt;/li&gt;&lt;li&gt;多种编程语言混编在一个程序中（polyglot）&lt;/li&gt;&lt;li&gt;类似于LLVM，GraalVM也提供了方便的机制方便开发新的编程语言&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;官方网站在： https://www.graalvm.org/&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_11&quot;/&gt;当前痛点&lt;/h3&gt; 
&lt;p&gt;在云原生时代，Java程序是有很大的劣势的，为什么这么说呢？一般的Java应用程序都要几十兆的内存，启动也不不快。&lt;/p&gt; 
&lt;p&gt;最流行的SpringBoot/SpringCloud微服务框架为例，启动一个已经优化好，很多bean需要lazy load的application至少需要3-4秒时间，内存需要几百兆，业务逻辑稍微复杂一点点，没有1G以上的内存是很难满足业务的需要呢？&lt;/p&gt; 
&lt;p&gt;那么在云原生时代，一个充满黑科技的JVM介绍给大家，它能帮助我们让Java程序的启动速度加快100倍，内存只需要原来的五分之一，甚至更少。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Graalvm_19&quot;/&gt;Graalvm的介绍&lt;/h3&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;GraalVM是2018年Oracle开发的下一代JVM实现，被官方称为“Universal VM”和“Polyglot VM”，这是一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台使用。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;这里“任何语言”包括了Java、Scala、Groovy、Kotlin等基于Java虚拟机之上的语言，还包括了C、C++、Rust等基于LLVM的语言，同时支持其他像JavaScript、Ruby、Python和R语言等等。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5f89505b7321c88bccdc1e3283f56cd6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;GraalVM可以无额外开销地混合使用这些编程语言，支持不同语言中混用对方的接口和对&lt;br/&gt; 象，也能够支持这些语言使用已经编写好的本地库文件。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;它的口号“Run Programs Faster Anywhere”就能感觉到一颗蓬勃的野心&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;Graalvm_32&quot;/&gt;Graalvm性能的对比&lt;/h4&gt; 
&lt;p&gt;GraalVM的性能真的不错。以JDK 8为例&lt;/p&gt; 
 
&lt;p&gt;其中OpenJDK是通过“GPL v2 with CE”协议开源的，可以免费商用的。&lt;/p&gt; 
&lt;p&gt;之前在用Apache Spark测试性能时， 对比一下两者性能， 稍微数据量大点的查询，会发现Oracle JDK一般都会比OpenJDK快30%以上。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;而GraalVM分为社区版和商业版，其中GraalVM的社区版也是采用了和OpenJDK一样的“GPL v2 with CE”协议开源的。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;对于GraalVM的社区版，非常惊喜的发现其比Oracle JDK也会快10%以上。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;没有试过GraalVM的商业版， 官方报道，其商业版比社区版提升的性能更多&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;Graalvm_49&quot;/&gt;Graalvm主要特性&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt;高性能的现代Java&lt;/li&gt;&lt;li&gt;占用资源少，启动速度快&lt;/li&gt;&lt;li&gt;JavaScript,Java, Ruby以及R混合编程&lt;/li&gt;&lt;li&gt;在JVM上运行原生语言&lt;/li&gt;&lt;li&gt;跨语言工具&lt;/li&gt;&lt;li&gt;JVM应用扩展&lt;/li&gt;&lt;li&gt;原生应用扩展&lt;/li&gt;&lt;li&gt;本地Java库&lt;/li&gt;&lt;li&gt;数据库支持多语言&lt;/li&gt;&lt;li&gt;创建自己的语言&lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;Graalvm_62&quot;/&gt;Graalvm工作原理&lt;/h4&gt; 
&lt;p&gt;GraalVM的基本工作原理是将这些语言的源代码（例如，JavaScript）或源代码编译后的中间格式（例如，LLVM字节码、Class字节码）通过解释器转换为能被GraalVM接受的中间表示（Intermediate Representation，IR），譬如设计一个解释器专门对&lt;strong&gt;LLVM&lt;/strong&gt;输出的字节码进行转换来支持C和C++语言，这个过程称为“程序特化”（Specialized，也常称为Partial Evaluation）。&lt;/p&gt; 
&lt;p&gt;GraalVM提供了&lt;strong&gt;Truffle&lt;/strong&gt;工具集来快速构建面向一种新语言的解释器，并用它构建了一个称为&lt;strong&gt;Sulong&lt;/strong&gt;的高性能LLVM字节码解释器。&lt;/p&gt; 
&lt;p&gt;从某个角度来看，GraalVM才是真正意义上与物理计算机相对应的高级语言虚拟机，因为它与物理硬件的指令集一样，做到了只与机器特性相关而不与某种高级语言特性相关。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Graalvm_70&quot;/&gt;Graalvm的高等优化能力&lt;/h4&gt; 
&lt;p&gt;Oracle Labs的研究总监Thomas Wuerthinger在接受采访时谈到：“&lt;strong&gt;随着GraalVM1.0的发布，已经证明了拥有高性能的多语言虚拟机是可能的，并且实现这个目标的最佳方式不是通过类似Java虚拟机和微软CLR那样带有语言特性的字节码&lt;/strong&gt;”。&lt;/p&gt; 
&lt;p&gt;本来就不以速度见长的语言运行环境，由于GraalVM本身能够对输入的中间表示进行自动优化，在运行时还能进行即时编译优化，往往使用GraalVM实现能够获得比原生编译器更优秀的执行效率，譬如Graal.js要优于Node.js、Graal.Python要优于CPtyhon，TruffleRuby要优于Ruby MRI，FastR要优于R语言等等。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;GraalvmHotspot_76&quot;/&gt;Graalvm与Hotspot的对比&lt;/h4&gt; 
&lt;p&gt;GraalVM本来就是在HotSpot基础上诞生的，天生就可作为一套完整的符合Java SE8标准Java虚拟机来使用。&lt;/p&gt; 
&lt;p&gt;它和标准的HotSpot差异主要在即时编译器上，其执行效率、编译质量目前与标准版的HotSpot相比也是互有胜负。&lt;/p&gt; 
&lt;p&gt;Oracle Labs和美国大学里面的研究院所做的最新即时编译技术的研究全部都迁移至基于GraalVM之上进行了，其发展潜力令人期待。&lt;/p&gt; 
&lt;p&gt;如果Java语言或者HotSpot虚拟机真的有被取代的一天，那从现在看来GraalVM是希望最大的一个候选项，这场革命很可能会在Java使用者没有明显感觉的情况下悄然而来，Java世界所有的软件生态都没有发生丝毫变化，但天下第一的位置已经悄然更迭。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Graalvm_86&quot;/&gt;Graalvm即时编译器&lt;/h4&gt; 
&lt;p&gt;自JDK 10起，HotSpot中又加入了一个全新的即时编译器：Graal编译器，看名字就可以联想到它是来自于Graal VM。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;C1C2_90&quot;/&gt;C1/C2即时编译器&lt;/h5&gt; 
&lt;p&gt;对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上是取决于即时编译器所输出的代码质量。&lt;/p&gt; 
&lt;p&gt;HotSpot虚拟机中包含有两个即时编译器：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;编译时间较短但输出代码优化程度较低的客户端编译器（简称为C1）&lt;/li&gt;&lt;li&gt;编译耗时长但输出代码优化质量也更高的服务端编译器（简称为C2）&lt;/li&gt;&lt;/ul&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统的。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;C2_101&quot;/&gt;C2即时编译器&lt;/h4&gt; 
&lt;p&gt;Graal编译器是作为C2编译器替代者的角色登场的。C2的历史已经非常长了，可以追溯到Cliff Click大神读博士期间的作品，这个由C++写成的编译器尽管目前依然效果拔群，但已经复杂到连Cliff Click本人都不愿意继续维护的程度。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Graal_105&quot;/&gt;Graal编译器&lt;/h4&gt; 
&lt;p&gt;而Graal编译器本身就是由Java语言写成，实现时又刻意与C2采用了同一种名为“Sea-of-Nodes”的高级中间表示（High IR）形式，使其能够更容易借鉴C2的优点。&lt;/p&gt; 
&lt;p&gt;Graal编译器比C2编译器晚了足足二十年面世，有着极其充沛的后发优势，在保持能输出相近质量的编译代码的同时，开发效率和扩展性上都要显著优于C2编译器，这决定了C2编译器中优秀的代码优化技术可以轻易地移植到Graal编译器上，但是反过来Graal编译器中行之有效的优化在C2编译器里实现起来则异常艰难。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;这种情况下，Graal的编译效果短短几年间迅速追平了C2，甚至某些测试项中开始逐渐反超C2编译器。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;Graal能够做比C2更加复杂的优化：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;“部分逃逸分析”（Partial Escape Analysis）&lt;/li&gt;&lt;li&gt;比C2更容易使用“激进预测性优化”（Aggressive Speculative Optimization）的策略&lt;/li&gt;&lt;li&gt;支持自定义的预测性假设&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;_119&quot;/&gt;未来可期&lt;/h5&gt; 
&lt;p&gt;Graal编译器尚且年幼，还未经过足够多的实践验证，所以仍然带着“实验状态”的标签，需要用开关参数去激活，这让笔者不禁联想起JDK 1.3时代，HotSpot虚拟机刚刚横空出世时的场景，同样也是需要用开关激活，也是作为Classic虚拟机的替代品的一段历史。&lt;/p&gt; 
&lt;p&gt;Graal编译器未来的前途可期，作为Java虚拟机执行代码的最新引擎，它的持续改进，会同时为HotSpot与Graal VM注入更快更强的驱动力。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_125&quot;/&gt;编译为原生执行程序&lt;/h5&gt; 
&lt;p&gt;编译为原生程序有一定的假设条件，比如：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;尽量少的JNI调用&lt;/li&gt;&lt;li&gt;尽量少的使用反射&lt;/li&gt;&lt;li&gt;尽量少的class loader隔离等&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;当没有用这些复杂功能的时候，很容易可以使用GraalVM提供的 native image 编译Jar为可执行程序。&lt;/p&gt; 
&lt;p&gt;当然即使当程序使用了 JNI、反射时，也没关系，我们可以使用一些配置文件告诉GraalVM单独处理这些信息，比如：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;通过参数 -H:JNIConfigurationFiles 告诉JNI相关配置JSON文件&lt;/li&gt;&lt;li&gt;通过参数 -H:ReflectionConfigurationFiles 告诉反射相关配置JSON文件&lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;稍微会复杂一些，但是只要有足够的耐心，理论上也是可以编译成功的！&lt;/p&gt; 
&lt;p&gt;不过我们可以使用一些原生支持GraalVM native image的框架， 比如：Quarkus。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;GraalVM_Serverless_144&quot;/&gt;GraalVM的原生编译非常适合微服务和 Serverless&lt;/h5&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;当可以把Java程序也编译为原生的可执行程序后 （目前GraalVM已经支持编译为Windows， MacOS， Linux上的原生程序），最主要的两个变化：&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;启动时间变短了，之前启动一个有“依赖注入”的Java程序，可能启动时间要2秒以上。如果Java程序是要长期运行的，那启动时间稍慢一点是没问题的，但是对于 Serverless 应用，这就变为冷启动（cold start）了，影响比较大。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;程序运行的内存需求变小了，之前启动一个Java程序，控制的好的话（heap设置的比较小），也要100M以上的内存，但是编译为原生程序后，只需要4M内存就可以了。 这样同样的一台机器就可以启动非常多的进程，适合简单的微服务。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h4&gt;&lt;a id=&quot;_152&quot;/&gt;参考资料&lt;/h4&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;https://it.deepinmind.com/jvm/2019/08/27/graalvm-ten-things.html&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;https://www.zhihu.com/question/274042223&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;https://www.jianshu.com/p/9e578398b108&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>670f43dc3751cb9eac8f886181973562</guid>
<title>记一次跨域配置引发的思考</title>
<link>https://toutiao.io/k/91gckgl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Flora，携程高级研发经理，关注Node.js相关领域。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文主要记录一次静态资源服务源站更新了跨域策略后，引发的客户端跨域请求失败的案例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果对跨域不太熟悉的同学，可以阅读一下&lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&quot; textvalue=&quot;MDN HTTP访问控制（CORS）这篇文章&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;MDN HTTP访问控制（CORS）这篇文章&lt;/a&gt;。相关概念在本文中就不再做赘述。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、背景回顾&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个周五的下午，我们收到了一个需求，需要调整一下响应头中的Access-Control-Allow-Origin字段。这个需求的起因是什么呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先看一下目前的情况。针对webresource站点（后续皆以这个站点作为资源站点的代号），无论是否是跨域请求，都会返回这样的头部。见图1。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fy7D4fzsyOzyggqQppdPRV3S2l8Dv7h6x3Vh92RatKNkcNGBpjlurZIA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图1 请求webresource站点的响应头截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.1 Screenshot of response headers for requesting a webresource site&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个响应看上去似乎没有什么问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是考虑这样一个场景：如果用户需要基于HTTP cookies和HTTP认证信息发送身份凭证，那么就需要再客户端设置一个特殊的credentials标志。例如，如果使用了fetch，那么就需要新增fetch的配置，如图2所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0924051&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fyt7uA63vljgufnj4g6xU9Zia9q3gdKlcMRCfaygXxIE0tUYKhg6NIQxw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;790&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图2 fetch方法新增credentials配置&lt;/p&gt;&lt;p&gt;Fig.2 fetch method adds credentials configuration&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;再客户端调整成如上配置后，再次运行会报以下错误，见图3。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Access to fetch at&lt;/p&gt;&lt;p&gt;&#x27;https://webresource.c-ctrip.com/ResUnionOnline/R1/common/marinRedirect.js?v=20220903&#x27;&lt;/p&gt;&lt;p&gt;from origin &#x27;https://www.ctrip.com&#x27; has been blocked by CORS policy: The value of the &#x27;Access-Control-Allow-Origin&#x27; header in the response must not be the wildcard &#x27;*&#x27; when the request&#x27;s credentials mode is &#x27;include&#x27;.”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1247059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fy5xzOfKh8sTtzCzaqicP93o4al0FQYlvVaBFKdtXKOESc9L1ChiaDSicHw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;850&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图3 请求出错截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.3 Screenshot of request error&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过翻阅这篇文章(&lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&quot; textvalue=&quot;Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*&lt;/a&gt;’)，我们可以得到解答：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“&lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&quot; textvalue=&quot;CORS&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;CORS&lt;/a&gt; 请求发出时，已经设定了 credentials，但服务端配置了 http 响应首部 &lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS&quot; textvalue=&quot;Access-Control-Allow-Origin &quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Access-Control-Allow-Origin &lt;/a&gt;的值为通配符 (&quot;*&quot;) ，而这与使用 credentials 相悖。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，这才回到了本节一开始我们需要做的一个调整，将原先的Access-Control-Allow-Origin设置为具体的origin值，而非 * 星号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再次调整之后，服务的响应头更新为图4所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8585859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3FyZ2NA3c9S8aTHawx7jwPiauBsRTxj4TEA8P0zPuLGGpiaSfQ5jFmyAwhw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图4 请求webresource站点的响应头截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.4 Screenshot of response headers for requesting a webresource site&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;二、故障现场&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;周五代码调整好，资源源站服务的单元测试跑通，发&lt;/span&gt;&lt;span&gt;布到金丝雀测试，&lt;/span&gt;&lt;span&gt;用户也反馈不报错了，变更正式发布。监控看板一切正常，就愉快的回家过周末了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;周六上午突然有开发同学截了一张图给我，说他们的应用报错了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1eqznWPRyN5VaUjgkUVt1cgX7BIKF5poaxniaiahOxXe6opY7fHTwngrTWMH5dwO5Apmic1F9MJPKC9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;图5 在线故障截图&lt;/p&gt;&lt;p&gt;Fig.5 Screenshot of online fault&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用户在&lt;a target=&quot;_blank&quot; href=&quot;https://ebooking.ctrip.com/login/index?targetPath=%2Febkovsassembly%2Fdefault.html&quot; textvalue=&quot;https://ebooking.ctrip.com&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://ebooking.ctrip.com&lt;/a&gt; 访问了一个资源，但是这个资源响应的Access-Control-Allow-Origin的头是 &lt;a target=&quot;_blank&quot; href=&quot;https://flights.ctrip.com/online/channel/domestic&quot; textvalue=&quot; https://flights.ctrip.com&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://flights.ctrip.com&lt;/a&gt; 。我去访问了这个页面，并未发现此类报报错。回访了一些用户，也让同事一起尝试访问，得到的反馈是一部分客户端报错，一部分客户端正常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、原因分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当时我们的第一反应就是再次检查源站的逻辑更改，发现源站的Access-Control-Allow-Origin的配置代码无异常，绝对不会将Access-Control-Allow-Origin的值 origin设置错误。再次结合反馈的情况，是部分用户会报错，开始将排障方向转向CDN(Content Delivery Network)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果对CDN不熟悉的同学，可以阅读&lt;a target=&quot;_blank&quot; href=&quot;https://en.wikipedia.org/wiki/Content_delivery_network&quot; textvalue=&quot;wikipedia CDN&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;wikipedia CDN&lt;/a&gt;或者&lt;a target=&quot;_blank&quot; href=&quot;https://www.akamai.com/our-thinking/cdn/what-is-a-cdn&quot; textvalue=&quot;What is a CDN (Content Delivery Network)?&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;What is a CDN (Content Delivery Network)?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先看这张简化的CDN结构图（图6）。目前针对webresource站点有三家CDN供应商，我们将他们称为：B供应商、W供应商和A供应商。其中B和W供应商为国内用户提供服务，他们的流量配比分别是50%和50%；A供应商为海外用户提供服务，他的流量配比是100%。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当一个国内用户请求某个webresource站点的资源时，他有可能会被分配到B、有可能分配到W。B或者W都会有概率（如果CDN节点命中失败的话），就会请求到资源源站服务。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7763975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3FyFagNKIDZBj3BGvtk9PRUAmCf4eUH90xtcXxMvFGabY33vWhEiaRhvFg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图6 简化的CDN结构图&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.6 Simplified CDN Structure Diagram&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由于客户端的反馈是部分正确部分异常，所以推测是CDN供应商可能某一家有异常或者某个节点有异常。于是再次绑定B供应商和W供应商的服务器节点进行测试，均设置请求头中的Origin为&lt;a target=&quot;_blank&quot; href=&quot;https://ebooking.ctrip.com/login/index?targetPath=%2Febkovsassembly%2Fdefault.html&quot; textvalue=&quot;https://ebooking.ctrip.com&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://ebooking.ctrip.com&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们得到了如下的结果：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1）B供应商响应的内容和源站响应的内容保持一致，如图7所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8318182&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3FyGuRRZ3XLsbxC4pnj17LOCZBlAKeicbhuicCkox1gH7u0tVQZ6d9lHzew/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图7 B供应商的响应体截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.7 Screenshot of response body for B supplier&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2）W供应商响应的内容与源站有2个响应头不一致，如图8所示。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7181373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fyic6yvt7zicVoFiagib7W0QB4E7iaHzNUf9I7CiaR3f6a1UIcficfFeyN188gA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;408&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图8 W供应商的响应体截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.8 Screenshot of response body for W supplier&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;第一个不一致是Access-Control-Allow-Origin不是源站，第二个不一致是缺少了Vary的头部。细心的同学通过“图4 请求webresource站点的响应头截图”，可以看到，源站是有设置Vary头部为“Origin, Accept-Encoding”，见图9。要知道，一旦缺少了这个头部，就无法标识要基于Origin做协商缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对Vary不熟悉的同学，可以参看&lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary&quot; textvalue=&quot;HTTP Vary&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;HTTP Vary&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“Vary 是一个 HTTP 响应头部信息，它决定了对于未来的一个请求头，应该用一个缓存的回复 (response) 还是向源服务器请求一个新的回复。它被服务器用来表明在 &lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Content_negotiation&quot; textvalue=&quot;content negotiation&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;content negotiation&lt;/a&gt; algorithm（内容协商算法）中选择一个资源代表的时候应该使用哪些头部信息（headers）.”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果Vary字段中有Origin，那么简单理解可以是基于Origin+URL做缓存。当Origin不一样的时候，就需要做头部信息的更新。同理，比如一些特殊文件polyfill，是需要基于浏览器做一些处理的，那么就可以设置将User-Agent设置到Vary中，这样就会针对同一个文件，基于User-Agent做缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9370629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3FyDTGRZvLOSYWFWHzQFPaee20yldh3icOEUYzSa8rARPtJmw0PyKSylJg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;429&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图9 请求webresource站点的响应头截图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.9 Screenshot of response headers for requesting a webresource site&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;至此问题基本定位到：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当两个不同的Origin（主站点）跨域请求同一个资源的时候，由于W供应商并没有根据资源服务返回的响应，正确配置CDN缓存头部，这样会导致返回的Access-Control-Allow-Origin值错乱。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、故障解决&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决在线故障第一要素是快速响应。所以我们将国内CDN配比从原先的各50%，更改成B供应商100%，保证客户端的响应正常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接着联系W供应商，当我们认为是供应商的一个严重的bug时，供应商的答复是：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;①请求Origin: http://ebooking.ctrip.com 缓存下来后（其对应的Etag为W/&quot;D96CF9DBB3B578CC1721941E799BE22D&quot;），由于源站响应了Vary: origin, accept-encoding，走入到了Vary缓存的逻辑中；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;②再请求Origin: http://a.ctrip.com，由于走入到Vary缓存的逻辑，且VaryData没有匹配到http://a.ctrip.com，则走入到Vary miss的逻辑中，miss回上层的时候带了If-None-Match: W/&quot;D96CF9DBB3B578CC1721941E799BE22D&quot;，此次回上层带的Origin是http://a.ctrip.com，但由于带了If-None-Match，且源站不同Origin的Etag值是相同的。所以响应了304，这时候就会直接复用Origin: http://ebooking.ctrip.com的响应了，也就会用到Origin: http://ebooking.ctrip.com响应的Access-Control-Allow-Origin头部了”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里W供应商这里有一个致命的逻辑错误：当用If-None-Match请求源站时，源站返回了304。这代表body没有改变，但同时源站返回了正确的Access-Control-Allow-Origin的头给到CDN。然而CDN并没有替换源站给到的头，而是直接读取一个缓存中错误的头。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然我们源站遵循了HTTP的标准，但是CDN没有遵循，导致返回给用户的响应头出错了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.258794&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fy2VgnibqztiaiaWlgvPGsibXGGp4JCK9L8trTpxOMiaqxxKgJ3nwUGjqOgmg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;图10 304请求也需要响应Vary头&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Fig.10 304 requests also need to respond to the Vary header&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;经过一番沟通，W供应商答应可以将这个逻辑做一个配置，规避出错的问题。但是需要按照资源域名逐一配置，也就是配置白名单的方式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以最终的解决方案是给到W供应商一批资源域名列表，让供应商做手动配置。且需要记住每一次新增一个资源域名都要同步到W供应商。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、经验总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过这次的故障，我们有如下总结：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1）测试完整性&lt;/strong&gt;：资源源站站点的每次更新发布，除了需要验证自身应用的正确性，也需要将每个&lt;strong&gt;CDN&lt;/strong&gt;供应商进行逐一的集成测试。因为不知道哪一个环节或者哪个配置可能会踩到坑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2）开发标准性：&lt;/strong&gt;无论我们的上游是怎么处理的，资源源站服务的开发一定要遵循&lt;strong&gt;HTTP&lt;/strong&gt;标准。只有参照标准，才能进行有秩序的治理。&lt;a target=&quot;_blank&quot; href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP&quot; textvalue=&quot;HTTP&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;HTTP&lt;/a&gt;是一份需要经常拿来阅读的文档。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3）资源的唯一性：&lt;/strong&gt;在引用静态资源时，尽量保证资源URL的唯一性，例如可以用md5来标识文件。这样的好处是，当这个资源出现一些不可预期的故障时，可以及时升级文件来达到快速刷新客户端请求内容的效果，而不是依靠缓存清理工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一方面是因为每个CDN供应商purge（清理缓存）的机制不一样，而且没有一个治理工具可以获悉是否每个CDN节点的缓存正确purge了。我想也许“缓存清理成功率”这个指标并未写到CDN供应商的交付指标中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一个方面是还有一些未可知的缓存节点，例如客户端的缓存，又例如在某个酒店内部使用的系统，有可能酒店内部网络存在缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们曾经发生过无论如何执行CDN侧的缓存清理脚本，客户端都无法拿到新的资源。与CDN供应商排查了许久未果，最终迫不得已还是修改了引用的URL地址（例如加一个query字段，虽然不优雅，但至少能暂时解决问题）。所以保证资源的唯一性还是很有必要的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后还想说一句，如果可以实现统一各CDN供应商的标准，那该是件多么美好的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;再经过一番深入了解后知悉，某些CDN供应商的设计初衷是直接对接存储，而非一个静态源站服务。而一些头部的配置是直接放在CDN供应商的控制面板中做配置。例如默认不会开启Vary这些的配置，是为了提升缓存效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;【推荐阅读】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1dCMcvI6oZNTERLqrFDw3Fyv9EKQWk0MWMdBibj8E0BgakPSnD3icB5swqqyOLypD82PDjvBRWvCEHQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6c318a230c276d2393bfa200ee4dd6f</guid>
<title>聊一聊责任链模式</title>
<link>https://toutiao.io/k/zqs36e9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;将一堆“事情”串联在一起，有序执行，就叫责任链&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;责任链模式（Chain of Responsibility Pattern）是将链中每一个节点看作是一个对象，每个节点处理的请求均不同，且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给每一个节点对象，直至有对象处理这个请求为止，属于行为型模式。下面放一张足球比赛的图，通过层层传递，最终射门。通过这张图，可以更好的理解责任链模式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7519788918205804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBlr3yRHvpklXExpKib024nDVremG3w8A3Ot7CQHG7dwP0Dy0fsALyEoYiaZjJmCom2NG0PtKQXErBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1137&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、入门案例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;2.1 类图&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.57265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBlr3yRHvpklXExpKib024nDN1o3icuB50pTQ9Q3EP4PTkFlg3qZuS3RKSZtzdXjxFa5cYicl5839bKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2.2 基础类介绍&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象接口RequestHandler&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 13:41&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;RequestHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;doHandler&lt;/span&gt;&lt;span&gt;(String req)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;抽象类BaseRequestHandler&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 13:45&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BaseRequestHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RequestHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; RequestHandler next;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;span&gt;(RequestHandler next)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;具体处理类AHandler&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 14:00&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;BaseRequestHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doHandler&lt;/span&gt;&lt;span&gt;(String req)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 处理自己的业务逻辑&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;A中处理自己的逻辑&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 传递给下个类（若链路中还有下个处理类）&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (next != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            next.doHandler(req);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;当然还有具体的处理类B、C等等，这里不展开赘述。&lt;/em&gt; &lt;strong&gt;使用类Client&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 14:06&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        BaseRequestHandler a = &lt;span&gt;new&lt;/span&gt; AHandler();&lt;br/&gt;        BaseRequestHandler b = &lt;span&gt;new&lt;/span&gt; BHandler();&lt;br/&gt;        BaseRequestHandler c = &lt;span&gt;new&lt;/span&gt; CHandler();&lt;br/&gt;        a.next(b);&lt;br/&gt;        b.next(c);&lt;br/&gt;        a.doHandler(&lt;span&gt;&quot;链路待处理的数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;2.3 处理流程图&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32592592592592595&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBlr3yRHvpklXExpKib024nDbBUibjYzr3gI6MrANG1QGBg9tD9zdzB3o5UqRd1tD8701t51XEjq4fA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;3.1 场景举例&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;场景一&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;前两年，在一家金融公司待过一段时间，其中就有一个业务场景：一笔订单进来，会先在后台通过初审人员进行审批，初审不通过，订单流程结束。初审通过以后，会转给终审人员进行审批，不通过，流程结束；通过，流转到下个业务场景。对于这块业务代码，之前一代目是一个叫知了的同事，他撸起袖子就是干，一套if-else干到底。后来，技术老大CodeReview，点名要求改掉这块。于是乎，想到用用设计模式吧，然后就噼里啪啦一顿改。（当然，比较复杂的情况，还是可以用工作流来处理这个场景，当时碍于时间成本，也就放弃了）。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;场景二&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;上家公司对接甲方爸爸的时候，对方会调用我们接口，将数据同步过来。同样，我们需要将处理好的数据，传给他们。由于双方传输数据都是加密传输，所以在接受他们数据之前，需要对数据进行解密，验签，参数校验等操作。同样，我们给他们传数据也需要进行加签，加密操作。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;具体案例&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;话不多说，对于场景二，我来放一些伪代码，跟大家一起探讨下。1、一切从注解开始，我这里自定义了一个注解&lt;code&gt;@Duty&lt;/code&gt;,这个注解有spring的&lt;code&gt;@Component&lt;/code&gt;注解，也就是标记了这个自定义注解的类，都是交给spring的bean容器去管理。注解中，有两个属性：1.type，定义相同的type类型的bean，会被放到一个责任链集合中。2.order，同一个责任链集合中，bean的排序，数值越小，会放到链路最先的位置，优先处理。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 16:11&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.TYPE})&lt;br/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Inherited&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Duty {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 标记具体业务场景&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;type&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 排序：数值越小，排序越前&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; 0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、定义一个顶层的抽象接口&lt;code&gt;IHandler&lt;/code&gt;，传入2个泛型参数，供后续自定义。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 15:31&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 责任链顶层抽象类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IHandler&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 抽象处理类&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; t&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;R &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3、定义一个责任链bean的管理类&lt;code&gt;HandleChainManager&lt;/code&gt;，用来存放不同业务下的责任链路集合。在该类中，有一个Map和两个方法。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;handleMap：这个map会存放责任链路中，具体的执行类，key是注解&lt;code&gt;@Duty&lt;/code&gt;中定义的type值，value是标记了&lt;code&gt;@Duty&lt;/code&gt;注解的bean集合，也就是具体的执行类集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;setHandleMap：传入具体执行bean的集合，存放在map中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;executeHandle：从map中找到具体的执行bean集合，并依次执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 16:00&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 责任链管理类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HandleChainManager&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 存放责任链路上的具体处理类&lt;br/&gt;     * k-具体业务场景名称&lt;br/&gt;     * v-具体业务场景下的责任链路集合&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, List&amp;lt;IHandler&amp;gt;&amp;gt; handleMap;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 存放系统中责任链具体处理类&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; handlerList&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setHandleMap&lt;/span&gt;&lt;span&gt;(List&amp;lt;IHandler&amp;gt; handlerList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        handleMap = handlerList&lt;br/&gt;                .stream()&lt;br/&gt;                .sorted(Comparator.comparingInt(h -&amp;gt; AnnotationUtils.findAnnotation(h.getClass(), Duty&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;order&lt;/span&gt;()))&lt;br/&gt;                .&lt;span&gt;collect&lt;/span&gt;(&lt;span&gt;Collectors&lt;/span&gt;.&lt;span&gt;groupingBy&lt;/span&gt;(&lt;span&gt;handler&lt;/span&gt; -&amp;gt; &lt;span&gt;AnnotationUtils&lt;/span&gt;.&lt;span&gt;findAnnotation&lt;/span&gt;(&lt;span&gt;handler&lt;/span&gt;.&lt;span&gt;getClass&lt;/span&gt;(), &lt;span&gt;Duty&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;type&lt;/span&gt;()))&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 执行具体业务场景中的责任链集合&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; type 对应&lt;span&gt;@Duty&lt;/span&gt;注解中的type，可以定义为具体业务场景&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; t 被执行的参数&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &amp;lt;T, R&amp;gt; &lt;span&gt;R &lt;span&gt;executeHandle&lt;/span&gt;&lt;span&gt;(String type, T t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;IHandler&amp;gt; handlers = handleMap.get(type);&lt;br/&gt;        R r = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (CollectionUtil.isNotEmpty(handlers)) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (IHandler&amp;lt;T, R&amp;gt; handler : handlers) {&lt;br/&gt;               r = handler.handle(t);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; r;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4、定义一个配置类&lt;code&gt;PatternConfiguration&lt;/code&gt;，用于装配上面的责任链管理器&lt;code&gt;HandleChainManager&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 15:35&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 设计模式配置类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PatternConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; HandleChainManager &lt;span&gt;handlerChainExecute&lt;/span&gt;&lt;span&gt;(List&amp;lt;IHandler&amp;gt; handlers)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HandleChainManager handleChainManager = &lt;span&gt;new&lt;/span&gt; HandleChainManager();&lt;br/&gt;        handleChainManager.setHandleMap(handlers);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; handleChainManager;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5、具体的处理类：&lt;code&gt;SignChainHandler&lt;/code&gt;、&lt;code&gt;EncryptionChainHandler&lt;/code&gt;、&lt;code&gt;RequestChainHandler&lt;/code&gt;，这里我以&lt;code&gt;SignChainHandler&lt;/code&gt;为例。在具体处理类上标记自定义注解&lt;code&gt;@Duty&lt;/code&gt;，该类会被注入到bean容器中，实现&lt;code&gt;IHandler&lt;/code&gt;接口，只需关心自己的handle方法，处理具体的业务逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/10/25 15:31&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 加签类&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Duty&lt;/span&gt;(type = BusinessConstants.REQUEST, order = &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SignChainHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IHandler&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 处理加签逻辑&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; s&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(String s)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 加签逻辑&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;甲方爸爸要求加签&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;加签&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;6、具体怎么调用？这里我写了个测试controller直接调用，具体如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; 往事如风&lt;br/&gt; * &lt;span&gt;@version&lt;/span&gt; 1.0&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/9/6 17:32&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HandleChainManager handleChainManager;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;/send&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;duty&lt;/span&gt;&lt;span&gt;(@RequestBody String requestBody)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String response = handleChainManager.executeHandle(BusinessConstants.REQUEST, requestBody);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; response;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;7、执行结果，会按照注解中标记的order依次执行。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBlr3yRHvpklXExpKib024nDaFLeVMib9ne1ZNOMVXx9MLLMFLfQFMia8HdGu47z6puRQkQ7Nw2VaR7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;至此，完工。又可以开心的撸代码了，然后在具体的执行类中，又是一顿if-else。。。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源码中运用&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;4.1Mybatis源码中的运用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;Mybatis中的缓存接口&lt;code&gt;Cache&lt;/code&gt;，cache作为一个缓存接口，最主要的功能就是添加和获取缓存的功能，作为接口它有11个实现类，分别实现不同的功能，下面是接口源码和实现类。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; org.apache.ibatis.cache;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.concurrent.locks.ReadWriteLock;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Cache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;putObject&lt;/span&gt;&lt;span&gt;(Object var1, Object var2)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Object &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;Object &lt;span&gt;removeObject&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;clear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;getSize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;default&lt;/span&gt; ReadWriteLock &lt;span&gt;getReadWriteLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvBlr3yRHvpklXExpKib024nDx9wlByQIibHtGvFKibCVQ85delvdUD63HyU1Op841z3yxz6bQKkZx1wA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;下面，我们来看下其中一个子类&lt;code&gt;LoggingCache&lt;/code&gt;的源码。主要看他的putObject方法和getObject方法，它在方法中直接传给下一个实现去执行。这个实现类其实是为了在获取缓存的时候打印缓存的命中率的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoggingCache&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Cache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Log log;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Cache delegate;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; requests = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; hits = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LoggingCache&lt;/span&gt;&lt;span&gt;(Cache delegate)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.delegate = delegate;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.log = LogFactory.getLog(&lt;span&gt;this&lt;/span&gt;.getId());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putObject&lt;/span&gt;&lt;span&gt;(Object key, Object object)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.delegate.putObject(key, object);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ++&lt;span&gt;this&lt;/span&gt;.requests;&lt;br/&gt;        Object value = &lt;span&gt;this&lt;/span&gt;.delegate.getObject(key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ++&lt;span&gt;this&lt;/span&gt;.hits;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.log.isDebugEnabled()) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.log.debug(&lt;span&gt;&quot;Cache Hit Ratio [&quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.getId() + &lt;span&gt;&quot;]: &quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;.getHitRatio());&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后，经过&lt;code&gt;Cache&lt;/code&gt;接口各种实现类的处理，最终会到达&lt;code&gt;PerpetualCache&lt;/code&gt;这个实现类。与之前的处理类不同的是，这个类中有一个map，在map中做存取，也就是说，最终缓存还是会保存在map中的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PerpetualCache&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Cache&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String id;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;Object, Object&amp;gt; cache = &lt;span&gt;new&lt;/span&gt; HashMap();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;PerpetualCache&lt;/span&gt;&lt;span&gt;(String id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putObject&lt;/span&gt;&lt;span&gt;(Object key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.cache.put(key, value);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;getObject&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.cache.get(key);&lt;br/&gt;    }&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4.2spring源码中的运用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;4.2.1DispatcherServlet类&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;DispatcherServlet 核心方法 doDispatch。HandlerExecutionChain只是维护HandlerInterceptor的集合，可以向其中注册相应的拦截器，本身不直接处理请求，将请求分配给责任链上注册处理器执行，降低职责链本身与处理逻辑之间的耦合程度。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doDispatch&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, HttpServletResponse response)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;  HttpServletRequest processedRequest = request;&lt;br/&gt;  HandlerExecutionChain mappedHandler = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;boolean&lt;/span&gt; multipartRequestParsed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;   ModelAndView mv = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   Exception dispatchException = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    processedRequest = checkMultipart(request);&lt;br/&gt;    multipartRequestParsed = (processedRequest != request);&lt;br/&gt;    &lt;span&gt;// Determine handler for the current request.&lt;/span&gt;&lt;br/&gt;    mappedHandler = getHandler(processedRequest);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mappedHandler == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     noHandlerFound(processedRequest, response);&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// Determine handler adapter for the current request.&lt;/span&gt;&lt;br/&gt;    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());&lt;br/&gt;    &lt;span&gt;// Process last-modified header, if supported by the handler.&lt;/span&gt;&lt;br/&gt;    String method = request.getMethod();&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; isGet = &lt;span&gt;&quot;GET&quot;&lt;/span&gt;.equals(method);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isGet || &lt;span&gt;&quot;HEAD&quot;&lt;/span&gt;.equals(method)) {&lt;br/&gt;     &lt;span&gt;long&lt;/span&gt; lastModified = ha.getLastModified(request, mappedHandler.getHandler());&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;new&lt;/span&gt; ServletWebRequest(request, response).checkNotModified(lastModified) &amp;amp;&amp;amp; isGet) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;     }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!mappedHandler.applyPreHandle(processedRequest, response)) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// Actually invoke the handler.&lt;/span&gt;&lt;br/&gt;    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (asyncManager.isConcurrentHandlingStarted()) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    applyDefaultViewName(processedRequest, mv);&lt;br/&gt;    mappedHandler.applyPostHandle(processedRequest, response, mv);&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;    dispatchException = ex;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;catch&lt;/span&gt; (Throwable err) {&lt;br/&gt;    &lt;span&gt;// As of 4.3, we&#x27;re processing Errors thrown from handler methods as well,&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// making them available for @ExceptionHandler methods and other scenarios.&lt;/span&gt;&lt;br/&gt;    dispatchException = &lt;span&gt;new&lt;/span&gt; NestedServletException(&lt;span&gt;&quot;Handler dispatch failed&quot;&lt;/span&gt;, err);&lt;br/&gt;   }&lt;br/&gt;   processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;   triggerAfterCompletion(processedRequest, response, mappedHandler, ex);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;catch&lt;/span&gt; (Throwable err) {&lt;br/&gt;   triggerAfterCompletion(processedRequest, response, mappedHandler,&lt;br/&gt;     &lt;span&gt;new&lt;/span&gt; NestedServletException(&lt;span&gt;&quot;Handler processing failed&quot;&lt;/span&gt;, err));&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (asyncManager.isConcurrentHandlingStarted()) {&lt;br/&gt;    &lt;span&gt;// Instead of postHandle and afterCompletion&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (mappedHandler != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// Clean up any resources used by a multipart request.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (multipartRequestParsed) {&lt;br/&gt;     cleanupMultipart(processedRequest);&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;4.2.2HandlerExecutionChain类&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;这里分析的几个方法，都是从DispatcherServlet类的doDispatch方法中请求的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;applyPreHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, &lt;br/&gt;                       HttpServletResponse response)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    HandlerInterceptor[] interceptors = &lt;span&gt;this&lt;/span&gt;.getInterceptors();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!ObjectUtils.isEmpty(interceptors)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interceptors.length; &lt;span&gt;this&lt;/span&gt;.interceptorIndex = i++) {&lt;br/&gt;            HandlerInterceptor interceptor = interceptors[i];&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (!interceptor.preHandle(request, response, &lt;span&gt;this&lt;/span&gt;.handler)) {&lt;br/&gt;                &lt;span&gt;this&lt;/span&gt;.triggerAfterCompletion(request, response, (Exception)&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在applyPreHandle方法中，执行triggerAfterCompletion方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;triggerAfterCompletion&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, &lt;br/&gt;                            HttpServletResponse response, Exception ex)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    HandlerInterceptor[] interceptors = &lt;span&gt;this&lt;/span&gt;.getInterceptors();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!ObjectUtils.isEmpty(interceptors)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;.interceptorIndex; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --i) {&lt;br/&gt;            HandlerInterceptor interceptor = interceptors[i];&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                interceptor.afterCompletion(request, response, &lt;span&gt;this&lt;/span&gt;.handler, ex);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable var8) {&lt;br/&gt;                logger.error(&lt;span&gt;&quot;HandlerInterceptor.afterCompletion threw exception&quot;&lt;/span&gt;, var8);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取拦截器，执行applyPostHandle方法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;applyPostHandle&lt;/span&gt;&lt;span&gt;(HttpServletRequest request, &lt;br/&gt;                     HttpServletResponse response, ModelAndView mv)&lt;/span&gt; &lt;br/&gt;                     &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    HandlerInterceptor[] interceptors = &lt;span&gt;this&lt;/span&gt;.getInterceptors();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!ObjectUtils.isEmpty(interceptors)) {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = interceptors.length - &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --i) {&lt;br/&gt;            HandlerInterceptor interceptor = interceptors[i];&lt;br/&gt;            interceptor.postHandle(request, response, &lt;span&gt;this&lt;/span&gt;.handler, mv);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;5.1 优点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将请求与处理解耦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求处理者（节点对象）只需要关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，转发给下一个节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链路结构灵活，可以通过改变链路的结构动态的新增或删减责任。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易于扩展新的请求处理类（节点），符合&lt;strong&gt;开闭原则&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;5.2 缺点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;责任链太长或者处理时间过长，会影响整体性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果节点对象存在循环引用时，会造成死循环，导致系统崩溃。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;&lt;span&gt;六、参考源码&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;&lt;span&gt;应用仓库：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>