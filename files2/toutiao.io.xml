<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1c4f079334f13526fa614f6d95b36c20</guid>
<title>田螺哥的MySQL专栏！25篇，真香！</title>
<link>https://toutiao.io/k/w5t80m1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;捡田螺的小男孩&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;gh_51e0e901a289&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>332efcb6ce38c30b8cdc09db8e1c367d</guid>
<title>一文带你彻底加强夯实底层原理之GC垃圾回收技术的分析指南（GC原理透析）</title>
<link>https://toutiao.io/k/rk24wbw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;前提介绍&lt;/h2&gt; 
&lt;p&gt;很多小伙伴，都跟我反馈，说自己总是对JVM这一块的学习和认识不够扎实也不够成熟，因为JVM的一些特性以及运作机制总是混淆以及不确定，导致面试和工作实战中出现了很多的纰漏和短板，解决广大小伙伴痛点，我写了本篇文章，希望可以帮助大家夯实基础和锻造JVM技术功底。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;GC_4&quot;/&gt;什么是垃圾收集（GC)&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;在JVM领域中GC（Garbage Collection）翻译为 “垃圾收集“，Garbage Collector翻译为 “垃圾收集器”&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;Generational_Model_8&quot;/&gt;分代模型(Generational Model)&lt;/h2&gt; 
&lt;p&gt;我们都知道在JVM中，执行垃圾收集需要停止整个应用（STW）。对象越多则收集所有垃圾消耗的时间就越长。程序中的大多数可回收的内存可归为两类:&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;大部分对象很快就不再使用&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;还有一部分不会立即无用，但也不会持续(太)长时间&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;这形成了分代数据模型。基于这一结构, VM中的内存被分为年轻代(Young Generation)和老年代(Old Generation)，老年代有时候也称为年老区(Tenured)。如下所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5b883331f2c0540e7787bff480a559a3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;从上图可以看出拆分为这样两个可清理的单独区域，允许采用不同的算法来大幅提高GC的性能。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_21&quot;/&gt;分代模型出现问题&lt;/h3&gt; 
&lt;p&gt;在不同分代中的对象可能会互相引用, 在收集某一个分代时就会成为 “事实上的” GC root。当然，要着重强调的是，分代假设并不适用于所有程序。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_25&quot;/&gt;分代模型适合场景&lt;/h3&gt; 
&lt;p&gt;GC算法专门针对“总体生命周期较短”，“总体生命周期较长” 这类特征的对象来进行优化, JVM对收集那种存活时间半长不长的对象就显得非常尴尬了，如下图对象分布。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d2eab11ca677fdf31811f7a1b8b08d4e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;堆内存中的内存池划分也是类似的。不太容易理解的地方在于各个内存池中的垃圾收集是如何运行的。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cb0be34c78434603e0ced4f25995c9bb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Eden_35&quot;/&gt;新生代(Eden,伊甸园)&lt;/h4&gt; 
&lt;p&gt;Eden是内存中的一个区域， 用来分配新创建的对象。通常会有多个线程同时创建多个对象，所以Eden区被划分为多个线程本地分配缓冲区(Thread Local Allocation Buffer, 简称TLAB)。通过这种缓冲区划分，大部分对象直接由JVM 在对应线程的TLAB中分配, 避免与其他线程的同步操作。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5c1e30c8a14c07d83be17ee74137985c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;如果 TLAB 中没有足够的内存空间, 就会在共享Eden区(shared Eden space)之中分配。如果共享Eden区也没有足够的空间, 就会触发一次 年轻代GC 来释放内存空间。如果GC之后 Eden 区依然没有足够的空闲内存区域, 则对象就会被分配到老年代空间(Old Generation)。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c1fc909e877b7406842ec91e77cd68f6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当Eden区进行垃圾收集时，GC将所有从root可达的对象过一遍, 并标记为存活对象。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b0123054f1d12fb0c91a23566f953d57.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;对象间可能会有跨代的引用，所以需要一种方法来标记从其他分代中指向Eden的所有引用。这样做又会遭遇各个分代之间一遍又一遍的引用。JVM在实现时采用了卡片标记(card-marking)。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_51&quot;/&gt;卡片标记&lt;/h5&gt; 
&lt;p&gt;JVM只需要记住Eden区中 “脏”对象的粗略位置，可能有老年代的对象引用指向这部分区间。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Survivor_Spaces_55&quot;/&gt;存活区(Survivor Spaces)&lt;/h4&gt; 
&lt;p&gt;Eden区的旁边是两个存活区, 称为 from 空间和 to 空间。需要着重强调的的是, 任意时刻总有一个存活区是空的(empty)。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/74929ba76bac7a15a21b196e582075fa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;空的那个存活区用于在下一次年轻代GC时存放收集的对象。年轻代中所有的存活对象(包括Edenq区和非空的那个 “from” 存活区)都会被复制到 ”to“ 存活区。GC过程完成后, ”to“ 区有对象,而 ‘from’ 区里没有对象。两者的角色进行正好切换 。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/22985e27f15bf8e4e3088f8994d98c2f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;存活的对象会在两个存活区之间复制多次，直到某些对象的存活时间达到一定的阀值。分代理论假设, 存活超过一定时间的对象很可能会继续存活更长时间。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/78d8d1c57f227cbf7e0cf9c7ab84fc1d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这类“ 年老” 的对象因此被提升(promoted )到老年代。提升的时候， 存活区的对象不再是复制到另一个存活区,而是迁移到老年代, 并在老年代一直驻留, 直到变为不可达对象。&lt;/p&gt; 
&lt;p&gt;此外GC会跟踪记录每个存活区对象存活的次数，每次分代GC完成后，存活对象的年龄就会+1。当年龄超过提升阈值(tenuring threshold)，就会被提升到老年代区域。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MaxTenuringThreshold_73&quot;/&gt;MaxTenuringThreshold的判定&lt;/h5&gt; 
&lt;p&gt;具体的提升阈值由JVM动态调整,但也可以用参数 &lt;code&gt;-XX:+MaxTenuringThreshold&lt;/code&gt;来指定上限。如果设置 &lt;code&gt;-XX:+MaxTenuringThreshold=0&lt;/code&gt; , 则GC时存活对象不在存活区之间复制，直接提升到老年代。现代 JVM 中这个阈值默认设置为15个GC周期。这也是HotSpot中的最大值。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Old_Generation_77&quot;/&gt;老年代(Old Generation)&lt;/h4&gt; 
&lt;p&gt;老年代内存空间一般情况下，里面的对象是垃圾的概率也更小。&lt;/p&gt; 
&lt;p&gt;老年代GC发生的频率比年轻代小很多。同时, 因为预期老年代中的对象大部分是存活的, 所以不再使用标记和复制(Mark and Copy)算法。而是采用移动对象的方式来实现最小化内存碎片。老年代空间的清理算法通常是建立在不同的基础上的。原则上,会执行以下这些步骤:&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;通过标志位(marked bit),标记所有通过 GC roots 可达的对象.&lt;/li&gt;&lt;li&gt;删除所有不可达对象&lt;/li&gt;&lt;li&gt;整理老年代空间中的内容，方法是将所有的存活对象复制,从老年代空间开始的地方,依次存放。&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;通过上面的描述可知, 老年代GC必须明确地进行整理,以避免内存碎片过多。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;PermGen_89&quot;/&gt;永久代(PermGen)&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Java8之前有一个特殊的空间，称为“永久代”(Permanent Generation)。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;它存储元数据(metadata)的地方,比如 class 信息等。此外,这个区域中也保存有其他的数据和信息, 包括内部化的字符串(internalized strings)等等。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b3503096919038a9eeb20ed07f6e2661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Metaspace_97&quot;/&gt;元数据区(Metaspace)&lt;/h4&gt; 
&lt;p&gt;Java 8直接删除了永久代(Permanent Generation)，改用Metaspace。将静态变量和字符串常量都放到其中。像类定义(class definitions)之类的信息会被加载到Metaspace 中。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/63a8463bf3eb527599bb9e6fba3e7059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;元数据区位于本地内存(native memory)，不再影响到普通的Java对象。默认情况下, Metaspace的大小只受限于Java进程可用的本地内存。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_105&quot;/&gt;常见的垃圾回收思想的误区&lt;/h3&gt; 
&lt;p&gt;在我们的日常生活中垃圾收集主要就是找到垃圾并进行清理，这与我们JVM的运作机制恰恰相反，JVM中的垃圾收集器跟踪和标记所有正在使用的对象，并把其余部分的对象当做垃圾对象。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;所以这里一定要区分清楚，我们这里的标记：是指&lt;strong&gt;标记可用对象，而不是垃圾对象&lt;/strong&gt;。常常会有人吧这两者理解错误和混乱。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;记住这一点以后，我们再深入讲解内存自动回收的原理，探究JVM中垃圾收集的具体实现。先从基础开始, 介绍垃圾收集的一般特征、核心概念以及实现算法。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_113&quot;/&gt;常见的垃圾回收类型&lt;/h3&gt; 
&lt;p&gt;垃圾回收类型主要是通过回收的范围进行界定和划分。具体的JVM回收区域如下图所示。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Java8_117&quot;/&gt;Java8之前&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/44190f13591d80bda1b79d6f218ffe88.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Java8_121&quot;/&gt;Java8之后&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/8f34a62b21efa1f283a72b89af66e953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;垃圾收集（Garbage Collection）通常分为：Minor GC - Major GC - Full GC 。接下来介绍这些事件及其区别，然后你会发现这些区别也不是特别清晰。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;Minor GC：年轻代垃圾回收机制，属于轻量级GC，主要面向于年轻代区域的垃圾对象进行回收。&lt;/li&gt;&lt;li&gt;Major GC：老年代垃圾回收机制，属于重量级GC，主要面向于老年代区域的垃圾对象进行回收。&lt;/li&gt;&lt;li&gt;Full GC：完全化GC，属于全量极GC，大致角度而言&lt;strong&gt;Major GC&lt;/strong&gt;和&lt;strong&gt;Full GC&lt;/strong&gt;差不多，其实具体分析，FullGC的范围是面向于整体的Heap堆内存。&lt;/li&gt;&lt;/ul&gt; 
&lt;h2&gt;&lt;a id=&quot;GCGC_BenefitsCost_131&quot;/&gt;GC的优点和缺点（GC Benefits/Cost）&lt;/h2&gt; 
&lt;h3&gt;&lt;a id=&quot;_133&quot;/&gt;好处&lt;/h3&gt; 
&lt;ol&gt;&lt;li&gt;提高系统的可靠性和稳定性&lt;/li&gt;&lt;li&gt;内存管理与程序设计的解耦&lt;/li&gt;&lt;li&gt;调试内存错误所花费的时间更少&lt;/li&gt;&lt;li&gt;悬挂程序点/内存泄漏不会发生&lt;/li&gt;&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注意：Java程序没有内存泄漏；“不意味着对象存储地址”更准确）&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;_142&quot;/&gt;坏处&lt;/h4&gt; 
 
&lt;h4&gt;&lt;a id=&quot;Minor_GC_147&quot;/&gt;Minor GC&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;年轻代内存的垃圾收集称为Minor GC。那什么时候会触发MinorG以及出发MinorGC得我条件是什么？&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/bacb722b6107ab3070c5c79431bd6209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_153&quot;/&gt;触发MinorGC的时机&lt;/h5&gt; 
&lt;p&gt;当JVM无法为新对象分配Eden区的内存空间时/达到了Eden存放阈值的时候会触发 Minor GC，所以新对象分配频率越高，Minor GC的频率就越高。并且Minor GC每次都会引起全线停顿(stop-the-world )，暂停所有的应用线程，对大多数程序而言,暂停时长基本上是可以忽略不计的。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_157&quot;/&gt;MinorGC回收的瓶颈&lt;/h5&gt; 
&lt;p&gt;Eden区的对象基本上都是垃圾，也不怎么复制到Survior区/老年代。如果情况不是这样, 大部分新创建的对象不能被垃圾回收清理掉，则 Minor GC的停顿就会持续更长的时间。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_161&quot;/&gt;MinorGC回收的范围&lt;/h5&gt; 
&lt;p&gt;Minor GC实际上忽略了老年代，主要面向的对象范围有两部分组成：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;主要是面向于老年代到年轻代的所引用的对象范围，例如，它会将从老年代指向年轻代的引用都被认为是GC Root，&lt;strong&gt;（而从年轻代指向老年代的引用在标记阶段全部被忽略）&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;主要面向的是Survior区之间的相互引用，此种场景的生命周期较短，属于年轻代之内的对象之间的引用关系。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;所以，Minor GC的定义很简单、清理的就是年轻代，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/786ae73319e5064720ebc36a2e3a3713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Major_GC_vs_Full_GC_173&quot;/&gt;Major GC vs Full GC&lt;/h4&gt; 
&lt;p&gt;从上面我们知道了Minor GC清理的是年轻代空间(Young space)，相应的其他区域也有对应的回收机制和策略。&lt;/p&gt; 
 
&lt;h4&gt;&lt;a id=&quot;Minor_GCMajorGCFullGC_181&quot;/&gt;Minor GC、MajorGC和FullGC执行效果&lt;/h4&gt; 
&lt;p&gt;大部分情况下，发生在年轻代的Minor GC次数会很多，会引起STW，也就是全局化暂停执行业务线程的行为，但是时间很短（几乎可以忽略不计）。而Major GC和Full GC也会造成全局化暂停的效果。所以一般情况下尽可能减少MajorGC和FullGC是什么必要的，但是也不能“一棒子打死一船人”。必要的时候还是需要触发少量几次Major GC以及FullGC，进而释放一些RSS常驻内存。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;GC_185&quot;/&gt;垃圾收集(GC)的原理&lt;/h2&gt; 
&lt;h3&gt;&lt;a id=&quot;Automated_Memory_Management_187&quot;/&gt;自动内存管理(Automated Memory Management)&lt;/h3&gt; 
&lt;p&gt;如果要显式地声明什么时候需要进行内存管理，实现自动进行收集垃圾，那样就太方便了，开发者不再耗费脑细胞去考虑要在何处进行内存清理。运行时环境会自动算出哪些内存不再使用，并将其释放，历史上第一款垃圾收集器是1959年为Lisp语言开发的。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Reference_Counting_191&quot;/&gt;引用计数(Reference Counting)&lt;/h4&gt; 
&lt;p&gt;共享指针方式的引用计数法， 可以应用到所有对象。许多语言都采用这种方法，包括 Perl、Python 和 PHP 等。下图很好地展示了这种方式：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7352d93e8848363eaa1bad57b0662304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;上图中所展示的GC ROOTS，表示程序正在使用的对象。主要（&lt;strong&gt;这里指的不是全部&lt;/strong&gt;）集中在于当前正在执行的方法中的局部变量或者是静态变量等。在这里主要我指的是Java。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;蓝色的圆圈表示可以引用到的对象，里面的数字就是被引用计数器&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;灰色的圆圈是各个作用域都不再引用的对象，可以被认为是垃圾，随时会被垃圾收集器清理。&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;detached_cycle_202&quot;/&gt;循环引用（detached cycle）的问题&lt;/h5&gt; 
&lt;p&gt;引用计数器无法针对于循环引用这种场景进行正确的处理和探测。任何作用域中都没有引用指向这些对象，但由于循环引用, 导致引用计数一直大于零，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f26c7fceb0bc9760e02565e488f98f94.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;红色线路和红色圆圈对象实际上属于垃圾引用以及垃圾对象，但由于引用计数的局限，所以存在内存泄漏，永远都无法进行回收该区域的对象内存。&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;detached_cycle_210&quot;/&gt;循环引用（detached cycle）的解决方案&lt;/h5&gt; 
&lt;p&gt;比如说可以针对于一些这种循环模式进行加入到 “弱引用”(‘weak’ references)的体系中，所以即使无法进行解决循环引用计数的场景，也可以通过弱引用实现内存回收。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;精华推荐 | 【JVM深层系列】「GC底层调优系列」一文带你彻底加强夯实底层原理之GC垃圾回收技术的分析指南（GC算法分析）&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26571307858daffc42ddaa94d87b4127</guid>
<title>Nephoo扩展Kubernetes解决云原生自动化</title>
<link>https://toutiao.io/k/4nrgtwd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;IMJupOYP&quot;&gt;Nephio项目由Linux基金会于2022年启动，该基金会与谷歌和一系列电信运营商、解决方案供应商和集成商一起，着手构建一个统一平台，使用Kubernetes为大规模5G电信网络部署提供意图驱动的云原生自动化。&lt;/p&gt;&lt;p data-pid=&quot;V9R_YzZi&quot;&gt;Nephoo社区的驱动力是在容器和虚拟机的大规模部署中，云原生自动化尚未完全实现。采用完全云原生堆栈仍然需要在资本和运营投资方面做出努力，而且对于采用者来说，结果并非100%完美。&lt;/p&gt;&lt;p data-pid=&quot;RSWIgwe0&quot;&gt;目前，Kubernetes的部署正在促进容器的带外自动化。Nephoo使Kubernetes能够：&lt;/p&gt;&lt;p data-pid=&quot;OC93nAXK&quot;&gt;——在其上部署云基础设施和网络功能，无需带外管理。&lt;/p&gt;&lt;p data-pid=&quot;QcXIahwH&quot;&gt;——管理其自身的基础设施和网络功能的配置，减少对外部编排的需求。&lt;/p&gt;&lt;p data-pid=&quot;ZUli5G1v&quot;&gt;Nephoo首先对Kubernetes的部署和配置进行了调整。我们知道，对于大型或电信网络，Kubernetes非常适合充当统一和自动化的控制平面，以配置可能分布的每个基础设施的所有方面和主机网络功能。&lt;/p&gt;&lt;p data-pid=&quot;P1D0sYqZ&quot;&gt;但据观察，Kubernetes并没有被用来自动执行云原生功能（CNF）和VNF。除了托管CNFs和VNFs（虚拟网络功能）之外，Nephoo架构还将在自动化方面使用Kubernetes。&lt;/p&gt;&lt;p data-pid=&quot;yGHCqxmS&quot;&gt;典型的大型电信网络涉及来自多个供应商和不同网络管理标准的网络功能。但是，如果我们从不同的供应商那里实现配置，并比较一个网络功能或云基础设施，情况就不一样了。例如，有O-RAN（开放无线接入网络）或3GPP等标准，但部署的配置有所不同。&lt;/p&gt;&lt;p data-pid=&quot;QTvZU_eh&quot;&gt;为了自动化供应，Nephoo将Kubernetes的声明性、主动协调的方法与机器可操作的配置相结合。它是声明性的，因为配置将作为基础设施自协调的意图提供，直到其达到预期状态（从观察到的状态进行检查）。&lt;/p&gt;&lt;p data-pid=&quot;HDElwEJ7&quot;&gt;此时，大多数现代基础设施管理员都在使用Helm图表进行复杂的Kubernetes工作负载部署和配置，但使用它们仍然很复杂。Helm图表是数千个嵌套的YAML模板文件。使用Helm图表的缺点是它会产生有条件生成的配置输出。&lt;/p&gt;&lt;p data-pid=&quot;BMvX_Fnr&quot;&gt;在Helm图表中，基于意图的连续协调是不可能实现的，因为它会生成带有条件的配置。对于Nepho，这种方法将被CRD（自定义资源定义）所取代。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;459&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;459&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;JFKY7W8C&quot;&gt;为了解决大规模Kubernetes环境中的配置问题，Nephoo将为不同的网络功能生成CRD和operator，以管理生命周期和配置。此外，随Helm提供的基础设施即代码（IaaC）将被配置即数据（CaD）取代。这些将部署在公共和私有云基础设施中，以实现自动化。CRD和operator的实施将符合3GPP、ORAN、O2等标准。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;TZkjS719&quot;&gt;原文链接：&lt;/p&gt;&lt;p data-pid=&quot;2wrJ2PHo&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//thenewstack.io/nephio-extends-kubernetes-to-solve-cloud-native-automation/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;thenewstack.io/nephio-e&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;xtends-kubernetes-to-solve-cloud-native-automation/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b512397cfdc658eb8dc7aa0a58cd4599</guid>
<title>定制一个 Vue 3 模板 - 集成 Vite, Pinia, Vue Router 与 Tailwind CSS</title>
<link>https://toutiao.io/k/585o10o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久前，我意识到我正在用一些重复使用的后台基础模板，浪费了我一些摸鱼时间，我突然想到--为什么不把这些可重复使用的部分重新利用起来，把它们简单地堆在一个模板里呢？🤔&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个后台模板中，用到了如下的框架或库：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vite&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Pinia&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Router&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tailwind CSS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vite SVG loader&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始之前，首先要安装 Node.js，这个自行百度解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;快速入门 - Vue, Router &amp;amp; Store&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先从初始化模板开始：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm init vue@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着输入项目名称 &lt;code&gt;vue3-boilerplate&lt;/code&gt;，然后在功能提示中选择安装 &lt;code&gt;Pinia&lt;/code&gt;和 &lt;code&gt;Vue Router&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;✔ Project name: vue3-boilerplate&lt;br/&gt;...&lt;br/&gt;✔ Add Vue Router &lt;span&gt;for&lt;/span&gt; Single Page Application development? Yes&lt;br/&gt;✔ Add Pinia &lt;span&gt;for&lt;/span&gt; state management? Yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据提示，选择所需功能后，执行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; vue3-boilerplate&lt;br/&gt;npm install&lt;br/&gt;npm run dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行后在本地开发环境中查看 &lt;code&gt;http://127.0.0.1:5173&lt;/code&gt; 此示例页面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5628415300546448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4MfldLrvTZibMe789ibZAqYibcZwFibfJjBs1x2amfxdpuFl7TyzQwiaBibrHPv6y8Nhw8HOrHmeA6jnibzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加 Tailwind CSS&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了基础后，现在我们需要一些样式。按照这个指南，我们安装Tailwind CSS，然后初始化配置文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install -D tailwindcss postcss autoprefixer&lt;br/&gt;npx tailwindcss init -p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完后，在根目录中，会有一个 &lt;code&gt;tailwind.config.js&lt;/code&gt;文件，填充内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/** @&lt;span&gt;type&lt;/span&gt; {import(&lt;span&gt;&#x27;tailwindcss&#x27;&lt;/span&gt;).Config} */&lt;br/&gt;module.exports = {&lt;br/&gt;  content: [&lt;span&gt;&quot;./index.html&quot;&lt;/span&gt;, &lt;span&gt;&quot;./src/**/*.{vue,js,ts,jsx,tsx}&quot;&lt;/span&gt;],&lt;br/&gt;  theme: {&lt;br/&gt;    extend: {},&lt;br/&gt;  },&lt;br/&gt;  plugins: [],&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们需要加载 &lt;code&gt;@tailwind&lt;/code&gt; 指令，所以在 &lt;code&gt;/src/assets&lt;/code&gt; 文件夹中创建&lt;code&gt;tailwind.css&lt;/code&gt;，其中包含以下内容(指令):&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@tailwind base;&lt;br/&gt;@tailwind components;&lt;br/&gt;@tailwind utilities;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;/src/assets/main.css&lt;/code&gt; 顶部导入它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@import &lt;span&gt;&quot;./tailwind.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们已经在 &lt;code&gt;/src/main.js&lt;/code&gt; 中导入了 &lt;code&gt;/src/assets/main.css&lt;/code&gt; 文件，所以，现在就可以在项目中使用 Tailwind 的实用类了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在 &lt;code&gt;/src/views/AboutView.vue&lt;/code&gt; 中的 &lt;code&gt;h1&lt;/code&gt; 标签添加一些实用类来测试一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;  &amp;lt;div class=&lt;span&gt;&quot;about&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;h1 class=&lt;span&gt;&quot;text-xl font-medium text-white&quot;&lt;/span&gt;&amp;gt;This is an about page&amp;lt;/h1&amp;gt;&lt;br/&gt;  &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在下面单独定义我们的CSS属性。要做到这一点，需要安装这个PostCSS插件 - &lt;code&gt;postcss-import&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install -D postcss-import&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，在实用类中使用 &lt;code&gt;@apply&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;style lang=&lt;span&gt;&quot;scss&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;.about {&lt;br/&gt;  @apply lg:min-h-screen lg:flex lg:items-center;&lt;br/&gt;  h1 {&lt;br/&gt;    @apply text-xl font-medium text-white;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加 SVG loader （可选）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我比较喜欢SVG，🥁恰好，我们新的模板可以很容易地导入SVG图像，但有一个问题--我们必须把它作为组件使用，这意味着需要手动在模板标签中添加SVG代码，然后像这样导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，有这样一个 vit-svg-loader 包，它基本上可以让我们在Vue模板中简单地导入 &lt;code&gt;.svg&lt;/code&gt; 文件作为组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，安装它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install vite-svg-loader --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;vite.config.js&lt;/code&gt; 配置文件中添加这个插件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import svgLoader from &lt;span&gt;&#x27;vite-svg-loader&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default defineConfig({&lt;br/&gt;   plugins: [vue(), svgLoader()],&lt;br/&gt;   ...&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，为了测试，把&lt;code&gt;/src/assets/logo.svg&lt;/code&gt; 中的 Vue logo 代码改成这个，然后保存:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;svg xmlns=&lt;span&gt;&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt; xmlns:xlink=&lt;span&gt;&quot;http://www.w3.org/1999/xlink&quot;&lt;/span&gt; viewBox=&lt;span&gt;&quot;0 0 2454.32 2457.41&quot;&lt;/span&gt;&amp;gt;&amp;lt;defs&amp;gt;&amp;lt;linearGradient id=&lt;span&gt;&quot;a&quot;&lt;/span&gt; x1=&lt;span&gt;&quot;285.11&quot;&lt;/span&gt; y1=&lt;span&gt;&quot;1790.44&quot;&lt;/span&gt; x2=&lt;span&gt;&quot;285.7&quot;&lt;/span&gt; y2=&lt;span&gt;&quot;1789.74&quot;&lt;/span&gt; gradientTransform=&lt;span&gt;&quot;matrix(2454.32, 0, 0, -2187.24, -699180.9, 3916163.49)&quot;&lt;/span&gt; gradientUnits=&lt;span&gt;&quot;userSpaceOnUse&quot;&lt;/span&gt;&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#41d1ff&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;1&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#bd34fe&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/linearGradient&amp;gt;&amp;lt;linearGradient id=&lt;span&gt;&quot;b&quot;&lt;/span&gt; x1=&lt;span&gt;&quot;285.22&quot;&lt;/span&gt; y1=&lt;span&gt;&quot;1790.33&quot;&lt;/span&gt; x2=&lt;span&gt;&quot;285.29&quot;&lt;/span&gt; y2=&lt;span&gt;&quot;1789.46&quot;&lt;/span&gt; gradientTransform=&lt;span&gt;&quot;matrix(1125.42, 0, 0, -2051.66, -319596.68, 3673197.31)&quot;&lt;/span&gt; gradientUnits=&lt;span&gt;&quot;userSpaceOnUse&quot;&lt;/span&gt;&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffea83&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0.08&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffdd35&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;1&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffa800&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/linearGradient&amp;gt;&amp;lt;/defs&amp;gt;&amp;lt;path d=&lt;span&gt;&quot;M2464.14,381.6,1311.22,2443.21c-23.8,42.57-85,42.82-109.12.46L26.33,381.79C0,335.63,39.47,279.72,91.78,289.08L1245.93,495.37a62.88,62.88,0,0,0,22.27,0l1130-206C2450.35,279.87,2490,335.35,2464.14,381.6Z&quot;&lt;/span&gt; transform=&lt;span&gt;&quot;translate(-17.94 -17.87)&quot;&lt;/span&gt; style=&lt;span&gt;&quot;fill:url(#a)&quot;&lt;/span&gt;/&amp;gt;&amp;lt;path d=&lt;span&gt;&quot;M1795.71,18.48,942.53,185.66a31.33,31.33,0,0,0-25.25,28.9L864.8,1101a31.33,31.33,0,0,0,29.41,33.14,31.77,31.77,0,0,0,8.91-.75l237.54-54.82a31.32,31.32,0,0,1,37.73,36.79l-70.57,345.59a31.33,31.33,0,0,0,39.8,36.24l146.72-44.57a31.34,31.34,0,0,1,39.79,36.32L1222,2031.73c-7,33.95,38.14,52.47,57,23.36l12.59-19.44L1986.77,648.19c11.65-23.23-8.44-49.72-33.94-44.79l-244.52,47.18a31.33,31.33,0,0,1-36-39.44L1831.86,57.91a31.34,31.34,0,0,0-36.14-39.43Z&quot;&lt;/span&gt; transform=&lt;span&gt;&quot;translate(-17.94 -17.87)&quot;&lt;/span&gt; style=&lt;span&gt;&quot;fill:url(#b)&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/svg&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;/src/App.vue&lt;/code&gt; 文件中，把它作为SVG组件导入，并用&lt;code&gt;&amp;lt;img class=&quot;logo&quot; /&amp;gt;&lt;/code&gt;替换它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;   import LogoSVG from &lt;span&gt;&#x27;./assets/logo.svg?component&#x27;&lt;/span&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;template&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;   &amp;lt;LogoSVG alt=&lt;span&gt;&quot;Vite logo&quot;&lt;/span&gt; class=&lt;span&gt;&quot;logo&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，一个简单的模板框架就搭建完啦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;下一步是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将它，发布到 npm 上，然后可以类似的命令安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i @richardecom/vue3-boilerplate&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面还有份清单，你可以选择性添加进去：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NuxtJS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Meta&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VeeValidate&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Toastification&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>92971919e1a0b60b0745cd41aceecc91</guid>
<title>我用 Rust 改写了自己的C++项目：这两个语言都很折磨人！</title>
<link>https://toutiao.io/k/bw5ceze</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;作者 | Strager&lt;/section&gt;&lt;section&gt;
译者 | 马可薇&lt;/section&gt;&lt;section&gt;
策划 | 褚杏娟&lt;/section&gt;&lt;section&gt;
C++ 漫长的构建时间可谓臭名昭著，编程圈的“我的代码在编译”只是个段子，但 C++ 让这个段子长盛不衰。&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5759162303664922&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKAVNicPMTwjV67w706lrEvcrH9icYXxN4rL15xOEiaqm7Ioibk5EL6v6v8Q/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;谷歌 Chromium 规模的项目在新硬件上的构建时间长达一小时，而在老硬件上的构建时间更是达到了六个小时。虽然也有海量的调整方案能加速构建速度，还有不少削减构建内容但极易出错的捷径供人选择，再加上数千美元的云计算能力，Chromium 的构建时间仍是接近十分钟。这点我完全无法接受，人们每天都是怎么干活的啊？&lt;/p&gt;&lt;p&gt;有人说 Rust 也是一样，构建时间同样令人头疼。但事实就是如此，还是这仅仅是一种反 Rust 的宣传手段？在构建时间方面 Rust 和 C++ 究竟谁能更胜一筹呢？&lt;/p&gt;&lt;p&gt;构建速度和运行时性能对我来说非常重要。构建测试的周期越短，我编程就越高效、越快乐。我会不遗余力地让我的软件速度更快，让我的客户也越快乐。因此，我决定亲自试试 Rust 的构建速度到底怎么样，计划如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;找一个 C++ 项目&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;把项目中的一部分单独拿出来&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;逐行将 C++ 代码重写为 Rust&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;优化 C++ 和 Rust 项目的构建&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对比两个项目的构建测试时间&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我的猜想如下（有理有据的猜测，但不是结论）：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Rust 的代码行数比 C++ 少。C++ 中多数函数和方法都需要声明两次：一次在 header 里，一次在实现文件里。但 Rust 不需要，因此代码行数会更少。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;C++ 的完整构建时间比 Rust 长（Rust 更胜一筹）。在每个.cpp 文件里，都需要重新编译一次 C++ 的 #include 功能和模板，虽然都是并行运行，但并行不等于完美。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Rust 的增量构建时间比 C++ 长（C++ 更胜一筹）。Rust 一个 crate（独立可编译单元）一编译，但 C++ 是按文件编译。因此代码每次变动，Rust 要读取的比 C++ 多。·&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;对此，大家怎么看呢？我在推特上的投票结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6866059817945384&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;769&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKPrsYAAXGXJLjssUGdQibGfTr1AX4LvFLVVEJPXhwaCjl8guxiauZF8gA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;42% 的人认为 C++ 会赢，35% 同意“看情况”，另外 17% 的则觉得 Rust 会让我们大吃一惊。&lt;/p&gt;&lt;p&gt;那么结果到底如何呢？下面让我们进入正题。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;编写 C++ 和 Rust 的测试对象&lt;/span&gt;
&lt;/section&gt;&lt;section&gt;
&lt;span&gt;找个项目&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;考虑到我未来一个月都要花在重写代码上，什么样的代码最合适？我认为得满足以下几点：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;很少或不用第三方依赖（标准库可以使用）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;能在 Linux 和 macOS 上运行（我不怎么管 Windows 上的构建时间）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大量测试套组（不然我没法确定 Rust 代码的正确性）；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;FFI（外部函数接口）、指针、标准或自定义容器、功能类和函数、I/O、并发、泛型、宏、SIMD（单指令多数据流）、继承等等，多少都有使用。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其实答案也很简单，直接找我前几年一直在做的项目就行。我用的是一个 JavaScript 词法分析器，quick-lint-js 项目。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDK3Cnaiaam5CqSlqogq5OSNdALbCjFnpQVK9MJl23bFM7lqgWhmmKopJg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;quick-lint-js 的吉祥物 Dusty&lt;/span&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;截取 C++ 代码&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;quick-lint-js 项目中 C++ 部分的代码行数超过 10 万，要把这些全改成 Rust 得花上我半年时间，不如只关注 JavaScript 词法分析部分，其中涉及项目中的：&lt;/p&gt;&lt;p&gt;可惜这部分代码里不涉及并发或 I/O，我测试不了 Rust 里 async/await 的编译时间开销，但这只是 quick-lint-js 项目里的一小部分，所以我还不用太担心。&lt;/p&gt;&lt;p&gt;我首先把所有的 C++ 代码都复制到新项目里，然后删掉已知与词法分析无关的部分，比如分析器和 LSP 服务器。我甚至一不小心删多了代码，最后不得不重新把这些代码添了回去。在我不断截代码的过程中，C++ 的测试一直保持了通过状态。&lt;/p&gt;&lt;p&gt;在彻底将 quick-lint-js 项目中涉及词法分析的部分全截出来之后，项目中 C++ 的代码大约有 1.7 万行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5375375375375375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKhrVjWMrBFTPx8KJejNkJCq61fsantbODgM6UD4Ryfibybwps2Pw4pNw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;重写代码&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;至于要怎么重写这上千行的 C++ 代码，我选择按部就班：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;找一个适合转换的模块；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;复制黏贴代码、测试、搜索替换并修改部分语法、继续运行 cargo（Rust 的构建系统和包管理器）测试直到构建测测试都通过；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果这个模块依赖另一个模块，那就找到被依赖的模块，继续进行第二步，然后再回到现在这个模块；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果还有模块没转换，再回到第一步。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;主要影响 Rust 和 C++ 构建时间的问题在于，C++ 的诊断系统是通过大量代码生成、宏、constexpr（常量表达式）实现的，而我在重写 Rust 版时，则用了代码生成、proc 宏、普通宏以及一点点 const 实现。传闻 proc 宏速度很慢，也有说是因为代码质量太差导致的 proc 宏速度慢。希望我写的 proc 宏还可以（祈祷～）。&lt;/p&gt;&lt;p&gt;我写完才发现，原来 Rust 项目比 C++ 项目还要大，Rust 代码 17.1k 行，而 C++ 只有 16.6k 行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5670103092783505&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKsibLXOlBSM3k2aAAoKWPIMJuk8T7hfpxQmpoXydT1SHdib3pcInuTang/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;优化 Rust 构建&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;构建时间很重要，因为我在截取 C++ 代码之前就已经做好了 C++ 项目构建时间的优化，所以我现在只需要对 Rust 项目的构建时间做同样的优化即可。以下是我觉得可能会优化 Rust 构建时间的条目：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;更快的链接器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Cranelift 后端&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;编译器和链接器标志&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;工作区与测试布局区分&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最小化依赖功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cargo-nextest&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 PGO 自定义工具链&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;更快的链接器&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;我第一步要做的是分析构建，我用的是 -Zself-profile rustc 标志。在这个标志所生成的两个文件里，其中一个文件中的 run_linker 阶段颇为突出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2536115569823435&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKTRgdMALqsCsr1GcbnXoiaobCzXStDngPnBhYXN33bUBZY8wRC0qmtnQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一轮 -Zself-profile 结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;之前我通过向 Mold 链接器的转换成功优化了 C++ 的构建时间，那这套对 Rust 能否行得通？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Linux：链接器性能几乎一致。&lt;/strong&gt;（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4454649827784156&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKnlmusl0m4dORuZ13bOP9tpV2B29XyHhf5DDAy4oQhHSaInPAcCZjPQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;可惜，Linux 上虽然确实有提升，但效果不明显。那 macOS 上的优化又表现如何？在 macOS 上默认链接器的替代品有两种，lld 和 zld，效果如下：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;macOS：链接器性能几乎不变&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.61742006615215&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKcnia8ozpZMzGhxSL0nM8WxDNzVufsNrEWianagLFDZibgXKlvkQalOWtw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;可以看出，macOS 上替换默认链接器的效果同样不明显，我怀疑这可能是因为 Linux 和 macOS 上的默认链接器对我的小项目而言已经做到了最好，这些优化后的链接器（Mold、lld、zld）在大型项目上效果非常好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;Cranelift 后端&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;让我们再回到 -Zself-profile 的另一篇报告上，LLVM_module_­codegen_emit_obj 和 LLVM_passes 阶段颇为突出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41029900332225916&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDK9MiapDyRYoK9vxJ8nV2vPCahPm3kjrSmZ8qUSfIiareb06FwWwtuxDhg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;-Zself-profile 的第二轮结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;传闻可以把 rustc 的后端从 LLVM 换成 Cranelift，于是我又用 rustc Cranelift 后端重新构建了一遍，-Zself-profile 结果看起来不错：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30716723549488056&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;586&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKpp6whabxGK1icpL4uTZzbL4bXPm7fibfVH8IAT4DlMrVjsB8OicRibZoWQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 Cranelife 的 -Zself-profile 第二轮结果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;可惜，在实际的构建中 Cranelife 比 LLVM 慢。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rust 后端：默认 LLVM 比 Cranelift 强&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46889400921658986&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKfxC5PZpOJJWKEYpvnILKibQRZDXks4nDxZg1JDia8SbySJy2ibjlh0IJg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;2023 年 1 月 7 日更新：rustc 的 Cranelift 后端维护者 bjorn3 帮我看了下为什么 Cranelift 在我的项目上效果不佳：可能是 rustup 的开销导致的。如果绕过这部分 Cranelife 效果可能会有提升，上图中的结果没有采用任何措施。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;编译器和链接器标志&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;编译器里有一堆可以加快（或减缓）构建速度的选项，让我们一一试过：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;-Zshare-generics=y (rustc) (Nightly only)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;-Clink-args=-Wl,-s (rustc)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;debug = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;debug-assertions = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;incremental = true 且 incremental = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;overflow-checks = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;panic = &#x27;abort&#x27; (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lib.doctest = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;lib.test = false (Cargo)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;rustc 标志：快速构建优于调试构建&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6462585034013606&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKDuxk1eodYhBYoNgvc3Eiasyr4ayic6AFbT399QD5lickyK3du7IOpY6cw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;注：图中的“quick, -Zshare-generics=y”与“quick, incremental=true”且启用“-Zshare-generics=y”标志相等同，其余柱状图没有标识“-Zshare-generics=y”是因为没有启用该标志，后者意味着需要 nightly rust 编译器。&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;上图中使用的多数选项都有文档可查，但我还没找到有人写过加 -s 的链接。子命令 -s 将包括 Rust 标准库静态链接在内的所有调试信息全部剥离，让链接器做更少的工作，从而减少链接时间。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;工作区与测试布局&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;在文件的物理位置问题上，Rust 和 Cargo 都提供了部分灵活性。对我的项目而言，以下是三种合理布局：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7480832420591457&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKOLQicpaQibfy1icMWDiaj05m5JSGU8crSKRo3icKyhDWSdyHDVogicY2ibosQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;理论上来说，如果我们把代码拆成多个 crate，cargo 就可以并行化 rustc 的调用。鉴于我的 Linux 机器上有一个 32 线程的 CPU，macOS 机器上有一个 10 线程的 CPU，并行化应该可以降低构建时间。&lt;/p&gt;&lt;p&gt;对一个 crate 而言，Rust 项目中的测试有很多可运行的地方：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;576&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKDrhuicN5t1dfwUibL570gW9zPPVrricbNGSyZtOYVxcYTpib76uwgEQF5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;由于依赖周期的存在，我没办法做“源码文件内的测试”这个布局的基准，但其他布局组合里我都做了基准：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rust 完整构建：工作区布局最快&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2512820512820513&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKgKGq9ECu6YgjDLW06dzvRdBPP2HtcoXdfW2VkDIHL3H4LdzffneBGg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Rust 增量构建：最佳布局不明&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4717314487632509&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKwKRWpaj2N52UqLtdmLBOvMUnh2ngzVkjRa3hFWnUxIdXdrWZgibkdlQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;工作区设置中，无论是分成多个可执行测试（many test exes），还是合并成一个可执行测试，似乎都能斩获头筹。所以后续我们还是按照“工作区 + 多个可执行文件”的配置吧。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;最小化依赖功能&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;多个 crate 的拆分支持可选功能，而部分可选功能都是默认启用的，具体功能可以通过 cargo tree 命令查看：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7420289855072464&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDK9lnEUh1O4yxhrBrd8wveBo6pPfXDkLdYVx5Vq1bg4ialD4Qh5rXKMBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;让我们把 crate 之一，libc 中的 std 功能关掉，测试后再看看构建时间有没有变化。&lt;/p&gt;&lt;p&gt;Cargo.toml&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; [&lt;span class=&quot;code-snippet__meta&quot;&gt;dependencies&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;+libc = { version = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0.2.138&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;-features = &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-libc = { version = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0.2.138&quot;&lt;/span&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关掉libc功能后没有任何变化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。（测试于Linux，数据越小越好）&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11130434782608696&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKz2RRdyuqrDoSpiaTAJvESDllu49sBosl6wElhYtmewjef6UjkyBiba8Q/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;构建时间没有任何变化，有可能 std 功能实际没什么大影响。不管怎么说，让我们进入下一个环节。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;cargo-nextest&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;作为一款据说“比 cargo 测试快 60%”的工具，cargo-nextest 对于我这个代码中 44% 都是测试的项目来说非常合适。让我们来对比下构建和测试时间：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Linux：cargo-nextest 减慢了测试速度&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5547785547785548&quot; data-w=&quot;858&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKibga0hEzhich3PX8eHCMUhuHNYfrP6hcmv3VSZzh39IMxia0orjX8ibQ0A/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;在我的 Linux 机器上，cargo-nextest 帮了倒忙，虽然输出不错，不过……&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 cargo-nextest 测试输出：&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.002s]&lt;/span&gt;        &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_locale&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;no_match&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.002s]&lt;/span&gt;     &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_offset_of&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;fields_have_different_offsets&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.002s]&lt;/span&gt;     &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_offset_of&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;matches_memoffset_for_primitive_fields&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.002s]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_padded_string&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;as_slice_excludes_padding_bytes&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.002s]&lt;/span&gt;     &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_offset_of&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;matches_memoffset_for_reference_fields&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PASS&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-attr&quot;&gt;[   0.004s]&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cpp_vs_rust&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;::test_linked_vector&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;push_seven&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;那 macOS 上怎么说？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;macOS：cargo-nextest 加快了构建测试&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.54609375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDK04QxUWILAniaBt5K60ia0HUl2m3XLbJSwJ5rYgJrIiaTHJWUPR1S8hPDQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在我的 MacBook pro 上，cargo-nextest 确实提高了构建测试的速度。但为什么 Linux 上没有呢？难道是和硬件有关？&lt;/p&gt;&lt;p&gt;在下面测试中，我会在 macOS 上使用 cargo-nextest，但 Linux 上的测试不用。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;使用 PGO 自定义工具链&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;我发现 C++ 编译器的构建如果用配置文件引导的优化（PGO，也称作 FDO），会有明显的性能提升。因此，让我们试试用 PGO 优化 Rust 工具链的同时，也用 LLVM BOLT 加上 -Ctarget-cpu=native 进一步优化 rustc。&lt;/p&gt;&lt;p&gt;Rust 工具链：自定义工具链是最快的。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3921875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKicuUEBQR2e1sWpUY0n3jnjX6WAXbZaMc01CjPic1DWWT6C9dHL3qJMZA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;如果你好奇的话，可以看看这段工具链构建脚本。可能不适用于你的机器，但只要我能运行就行：&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;https://github.com/quick-lint/cpp-vs-rust/blob/953429a4d92923ec030301e5b00face1c13bb92b/tools/build-toolchains.sh&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;与 C++ 编译器相比，通过 rustup 发布的 Rust 工具链似乎已经是优化完成的结果。PGO 加上 BOLT 的组合只带来了不到 10% 的性能提升。但有提升就是好的，所以在后续与 C++ 的竞争中我们会继续使用这个速度最快的工具链。&lt;/p&gt;&lt;p&gt;我第一次搭建的 Rust 自定义工具链比 Nightly 还要慢 2%，我在 Rust config.toml 的各种选项中反复调整，不断交叉检查 Rust 的 CI 构建脚本以及我自己的脚本，最终在好几天的挣扎后才让这二者性能持平。在我最终润色这篇文章时，我进行了 rustup 更新，拉取 git 项目，并重头又建了一遍工具链。结果这次我的自定义工具链速度更快了！有可能是我在 Rust 仓库里提交错了代码……&lt;/p&gt;&lt;section&gt;
&lt;span&gt;优化 C++ 构建&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;在最初的 C++ 项目 quick-lint-js 中，我已经用常见的手段优化了编译时间，比如用 PCH、禁用异常和 RTTI、调整编译标志、删除非必要 #include、将代码从头中移出、外置模板实例等方法。但此外还有一些 C++ 编译器和链接器我没试过，在我们进入 C++ 和 Rust 的对比之前，先从这些里面挑出最适合我们的。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Linux：自定义 Clang 是最快的工具链&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7486209613869188&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1269&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKlNAxsCBI0ibO33iab1aeOUHOicfBQfzzXufwNFntyPhEWQ417ohsoFyKA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;很明显，Linux 上的 GCC 是个特例，而 Clang 的表现则要好上很多。我自定义构建的 Clang（和 Rust 工具链一样，也是用 PGO 和 BOLT 构建的）相较于 Ubuntu 的 Clang，显著优化了构建时间，而 libstdc++ 的构建略快于平均 libc++ 的速度。&lt;/p&gt;&lt;p&gt;那我的自定义 Clang 加上 libstdc++ 在 C++ 和 Rust 的对比中表现如何呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;macOS：Xcode 是最快的工具链&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.88125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKxCU1JccicMbrBibkWhOU3nJWsze5qPxYISV1RT93iaIcsx6UphuVxAQxA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在 macOS 上，搭配 Xcode 的 Clang 工具链似乎要比 LLVM 网站上的 Clang 工具链优化得更好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;C++20 模块&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;我的 C++ 代码用的是 #include，但如果用 C++20 中新增加的 import 又会怎么样呢？C++20 的模块是不是理论上来说应该会让编译速度超级快？&lt;/p&gt;&lt;p&gt;我在项目了尝试过 C++20 模块，但直到 2023 年的 1 月 3 日，Linux 上的 CMake 模块支持过于实验性质了，我甚至连“hello world”都没跑起来。&lt;/p&gt;&lt;p&gt;或许 2023 年中 C++20 模块会大放异彩，对于我这种超级在意构建时间的人来说，真是这样就太好了。但目前为止，我还是继续用经典 C++ 的 #include 和 Rust 做对比吧。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;对比 C++ 和 Rust 的构建时间&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;通过把 C++ 项目改写成 Rust，并尽可能地优化 Rust 的构建时间后，问题来了：C++ 和 Rust 究竟谁更快呢？&lt;/p&gt;&lt;p&gt;很可惜，答案是“看情况”！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Linux：Rust 部分情况下构建速度超越 C++&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35859375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKdEJibcE0lzK8x78BkCfYclRIs0XiaFDmDTZduPXH1mmAX8CjvPKxKZKA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;在我的 Linux 机器上，部分情况下 Rust 的构建速度确实优于 C++，但也有速度持平或逊于 C++ 的情况。在增量 lex 的基准上，我们修改了大量源码，Clang 比 rustc 速度快，但在其他增量基准上，rustc 又会反超 Clang。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;macOS：C++ 构建速度通常快于 Rust&lt;/strong&gt;。（数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.371875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKw7g1ibtciaUZPBIatYV9PBs044T82Niamn62ibxCAjkln1oz5YkH0khHwQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;但我的 macOS 机器上情况却截然不同。C++ 的构建速度常常快上 Rust 许多。在增量测试 utf-8 的基准，我们修改中等数量测试文件，rustc 编译速度会略微超过 Clang，但在包括全量构建等其他基准上，Clang 很明显效果要更好。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;超过 17k 行代码&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;我基准测试的项目只有 17k 行代码，算是小型项目，那么对超过 10 万行代码的大型项目来说，又是什么情况呢？&lt;/p&gt;&lt;p&gt;我把最大的模块，也就是词法分析器的代码复制粘贴了 8、16 以及 24 遍，分别用来测试。因为我的基准里也包括了运行测试的时间，我觉得构建时间即使是对于那些能瞬间构建完的项目，也应该会线性增长。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44472361809045224&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;398&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKmGP9KaXgtLS2TIzR7BHCpfLHwcCPIFRpDB001ZX2E1t0VDgQOktTzg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;倍数扩大后 C++ 完整构建优于 Rust&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31015625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDKQia4vUvqOTSbTBnMBae2bbmuDe9TSj795NJM0gJ26wOLpib58awAnPcQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;倍数扩大后 C++ 增量构建优于 Rust&lt;/strong&gt;。（测试于 Linux，数据越小越好）&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.84765625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VNlhKiaIQ9LMTliaiaL3yyGWDK61F1P4gCJdrN2UIHwYjtzWaujvI5KmuRibAVsSORGY6qqh60KmRUQGg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;Rust 和 Clang 确实都是线性扩大，这点很好。&lt;/p&gt;&lt;p&gt;正如预期中一样，修改 C++ 的头文件，也就是增量 diag-type 会大幅影响构建时间。而由于 Mold 链接器的存在，其他增量基准中构建时间的扩展系数很低。&lt;/p&gt;&lt;p&gt;Rust 构建的扩展性让我很失望，即使只是增量 utf-8 测试的基准，无关文件的加入也不应该让它的构建时间如此受影响。测试所用的 crate 布局时“工作区且多个可执行测试”，因此 utf-8 测试应该能独立编译可执行文件。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;结   论&lt;/span&gt;
&lt;/section&gt;&lt;p&gt;编译时间对 Rust 而言算是问题吗？答案是肯定的。虽然也有一些可以加快编译速度的提示和技巧，但却没有效果非常显著的数量级改进，这让我在开发 Rust 时非常高兴。&lt;/p&gt;&lt;p&gt;Rust 的编译时间和 C++ 相比呢？确实也很糟。至少对我的编码风格来说，Rust 在大型项目上开发的编译时间甚至更加远比 C++ 还要糟糕。&lt;/p&gt;&lt;p&gt;再回过头看看我当初的假设，几乎全军覆没：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Rust 改写版代码行数比 C++ 多；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在全量构建上，C++ 相比 Rust 在 1.7 万行代码上构建时间相似，在 10 万行代码上构建时间要少；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在增量构建上，Rust 相比 C++ 在部分情况构建时间要短，在 1.7 万行上构建时间要长，在 10 万行代码上构建时间甚至更长。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我不爽吗？确实。在改写过程中，我不断学习着 Rust 相关的知识，比如 proc marco 能替代三个不同代码生成器，简化构建流水线，让新开发者们日子更好过。但我完全不想念头文件，以及 Rust 的工具类真的很好用，特别是 Cargo、rustup 以及 miri。&lt;/p&gt;&lt;p&gt;但我决定不把 quick-lint-js 项目中剩下的代码也改成 Rust，但如果 Rust 的构建时间能有明显优化，或许我会改变主意。当然，前提是我还没被 Zig 迷走心神。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>