<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0aaec14b3cf29e4d3d553c495f662dfb</guid>
<title>Linux 主机性能测试方法</title>
<link>https://toutiao.io/k/z0e7y3o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-linux tag-raspberry-pi no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;最近打算用躺家吃灰的树莓派4B搭一个NAS，用来快捷方便地访问和备份一些资源。由于备选的硬件（芯片、硬盘、网线、路由器等）和软件（内网穿透技术）的技术选型比较多，这时候就需要有一个能简单评估服务性能的方法。因此简单搜寻了一下常见方案，方便在技术选型时有个统一的对比标准，并且对一些常见指标能在数量级上有一些感性的理解。&lt;/p&gt;&lt;h2 id=&quot;%E7%A1%AC%E7%9B%98&quot;&gt;硬盘&lt;/h2&gt;&lt;p&gt;对于硬盘的读写速度测试，首先我们需要注意根据读写的实现细节不同，测试出的结果会有很大的差别。例如对于读来说，是否走缓存读、缓存的大小如何；对于写来说，是否只写缓存、是否同步等待刷盘、刷盘的时机如何，等等。&lt;/p&gt;&lt;p&gt;在实际测试的时候一定要明确自己使用的是哪种IO模式，否则就会得到一些似是而非的结论。&lt;/p&gt;&lt;h3 id=&quot;%E8%AE%BE%E5%A4%87%E6%9F%A5%E8%AF%A2&quot;&gt;设备查询&lt;/h3&gt;&lt;p&gt;在测试硬盘前，我们首先得知道我们有哪些硬盘、分别对应哪些分区。用 &lt;code&gt;lsblk&lt;/code&gt; （list block）命令可以查看当前机器下挂载的块设备：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ lsblk
NAME        MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda           8:0    1 29.3G  0 disk
└─sda1        8:1    1 29.3G  0 part /media/pi/5615-BDE2
mmcblk0     179:0    0 59.5G  0 disk
├─mmcblk0p1 179:1    0  256M  0 part /boot
└─mmcblk0p2 179:2    0 59.2G  0 part /&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，这里的 sda (SATA device a) 表示我外部插入的一个U盘；mmcblk0 (Multimedia card block 0) 表示树莓派自带的一张 SD 卡。这两个类型是 disk，也就是实体磁盘。&lt;/p&gt;&lt;p&gt;每个 disk 会被分成多个 partition，也就是这里的 sda1 和 mmcblk0p1、mmcblk0p2。每个 partition 又会 mount 到不同的文件夹下，用于在文件系统中进行访问。因此对于文件系统本身来说，我们只会关心到 partition 层面。&lt;/p&gt;&lt;p&gt;通过 &lt;code&gt;df&lt;/code&gt; 命令我们也能直接观察到所有分区的挂载情况：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ df -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/root        59G   11G   46G  19% /
devtmpfs        3.5G     0  3.5G   0% /dev
tmpfs           3.7G     0  3.7G   0% /dev/shm
tmpfs           3.7G   65M  3.6G   2% /run
tmpfs           5.0M  4.0K  5.0M   1% /run/lock
tmpfs           3.7G     0  3.7G   0% /sys/fs/cgroup
/dev/mmcblk0p1  253M   32M  221M  13% /boot
tmpfs           738M  4.0K  738M   1% /run/user/1000
/dev/sda1        30G   23M   30G   1% /media/pi/5615-BDE2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时，disk 和 partition 的详细信息也可以通过 &lt;code&gt;fdisk&lt;/code&gt; 命令查看：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo fdisk -l
Disk /dev/mmcblk0: 59.5 GiB, 63864569856 bytes, 124735488 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x140cee6b

Device         Boot  Start       End   Sectors  Size Id Type
/dev/mmcblk0p1        8192    532479    524288  256M  c W95 FAT32 (LBA)
/dev/mmcblk0p2      532480 124735487 124203008 59.2G 83 Linux


Disk /dev/sda: 29.3 GiB, 31457280000 bytes, 61440000 sectors
Disk model: ProductCode
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xf3203eea

Device     Boot Start      End  Sectors  Size Id Type
/dev/sda1        2048 61439999 61437952 29.3G  7 HPFS/NTFS/exFAT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总之，在这里我们只需要搞清楚我们想测试的磁盘和分区分别是哪个即可。&lt;/p&gt;&lt;h3 id=&quot;hdparm&quot;&gt;hdparm&lt;/h3&gt;&lt;p&gt;对于读性能测试，我们一般可以用 &lt;a href=&quot;https://sourceforge.net/projects/hdparm/&quot;&gt;hdparm&lt;/a&gt; 工具（hard disk parameter? hardware device parameter?）。Debian下直接 apt 安装即可：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install hdparm -y&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hdparm目前只支持磁盘读性能测试，提供了三种方式进行测试：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;直接读内存： &lt;code&gt;sudo hdparm -T [device]&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;带buffer读磁盘： &lt;code&gt;sudo hdparm -t [device]&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;不带buffer读磁盘: &lt;code&gt;sudo hdparm -t --direct [device]&lt;/code&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以我的 mmcblk0 设备为例，跑出来结果分别如下（当然，每次测试建议跑多次取平均值，这里偷个懒）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo hdparm -T /dev/mmcblk0

/dev/mmcblk0:
 Timing cached reads:   1840 MB in  2.00 seconds = 921.43 MB/sec
 
$ sudo hdparm -t /dev/mmcblk0

/dev/mmcblk0:
 Timing buffered disk reads: 130 MB in  3.04 seconds =  42.74 MB/sec
 
$ sudo hdparm -t --direct /dev/mmcblk0

/dev/mmcblk0:
 Timing O_DIRECT disk reads: 124 MB in  3.01 seconds =  41.17 MB/sec
 &lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然，走内存读是飞快，不过对于测试磁盘性能来说没有任何意义；不带buffer看起来比带buffer要慢一点点，差别不太大；考虑到现实场景中大多数都是带buffer的读，因此我们在比较时用带buffer读的结果来进行参考即可。&lt;/p&gt;&lt;h3 id=&quot;dd&quot;&gt;dd&lt;/h3&gt;&lt;p&gt;dd (data definition? data duplicator?) 是进行磁盘操作、文件生成之类的常用工具。在 gnu 的 coreutils 下，类 Unix 发行版几乎都自带。&lt;/p&gt;&lt;h4 id=&quot;%E5%86%99%E6%80%A7%E8%83%BD&quot;&gt;写性能&lt;/h4&gt;&lt;p&gt;一般我们会用 dd 来进行磁盘写性能测试，一般来说也有三种方式：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;直接写内存： &lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt;使用内存做缓存写完后一次性刷盘：&lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync&lt;/code&gt;。&lt;/li&gt;&lt;li&gt;使用内存做缓存，每写完一部分就刷一次盘：&lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test oflag=dsync&lt;/code&gt;。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;还是以我的 mmcblk0 设备为例（当前目录即挂载的 mmcblk0 设备），跑出来结果分别如下（当然，每次测试建议跑多次取平均值，这里还是偷个懒）：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dd bs=1M count=256 if=/dev/zero of=test
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 1.39574 s, 192 MB/s

$ dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 31.739 s, 8.5 MB/s

$ dd bs=1M count=256 if=/dev/zero of=test oflag=dsync
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 39.694 s, 6.8 MB/s

$ rm test&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可见写内存不sync的确还是快，不过还是没啥参考意义。考虑到实际情况下大部分程序都是采用 fdatasync 的模式来写，因此我们在比较时用这个数据即可。&lt;/p&gt;&lt;h4 id=&quot;%E8%AF%BB%E6%80%A7%E8%83%BD&quot;&gt;读性能&lt;/h4&gt;&lt;p&gt;当然，有人也会利用 dd 进行读性能测试，比如：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo dd bs=1M count=256 if=/dev/mmcblk0 of=/dev/null
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 6.03649 s, 44.5 MB/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来很美好，结果也和 hdparm 差不多。但是当你第二次再跑这个命令的时候，由于写缓存的存在，结果会快特别多：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo dd bs=1M count=256 if=/dev/mmcblk0 of=/dev/null
256+0 records in
256+0 records out
268435456 bytes (268 MB, 256 MiB) copied, 0.267236 s, 1.0 GB/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;显然这样的测试是没有意义的。考虑到这种测试方法甚至很难做到幂等，这里还是不建议用 dd 来测试读性能。&lt;/p&gt;&lt;h3 id=&quot;%E5%B0%8F%E7%BB%93&quot;&gt;小结&lt;/h3&gt;&lt;p&gt;对于磁盘读性能测试，建议使用 &lt;code&gt;sudo hdparm -t [device]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;对于磁盘写性能测试，建议使用 &lt;code&gt;dd bs=1M count=256 if=/dev/zero of=test conv=fdatasync&lt;/code&gt;。&lt;/p&gt;&lt;h2 id=&quot;%E7%BD%91%E7%BB%9C&quot;&gt;网络&lt;/h2&gt;&lt;p&gt;网速测试一般分两种，一种是测试当前设备对普通公网设备的读写速度；另一种是点对点测试两个服务器之间的速度。&lt;/p&gt;&lt;h3 id=&quot;speedtest&quot;&gt;speedtest&lt;/h3&gt;&lt;p&gt;speedtest 工具在各地都有测速服务器，通过命令行（speedtest-cli）或者网页（https://speedtest.cn，https://speedtest.net）都可以进行网速上下行的测试。这里以命令行为例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install speedtest-cli -y

$ speedtest-cli
Retrieving speedtest.net configuration...
Testing from China Mobile (183.192.82.69)...
Retrieving speedtest.net server list...
Selecting best server based on ping...
Hosted by Chinamobile-5G (Shanghai) [8.49 km]: 6.054 ms
Testing download speed................................................................................
Download: 128.24 Mbit/s
Testing upload speed......................................................................................................
Upload: 22.88 Mbit/s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然多次测试可能会访问到不同的测试点、导致结果有区别，不过其实也大差不差了。&lt;/p&gt;&lt;p&gt;在使用时偶尔会遇到返403，不要慌，多试几下一般就好了 。&lt;/p&gt;&lt;h3 id=&quot;iperf3&quot;&gt;iperf3&lt;/h3&gt;&lt;p&gt;如果我们并不是想测试公网网速，而是测试两个服务器之间点对点的网速。这时用 &lt;a href=&quot;https://iperf.fr/iperf-doc.php#doc&quot;&gt;iperf3&lt;/a&gt; 工具就好。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install iperf3 -y # Debian 下
$ brew install iperf3        # MacOS 下&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意，除了 iperf3 之外，还有一个 iperf。这两个版本分别由不同组织开发，前后也不兼容。虽然似乎 iperf3 有坑，不过似乎功能多一点，尤其是支持了下行带宽测试（iperf 只支持上行带宽测试），所以这里还是用 iperf3。&lt;/p&gt;&lt;p&gt;iperf3 是 C/S 架构，服务端开启 server ，客户端开启 client，然后互相通信进行测速。以我在家的树莓派和一个在 HK 的 Azure 主机为例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -s -p 5555                   # azure 主机上开启 server

$ iperf3 -c 104.208.65.181 -p 5555    # pi 上开启 client 并连接 server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，client 上会有报告：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -c 104.208.65.181 -p 5555
Connecting to host 104.208.65.181, port 5555
[  5] local 192.168.1.2 port 35994 connected to 104.208.65.181 port 5555
[ ID] Interval           Transfer     Bitrate         Retr  Cwnd
[  5]   0.00-1.00   sec  8.68 MBytes  72.8 Mbits/sec    0   2.95 MBytes
[  5]   1.00-2.00   sec  1.25 MBytes  10.5 Mbits/sec  2018    252 KBytes
[  5]   2.00-3.00   sec  2.50 MBytes  21.0 Mbits/sec  1076    286 KBytes
[  5]   3.00-4.00   sec  3.75 MBytes  31.5 Mbits/sec  861    237 KBytes
[  5]   4.00-5.00   sec  2.50 MBytes  21.0 Mbits/sec   99    187 KBytes
[  5]   5.00-6.00   sec  1.25 MBytes  10.5 Mbits/sec    0    206 KBytes
[  5]   6.00-7.00   sec  2.50 MBytes  21.0 Mbits/sec    0    215 KBytes
[  5]   7.00-8.00   sec  2.50 MBytes  21.0 Mbits/sec    0    218 KBytes
[  5]   8.00-9.00   sec  2.50 MBytes  21.0 Mbits/sec    0    218 KBytes
[  5]   9.00-10.00  sec  2.50 MBytes  21.0 Mbits/sec    0    220 KBytes
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.00  sec  29.9 MBytes  25.1 Mbits/sec  4054             sender
[  5]   0.00-10.09  sec  26.5 MBytes  22.1 Mbits/sec                  receiver

iperf Done.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看出 client 对 server 的上行带宽大约是 22Mbit/sec。&lt;/p&gt;&lt;p&gt;类似的，server配置不变，client加上 -R 参数后可以测试出 server 对 client 的下行带宽：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ iperf3 -c 104.208.65.181 -p 5555 -R
Connecting to host 104.208.65.181, port 5555
Reverse mode, remote host 104.208.65.181 is sending
[  5] local 192.168.1.2 port 36000 connected to 104.208.65.181 port 5555
[ ID] Interval           Transfer     Bitrate
[  5]   0.00-1.00   sec  6.47 MBytes  54.3 Mbits/sec
[  5]   1.00-2.00   sec  25.7 MBytes   216 Mbits/sec
[  5]   2.00-3.00   sec  13.2 MBytes   111 Mbits/sec
[  5]   3.00-4.00   sec  16.3 MBytes   137 Mbits/sec
[  5]   4.00-5.00   sec  12.4 MBytes   104 Mbits/sec
[  5]   5.00-6.00   sec  14.4 MBytes   121 Mbits/sec
[  5]   6.00-7.00   sec  14.0 MBytes   117 Mbits/sec
[  5]   7.00-8.00   sec  13.9 MBytes   116 Mbits/sec
[  5]   8.00-9.00   sec  11.5 MBytes  96.7 Mbits/sec
[  5]   9.00-10.00  sec  11.3 MBytes  95.2 Mbits/sec
- - - - - - - - - - - - - - - - - - - - - - - - -
[ ID] Interval           Transfer     Bitrate         Retr
[  5]   0.00-10.09  sec   142 MBytes   118 Mbits/sec  2560             sender
[  5]   0.00-10.00  sec   139 MBytes   117 Mbits/sec                  receiver

iperf Done.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里可以看出 server 对 client 的下行带宽大约是 117Mbit/sec。&lt;/p&gt;&lt;h2 id=&quot;cpu%E5%86%85%E5%AD%98&quot;&gt;CPU&amp;amp;内存&lt;/h2&gt;&lt;h3 id=&quot;sysbench&quot;&gt;sysbench&lt;/h3&gt;&lt;p&gt;对于CPU和内存的性能测试，可以使用 &lt;a href=&quot;https://github.com/akopytov/sysbench&quot;&gt;sysbench&lt;/a&gt; 工具。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo apt install sysbench -y # Debian 下
$ brew install sysbench        # MacOS 下&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于我的树莓派测试如下：&lt;/p&gt;&lt;p&gt;CPU单线程测试，可以看出单核每秒操作数大约1483：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sysbench cpu --threads=1 run
sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Prime numbers limit: 10000

Initializing worker threads...

Threads started!

CPU speed:
    events per second:  1483.17

General statistics:
    total time:                          10.0002s
    total number of events:              14839

Latency (ms):
         min:                                    0.67
         avg:                                    0.67
         max:                                    1.88
         95th percentile:                        0.68
         sum:                                 9992.91

Threads fairness:
    events (avg/stddev):           14839.0000/0.00
    execution time (avg/stddev):   9.9929/0.00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内存读写测试，可以看出读写速度约是 1814MiB 每秒：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sysbench memory run
sysbench 1.0.18 (using system LuaJIT 2.1.0-beta3)

Running the test with following options:
Number of threads: 1
Initializing random number generator from current time


Running memory speed test with the following options:
  block size: 1KiB
  total size: 102400MiB
  operation: write
  scope: global

Initializing worker threads...

Threads started!

Total operations: 18590983 (1858174.07 per second)

18155.26 MiB transferred (1814.62 MiB/sec)


General statistics:
    total time:                          10.0001s
    total number of events:              18590983

Latency (ms):
         min:                                    0.00
         avg:                                    0.00
         max:                                    0.20
         95th percentile:                        0.00
         sum:                                 4463.57

Threads fairness:
    events (avg/stddev):           18590983.0000/0.00
    execution time (avg/stddev):   4.4636/0.00
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，对 MacOS 的 CPU benchmark 似乎有坑，测试出来的结果异常的大，不具有参考价值。&lt;/p&gt;&lt;h3 id=&quot;md5sum&quot;&gt;md5sum&lt;/h3&gt;&lt;p&gt;虽然 sysbench 的基准测试看起来比较靠谱，但是实际环境下，真正的执行效率还跟执行的指令啥的都有挺大关系。比如，我们以执行 md5 的速度来对比 CPU 的执行效率：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ dd if=/dev/zero bs=1M count=1024 | md5sum
1024+0 records in
1024+0 records out
1073741824 bytes (1.1 GB, 1.0 GiB) copied, 5.81996 s, 184 MB/s
cd573cfaace07e7949bc0c46028904ff  -&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过 &lt;code&gt;dd&lt;/code&gt; 命令向 &lt;code&gt;md5sum&lt;/code&gt; 持续发送 1GB 的数据进行计算，计算的速度也可以看成是 CPU 单核性能的一种指标。（考虑到管道操作是单线程，这个指令其实也只能用到一个核）&lt;/p&gt;&lt;p&gt;然后，如果我们多找几个 CPU 进行以下对比，我们就会发现一些神奇的现象：&lt;/p&gt;&lt;h4 id=&quot;cortex-a72%EF%BC%88arm%EF%BC%89&quot;&gt;Cortex-A72（ARM）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：1479.99 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：184 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;neoverse-n1%EF%BC%88arm%EF%BC%89&quot;&gt;Neoverse-N1（ARM）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：3497.70 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：424 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-platinum-8171m-cpu-260ghz%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) Platinum 8171M CPU @ 2.60GHz（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：820.19 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：409 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-cpu-e5-26xx-v4%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) CPU E5-26xx v4（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：927.74 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：459 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;intelr-xeonr-platinum-8255c-cpu-250ghz%EF%BC%88x8664%EF%BC%89&quot;&gt;Intel(R) Xeon(R) Platinum 8255C CPU @ 2.50GHz（x86_64）&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;sysbench 单线程：1054.30 event/s&lt;/li&gt;&lt;li&gt;dd + md5sum：515 MB/s&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可以发现 ARM 架构的机器在 sysbench 上表现几乎都比 X86_64 的机器好很多，但是实际跑 md5sum 却相差不大甚至差不少。&lt;/p&gt;&lt;p&gt;可见不同架构间二者的指标并不完全正相关；不过相同架构间二者的指标还是基本正相关的。&lt;/p&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://romanrm.net/dd-benchmark&quot;&gt;dd-benchmark&lt;/a&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man8/hdparm.8.html&quot;&gt; &lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man8/hdparm.8.html&quot;&gt;man-hdparm&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://iperf.fr/iperf-doc.php#doc&quot;&gt;iperf&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>baf3b3d298b5c2e9fe845ea3dccab33f</guid>
<title>Spring 事务的这 10 种坑使得事务失效了</title>
<link>https://toutiao.io/k/c5l12vd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;92275&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。在某些业务场景下，如果同时有多张表的写入操作，为了保证操作的原子性（要么同时成功，要么同时失败）避免数据不一致的情况，我们一般都会使用spring事务。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;没错，spring事务大多数情况下，可以满足我们的业务需求。但是今天我要告诉大家的是，它有很多坑，稍不注意事务就会失效。&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;不信，我们一起看看。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;1.错误的访问权限&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法的访问权限被定义成了private，这样会导致事务失效，spring要求被代理方法必须是public的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AbstractFallbackTransactionAttributeSource类的computeTransactionAttribute方法中有个判断，如果目标方法不是public，则TransactionAttribute返回null，即不支持事务。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute computeTransactionAttribute(Method method, @Nullable &lt;span&gt;&lt;span&gt;Class&lt;/span&gt;&amp;lt;?&amp;gt; &lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// The method may be on an interface, but we need attributes from the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// If the target class is null, the method will be unchanged.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// First try is the method in the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;// Second try is the transaction attribute on the target class.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;if&lt;/span&gt; (specificMethod != method) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// Fallback is to look at the original method.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      txAttr = findTransactionAttribute(method);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// Last fallback is the class of the original method.&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      txAttr = findTransactionAttribute(method.getDeclaringClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.方法被定义成final的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法被定义成了final的，这样会导致spring aop生成的代理对象不能复写该方法，而让事务失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;3.方法内部调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        updateStatus(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateStatus&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;// doSameThing();&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;4.当前实体没有被spring管理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;//@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以看到UserService类没有定义@Service注解，即没有交给spring管理bean实例，所以它的add方法也不会生成事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;5.错误的spring事务传播特性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NEVER)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。只有这三种传播特性才会创建新事务：PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW，PROPAGATION_NESTED。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;6.数据库不支持事务&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;msql8以前的版本数据库引擎是支持myslam和innerdb的。我以前也用过，对应查多写少的单表操作，可能会把表的数据库引擎定义成myslam，这样可以提升查询效率。但是，要千万记得一件事情，myslam只支持表锁，并且不支持事务。所以，对这类表的写入操作事务会失效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;7.自己吞掉了异常&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种情况下事务不会回滚，因为开发者自己捕获了异常，又没有抛出。事务的AOP无法捕获异常，导致即使出现了异常，事务也不会回滚。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;8.抛出的异常不正确&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) throws Exception {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt;(e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种情况下，开发人员自己捕获了异常，又抛出了异常：Exception，事务也不会回滚。因为spring事务，默认情况下只会回滚RuntimeException（运行时异常）和Error（错误），不会回滚Exception。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;9.多线程调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            roleService.doOtherThing();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }).start();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的，这样会导致两个事务方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final ThreadLocal&amp;lt;Map&amp;lt;&lt;span&gt;Object&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&amp;gt;&amp;gt; resources =&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;10.嵌套事务多回滚了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        userMapper.insertUser(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        roleService.doOtherThing();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NESTED)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;why?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;怎么样才能只回滚保存点呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf4j&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class UserService {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private UserMapper userMapper;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    private RoleService roleService;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    public void add(UserModel userModel) throws Exception {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;userMapper&lt;/span&gt;&lt;span&gt;.insertUser&lt;/span&gt;(userModel);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;roleService&lt;/span&gt;&lt;span&gt;.doOtherThing&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;log&lt;/span&gt;&lt;span&gt;.error&lt;/span&gt;(e.getMessage(), e);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在代码中手动把内部嵌套事务放在try/catch中，并且不继续往抛异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;介绍到这里，你会发现spring事务的坑还是挺多的~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;来源：苏三说技术&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;链接：https://juejin.cn/post/6863796940069568520&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edde4724c4d4e9762ce0d3515a394cc5</guid>
<title>用 Charles 断点调试 HTTPS 请求，原理揭秘</title>
<link>https://toutiao.io/k/hnbu55g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的网站基本都是 https 的，而 charles 是常用的 http 抓包工具，所以用 charles 调试 https 请求是常见的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天就分享下如何用 charles 调试 https 请求，如何打断点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装 charles，点击 start recording：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31950207468879666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JxXywNZ7nbTYk2ibzkXOdPJiat1CSGawdGPQAWr2QSkXRiaOXhTqbd836A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器访问一些页面，这时候左侧就会展示出抓到的 http/https 请求：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6199701937406855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JER0xZ22YzWia4DJYt36zAOUNkhhxLGoITBt1Po7qTBESOnhH7VcTyTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这时候抓到的是加密过后的内容，这是 https 的机制导致的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34175334323922735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J7yLeKvKzZTHzLPbTOw6FsY6PjdKWVlWqbbucR4rQCT7T21jW5gTGmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端会下发被 CA 认证过的证书，里面包含了公钥，而服务器自己保留私钥，通过这种机制完成对称密钥的传输和身份的认证，之后加密传输数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间人拿到的数据自然都是被加密过的，也就是上图的那些乱码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37830319888734354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JZ5ic56kK1ibbcp8OZZIXTp2rCJfyZR0xdb6WfehiangakDTdziamXgQbnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那抓包工具怎么能拿到明文的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自己用服务端的证书和服务端对接不就行了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24619289340101522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Jj4Q3dwPGUq5nn9dMPhZFfqLTWZoic7vShfNXGvdGeT4hFfRvVITPhYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Charles 自己用服务端的证书来和服务端通信，然后给浏览器一个自己的证书，这样就能解密传输的内容，拿到明文数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 Proxy 的 SSL Proxy Setting：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7525773195876289&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JnLh1oZhPalibFgtk6VLSDzgA3iaAqhMicJRcdOwKM8u5XBGlQVbEnSK5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加一条对 juejin 的 https 代理：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8082901554404145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Jj8nAiaeldzJuHib1QGL6RJDH70ibicjn5hvicYG79tfZwuzDyRhlsm1TKMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 juejin 之前的证书：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6383442265795207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JoibRMYepyoRbyHwF59B3HOlh3iccqTGJNLhGJqlk9VyWrY2UVT5LEtzg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1836&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理之后就换成了 Charles 的证书，但是会提示不安全：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6749760306807286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7Ja089OYYrthv1DHzibobb0APccNMtqpQfLhPC2Skgo8m7TOY53L6tUhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2086&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5479009687836384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J6emLXtspicPgAWNib3OlnpKOfgxzWFnHKiaOicF0om8iciazG7NyKqs0J1Pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1858&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为系统有一个存放所有根证书的地方，要那里存在并且被信任的证书才是安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 help &amp;gt; SSL Proxying &amp;gt; Install Charles Root Certificate，安装到系统的钥匙串中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40544871794871795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JNDialia8g3HMMuddvmYzq5B1Pmwp8FFt6TEIjudOPoVPkooAvcseXsNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1248&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改为始终信任：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0803858520900322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JWviaIab5CEkAjqmX4Kd5lWOIib36IiaicnJqbyWgmjvNudhUfmXnVRAib0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候浏览器里就会标记安全了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43333333333333335&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JStw9cFCYwxWhJgvLn7R7hE0vSAZ0pcmibibrjHttS8G9Zhnia7mL7fSpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1860&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且在 charles 里就会看到明文的 http 请求和响应内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8584779706275033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JnEetIJiavgrVJZzJczMFovxG90Lbx4VibvHN0oMXALysibs9SFXFx3VjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程的原理就是这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24619289340101522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JibeRtscaHrn6dtsJSSLsw5kRHYG9I0L2f2GtcibSicXaGAmic6AhCYfXVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在能够抓 https 包了，但是还不够，现在只能看，很多情况下我们是希望能修改一下请求和响应内容的，这时候就要用断点功能了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键请求，勾选 breakpoints：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.260180995475113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JT5DVkKKXFcRf5OaibfhPsH4NGQSLw3pljibDVpS61ljicpmVpPwZltJhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后开启断点：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3169877408056042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JiaMNzsSDNOMYZhpZd5FaibNEg7zj6ExHvwV2fEZTSnQibiaEOicPNiaQnVKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刷新页面你会发现它断住了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6733333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JFWTXwibgfA6S16wov5vBbhz2aLf138wfjeMsOWFFHYD98bHN9vF61Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面三个按钮分别是取消、终止、执行修改后的请求的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面可以改 url，添加 header，还可以改请求内容和 cookie：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7567567567567568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JTqsORTXqrjibicrD0qN2AaDsZHYKlZVxricRAs1Ut4mibKQUnNqaPRX6pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 execute 之后就会发送请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后响应的时候还会断住，这时候就可以用同样的方式修改响应了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7451487710219923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JsCE8NjnVLiciczLFeOh3NjQgkica10qmB7qn8XxjEH25qmoOibZJ3MFPfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我把 title 修改了一下，点击 execute 之后，看到的网页就是修改过后的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6155988857938719&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JbqCbRGBAeENX3lAg0B6LZd56958qWCeY3GU56mS0Zmb4FkKh5icNR8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就可以断点调试 https 请求了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么可以实现断点功能呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个很容易想明白，怎么请求、怎么响应都是 Charles 控制的，那想实现一个断点和编辑的功能，岂不是很容易么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学可能会问，移动端怎么调试呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实是一样的，只不过移动端也要把 Charles 证书安装到自己的系统中，需要点击安装 charles 证书到移动设备：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3909313725490196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JYBib58sp9zfickKX5IeYsuNDKOAfdgY54UosWIicfo55olSlFaRdPnFOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他会提示你在手机设置代理服务器，然后下载 Charles 证书：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1206896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7J8AGeA8RV6juqyWMlfGibOdq7iapP69GYLibNz186I54PhXzv3OPYKTGRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理和我们在 PC 端下载 Charles 证书是一样的，后续流程也一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此以外，chrome 还有一个浏览器插件可以更细粒度的控制代理，叫做 SwitchyOmega：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8913934426229508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JwibnHjeun0zlTRsaSbzLFhk1nWOQgs9klH1iarulka6eDUPLA2vYlwyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以配置若干个代理服务器，比如 charles 的代理服务器：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3214936247723133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JAcFWgia64CmMdz4OUrOS7nRpXvgGnr5z6teLicIxmkwtLgEq7tCglY5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可以在 Charles 的 Proxy &amp;gt; Proxy Setting 里配置：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8825561312607945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JPdAxpcWGZoqhdnI8bFuiaibuTRg9IhoIO7M9eKWuZzRzyD7rVSDYBJDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就可以配置什么 url 用什么代理，或者不用代理直接连接：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33678756476683935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGj1wLqXZRgsrcnMHjegMa7JqPe7pvI9A5mCsht1ba5P891OqK7ypJF3c6KP9dGDU69zyIj7wYfx1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2316&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你有多个代理服务器，或者想控制有的页面走代理有的不走的时候，就可以用这个插件来控制了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 Charles 调试 https 请求是常见的需求，它需要安装 Charles 的证书到本地系统，然后信任，之后就可以抓到明文数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理就是 Charles 会使用服务器的证书来和服务器通信，然后发一个自己的证书给浏览器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Charles 还有断点调试功能，可以修改请求和响应的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;移动端 https 调试也是同样的原理，只不过需要配置下代理和证书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想切换代理服务器或者设置有的页面不走代理，可以用 Chrome 插件 SwitchyOmega 来控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会断点调试 https 请求还是很有意义的，比如改改 header、改改 body，看看会有啥效果，使用场景有很多。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7a96e940245270912c9ae5195aa767c3</guid>
<title>关于AspectJ，你知道多少？</title>
<link>https://toutiao.io/k/e7r4jd1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自从学习spring起，&lt;code&gt;AOP&lt;/code&gt;这个词几乎是天天挂在嘴边，好像一切都是天经地义的。尤其在springboot里面，经常见到的&lt;code&gt;@Before&lt;/code&gt; &lt;code&gt;@After&lt;/code&gt;等之类的内容，一般更是没有多少解释，通常被告知&quot;这是aop的用法&quot;。能有人特别说明一下下面这点信息就算不错的了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Before&lt;/code&gt; &lt;code&gt;@After&lt;/code&gt;等这些的实现，底层是 &lt;code&gt;aspectj&lt;/code&gt; 。官网地址：aspectJ官网&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;aspectj&lt;/code&gt;并不天然是&lt;code&gt;spring framework&lt;/code&gt;的一部分，人家本是一个独立项目，以优秀的方式实现了aop；还有一些其他的aop实现，如&lt;code&gt;Jboss Aop&lt;/code&gt;什么的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;spring framework&lt;/code&gt;有自己的aop实现，但难用，麻烦；后来spring官方索性将 优秀的&lt;code&gt;aspectj&lt;/code&gt; 集成到了&lt;code&gt;spring framework&lt;/code&gt;源码中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从此以后就成了现在我们看到的&lt;code&gt;spring framework&lt;/code&gt;的aop似乎天然就是&lt;code&gt;aspectj&lt;/code&gt;的样子。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我总觉得不对劲，距离透彻的理解，似乎总差着一段距离。于是今天势必追查清楚，求个究竟。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;引出具体问题&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，明确一个基本事实，就是 ：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;aspectj&lt;/code&gt;并不天然是&lt;code&gt;spring framework&lt;/code&gt;的一部分，它本是一个独立项目，它以自己的方式实现了aop；&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们就不仅仅是一定要把它用在spring项目中；比如我想把它用在我的一个简单的控制台项目中，该怎么做呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然地，网上的文章一大抄，基本上一搜都是教你什么是 pointcut，什么是 joinpoint等等，然后如何用在&lt;code&gt;springboot&lt;/code&gt;项目中。这个太简单，太程式化，已经麻木了，不值一提。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现步骤&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过一些搜索、尝试，起初我的项目并没有如预期一样执行，输出的指定的 before after之类的内容。经过更多的搜索和思考，想明白了原理之后，一切都变得水到渠成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，在外网搜到一个有用的文章，给了我很多启发。How to create a Hello World with IntelliJ and Aspect J里面的步骤也挺详细的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;正式进入实现步骤&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 安装编译器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要正常使用aspectj将自己写好的pointcut等内容织入到对应的class文件，这是一个类似于编译的过程。就像编译C语言需要gcc编译器，编译java需要javac编译器一样(当然也可能是别的编译器)。我们需要下载&lt;code&gt;aspectj&lt;/code&gt;，并安装在我们的电脑中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载和安装步骤依次如下图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下载地址:https://www.eclipse.org/aspectj/downloads.php&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4661582459485224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QwEovU8rw8bOqicsKrg9Fsu1icRiceVyVpJujJAQTXiaOtpFboetibn0dOfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1049&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6049382716049383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QOibibEl1O6iaXFicaibiaQI2LSyel8Zj4gnJbpu92Lh0YfMnrPtQYRYFib47g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3923076923076923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QD6D1gotNf8eriamR1B54ajvUvwPUJtibWAbH3D6KsKHKiakYiaxnCPcQFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;390&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QuZibtibvE3DjOp05HMzMLzwhIfib5lqibuDDvX8qlJHQZY3KjKX2YdMtzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QqEBedGkRol4SfMRGHgqX3hUz6yYGkX3U5S1J2aktmK4LsyPoEU1icxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QiaUGgHKGKaKdhzwZ7RLbiaa7xQ1W1Bic1ARlpUZVuVAuuAOgD4ribO2tzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7236421725239617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QlngZZaIPMDhhaA7shKqkNCJcemKguRBFPc0wBgz9l11XM6Mt460l9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;截至此处，已经下载并安装了 aspectj到本地。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.配置环境变量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地，类似我们安装了jdk到本地，但cmd命令行里并不能直接使用&lt;code&gt;javac xxx.java&lt;/code&gt;命令，就是因为我们没有把&lt;code&gt;javac&lt;/code&gt;可执行文件配置到我们的&lt;code&gt;path&lt;/code&gt;环境变量里。&lt;br/&gt;这个aspect编译器也一样，同样需要配置环境变量。如下图：我只配置了&lt;code&gt;CLASSPATH&lt;/code&gt;，并且只把&lt;code&gt;C:\aspectj1.9\lib\aspectjrt.jar&lt;/code&gt;配置进去就最终成功了。&lt;img data-ratio=&quot;0.6382978723404256&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qiaq0PSv1k8DyrGw2zwDO1DBsadriaNL3mufMZUt9qNyLpA5p6D4gia5FQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 验证一下&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随便试了一下，&lt;code&gt;ajc xxx&lt;/code&gt;，别管它报错不报错，有反应就行。说明这个ajc编译器已经成功地配置并且可用了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.693089430894309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QMKpObMkNhfFzSlQ65fdhls56J2qIe3BaLoTTPNyQ1PHAIA7ES1TX6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;492&quot;/&gt;至此，系统级环境配置结束。开始设法将&lt;code&gt;aspectj&lt;/code&gt;用在常规项目中。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IDEA新建一个最简单的项目&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 新建一个空maven项目&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3529962546816479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QzOhpSzI6F21WjV4m571LvENaibib2Y2iaHxGrzJpt73LaNFwg4k6WLLmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 添加&lt;code&gt;aspectj&lt;/code&gt;依赖&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4955947136563877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qzdy2ZtADI0RvMSNZ5qWGN22co31cjSFdYbyNg9UHFO1hxtVAEfVbSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 随便写个mai方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24836601307189543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qgc30T49zCGUzG1QKpcNYjnzLMot3NbzgFBNcuAXCq0rFux19j75oHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;figcaption&gt;在这里插入图片描述&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.新增一个&lt;code&gt;AspectJ&lt;/code&gt;文件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21074380165289255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QYFGlGWr4TfG7pn9N8I7vKnlvmr7DqR5JHZcDANu6RJFhIAruf4dOUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;我猜测这里之所以能这么新增，是因为我的IDEA已经安装了aspectj插件。来看一下。&lt;img data-ratio=&quot;0.5073170731707317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QrULsF0LsO4qJXHMYoFOD6SeaiapOJO1FUoldngudyPyuXKbxw2ibPZ8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;应该是上图两个插件中的第一个，不去验证了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. &lt;code&gt;aspectj&lt;/code&gt;文件里添加&lt;code&gt;pointcut&lt;/code&gt;等内容&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就可以在其他网页里随便抄一段了。如&lt;img data-ratio=&quot;0.29054726368159206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QoMGIiaib3mMUAoMVeXq1zYWViaIhSbPxjvzOUs2f8KicTmd8jKF9mrG1Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;显然，这里我是试图在 main方法调用之前拦截到的。如果能拦截到，则控制台会输出绿色字的内容。下面直接启动一下main方法，看效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27419354838709675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qg9b3PG4mDhW0a9MJgsTLwRGXk5lOSricPiccx9KhoAamRBIEpY8siaWOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;然而并没有。不管你再怎么clean，clean install，rebuild，等等等等，都一样，不用再试了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开始思考和解决&lt;code&gt;aspectj&lt;/code&gt;为什么不生效&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码居然有了个&lt;code&gt;aspectj&lt;/code&gt;关键字，居然编译没报错，已经很让我惊讶了。难道jdk编译的时候认识它？或者是由于插件的原因，使它显示为蓝色？但编译为什么没报错呢？既然没报错那为什么又不生效呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过网上搜索查资料和思考，我悟了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原因其实也很简单，就是这段代码不应该由jdk来编译，因为jdk又不知道遇到aspect该怎么办；而应该由 &lt;code&gt;aspectj&lt;/code&gt;提供的编译功能来编译，也即&lt;code&gt;ajc&lt;/code&gt;。(但我也没弄明白为什么有aspect字，jdk编译却不报错)&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 下面开始给IDEA配置&lt;code&gt;ajc&lt;/code&gt;编译器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5913461538461539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Q0mSMJSAkb02WrsMGNibDVM4VzoDrSyl8tDrzLEGkG6dYdzzbgyBuCCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5379939209726444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QnqAdw6MAAiaiblO2K2HS2iazFR2cTP449PRXFlC8ZZQ9D15iaiaAuZsDImA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot;/&gt;&lt;img data-ratio=&quot;0.3282336578581363&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QQibrUPrkNRnJngjVucr0SyGELEAAl7q97tUWuwKO2MVwJc4kYnkO6sQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;719&quot;/&gt;给&lt;code&gt;Path to aspectjtools.jar&lt;/code&gt;配置路径，测试一下，如下图。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18115055079559364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4Qwmss3ocPkqVA2WZ3ngCcMhyXnZiak5eyKkthJwiaqkwBzFkKFiaLkos1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;817&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 此时让我们再编译一下项目&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果配置正确的话，现在我们就是用&lt;code&gt;ajc&lt;/code&gt;编译的了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 然后运行：&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5649779735682819&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QJrXCd84FbTzrKDiaOXuia8m7l1NE22OeMlAwjsOaFQb8FCOCsWzgqibtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;立竿见影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此完整演示成功。基本原理，总结起来就是&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;安装aspectj，也就有了aspectj编译器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目中配置编译器，使用ajc编译器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;项目中新增aspect文件，指定各种切点等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用ajc编译项目，生成符合预期的结果。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几行 的demo，地址如下：aspectj-demo.zip&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此文真的给你解惑了，或者起到了帮助，可考虑打赏。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;后记补充&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写完之后，我以为就完了，但是后来马上又发现了问题。就是在前面引入的两个maven依赖，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &amp;lt;dependencies&amp;gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;aspectjrt&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;1.8.7&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;1.8.7&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;br/&gt;    &amp;lt;/dependencies&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它为什么要是两个依赖呢？我偶然地发现，一个依赖也能正常执行。更奇怪的是，这两个依赖，只依赖任何一个就可以正常执行了。已经亲测@2021年8月23日23点04分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这里又引出了下一个问题&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;aspectjrt&lt;/code&gt;和&lt;code&gt;aspectjweaver&lt;/code&gt;是什么关系，各自有什么作用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在来看一下&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4088541666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HmXWpTc2vib0nbNAgdn2IPSiazUVPk9J4QNuFpbOPibVic6HNialOd9RZBQ2MVc3EEIPZ3ywTFbCUCWmvC0rTOSBjKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;由图可知，这是很明显的，&lt;code&gt;aspectjweaver&lt;/code&gt; 包含了&lt;code&gt;aspectjrt&lt;/code&gt;全部的内容。另外主要多出来的内容，以我的经验，我一眼就看出了重点：（以下是猜测，但我感觉是对的）
后者比前者多出的内容，主要是 &lt;code&gt;asm&lt;/code&gt; 和 &lt;code&gt;weaver&lt;/code&gt;。那么，&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;asm是什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ASM 是一个 Java 字节码操控框架。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class 文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM 从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;weaver是什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;weaver这个词，就是“织入”的意思啊，字面意思不解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，很明显，weaver + asm，实现了可以动态织入 pointcut等内容到字节码中去的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，下一步再可以得出推论。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推论&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;aspectjrt&lt;/code&gt; 功能单纯一些，应该是提供一个&lt;code&gt;编译过后的已经织入了pointcut等内容的java字节码的程序的运行环境&lt;/code&gt;。关键词：&lt;code&gt;rt&lt;/code&gt;，也就是 &lt;code&gt;runtime&lt;/code&gt;。这个概念我们已经比较熟悉了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;aspectjweaver&lt;/code&gt; 包含了&lt;code&gt;aspectjrt&lt;/code&gt;全部内容，另外多出了 &lt;code&gt;动态织入的能力&lt;/code&gt;，主要是&lt;code&gt;asm + weaver&lt;/code&gt;部分的代码。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的示例中，之所以需要配置ajc编译器，要编译之后才能正常执行，正是因为推论1的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而推论2
我猜测多出来的这部分能力，就是让java项目可以不用再专门指定ajc编译器，而是使用&lt;code&gt;asm + weaver&lt;/code&gt;可以对java代码进行动态编译和织入内容，这样的话直接使用通用的javac编译器就可以了。当然，还看得出来，也支持了注解的用法。顺便多说一句，&lt;strong&gt;这个情况我已经用代码验证了，符合猜想，大概是对的无疑了&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ps: spring项目应用三步曲:  &lt;code&gt;aspect&lt;/code&gt;(需要标记为@Component) --&amp;gt; &lt;code&gt;pointcut&lt;/code&gt; --&amp;gt; &lt;code&gt;advice&lt;/code&gt;看似不起眼，其实ps:这句话很精髓，懂的自然懂。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以&lt;/strong&gt;，项目里，想要使用aspectj注解的写法，需要引入 &lt;code&gt;aspectjweaver&lt;/code&gt; 而不是&lt;code&gt;aspectjrt&lt;/code&gt; ，比如&lt;code&gt;spring&lt;/code&gt;里的aop相关的用法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果愿意自己指定ajc编译器，则可只引入体积较小的&lt;code&gt;aspectjrt&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我忽然觉得自己理解得更通透了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>