<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ead64aee4295f11b07d15f5eaba76f34</guid>
<title>Redis高可用方案</title>
<link>https://toutiao.io/k/3hh68yl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;鉴于上一篇文章提出了，&lt;/span&gt;&lt;span&gt;Redis的性能瓶颈在于内存和网络IO上&lt;/span&gt;&lt;span&gt;，针对内存上的性能瓶颈，Redis总共采用了三种技术方案，分别是&lt;/span&gt;&lt;span&gt;增加内存&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;内存淘汰策略&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;集群&lt;/span&gt;&lt;span&gt;。集群不仅解决了&lt;/span&gt;&lt;span&gt;内存瓶颈&lt;/span&gt;&lt;span&gt;还是提供了&lt;/span&gt;&lt;span&gt;高可用&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;分布式&lt;/span&gt;&lt;span&gt;性能。Redis高可用方案从演变的过程大致分为三种，分别是&lt;/span&gt;&lt;span&gt;主从复制模式&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;哨兵模式&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;集群模式&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;众所周知，单机模式下，如果Redis服务器出现故障，内存中的数据将不复存在，而对应的客户端请求都将打到数据库服务器上，当访问量非常大的情况下，数据库服务器是会崩的。虽然Redis服务恢复了正常，可以通过RDB和AFO从磁盘中恢复数据，但是如果磁盘出现了故障，数据仍旧是不可用的，并且，在单机模式下，读写是不分离的，大量的请求也会出现IO性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果同一个&lt;span&gt;数据&lt;/span&gt;服务器部署到多台机器上，当一台机器宕机，只要有一个机器仍旧可用就不会影响正常使用。这也正是Redis最初想到的高可用性能方案之一主从复制模式。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、主从复制模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主从复制模式就是让一个服务器去复制另一个服务器。我们称被复制的服务器叫&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;，而对主服务器进行复制的服务器叫&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;106&quot; data-backw=&quot;380&quot; data-ratio=&quot;0.2789473684210526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uNBJjalgSkSHTYT93rsvSmwoYxxicN0fliciaWqksxvYL7FHTs9EgKqFXiaZ1NxmITWmkljtUTYH7SC6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Redis的复制功能分为两个部分：&lt;/span&gt;&lt;span&gt;同步&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;命令传播&lt;/span&gt;&lt;span&gt; 两个操作&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;当客户端向从服务器发送异步SLAVEOF命令，就意味着让从服务器复制一个主服务器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）&lt;/span&gt;&lt;span&gt;同步&lt;/span&gt;&lt;span&gt;，在&lt;/span&gt;&lt;span&gt;Redis2.8版本开始使用了&lt;/span&gt;&lt;span&gt;PSYNC&lt;/span&gt;&lt;span&gt;命令替代了2.8版本之前的&lt;/span&gt;&lt;span&gt;SYNC&lt;/span&gt;&lt;span&gt;命令，用来执行复制时的同步操作。PSYNC的命令具有&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;两种模式。而SYNC仅支持完整重同步。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2）&lt;/span&gt;&lt;span&gt;命令传播&lt;/span&gt;&lt;span&gt;，在执行同步完成之后，主从服务器两者的数据达到一致的状态，此时主服务器只需要将自己执行的写命令发送给从服务器，而从服务器只需要一直执行主服务器发来的写命令就可以保证主从服务器的一致性了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/span&gt;：&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;心跳检测&lt;/span&gt;&lt;/span&gt;，在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令&lt;/span&gt;&lt;span&gt;REPLCONF ACK 偏移量&lt;/span&gt;&lt;span&gt; 。主要有三个作用，分别是&lt;/span&gt;&lt;span&gt;检测网络连接状态、辅助实现min-slaves选项、检测命令丢失&lt;/span&gt;&lt;span&gt;。主要是为了保证数据能够安全同步到从服务器并且保证数据状态一致不丢失。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;：它适用于&lt;/span&gt;&lt;span&gt;初次&lt;/span&gt;&lt;span&gt;复制情况，主要是通过让主服务器&lt;/span&gt;&lt;span&gt;创建并发送RDB文件&lt;/span&gt;&lt;span&gt;，以及向从服务器发送保存&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;缓&lt;/span&gt;&lt;span&gt;冲区&lt;/span&gt;&lt;span&gt;里面的写命令来进行同步。&lt;/span&gt;&lt;span&gt;（缓&lt;/span&gt;&lt;span&gt;冲区，是因为在发送RDB的同时，有新的写命令过来，而不在RDB文件中的那一部分命令）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;部分重同步：&lt;/span&gt;&lt;span&gt;它适用于&lt;/span&gt;&lt;span&gt;断线后&lt;/span&gt;&lt;span&gt;的重复制情况，当服务器断线后重新连接了主服务器。如果条件允许，主服务器可以将主服务器&lt;/span&gt;&lt;span&gt;连接断开期间&lt;/span&gt;&lt;span&gt;所执行的写命令发送给从服务器。从服务器只需要接收并执行这些命令即可，就可以将数据库更新至主服务器当前所处的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;1、PSYNC和SY&lt;/span&gt;&lt;span&gt;NC&lt;/span&gt;&lt;span&gt;同步有什么区别呢？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;PSYNC和SYNC同步的区别主要在于，PSYNC支持部分重同步，而SYNC的每次同步都是由主服务器全量的创建并传递RDB文件给从服务器，非常占用网络资源和从服务器导入时的阻塞时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、部分重同步有什么特点呢？&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器和从服务器分别维护一个复制偏移量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记同步的进度，偏移量相同则完全同步，偏移量不相同则数据未处于一致状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器的复制&lt;span&gt;积&lt;/span&gt;压缓冲区&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）主服务器的复制&lt;span&gt;积&lt;/span&gt;压缓冲区里面会保存一部分最近传播的写命令，并且复制积压缓冲区会为队列中的每个字节记录相应的&lt;/span&gt;&lt;span&gt;复制偏移量&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）通过偏移量，可以得知从服务器所丢失的数据是否在积压缓冲区中，如果存在则进行&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;，如果不存在则进行&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;服务器的运行ID&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）从服务器初次复制主服务器数据时，主服务器会将自己的运行ID传递给从服务器，而从服务器会存储起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）如果从服务器断电后，重新连接上一个主服务器，它会将之前存储的运行ID传递过去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;span&gt;3）如果发送的运行ID和当前连接的服务器运行ID相同，则主服务器可以执行&lt;/span&gt;&lt;span&gt;部分重同步&lt;/span&gt;&lt;span&gt;操作。否则进行&lt;/span&gt;&lt;span&gt;完整重同步&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、主从模式的优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、哨兵模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵是实现Redis高可用的解决方案，它是由一个或多个哨兵实例组成的系统。它可以&lt;/span&gt;&lt;span&gt;监视&lt;/span&gt;&lt;span&gt;任意多个&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;以及属下的&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;。当主服务器进入下线状态，它将从下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器替代已下线的服务器继续处理命令请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;382&quot; data-backw=&quot;499&quot; data-ratio=&quot;0.7655310621242485&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z33JZWhn1uNxohrLo4cB3447SqeISI4j6PppQLCrVYBgn8tYaRzBGuxTnfAAhBmnHcaTKJaanvtPagvibmexMHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，哨兵的核心还是&lt;/span&gt;&lt;span&gt;主从复制模式&lt;/span&gt;&lt;span&gt;，只是在主服务器下线时多了一个监听的对象，并通过哨兵系统实现了竞选机制，从主服务器下属的从服务器中选择一个最优质的作为新的主服务器。&lt;/span&gt;&lt;span&gt;哨兵系统也是有多个哨兵实例组成的，所以哨兵本身也是会出现单点故障，哨兵实例之间也会相互监视。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、启动并初始化哨兵&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵其实就是一个运行在特殊模式下的redis服务器，和普通服务器不同的是，它不会加载RDB或AOF文件，因为哨兵的执行工作和普通服务器执行的工作不同，所以初始化的过程并不完全相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵状态中的masters字典结构中记录了所有被哨兵监视的主服务器的信息，字典的键是主服务器的名字，字典的值是被监视主服务器对应的实例结构，这个实例可以是&lt;/span&gt;&lt;span&gt;主服务器&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;从服务器&lt;/span&gt;&lt;span&gt;又或者是一个&lt;/span&gt;&lt;span&gt;哨兵&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、创建连向主服务器的网络连接&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;初始化哨兵之后，会创建连向被监视的主服务器的网络连接，哨兵将成为主服务器的客户端。哨兵会创建两个连向主服务器的异步网络连接。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;命令连接&lt;/span&gt;&lt;span&gt;，用于向主服务器发送命令，并接受命令回复&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;订阅连接&lt;/span&gt;&lt;span&gt;，用于订阅主服务器_sentinel_:hello频道&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这两个连接主要是为了防止不丢失&lt;span&gt;_sentinel_:hello频道信息，另一方面是用来和主服务器发送命令来进行通信，以及哨兵还必须向主服务器创建命令连接。哨兵需要和多个实例创建网络连接，所以哨兵使用的是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;异步连接&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、获取主服务器信息&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔10s向master和 slave发送info命令。作用是获&lt;/span&gt;&lt;span&gt;取当前数据库信息&lt;/span&gt;&lt;span&gt;，比如发现新增从节点时，会建立连接，并加入到监控列表中，当主从数据库的角色发生变化进行信息更新。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔2s向主数据里和从数据库的_sentinel_:hello频道发送自己的信息。作用是将自己的&lt;/span&gt;&lt;span&gt;监控数据和哨兵分享&lt;/span&gt;&lt;span&gt;。每个哨兵会订阅数据库的_sentinel:hello频道，当其他哨兵收到消息后，会判断该哨兵是不是新的哨兵，如果是则将其加入哨兵列表，并建立连接。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔1s向所有主从节点和所有哨兵节点发送ping命令，作用是&lt;/span&gt;&lt;span&gt;监控节点是否存活&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、主观下线和客观下线&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵节点发送ping命令时，当超过一定时间(down-after-millisecond)后，如果节点未回复，则哨兵认为&lt;/span&gt;&lt;span&gt;主观下线&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主观下线表示当前哨兵认为该节点已经下线，如果该节点为主数据库，哨兵会进一步判断是否需要进行故障切换，这时候就要发送命令询问其他哨兵节点是否认为该主节点是主观下线，当其他哨兵那里接收到了足够数量（quorum）的已下线判断之后，哨兵就会认为是&lt;/span&gt;&lt;span&gt;客观下线&lt;/span&gt;&lt;span&gt;，并对主服务器执行&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、故障转移操作&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选举领头哨兵&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选举从服务器优先级最高的服务器，优先级可以通过slave-priority配置&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;优先级相同，则通过复制偏移量越大优先级越高&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果以上条件都相同，则选出运行id最小的从数据库&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;选出从数据库后，哨兵通过slave no one命令升级为主服务器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;最后发送slaveof 命令将其他从节点的主数据库设置为新的主数据库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、哨兵优缺点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;始终只有一台主服务器处理请求，写操作受到单机的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;仍旧复用主从模式，所有从节点的数据都是全量的费内存。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主服务器故障，在选举的过程中，服务器会开启保护机制禁止写操作，影响客户端的正常使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、集群模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群是Redis提供的&lt;/span&gt;&lt;span&gt;分布式数据库&lt;/span&gt;&lt;span&gt;方案，相当于每台redis服务器上存储不同的数据，实现了&lt;/span&gt;&lt;span&gt;数据解耦&lt;/span&gt;&lt;span&gt;，同时解决了Redis容量有限的问题。集群通过分片来进行&lt;/span&gt;&lt;span&gt;数据共享&lt;/span&gt;&lt;span&gt;，采用&lt;/span&gt;&lt;span&gt;多主多从&lt;/span&gt;&lt;span&gt;模式，并提供&lt;/span&gt;&lt;span&gt;复制&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;功能。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;集群关键词&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;节点、槽指派、命令执行、重新分片、转向、故障转移、消息&lt;/span&gt;&lt;span&gt;等。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、节点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span&gt;就是一个运行在集群模式下的&lt;/span&gt;&lt;span&gt;Redis服务器&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;它会继续使用所有在单机模式中使用服务器组件&lt;/span&gt;&lt;span&gt;。比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件事件处理器处理命令请求和返回数据&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;时间事件处理器执行serverCron函数，而&lt;span&gt;serve&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;Cron函数会调用集群模式下的clusterCron函数。c&lt;span&gt;lusterCron&lt;/span&gt;&lt;span&gt;函数主要负责执行集群模式下给其他节点发送Gossip消息，检查节点是否断线，以及自动故障转移等&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;使用数据库保存键值对数据。RDB持久化以及AOF持久化。发布与订阅模式。复制模块等进行节点的复制工作，以及Lua脚本环境执行客户端输入的Lua脚本。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;节点会继续使用redisServer结构存储服务器状态，继续使用redisClient结构保存客户端状态，以及集群模式下的clusterNode结构存储集群模式下用到的数据以及节点的当前状态（节点的创建时间、名字、当前配置纪元、节点的Ip地址、端口号等等）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;：&lt;/span&gt;&lt;span&gt;节点和单机&lt;/span&gt;&lt;span&gt;服务器的&lt;/span&gt;&lt;span&gt;一个区别是，&lt;/span&gt;&lt;span&gt;&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;只能使用&lt;span data-mpa-emphasize-underline=&quot;t&quot;&gt;&lt;span&gt;0号数据库&lt;/span&gt;&lt;span data-mpa-emphasize-underline-bg-line=&quot;t&quot;/&gt;&lt;/span&gt;，而单机&lt;/span&gt;&lt;span&gt;服务器&lt;/span&gt;&lt;span&gt;没有这个限制。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2、槽指派&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群&lt;/span&gt;&lt;span&gt;通过&lt;/span&gt;&lt;span&gt;分片&lt;/span&gt;&lt;span&gt;的方式来&lt;/span&gt;&lt;span&gt;存储&lt;/span&gt;&lt;span&gt;数据库中的&lt;/span&gt;&lt;span&gt;键值对&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;集群的整个数据被分为16384个槽&lt;/span&gt;&lt;span&gt;。数据库中的每个键都属于16384个槽的其中一个。集群中的每个节点可以处理0个或最多16384个槽。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据库中的16384个&lt;/span&gt;&lt;span&gt;槽&lt;/span&gt;&lt;span&gt;都有&lt;/span&gt;&lt;span&gt;被节点处理&lt;/span&gt;&lt;span&gt;时，集群才处于&lt;/span&gt;&lt;span&gt;在线状态&lt;/span&gt;&lt;span&gt;，否则处于&lt;/span&gt;&lt;span&gt;下线状态&lt;/span&gt;&lt;span&gt;。将槽指派分配给节点的命令是：CLUSTER ADDSLOTS 槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个节点处理哪些槽也都记录在&lt;span&gt;clusterNode结构体中。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;槽指派主要是使用结构体中的slots（一个二进制位数组）存储。&lt;/span&gt;&lt;span&gt;当前节点不仅将槽指派存储在结构体中，它还通过消发送给其他节点告知它们我处理了哪些槽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，集群中的每个节点都会知道数据库中的16384个槽分别被指派给了集群中的哪些节点&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，数据库中的16384个槽都进行了指派之后，集群就处于&lt;/span&gt;&lt;span&gt;上线状态&lt;/span&gt;&lt;span&gt;，此时，客户端就可以向集群中的节点&lt;/span&gt;&lt;span&gt;发送数据命令&lt;/span&gt;&lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;3、命令执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;4、重新分片&amp;amp;转向&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redis集群的&lt;/span&gt;&lt;span&gt;重新分片&lt;/span&gt;&lt;span&gt;可以将某个节点（源节点）的槽指派给另一个节点（目标节点）。同时该槽的键值对也会移动到目标节点。重新分片可以在线操作，集群不需要下线，也不影响两个节点的正常工作。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重新分片是通过Redis集群管理软件redis-trib负责执行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASK错误&lt;/span&gt;&lt;span&gt;，如果在&lt;/span&gt;&lt;span&gt;重新分片的过程中遇到了键的命令请求，可能会触发ASK错误&lt;/span&gt;&lt;span&gt;。类似于MOVED错误，ASK错误也是会被隐藏的，并返回目标分片ip和端口号。而对于集群模式下的redis-cli接收到ASK错误，也不会打印错误，而是根据返回的ip+端口号直接转向。若想看到ASK错误，可以在单机模式的redis-cli客户端下访问。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASK错误和MOVED错误都会导致客户端转向，但是它们也是有区别的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;5、故障转移&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Redis集群中的节点分为主节点和从节点，主节点用于处理槽，而从节点则用于复制主节点。若主节点下线，则从从节点中选择优质节点替代已下线的主节点。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;集群中的每个节点都会定期向其他节点发送ping消息，用来检测对方是否在线。如果对方没有在规定的时间内返回pong，则发送ping的节点可以认为对方疑似下线。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;在一个集群里面，半数以上的负责处理槽的主节点都发现某个主节点都疑似下线，那么这个主节点将被标记为下线。将主节点标记为下线的其他主节点并向集群广播主节点下线的消息。所有收到消息的节点都会立即将那个主节点标记为已下线。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个从节点发现自己复制的主节点下线了，则进行&lt;/span&gt;&lt;span&gt;故障转移&lt;/span&gt;&lt;span&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;选举新的主节点（详细请查阅资料）&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;被选中的从节点会执行 slaveof on one 命令，成为新的主节点&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新的主节点会撤销所有对已下线主节点的槽指派，并将槽全部指向自己&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;新的主节点向集群广播一条pong消息，告知其他主节点和从节点，自己已成为新的主节点之一，并且接管了已下线的节点所负责的槽。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6、消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;集群中的各个节点通过发送和接收消息来进行通信。节点发送的消息主要有以下5种。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;MEET消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PING消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PONG消息&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;FAIL消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;PUBLISH消息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注意：一条消息由&lt;/span&gt;&lt;span&gt;消息头&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;消息正文&lt;/span&gt;&lt;span&gt;组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、拓展&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Codis代理：https://developer.aliyun.com/article/848655&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Twemproxy代理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、参考来源&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《Redis设计与实现》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/Seky_fei/article/details/107239765&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;578&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uNE2jbQicbpwrWbzt4yCuXsolw0UEM7wZRXB1Rl8vvAJzbNsaQc7llGM2RQmT0TEJD94GARMRFUQvQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.271585557299843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z33JZWhn1uOnC8YBW9UGogSXeaGKoIibSDV6rg2FnuL671lPX6ibOEBOcNuvPqxyhqxlWicyf8dcraK579G8FWzrg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>914885e75129aa209afd07d752333d9a</guid>
<title>2022 年了，我才开始学 TypeScript ，晚吗？（7.5k字总结）</title>
<link>https://toutiao.io/k/7ppg48s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25220458553791886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR7Ujrq3JOdFEjypcT9HbREvfiaNviclzzszmueEsq5NBmyPwLhkY0zgiaYLvonb8IjLMgNdZicolHZaw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;567&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实早在初学前端时，就有大致了解过 typescript ,但后面工作中基本 vue2 开发为主，所以真正能够接触到 typescript 的机会其实并不多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管在某些间歇性踌躇满志的时刻，我也会上X站搜索 &lt;code&gt;typescript最新教程&lt;/code&gt;，但都很难坚持过10节视频，又或者刷掘金的时候看到相关文章，我也会麻溜的点赞收藏一条龙，可是到现在也只是在我的收藏夹里吃灰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可能不是我太懒，只是这个世界诱惑太多，毕竟刷剧刷短视频它不香吗，学习，学个屁！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近刷掘金看着大伙的年中总结，不是跳槽涨薪了，就是完成了多少 flag。吓得我从床上一个激灵蹦起，低头看着自己日渐肥硕的肚子，仔细想想，这过去的大半年，除了完成日常的工作，我基本回家就开始躺平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再这么下去可不行，躺平的日子舒坦归舒坦但多少感到有点乏味，还是得给自己整点事情干。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拍拍自己的大肚皮，那就从现在开始，就把我那学了又相当于没学的 typescript ，重新整起来吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是 TypeScript&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;简而言之，TypeScript是JavaScript的超集，具有可选的类型并可以编译为纯JavaScript。从技术上讲TypeScript就是具有静态类型的 JavaScript 。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TypeScript优缺点&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增强代码的可维护性，尤其在大型项目的时候效果显著&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;友好地在编辑器里提示错误，编译阶段就能检查类型发现大部分错误&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持最新的JavaScript新特特性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;周边生态繁荣，vue3已全面支持 typescript&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;需要一定的学习成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;和一些插件库的兼容并不是特别完美，如以前在 vue2 项目里使用 typescript就并不是那么顺畅&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加前期开发的成本，毕竟你需要写更多的代码（但是便于后期的维护）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装环境&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装typescript&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们可以新建一个空文件夹，用来学习 ts，例如我在文件夹下新建了个 &lt;code&gt;helloworld.ts&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm install -g  typescript // 全局安装 ts&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不记得自己是否已经安装过 typescript 的，可以使用以下命令来验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tsc -v &lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现版本，则说明已经安装成功&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Version 4.6.3&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 tsconfig.json 配置文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;tsc --init&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令后我们就可以看到生成了一个 tsconfig.json 文件，里面有一些配置信息，我们暂时先按下不表&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们&lt;code&gt;helloworld.ts&lt;/code&gt;文件中,随便写点什么&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; s:&lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;彼时彼刻，恰如此时此刻&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(s);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台执行 &lt;code&gt;tsc helloworld.ts&lt;/code&gt; 命令，目录下生成了一个同名的 helloworld.js 文件，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;&quot;彼时彼刻，恰如此时此刻&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(s);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过tsc命令，发现我们的typescript代码被转换成了熟悉的js代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接着执行&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;node helloworld.js&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即可看到输出结果&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安装 ts-node&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么通过我们上面的一通操作，我们知道了运行tsc命令就可以编译生成一个js文件，但是如果每次改动我们都要手动去执行编译，然后再通过 node命令才能查看运行结果岂不是太麻烦了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 ts-node 正是来解决这个问题的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;npm i -g ts-node // 全局安装ts-node&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个插件，我们就可以直接运行.ts文件了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们试一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ts-node helloworld.ts&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们的打印结果已经输出&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续我们的示例都可以通过这个命令来进行验证&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就可以正式进入到 typescript 的学习之旅了&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TypeScript 基础类型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Boolean 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; flag: &lt;span&gt;boolean&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Number 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; count: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;String 类型&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; name: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Enum 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;枚举类型用于定义数值集合，使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。，如周一到周日，方位上下左右等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始值默认为 0 其余的成员会会按顺序自动增长 可以理解为数组下标&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; red: Color = Color.RED;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(red); &lt;span&gt;// 0&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED = &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pink: Color = Color.PINK;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(pink); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED = &lt;span&gt;&quot;红色&quot;&lt;/span&gt;,&lt;br/&gt;  PINK = &lt;span&gt;&quot;粉色&quot;&lt;/span&gt;,&lt;br/&gt;  BLUE = &lt;span&gt;&quot;蓝色&quot;&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; pink: Color = Color.PINK;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(pink); &lt;span&gt;// 粉色&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 const 关键字修饰的枚举，常量枚举与普通枚举的区别是，整个枚举会在编译阶段被删除 我们可以看下编译之后的效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; Color {&lt;br/&gt;  RED,&lt;br/&gt;  PINK,&lt;br/&gt;  BLUE,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; color: Color[] = [Color.RED, Color.PINK, Color.BLUE];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(color); &lt;span&gt;//[0, 1, 2]&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//编译之后的js如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; color = [&lt;span&gt;0&lt;/span&gt; &lt;span&gt;/* RED */&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; &lt;span&gt;/* PINK */&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; &lt;span&gt;/* BLUE */&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;// 可以看到我们的枚举并没有被编译成js代码 只是把color这个数组变量编译出来了&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Array 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对数组类型的定义有两种方式:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;const&lt;/span&gt; arr: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; arr2: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;元组（tuple）类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面数组类型的方式，只能定义出内部全为同种类型的数组。对于内部不同类型的数组可以使用元组类型来定义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元组（ Tuple ）表示一个已知数量和类型的数组,可以理解为他是一种特殊的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;const&lt;/span&gt; tuple: [&lt;span&gt;number&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是，元组类型只能表示一个已知元素数量和类型的数组，长度已指定，越界访问会提示错误。例如，一个数组中可能有多种类型，数量和类型都不确定，那就直接any[]。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;undefined和null&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下 null 和 undefined 是所有类型的子类型。也就是说你可以把 null 和 undefined 赋值给其他类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; a: &lt;span&gt;undefined&lt;/span&gt; = &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; b: &lt;span&gt;null&lt;/span&gt; = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&#x27;zhangmazi&#x27;&lt;/span&gt;;&lt;br/&gt;  str = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  str = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你在tsconfig.json指定了&quot;strictNullChecks&quot;:true ，即开启严格模式后， null 和 undefined 只能赋值给 void 和它们各自的类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 启用 --strictNullChecks&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;undefined&lt;/span&gt;;    &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;// 编译错误&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;any 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;any会跳过类型检查器对值的检查，任何值都可以赋值给any类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; value: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  value = &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = []; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = {};&lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;void 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;void 意思就是无效的, 一般只用在函数上，告诉别人这个函数没有返回值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(): &lt;span&gt;void&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;never 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;never 类型表示的是那些永不存在的值的类型。例如never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值会永不存在的两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1 如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值（因为抛出异常会直接中断程序运行，这使得程序运行不到返回值那一步，即具有不可达的终点，也就永不存在返回了）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2 函数中执行无限循环的代码（死循环），使得程序永远无法运行到函数返回值那一步，永不存在返回。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 异常&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;(&lt;span&gt;msg: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(msg); &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 死循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loopForever&lt;/span&gt;(): &lt;span&gt;never&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {};&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Unknown 类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unknown与any一样，所有类型都可以分配给unknown:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; value: unknown = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  value = &lt;span&gt;&quot;zhangmazi&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  value = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unknown与any的最大区别是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;任何类型的值可以赋值给any，同时any类型的值也可以赋值给任何类型。unknown 任何类型的值都可以赋值给它，但它只能赋值给unknown和any&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对象类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里所说的对象类型，就是我们常说的&lt;code&gt;函数、{}、数组、类&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;object, Object 和 {} 类型&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;object object 类型用于表示所有的非原始类型，即我们不能把 number、string、boolean、symbol等 原始类型赋值给 object。在严格模式下，null 和 undefined 类型也不能赋给 object。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; object: object;&lt;br/&gt;object = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;&quot;a&quot;&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;object = {}; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大 Object 代表所有拥有 toString、hasOwnProperty 方法的类型 所以所有原始类型、非原始类型都可以赋给 Object(严格模式下 null 和 undefined 不可以)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; bigObject: &lt;span&gt;Object&lt;/span&gt;;&lt;br/&gt;object = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;&quot;a&quot;&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;object = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;ObjectCase = &lt;span&gt;undefined&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;ObjectCase = {}; &lt;span&gt;// ok&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;{} 空对象类型和大 Object 一样 也是表示原始类型和非原始类型的集合&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 TypeScript 中，我们通过 Class 关键字来定义一个类&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, age: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;  }&lt;br/&gt;  sayHi(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`Hi, &lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; flag1: &lt;span&gt;number&lt;/span&gt;[] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; flag2: &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数声明&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数表达式&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口定义函数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Add {&lt;br/&gt;  (x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可选参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y?: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; y ? x + y : x;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt; = 0&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;剩余参数&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;...numbers: &lt;span&gt;number&lt;/span&gt;[]&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; numbers.length; i++) {&lt;br/&gt;    sum += numbers[i];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; sum;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;函数重载&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;number&lt;/span&gt;, y: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;string&lt;/span&gt;, y: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;x: &lt;span&gt;any&lt;/span&gt;, y: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面示例中，我们给同一个函数提供多个函数类型定义，从而实现函数的重载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;函数重载真正执行的是同名函数最后定义的函数体 在最后一个函数体定义之前全都属于函数类型定义 不能写具体的函数实现方法 只能定义类型&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体示例原理可参考&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型推论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码等价于&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x: &lt;span&gt;number&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 报错&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述示例我们可以看出，我们没有给 x 指定明确类型的时候，typescript 会推断出 x 的类型是 number。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x;&lt;br/&gt;x = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;x = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型断言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;某些情况下，我们可能比typescript更加清楚的知道某个变量的类型，所以我们可能希望手动指定一个值的类型&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型断言有两种方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;to be or not to be&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;str).length;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str: &lt;span&gt;any&lt;/span&gt; = &lt;span&gt;&quot;to be or not to be&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; strLength: &lt;span&gt;number&lt;/span&gt; = (str &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;).length;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;非空断言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上下文中当类型检查器无法断定类型时，可以使用缀表达式操作符 &lt;code&gt;!&lt;/code&gt; 进行断言操作对象是非 null 和非 undefined 的类型，&lt;strong&gt;即x!的值不会为 null 或 undefined&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span&gt;let&lt;/span&gt; user: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(user!.toUpperCase()); &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(user.toUpperCase()); &lt;span&gt;// 错误&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定赋值断言&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value:&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(value); &lt;span&gt;// Variable &#x27;value&#x27; is used before being assigned.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义了变量, 没有赋值就使用，则会报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; value!:&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(value); &lt;span&gt;// undefined 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;联合类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;联合类型用&lt;code&gt;|&lt;/code&gt;分隔，表示取值可以为多种类型中的一种&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; status:&lt;span&gt;string&lt;/span&gt;|&lt;span&gt;number&lt;/span&gt;&lt;br/&gt;status=&lt;span&gt;&#x27;to be or not to be&#x27;&lt;/span&gt;&lt;br/&gt;status=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型别名&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型别名用来给一个类型起个新名字。它只是起了一个新名字，并没有创建新类型。类型别名常用于联合类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; count = &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;[];&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;(&lt;span&gt;value: count&lt;/span&gt;) &lt;/span&gt;{}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;交叉类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交叉类型就是跟联合类型相反，用&lt;code&gt;&amp;amp;&lt;/code&gt;操作符表示，交叉类型就是两个类型必须存在&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IpersonA{&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IpersonB {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; person: IpersonA &amp;amp; IpersonB = { &lt;br/&gt;    name: &lt;span&gt;&quot;师爷&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;    gender: &lt;span&gt;&quot;男&quot;&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;person 即是 IpersonA 类型，又是 IpersonB 类型&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：交叉类型取的多个类型的并集，但是如果key相同但是类型不同，则该key为never类型&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; IpersonA {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; IpersonB {&lt;br/&gt;    name: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testAndFn&lt;/span&gt;(&lt;span&gt;params: IpersonA &amp;amp; IpersonB&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(params)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;testAndFn({name: &lt;span&gt;&quot;黄老爷&quot;&lt;/span&gt;}) &lt;span&gt;// error TS2322: Type &#x27;string&#x27; is not assignable to type &#x27;never&#x27;.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类型守卫&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内&lt;/strong&gt;。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说：&lt;strong&gt;类型守卫是运行时检查，确保一个值在所要类型的范围内&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要有四种的方式来实现类型保护：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; InObj1 {&lt;br/&gt;    a: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    x: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; InObj2 {&lt;br/&gt;    a: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    y: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isIn&lt;/span&gt;(&lt;span&gt;arg: InObj1 | InObj2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// x 在 arg 打印 x&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&#x27;x&#x27;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; arg) &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;x&#x27;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;// y 在 arg 打印 y&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&#x27;y&#x27;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; arg) &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;y&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;isIn({a:&lt;span&gt;1&lt;/span&gt;, x:&lt;span&gt;&#x27;xxx&#x27;&lt;/span&gt;});&lt;br/&gt;isIn({a:&lt;span&gt;1&lt;/span&gt;, y:&lt;span&gt;&#x27;yyy&#x27;&lt;/span&gt;});&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isTypeof&lt;/span&gt;(&lt;span&gt; val: &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; val === &lt;span&gt;&quot;number&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; val === &lt;span&gt;&quot;string&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;啥也不是&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;typeof 只支持：typeof &#x27;x&#x27; === &#x27;typeName&#x27; 和 typeof &#x27;x&#x27; !== &#x27;typeName&#x27;，x 必须是 &#x27;number&#x27;, &#x27;string&#x27;, &#x27;boolean&#x27;, &#x27;symbol&#x27;。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;creatDate&lt;/span&gt;(&lt;span&gt;date: &lt;span&gt;Date&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(date)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(date &lt;span&gt;instanceof&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;){&lt;br/&gt;        date.getDate()&lt;br/&gt;    }&lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(date)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isNumber&lt;/span&gt;(&lt;span&gt;num: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;num&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;number&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; num === &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;isString&lt;/span&gt;(&lt;span&gt;str: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;): &lt;span&gt;str&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; str=== &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用接口来定义对象的类型。接口是对象的状态(属性)和行为(方法)的抽象(描述)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单理解就是：&lt;strong&gt;为我们的代码提供一种约定&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用关键字interface来声明接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;    age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; tom: Person = {&lt;br/&gt;    name: &lt;span&gt;&#x27;Tom&#x27;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;25&lt;/span&gt;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口一般首字母大写。(当然挺多人也习惯 I 大写字母开头，用来表示这是一个接口)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置接口可选|只读&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  readonly name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;可选属性，我们最常见的使用情况是，不确定这个参数是否会传，或者存在。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引签名&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们希望一个接口中除了包含必选和可选属性之外，还允许有其他的任意属性，这时我们可以使用 &lt;strong&gt;索引签名&lt;/strong&gt; 的形式来满足上述要求。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要注意的是，一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age?: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  [prop: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;; &lt;span&gt;//  propName字段必须是 string类型 or number类型。 值是any类型，也就是任意的&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p1 = { name: &lt;span&gt;&quot;张麻子&quot;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p2 = { name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;, age: &lt;span&gt;28&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p3 = { name: &lt;span&gt;&quot;汤师爷&quot;&lt;/span&gt;, sex: &lt;span&gt;1&lt;/span&gt; }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们规定 以 string 类型的值来索引，索引到的是一个 any 类型的值&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接口与类型别名的区别&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，在大多数的情况下使用接口类型和类型别名的效果等价，但是在某些特定的场景下这两者还是存在很大区别。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;TypeScript 的核心原则之一是对值所具有的结构进行类型检查。而接口的作用就是为这些类型命名和为你的代码或第三方代码定义数据模型。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;type(类型别名)会给一个类型起个新名字。type 有时和 interface 很像，但是可以作用于原始值（基本类型），联合类型，元组以及其它任何你需要手写的类型。起别名不会新建一个类型 - 它创建了一个新名字来引用那个类型。给基本类型起别名通常没什么用，尽管可以做为文档的一种形式使用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口和类型别名都可以用来描述对象或函数的类型，只是语法不同&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MyTYpe = {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;都允许扩展&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;interface 用 &lt;code&gt;extends&lt;/code&gt; 来实现扩展&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; MyInterface2 &lt;span&gt;extends&lt;/span&gt; MyInterface {&lt;br/&gt;  sex: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; person:MyInterface2 = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  sex:&lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; MyType = {&lt;br/&gt;  name:&lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MyType2 = MyType &amp;amp; {&lt;br/&gt;  sex:&lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; value: MyType2 = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  sex:&lt;span&gt;&#x27;男&#x27;&lt;/span&gt;,&lt;br/&gt;  say(): &lt;span&gt;void&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;hello 啊，树哥！&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同点&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;type可以声明基本数据类型别名/联合类型/元组等，而interface不行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 基本类型别名&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserName = &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; UserName = &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;// 联合类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Animal = Pig | Dog | Cat;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; List = [&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;boolean&lt;/span&gt;, &lt;span&gt;number&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 此时Person同时具有name和age属性&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如我们现在有个这样的需求，我们要实现一个这样的函数，函数的参数可以是任何值，返回值就是将参数原样返回，并且参数的类型是 string，函数返回类型就为 string？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你很容易写下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;string&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;string&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在需求有变，需要返回一个 number 类型的值，你会说，联合类型就完事了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样又有一个问题，就是如果我们需要返回一个 boolean 类型，string 数组甚至任意类型呢，难道有多少个就写多少个联合类型？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，我们直接用 any 就行了！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;(&lt;span&gt;arg:&lt;span&gt;any&lt;/span&gt;&lt;/span&gt;):&lt;span&gt;any&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管 any 大法好，很多时候 any 也确实能够解决不少问题，但是这样也不符合我们的需求了，传入和返回都是 any 类型，&lt;strong&gt;传入和返回并没有统一&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个骚有最求的程序员，我们还能不能有其他解决办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候就要祭出我们的泛型了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基本使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的需求，我们如果用泛型来解决的话：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型的语法是尖括号 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 里面写类型参数，一般用 &lt;code&gt;T&lt;/code&gt; 来表示第一个类型变量名称，其实它可以用任何有效名称来代替,比如我们用&lt;code&gt;NIUBI&lt;/code&gt;也是编译正常的&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;泛型就像一个占位符一个变量，在使用的时候我们可以将定义好的类型像参数一样传入，原封不动的输出&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有两种方式来使用：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;定义要使用的类型，比如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;); &lt;span&gt;// 定义 T 为 string 类型&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;利用 typescript 的类型推断，比如：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getValue(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;) &lt;span&gt;// 自动推导类型为 string&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多个参数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValue&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:[T,U]&lt;/span&gt;):[&lt;span&gt;T&lt;/span&gt;,&lt;span&gt;U&lt;/span&gt;] &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; str = getValue([&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;]);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.199297629499561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/pfCCZhlbMQR7Ujrq3JOdFEjypcT9HbREJmk5dw0bORpdeYnmXqOC9X5vpEmoQ4ae9u8aXQDT7sczTTEibPbUeZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1139&quot;/&gt; typescript 给我们自动推断出输入、返回的类型&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型约束&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在函数内部使用泛型变量的时候，由于事先不知道它是哪种类型，所以不能随意的操作它的属性或方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getLength&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length); &lt;span&gt;// 报错，不能调用 length 属性&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为泛型 T 不一定包含属性 length，那么我想 getLength 这个函数只允许传入包含 length 属性的变量，该怎么做呢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以使用&lt;code&gt;extends&lt;/code&gt;关键字来对泛型进行约束&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Lengthwise {&lt;br/&gt;  length: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getLength&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Lengthwise&lt;/span&gt;&amp;gt;(&lt;span&gt;arg:T&lt;/span&gt;):&lt;span&gt;T&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length); &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; str = getLength(&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = getLength([&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; obj = getLength({ length: &lt;span&gt;5&lt;/span&gt; })&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里可以看出，不管你是 str，arr 还是obj，只要具有 length 属性，都可以&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体参考&lt;span&gt;轻松拿下 TS 泛型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型接口&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在定义接口的时候指定泛型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; KeyValue&amp;lt;T,U&amp;gt; {&lt;br/&gt;  key: T;&lt;br/&gt;  value: U;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person1:KeyValue&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;number&lt;/span&gt;&amp;gt; = {&lt;br/&gt;  key: &lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  value: &lt;span&gt;18&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person2:KeyValue&amp;lt;&lt;span&gt;number&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; = {&lt;br/&gt;  key: &lt;span&gt;20&lt;/span&gt;,&lt;br/&gt;  value: &lt;span&gt;&#x27;张麻子&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型类&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; Test&amp;lt;T&amp;gt; {&lt;br/&gt;  value: T;&lt;br/&gt;  add: &lt;span&gt;(&lt;span&gt;x: T, y: T&lt;/span&gt;) =&amp;gt;&lt;/span&gt; T;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; myTest = &lt;span&gt;new&lt;/span&gt; Test&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt;();&lt;br/&gt;myTest.value = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;myTest.add = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;x, y&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; x + y;&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型类型别名&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Cart&amp;lt;T&amp;gt; = { list: T[] } | T[];&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; c1: Cart&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; = { list: [&lt;span&gt;&quot;1&quot;&lt;/span&gt;] };&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; c2: Cart&amp;lt;&lt;span&gt;number&lt;/span&gt;&amp;gt; = [&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型参数的默认类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以为泛型中的类型参数指定默认类型。当使用泛型时没有在代码中直接指定类型参数，从实际值参数中也无法推测出时，这个默认类型就会起作用。有点 js 里函数默认参数的意思。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createArray&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; = &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;length: &lt;span&gt;number&lt;/span&gt;, value: T&lt;/span&gt;): &lt;span&gt;Array&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; result: T[] = [];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; length; i++) {&lt;br/&gt;    result[i] = value;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;泛型工具类型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键词除了做类型保护，还可以从实现推出类型，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//先定义变量，再定义类型&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; p1 = {&lt;br/&gt;  name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; People = &lt;span&gt;typeof&lt;/span&gt; p1;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getName&lt;/span&gt;(&lt;span&gt;p: People&lt;/span&gt;): &lt;span&gt;string&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p.name;&lt;br/&gt;}&lt;br/&gt;getName(p1);&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用来获取一个对象接口中的所有 key 值&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt; | &lt;span&gt;&quot;female&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PersonKey = keyof Person; &lt;span&gt;//type PersonKey = &#x27;name&#x27;|&#x27;age&#x27;|&#x27;gender&#x27;;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getValueByKey&lt;/span&gt;(&lt;span&gt;p: Person, key: PersonKey&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p[key];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; val = getValueByKey({ name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;, age: &lt;span&gt;18&lt;/span&gt;, gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt; }, &lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(val); &lt;span&gt;// 树哥&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来遍历枚举类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Keys = &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Obj =  {&lt;br/&gt;  [p &lt;span&gt;in&lt;/span&gt; Keys]: &lt;span&gt;any&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// -&amp;gt; { a: any, b: any, c: any }&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ReturnType&amp;lt;T&amp;gt; = T &lt;span&gt;extends&lt;/span&gt; (&lt;br/&gt;  ...args: &lt;span&gt;any&lt;/span&gt;[]&lt;br/&gt;) =&amp;gt; infer R ? R : &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Lengthwise {&lt;br/&gt;  length: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loggingIdentity&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Lengthwise&lt;/span&gt;&amp;gt;(&lt;span&gt;arg: T&lt;/span&gt;): &lt;span&gt;T&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(arg.length);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; arg;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity(&lt;span&gt;3&lt;/span&gt;);  &lt;span&gt;// Error, number doesn&#x27;t have a .length property&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们传入合法的类型的值，即包含 length 属性的值时：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;loggingIdentity({length: &lt;span&gt;10&lt;/span&gt;, name: &lt;span&gt;&#x27;张麻子&#x27;&lt;/span&gt;}); &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;[]&lt;/code&gt; 操作符可以进行索引访问：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; x = Person[&lt;span&gt;&quot;name&quot;&lt;/span&gt;]; &lt;span&gt;// x is string&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内置工具类型&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Required&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将类型的属性变成必选&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name?: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    age?: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;    hobby?: &lt;span&gt;string&lt;/span&gt;[]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user: Required&amp;lt;Person&amp;gt; = {&lt;br/&gt;    name: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;18&lt;/span&gt;,&lt;br/&gt;    hobby: [&lt;span&gt;&quot;code&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Partial&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 Required 相反，将所有属性转换为可选属性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;    name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;    age: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; shuge:Person = {&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// error  Property &#x27;age&#x27; is missing in type &#x27;{ name: string; }&#x27; but required in type &#x27;Person&#x27;.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面知道，如果必传而我们少穿传了的话，就会报错&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 Partial 将其变为可选&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User = Partial&amp;lt;Person&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; shuge: User={&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;} &lt;span&gt;// 编译正确&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Exclude&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; 的作用是将某个类型中属于另一个的类型移除掉,剩余的属性构成新的类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; T0 = Exclude&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;b&quot; | &quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T1 = Exclude&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;c&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T2 = Exclude&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;(&lt;span&gt;() =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;), &lt;span&gt;Function&lt;/span&gt;&amp;gt;; // &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Extract&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Exclude 相反，&lt;code&gt;Extract&amp;lt;T,U&amp;gt;&lt;/code&gt; 从 T 中提取出 U。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; T0 = Extract&amp;lt;&lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;b&quot;&lt;/span&gt; | &lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;a&quot;&lt;/span&gt; | &lt;span&gt;&quot;f&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// &quot;a&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; T1 = Extract&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;(&lt;span&gt;() =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;), &lt;span&gt;Function&lt;/span&gt;&amp;gt;; // &lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;适用于：并集类型&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Readonly&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把数组或对象的所有属性值转换为只读的，这就意味着这些属性不能被重新赋值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender?: &lt;span&gt;&quot;male&quot;&lt;/span&gt; | &lt;span&gt;&quot;female&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; p: Readonly&amp;lt;Person&amp;gt; = {&lt;br/&gt;  name: &lt;span&gt;&quot;hello&quot;&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;10&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;&quot;male&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;p.age = &lt;span&gt;11&lt;/span&gt;; &lt;span&gt;// error  Cannot assign to &#x27;age&#x27; because it is a read-only property.&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Record&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Record&amp;lt;K extends keyof any, T&amp;gt; 的作用是将 K 中所有的属性的值转化为 T 类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Property = &lt;span&gt;&#x27;key1&#x27;&lt;/span&gt;|&lt;span&gt;&#x27;key2&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Person = Record&amp;lt;Property, &lt;span&gt;string&lt;/span&gt;&amp;gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; p: Person = {&lt;br/&gt;  key1: &lt;span&gt;&quot;hello 啊&quot;&lt;/span&gt;,&lt;br/&gt;  key2: &lt;span&gt;&quot;树哥&quot;&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Pick&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从某个类型中挑出一些属性出来&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Person = {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;  age:&lt;span&gt;number&lt;/span&gt;;&lt;br/&gt;  gender:&lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P1 = Pick&amp;lt;Person, &lt;span&gt;&quot;name&quot;&lt;/span&gt; | &lt;span&gt;&quot;age&quot;&lt;/span&gt;&amp;gt;; &lt;span&gt;// { name: string; age: number; }&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user:P1={&lt;br/&gt;  name:&lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;,&lt;br/&gt;  age:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;8&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Omit&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与Pick相反，&lt;code&gt;Omit&amp;lt;T,K&amp;gt;&lt;/code&gt; 从T中取出除去K的其他所有属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt; Person {&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  age: &lt;span&gt;number&lt;/span&gt;,&lt;br/&gt;  gender: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P1 = Omit&amp;lt;Person, &lt;span&gt;&quot;age&quot;&lt;/span&gt; | &lt;span&gt;&quot;gender&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user:P1  = {&lt;br/&gt;  name: &lt;span&gt;&#x27;树哥&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;9&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NonNullable&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;去除类型中的 &lt;code&gt;null&lt;/code&gt; 和 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; P1 = NonNullable&amp;lt;&lt;span&gt;string&lt;/span&gt; | &lt;span&gt;number&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&amp;gt;; &lt;span&gt;// string | number&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; P2 = NonNullable&amp;lt;&lt;span&gt;string&lt;/span&gt;[] | &lt;span&gt;null&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&amp;gt;; &lt;span&gt;// string[]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;10&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ReturnType&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来得到一个函数的返回值类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Func = &lt;span&gt;(&lt;span&gt;value: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test: ReturnType&amp;lt;Func&amp;gt; = &lt;span&gt;&quot;1&quot;&lt;/span&gt;;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;11&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Parameters&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于获得函数的参数类型所组成的元组类型。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; P1 = Parameters&amp;lt;&lt;span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&amp;gt;; &lt;span&gt;// [number, string]&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;12&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;InstanceType&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回构造函数类型T的实例类型&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;class&lt;/span&gt; C {&lt;br/&gt;  x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  y = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; D = InstanceType&amp;lt;&lt;span&gt;typeof&lt;/span&gt; C&amp;gt;;  &lt;span&gt;// C&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;tsconfig.json&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开头环境安装部分，记得我们有生成一个 tsconfig.json 文件，那么这个文件究竟有什么用呢&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tsconfig.json 是 TypeScript 项目的配置文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tsconfig.json 包含 TypeScript 编译的相关配置，通过更改编译配置项，我们可以让 TypeScript 编译出 ES6、ES5、node 的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重要字段&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;files - 设置要编译的文件的名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;include - 设置需要进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;exclude - 设置无需进行编译的文件，支持路径模式匹配；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compilerOptions - 设置与编译流程相关的选项。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;compilerOptions 选项&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;compilerOptions&quot;&lt;/span&gt;: {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 基本选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;target&quot;&lt;/span&gt;: &lt;span&gt;&quot;es5&quot;&lt;/span&gt;,                       &lt;span&gt;// 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;module&quot;&lt;/span&gt;: &lt;span&gt;&quot;commonjs&quot;&lt;/span&gt;,                  &lt;span&gt;// 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;lib&quot;&lt;/span&gt;: [],                             &lt;span&gt;// 指定要包含在编译中的库文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;allowJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       &lt;span&gt;// 允许编译 javascript 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;checkJs&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                       &lt;span&gt;// 报告 javascript 文件中的错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;jsx&quot;&lt;/span&gt;: &lt;span&gt;&quot;preserve&quot;&lt;/span&gt;,                     &lt;span&gt;// 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;declaration&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                   &lt;span&gt;// 生成相应的 &#x27;.d.ts&#x27; 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;sourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                     &lt;span&gt;// 生成相应的 &#x27;.map&#x27; 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;outFile&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 将输出文件合并为一个文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;outDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                        &lt;span&gt;// 指定输出目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;rootDir&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 用来控制输出目录结构 --outDir.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;removeComments&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 删除编译后的所有的注释&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noEmit&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        &lt;span&gt;// 不生成输出文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;importHelpers&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 从 tslib 导入辅助工具函数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;isolatedModules&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               &lt;span&gt;// 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 严格的类型检查选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                        &lt;span&gt;// 启用所有严格类型检查选项&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitAny&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 在表达式和声明上有隐含的 any类型时报错&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strictNullChecks&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,              &lt;span&gt;// 启用严格的 null 检查&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitThis&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 当 this 表达式值为 any 类型的时候，生成一个错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;alwaysStrict&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                  &lt;span&gt;// 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 额外的检查 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noUnusedLocals&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                &lt;span&gt;// 有未使用的变量时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noUnusedParameters&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,            &lt;span&gt;// 有未使用的参数时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noImplicitReturns&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,             &lt;span&gt;// 并不是所有函数里的代码都有返回值时，抛出错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;noFallthroughCasesInSwitch&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,    &lt;span&gt;// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 模块解析选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;moduleResolution&quot;&lt;/span&gt;: &lt;span&gt;&quot;node&quot;&lt;/span&gt;,            &lt;span&gt;// 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;baseUrl&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 用于解析非相对模块名称的基目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;paths&quot;&lt;/span&gt;: {},                           &lt;span&gt;// 模块名到基于 baseUrl 的路径映射的列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;rootDirs&quot;&lt;/span&gt;: [],                        &lt;span&gt;// 根文件夹列表，其组合内容表示项目运行时的结构内容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;typeRoots&quot;&lt;/span&gt;: [],                       &lt;span&gt;// 包含类型声明的文件列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;types&quot;&lt;/span&gt;: [],                           &lt;span&gt;// 需要包含的类型声明文件名列表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;allowSyntheticDefaultImports&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,  &lt;span&gt;// 允许从没有设置默认导出的模块中默认导入。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* Source Map Options */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;sourceRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                    &lt;span&gt;// 指定调试器应该找到 TypeScript 文件而不是源文件的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;mapRoot&quot;&lt;/span&gt;: &lt;span&gt;&quot;./&quot;&lt;/span&gt;,                       &lt;span&gt;// 指定调试器应该找到映射文件而不是生成文件的位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;inlineSourceMap&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,               &lt;span&gt;// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;inlineSources&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,                 &lt;span&gt;// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/* 其他选项 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;experimentalDecorators&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,        &lt;span&gt;// 启用装饰器&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;emitDecoratorMetadata&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;          &lt;span&gt;// 为装饰器提供元数据的支持&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;vue 项目开发，我遇到了这些问题&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;关于首屏优化，我做了哪些&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一份不可多得的 TS 学习指南&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;TS中文文档&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;&lt;br/&gt;&lt;span&gt;2021 typescript史上最强学习入门文章&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;关于本文&lt;/span&gt;&lt;/section&gt;&lt;h1 data-v-a4949a24=&quot;&quot;&gt;&lt;span&gt;作者：呛再首&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;https://juejin.cn/post/7124117404187099172&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3913677&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;0.006666666666666667&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot; data-width=&quot;100%&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCu1rRLicXibOB6jq4wpe7W4Ioibu7XTJR1ABzARKoLxyWEWeIV6HJRII2GK1ntnCkVIqjY852gntBd5Q/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;敬请关注「Nodejs技术栈」微信公众号，&lt;span&gt;期望与志同道合的你一起打造优质 “Nodejs技术栈” 交流群，一起互相学习进步！&lt;/span&gt;&lt;span&gt;可长按下方二维码&lt;/span&gt;&lt;span&gt;添加【五月君】个人微信备注 “Node” 邀请入群。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zPkNS9m6iatLmT5coKbicuqENgoc3Pz4QWwtrEoP2RU2thicCJHaKNmJ23Hh9jYvicpVgiauY6NxNaZ59D6svw1Qskg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff354f8cb1e2a1da4d94f89c1306738d</guid>
<title>使用 ELK 收集日志</title>
<link>https://toutiao.io/k/mollir5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在当前分布式、微服务架构下，各个应用都部署在不同的服务器上，每个应用都在记录着自己重要或者不重要的日志信息。当我们要通过日志信息来排查错误时，可以根据出错应用在对应的机器上找报错相关的日志信息。但是，可能我们不具有相应服务器的访问权限，也可能相同的应用部署在多台服务器上，导致根本不知道在哪台服务器上找日志。遇到类似这样的尴尬，想要通过日志来排查错误就搞得很麻烦。在这种情况下，ELK 为我们提供了统一的日志管理解决方案，它能很好的支持 Logback 等日志框架，使得我们可以集中的管理不同应用输出的日志信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 是 ElasticSearch、Logstash 和 Kibana 的简写。ElasticSearch 主要用来存储日志信息，并提供检索功能；Logstash 用于收集应用发送的日志信息，并写入到 ElasticSearch 当中；Kibana 是一个可视化的日志查看、分析工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 架构大体如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5615942028985508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtiaoRFfPUskPicqs87jsvqaNYia2rh7eibkRCAU3SJoPZ6Dr45niarUIt3Yxn8vdjb9wiagiaO526Pf0WRKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在上图中应用日志框架直接将日志发送给 Logstash，然后 Logstash 将接收的日志写入 ElasticSearch 中，开发人员通过可视化的 Kibana 可以进行日志的查询和分析。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在上图中，Logstash、ElasticSearch 都可以是多个，而不是一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ELK 的下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 都可以通过它们的官网进行下载，最好将它们的版本进行统一。我这里下载的是 7.17.6 的版本，即 ElasticSearch、Logstash 和 Kibana 都是 7.17.6 版本的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        它们的下载地址分别如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;- elasticsearch下载地址:&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-17-6&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;- logstash下载地址：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/logstash-7-17-6&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;- kibana下载地址：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;https://www.elastic.co/cn/downloads/past-releases/kibana-7-17-6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        ELK 下载后只需要解压缩后进行配置即可使用，还是很方便的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ELK 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        我这里使用的是 Windows 系统进行演示，在将 ELK 配置好后直接使用命令行进行启动，并没有将其注册为服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ElasticSearch 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 ES 的安装目录下有个 config 目录，打开该目录下的 elasticsearch.yml 文件，然后取消掉两行配置的注释符号，并进行简单的修改，配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;network.host: 0.0.0.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;discovery.seed_hosts: [&quot;127.0.0.1&quot;, &quot;[::1]&quot;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        在 ES 的安装目录下打开命令行执行以下命令，来启动 ES：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\elasticsearch.bat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Logstash 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 Logstash 的安装目录下同样有一个 config 目录，复制 logstash-sample.conf 配置文件，并命名为 log_to_es.conf，文件名可以自己定，启动时写对即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        修改配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;input {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  beats {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    port =&amp;gt; 5044&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  tcp {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    host =&amp;gt; &quot;0.0.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    port =&amp;gt; 8082&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mode =&amp;gt; &quot;server&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tags =&amp;gt; [&quot;bsjiot&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    codec =&amp;gt; json_lines&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;output {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  elasticsearch {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    hosts =&amp;gt; [&quot;http://localhost:9200&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        其中 input 是用于收集日志信息的配置，output 是用于将收集的信息推送到 ES 中。通过命令行来启动 Logstash，命令如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\logstash.bat -f .\config\log_to_es.conf&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Kibana 的配置与启动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;        在 Kibana 的安装目录下也同样有一个 config 目录，修改该目录下的 kibana.yml 文件，配置如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;elasticsearch.hosts: [&quot;http://localhost:9200&quot;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;server.host: &quot;127.0.0.1&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;        通过在命令行如下命令启动 Kibana，命令如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;.\bin\kibana.bat&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过 Logback 输出日志到 ELK&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;上面配置完 ELK 并启动后，通过 SpringBoot 来进行测试。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;首先引入两个依赖，引入依赖如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;net.logstash.logback&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;logstash-logback-encoder&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;version&amp;gt;7.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;groupId&amp;gt;ch.qos.logback&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;artifactId&amp;gt;logback-core&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;接下来配置 Logback 的配置文件：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;appender name=&quot;LOGSTASH&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;destination&amp;gt;localhost:8082&amp;lt;/destination&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;encoder charset=&quot;UTF-8&quot; class=&quot;net.logstash.logback.encoder.LogstashEncoder&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &amp;lt;customFields&amp;gt;{&quot;appname&quot;:&quot;xxxx&quot;}&amp;lt;/customFields&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;/encoder&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/appender&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;root level=&quot;info&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;appender-ref ref=&quot;CONSOLE&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;lt;appender-ref ref=&quot;LOGSTASH&quot; /&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;root&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;最后通过 Logback 来输出一些日志，然后在 Kibana 中进行查看。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过 Kibana 查看日志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;我们来&lt;/span&gt;&lt;span&gt;&lt;strong&gt;访问 Kibana 提供的 Web 页面&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;浏览器中打开 http://localhost:5601/ 该地址&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。然后在左侧列表中选择 &lt;strong&gt;Stack Managentment&lt;/strong&gt;，选择后会出现新的页面，然后选择 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Index Patterns&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 选项。在新出现的页面中点击 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;Create Index pattern&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 按钮，然后命名其为 logstash-*（这里名字随意），并选择 @timestamp 的字段，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40168539325842695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwtje49PygRE6ddtoFUxO4np2MoDAEFIQ5GibUhqH1OJiaFGRwcIVyJ17LYHnDbuYwyXuQHxIbbrZKvRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;712&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;选择好后，点击 Create index pattern 按钮即可。创建完成后，返回 Kibana 的首页，选择 Discover 选项，切换到我们新建的 logstash-* 选项下，然后选择时间段，就可以看到相应的日志信息了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;        &lt;/span&gt;上例中 ELK 都部署在了一台机器上，Demo 演示而已。实际情况中，ELK 可能部署在多台机器上，且可以配置集群。当微服务等客户端特别多时，同时向 Logstash 发送数据，并写入 ES 可能会影响性能，此时可以在客户端和 Logstash 中间引入 Kafka 来缓解 Logstash 和 ES 的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0712962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwthBDooApBDUM9yqM6BWHMOaJyrXzMxqibI7B90xNgZswWSVSatF56vMAicAA56UmJkc2rQlDUARycYQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【mongo】 下载 SpringBoot 整合操作 MongoDB 的文档。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内回复 【&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;cisp知识整理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;】 下载 CISP 读书笔记。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号内&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;回复【java开发手册】获取《Java开发手册》黄山版。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0MzA2OTc4MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Bfv9smoHwth5nBzNr9kZshQ25yhLz08JicGiaeuWY5k8z6JHS4KYxQ2zp2lU9mjSC6PsvBlib658u3CnrSQsuCzAg/0?wx_fmt=png&quot; data-nickname=&quot;码农UP2U&quot; data-alias=&quot;&quot; data-signature=&quot;关于 Java、PHP、其他编程语言……或安全、或码农、或技术、或总结！学习交流，共同进步！码农 up to you，码农UP2U!&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>702340b12a594b51dd59df6e8e25d149</guid>
<title>分布式中灰度方案实践</title>
<link>https://toutiao.io/k/jpnejcx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;让请求在导航的服务节上点执行；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、背景简介&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;分布式系统中会存在这样的开发场景，不同需求可能涉及到对同一个服务的开发，那么该服务在研发期间就会存在多个版本并行的状态，为了保持不同版本之间的隔离性，验收需要将请求路由到指定版本号的服务上处理；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.22421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMIIC53dUFJj5fFgn7TgYuqMZXcSialla04qwCDMUyXWRDEw8ibDFSU53g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;假设存在三个服务：A、B、C，且服务B和C都存在多个版本，那么让请求按照即定的路由规则执行，即可保证研发期间的验收是版本间隔离的，并且可以实现灰度部署的策略；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、负载策略&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在微服务系统架构中，请求在服务间转发时会执行负载的策略，尤其当服务存在多版本号的集群模式时，很显然常规的轮询、权重、随机等策略无法满足需求；进行路由规则的自定义设计和开发是常见方式；&lt;/p&gt;&lt;p&gt;经典应用场景：在请求发起时，可以通过Header、Cookie、Parameter等不同的方式，携带路由规则的方式与参数执行匹配逻辑，从而将请求路由到指定版本的服务；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;默认主分支路由&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMErvMib69kVpIPZaprUQyZUzpZ5c6SjvLCe1IIkvpIbebh23NWdRWh6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通常来说请求会在主干分支上执行，或者其他分支路由规则不匹配，也可以通过标识配置，判断是否由主分支兜底，甚至是存活的任意服务兜底；&lt;/p&gt;&lt;p&gt;存活的服务中可能存在多个版本，但是主分支Master是否存活是服务健康与否的基本标志，常规应用中路由规则如果不匹配，会由Master服务进行兜底；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;版本号统一路由&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMHlbsj1E7ibaEYhyHQpfFl7P8t2xyvFWhPDlV6qYSO7UEjwof0PicmzgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;请求通过携带分支号进行统一版本路由是常用的轻量级方案，即如果请求携带的是&lt;code&gt;2.0.0&lt;/code&gt;的分支，则在路由时优先匹配相关版本的服务，不匹配时由Master服务处理即可；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务定制化路由&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMd8adj8VM3VSsiasJo98En6FS3ejN5VW3jhrPxhIgpLxibbtDWXNIgRIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在请求或配置中指定各个服务的路由分支号，也是常见的匹配方案，如上图在请求时指定服务B由&lt;code&gt;1.0.0&lt;/code&gt;分支执行，服务C由&lt;code&gt;3.0.0&lt;/code&gt;分支执行，其余服务在主干分支执行；&lt;/p&gt;&lt;p&gt;路由规则可以看做是对可用服务的匹配筛选，如果筛选出来的服务存在集群部署时，还要去执行相应的负载均衡策略，例如上图中当服务C的&lt;code&gt;3.0.0&lt;/code&gt;分支是集群时，路由匹配到该版本后，再通过负载均衡的策略选中其中一个服务处理请求；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、灰度部署&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;当负载均衡的策略可以按照定制化开发的规则执行时，那服务的灰度发布就会容易很多，在不影响现有服务的情况下发布新版本，同时将请求按照规则分流，完成对新服务的验收后，替换掉旧版本即可；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.371875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMlNdzyqibgnbyiaAwxoDQ5Nv3455cK2QSOAYocvKDV2JFdQcCgicZH3Tzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;分布式系统中子服务的拆分非常多，版本开发通常只会涉及其中部分子服务，通过灰度模式将相关服务部署到线上，并且不会影响主干的服务，只有开启特定的配置才会将请求分流到灰度服务；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;流程细节&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、做好路由配置和管理，请求默认在主干服务执行；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、部署版本涉及的相关服务，灰度层面默认不会处理请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、验收阶段基于配置，将指定规则的请求路由到灰度层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4、常用规则：携带分支号、灰度用户群、比例分流、IP等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5、完成灰度服务验收后，将相关服务标记为主干服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6、将旧的主干服务下线后，即本次上线流程完整结束；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;7、若发现灰度服务验收失败，撤掉灰度层或修改都可以；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;灰度发布的模式即依赖于自定义的路由规则，以及服务在负载均衡时权重比例倾斜，这些都可以在配置中心管理，在测试时动态修改即可；&lt;/p&gt;&lt;p&gt;在这种模式下，灰度服务的上线或者下线几乎是没有明显感知的，如果是相对简单的流程，由测试人员验收灰度层服务即可，如果是复杂的流程，放开一定比例的用户流量，流程观察没有问题后完成升级；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、实践方案&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、流程设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMgNdNplzqb3hCurbHPRzxgFic93pHY5fKS02I75o4SL1iaMdQDMPyJQtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在灰度方案落地实践的过程中，通常客户端会携带路由规则的标识，从而将请求发送到指定服务，在规则无法正常匹配的时候，由主干服务处理，对于一些核心的开关标识在配置中心统一维护；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、路由标识&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;标识获取&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常情况下，路由的标识是在请求头中携带的，这样比较方便统一管理，常用的传递格式如下:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;版本号统一路由：routeId:2.0.0，即所有请求优先在&lt;code&gt;2.0.0&lt;/code&gt;分支执行；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务定制化路由：serverC:3.0.0，请求服务C时优先在&lt;code&gt;3.0.0&lt;/code&gt;分支执行；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在微服务的组件中获取请求头的方式很多，比如Gateway网关中的路由过滤器，或者服务中的拦截器，都可以获取请求的相关参数信息，从而执行路由规则；&lt;/p&gt;&lt;p&gt;&lt;strong&gt;标识管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;自定义路由规则需要客户端标识，虽然获取请求中的标识并不复杂，但是将标识传递到路由规则中就涉及到上下文参数管理：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMNX8CZz0t6icDfiaEm1sIjTTx4uRfpzH6CaCRkG3vZViamXYCJNY5l2QmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;写阶段：在过滤或拦截中获取路由标识，写入上下文容器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读阶段：路由时从容器中读取标识，基于配置信息执行规则；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;请求从进入网关开始，在服务间通信时会涉及负载均衡的策略，在过滤或拦截器中将标识写到上下文容器，执行路由规则需要读取上下文容器，如果标识不存在则默认选择主干服务执行请求；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、服务选中&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;微服务之间通信时，选中一个服务执行请求的逻辑比较复杂，尤其在灰度模式下涉及到对路由规则的改造，即策略指定的服务优先被选中；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.37109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDJgPtsgPicjqR35icSHkpbeMqAib0q3ic9DO132F9VcbIjAt7BicfTia7dEXEmq9iafs4z4pD2hc5xMAoVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、从注册中心查询相应服务的可用列表；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、基于路由规则，匹配符合请求标识的服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3、对筛选的结果列表执行负载均衡，选中服务；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在整个路由机制中，会涉及到匹配规则自定义改造，从常规的手段来看，将版本的分支号加载到服务的元数据信息中，再结合服务名称或者IP地址，来实现对服务列表的多维度过滤，可以支撑大部分轻量级灰度策略的实现。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;br/&gt;组件封装：&lt;br/&gt;https://gitee.com/cicadasmile/butte-frame-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>78688f646912c4445722888098f45d63</guid>
<title>浅谈策略模式在消息转发场景下的应用</title>
<link>https://toutiao.io/k/5qpklzd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇文章中，我们介绍了如何设计一个消息中心，传送门 👉&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247485198&amp;amp;idx=1&amp;amp;sn=af6ade172c7ed2863b345d8f73b21645&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《如何设计一个消息中心》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了承载这些消息的地方后，接下来的问题便是，&lt;strong&gt;这些消息从哪里来？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常对于一个内容型产品来说，在其互动体系中，为了增强消息的用户触达，增强用户的互动心智，在互动（评论、点赞等）行为发生后，会将互动消息推送至消息中心，然后根据不同的互动行为类型匹配不同的消息模版。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7637906647807637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyrticBqJGpgDU9jqfNNpZFhiaOiaITXseLsGJ5vtD5CDJGNddia08can4CaB7xYic0oHX4n3ibvQO31tFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1414&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而随着互动行为种类的增加（内容的点赞、评论的点赞……），不断的通过 if…else 来根据不同的消息类型生成不同的消息模版会使得业务代码愈发复杂，难以维护。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.426517571884984&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyrticBqJGpgDU9jqfNNpZFhjYOMGPhXgof72eHtaFEwoDH2D7vHsb9SDnlnmsSInUYJKvE8zMsfCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1252&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅如此，一旦需要增加一种新的互动消息时，需要对原有代码进行破坏性修改，违背了“开闭原则”。因此有必要对互动行为消息转发至消息中心这一场景进行抽象，让后续的维护者、建设者只需要关心某一特定的互动行为消息即可（我可不想未来被别人喷在 💩 山上拉 💩）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;策略模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说明具体的实现方案前，我们先介绍一个设计模式——策略模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式，英文全称是 Strategy Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译成中文就是：定义一簇算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;策略模式用来解耦策略的&lt;strong&gt;定义、创建、使用&lt;/strong&gt;。实际上，一个完整的策略模式就是由这三个部分组成的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;策略类的定义比较简单，包含一个策略接口和一组实现这个接口的策略类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略的创建由工厂类来完成，封装策略创建的细节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。其中，“运行时动态确定”才是策略模式最典型的应用场景。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;实现方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在对策略模式有了基本的了解后，我们尝试在本节将其运用起来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细分析了第一章的应用场景后我们发现其实实现链路并不复杂，整体流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44553805774278216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybyrticBqJGpgDU9jqfNNpZFhbg3Ad2GdSm0QZ5G3K8hwnr3KibMDmGvTicZKTlmlsicgJxQmauC66cBRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1524&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本例中，根据不同的互动行为类型，我们将点赞消息和评论消息分成以下几类：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点赞类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内容点赞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;评论点赞&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;评论类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;内容评论&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内容评论的回复&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;转发策略的定义&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个方案中最重要的一环是对转发策略的匹配，因此第一步我们要做的应该是定义一个策略。为了方便后续的扩展（未来可能会有多种转发策略），我们此处定义一个策略接口&lt;code&gt;MsgTransmitStrategy&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;MsgTransmitStrategy&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 是否命中策略&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;match&lt;/span&gt;&lt;span&gt;(T message)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 消息类型&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;TransmitMsgType &lt;span&gt;getMsgType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;// 创建需要转发的消息实体&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;MessageContent &lt;span&gt;createMessageContent&lt;/span&gt;&lt;span&gt;(T message)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个策略需要具备的行为能力应该有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;明确自己是否命中了转发策略：&lt;code&gt;match(T message)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明白自己要转发的是什么类型的消息：&lt;code&gt;getMsgType()&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建要转发的消息：&lt;code&gt;createMessageContent(T message)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;转发策略的创建&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以点赞消息为例，上文提到存在两种点赞消息的转发策略：内容点赞与评论点赞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们需要创建两个具体的策略：&lt;code&gt;ContentLikeMsgTransmitStrategy&lt;/code&gt;和&lt;code&gt;CommentLikeMsgTransmitStrategy&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ContentLikeMsgTransmitStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MsgTransmitStrategy&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TransmitMsgType &lt;span&gt;getMsgType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; TransmitMsgType.CONTENT_LIKE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;match&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; MessageContent &lt;span&gt;createMessageContent&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// do something……………&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; messageContent;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CommentLikeMsgTransmitStrategy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;MsgTransmitStrategy&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; TransmitMsgType &lt;span&gt;getMsgType&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; TransmitMsgType.COMMENT_LIKE;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;match&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; MessageContent &lt;span&gt;createMessageContent&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// do something……………&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; messageContent;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;转发策略的使用&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们已经创建了几种消息转发策略了，那么客户端代码一般如何确定使用哪个策略呢？最常见的是运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的“运行时动态”指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来创建一个&lt;code&gt;MsgTransmitExecutor&lt;/code&gt;作为策略的执行器，通过遍历的手段依次调用每个策略的 match 方法，符合条件的策略类可以执行统一的转发方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MsgTransmitExecutor&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MsgTransmitTools msgTransmitTools;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; BentleyManager bentleyManager;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(T message, List&amp;lt;MsgTransmitStrategy&amp;lt;T&amp;gt;&amp;gt; strategyList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (MsgTransmitStrategy&amp;lt;T&amp;gt; strategy : strategyList) {&lt;br/&gt;           &lt;span&gt;// 依次调用策略的match方法&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (strategy.match(message)) {&lt;br/&gt;                MessageContent messageContent = strategy.createMessageContent(message);&lt;br/&gt;                Optional.ofNullable(messageContent)&lt;br/&gt;                        .filter(mc -&amp;gt; msgTransmitTools.isNeedSendPush(mc))&lt;br/&gt;                        .ifPresent(mc -&amp;gt; bentleyManager.sendMessage(mc));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，对于客户端（实际调用策略的类），只需通过组合（而非继承）的方式，将策略的执行器注入到具体的消息处理逻辑中即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LikeMsgListener&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MessageConsumer&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 点赞消息转发策略集合&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;MsgTransmitStrategy&amp;lt;String&amp;gt;&amp;gt; LIKE_MSG_TRANSMIT_STRATEGY_LIST = Lists.newArrayList();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; MsgTransmitExecutor&amp;lt;String&amp;gt; msgTransmitExecutor;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ContentLikeMsgTransmitStrategy contentLikeMsgTransmitStrategy;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Resource&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CommentLikeMsgTransmitStrategy commentLikeMsgTransmitStrategy;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LIKE_MSG_TRANSMIT_STRATEGY_LIST.addAll(Arrays.asList(&lt;br/&gt;                contentLikeMsgTransmitStrategy,&lt;br/&gt;                commentLikeMsgTransmitStrategy&lt;br/&gt;        ));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ConsumeConcurrentlyStatus &lt;span&gt;processMessage&lt;/span&gt;&lt;span&gt;(String message, MessageExt messageExt)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            msgTransmitExecutor.execute(message, LIKE_MSG_TRANSMIT_STRATEGY_LIST);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            PgLog.messageBoxError(&lt;span&gt;&quot;LikeListener&quot;&lt;/span&gt;, e);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ConsumeConcurrentlyStatus.CONSUME_SUCCESS;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述实例中，通过 LikeMsgListener 监听点赞类消息。通过 MsgTransmitStrategy 接口定义消息转发至消息中心的行为策略，MsgTransmitExecutor 作为策略的执行器最终实现将匹配过后的消息以不同的模版类型推送至消息中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个方案，通过利用策略模式避免了整个转发场景中使用多重条件判断，维护者只需专注于当前的转发策略即可，遵循了“开闭原则”，同时通过组合而非继承的方式注入策略执行器，扩展性较好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但任何事物都具有两面性，一旦未来的场景变得更加复杂（例如点赞行为可以支持更多类型），转发策略类会增多，届时就需要考虑使用一些混合模式（例如策略也可以使用工厂模式创建等方法），解决业务发展所带来的策略类膨胀的问题了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>