<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3def248f2f63b79bb96b8364a34a4486</guid>
<title>研发过程中的文档管理与工具</title>
<link>https://toutiao.io/k/mdiqwn5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;写文档也是技术活&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;01：实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于多数开发同学来说，很多时候即讨厌没有研发文档，但是自己又不愿意常写文档，痛且倔强着；&lt;/p&gt;&lt;p&gt;程序员该不该写文档，与争论哪种编程语言最好一样，想撕的嘴不留情，该写的笔不停耕；&lt;/p&gt;&lt;p&gt;当自我的意识上去纠结一件事情要不要去做的时候，不妨停下来看一看，大的职场环境是如何选择的，纠结自然就没必要了；&lt;/p&gt;&lt;p&gt;对于写文档这件事情，并不需要去思考能带来哪些好处或者会占用多少时间，用心去写自然明白当中利弊；&lt;/p&gt;&lt;p&gt;最近两年听到不少搬砖的朋友说，公司已经把文档管理提升到资产层面，在重大版本推进过程中，预留文档输出的时间，这可不是一般的大聪明；&lt;/p&gt;&lt;p&gt;从工作的这几年实践经验来看，写文档原则上本着复杂的事项细写，简单的事项简写或者不写，卷可以但又不闲的慌；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;02：目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;互联网的产品，多少存在一定的虚拟属性，很多事情和想法也都具有明显的抽象感，如果缺乏文档的结构化描述，时间拉扯下很容易烟消云散；&lt;/p&gt;&lt;p&gt;这里罗列一份在研发管理和职场中，或多或少都会接触到的文档内容，虽然结构复杂，但随着时间的沉淀，其带来的价值远大于维护成本；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1pUKiaFoXG4ib9PPZVwpx79SV5ltYK13xlzIia0IYYY3hbKLDLRfI5xrv2Qu6NuAcNujXxlz7FmdiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;工作中涉及到的文档种类比较繁多，但就管理和沉淀的动作来说属于那种重要但不紧急的事情，这样说并不是指研发流程中动作的时序可以混乱；&lt;/p&gt;&lt;p&gt;顺着工作流程把该输出的文档做好，是比较正常的节奏，在特殊情况下也可以先解决事情，再后补文档；&lt;/p&gt;&lt;p&gt;从开发的角度来说，如果是常规状态下的版本推进，那么在版本结束时各种相关文档就可以上传指定目录了；&lt;/p&gt;&lt;p&gt;但是工作中不乏很多生产环境突发的棘手状况，此时团队自然优先解决，如果问题影响过大，在事后必然还要输出总结文档，即是经验更是教训；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;03：模板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果是个人的文档，简明扼要即可；但是工作文档需要有规范和风格上的约束，通常情况下基于统一的模板库即可；&lt;/p&gt;&lt;p&gt;在研发流程中，通常会围绕项目的进度管理文档，在该文档中会统筹流程中的核心内容，涉及各个阶段的进度维护；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3343283582089551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1pUKiaFoXG4ib9PPZVwpx79lI8C7vNw3Go4yW3icYKaWvqvV7EUjxYFwPH6YgS5gHcgakRDuW1e8ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1005&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于项目进度管理的文档模板，在流程推进的过程中，不断补齐相关的核心内容，清晰准确的记录版本进度；&lt;/p&gt;&lt;p&gt;采用特定的模板写工作文档，本身就会起到规范的效果，在部门的日常管理中，需要阶段性的沉淀和维护各类文档的模板结构，而模板的内容可以根据具体需求来定，在使用的过程中也需要时常优化；&lt;/p&gt;&lt;p&gt;如果文档模板足够丰富，在一定程度上可以解决不想写文档的问题，在写文档这件事上之所以会劝退很多人，很大原因是缺少可用的文档模板；&lt;/p&gt;&lt;p&gt;当模板库中存在：项目进度、研发设计、测试用例、阶段总结、阶段规划等各种样例时，下载之后直接使用，编写核心内容即可，这样排斥写文档的情绪自然减少；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;04：内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;文档的内容是价值所在，对于团队的协作来说内容简明扼要即可，让阅读文档的人可以快速准确的理解事情的信息；&lt;/p&gt;&lt;p&gt;通常需要输出文档的事项都比较复杂，所以在内容上需要适当的排版，复杂的逻辑尽量使用图解来描述，这样内容条理和思路都会很清晰；&lt;/p&gt;&lt;p&gt;对于其他细节方面的把控，比如段落缩进、专业名词、空格等，通常本着：对内的文档尽量做好，对外的文档必须做好的原则；&lt;/p&gt;&lt;p&gt;文档内容是思考逻辑的呈现，在编写过程中也容易发现逻辑上的问题，再通过评审讨论和完善内容，这样事情围绕文档在后续的过程中不会过度偏离主线；&lt;/p&gt;&lt;p&gt;对于开发这个角色来说，写文档是避不开的事，在一个项目上待的时间久了，再看初期的代码，都觉得不是自己写的，更别说是复杂的业务逻辑了；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1pUKiaFoXG4ib9PPZVwpx79iaoibRT8HKwBNm6TkaIWT9ZFIUkltmq5qtLlTpz61WvfHsacKW5ATQPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在研发文档中，最常用的图解就是逻辑时序，再适当的丰富相关的内容，在一份图中可以包括流程、逻辑、交互、数据管理等各个核心节点；&lt;/p&gt;&lt;p&gt;开发的设计文档基本是几张图就可以描述清楚的，通常涉及：业务流程图，逻辑时序图，数据结构图；&lt;/p&gt;&lt;p&gt;当复杂的业务呈现在文档和设计图上时，其实就是给事情预设好了航线，当然有时候中途被迫返航或变道也不少见；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;05：工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;工欲善其事，必先利其器，想快速做好一份文档，必须得有趁手好用的工具才行，在多年写文档的经验中，以下工具多少都试用过；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.3336745138178097&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvC1pUKiaFoXG4ib9PPZVwpx79YtkTzCz6DWCZMATP0011yL5blqjntPSMetpqzYgdpD3KQEoltH1gUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中标红的工具，是个人在实践中觉得不错的工具，当下使用最多的是DrawIO和语雀文档，在免费的边界内足够日常使用；&lt;/p&gt;&lt;p&gt;由于工作中需要对接的事项比较多，很难统一协作的各方使用的文档工具，自然接触到的工具类型就很复杂，对于团队内部来说，通常使用办公软件集成的工具，以便于统一管理；&lt;/p&gt;&lt;p&gt;写文档的习惯已经持续了很多年，工具的变迁也经历了三次，从办公文档迁向Markdown，从线下迁移到线上，更换过一次文档工具；&lt;/p&gt;&lt;p&gt;时间在变，文档类产品也在不断的更新换代，如何寻找自己顺手的工具，本着一个基本的原则：免费的范畴内，支持在线管理，功能适当丰富即可；&lt;/p&gt;&lt;p&gt;最后分享一条写文档的理由：因为工作多而复杂，所以要写到文档中，这样便能安心的忘了它。&lt;/p&gt;&lt;p&gt;&lt;span&gt;END&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-alias=&quot;cicada_smile&quot; data-from=&quot;0&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-signature=&quot;积累、总结、用心记录。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33162ad63f101deed841e5e92b90e764</guid>
<title>【设计模式】10分钟学懂UML类图</title>
<link>https://toutiao.io/k/wg4oeyc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;h2&gt;UML介绍&lt;/h2&gt;&lt;p&gt;自己刚刚参加工作时，刚进部门第一周leader让我熟悉一个模块的调用过程，那个模块包含几十个类、有上百个方法，类和类之间关系错综复杂，各种方法调来调去，我就画了一整张纸，密密麻麻，睡醒觉第二天就已经看不懂了，&lt;span&gt;简直裂开&lt;/span&gt;&lt;span&gt;，这种感觉记忆尤新，当时&lt;/span&gt;leader说”工具不对“，然后从那个时候才开始接触UML。&lt;/p&gt;&lt;p&gt;UML（Unified Modeling Language）是一种统一建模语言，是用来对软件密集系统进行可视化建模的一种语言。&lt;/p&gt;&lt;p&gt;UML图有很多种，主要包含以下几类：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8323232323232324&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKyn3D5MxmUMJKlicib7Diaf4bPzogterjvgdfSYqwT3D4bekolLx65wbqw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是对于初学者来说，我们不需要掌握所有的UML图，才能进行系统分析和设计工作，否则学习的成本太高了。根据二八原则，一般说来，在UML图中，只要掌握&lt;span&gt;类图&lt;/span&gt;、&lt;span&gt;用例图&lt;/span&gt;、&lt;span&gt;时序图&lt;/span&gt;的使用，就能完成80%的工作了。而对于程序员来说，使用最频繁的又是类图。因此，本文我们只介绍UML类图。&lt;/p&gt;&lt;h2&gt;抽象类、抽象类、接口和包的UML类图表示&lt;/h2&gt;&lt;h3&gt;类的UML类图表示&lt;/h3&gt;&lt;p&gt;UML类图中用矩形框表示一个具体类，矩形框分为三层：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 第一层：类名&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 第二层：成员变量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 第三层：成员方法&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;成员变量以及成员方法名&lt;span&gt;前&lt;/span&gt;的访问修饰符用对应符号来表示，成员变量以及成员方法名&lt;span&gt;后&lt;/span&gt;紧跟着&quot;:&quot;后面再跟着成员变量的类型或者方法的返回类型,举个例子。&lt;/p&gt;&lt;section&gt;下面是一个具体类的定义：&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Student&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String pubVar;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String proVar;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String priVar;&lt;br/&gt;    String defaultVar;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;pubFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;pubFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;proFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;proFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String &lt;span&gt;priFun&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;priFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    String &lt;span&gt;defaultFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;defaultFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是该类对应的UML类图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3499308437067773&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKxicKfdEw8Nhdn1OFlJZia1rhcv9ufFjeNFguzXteuxH8mAghSdHSrGZw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;抽象类的UML类图表示&lt;/h3&gt;&lt;p&gt;抽象类在UML类图中同样用矩形框表示，不同的是抽象类的类名以及抽象方法的名字都用斜体字表示，其它和具体类没有任何差别。&lt;/p&gt;&lt;p&gt;下面是一个抽象类的定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String pubVar;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String proVar;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String priVar;&lt;br/&gt;    String defaultVar;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;pubFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;pubFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; String &lt;span&gt;proFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;proFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String &lt;span&gt;priFun&lt;/span&gt;()&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;priFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    String &lt;span&gt;defaultFun&lt;/span&gt;(){&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;defaultFun&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    //抽象方法&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;abstractFun&lt;/span&gt;();&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;其对应的UML类图如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3603305785123967&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKcRwYzUoPmvGyba68IoKANaFSiavXbibH4hBcMh2tB3O0PK2oQJ1xn7aw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;接口的UML类图表示&lt;/h3&gt;&lt;p&gt;接口在类图中也是用矩形框表示，但是与类的表示法不同的是，接口在类图中的第一层顶端会用&lt;span&gt; &amp;lt;&amp;lt;interface&lt;/span&gt;&lt;interface&gt;&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/interface&gt;&lt;interface&gt;标注这是一个接口，下面是接口的名字，第二层是方法。另外需要注意的是接口的方法前面没有访问修饰符&lt;/interface&gt;&lt;interface&gt;&lt;span&gt;默认就是public&lt;/span&gt;&lt;/interface&gt;&lt;interface&gt;访问权限。&lt;/interface&gt;&lt;/p&gt;&lt;p&gt;下面是一个接口的定义：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;Shoes&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;void&lt;/span&gt; &lt;span&gt;abstractFun&lt;/span&gt;();&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;其对应的UML类图如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18816388467374812&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeK5OzzPtIib5RcuzXELGMRSzu8KJmGw2V460zEASFHvwpePUTUmXfpCNA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;包的UML类图表示&lt;/h3&gt;&lt;section&gt;类和接口一般都出现在包中，UML类图中包的表示形式如图：&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;package&lt;/span&gt; graph;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2309941520467836&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKlgYwt0HAiadN6dGRbBKyrU4u6jysq8uyIQvFW3tzrhJiaDpiaEhayTdrg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h2&gt;UML类图表示类之间关系&lt;/h2&gt;&lt;h3&gt;继承关系&lt;/h3&gt;&lt;p&gt;&lt;span&gt;继承关系&lt;/span&gt;也称为泛化关系，是指对象与对象之间的继承关系。如，&lt;/p&gt;&lt;p&gt;在UML类图中，继承关系是用&lt;span&gt;空心&lt;/span&gt;三角和&lt;span&gt;实线&lt;/span&gt;组成的箭头表示，从&lt;span&gt;子类指向父类&lt;/span&gt;。&lt;/p&gt;&lt;section&gt;下面的例子中，Son类继承了Parent类。&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Son&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;extends&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;Parent&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;用UML类图表示如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4794520547945205&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKKQkvC7ribMFdCL39APRxq0zoNlSBicD9ibCPxyVlbO7zoicjZicASicCFbRw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;h3&gt;实现关系&lt;/h3&gt;&lt;p&gt;&lt;span&gt;实现关系&lt;/span&gt;是指接口及其实现类之间的关系。在UML类图中，实现关系用&lt;span&gt;空心三角&lt;/span&gt;和&lt;span&gt;虚线&lt;/span&gt;组成的箭头来表示，从&lt;span&gt;实现类指向接口&lt;/span&gt;，&lt;/p&gt;&lt;section&gt;下面的例子中，Dog类实现了了Animal类。&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;interface&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;Animal&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;implements&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;Animal&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;用UML类图表示如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44976076555023925&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKVUDGiczN8JbnS9UibKaELjausIgRVpxwbhvaWPkOX2pq0EyQCHjjNicnQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;聚合关系&lt;/h3&gt;&lt;p&gt;&lt;span&gt;聚合关系&lt;/span&gt;是一种特殊的关联关系，表示的是整体和部分的关系，整体与部分具有各自的生命周期,即使整体没有了，部分还能存在，典型的例子就是，公司部门与员工的关系，一个部门撤消了，员工还能存在。&lt;/p&gt;&lt;p&gt;在UML图中，聚合关系用空心菱形加实线箭头表示，&lt;span&gt;空心菱形&lt;/span&gt;在整体一方，&lt;span&gt;箭头&lt;/span&gt;指向部分一方。&lt;/p&gt;&lt;section&gt;如下所示&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Department&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;Employee employee&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;其对应的UML类图如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46026986506746626&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKJMRZ6iaZGRRHcuPM7zFiaZDbSstaKXc1hdqF5iaSokunSOxNOE5DibcgMg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;组合关系&lt;/h3&gt;&lt;p&gt;和聚合关系类似，&lt;span&gt;组合关系&lt;/span&gt;表示的也是整体与部分的关系，但&lt;span&gt;不同于聚合关系&lt;/span&gt;的是:组合关系中，&lt;span&gt;整体与部分不可以分开&lt;/span&gt;，一旦整体对象不存在，部分对象也将不存在，部分对象与整体对象之间具有同生共死的关系。&lt;/p&gt;&lt;p&gt;组合关系和聚合关系不关概念很像，它们的UML类图表示也很像，&lt;span&gt;在UML图中，组合关系用&lt;/span&gt;&lt;span&gt;实心菱形&lt;/span&gt;&lt;span&gt;加实线箭头表示，实心菱形在整体一方，箭头指向部分一方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;举个例子，比如人的头（Head）和嘴巴（Mouth），嘴巴是头的组成部分之一，一旦头没了，嘴巴也没了，因此头和嘴巴是组合关系，对应的java代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Mouth&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Head&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Mouth mouth;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;其UML类图表示如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4314868804664723&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKRwDlvLAQ0Vib8yfKaBduJPpZsDOfVVvklbCCID98LqJJVcgKx1pGKkw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在Java代码形式上，&lt;/span&gt;&lt;span&gt;聚合和组合&lt;/span&gt;&lt;span&gt;关系中的&lt;/span&gt;&lt;span&gt;部分对象是整体对象&lt;/span&gt;&lt;span&gt;的一个&lt;/span&gt;&lt;span&gt;成员变量&lt;/span&gt;&lt;span&gt;，仅从类代码本身是区分不了聚合和组合的。如果一定要区分，那么需要结合业务角度上来看，如果作为整体的对象必须要部分对象的参与，才能完成自己的职责，那么二者之间就是组合关系，否则就是聚合关系。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;依赖关系&lt;/h3&gt;&lt;p&gt;&lt;span&gt;依赖（Dependency）&lt;/span&gt;关系是一种弱关联关系。如果对象A用到对象B，但是和B的关系不是太明显的时候，就可以把这种关系看作是依赖关系。如：工人(Worker)要去拧螺丝，要依赖螺丝刀(Screwdriver)来帮助你完成拧螺丝的工作&lt;/p&gt;&lt;p&gt;依赖关系在Java中的具体代码表现形式为B为A的构造器或方法中的局部变量、方法或构造器的参数、方法的返回值，或者A调用B的静态方法。&lt;/p&gt;&lt;p&gt;在UML类图中，依赖关系用一个&lt;span&gt;带虚线的箭头&lt;/span&gt;表示，由&lt;span&gt;使用方指向被使用方&lt;/span&gt;，可以看下面的例子。&lt;/p&gt;&lt;section&gt;java代码：&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Screwdriver&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Worker&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//Screwdriver对象作为Worker类方法的参数，构成依赖关系&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;screw&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;Screwdriver screwdriver&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;){&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;对应的UML类图表示如下：&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47334410339256866&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKduVrLBl3QgEcImAdaqNlsB3z1zSeZORfthapwsx7QbTywNYW95mv0w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;经过上面的介绍，相信大家对UML类图已经有比较好的理解了，最后给大家介绍一个可以免费画UML类图的在线工具：&lt;/span&gt;&lt;span&gt;https://www.processon.com/，本文的所有例子都是在这上面画的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;最后，在网上找到一张对于类图比较综合的例子（如有侵权，请联系我删除），它将我们前面介绍的内容都联系起来，如下图所示，大家可以对照着理解&lt;/span&gt;&lt;span&gt;图&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;各个&lt;/span&gt;&lt;span&gt;类之间的关系：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9933065595716197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qxCPEjAQyqbKDicic1SHT4MeKrTicRsDreFibBJZxL1XS0MDDqzRZd0RxGqLh3EY0SjVrPNle8GfsUxRQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文源码地址：&lt;br/&gt;https://github.com/qinlizhong1/javaStudy/tree/master/DesignPattern/src/graph&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;本文示例代码环境：&lt;br/&gt;操作系统：macOs 12.1&lt;br/&gt;JDK版本：12.0.1&lt;br/&gt;maven版本: 3.8.4&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;span mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;— &lt;strong mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;完&lt;/strong&gt; —&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;30&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;span mp-original-font-size=&quot;14.079999923706055&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;section mp-original-font-size=&quot;14.079999923706055&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;span mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;欢迎关注原创技术号↓&lt;/strong&gt;&lt;strong mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;27.19999885559082&quot;&gt;&lt;section&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5NTEwNTk2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ldJ288bl0qyHbrgbic86ZUMAOA1zPJrQTNTA56XkLkl7T44eeoYqP6WNskSwUoJWT68Yzdz0sRyl2mGkuPLVFqQ/0?wx_fmt=png&quot; data-nickname=&quot;非科班大厂码农&quot; data-alias=&quot;&quot; data-signature=&quot;混迹于BAT的非科班程序员，以java为载体，介绍数据库、缓存、搜索引擎、设计模式、架构等技术栈，让我们从小白走向架构师~&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-id=&quot;us2339328&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section data-width=&quot;40%&quot; mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;section mp-original-font-size=&quot;16&quot; mp-original-line-height=&quot;25.600000381469727&quot;&gt;&lt;span&gt;&lt;strong data-style=&quot;box-sizing: border-box; color: rgb(0, 122, 170); font-size: 20px; letter-spacing: 0.54px; max-width: 100%; overflow-wrap: break-word;&quot; mp-original-font-size=&quot;20&quot; mp-original-line-height=&quot;32&quot;&gt;&lt;span mp-original-font-size=&quot;20&quot; mp-original-line-height=&quot;32&quot;&gt;如有帮助，辛苦点赞和在看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76e8f392b76e566443203f43a023264a</guid>
<title>千万级乘客排队系统重构&amp;压测方案——总结篇</title>
<link>https://toutiao.io/k/qjesxr7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、 前言&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发布上篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5NTg1ODg2MQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=65019d4697f39ba76d1fd0f04f30cf2d&amp;amp;chksm=fe6ac787c91d4e916c64e05681c7f4b98403576ac7216853530623d9fe2e3fc8c5625673b80a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;线上真实排队系统重构案例分享——实战篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;线上真实排队系统重构案例分享——实战篇&lt;/a&gt;之后，一些朋友问我们重构进度咋样了，截至目前，我们乘客排队系统重构已经上线，并且灰度1个月了，目前已稳定运行，从目前结果来看，还是远超预期的。这篇文章主要讲一讲，乘客排队场景压测方案以及个人的一些总结。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、 如何评估一个排队系统性能&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于排队系统压测，也是和运维同学，测试同学碰撞了挺久，大家各执己见。因为之前，也没有对排队系统性能真正的评估，没有标准。我结合目前线上场景(目前排名前10城市)，分析如下:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;乘客排队形成排队时机高峰期，时间段(8:00~ 10:00 18:00~19:00 21:00~23:00)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;排队平均等待时间(出队时间-入队时间)
1min ~ 5min&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高峰期各大城市进入排队比例(排队订单量/当天订单总量) 10% ~ 38%&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可知，排队性能评估指标——5分钟时间窗口支持最大排队数量(取极限值5min)。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、 压测目标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前:  乘客排队开全国，10% ~ 38%订单进排队，我们按50%进排队计算，目前高峰期3万/QPM,  计算得:3万 * 5 * 0.5 = 7.5万&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目标: 按目前订单量翻5倍目标压测，即5分钟内，支持37.5万订单同时排队&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、压测步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;&lt;th&gt;步骤&lt;/th&gt;&lt;th&gt;观测指标&lt;/th&gt;&lt;th&gt;操作&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;01&lt;/td&gt;&lt;td&gt;下单后派单——历史流程&lt;/td&gt;&lt;td&gt;历史流程5min支持最大排队订单数量，接口QPS情况&lt;/td&gt;&lt;td&gt;关闭开关，订单排队5min取消&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;02&lt;/td&gt;&lt;td&gt;下单后派单——新流程&lt;/td&gt;&lt;td&gt;新流程5min支持最大排队订单数量，接口QPS情况&lt;/td&gt;&lt;td&gt;开启开关，订单排队5分钟取消&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;历史流程5min同时入队量到达10W订单时，接口出现大量超时异常，到达性能瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新流程情况如下—— 5min内入队50W订单排队，无异常，此时重要接口情况如下:&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;接口&lt;/th&gt;&lt;th&gt;目前QPS&lt;/th&gt;&lt;th&gt;压测目标&lt;/th&gt;&lt;th&gt;压测QPS&lt;/th&gt;&lt;th&gt;平均RT&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;入队&lt;/td&gt;&lt;td&gt;300&lt;/td&gt;&lt;td&gt;1500&lt;/td&gt;&lt;td&gt;3000&lt;/td&gt;&lt;td&gt;12ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;出队&lt;/td&gt;&lt;td&gt;300&lt;/td&gt;&lt;td&gt;1500&lt;/td&gt;&lt;td&gt;3000&lt;/td&gt;&lt;td&gt;40ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;是否在队列中&lt;/td&gt;&lt;td&gt;3000&lt;/td&gt;&lt;td&gt;15000&lt;/td&gt;&lt;td&gt;15000+&lt;/td&gt;&lt;td&gt;4ms&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查询排队位置&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;8500&lt;/td&gt;&lt;td&gt;8ms&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、乘客排队重构新老对比&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;5min同时排队订单数量&lt;/th&gt;&lt;th&gt;单蜂巢支持最大队列数&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;重构前&lt;/td&gt;&lt;td&gt;&amp;lt;10W&lt;/td&gt;&lt;td&gt;&amp;lt;1000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;重构后&lt;/td&gt;&lt;td&gt;&amp;gt;50W&lt;/td&gt;&lt;td&gt;无限制&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重构后查询接口平均RT整体降低65%，更新接口平均RT降低40%,且无性能瓶颈，后期可水平扩展。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六 总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次重构开发人力只投入了2人(人力有限)，开发时间只用了7天，一共20多个接口改造，3个定时任务脚本，外加后台配置管理。在时间紧，任务重的前提下，依然有条不紊地进行，后面测试阶段测试反馈bug也很少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截至目前，主导重构项目已经有6~7个了，重构做多了，也已经形成自己的套路和方法，方案已经很成熟了，很多细节上的坑可以避免。这里，也欢迎系统遇到瓶颈或者有重构需求，遇到困难的朋友一起交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注&quot;浅谈架构&quot;公众号，不定期分享原创技术文章。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kulR6Bq67WicS8obXBjC9RqxibSJcgOsnicwSlKjFSxuEECwjZjYS8Y9zpmCdyv6z4yeSicSQSDNz2XUzRppBjuGXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;file&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                  &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                    &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                  &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                  &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                &lt;/div&gt;
                                              
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>74e695ce0864641847f05dca2f2bd02f</guid>
<title>全链路压测改造之全链自动化测试实践</title>
<link>https://toutiao.io/k/kmh9i75</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;本期作者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3064771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTzOBwcGZGeopabI7c33JJo3TxbJA0yIoIDk0cCksP1ILS2ib4EjO90Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;李思佳&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;bilibili资深测试开发工程师&lt;/p&gt;&lt;p&gt;2020年加入B站，深度参与全链路压测、多活、混沌工程等专项的建设和实践。&lt;/p&gt;&lt;p&gt;深耕系统稳定性测试领域。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01 背景与意义&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;B站直播营收送礼业务有着高写、在跨晚和S赛等大型活动下流量陡增、数据实时性要求高等特性，传统压测对于写场景为了避免影响线上数据做了各种屏蔽和黑名单处理，有着无法逼近线上真实情况的问题，因此业务对全链路压测有着较大的诉求，需要通过全链路压测来系统性地评估服务容量，发现瓶颈和隐患。&lt;/p&gt;&lt;p&gt;对于该诉求，直播技术侧结合公司的全链路压测方案，对营收送礼业务进行了全链路压测的服务改造。整个过程涉及到营收核心服务、底层中间件、压测sdk、压测控制台、施压平台等多处改造，链路长、配置多、影响的业务广，对质量方面的要求非常高，测试面临了比较大的挑战。一方面，要保障全链路压测安全可控，各个改造节点均需确保正确可靠，另一方面因底层改动带来的上层业务测试回归量巨大，测试效率难以保证。基于以上痛点，我们设计了全链自动化的测试方案，并与项目一起实践落地。接下来，我们来详细介绍下该方案的设计，希望能对一些正在或即将进行全链路压测建设的团队在质量保障工作上带来一些灵感和参考。&lt;/p&gt;&lt;p&gt;首先，我们先来介绍下业内普遍的全链路压测方案以及B站采用的方案，再基于具体的改造点来看测试范围。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 1.1 行业内全链路压测方案对比&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案一：流量混布, 存储隔离, 线上施压&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;对线上服务压测，压测前根据容量预估和压测目标，对线上服务进行扩容和cpu、mem等相关配置的变更。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;压测产生的数据与线上真实数据做隔离，采用影子库表的方式，防止污染线上真实存储。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;需构造压测数据和压测流量，通过压测标记来区分流量属性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案二：对数据本身做标记, 逻辑隔离，线上施压&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案三：镜像环境 OR 线下压测 &lt;/span&gt;&lt;/strong&gt;             &lt;/p&gt;&lt;p&gt;技术同学经过调研，基于当前业务的语言栈较统一、基础组件较统一以及服务治理较完善等特点，选择了方案一作为B站的全链路压测方案。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 1.2 B站全链路压测方案介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;B站的全链路压测方案在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc0NTgwMg==&amp;amp;mid=2247487413&amp;amp;idx=1&amp;amp;sn=2a667abc5ac50985642d1f3300747e1b&amp;amp;chksm=cf2cca90f85b4386f72cfe9a73a061b04c84849cbebcfe91f6c05216d9c346393de779d7dfb9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站在全链路压测上的实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;B站在全链路压测上的实践&lt;/span&gt;&lt;/a&gt;一文中有详细介绍，简单来说主要为流量混部、线上压测和存储隔离三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流量混部&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;- 与线上集群资源共用，在深夜低峰时期进行线上压测&lt;/p&gt;&lt;p&gt;- 通过流量打标的方式对流量进行区分，压测流量均带有压测标识，支持对http请求和grpc请求打标进行全链路压测&lt;/p&gt;&lt;p&gt;- 服务接入压测sdk，对压测流量进行识别、拦截和处理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;线上压测&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;- 通过公司的压测平台，进行压测任务和场景设计、压测数据构造以及压测结果分析等，具体压测平台的设计及原理在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc0NTgwMg==&amp;amp;mid=2247486677&amp;amp;idx=1&amp;amp;sn=46325046c76586d566ad1291ae12c2cb&amp;amp;chksm=cf2cc9f0f85b40e6e8e8a6f0cedb396382afcf5a4ccbb729c13962109de0bfd182008d0e63fe&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站压测实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;B站压测实践&lt;/span&gt;&lt;/a&gt;一文中有详细介绍。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;存储隔离&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;- 我们采用存储隔离的手段，对db创建影子表，redis创建影子key，mq创建影子topic，将压测流量完全隔离&lt;/p&gt;&lt;p&gt;- 搭建全链路压测配置控制台，管理压测规则，主要涉及对已接入全链路压测的服务的以下几点配置：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;△ 需要压测的接口&lt;/p&gt;&lt;p&gt;△ 压测接口依赖的下游接口的透传/镜像/Mock规则&lt;/p&gt;&lt;p&gt;△ 数据库表的透传/镜像/写丢弃规则&lt;/p&gt;&lt;p&gt;△ 缓存的透传/镜像规则&lt;/p&gt;&lt;p&gt;△ 消息队列的透传/拦截/镜像规则&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTDibysFibxdpRbomhvZptPWpYrxIIN8O1Pgow7enfeOF4nz3LIvvib2ibKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;直播的全链路压测架构图如下，可以看到整体链路，由压测平台施压，被压测的服务接入压测sdk，获取到由压测规则控制台下发的压测配置信息，根据配置信息对接收到的压测流量做处理，如配置了镜像规则的数据表，压测数据写入影子表，对配置了镜像规则的redis,压测的缓存数据写入影子key等等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9314815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTYAwK5J6b2rWcUK1DoicweO0Ej46tZViaJicV65rFjfadqia60XlHoO9Z9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对此链路上如此多的服务改造点（SQL改造、redis改造、databus改造、job改造、context改造、go channel改造、sync/pipeline改造...），如何能&lt;span&gt;又快又好又全面&lt;/span&gt;的测试覆盖，是我们设计全链自动化测试方案的初衷，我们将其主要分为三个阶段。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一阶段&lt;/span&gt;&lt;/strong&gt;，我们对各个新增节点分别做了测试保障，如&lt;span&gt;mirror sdk&lt;/span&gt;、压测配置控制台等，保正底层基础能力的正确性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二阶段&lt;/span&gt;&lt;/strong&gt;，当基础建设已完成，进入到了业务接入及全流程验证阶段。业务是不停迭代的，其中随着基架的不断演进，业务所涉及的服务也包含了部分历史债，当此套框架真正接入业务后，我们往往在业务实际使用中会发现很多不适配的地方，包括框架设计不够健壮或者业务的使用姿势不规范等原因，需要修复或兼容。这个阶段的测试也是最繁琐、测试量最大、重复性很高的地方，为此全链自动化测试全面应用于此阶段，来提升效率及业务覆盖度。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三阶段&lt;/span&gt;&lt;/strong&gt;，主要应对于未来的拓展，随着全链路压测覆盖的业务越来越多，当”常态化“的全链路压测计划提上日程，重复的工作和人力成本随之增加。此时测试工具更需要平台化及可视化，为压测前、压测中、压测后各个阶段的重复工作提供有效的自动化支持。&lt;/p&gt;&lt;p&gt;接下来，我们详细介绍在第一和第二阶段中，测试方案的设计及应用。&lt;/p&gt;&lt;p&gt;注释：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;压测配置控制台：全链路压测配置中心，配置被测服务、被测接口、下游依赖接口、被测接口涉及到的缓存、数据库、消息队列。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;mirror sdk：为大仓提供的压测控制sdk，通过配置文件可以直接控制数据库、缓存、消息队列等组件对压测流量进行处理。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 1.3 全链自动化测试方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们主要遇到的测试难点如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;改造均为核心业务，涉及改造的服务数多、接口数多，测试量大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;改造非常底层，涉及mysql、tidb、redis、databus等中间件，业务逻辑分支多，传统手动测试很难高效全面覆盖。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;改造的服务涉及的依赖和配置多，中间任何节点的错误均可能导致在压测实施时影响到线上，如配置遗漏可能导致数据写到线上库、sdk故障可能导致压测标失效等，需要在压测前的进行“扫雷”。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;设计方向思考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;全链自动化方案设计主要包含以下三个部分&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5166667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXT37M2zvrNEopCCFaG4bic2VBQibkHakQD36zjd7ptgpBY56icdiavsg4xFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02 主要测试过程与实施&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 2.1 链路梳理分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;链路梳理是保障全链路压测安全实施的前提，服务改造、压测配置、自动化校验等工作都&lt;strong&gt;&lt;span&gt;强依赖&lt;/span&gt;&lt;/strong&gt;链路梳理与分析，梳理工作非常繁琐，使用传统翻代码的手段不仅低效，而且容易遗漏而引发安全事故。这里我们主要采用动静结合的方式来完成链路梳理工作。&lt;/p&gt;&lt;p&gt;工具：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;trace追踪：全链路跟踪系统，提供分布式环境下服务调用链监控，还原请求调用关系。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动化代码规范扫描与检查工具bilicontextcheck lint：检查代码中不规范使用context的地方以及是否有context传递中断的场景。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;静态扫描：调用链中容易出现因ctx使用不规范导致调用链断裂的情况，对此使用bilicontextcheck lint工具用来检查业务代码中ctx不规范的地方，确保调用链不会断，压测标识能完整传递。&lt;/p&gt;&lt;p&gt;链路追踪：依赖链路追踪工具可视化的返回服务链路的依赖关系，各节点对数据库、缓存、消息队列的调用信息等，以下是使用示例。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3824074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTgM1QxPkrzFPF9QKVSdEGwsibXwrQDJznia02hWrrRTJyZTbFaS0ugHwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上两个阶段，我们完成了大部分梳理工作，但由于业务实际代码逻辑的实现过于复杂和多样，为了保证梳理工作更全面且不遗漏，我们最后加上人工check代码的方式做补充，打通链路完整性梳理的“最后一公里”。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 2.2 压测配置确认&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过对业务的链路分析，我们明确了具体的压测范围，业务的服务依赖关系，接着需要在压测控制台进行整个链路的压测规则配置，涉及服务的接口配置、依赖接口配置、数据库配置、缓存配置、消息队列配置，根据实际业务场景配置透传、镜像、写丢弃、Mock等规则。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.262963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXT80RmIv8ysDEeXvvzMtiba3iaOkVpMmdhh0Vkhf0dppWuk8uGtWbibl86g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 2.3 自动化校验&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;测试覆盖率和效率的提升，均离不开自动化测试，因此，测试改造工作也基本围绕&quot;自动化&quot;来展开。在基架改造、业务服务改造、压测配置、服务部署等工作都完成后，将进入测试验证阶段。本阶段主要通过自动化的手段对业务进行正确性验证，两套流量均需包含以下内容的检查：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;接口返回校验：response结果需符合业务预期，输入/输出参数检验、格式校验、容错处理、安全检验等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接口存储校验：mysql、tidb、redis的读写符合业务预期&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务异步流程校验：确认压测标识全链路透传，压测流量和正常流量在异步流程下trace均能正常关联，比如送礼链路的异步结算流程，在送礼接口调用完成后，可通过订单id查询结算表数据来验证结算是否异步调用成功&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;链路完备性校验：结合压测控制台规则，对接口的调用链路进行自动校验&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化实施的关键key&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;要实现以上功能，我们需要对已有的自动化框架进行改造，保持原自动化case能复用的基础上，增加压测流量构造、链路完备性检测等功能，以下是我们团队自动化框架的分层设计图，红色部分为本次的框架改造点。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4826667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXT9KblW0CdnvkQcrkTjQTiaBHeMPboq4pibNTARPLjKr0HaDdy1b8mbCTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化框架分层设计&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;通过上图，可以看到我们的自动化测试框架分为三层结构设计，最上层为case层，按业务做单接口用例和场景用例的编排，中间层为invoker层，做请求封装(http&amp;amp;grpc)、配置管理、断言、中间件连接等基础功能封装和聚合，最底层coverage层包含grpc和php服务测试覆盖率统计功能，本次改造在原有测试框架上进行，对框架的核心改造如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;增加压测标识“mirror”，通过全局变量 config.mirror 控制流量入口，设计压测标识的从上到下透传。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在invoker层封装链路检测工具集“trace_toolset”，进行链路完备性检查。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在invoker层封装http/grpc请求，request header中增加压测标识mirror。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化框架改造 — 入口改造&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;使框架能支持压测流量的构造，在流量构造层使用全局变量控制流量入口，能一键切换流量指向正常环境还是全链路压测环境。&lt;br/&gt;改造点：在配置文件config中增加压测标识：config.mirror，默认值为空（若值为空则识别为正常流量）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7340659&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTrvI3b6qujHibSOMPDGydibGzLhm4QoGNzM0G7Pxh9erIJ0rztVpxx8Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化框架改造 — 压测数据构造&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;压测写场景，往往涉及到要对压测的上游数据进行构造，如送礼场景，需要压测用户的钱包有余额，压测前需要在相关的影子表插入数据，这类型case属于压测前的数据准备工作，需识别并进行构造。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化框架改造 — 自动化链路完备性校验&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;链路完备：需要确保调用链路完整且染色标不能中断，保障方案分静态收敛和动态收敛两种策略，基于业务验证占据80%+工作量，此验证过程必须尽可能的自动化，为此我们引入链路检测工具集“trace_toolset”，自动进行链路完备性检查。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4388889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTcvhA41Eksrt3k5l6n283TNCDla0gbMvzGRuUPo6ibBibiba6a9sDIGQNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;trace_toolset&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于接口链路的唯一标识traceid，从链路追踪工具中获取链路的各个节点，结合压测规则配置控制台的配置，依次检查调用链中的mysql、tidb、redis、databus的调用是否符合预期，分别对正常流量和压测流量两套规则进行检测，对于校验结果回传至上层case，输出测试报告，以下是链路检查工具与自动化框架结合下的调用流程。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2527778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXT6BlHpu903xmxzzqt3l8iapOh0J3nia2xRUgjSibl0pia5rnuqaVeefs9rA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;自动化case改造复用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于服务改造范围大、涉及的接口多、链路长的特性，怎么提升测试效率以及回归效率（底层bugfix回归）是需要解决的一大难题，本次方案主要采用case复用的思路来解决效率问题，复用已有业务沉淀的自动化case，在此基础上，保持case中间部分业务结构不变，通过mirror识别，仅修改头部流量入口和尾部规则校验方法，让case能复用于压测流量，快速将case翻倍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4611111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXT5ZgOtShjcicGhafQponibggSX5pflGHcgafM8YFDzdjzmd35If6wX5ZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03 案例实践&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.1 业务场景和服务依赖梳理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;梳理压测接口的服务依赖大盘，以下是某场景的服务依赖关系图，通过服务依赖关系确认哪些服务需要接入压测：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3388889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTbJKrT5ffp0TVjJibpAO8BEjJBvWCzy6WpP72YLaotibcLdnEx3Jr3B2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;根据深度遍历：定位到某个服务依赖其他服务的接口，对链路上的每个接口以及接口涉及的db、redis、databus做确认。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8160271&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTEDSlXbtJqMAibFLQd511X1I5JnESANwEPKd4d2sB7MrRNU5J7YfhyWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;886&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.2 服务压测配置&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于梳理出来的链路关系在压测配置控制台进行配置，需根据实际业务场景配置透传、镜像、丢弃等规则。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.3 业务自动化测试&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;正常流量自动化业务验证&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;压测流量自动化业务验证&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务逻辑、存储、trace完备性检查&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.4 问题排查与修复&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于运行失败的自动化case进行排查与修复，测试过程中主要可以发现以下4类问题：业务涉及的服务代码问题、配置问题、sdk&amp;amp;压测控制台问题、基架问题等。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.5  预发验证，灰度部署上线&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;制定上线流程、进行风险评估和应急预案准备，实时监控上线过程， 确保业务安全无损上线。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTheDH6YiclR7Od74dE3AclMgCaqYsy4Y28gRfT01lYqb2icxibIMRBwiaaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.6 线上全链路压测执行，压测结果分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;业务进行线上全链路压测，通过压测平台进行施压，发现潜在的业务风险。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt; 3.7 全链路瓶颈分析与优化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对全链路压测过程中发现的异常点逐个进行排查与分析，探索系统瓶颈和隐患，确保业务服务的稳定性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0314815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1BMf5Ir754QsvjWMiafsXLIxPicYXsSBXTDJQB5CWxzF1VAHyOYEl9hzhq9jkjyqaHsEkOx4crIa0UXT8CNnehbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;未完待续&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于全链自动化测试方案的第三阶段，面对未来可能出现的由业务”常态化“全链路压测带来的人力成本高、重复工作多等问题，我们的测试工具也在持续建设以贯穿整个压测生命周期，第三阶段的方案在后面的实践中我们再来为大家深度分享。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bf44c7bb57738a4b8df6787381c64bef</guid>
<title>高并发架构解决春节抢火车票难题</title>
<link>https://toutiao.io/k/liozvvz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;大家好，我是Tom哥。&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网上看到一篇讲 12306 抢票的文章，我看完后，觉得文章写很完整。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅给出了模拟场景的代码，而且也用压测工具测试了并发情况，是一个很好的学习案例，分享给大家共读。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.200854700854701&quot; data-type=&quot;png&quot; data-w=&quot;468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdJM8x13a2bVIynCsNCK4mHwoT3adcnaXfFIicyDpRCQjaXS5k2bJsByApbJPNwV8PgsClGlXAo0uA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;12306抢票，极限并发带来的思考&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然现在大多数情况下都能订到票，但是放票瞬间即无票的场景，相信大家都深有体会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尤其是春节期间，大家不仅使用 12306，还会考虑“智行”和其他的抢票软件，全国上下几亿人在这段时间都在抢票。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“12306 服务”承受着这个世界上任何秒杀系统都无法超越的 QPS，上百万的并发再正常不过了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者专门研究了一下“12306”的服务端架构，学习到了其系统设计上很多亮点，在这里和大家分享一下并&lt;strong&gt;&lt;span&gt;模拟一个例子&lt;/span&gt;&lt;/strong&gt;：如何在 100 万人同时抢 1 万张火车票时，系统提供正常、稳定的服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大型高并发系统架构&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;高并发的系统架构都会采用分布式集群部署，服务上层有着层层负载均衡，并提供各种容灾手段（双火机房、节点容错、服务器灾备等）保证系统的高可用，流量也会根据不同的负载能力和配置策略均衡到不同的服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下边是一个简单的示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6205733558178752&quot; data-w=&quot;593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9J8hQicqicMYNlHuPDGWhMOP1kpfcwopVW9vic5mPWlHzWbj1sz1c9mekA/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;负载均衡简介&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图中描述了用户请求到服务器经历了三层的负载均衡，下边分别简单介绍一下这三种负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;①OSPF（开放式最短链路优先）是一个内部网关协议（Interior Gateway Protocol，简称 IGP）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSPF 通过路由器之间通告网络接口的状态来建立链路状态数据库，生成最短路径树，OSPF 会自动计算路由接口上的 Cost 值，但也可以通过手工指定该接口的 Cost 值，手工指定的优先于自动计算的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSPF 计算的 Cost，同样是和接口带宽成反比，带宽越高，Cost 值越小。到达目标相同 Cost 值的路径，可以执行负载均衡，最多 6 条链路同时执行负载均衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;②LVS （Linux Virtual Server）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是一种集群（Cluster）技术，采用 IP 负载均衡技术和基于内容请求分发技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;③Nginx&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想必大家都很熟悉了，是一款非常高性能的 HTTP 代理/反向代理服务器，服务开发中也经常使用它来做负载均衡。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 实现负载均衡的方式主要有三种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们就针对 Nginx 的加权轮询做专门的配置和测试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx 加权轮询的演示&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 实现负载均衡通过 Upstream 模块实现，其中加权轮询的配置是可以给相关的服务加上一个权重值，配置的时候可能根据服务器的性能、负载能力设置相应的负载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一个加权轮询负载的配置，我将在本地的监听 3001-3004 端口，分别配置 1，2，3，4 的权重：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;#配置负载均衡&lt;br/&gt;    upstream load_rule {&lt;br/&gt;       server 127.0.0.1:3001 weight=1;&lt;br/&gt;       server 127.0.0.1:3002 weight=2;&lt;br/&gt;       server 127.0.0.1:3003 weight=3;&lt;br/&gt;       server 127.0.0.1:3004 weight=4;&lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;    server {&lt;br/&gt;    listen       80;&lt;br/&gt;    server_name  load_balance.com www.load_balance.com;&lt;br/&gt;    location / {&lt;br/&gt;       proxy_pass http://load_rule;&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在本地 /etc/hosts 目录下配置了 www.load_balance.com 的虚拟域名地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来使用 Go 语言开启四个 HTTP 端口监听服务，下面是监听在 3001 端口的 Go 程序，其他几个只需要修改端口即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;os&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;strings&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    http.HandleFunc(&lt;span&gt;&quot;/buy/ticket&quot;&lt;/span&gt;, handleReq)&lt;br/&gt;    http.ListenAndServe(&lt;span&gt;&quot;:3001&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//处理请求函数,根据请求将响应结果信息写入日志&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handleReq&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    failedMsg :=  &lt;span&gt;&quot;handle in port:&quot;&lt;/span&gt;&lt;br/&gt;    writeLog(failedMsg, &lt;span&gt;&quot;./stat.log&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//写入日志&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;writeLog&lt;/span&gt;&lt;span&gt;(msg &lt;span&gt;string&lt;/span&gt;, logPath &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, &lt;span&gt;0644&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; fd.Close()&lt;br/&gt;    content := strings.Join([]&lt;span&gt;string&lt;/span&gt;{msg, &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;}, &lt;span&gt;&quot;3001&quot;&lt;/span&gt;)&lt;br/&gt;    buf := []&lt;span&gt;byte&lt;/span&gt;(content)&lt;br/&gt;    fd.Write(buf)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我将请求的端口日志信息写到了 ./stat.log 文件当中，然后使用 AB 压测工具做压测：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ab -n 1000 -c 100 http://www.load_balance.com/buy/ticket&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统计日志中的结果，3001-3004 端口分别得到了 100、200、300、400 的请求量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这和我在 Nginx 中配置的权重占比很好的吻合在了一起，并且负载后的流量非常的均匀、随机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的实现大家可以参考 Nginx 的 Upsteam 模块实现源码，这里推荐一篇文章《Nginx 中 Upstream 机制的负载均衡》：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://www.kancloud.cn/digest/understandingnginx/20260&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;秒杀抢购系统选型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到我们最初提到的问题中来：火车票秒杀系统如何在高并发情况下提供正常、稳定的服务呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的介绍我们知道用户秒杀流量通过层层的负载均衡，均匀到了不同的服务器上，即使如此，集群中的单机所承受的 QPS 也是非常高的。如何将单机性能优化到极致呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要解决这个问题，我们就要想明白一件事：&lt;/span&gt;通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们系统要做的事情是要保证火车票订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个阶段的先后顺序该怎么分配才更加合理呢？我们来分析一下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下单减库存&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1436077057793345&quot; data-w=&quot;571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9fMZB8VgfOOytGu3lhb9oD5devWWUHjkaKZ7jK80m2SQnxsHesUyK8g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种顺序是我们一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样也会产生一些问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制 IP 和用户的购买订单数量，这也不算是一个好方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;支付减库存&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1436077057793345&quot; data-w=&quot;571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW93oaVcxUicLx5s5Ps0sdSwVJqy8oX4FSTRvcicGDAaFJyqGk1FS5fFDzQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预扣库存&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6830985915492958&quot; data-w=&quot;426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9JcX0CkXibxSgGVhFCz2nLgUeZjtCE2sR4xZr0tNet7IDwuFpVrYJjyw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库 IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么有没有一种不需要直接操作数据库 IO 的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费队列中处理，订单量比较少的情况下，生成订单非常快，用户几乎不用排队。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;扣库存的艺术&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的分析可知，显然预扣库存的方案最合理。我们进一步分析扣库存的细节，这里还有很大的优化空间，库存存在哪里？怎样保证高并发下，正确的扣库存，还能快速的响应用户请求？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单机低并发情况下，我们实现扣库存通常是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4076086956521739&quot; data-w=&quot;368&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9TQXCPIRu2281edE1tMuZvfI8mXE5MBMYJ7lB4TzvzwGAu95iaTFSCzQ/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了保证扣库存和生成订单的原子性，需要采用事务处理，然后取库存判断、减库存，最后提交事务，整个流程有很多 IO，对数据库的操作又是阻塞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式根本不适合高并发的秒杀系统。接下来我们对单机扣库存的方案做优化：本地扣库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把一定的库存量分配到本地机器，直接在内存中减库存，然后按照之前的逻辑异步创建订单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改进过之后的单机系统是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3268101761252446&quot; data-w=&quot;511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9mMlbCf8DJibI9EmfsoCvudjFxSn48nWUFEAI8SY5zCichZAKdQNlaK2g/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就避免了对数据库频繁的 IO 操作，只在内存中做运算，极大的提高了单机抗并发的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是百万的用户请求量单机是无论如何也抗不住的，虽然 Nginx 处理网络请求使用 Epoll 模型，c10k 的问题在业界早已得到了解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 Linux 系统下，一切资源皆文件，网络请求也是这样，大量的文件描述符会使操作系统瞬间失去响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们提到了 Nginx 的加权均衡策略，我们不妨假设将 100W 的用户请求量平均均衡到 100 台服务器上，这样单机所承受的并发量就小了很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们每台机器本地库存 100 张火车票，100 台服务器上的总库存还是 1 万，这样保证了库存订单不超卖，下面是我们描述的集群架构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46747352496217853&quot; data-w=&quot;661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9SiaQEGuyP4EJXiczK0a0KgoPmibjjH2BodSGNOb6e00ksOIFOVjibTo2gw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题接踵而至，在高并发情况下，现在我们还无法保证系统的高可用，假如这 100 台服务器上有两三台机器因为扛不住并发的流量或者其他的原因宕机了。那么这些服务器上的订单就卖不出去了，这就造成了订单的少卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要解决这个问题，我们需要对总订单量做统一的管理，这就是接下来的容错方案。服务器不仅要在本地减库存，另外要远程统一减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了远程统一减库存的操作，我们就可以根据机器负载情况，为每台机器分配一些多余的“Buffer 库存”用来防止机器中有机器宕机的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们结合下面架构图具体分析一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.518361581920904&quot; data-w=&quot;708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MOwlO0INfQrfowULp3xliaU43T7YCHWW9aCUqf9PSibScwFBxf1pWAAgvgALlTD6K3FPAbMw88MyF9OXqMfyJPpw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们采用 Redis 存储统一库存，因为 Redis 的性能非常高，号称单机 QPS 能抗 10W 的并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本地减库存以后，如果本地有订单，我们再去请求 Redis 远程减库存，本地减库存和远程减库存都成功了，才返回给用户抢票成功的提示，这样也能有效的保证订单不会超卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当机器中有机器宕机时，因为每个机器上有预留的 Buffer 余票，所以宕机机器上的余票依然能够在其他机器上得到弥补，保证了不少卖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Buffer 余票设置多少合适呢，理论上 Buffer 设置的越多，系统容忍宕机的机器数量就越多，但是 Buffer 设置的太大也会对 Redis 造成一定的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 内存数据库抗并发能力非常高，请求依然会走一次网络 IO，其实抢票过程中对 Redis 的请求次数是本地库存和 Buffer 库存的总量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当本地库存不足时，系统直接返回用户“已售罄”的信息提示，就不会再走统一扣库存的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这在一定程度上也避免了巨大的网络请求量把 Redis 压跨，所以 Buffer 值设置多少，需要架构师对系统的负载能力做认真的考量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;代码演示&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言原生为并发设计，我采用 Go 语言给大家演示一下单机抢票的具体流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;初始化工作&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Go 包中的 Init 函数先于 Main 函数执行，在这个阶段主要做一些准备性工作。&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们系统需要做的准备工作有：初始化本地库存、初始化远程 Redis 存储统一库存的 Hash 键值、初始化 Redis 连接池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还需要初始化一个大小为 1 的 Int 类型 Chan，目的是实现分布式锁的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以直接使用读写锁或者使用 Redis 等其他的方式避免资源竞争，但使用 Channel 更加高效，这就是 Go 语言的哲学：不要通过共享内存来通信，而要通过通信来共享内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 库使用的是 Redigo，下面是代码实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;...&lt;br/&gt;&lt;span&gt;//localSpike包结构体定义&lt;/span&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; localSpike&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; LocalSpike &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    LocalInStock     &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;    LocalSalesVolume &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;//remoteSpike对hash结构的定义和redis连接池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;package&lt;/span&gt; remoteSpike&lt;br/&gt;&lt;span&gt;//远程订单存储健值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; RemoteSpikeKeys &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    SpikeOrderHashKey &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;//redis中秒杀订单hash结构key&lt;/span&gt;&lt;br/&gt;    TotalInventoryKey &lt;span&gt;string&lt;/span&gt;    &lt;span&gt;//hash结构中总订单库存key&lt;/span&gt;&lt;br/&gt;    QuantityOfOrderKey &lt;span&gt;string&lt;/span&gt;   &lt;span&gt;//hash结构中已有订单数量key&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//初始化redis连接池&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewPool&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;redis&lt;/span&gt;.&lt;span&gt;Pool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;redis.Pool{&lt;br/&gt;        MaxIdle:   &lt;span&gt;10000&lt;/span&gt;,&lt;br/&gt;        MaxActive: &lt;span&gt;12000&lt;/span&gt;, &lt;span&gt;// max number of connections&lt;/span&gt;&lt;br/&gt;        Dial: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(redis.Conn, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;            c, err := redis.Dial(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, &lt;span&gt;&quot;:6379&quot;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;panic&lt;/span&gt;(err.Error())&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; c, err&lt;br/&gt;        },&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    localSpike = localSpike2.LocalSpike{&lt;br/&gt;        LocalInStock:     &lt;span&gt;150&lt;/span&gt;,&lt;br/&gt;        LocalSalesVolume: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    remoteSpike = remoteSpike2.RemoteSpikeKeys{&lt;br/&gt;        SpikeOrderHashKey:  &lt;span&gt;&quot;ticket_hash_key&quot;&lt;/span&gt;,&lt;br/&gt;        TotalInventoryKey:  &lt;span&gt;&quot;ticket_total_nums&quot;&lt;/span&gt;,&lt;br/&gt;        QuantityOfOrderKey: &lt;span&gt;&quot;ticket_sold_nums&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;    redisPool = remoteSpike2.NewPool()&lt;br/&gt;    done = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    done &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地扣库存和统一扣库存&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地扣库存逻辑非常简单，用户请求过来，添加销量，然后对比销量是否大于本地库存，返回 Bool 值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; localSpike&lt;br/&gt;&lt;span&gt;//本地扣库存,返回bool值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(spike *LocalSpike)&lt;/span&gt; &lt;span&gt;LocalDeductionStock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    spike.LocalSalesVolume = spike.LocalSalesVolume + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; spike.LocalSalesVolume &amp;lt; spike.LocalInStock&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里对共享数据 LocalSalesVolume 的操作是要使用锁来实现的，但是因为本地扣库存和统一扣库存是一个原子性操作，所以在最上层使用 Channel 来实现，这块后边会讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;统一扣库存操作 Redis，因为 Redis 是单线程的，而我们要实现从中取数据，写数据并计算一些列步骤，我们要配合 Lua 脚本打包命令，保证操作的原子性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; remoteSpike&lt;br/&gt;......&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; LuaScript = &lt;span&gt;`&lt;br/&gt;        local ticket_key = KEYS[1]&lt;br/&gt;        local ticket_total_key = ARGV[1]&lt;br/&gt;        local ticket_sold_key = ARGV[2]&lt;br/&gt;        local ticket_total_nums = tonumber(redis.call(&#x27;HGET&#x27;, ticket_key, ticket_total_key))&lt;br/&gt;        local ticket_sold_nums = tonumber(redis.call(&#x27;HGET&#x27;, ticket_key, ticket_sold_key))&lt;br/&gt;        -- 查看是否还有余票,增加订单数量,返回结果值&lt;br/&gt;       if(ticket_total_nums &amp;gt;= ticket_sold_nums) then&lt;br/&gt;            return redis.call(&#x27;HINCRBY&#x27;, ticket_key, ticket_sold_key, 1)&lt;br/&gt;        end&lt;br/&gt;        return 0&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//远端统一扣库存&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(RemoteSpikeKeys *RemoteSpikeKeys)&lt;/span&gt; &lt;span&gt;RemoteDeductionStock&lt;/span&gt;&lt;span&gt;(conn redis.Conn)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    lua := redis.NewScript(&lt;span&gt;1&lt;/span&gt;, LuaScript)&lt;br/&gt;    result, err := redis.Int(lua.Do(conn, RemoteSpikeKeys.SpikeOrderHashKey, RemoteSpikeKeys.TotalInventoryKey, RemoteSpikeKeys.QuantityOfOrderKey))&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result != &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用 Hash 结构存储总库存和总销量的信息，用户请求过来时，判断总销量是否大于库存，然后返回相关的 Bool 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在启动服务之前，我们需要初始化 Redis 的初始库存信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hmset ticket_hash_key &quot;ticket_total_nums&quot; 10000 &quot;ticket_sold_nums&quot; 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;响应用户信息&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们开启一个 HTTP 服务，监听在一个端口上：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    http.HandleFunc(&lt;span&gt;&quot;/buy/ticket&quot;&lt;/span&gt;, handleReq)&lt;br/&gt;    http.ListenAndServe(&lt;span&gt;&quot;:3005&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面我们做完了所有的初始化工作，接下来 handleReq 的逻辑非常清晰，判断是否抢票成功，返回给用户信息就可以了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;span&gt;//处理请求函数,根据请求将响应结果信息写入日志&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;handleReq&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, r *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    redisConn := redisPool.Get()&lt;br/&gt;    LogMsg := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &amp;lt;-done&lt;br/&gt;    &lt;span&gt;//全局读写锁&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; localSpike.LocalDeductionStock() &amp;amp;&amp;amp; remoteSpike.RemoteDeductionStock(redisConn) {&lt;br/&gt;        util.RespJson(w, &lt;span&gt;1&lt;/span&gt;,  &lt;span&gt;&quot;抢票成功&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;        LogMsg = LogMsg + &lt;span&gt;&quot;result:1,localSales:&quot;&lt;/span&gt; + strconv.FormatInt(localSpike.LocalSalesVolume, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        util.RespJson(w, &lt;span&gt;-1&lt;/span&gt;, &lt;span&gt;&quot;已售罄&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;)&lt;br/&gt;        LogMsg = LogMsg + &lt;span&gt;&quot;result:0,localSales:&quot;&lt;/span&gt; + strconv.FormatInt(localSpike.LocalSalesVolume, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    done &amp;lt;- &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//将抢票状态写入到log中&lt;/span&gt;&lt;br/&gt;    writeLog(LogMsg, &lt;span&gt;&quot;./stat.log&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;writeLog&lt;/span&gt;&lt;span&gt;(msg &lt;span&gt;string&lt;/span&gt;, logPath &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    fd, _ := os.OpenFile(logPath, os.O_RDWR|os.O_CREATE|os.O_APPEND, &lt;span&gt;0644&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; fd.Close()&lt;br/&gt;    content := strings.Join([]&lt;span&gt;string&lt;/span&gt;{msg, &lt;span&gt;&quot;\r\n&quot;&lt;/span&gt;}, &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;    buf := []&lt;span&gt;byte&lt;/span&gt;(content)&lt;br/&gt;    fd.Write(buf)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们扣库存时要考虑竞态条件，我们这里是使用 Channel 避免并发的读写，保证了请求的高效顺序执行。我们将接口的返回信息写入到了 ./stat.log 文件方便做压测统计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单机服务压测&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启服务，我们使用 AB 压测工具进行测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ab -n 10000 -c 100 http://127.0.0.1:3005/buy/ticket&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是我本地低配 Mac 的压测信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;This is ApacheBench, Version 2.3 &amp;lt;$revision: 1826891=&quot;&quot;&amp;gt;&lt;br/&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/&lt;br/&gt;Licensed to The Apache Software Foundation, http://www.apache.org/&lt;br/&gt;&lt;br/&gt;Benchmarking 127.0.0.1 (be patient)&lt;br/&gt;Completed 1000 requests&lt;br/&gt;Completed 2000 requests&lt;br/&gt;Completed 3000 requests&lt;br/&gt;Completed 4000 requests&lt;br/&gt;Completed 5000 requests&lt;br/&gt;Completed 6000 requests&lt;br/&gt;Completed 7000 requests&lt;br/&gt;Completed 8000 requests&lt;br/&gt;Completed 9000 requests&lt;br/&gt;Completed 10000 requests&lt;br/&gt;Finished 10000 requests&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;Server Software:&lt;br/&gt;Server Hostname:        127.0.0.1&lt;br/&gt;Server Port:            3005&lt;br/&gt;&lt;br/&gt;Document Path:          /buy/ticket&lt;br/&gt;Document Length:        29 bytes&lt;br/&gt;&lt;br/&gt;Concurrency Level:      100&lt;br/&gt;Time taken for tests:   2.339 seconds&lt;br/&gt;Complete requests:      10000&lt;br/&gt;Failed requests:        0&lt;br/&gt;Total transferred:      1370000 bytes&lt;br/&gt;HTML transferred:       290000 bytes&lt;br/&gt;Requests per second:    4275.96 [#/sec] (mean)&lt;br/&gt;Time per request:       23.387 [ms] (mean)&lt;br/&gt;Time per request:       0.234 [ms] (mean, across all concurrent requests)&lt;br/&gt;Transfer rate:          572.08 [Kbytes/sec] received&lt;br/&gt;&lt;br/&gt;Connection Times (ms)&lt;br/&gt;              min  mean[+/-sd] median   max&lt;br/&gt;Connect:        0    8  14.7      6     223&lt;br/&gt;Processing:     2   15  17.6     11     232&lt;br/&gt;Waiting:        1   11  13.5      8     225&lt;br/&gt;Total:          7   23  22.8     18     239&lt;br/&gt;&lt;br/&gt;Percentage of the requests served within a certain time (ms)&lt;br/&gt;&lt;span&gt;  50%&lt;/span&gt;&lt;span&gt;     18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  66%&lt;/span&gt;&lt;span&gt;     24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  75%&lt;/span&gt;&lt;span&gt;     26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  80%&lt;/span&gt;&lt;span&gt;     28&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  90%&lt;/span&gt;&lt;span&gt;     33&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  95%&lt;/span&gt;&lt;span&gt;     39&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  98%&lt;/span&gt;&lt;span&gt;     45&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  99%&lt;/span&gt;&lt;span&gt;     54&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 100%&lt;/span&gt;&lt;span&gt;    239 (longest request)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据指标显示，我单机每秒就能处理 4000+ 的请求，正常服务器都是多核配置，处理 1W+ 的请求根本没有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且查看日志发现整个服务过程中，请求都很正常，流量均匀，Redis 也很正常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//stat.log&lt;br/&gt;...&lt;br/&gt;result:1,localSales:145&lt;br/&gt;result:1,localSales:146&lt;br/&gt;result:1,localSales:147&lt;br/&gt;result:1,localSales:148&lt;br/&gt;result:1,localSales:149&lt;br/&gt;result:1,localSales:150&lt;br/&gt;result:0,localSales:151&lt;br/&gt;result:0,localSales:152&lt;br/&gt;result:0,localSales:153&lt;br/&gt;result:0,localSales:154&lt;br/&gt;result:0,localSales:156&lt;br/&gt;..&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;总结回顾&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说，秒杀系统是非常复杂的。我们这里只是简单介绍模拟了一下单机如何优化到高性能，集群如何避免单点故障，保证订单不超卖、不少卖的一些策略&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的订单系统还有订单进度的查看，每台服务器上都有一个任务，定时的从总库存同步余票和库存信息展示给用户，还有用户在订单有效期内不支付，释放订单，补充到库存等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现了高并发抢票的核心逻辑，可以说系统设计的非常的巧妙，巧妙的避开了对 DB 数据库 IO 的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 Redis 网络 IO 的高并发请求，几乎所有的计算都是在内存中完成的，而且有效的保证了不超卖、不少卖，还能够容忍部分机器的宕机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得其中有两点特别值得学习总结：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;①负载均衡，分而治之&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过负载均衡，将不同的流量划分到不同的机器上，每台机器处理好自己的请求，将自己的性能发挥到极致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样系统的整体也就能承受极高的并发了，就像工作的一个团队，每个人都将自己的价值发挥到了极致，团队成长自然是很大的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;②合理的使用并发和异步&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 Epoll 网络架构模型解决了 c10k 问题以来，异步越来越被服务端开发人员所接受，能够用异步来做的工作，就用异步来做，在功能拆解上能达到意想不到的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点在 Nginx、Node.JS、Redis 上都能体现，他们处理网络请求使用的 Epoll 模型，用实践告诉了我们单线程依然可以发挥强大的威力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器已经进入了多核时代，Go 语言这种天生为并发而生的语言，完美的发挥了服务器多核优势，很多可以并发处理的任务都可以使用并发来解决，比如 Go 处理 HTTP 请求时每个请求都会在一个 Goroutine 中执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，怎样合理的压榨 CPU，让其发挥出应有的价值，是我们一直需要探索学习的方向。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;24&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;来源：juejin.im/post/5d84e21f6fb9a06ac8248149&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于我：Tom哥，前阿里P7技术专家，offer收割机，参加多次淘宝双11大促活动。欢迎关注，我会持续输出更多经典原创文章，为你晋级大厂助力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;微信8.0将好友放开到了一万，小伙伴可以加我大号了，先到先得，再满就真没了。&lt;/strong&gt;&lt;strong&gt;扫描下方二维码即可加我微信啦，&lt;code&gt;2022，抱团取暖，一起牛逼。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.092130518234165&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;521&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KTof9YshwdaSEqIP60fNXXqd7e15vycGo75wsfR2yTDKxOpJaKG0BKzFod8CQxLtibu2vMp1GKBMDJRbk3rpLw/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/h2&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>