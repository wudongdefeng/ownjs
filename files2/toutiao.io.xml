<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>16f47a5677e17442dfbba8415e362330</guid>
<title>万字长文聊聊Web3的组成架构</title>
<link>https://toutiao.io/k/9ixbb92</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web3 发展至今，生态已然初具雏形，如果将当前阶段的 Web3 生态组成架构抽象出一个鸟瞰图，由下而上可划分为四个层级：&lt;strong&gt;区块链网络层、中间件层、应用层、访问层&lt;/strong&gt;。下面我们来具体看看每一层级都有什么。另外，此章节会涉及到很多项目的名称，因为篇幅原因不会一一进行介绍，有兴趣的可以另外去查阅相关资料进行深入了解。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8574257425742574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Xibk1Sk7nmicljEVKqE0ZCfBqvwl86YGDGz9VzOib7cCFnZBmD6ltmVTicwY90gRAzqSZj9Ecdwe9hkcsk7LjDHy2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1010&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;区块链网络层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最底层是「区块链网络层」，也是 Web3 的基石层，主要由各区块链网络所组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组成该层级的区块链网络还不少，Bitcoin、Ethereum、BNB Chain(BSC)、Polygon、Arbitrum、Polkadot、Cosmos、Celestia、Avalanche、Aptos、Sui 等等，还有很多。根据 Blockchain-Comparison 的统计，截止撰文之日的区块链至少有 150 条。这里我们主要说的是公链，联盟链不包括在内。因为区块链实在太多，会有些眼花缭乱，所以有必要进行分门别类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，不同区块链之间存在着分层结构，有 &lt;strong&gt;Layer0、Layer1、Layer2&lt;/strong&gt; 之分。其次，Web3 的繁荣发展，依赖于智能合约技术，而智能合约的运行环境为虚拟机。智能合约和虚拟机的关系，就和 Java 程序和 JVM 的关系类似。从不同的虚拟机维度上划分区块链，就可以分为两大类：&lt;strong&gt;EVM 链&lt;/strong&gt;和 &lt;strong&gt;Non-EVM 链&lt;/strong&gt;。EVM 是 Ethereum Virtual Machine，即为以太坊虚拟机的简称。EVM 链即为兼容 EVM 的区块链，而 Non-EVM 顾名思义就是不兼容 EVM 的区块链。最后，还可以根据存储的数据大小进行分类，可以分为计算型区块链和存储型区块链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先从分层结构说起。最好理解的是 Layer1，我们所熟知的比特币、以太坊、EOS、BSC 都属于 Layer1，也称为主链。在分布式系统中，存在 CAP 定理，即一个分布式系统不可能同时满足三个特性：一致性、可用性、分区容错性。一个分布式系统只能满足三项中的两项。Layer1 的区块链本质上也是分布式系统，也同样存在不可能三角问题，只是三个特性与 CAP 不同，分别为：可扩展性、安全性、去中心化，每个区块链也只能满足三项中的两项。比特币和以太坊偏向于安全性和去中心化，所以可扩展性比较弱，TPS 比较低。EOS 和 BSC 则只依赖于少数节点来维护共识，相比于比特币和以太坊，减低了去中心化特性，但提高了可扩展性，从而能达到很高的 TPS。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决比特币和以太坊的可扩展性问题，就慢慢衍生出了 Layer2。Layer2 是作为依附于主链的子链而存在，主要用于承载 Layer1 的交易量，承担执行层的角色，而 Layer1 则可变成结算层，可大大减少交易压力。目前主流的 Layer2 都是扩展以太坊的子链，包括 Arbitrum、Optimism、zkSync、StarkNet、Polygon 等。比特币也有 Layer2，主要包括闪电网络、Stacks、RSK 和 Liquid，但目前都比较小众。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Layer0 则比较抽象了，一般被定义为区块链基础设施服务层，主要由模块化区块链所构成，包括 Celestia、Polkadot、Cosmos 等。模块化区块链这个概念主要是由 Celestia 提出的，其核心设计思路就是把区块链的共识、执行、数据可用性这几个核心模块拆分开来，每个模块由一条单独的链来完成，再将几个模块组合到一起完成全部工作。这和软件架构设计中所提倡的模块化设计思想是一样的，可实现高内聚低耦合。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.55625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Xibk1Sk7nmicljEVKqE0ZCfBqvwl86YGDG4F98nLMNupFIHAX1SCyqZuTcC6SCS4xFt41PzlDD47KBoMVR7RpJAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现跨链通信的跨链桥或跨链协议也可以划入 Layer0。跨链桥的数量也是非常多，撰写此文时，debridges.com 上统计的跨链桥多达 113 条，其中 TVL 排名最高的三个分别为 Polygon、Arbitrum、Optimism 的官方跨链桥，这几个桥分别实现了各自的 Layer2 和以太坊之间的资产跨链。TVL 排名第四位的则是 Multichain，其前身为 Anyswap，是连接了最多条区块链的第三方跨链桥，截至今年 1 月份时，其连接的区块链多达 81 条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;聊完分层结构的划分，我们再从 EVM 的维度来梳理下不同的区块链。前面说过，从 EVM 维度上可划分为 EVM 链和 Non-EVM 链两大类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EVM 链是目前最主流的方向，基于 EVM 链的 DApp 和用户群体是目前整个 Web3 生态里规模最大的。有些原生就是兼容 EVM 的，比如 BSC、Heco、Arbitrum、Optimism 等；有些则是后期才扩展兼容 EVM 的，比如 zkSync 1.0 并不兼容 EVM，而 zkSync 2.0 则是兼容 EVM 的。很多区块链就算早期并不兼容 EVM，但也逐渐在拥抱 EVM。比如，Polkadot 推出了 Moonbeam 平行链来兼容 EVM，Cosmos 则有 Evmos。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前来看，排名靠前的区块链中，大部分都已经兼容 EVM，不过依然还有少部分 Non-EVM 链存在，比如 Solana、Terra、NEAR、Aptos、Sui。另外，EVM 链的智能合约主要使用 Solidity 作为开发语言，而 Non-EVM 链则主要使用 Rust 或 Move 语言开发智能合约。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上提到的这些区块链，主要还是偏向于解决去中心化计算的区块链，这些区块链普遍不支持大数据的存储，比如文件存储。而存储型的区块链则聚焦于解决大数据存储的问题，这类区块链目前不太多，主要有 Filecoin、Arweave、Storj、Siacoin 和 EthStorage。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前组成「区块链网络层」的区块链成员们主要就包括这些了，未来还会不断有新成员加入，但也有不少旧成员逐渐没落而被遗落在角落里。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;中间件层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在区块链网络层之上的这一层，我称之为「中间件层」，主要为上层应用提供各种通用服务和功能。所提供的通用服务和功能包括但不限于：&lt;strong&gt;安全审计、预言机、索引查询服务、API 服务、数据分析、数据存储、基本的金融服务、数字身份、DAO 治理&lt;/strong&gt;等。提供通用服务和功能的组件则可称为「中间件」，这些中间件也是存在多种形式，可以是链上协议，也可以是链下平台，或链下组织，包括中心化的企业或去中心化自治组织 DAO。下面就来聊聊这一层具体都有哪些中间件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来聊聊安全审计，这是非常核心的中间件，因为 Web3 里的区块链和应用大多都是开源的，且很多都是跟金融强相关，因此，安全性就成为了重中之重，安全审计自然也变成了刚需。安全审计的服务大多由一些安全审计公司所提供，比较知名的审计公司包括：CertiK、OpenZeppelin、ConsenSys、Hacken、Quantstamp，以及国内主要有慢雾、链安、派盾等。另外，还有不少知名度不高的小审计公司。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了审计公司，还有一些提供 Bug Bounty 的平台，一般就是在这些平台上发布任务，让白帽黑客们来找 Bug，找到的 Bug 安全漏洞等级越高则可获得的赏金越高。目前，全球最大的 Bug Bounty 平台是 Immunefi。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，再来聊聊预言机（Oracle Machine，简称 Oracle），在 Web3 生态里也是扮演着非常重要的角色，是区块链系统与外部数据源之间沟通的桥梁，主要实现智能合约与链下真实世界的数据互通。因为区块链网络本身对状态一致性的限制，需要保证每个节点在给定相同输入的情况下必须获得相同的结果，所以区块链被设计成一个封闭系统，只能获取到链内的数据，而无法主动获取外部系统的数据。但很多应用场景中是需要用到外部数据的，这些外部数据就由预言机来提供，这也是目前区块链与外部数据实现互通的唯一途径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据预言机所提供的具体功能，目前对预言机的分类大致有：DeFi 预言机、NFT 预言机、SocialFi 预言机、跨链预言机、隐私预言机、信用预言机、去中心化预言机网络。具体的预言机项目有 CreDA、Privy、UMA、Banksea、DOS、NEST、Chainlink 等，其中，Chainlink 为预言机的龙头，其定位为去中心化预言机网络，推出了 Data Feeds、VRF、Keepers、Proof of Reserve、CCIP 等一系列产品和服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，索引查询服务也是很关键的中间件，解决了链上数据的复杂查询问题。比如要查询 Uniswap 上某一天的总交易量，如果直接在链上查询是很麻烦的。所以就有了对索引查询服务的需求，这块的主要代表为 The Graph 和 Covalent。The Graph 的实现方案主要是可定制化监听链上数据并映射成自定义的数据进行存储，从而方便查询。而 Covalent 则是将很多通用、广泛使用的数据封装成统一的 API 服务，供用户查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到 API 服务，除了 Covalent，还存在解决其他不同需求的 API 提供商，比如：NFTScan，是聚焦于提供 NFT API 数据服务的；Infura 和 Alchemy，则主要提供区块链网络节点服务；API3，旨在打造去中心化 API 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是索引查询服务还是 API 服务，都是链上数据相关的服务，数据分析也是数据相关的服务，这一版块的成员主要有 Dune Analytics、Flipside Crypto、DeBank、Chainalysis 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据存储中间件则和底层几个专门做存储的区块链容易混淆，也有人将底层的 Filecoin、Arweave、Storj 等划分到这一层，但我觉得这些本质上还是底层区块链，所以我将其划入到区块链网络层。而中间件层的数据存储，目前主要就是 IPFS。IPFS 全称为 InterPlanetary File System，中文名为星际文件系统，是一个基于内容寻址、分布式、点对点的新型超媒体传输协议，其旨在取代 HTTP 协议。IPFS 与区块链网络很相似，但其实并不属于区块链网络，基于 IPFS 的 Filecoin 才是区块链网络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，看看有哪些中间件是提供基本金融服务的。这块的代表性组件主要包括 Uniswap、Curve、Compound、Aave 等，Uniswap 和 Curve 提供了链上交易功能，而 Compound 和 Aave 则是链上借贷平台。这几个本质上都是应用层的链上协议，但因为这些协议都逐渐被越来越多其他应用所依赖，类似于成为了乐高积木，可以用来组合搭建出不同的应用，于是就变成了通用性的应用协议，即下沉为了中间件的角色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，任何具有可组合性的组件，不管是链上应用协议，还是链下提供不同服务的中心化实体，或者是 DAO，只要其提供的服务和功能是大部分应用都需要的，就可以划入「中间件层」。不同的中间件就和不同的乐高积木一样，通过组装不同的积木就可以创建出不同的应用。包括数字身份、DAO 治理的工具等，其实也都是同样道理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用层是 Web3 生态里最繁荣的一层，这一层里，充斥着各种不同的 DApps，可谓是百花齐放、百家争鸣。下面我们主要介绍几个发展得相对比较繁荣的板块。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NFT&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NFT 全称为 Non-Fungible Token，表示「非同质化代币」，国内也称为数字藏品，用于代表艺术品等独一无二的数字资产。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个真正意义上的 NFT 项目叫 CryptoPunks，于 2017 年 6 月发布，由 10,000 个 24x24 像素的头像所组成。每个头像都是由算法生成的，独一无二且所有头像都上传到了以太坊上，也是目前为止唯一一个将所有头像数据全部上链的 NFT 项目。下图为 CryptoPunks 官网展示的部分头像：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xibk1Sk7nmicljEVKqE0ZCfBqvwl86YGDGy0j49JiaxUwwDmILktGJDYnFicibxRo4EbEjphiaD1dTphdvgyB3wDDC4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止撰文之日，CryptoPunks 的地板价（即最低价）为 66.88 ETH，按 ETH 的价格换算成美元，大概为 $84,397.21 美元。最贵的一个 CryptoPunk，成交价达到了 8000 ETH，成交于 2022 年 2 月 12 日。一个 NFT 头像为何会这么贵，这对于很多人都是很难理解的。其中，最主要的一个原因，就是它是第一个 NFT 项目，就和比特币是第一个区块链一样，其开创性的地位所带来的价值潜力非常大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受 CryptoPunks 的启发，一家名为 Axiom Zen（Dapper Labs 的前身）的公司于 2017 年 11 月底发行了 CryptoKitties，国内也称为加密猫、以太猫、谜恋猫。CryptoKitties 上线后便病毒式地传播开来，还造成了以太坊的拥堵，暴露出以太坊的性能问题。CryptoKitties 发行之前，Axiom Zen 的技术总监 Dieter Shirley 以 CryptoKitties 为案例，还提出了 ERC721 Token 协议作为 NFT 的通用技术标准，而随着 CryptoKitties 爆火后，以 ERC721 为主要技术标准的 NFT 被进一步采用，如今 ERC721 已经成为了所有 NFT 的基础标准之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继 CryptoPunks 和 CryptoKitties 之后，NFT 开始逐渐遍地开花，NFT 生态逐渐蓬勃发展。NFT 发展至今，已经涉足到了多个领域，如果对 NFT 生态的所有组成部分做详细分类的话，可以多达几十种。如果只聚焦于 NFT 本身，即 NFT 的不同用例，那大致可以做出以下分类：&lt;strong&gt;收藏品、艺术品、音乐、影视、游戏、体育运动、虚拟土地、金融、品牌、DID&lt;/strong&gt;。下面主要介绍每个分类的一些代表性的 NFT 项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收藏品其实很难单独定义为一个类别，宽泛地讲，几乎任何东西都可以归为收藏品，包括艺术品、游戏道具、虚拟土地等。能被定义为收藏品的 NFT 主要需具备一个特性：稀缺性。比如，10000 个 CryptoPunks 中，外星人的数量最少，所以有很高的稀缺性，而男性最多，稀缺性就很低了。最知名的收藏品 NFT，除了 CryptoPunks，还有 BAYC，全称为 Bored Ape Yacht Club，也称为无聊猿。无聊猿不只是一套单独的 NFT，其实只是「无聊猿宇宙」的开端，基于无聊猿之后，背后的团队 Yuga Labs 又相继发行了无聊猿犬舍俱乐部（Bored Ape Kennel Club，BAKC)、变异猿游艇俱乐部（Mutant Ape Yacht Club，MAYC），也发行了 ApeCoin（APE）代币，还推出了 Otherside，专为元宇宙打造的虚拟土地。这些，都已经形成了「无聊猿宇宙」系列 IP，而且无聊猿不只是在加密圈内流行，在圈外的周边产品也在不断增加，比如有无聊猿的帽子、衣服、雕像、餐厅等。无聊猿的成功已超越了 CryptoPunks，Yuga Labs 之后还直接收购了 CryptoPunks。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NFT 的特性能有效保护版权的所有权，所以在艺术品领域流行开来也是理所当然。艺术品 NFT 有几个代表性的作品值得介绍一番，第一个是艺术家 Beeple 的作品，名为“每一天：第一个 5000 天（EVERYDAYS: THE FIRST 5000 DAYS）”，是将他过去 5000 天内每天创作一幅的所有作品（共 5000 幅）合成一个 NFT 图像，在 2021 年 3 月以 69,346,250 美元售出。第二个值得介绍的是生成艺术，也称为衍生艺术。生成艺术中的艺术品不是由人创作出来的，而是由编程算法自动生成的，最知名的 NFT 生成艺术平台叫 Art Blocks，是一个基于以太坊的随机生成艺术平台。艺术家们可以把自己设计的独特算法上传到 Art Blocks 平台，并设定特定数量 NFT 进行发行，NFT 会根据算法自动生成。最后再介绍目前最贵的 NFT 艺术品，叫 ”The Merge“，2021 年 12 月以 9180 万美元天价成交。与其他 NFT 不同，”The Merge“ 其实不是一个单独的作品，而是由多个「mass」代币动态组合而成的。销售的其实也是 mass 代币，当初共售出 312,686 个 mass 代币，共有 28,983 个买家，即是说，”The Merge“ 是由这 28,983 个买家共同拥有其所有权，每个买家所拥有的 mass 代币数量就代表了占有多少份额的所有权。”The Merge“ 也可以理解为是一个碎片化 NFT 作品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;音乐 NFT 的兴起和艺术品类似，主要也是因为版权。下面介绍几个具有代表性的音乐 NFT 相关人物，第一个要介绍的是 Justin David Blau，是美国 DJ 和电子舞曲制作人，以艺名 3LAU 而闻名。他是最早采用音乐 NFT 的人之一，在 2020 年秋天卖出了他的第一张 NFT。而在 2021 年 2 月底，凭借 Ultraviolet NFT 专辑为他带来了 1168 万美元的收入。2021 年 5 月又成立了 NFT 音乐平台 Royal，8 月份完成了种子轮融资 1600 万美元，有 a16z、Coinbase 等顶级机构参与。第二个要介绍的是 Don Diablo，荷兰 DJ、数字艺术家、唱片制作人、音乐家和电子舞曲创作者，他在 2021 年卖出第一部完整的音乐会电影 NFT，名为 “Destination Hexagonia”，成交价 600 ETH（当时为 126 万美元）。最后再介绍一个叫 Kingship 的摇滚乐队，这是一支由无聊猿组成的虚拟乐队，由环球音乐集团所组建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NFT 也席卷到了影视圈，有几个知名的影视剧都陆续发行了 NFT，国外有《权力的游戏》《蝙蝠侠》《指环王》《黑客帝国》《行尸走肉》等，国内有《大话西游》《流浪地球》《我不是药神》《封神三部曲》等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NFT 用在游戏里主要就是作为游戏资产的载体，相比于传统游戏内的资产，NFT 的形式对游戏玩家来说可以真正拥有游戏资产的所有权，且 NFT 可以在游戏外流通交易。第一个游戏 NFT 项目就是 CryptoKitties，每一只猫都是一个独立的 NFT。后面讲到 GameFi 小节再继续深入聊聊游戏这块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体育运动领域也同样涉足了 NFT，目前最知名的两大体育 NFT 平台是 NBA Top Shot 和 Sorare。NBA Top Shot 顾名思义主要以 NBA 为主，而 Sorare 则服务于足球领域。除了 NBA 和足球，橄榄球、棒球、拳击、摔跤也都纷纷推出了各自的 NFT 纪念品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟土地类 NFT 主要由一些主打「元宇宙」概念的项目所推行，比较知名的有 Decentraland、The Sandbox、Roblox、Axie Infinity Land、Otherdeed 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;金融和 NFT 的结合，主要就是将 NFT 应用到 DeFi 中，比如 UniswapV3 中的流动性仓位就是 NFT。另外，还有一个思路则是先将 NFT 碎片化，接着将这些碎片后的 NFT 再赋予 DeFi 功能，比如可以赋予交易、借贷、质押挖矿等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;品牌和 NFT 的结合，主要是作为一种新的营销方式。这两三年陆续有各种品牌加入这个阵营，比如，奢侈品品牌有 GUCCI、LV、爱马仕等，餐饮品牌有 Taco Bell、星巴克、必胜客、可口可乐等，汽车品牌有迈凯伦、雪佛兰等，运动品牌有阿迪达斯、李宁、耐克等，还有很多其他品牌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，聊聊 DID，全称为 Decentralized Identity，即去中心化身份。所有人都知道 DID 非常重要，但其发展还比较缓慢，目前除了细分领域 ENS 域名之后，还没有成熟的 DID 体系形成网络效应。目前，应用最广泛的只有域名，基于以太坊的 ENS 是龙头，ENS 之于 Web3，就相当于 DNS 之于 Web2。不同的是，ENS 解析的域名，映射的不是网站 IP，而是用户的以太坊地址。比如，以太坊创始人 V 神的 ENS 为 “vitalik.eth”，映射的地址为 0xd8da6bf26964af9d7eed9e03e53415d37aa96045。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NFT 的可应用场景实在太多了，上面所列出的分类还没能覆盖到全部。因为 NFT 的特性，任何具有所有权的东西都可以指代，所以坊间有“万物皆可 NFT”的说法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DeFi&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DeFi 即去中心化金融，崛起于 2020 年夏天，因此那段时间也被称为 DeFi Summer。根据 TradingView 的统计数据，2020 年夏天刚崛起时，DeFi 总市值仅 50 亿美元，随后一路飙升，在 2021 年底达到了最高峰，将近 1800 亿美元。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.60859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Xibk1Sk7nmicljEVKqE0ZCfBqvwl86YGDG81enLN7A3gOnicibqYCnu46b1tRkP3xDGZjFicPnJ0f9IPN1gO2pMVNPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DeFi 有很多细分板块，主要包括：&lt;strong&gt;稳定币、交易所、衍生品、借贷、聚合器、保险、预测市场、指数&lt;/strong&gt;等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稳定币主要可分为三类：&lt;strong&gt;中心化稳定币、超额抵押稳定币、算法稳定币&lt;/strong&gt;。其中，超额抵押稳定币和算法稳定币为&lt;strong&gt;去中心化稳定币&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中心化稳定币直接与法定货币挂钩，由中心化机构所发行，要求每单位稳定币需要有 1:1 的法币储备。目前交易量最大的两个稳定币 USDT 和 USDC，都是法币抵押稳定币，与美元 1:1 挂钩，分别由 Tether 和 Circle 两家中心化机构所发行。另外，币安，全球第一大中心化数字货币交易所，联合 Paxos 发行了自己的法币抵押稳定币 BUSD，目前也是全球交易量排名第三的稳定币，仅次于 USDT 和 USDC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超额抵押稳定币通过超额抵押其他加密货币而锻造，抵押品会被锁定在智能合约里，智能合约会根据抵押品的价值锻造出对应数量的稳定币，智能合约依靠价格预言机来维持与法币的锚定。此类型的稳定币主要以 DAI 为代表，由 MakerDAO 推出，和美元保持 1:1 锚定，目前交易量排名第四。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法稳定币则比较新颖，顾名思义，主要是通过算法来控制稳定币的供应。此赛道的选手也不少，包括 UST、FEI、AMPL、ESD、BAC、FRAX、CUSD、USDD、USDN 等，但目前还没有一个真正实现稳定的算法稳定币出现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，来聊聊交易所，DeFi 里的交易所是指&lt;strong&gt;去中心化交易所&lt;/strong&gt;，简称 &lt;strong&gt;DEX&lt;/strong&gt;。DEX 是 DeFi 所有板块里市值占比最高的板块，也是 DeFi 的基石板块。如果对 DEX 再进一步细分，还可以分为现货 DEX 和衍生品 DEX，衍生品 DEX 主要交易永续合约或期权。如果从交易模式上划分，那 DEX 主要可分为两种：&lt;strong&gt;Orderbook 模式&lt;/strong&gt;和 &lt;strong&gt;AMM 模式&lt;/strong&gt;。Orderbook 模式的 DEX，主要包括 dYdX、apeX、0x、Loopring 等。AMM 模式的 DEX 则比较多了，主要包括 Uniswap、SushiSwap、PancakeSwap、Curve、Balancer、Bancor、GMX、Perpetual 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Orderbook 模式是最早出现的交易类型，交易方式和股票盘口的买卖方式一样，交易用户可选择成为挂单者（maker）或吃单者（taker），交易会根据价格优先和时间优先的规则撮合成交。采用 Orderbook 的 DEX，根据其发展历程主要还可以再分为三种模式：&lt;strong&gt;纯链上撮合+结算模式、链下撮合+链上结算模式、Layer2 模式&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;纯链上撮合结算模式，用户提交的挂单和吃单都是直接在链上，吃单会直接和链上的挂单成交。该模式的代表为 EtherDelta，其优点是完全链上，去中心化程度高，但缺点是交易性能很低且交易成本很贵，用户挂单、撤单都需要支付燃料费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链下撮合+链上结算模式的代表则是 0x 协议，相比于第一种模式，主要多了链下的「中继器」角色，用户通过链下签名的方式生成委托单并提交给中继器，由中继器来维护 Orderbook，撮合成功的委托单再由中继器提交到链上进行结算。因为将撮合移到了链下处理，大大提高了交易性能，但结算是一笔笔单独结算的，所以结算的性能成为了瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Layer2 模式的代表为 dYdX，背后所使用的技术主要由 StarkWare 所提供的产品 StarkEx 所支持。其基本原理就是部署一个单独的、专用的 Layer2，用户的撮合交易和结算都发生在这个 Layer2 上，然后定时将所有交易记录（包括结算记录）全部打包生成证明并发送到 Layer1 上进行验证。与 Layer2 公链不同，Layer2 公链提供的是通用交易，而 dYdX 背后所使用的这个 Layer2 只能用于专用的交易场景，这其实算是个私有链，也可称为应用链，这也是一种新的应用模式。这种模式的交易体验和中心化交易所已经相差无几了，但中心化程度比较高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完全去中心化且交易体验也较好的交易模式，目前主流的就是 AMM 模式了，AMM 为 Automated Market Maker 的简称，也称为自动做市商模式。引爆 AMM 模式的是 Uniswap，于 2018 年 11 月上线，之后的 SushiSwap、PancakeSwap、Curve 等都是基于 Uniswap 的模式进行改造。该模式需要流动性池作支撑，流动性提供者（简称 LP）往交易池里注入资产作为流动性，其实就是资金池，然后用户直接和流动性池进行交易，而 LP 则从中赚取用户的交易手续费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于交易所暂时就先聊这么多，接着来看看&lt;strong&gt;衍生品&lt;/strong&gt;。DeFi 衍生品板块主要包括几个方向：&lt;strong&gt;永续合约、期权、合成资产、利率衍生品&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永续合约也是期货合约，加了杠杆的交易产品，前面提到的 dYdX、apeX、GMX、Perpetual 就是知名的几个永续合约 DEX。期权比期货复杂，DeFi 期权领域的玩家主要包括 Hegic、Charm、Opium、Primitive、Opyn 等，但目前期权市场还很小，被关注的不多。合成资产是由一种或多种资产/衍生品组合并进行代币化的加密资产，早期主要合成 DAI、WBTC 等数字资产，后面基于现实世界中的股票、货币、贵金属等的合成资产也越来越多，目前该赛道的龙头项目是 Synthetix，另外还有 Mirror、UMA、Linear、Duet、Coinversation 等项目。DeFi 的利率衍生品主要是基于加密资产利率开发不同类型的衍生产品，以满足 DeFi 用户对确定性收益的不同需求，主要玩家有 BarnBridge、Swivel Finance、Element Finance 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着来看看&lt;strong&gt;借贷&lt;/strong&gt;，这也是 TVL 很高的一个版块，和 DEX 一样也是 DeFi 的基石。这块的借贷协议主要有 Compound、Aave、Maker、Cream、Liquity、Venus、Euler、Fuse 等。目前，大部分借贷协议都是采用&lt;strong&gt;超额抵押的借贷模型&lt;/strong&gt;，所谓超额抵押，举个例子，比如，要借出 80 美元的资产，那至少需要存入价值 100 美元的抵押资产，即抵押资产价值要高于借贷资产价值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然超额抵押模型是主流，但也存在几个创新方向：&lt;strong&gt;无息贷款、资产隔离池、跨链借贷、信用贷&lt;/strong&gt;。无息贷款的代表为 Liquity，用户在 Liquity 借出其稳定币 LUSD 的时候，用户一次性支付借款和赎回费用，借出后无需支付利息。资产隔离池就是将不同的借贷资产分开为不同的池子，每个借贷池都是独立的，避免一个不良资产或者一个池子受损导致整个平台都被连累。目前，资产隔离池差不多已经成为了标配，很多借贷协议都引入了这种模式，除了一开始就使用这种模式的 Fuse，包括 Compound、Aave、Euler 等协议也都加入了阵营。跨链借贷也是一个新趋势，Flux、Compound、Aave 等都在这个方向上进行拓展。信用贷在传统金融非常普遍，但在 DeFi 领域还比较少，主要是还缺乏有效的链上信用体系，目前的代表项目是 Wing Finance。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一个是&lt;strong&gt;聚合器&lt;/strong&gt;，DeFi 聚合器也分为好几种类型：&lt;strong&gt;DEX 聚合器、收益聚合器、资产管理聚合器、信息聚合器&lt;/strong&gt;。DEX 聚合器，主要就是将多个 DEX 聚合到一起，通过算法从中寻找出最优的交易路径，主流的 DEX 聚合器包括 1inch、Matcha、ParaSwap，以及 MetaMask 钱包内置的 MetaMask Swap 等。收益聚合器主要有 Yearn Finance、Alpha Finance、Harvest Finance、Convex Finance 等，主要就是聚合各种流动性挖矿，让参与多平台的 Yield Farming（收益耕作）实现自动化。资产管理聚合器主要就是监控、跟踪和管理 DeFi 用户的资产和负债，主要以 Zapper 和 Zerion 为代表。最后是信息聚合器，主要包括 CoinMarketCap、DeFiPulse、DeBank、DeFiPrime 等平台。另外，这些其实都是中心化数据平台，但其在 DeFi 生态里依然扮演了重要角色，DeFi 生态里并非全都是去中心化的应用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，再简单聊聊&lt;strong&gt;保险&lt;/strong&gt;。我们知道，保险在传统金融中是非常大的一块市场，但 DeFi 里的保险发展至今，却是非常缓慢。整个 Web3 行业里，各种风险很多，协议漏洞风险、项目跑路风险、监管风险等，所以实际上对 DeFi 保险的需求市场本身很大，但因为开发设计门槛高，且流动性比较低，所以才导致整个保险赛道发展缓慢，目前依然处于非常早期的阶段，Nexus Mutual、Cover、Unslashed、Opium 等项目是该领域主要的玩家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，再看看&lt;strong&gt;预测市场&lt;/strong&gt;。预测市场是依托数据的市场，可用于押注和预测未来的所有事件，也是以太坊生态最早出现的应用场景之一，并在 2020 年美国大选中迎来爆发式增长，主要项目有 PolyMarket、Augur、Omen 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是&lt;strong&gt;指数&lt;/strong&gt;板块，提供一揽子资产敞口的指数基金在 DeFi 领域逐渐兴起。但广为人知的指数其实并不多，主要有：DPI、sDEFI、PIPT、DEFI++。DPI 全称为 DeFi Pulse Index，是由 DeFi Pulse 和 Set Protocol 合作创建的，是一种市值加权指数，包含了一些主流 DeFi 协议代币作为基础资产，包括 Uniswap、Aave、Maker、Synthetix、Loopring、Compound、Sushi 等。DPI 可以赎回为一揽子基础资产。sDEFI 则是由 Synthetix 所推出的指数代币，是该领域历史最悠久的指数。sDEFI 是一种合成资产，它不持有任何基础代币，而是使用预言机喂价来跟踪代币价值。PIPT 全称为 Power Index Pool Token，是由 PowerPool 所发行，由 8 种代币资产所组成。PowerPool 发行的指数除了 PIPT，另外还有 Yearn Lazy Ape Index、Yearn Ecosystem Token Index 和 ASSY Index 三个指数。DEFI++ 则是由 PieDAO 所发行，其组成有 14 种资产。PieDAO 还发行了 BCP 和 PLAY，BCP 由 WBTC、WETH、DEFI++ 三种代币组成，PLAY 则由一些元宇宙项目的代币所组成。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;GameFi&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GameFi 从字面上理解就是 Game Finance，是游戏和金融的融合体，也是目前 Web3 游戏的代名词。GameFi 这个词语诞生之前，Web3 游戏则通常被称为区块链游戏，或简称链游。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CryptoKitties 是第一款广为人知的区块链游戏，这是一款虚拟养猫的养成类游戏，每一只猫咪都是一个独立的 NFT。初代猫咪总共有 50000 只，每只猫咪都有不同的属性。玩家购买猫咪 NFT 后，就可以开始玩繁殖小猫的游戏。生出来的小猫咪，有部分基因属性会遗传自上一代，而有些基因则随机生成。生出来的猫咪本质上就是新的 NFT，可以卖出变现。如果生成的新猫咪产生了稀有的基因属性，还可以卖到不错的价格。截止撰文之日（2023 年 1 月底），已经产生了 2,021,774 只猫咪，持有的钱包地址有 136,283。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继 CryptoKitties 之后，越来越多养成类游戏陆续出现，如加密狗、加密兔、加密青蛙等等。打破这种局面的是一款叫 Fomo3D 的游戏，这是一款公开、透明、去中心化的博彩资金盘游戏。游戏规则也简单，用户通过支付 ETH 购买 Key 参与游戏，用户支付的 ETH 会分配到奖池、分红池、空投池、官方池等。拥有 Key 则可以得到持续的分红，拥有的 Key 越多，则得到的分红会越多。且每轮游戏存在一个倒计时（24 小时），倒计时结束时，最后一个购买 Key 的玩家可以获得奖池里大部分的 ETH。但每次有用户购买 Key，则倒计时剩余时间会增加 30 秒。第一轮游戏持续了很久时间，最后被人用技术手段赢走了奖池。Fomo3D 爆火之后，也是各种优化升级版的同类游戏不断出现，但事实证明，这类游戏还是无法持久。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而之后，再次引爆市场的游戏则是 Axie Infinity，国内则被称为“阿蟹”（与 Axie 谐音）。这是一款结合了宝可梦和加密猫玩法的游戏，游戏里的 Axies 可以升级、繁殖、对战、交易等。与加密猫等游戏不同的是，Axie Infinity 的经济系统里还引入了 SLP 和 AXS 代币，玩家可通过战斗赢取 SLP 代币，而通过消耗 SLP 和 AXS 可以繁殖新的 Axies，赢取的 SLP 代币和繁殖出来的 Axies 都可以在市场上出售来赚取收入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，Axie Infinity 其实在 2018 年就已经问世，但直到 2021 年才开始爆红，让其爆红的主要原因在于它的 Play-To-Earn 模式被推广开来了，即边玩边赚的特性呈病毒式传播了。其赚钱路径主要是先投入成本购买 Axies，然后通过玩游戏赚 SLP 代币和繁殖新的 Axies，再把 SLP 代币和 Axies 出售换成 ETH 或稳定币，最终将 ETH 或稳定币换成法币。这种赚钱模式一开始是从菲律宾逐渐流行起来的，当时，新冠疫情爆发，菲律宾当地许多人陷入了无收入的困境，而 Axie Infinity 的边玩边赚特性让这些人看到了希望。而且，这种赚钱模式也吸引了众多打金工作室，且逐渐从菲律宾扩展到了印度、印度尼西亚、巴西、中国等。截止撰文之日，日活用户已达 280 万。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而现在，边玩边赚模式几乎成为了 Web3 游戏的标配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他比较知名的游戏还有 Decentraland、The Sandbox、Illuvium、Star Atlas、Alien Worlds 等。这些就不展开说了，感兴趣的可以自行去搜索了解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SocialFi&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SocialFi 顾名思义就是 Social Finance，是社交和金融在 Web3 领域的有机结合，其实就是去中心化社交，是近两年才开始流行的概念。目前，在这个赛道的知名项目还比较少，目前的龙头是 Lens Protocol。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lens Protocol 是由 Aave 团队所开发的，在 2022 年 5 月上线。它不是一个独立的社交应用，也不是一个带有前端的完整社交产品，而是提供了一系列模块化组件的社交图谱平台，而具体的应用产品可以采用这些组件去构建。所以，Lens 的定义其实是 Web3 社交应用的基础设施。上线之初就已经拥有了 50 多个生态项目，比较热门的有 Lenster、Lenstube、ORB、Phaver、re:meme、Lensport、Lensta 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lenster 是去中心化社交媒体应用，可以通过连接 Web3 钱包并使用 Lens 来登录。登录用户就可以在 Lenster 发布内容，和在微博或推特发布内容类似，不同的是，在 Lenster 上发布内容时可选择收费。也可以评论其他用户的内容，不过目前还不支持层级式的评论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lenstube 则是去中心化视频平台，可以理解为就是去中心化的 Youtube。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ORB 是去中心化职业社交媒体应用，具有端到端链上信誉系统。具体来说，ORB 可以通过将各种 NFT 和 POAP 与用户经验、教育、技能和项目联系起来，从而创建个人去中心化专业档案并建立链上可信度，以及探索工作机会和申请链上身份，还可以用在链上分享自己的想法，与 Web3 人士建立联系并构建社区。此外，ORB 还允许用户利用碎片化时间通过学习 Web3 知识来获取 NFT，即 Learn-to-Earn。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Phaver 是一款适用于 iOS 和 Android 的 Share-to-Earn 社交应用，用户可以发布帖子，内容可以是图片、链接、产品应用等。用户还可以浏览 Lens 内的所有内容。Lens Profile 用户连接钱包后，还可以通过 Phaver 直接发布帖子到 Lens 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;re:meme 是一个链上 meme 生成器，允许用户上传 meme 模版，也能选择是否收费，然后其他人可以用图像编辑器添加文本、绘图和补充图像等。:meme 还可以扩展到音乐、视频和学术论文等媒体格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lensport 是一个只聚焦于 Lens 协议的社交 NFT 市场，用户可以发现、发布和出售帖子，也可以投资支持创作者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lensta 是一个聚焦于 Lens 协议的图片流应用，可以浏览 Lens 中带有图片的最新、最热门以及 Lenster、Lensport 等上收集费用最多的帖子。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;访问层&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问层是 Web3 组成架构里的最上层，也是直接面向终端用户的入口层。这一层里主要包括钱包、浏览器、聚合器等，另外，有一些 Web2 的社交媒体平台也成为了 Web3 的入口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看钱包，这也是最主要的入口。目前的钱包有多种分类，有浏览器钱包、手机钱包、硬件钱包、多签钱包、MPC 钱包、智能合约钱包等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器钱包就是通过网络浏览器使用的加密钱包，是大部分用户使用最广泛的钱包，最常用的就是 MetaMask、Coinbase Wallet、WalletConnect 等。MetaMask 是最被广泛支持的钱包之一，支持所有的 EVM 链，也已经成为了所有 DApps 的标准，目前支持的浏览器包括 Chrome、Brave、Firefox、Edge，以浏览器插件的方式存在。Coinbase Wallet 顾名思义是由交易所 Coinbase 所发行的钱包，于 2021 年 11 月推出后迅速发展，成为了与 MetaMask 旗鼓相当的对手，但浏览器还只支持 Chrome。WalletConnect 则比较特殊，它并不是一款具体的钱包应用，而是连接 DApps 和钱包的开源协议。最常用的就是用于连接手机钱包，在浏览器上的 DApp 选择连接 WalletConnect，会展示一个二维码，用你的手机钱包扫这个二维码就可以授权你的手机钱包连接上浏览器上的 DApp。而且，WalletConnect 支持所有区块链，不只是 EVM 链，也支持接入所有钱包。另外，不像 MetaMask 和 Coinbase Wallet 需要安装其浏览器插件，WalletConnect 不需要安装浏览器插件，所以可以支持所有浏览器，比如也支持 Safari，而 MetaMask 和 Coinbase Wallet 是不支持 Safari 的。因此，WalletConnect 成为了最受欢迎的钱包，也成为了所有 DApp 接入钱包的标配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手机钱包，即移动端数字资产钱包，很多钱包都支持。MetaMask 和 Coinbase Wallet 也有手机端的钱包 App。另外，比较知名的手机钱包还有 TokenPocket、BitKeep、Rainbow、imToken、Crypto.com 等。大部分流行的手机钱包都支持多链，包括 EVM 链，也包括 Non-EVM 链，比如 TokenPocket 目前支持了 Bitcoin、Ethereum、BSC、TRON、Polygon、Arbitrum、Avalanche、Solana、Cosmos、Polkadot、Aptos 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬件钱包则是把数字资产私钥存储在安全的硬件设备中，与互联网隔离，可通过 USB 即插即用。现在使用最广泛的硬件钱包是 Ledger 和 Trezor。Ledger 目前有三款不同型号的硬件钱包：Ledger Stax、Ledger Nano X、Ledger Nano S Plus。Ledger Stax 是在 2023 年才推出的新型号，支持触摸屏，而另外两款则不支持。Trezor 则有两款型号：Trezor Model T 和 Trezor Model One。Model T 支持触摸屏。除了 Ledger 和 Trezor，市面上的硬件钱包还有 SafePal、OneKey、imKey、KeepKey、ColdLar 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多签钱包，顾名思义，是指需要多人签名才能执行操作的钱包。最知名的多签钱包就是 Gnosis Safe，其本质上是一套链上智能合约，最常用的就是 2/3 签名，即总共有三个用户共同管理钱包，每次执行操作时，需要这三人中至少两个人的签名才能触发链上执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MPC 全称为 Multi-Party Computation，MPC 钱包也称为多方计算钱包，是新一代钱包类型，通过对私钥进行多方计算在链下实现多签和跨链等复杂的验证方式。简单来说，就是将私钥拆分成多个分片，然后由多方各自存储管理每个分片，签名的时候，再联合多方将分片重新拼接成完整的私钥。MPC 钱包与多签签名很类似，也可以实现 2/3 签名，不同的是，多签钱包是在智能合约层面实现签名校验，而 MPC 钱包则是通过链下计算实现的。目前已提供 MPC 钱包服务的还不多，主要有 ZenGo、Safeheron、Fordefi、OpenBlock、web3auth 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;智能合约钱包就是使用智能合约账户作为地址的钱包，多签钱包 Gnosis Safe 也属于智能合约钱包。而近一两年对智能合约钱包最新的尝试则是结合「账户抽象（Account Abstraction）」的新一代钱包。账户抽象主要是要将签名者和账户分离开来，钱包地址不再与唯一的私钥强绑定，可以实现更换签名者，也可以实现多签，还可以实现更换签名算法。目前在这个赛道的选手除了 Gnosis Safe 还有 UniPass、Argent、Blocto 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;钱包暂时就聊这么多，接着来说说浏览器。很多 DApp 都还是只提供了网页版本的前端，所以浏览器就成为了重要的访问入口。但因为不是所有浏览器都支持钱包扩展插件，所以也不是所有浏览器都能成为很好的 Web3 入口。最常用的浏览器是 Chrome，所有浏览器钱包都会开发 Chrome 的钱包插件。而 Safari 则很少用做 Web3 DApp 入口，因为除了 WalletConnect，没有其他浏览器钱包能够支持。还有一个值得介绍的浏览器是 Brave，这是一款内置了钱包的浏览器，其内置钱包叫 Brave Wallet。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一些聚合器也是 Web3 的访问入口，比如 DappRadar 收集了各种 DApps，用户可以通过它浏览并连接到这些 DApps。还有 Zapper、DeBank、Zerion 之类的聚合器，可以帮助用户追踪他们在各种 Web3 应用的所有资产和操作记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，像 Twitter 和 Reddit 这类 Web3 的社交媒体平台，因为聚集了很多 Web3 社群，也逐渐变成了 Web3 的访问入口。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c9fedf9d9d51835fe9a227ba0e18418</guid>
<title>自从项目用了灰度发布，睡觉真香！</title>
<link>https://toutiao.io/k/2t09s8r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-id=&quot;heading-0&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;「 &lt;/strong&gt;关注&lt;/span&gt;&lt;span&gt;&lt;strong&gt;“石杉的架构笔记”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大厂架构经验&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;倾囊相授&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;strong&gt;」&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.7786666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbrBVllM8y58P9qd6a1t1sjfQg5c93onhxbC0KecSYNjnXbbFPE9EsbibZ2vicLaxyiawUoqKic8b7Y4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-id=&quot;heading-0&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章来源：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【公众号：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码猿技术专栏】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3GHDOauYyUGbiaHXGx1ib5UxkKzSNtpMzY5tbbGdibG7icBSxlH783x1YTF0icAv8MWrmanB4u5qjyKfmYo1dDf7YbA/640?wx_fmt=gif&quot; data-w=&quot;100&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际生产中如有需求变更，并不会直接更新线上服务，最通常的做法便是：切出线上的小部分流量进行体验测试，经过测试后无问题则全面的上线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处也是非常明显，一旦出现了BUG，能够保证大部分的客户端正常使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现这种平滑过渡的方式就需要用到本篇文章介绍到的&lt;span&gt;全链路灰度发布&lt;/span&gt;。&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;什么是灰度发布？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。&lt;/span&gt;&lt;span&gt;在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。&lt;/span&gt;&lt;span&gt;灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么是全链路灰度发布？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在前面一篇文章有介绍到&lt;/span&gt;&lt;span&gt;网关的灰度发布&lt;/span&gt;&lt;span&gt;实现，仅仅是实现了&lt;/span&gt;&lt;span&gt;网关路由转发&lt;/span&gt;&lt;span&gt;的灰度发布，如下图：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43174924165824063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA5Dic4WYODDd06bUxKsWicmS1QXTwpLCHjSvhXMNnmQOUs6sGEfnkiaTB7vI96vj5Qgxm5f9XQ4d7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;989&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，网关灰度发布实现的是网关通过&lt;span&gt;灰度标记&lt;/span&gt;路由到&lt;span&gt;文章服务B&lt;/span&gt;（灰度服务），至于从文章服务B到评论服务是通过&lt;span&gt;openFeign&lt;/span&gt;内部调用的，默认无法实现灰度标记&lt;span&gt;grayTag&lt;/span&gt;的透传，因此文章服务B最终调用的是评论服务A，并不是评论服务B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;全链路灰度发布需要实现的是：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;网关通过灰度标记将部分流量转发给&lt;span&gt;文章服务B&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文章服务B能够实现灰度标记&lt;span&gt;grayTag&lt;/span&gt;的透传，最终调用&lt;span&gt;评论服务B&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过以上分析，全链路灰度发布需要实现两个点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;网关&lt;/span&gt;路由转发实现灰度发布&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务内部通过&lt;span&gt;openFeign&lt;/span&gt;调用实现灰度发布（透传灰度标记&lt;span&gt;grayTag&lt;/span&gt;）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;网关层的灰度路由转发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章将使用&lt;span&gt;Ribbon+Spring Cloud Gateway&lt;/span&gt; 进行改造负载均衡策略实现灰度发布。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在网关的全局过滤器中根据业务规则给流量打上灰度标记&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将灰度标记放入请求头中，传递给下游服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;改造Ribbon负载均衡策略，根据流量标记从注册中心获取灰度服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求路由转发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一个问题：根据什么条件打上灰度标记？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需要根据实际的业务需要，比如根据用户所在的地区、使用客户端类型、随机截取流量.....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我将直接使用一个标记&lt;span&gt;grayTag&lt;/span&gt;，只要客户端请求头中携带了这个参数，并且设置为true，则走灰度发布逻辑。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;请求头中携带：grayTag=true&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二个问题：为什么要在请求头中添加灰度标记传递给下游服务？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步非常关键，实现灰度标记透传给下游服务的关键，将灰度标记放在请求头中，下游服务只需要从请求头中获取灰度标记便知道是否是灰度发布，这个和令牌中继一个原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三个问题：灰度标记如何请求隔离？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring MVC中的每个请求都是开启一个线程进行处理，因此可以将灰度标记放置在&lt;span&gt;ThreadLocal&lt;/span&gt;中进行线程隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第四个问题：如何知道注册中心的服务哪个是灰度服务？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos支持在服务中配置一些元数据，可以将灰度标记配置在元数据中，这样就能区分哪些是灰度服务，哪些是正常服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第五个问题：如何针对特定的服务进行灰度发布？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我的一条调用链路如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4302788844621514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA5Dic4WYODDd06bUxKsWicmSUFxIxbOgdCHKewyfYseggJJnMbusl6cQiao4ZN0MPKZFMTxW9bKbmIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;753&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;&lt;span&gt;需求&lt;/span&gt;：现在只对&lt;span&gt;文章服务&lt;/span&gt;、&lt;span&gt;评论服务&lt;/span&gt;进行灰度发布，其他服务依然使用线上正在运行的服务&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的调用关系就变成了下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3563096500530223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA5Dic4WYODDd06bUxKsWicmS4wtYS3EnrhVyibYO3MA3XC5g1UYXoCHQMD3JyGO5NTJZcwDj0MnhYDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;943&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道网关路由中配置的服务很多，如何只针对文章服务进行灰度发布呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;很简单：只需要将自定义的Ribbon灰度发布规则只对文章服务生效。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里涉及到Ribbon中的一个注解：&lt;span&gt;@RibbonClients&lt;/span&gt; ，只需要在其中的value属性指定需要生效的服务名称，那么此时网关中的配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RibbonClients&lt;/span&gt;(value ={&lt;br/&gt;        &lt;span&gt;//只对文章服务进行灰度发布&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@RibbonClient&lt;/span&gt;(value = &lt;span&gt;&quot;article-server&quot;&lt;/span&gt;,configuration = GrayRuleConfig&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;} )&lt;br/&gt;@&lt;span&gt;SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;GatewayApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@RibbonClient&lt;/span&gt;可以指定多个，这个注解有如下两个属性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;value&lt;/span&gt;：指定服务的名称，在注册中心配置的服务名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;configuration&lt;/span&gt;：自定义的负载均衡策略，这里是灰度发布的策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;@RibbonClients&lt;/span&gt;其中有一个属性&lt;span&gt;defaultConfiguration&lt;/span&gt;，一旦使用这个属性，那么灰度发布的策略对网关路由中配置的所有服务都将生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第六个问题：说了这么多，具体如何实现？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关中首先需要定义一个&lt;span&gt;全局过滤器&lt;/span&gt;，伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GlobalGrayFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;GlobalFilter&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Mono&amp;lt;Void&amp;gt; &lt;span&gt;filter&lt;/span&gt;&lt;span&gt;(ServerWebExchange exchange, GatewayFilterChain chain)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         &lt;span&gt;//① 解析请求头，查看是否存在灰度发布的请求头信息，如果存在则将其放置在ThreadLocal中&lt;/span&gt;&lt;br/&gt;        HttpHeaders headers = exchange.getRequest().getHeaders();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (headers.containsKey(GrayConstant.GRAY_HEADER)){&lt;br/&gt;            String gray = headers.getFirst(GrayConstant.GRAY_HEADER);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (StrUtil.equals(gray,GrayConstant.GRAY_VALUE)){&lt;br/&gt;                &lt;span&gt;//②设置灰度标记&lt;/span&gt;&lt;br/&gt;                GrayRequestContextHolder.setGrayTag(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;       &lt;span&gt;//③ 将灰度标记放入请求头中&lt;/span&gt;&lt;br/&gt;   ServerHttpRequest tokenRequest = exchange.getRequest().mutate()&lt;br/&gt;    &lt;span&gt;//将灰度标记传递过去&lt;/span&gt;&lt;br/&gt;    .header(GrayConstant.GRAY_HEADER,GrayRequestContextHolder.getGrayTag().toString())&lt;br/&gt;    .build();&lt;br/&gt;            ServerWebExchange build = exchange.mutate().request(tokenRequest).build();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; chain.filter(build);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;①处的代码&lt;/span&gt;：从请求头中获取客户端传递过来的灰度标记（这里根据自己业务需要自行更改），判断是否是灰度发布&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;②处的代码&lt;/span&gt;：&lt;span&gt;GrayRequestContextHolder&lt;/span&gt;则是自定义的ThreadLocal实现的线程隔离工具，用来存放灰度标记&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;③处的代码&lt;/span&gt;：将灰度标记放置在请求头中，传递给下游微服务，这里是和令牌一个逻辑。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;注意：这个全局过滤器一定要放在&lt;span&gt;OAuth2.0&lt;/span&gt;鉴权过滤器之前，优先级要调高&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局过滤器中已经将灰度标记打上了，放置在&lt;span&gt;GrayRequestContextHolder&lt;/span&gt;中，下面只需要改造Ribbon的负载均衡的策略去注册中心选择灰度服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;span&gt;GrayRule&lt;/span&gt;，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 灰度发布的规则&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GrayRule&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ZoneAvoidanceRule&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initWithNiwsConfig&lt;/span&gt;&lt;span&gt;(IClientConfig clientConfig)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Server &lt;span&gt;choose&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//从ThreadLocal中获取灰度标记&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; grayTag = GrayRequestContextHolder.getGrayTag().get();&lt;br/&gt;            &lt;span&gt;//获取所有可用服务&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Server&amp;gt; serverList = &lt;span&gt;this&lt;/span&gt;.getLoadBalancer().getReachableServers();&lt;br/&gt;            &lt;span&gt;//灰度发布的服务&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Server&amp;gt; grayServerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;            &lt;span&gt;//正常的服务&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Server&amp;gt; normalServerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt;(Server server : serverList) {&lt;br/&gt;                NacosServer nacosServer = (NacosServer) server;&lt;br/&gt;                &lt;span&gt;//从nacos中获取元素剧进行匹配&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt;(nacosServer.getMetadata().containsKey(GrayConstant.GRAY_HEADER)&lt;br/&gt;                        &amp;amp;&amp;amp; nacosServer.getMetadata().get(GrayConstant.GRAY_HEADER).equals(GrayConstant.GRAY_VALUE)) {&lt;br/&gt;                    grayServerList.add(server);&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    normalServerList.add(server);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//如果被标记为灰度发布，则调用灰度发布的服务&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(grayTag) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; originChoose(grayServerList,key);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; originChoose(normalServerList,key);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//清除灰度标记&lt;/span&gt;&lt;br/&gt;            GrayRequestContextHolder.remove();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Server &lt;span&gt;originChoose&lt;/span&gt;&lt;span&gt;(List&amp;lt;Server&amp;gt; noMetaServerList, Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Optional&amp;lt;Server&amp;gt; server = getPredicate().chooseRoundRobinAfterFiltering(noMetaServerList, key);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (server.isPresent()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; server.get();&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑很简单，如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取灰度标记&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从Nacos注册中心获取灰度服务和正常服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据灰度标记去判断，如果灰度发布则选择特定的灰度服务进行转发&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个配置类，注入改造的灰度策略&lt;span&gt;GrayRule&lt;/span&gt;，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 灰度部署的负载规则配置类&lt;br/&gt; * 注意：这个类一定不要被Spring Boot 扫描进入IOC容器中，一旦扫描进入则对全部的服务都将生效&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GrayRuleConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; GrayRule &lt;span&gt;grayRule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GrayRule();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;注意：这个GrayRuleConfig不能被扫描进入IOC容器，一旦扫描进入则全局生效&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不仅仅网关需要用到这个灰度发布策略，凡是涉及到OpenFeign调用的微服务如果需要配置灰度发布都需要用到，因此这里陈某定义了一个公用的&lt;span&gt;gray-starter&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上述步骤网关的灰度发布则已经配置完成，此时只需要通过&lt;span&gt;&lt;strong&gt;@RibbonClients&lt;/strong&gt;&lt;/span&gt;指定对应哪个服务灰度发布。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;openFeign透传灰度标记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面在介绍网关的灰度发布配置时，是将灰度标记（&lt;span&gt;grayTag=true&lt;/span&gt;）放在了请求头中，因此在下游服务中需要做的就只是从请求头中将灰度标记取出来，然后将其存入&lt;span&gt;GrayRequestContextHolder&lt;/span&gt;上下文中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来下游服务中的&lt;span&gt;GrayRule&lt;/span&gt;则能从&lt;span&gt;GrayRequestContextHolder&lt;/span&gt;获取到灰度标记，从注册中心获取灰度服务进行调用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题来了：如何从请求头中取出灰度标记？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌中继的解决方案，使用的是openFeign的请求拦截器去配置请求头信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26173541963015645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA5Dic4WYODDd06bUxKsWicmSHmicfib1hCNTYA5jPNYvKQF38wMDey4iczG6qjcJJB1DnhEY3Woj7YZFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;703&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图：openFeign在调用时并不是用的原先的Request，而是内部新建了一个Request，其中复制了请求的URL、请求参数一些信息，但是请求头并没有复制过去，因此openFeign调用会丢失请求头中的信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是可以通过实现&lt;span&gt;RequestInterceptor&lt;/span&gt;将原先的请求头给复制过去，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FeignRequestInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RequestInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(RequestTemplate template)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        HttpServletRequest httpServletRequest = RequestContextUtils.getRequest();&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; headers = getHeaders(httpServletRequest);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt; entry : headers.entrySet()) {&lt;br/&gt;            &lt;span&gt;//② 设置请求头到新的Request中&lt;/span&gt;&lt;br/&gt;            template.header(entry.getKey(), entry.getValue());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取原请求头&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;getHeaders&lt;/span&gt;&lt;span&gt;(HttpServletRequest request)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;();&lt;br/&gt;        Enumeration&amp;lt;String&amp;gt; enumeration = request.getHeaderNames();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (enumeration != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (enumeration.hasMoreElements()) {&lt;br/&gt;                String key = enumeration.nextElement();&lt;br/&gt;                String value = request.getHeader(key);&lt;br/&gt;                &lt;span&gt;//将灰度标记的请求头透传给下个服务&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (StrUtil.equals(GrayConstant.GRAY_HEADER,key)&amp;amp;&amp;amp;Boolean.TRUE.toString().equals(value)){&lt;br/&gt;                    &lt;span&gt;//① 保存灰度发布的标记&lt;/span&gt;&lt;br/&gt;                    GrayRequestContextHolder.setGrayTag(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;                    map.put(key, value);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; map;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;①处的代码&lt;/span&gt;：从请求头中获取灰度发布的标记，设置到&lt;span&gt;GrayRequestContextHolder&lt;/span&gt;上下文中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;②处的代码&lt;/span&gt;：将这个请求头设置到新的Request中，继续向下游服务传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实配置一下&lt;span&gt;RequestInterceptor&lt;/span&gt;就已经完成了，关于灰度发布策略只需要复用网关的&lt;span&gt;GrayRule&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;p&gt;注意：也需要使用@RibbonClients注解去标注文章服务调用的哪些服务需要灰度发布。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RibbonClients&lt;/span&gt;(value = {&lt;br/&gt;        &lt;span&gt;//指定对comments这个服务开启灰度部署&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@RibbonClient&lt;/span&gt;(value = &lt;span&gt;&quot;comments&quot;&lt;/span&gt;,configuration = GrayRuleConfig&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;ArticleApplication&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Nacos中服务如何做灰度标记&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，分为两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1、在配置文件中指定，如下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cloud:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;nacos:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;discovery:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;## 灰度标记&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;grayTag:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2、在Nacos中动态的指定灰度标记&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8871715610510046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/19cc2hfD2rA5Dic4WYODDd06bUxKsWicmSibvzChbtVJ3o9sLIyThCibDlFxWYbiauFhYSGqnuhDpe8SChMspm3I8Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;647&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置完成之后，在客户端请求的时候只需要携带&lt;span&gt;grayTag=true&lt;/span&gt;这个请求头即可调用灰度服务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;blockquote mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务中全链路灰度发布方案其实很简单，重要的就是灰度打标，整体流程如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;网关中通过全局过滤器实现灰度打标，将灰度标记放入请求头中传递给下游服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关通过自定义的负载均衡策略，从注册中心获取灰度服务，进行转发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在openFeign调用时需要从请求头中获取灰度标记，放入上下文中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;openFeign调用同样是根据自定义的负载均衡策略从注册中心获取灰度服务，进行调用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21428571428571427&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/84QSpkgaj14GBzMnf1ibXkydLwCmhrWBooDwrdnlqYlsyB5PetG1T1oXxJ63G8TK58dqkDo7uzR7bKic50DxbTQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-w=&quot;336&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6538461538461539&quot; data-w=&quot;52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BXOuoE8lPAIR47zmQ1XOqSQszO2PjLgkgakpDZQSsUkLLnGszEu0eyGjvHNRqu6picb2kicC4lo95WZGiaxqibqW4A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;欢迎扫码加入儒猿技术交流群，每天晚上20:00都有Java面试、Redis、MySQL、RocketMQ、SpringCloudAlibaba、Java架构等技术答疑分享，更能跟小伙伴们一起交流技术&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;267&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;267&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLbPrUTW4zORxkXJU3pH9mPiawH9oZtZGKTkHyVL2wemkqNmPoJKDZlAt5ibgr2CibGkffw2ozqicds4gw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;41056&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;94152&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;100%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;另外推荐儒猿课堂的1元系列课程给您，欢迎加入一起学习~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;互联网Java工程师面试突击课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hjkFx86RFTZFibdBopicpMl5Scptaibp0pQAe5jUBMtXym9w4CncFBHsQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;SpringCloudAlibaba零基础入门到项目实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295NSLHaU5cHQTtyG2K5uK4iaA70v1g50BoQIRUVz4FBN1iahXdqc1M99Ww/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;亿级流量下的电商详情页系统实战项目&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295I9n8XXUWoEeuogklrbj2QN4JZ6cdgYeRys5CCsml2tkFfibLXdeqoFA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Kafka消息中间件内核源码精讲&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295yiaEcp1k5HBVycE8BGD0lGz5NZmKWmKXUtSBS7Jnm4FkTY8R5XFZkPw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;12个实战案例带你玩转Java并发编程&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295WWU9o0Pj51xAIa2qCs9xD2rdDIRLriaibePNSrWJVCknYn6b5lrF3CQQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Elasticsearch零基础入门到精通&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295QdxHC6HadPfaakPOo7DxxQpLH19lMZH0yAwRI3iajVXblNnwfMxBk9A/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于Java手写分布式中间件系统实战&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295r0mR5hhVpAlXTAZzlVvSg1dxegAaZrIZ9ftePV5QQQg2ibIZbiaA6CCg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;基于ShardingSphere的分库分表实战课&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;（1元专享）&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;160&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1J6IbIcPCLZn0ZLz1APC2Hxj148icL295hicEliaIKPfLpHqQAo4CdAorqyxd9HvqD8sADicO7wFHGJxNtRus6LlBA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e06a064c1a81369954a395fc316f476</guid>
<title>深入理解Linux 的Page Cache</title>
<link>https://toutiao.io/k/iiiv3bw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             defaultNoSetting&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzIxMjE1MzU4OA==&quot; data-alias=&quot;rrgeek&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9sNwsXcN68pL55XIyzTrCHZTbIUdTibQcuzuCaYeGTXNMyn6ACmicUrpoDC0xZSap46XJ59sKysPg9Rg379f32cA/0?wx_fmt=png&quot; data-nickname=&quot;人人极客社区&quot; data-signature=&quot;工程师们自己的Linux底层技术社区，分享体系架构、内核、网络、安全和驱动。&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;大家好，我是 Peter，昨天群里有小伙伴咨询page cache的问题，看到网上有篇不错的文章，分享给大家。如果大家有想看的内容，欢迎给我留言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. Page Cache&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.1 Page Cache 是什么？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;为了理解 Page Cache，我们不妨先看一下 Linux 的文件 I/O 系统，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.853125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6n2ibib377s4SvoQDKibCvOZwJ0GQeUSAWUjTaqJLjwL93ALDfWnrwJfNEmkH63T95CGSDVcIn7MuqFw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Figure1. Linux 文件 I/O 系统&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;上图中，红色部分为 Page Cache。可见 Page Cache 的本质是由 Linux 内核管理的内存区域。我们通过 mmap 以及 buffered I/O 将文件读取到内存空间实际上都是读取到 Page Cache 中。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.2 如何查看系统的 Page Cache？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通过读取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/proc/meminfo&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件，能够实时获取系统内存情况：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$ cat /proc/meminfo&lt;br/&gt;...&lt;br/&gt;Buffers:            1224 kB&lt;br/&gt;Cached:           111472 kB&lt;br/&gt;SwapCached:        36364 kB&lt;br/&gt;Active:          6224232 kB&lt;br/&gt;Inactive:         979432 kB&lt;br/&gt;Active(anon):    6173036 kB&lt;br/&gt;Inactive(anon):   927932 kB&lt;br/&gt;Active(file):      51196 kB&lt;br/&gt;Inactive(file):    51500 kB&lt;br/&gt;...&lt;br/&gt;Shmem:             10000 kB&lt;br/&gt;...&lt;br/&gt;SReclaimable:      43532 kB&lt;br/&gt;...&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;根据上面的数据，你可以简单得出这样的公式（等式两边之和都是 112696 KB）：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;两边等式都是 Page Cache，即：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;Page Cache = Buffers + Cached + SwapCached&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;通过阅读 1.4 以及 1.5 小节，就能够理解为什么 SwapCached 与 Buffers 也是 Page Cache 的一部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;题外话，小伙伴答案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;内核计算源码（linux 2.6.19）&lt;/span&gt;：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5364741641337386&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6n2ibib377s4SvoQDKibCvOZwJibQ1XibtHY9Hib2icaqfBd4J1X8KoymDc653Du7UE2227Fec8weaHhGnrw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内核算法：Cached  = files - SwapCached - Buffers；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Buffers + Cached + SwapCached = Active(file) + Inactive(file) + Shmem + SwapCached&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公式推出来的&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Cached = Active(file) + Inactive(file) + Shmem - Buffers ；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此可见，这个&lt;span&gt;Cached &lt;/span&gt;并不等于&lt;span&gt;Active(file) + Inactive(file) &lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个cache包含很多 ：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;含有普通文件数据的页‘；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;含有目录的页；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;含有直接从块设备文件(跳过文件系统)读出的数据的页；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;含有用户态进程数据的页；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;属于特殊文件系统文件的页，如shm；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.3 page 与 Page Cache&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;另一方面，并不是所有 page 都被组织为 Page Cache&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux 系统上供用户可访问的内存分为两个类型[2]，即：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么 Linux 不把 Page Cache 称为 block cache，这不是更好吗？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是因为从磁盘中加载到内存的数据不仅仅放在 Page Cache 中，还放在 buffer cache 中。例如通过 Direct I/O 技术的磁盘文件就不会进入 Page Cache 中。当然，这个问题也有 Linux 历史设计的原因，毕竟这只是一个称呼，含义随着 Linux 系统的演进也逐渐不同。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;下面比较一下 File-backed pages 与 Anonymous pages 在 Swap 机制下的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存是一种珍惜资源，当内存不够用时，内存管理单元（Memory Mangament Unit）需要提供调度算法来回收相关内存空间。内存空间回收的方式通常就是 swap，即交换到持久化存储设备上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;File-backed pages（Page Cache）的内存回收代价较低。Page Cache 通常对应于一个文件上的若干顺序块，因此可以通过顺序 I/O 的方式落盘。另一方面，如果 Page Cache 上没有进行写操作（所谓的没有脏页），甚至不会将 Page Cache 回盘，因为数据的内容完全可以通过再次读取磁盘文件得到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache 的主要难点在于脏页回盘，这个内容会在第二节进行详细说明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Anonymous pages 的内存回收代价较高。这是因为 Anonymous pages 通常随机地写入持久化交换设备。另一方面，无论是否有更操作，为了确保数据不丢失，Anonymous pages 在 swap 时必须持久化到磁盘。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.4 Swap 与缺页中断&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Swap 机制指的是当物理内存不够用，内存管理单元（Memory Mangament Unit）需要提供调度算法来回收相关内存空间，然后将清理出来的内存空间给当前内存申请方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Swap 机制存在的本质原因是 Linux 系统提供了虚拟内存管理机制，每一个进程认为其独占内存空间，因此所有进程的内存空间之和远远大于物理内存。所有进程的内存空间之和超过物理内存的部分就需要交换到磁盘上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;操作系统以 page 为单位管理内存，当进程发现需要访问的数据不在内存时，操作系统可能会将数据以页的方式加载到内存中。上述过程被称为缺页中断，当操作系统发生缺页中断时，就会通过系统调用将 page 再次读到内存中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但主内存的空间是有限的，当主内存中不包含可以使用的空间时，操作系统会从选择合适的物理内存页驱逐回磁盘，为新的内存页让出位置，&lt;strong&gt;选择待驱逐页的过程在操作系统中叫做页面替换（Page Replacement）&lt;/strong&gt;，替换操作又会触发 swap 机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果物理内存足够大，那么可能不需要 Swap 机制，但是 Swap 在这种情况下还是有一定优势：对于有发生内存泄漏几率的应用程序（进程），Swap 交换分区更是重要，这可以确保内存泄露不至于导致物理内存不够用，最终导致系统崩溃。但内存泄露会引起频繁的 swap，此时非常影响操作系统的性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux 通过一个 swappiness 参数来控制 Swap 机制[2]：这个参数值可为 0-100，控制系统 swap 的优先级：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后，为什么 Buffers 也是 Page Cache 的一部分？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是因为当匿名页（Inactive(anon) 以及 Active(anon)）先被交换（swap out）到磁盘上后，然后再加载回（swap in）内存中，由于读入到内存后原来的 Swap File 还在，所以 SwapCached 也可以认为是 File-backed page，即属于 Page Cache。这个过程如 Figure 2 所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/cYSwmJQric6n2ibib377s4SvoQDKibCvOZwJsXBSha03ceVX8EBH60JLZy5Unlq1RsS1sxibZmrvDcVMmIxtKho0Oww/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Figure2. 匿名页的被交换后也是 Page Cache&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;1.5 Page Cache 与 buffer cache&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;执行 free 命令，注意到会有两列名为 buffers 和 cached，也有一行名为 “-/+ buffers/cache”。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;~ free -m&lt;br/&gt;             total       used       free     shared    buffers     cached&lt;br/&gt;Mem:        128956      96440      32515          0       5368      39900&lt;br/&gt;-/+ buffers/cache:      51172      77784&lt;br/&gt;Swap:        16002          0      16001&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，cached 列表示当前的页缓存（Page Cache）占用量，buffers 列表示当前的块缓存（buffer cache）占用量。用一句话来解释：&lt;strong&gt;Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。&lt;/strong&gt;页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache）占用量，buffers 列表示当前的块缓存（buffer cache）占用量。用一句话来解释：&lt;strong&gt;Page Cache 用于缓存文件的页数据，buffer cache 用于缓存块设备（如磁盘）的块数据。&lt;/strong&gt;页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache 与 buffer cache 的共同目的都是加速数据 I/O：写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Linux 2.4 版本的内核之前，Page Cache 与 buffer cache 是完全分离的。但是，块设备大多是磁盘，磁盘上的数据又大多通过文件系统来组织，这种设计导致很多数据被缓存了两次，浪费内存。&lt;strong&gt;所以在 2.4 版本内核之后，两块缓存近似融合在了一起：如果一个文件的页加载到了 Page Cache，那么同时 buffer cache 只需要维护块指向页的指针就可以了&lt;/strong&gt;。只有那些没有文件表示的块，或者绕过了文件系统直接操作（如dd命令）的块，才会真正放到 buffer cache 里。因此，我们现在提起 Page Cache，基本上都同时指 Page Cache 和 buffer cache 两者，本文之后也不再区分，直接统称为 Page Cache。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图近似地示出 32-bit Linux 系统中可能的一种 Page Cache 结构，其中 block size 大小为 1KB，page size 大小为 4KB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6897689768976898&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nX2lNicGIRXafkvR6qT2VPRGq7DMhxu66a2xEs72seuLQ7iaA1LDo9Ccy76BW7hPUAMJ8kGexyR4wQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache 中的每个文件都是一棵基数树（radix tree，本质上是多叉搜索树），树的每个节点都是一个页。根据文件内的偏移量就可以快速定位到所在的页，如下图所示。关于基数树的原理可以参见英文维基，这里就不细说了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.614314115308151&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nX2lNicGIRXafkvR6qT2VPR9ULOCYcqgfIgeGosicZ5Uvb31xXraibVkA38MBSNBxGe6FTxBF4904jQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.6 Page Cache 与预读&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;操作系统为基于 Page Cache 的读缓存机制提供预读机制（PAGE_READAHEAD），一个例子是：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但是操作系统出于局部性原理[3]会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图代表了操作系统的预读机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2980332829046899&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cYSwmJQric6nX2lNicGIRXafkvR6qT2VPRZ43feicOUvE0FzQqpibgG1OYC9sFqBiaoobSicSvrfCHHbbwKf99kebhaA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;操作系统的预读机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中，应用程序利用 read 系统调动读取 4KB 数据，实际上内核使用 readahead 机制完成了 16KB 数据的读取。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2. Page Cache 与文件持久化的一致性&amp;amp;可靠性&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;现代 Linux 的 Page Cache 正如其名，是对磁盘上 page（页）的内存缓存，同时可以用于读/写操作。一切内存缓存都存在一致性问题：内存中的数据与磁盘中的数据不一致，例如用作分布式中间件缓存的 Redis 就与 MySQL 等数据库中的数据存在不一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux 提供多种机制来保证数据一致性，但无论是单机上的内存与磁盘一致性，还是分布式组件中节点 1 与节点 2 、节点 3 的数据一致性问题，理解的关键是 trade-off：吞吐量与数据一致性保证是一对矛盾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，需要我们理解一下文件的数据。&lt;strong&gt;文件 = 数据 + 元数据&lt;/strong&gt;。元数据用来描述文件的各种属性，也必须存储在磁盘上。因此，我们说保证文件一致性其实包含了两个方面：数据一致+元数据一致。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;文件的元数据包括：文件大小、创建时间、访问时间、属主属组等信息。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;我们考虑如下一致性问题：如果发生写操作并且对应的数据在 Page Cache 中，那么写操作就会直接作用于 Page Cache 中，此时如果数据还没刷新到磁盘，那么内存中的数据就领先于磁盘，此时对应 page 就被称为 Dirty page。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前 Linux 下以两种方式实现文件一致性：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Write Through（写穿）&lt;/strong&gt;：向用户层提供特定接口，应用程序可主动调用接口来保证文件一致性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Write back（写回）&lt;/strong&gt;：系统中存在定期任务（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;上述两种方式最终都依赖于系统调用，主要分为如下三种系统调用：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;fsync(intfd)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;fsync(fd)：将 fd 代表的文件的脏数据和脏元数据全部刷新至磁盘中。&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;fdatasync(int fd)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;fdatasync(fd)：将 fd 代表的文件的脏数据刷新至磁盘，同时对必要的元数据刷新至磁盘中，这里所说的必要的概念是指：对接下来访问文件有关键作用的信息，如文件大小，而文件修改时间等不属于必要信息&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;sync()&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sync()：则是对系统中所有的脏的文件数据元数据刷新至磁盘中&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;上述三种系统调用可以分别由用户进程与内核进程发起。下面我们研&lt;/span&gt;&lt;span&gt;究一下内核线程的相&lt;/span&gt;&lt;span&gt;关特性。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;创建的针对回写任务的内核线程数由系统中持久存储设备决定，为每个存储设备创建单独的刷新线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关于多线程的架构问题，Linux 内核采取了 Lighthttp 的做法，即系统中存在一个管理线程和多个刷新线程（每个持久存储设备对应一个刷新线程）。管理线程监控设备上的脏页面情况，若设备一段时间内没有产生脏页面，就销毁设备上的刷新线程；若监测到设备上有脏页面需要回写且尚未为该设备创建刷新线程，那么创建刷新线程处理脏页面回写。而刷新线程的任务较为单调，只负责将设备中的脏页面回写至持久存储设备中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;刷新线程刷新设备上脏页面大致设计如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每个设备保存脏文件链表，保存的是该设备上存储的脏文件的 inode 节点。所谓的回写文件脏页面即回写该 inode 链表上的某些文件的脏页面；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统中存在多个回写时机，第一是应用程序主动调用回写接口（fsync，fdatasync 以及 sync 等），第二管理线程周期性地唤醒设备上的回写线程进行回写，第三是某些应用程序/内核任务发现内存不足时要回收部分缓存页面而事先进行脏页面回写，设计一个统一的框架来管理这些回写任务非常有必要。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Write Through 与 Write back 在持久化的可靠性上有所不同：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3. 为什么使用 Page Cache 与为什么不使用 Page Cache?&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;3.1 Page Cache 的优势&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.加快数据访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果数据能够在内存中进行缓存，那么下一次访问就不需要通过磁盘 I/O 了，直接命中内存缓存即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于内存访问比磁盘访问快很多，因此加快数据访问是 Page Cache 的一大优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.减少 I/O 次数，提高系统磁盘 I/O 吞吐量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于 Page Cache 的缓存以及预读能力，而程序又往往符合局部性原理，因此通过一次 I/O 将多个 page 装入 Page Cache 能够减少磁盘 I/O 次数， 进而提高系统磁盘 I/O 吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;3.2 Page Cache 的劣势&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;page cache 也有其劣势，最直接的缺点是需要占用额外物理内存空间，物理内存在比较紧俏的时候可能会导致频繁的 swap 操作，最终导致系统的磁盘 I/O 负载的上升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache 的另一个缺陷是对于应用层并没有提供很好的管理 API，几乎是透明管理。应用层即使想优化 Page Cache 的使用策略也很难进行。因此一些应用选择在用户空间实现自己的 page 管理，例如 MySQL InnoDB 存储引擎以 16KB 的页进行管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Page Cache 最后一个缺陷是在某些应用场景下比 Direct I/O 多一次磁盘读 I/O 以及磁盘写 I/O。这一点可以参考[4]。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;【转自】https://spongecaptain.cool/SimpleClearFileIO&lt;/span&gt;&lt;/h2&gt;&lt;section data-style-type=&quot;7&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;9182&quot;&gt;&lt;img data-ratio=&quot;0.035&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; title=&quot;虚线阴影分割线&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FlgksGN9DLyrKwRzr1c16FygWiasGFoywNTt5ZgTU0GNicpmrDX5dfEpXfnpHGL7Ph4T39urWsicNByiaD81ib5Kictw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzIxMjE1MzU4OA==&quot; data-alias=&quot;rrgeek&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9sNwsXcN68rYQvuM9OQ4GZuQ71NNs0oqzemQYodxIzr99AUnFm3MPXGjfkmkWfyddvj20LVG1iaIPU0y8JF2jwA/0?wx_fmt=png&quot; data-nickname=&quot;人人都是极客&quot; data-signature=&quot;号主Peter&quot; data-weui-theme=&quot;light&quot;/&gt;​​&lt;/section&gt;&lt;p&gt;&lt;span&gt;5T技术资源大放送！包括但不限于：C/C++，Arm, Linux，Android，人工智能，单片机，树莓派，等等。在上面的【&lt;/span&gt;&lt;span&gt;人人都是极客&lt;/span&gt;&lt;span&gt;】公众号内回复「&lt;/span&gt;&lt;span&gt;peter&lt;/span&gt;&lt;span&gt;」，即可免费获取！！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.5343511450381679&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;393&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/9sNwsXcN68oYhIcYpqoZIhRU7sh0DPCQUEQ41ZNlgBriarPhich5ErCic7u77K0o2xshzNxOSUHgytLibN521HDw6w/640?wx_fmt=gif&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;记得点击&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;赞&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;和&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，给我充点儿电吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;10000&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10de3057838a50cc8794764629914b6c</guid>
<title>那些意欲取代 C++ 的编程语言，成功了吗？</title>
<link>https://toutiao.io/k/hvnx4ts</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;span&gt;↓&lt;/span&gt;&lt;span&gt;推荐关注↓&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MjM5MzA0OTkwMA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KovAgJ2aWyaPst9OYjHrAqibrbuoMgeibF7wVjf3CtwH61t8vcpADVpKupekBvic4gX8Ku7Hene4MU6aKMTcE3Z2g/0?wx_fmt=png&quot; data-nickname=&quot;伯乐在线&quot; data-alias=&quot;jobbole&quot; data-signature=&quot;伯乐在线分享IT互联网职场和精选干货文章（原域名已不再维护）。组织维护10万+star的开源技术资源库，包括：Python, Java, C/C++, Go, JS, CSS, Node.js, PHP, .NET 等&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;7&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;转自：CSDN&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section data-mpa-template=&quot;t&quot; data-mpa-category=&quot;正文&quot; data-mpa-template-id=&quot;1440&quot;&gt;&lt;section label=&quot;powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;【编者按】&lt;/span&gt;&lt;span&gt;说起 C++ 语言，程序员们应该再熟悉不过了。它包含了 C 语言提供的所有功能。在应用程序中，C++ 无处不在。近日，Garmin 的一名软件工程师 Lucian Radu Teodorescu 在一篇文章中总结了目前 C++ 继任语言的技术状况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：https://accu.org/journals/overload/30/172/teodorescu&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2022 年出现了许多可以与 C++ 竞争的语言。就在今年的 CPP North C++ 大会上，谷歌宣布了一门新的编程语言 Carbon，并称其将是「C++ 的继任者」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这一事件，国外媒体和开发者们也询问了 C++ 之父 Bjarne Stroustrup 的看法，他表示：“这些年总是有新的语言试图成为 C++ 的继承者，我欢迎对编程语言和编程风格进行实验。但 Carbon 太新且规范不足，我无法真正做出有意义的技术评论。而通常在不开发全新语言规则、库和管理方案的情况下，很难提供 C++ 的替代方案。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该语言发出后，也让一众网友浅来围观，有支持，也有反对的声音。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近日，Garmin 的一名软件工程师 Lucian Radu Teodorescu 在文章中报道了目前 C++ 继任语言的技术状况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C++ 是一种特殊的编程语言，也是最常用的编程语言之一，但它也是最受批评的语言之一。根据 TIOBE 指数，30 年来，C++ 一直是排名前 4 的编程语言（使用12个月的平均值），并且还成功摘得了&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650949793&amp;amp;idx=1&amp;amp;sn=1d51a81941a5c9c2059e1587f4234a7e&amp;amp;chksm=bd5a39728a2db064e4ca6cb557135cea882ce5891d54b086b7a14e88a63cdc53b3c7c343ad2b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot; 2022 年的年度编程语言称号&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt; 2022 年的年度编程语言称号&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5915697674418605&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuga5vFb8DjTIq6SZicSg2Yy8o4DXJOMccGswabsbe9zFibhJIGTIvQ5nZ0huk0EX3NVL1G0MnmgIugg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1376&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Irpb&quot;&gt;&lt;span&gt;参见下图，可了解过去 20 年的语言趋势（2022年10月的TIOBE编程社区指数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuga5vFb8DjTIq6SZicSg2Yy8tbNBCDwAve3ztadPNyHPMvJy2Bg5ibCoyia7Xbh7F1hJkElKQqzvaw7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;mvNN&quot;&gt;&lt;span&gt;对于一种已经存在了近 40 年的编程语言来说，能经常出现在顶级编程语言的名单中，的确是一个伟大的成就。在颇受欢迎的同时，C++ 的批评声却接连不断，例如 Liunx 之父直接说 C++ 是一门糟糕的语言。大部分的人都在抱怨这种语言太大了，太复杂了，有一些是应该被扼杀的功能，有太多的功能，反之，又有些功能不够用。以偏概全，C++ 可以被看作是一个没有清晰连贯的故事的各种功能的随机集合。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;qurz&quot;&gt;&lt;span&gt;在为该语言辩护时，Bjarne Stroustrup 认为，&quot;在 C++ 中，有一种更小、更干净的语言正在努力摆脱&quot;。这句话在 28 年后的今天仍然被广泛使用。虽然这句话意在为 C++ 辩护，但如果仔细分析一下，就会发现这也是一种隐含的批评。C++ 仍然没有成为人们所期望的那种更小、更干净的语言。它可能仅仅意味着这种更小更干净的语言只是一个海市蜃楼。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;意欲取代 C++ 的编程语言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;L9nX&quot;&gt;&lt;span&gt;那么问题来了，怎样才能获得一个更好的编程语言呢？它比现在的 C++ 更简单、更干净，并且与 C++ 占据同样的空间（系统编程语言）？一个 C++ 的继任语言是什么样子的？&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;L9nX&quot;&gt;&lt;span&gt;虽然过去也有一些尝试，但像 2022 年这样的还是很少见的，一下子有 3 种继任者语言在 C++ 主题演讲中公布。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;L9nX&quot;&gt;&lt;span&gt;首先，有 Dave Abrahams 和 Dimitri Racordon 在 C++ Now 上宣布的 Val。Val 的核心思想是，我们可以使用可变值语义建立安全且高效的程序。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;3rjf&quot;&gt;&lt;span&gt;两个月后，在 CppNorth 上，Chandler Carruth 宣布了 Carbon 语言。Carbon 语言试图解决 C++ 的几个方面：几十年来积累的技术债务、优先考虑向后兼容性和 C++ 的进化过程。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZeRa&quot;&gt;&lt;span&gt;又过了两个月，在 CppCon 上，Herb Sutter 宣布了 CppFront，作为 C++ 的可能继承者。他的主要目标是 &quot;使 C++ 本身向前发展，并使 C++ 加倍发展&quot;，防止用户迁移到其他语言。宣称的目标是使 C++ 的安全性提高 50 倍，简单 10 倍。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;sC7h&quot;&gt;&lt;span&gt;本文作者 Lucian Radu Teodorescu 试图对这三种语言提供一个批判性的观点。他解释道：“这样做并不是认为它们不能成为 C++ 的继承者；恰恰相反，我试图在希望取代 C++ 的位置之前列出这些语言在需要解决的问题。虽然我确实有一些个人偏见，但我会尽力客观地进行分析。”&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 早期取代者&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;PsH6&quot;&gt;&lt;span&gt;D 编程语言由 Walter Bright 创建，出现在 2001 年；在 2007 年时，Andrei Alexandrescu 加入了设计和开发工作。这种语言本应从 C++ 的错误中学习，并成为其继承者。它承诺了同样的效率水平，但增加了大量的新功能，并简化了 C++ 的一些更复杂的部分。D 的主页将 D 宣传为一种可以 &quot;写得快、读得快、跑得快 &quot;的语言。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;0TwO&quot;&gt;&lt;span&gt;D 已经吸引了一些商业用户，但可以说它并没有达到重要的编程语言的地位。Andrei 是作者长期以来的偶像之一，而且对 Walter 相当尊敬，但主要把 D 看作是一个语言功能的大集合，松散地绑在一起。在我看来，这门语言缺乏一个清晰的基础，可以让所有的功能都有凝聚力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;vG54&quot;&gt;&lt;span&gt;Go 编程语言于 2009 年由谷歌推出；1.0 版本于 2012 年发布。这种语言的目标是让程序员 &quot;大规模地构建快速、可靠和高效的软件&quot;。Go 语言的设计者不喜欢 C++，因此，Go 似乎更像是 C 的进化，而不是 C++ 的进化。Go 在 2022 年才增加了泛型，并且仍然缺乏广泛使用的功能，如异常处理。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;xKGY&quot;&gt;&lt;span&gt;虽然 Go 可以说是一种成功的编程语言，但它的成功主要是在云计算业务中。尽管它取得了相对的成功，但它不能被称为 C++ 的继承者。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CM9k&quot;&gt;&lt;span&gt;Rust 是 Mozilla 开发的一种编程语言，2010 年时公布，第一个版本在 2015 年发布。Rust 专注于可靠（内存和线程安全）和高效的软件。Rust 语言模型是围绕着所谓的借用检查器，它能跟踪所有对象的生命周期；因此，它可以在编译时检测安全错误，并不需要使用垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tEoz&quot;&gt;&lt;span&gt;Rust 虽然不像 Go 那样流行，但似乎被认为是 C++ 的良好替代品。问题是，Rust 和 C++ 之间没有清晰/干净/通用的接口方式，这使得想转到 Rust 的 C++ 程序员经历了突然的迁移。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Val&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Val 给自己的目标定位是：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速的定义&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;默认情况下是安全的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;简单&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可与 C++ 互操作&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;AR7R&quot;&gt;&lt;span&gt;Val 以这些目标针对 C++、Rust 和 Swift 语言的受众。它的目标是实现 C++ 的性能，但要比 Rust 更简单的方式保证安全。在性能方面，Val 旨在减少编写安全软件所需的对象复制和内存分配的数量。在安全性方面，Val 中的所有结构都保证是安全的，除非用户明确要求额外的控制（将代码的一部分标记为不安全）。该语言的简单性主要来自于它对 Swift 的强烈影响，通常被认为是一种简单易用的语言。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;idIZ&quot;&gt;&lt;span&gt;许多编程语言不一定有一个贯穿其所有功能的核心思想，就像语言的催化剂一样；这会给人的印象是这些语言缺乏连贯性。这不能说是 Val 的问题。这门语言突出之处在于它有一个模型可以在程序上消除安全问题：它被称为 Mutable Value Semantics（变值语义）。但是，在这之前，一起先来探讨一下它所解决的主要问题。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;AXeI&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; C++ 本质上是不安全的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bEdf&quot;&gt;&lt;span&gt;这一切都始于这样的观察：在存在突变的情况下，引用语义可能会导致不安全的程序。因为引用语义允许创建复杂的依赖关系图，所以突变不能保证在整个图中保留安全性。例如，如果一个函数对两个对象进行操作并改变了其中一个对象时，就不能保证另一个对象不会以完全意想不到的方式发生变化。这在单线程和多线程环境中都会产生问题。此外，如果不深入检查所有可能受到影响的代码，程序员们也没有系统的方法来验证突变的后果。这简直打破了结构化编程的核心思想。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;85lN&quot;&gt;&lt;span&gt;以下面这个 C++ 代码片段为例：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;void append_vec(vector&amp;lt;int&amp;gt;&amp;amp; dest, &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  const vector&amp;lt;int&amp;gt;&amp;amp; src) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    for ( auto x: src )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      dest.push_back(x);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;hvfJ&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;忽略执行中的低效率，这段代码有一个严重的安全问题。而且，如果只看这段代码，就不容易发现这个问题；还必须看一下周围的代码。如果此函数的调用者提供相同的向量作为源参数和目标参数，那么就会导致未定义的行为。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;glDp&quot;&gt;&lt;span&gt;为了确保像这样的函数有正确的语义，则需要一个独立性的保证：程序员们需要确保所交互的对象（至少写给其中一个对象）是不相同的。这在语言中无法得到适当的执行；因此，就处于不安全的领域。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Btco&quot;&gt;&lt;span&gt;这里的问题比它看起来要复杂得多。如果一个函数的两个参数都是引用（也就是说，我们没有在其中改变任何东西），那么就没有问题。只有当我们有 mutation.const 时，问题才会出现。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tox0&quot;&gt;&lt;span&gt;Swift 通过使用 copy-on-write 技术来解决这个问题，但这可能会导致效率低下。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;tyrN&quot;&gt;&lt;span&gt;Rust 通过跟踪对象的生命周期来解决这个问题。这给程序员增加了负担，而且会给程序增加不必要的限制。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SzAr&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;可变值语义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;VdOk&quot;&gt;&lt;span&gt;函数式编程语言通过禁止突变来避免上述问题。可以对多个对象有多个引用，因为没有人可以改变这些对象。这对许多程序员来说感觉很不自然，而且对无数的算法来说效率很低。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;abkR&quot;&gt;&lt;span&gt;Val 以一种完全不同的方式解决了这个问题：它对引用增加了限制，并确保没有人可以读取一个对象，而其他人却可以改变它。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;A3ow&quot;&gt;&lt;span&gt;Val 认识到整体/部分关系的重要性。这些关系只能形成一棵树，而不是一个循环图。如果想修改这棵树上的一个对象，马上就能知道这个变化的影响，也就是所有其他可能受到这个突变影响的对象。它允许程序员们推理出哪些对象可以安全地作为读和写传入一个函数。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lu1v&quot;&gt;&lt;span&gt;最后，按照这个逻辑，可以安全地添加引用来表示整体/部分关系。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;4wbZ&quot;&gt;&lt;span&gt;在 Val 模型中，突变是不被禁止的，但是每次突变一个对象时，编译器可以计算出哪些对象可以安全地读取，哪些对象可以同时安全地写入。安全性可以通过构造来保证。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uqVJ&quot;&gt;&lt;span&gt;消除对象之间的任意引用并关注整体/部分关系是赋予 Val 价值语义的原因。但是，由于 Val 也允许值的突变，就可以把这个模型称为可变值语义学。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uqVJ&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;科学的方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;s7hV&quot;&gt;&lt;span&gt;走到这一步，作者认为很重要的一个方面：Val 似乎遵循了一种科学的方法。&lt;/span&gt;&lt;span&gt;可以看到，在上述内容简单地描述了一个确保安全的计算模型。这不仅仅是作者提出的关于语言安全的主张。他们有一个安全的证明，在语言的限制下。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SCTo&quot;&gt;&lt;span&gt;该语言的主要创造者 Dimitri Racordon，实际上是一名博士后研究员。Dave Abrahams 似乎也是志同道合的人。Dave 和 Sean Parent 一起重新组建了 Adobe 的 STLabs。可以看出 Alex Stepanov（STL的创造者，也是STLabs的前成员）对 Dave 和 Sean 的研究导向的影响。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;aRId&quot;&gt;&lt;span&gt;不能保证 Val 会像 C++ 那样成功，但可以发现解决 C++ 的一些基本问题的合理方法：清楚地定义问题，然后提出一个通用而优雅的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;aRId&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;使用临时引用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;AWQI&quot;&gt;&lt;span&gt;Val 简单地指出使用临时引用是不安全的。这使得人们不清楚如何实现需要引用的程序，而不是表达整体/部分关系。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;nLBU&quot;&gt;&lt;span&gt;例如，实现一个双链表需要不能被模拟为整体/部分关系的引用。目前还不清楚如何实现具有可变值语义的双链表。另一个例子，考虑一个应用程序中的共享缓存组件。根据定义，这样的组件需要被多方访问，并且需要允许突变。同样，我们也不清楚如何在 Val 中实现这一点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9AXH&quot;&gt;&lt;span&gt;也许这些例子的简单答案是，用户必须将一些代码标记为不安全。这也许是可以的；作为语言的使用者，我们只是缺乏如何处理这些情况的经验。Val 必须为处理这些情况提供良好的指导。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9AXH&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;C++ 的互操作性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9XKy&quot;&gt;&lt;span&gt;在写这篇文章的时候，Val 还没有明确的公开计划如何来处理与 C++ 的互操作性，它只是宣布了它的意图。为了成为 C++ 的继任语言，Val 需要解决这个问题。而且，这个问题似乎并不容易。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2BpL&quot;&gt;&lt;span&gt;首先要注意的是，根据它的描述，Val 的灵感主要来自 Swift。这意味着 Val 和 C++ 之间的差距不小（一边是 Carbon 和 Cpp2 的差距，另一边是 C++ 的差距）。缩小这个差距可能需要很大的努力。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;uxKo&quot;&gt;&lt;span&gt;第二个障碍是可变值语义系统所带来的限制。C++ 本质上包含了大量的临时引用。这意味着，C++ 代码在 Val 中会被视为包含无数的不安全操作。在作者看来，几乎所有的 C++ 操作都应该在 Val 中被标记为不安全。这似乎增加了互操作性的差距。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;GQHu&quot;&gt;&lt;span&gt;请注意，作者并不是说 Val 不能与 C++ 适当地互操作。只是想表述实现这一点可能不是一个简单的努力。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Carbon&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;vZgq&quot;&gt;&lt;span&gt;Carbon &lt;/span&gt;&lt;span&gt;是在 CppNorth 2022 上面世，意欲成为 C++ 继任语言。Carbon 得到了谷歌的支持（据 Chandler 说，也得到了 Adobe 的支持）。此外，一个有趣的事实是，谷歌则在 CppCon 2022 上缺席；也许这是谷歌在考虑放弃 C++ 的一个标志。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;h7y7&quot;&gt;&lt;span&gt;在演讲中，Chandler 列举了目前 C++ 的问题。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MDMZ&quot;&gt;&lt;span&gt;Chandler 认为，解决这些问题的办法是开始考虑 C++ 的后继任语言。类似于 C++ 被创造为 C 的继承者，Swift 被创造为 ObjectiveC 的继承者，Kotlin 被创造为 Java 的继承者，则需要找到 C++ 的继承语言。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;MDMZ&quot;&gt;&lt;span&gt;为了创建一个 C++ 的继任语言，需要在现有的生态系统中构建，提供双向的互操作性，并确保有工具来帮助迁移和学习。而这些实际上就是新宣布的 Carbon 语言的目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lVjT&quot;&gt;&lt;span&gt;与 C++ 相比，Carbon 似乎没有一个标志性的特征。它就像是一个 C++ 的清理项目。在演讲中，Chandler 展示了更简洁的语法、更干净的指针语义、更好的包装、更好的公共/私有成员的默认值、显式参数、继承清理、API 扩展点和 C++ 0x 风格的泛型。所有这些功能都以这样或那样的方式存在于其他编程语言中。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;QnTM&quot;&gt;&lt;span&gt;Carbon 可以被看作是具有更好的默认值的 C++，这是件好事。人们会看到一种熟悉的语言更好/更简单。Carbon 的学习曲线可以很平滑，从 C++ 到 Carbon 的过渡不需要跳过太多的障碍。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;kLUc&quot;&gt;&lt;span&gt;但是，另一方面，这与 D 有什么不同？D 也试图通过学习 C++ 的错误和清理其粗糙的边缘而成为 C++ 的继承者。是什么让 Carbon 语言具有内部一致性，而不是让它感觉像一群不相关的功能？&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;CAsg&quot;&gt;&lt;span&gt;如果从进化的角度来看，即使今天所有的默认值都很有意义，又有什么能保证它们在接下来的几十年里都有意义？怎样才能防止 Carbon 积累技术债务？这个问题的部分答案是，正如 Chandler 提到的，使用工具来协助迁移。但是，都看到了从 Python 2 迁移到 Python 3 是多么的痛苦；可能不是每个人都相信工具可以帮助解决未来的问题。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;o4N4&quot;&gt;&lt;span&gt;这些问题都是 Carbon 团队需要回答的问题。作者表示并不是想说这些问题很难回答，但它们需要被回答。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;o4N4&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;与 C++ 的互操作性是困难的&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;gcgs&quot;&gt;&lt;span&gt;即使 Carbon 可以成为一个具有更好的默认值的 C++，与 C++ 的互操作性也不一定容易。下面是 Sean Baxter 提出的一些观点：&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;brrX&quot;&gt;&lt;span&gt;从这些方面来看，可以很容易地看出，与 C++ 的互操作性将是一个复杂的问题。最有可能的是，即使互操作性问题能够完全解决，对于大型软件来说，从 C++ 迁移到 Carbon 也不会是一个简单的过渡。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;brrX&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文化的兴衰&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;SWKz&quot;&gt;&lt;span&gt;谷歌是一家坚信文化是软件开发的驱动力的公司。Chandler 在他的主题演讲中也用 Peter Drucker 的一句话表达了这一点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;sY0r&quot;&gt;&lt;span&gt;文化把战略当作早餐，把技术当作午餐，把产品当作晚餐，不久也会把其他一切都吃掉。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;iYlM&quot;&gt;&lt;span&gt;虽然企业文化确实是必不可少的，但仅仅引用 Peter Drucker 的话并不是成功的秘诀。主要问题是很难衡量文化及其影响。Chandler 列出了关于 Carbon 文化的几个要点（包容性、社区友好等）。虽然所有这些观点都是好的，但它们不足以定义文化，也不足以让文化在 Carbon 项目中发挥作用。例如，Chandler 没有提到卓越的技术、毅力、尝试新事物的勇气，或者如何优先考虑不同的（与文化有关的）目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;hTQr&quot;&gt;&lt;span&gt;Lucian Radu Teodorescu 表示在他以前工作的一家公司，有一句口头禅是 &quot;我们从不让项目失败&quot;。谷歌和 Carbon 项目的文化中是否有一个类似的目标？人们似乎把谷歌看作是一家尝试许多产品并在一段时间后关闭它们的公司。例如，如下图，Victor Zverovich 的一条推特，他利用这种看法开了一个关于 Carbon 的玩笑。考虑到 Chandler 还宣布谷歌有一个不同的团队有同样的目标，但他们从 Rus t开始，转向 C++ 后，这种思路可能并不太牵强。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;BXSo&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34164070612668745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuga5vFb8DjTIq6SZicSg2Yy8VWsw5MYibXs66t7Rw1Bc4hm8qf3LOgElQh3XfHtVWzvFkhTU9dfvPQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;963&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZSLE&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;Lucian Radu Teodorescu 表示文化是好的，Chandler 提出的观点也是好的。但是，想要说服一名工程师则需要可验证的论据。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZSLE&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;治理模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;nEdR&quot;&gt;&lt;span&gt;关于 Carbon 公告的一个有趣之处是治理模式。Carbon 项目的目标是实现一种没有任何公司能决定语言未来的治理。每个人都可以通过创建拉动请求来参与语言的发展，但越是重要的功能，就越需要分析/论证。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1U13&quot;&gt;&lt;span&gt;对于没有达成共识的重要功能，有一个由三名成员（Chandler Carruth, Kate Gregory, Richard Smith）组成的指导委员会，负责达成决定。他们没有机会对设计做出贡献；他们只需要权衡提交给他们的论据并做出选择。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;UPpH&quot;&gt;&lt;span&gt;有趣的是，这个模型试图强调一个民主的过程，这在某种程度上类似于 ISO 的目标。这只是对参与各方的不同划分，当陷入僵局时会有更明确的规则来做什么。如果从事 C++ 标准化工作的人也从事 Carbon 的工作，那么 Carbon 的过程是否会明显好转就不清楚了。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;wepU&quot;&gt;&lt;span&gt;虽然民主方法是目前最好的治理方式，但我们最近看到了一系列重大的政治失败，这些失败可能与民主的负面影响直接相关。值得一提的是，在古希腊，民主被认为是一种糟糕的治理方式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Cpp2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cipk&quot;&gt;&lt;span&gt;CppFront 是 Herb Sutter 在 CppCon 2022 的闭幕主题演讲中宣布的一个项目。&lt;/span&gt;&lt;span&gt;它是一个转码器，可以将 &quot;更好的 C++&quot;，即 Cpp2，转换为旧的 C++。&lt;/span&gt;&lt;span&gt;虽然 CppFront / Cpp2 是今年正式宣布的，但 Herb 已经在这个项目上工作了大约 7 年；&lt;/span&gt;&lt;span&gt;每年，Herb 都会展示 Cpp2 的一小部分。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;w084&quot;&gt;&lt;span&gt;Herb 希望改进 C++（即10倍），而不是进行增量式的改变（即10%）。他希望使 C++ 实现 30 年前 Stroustrup 设想的那个更简单、更干净的语言的老目标。有趣的是，它采用了 Stroustrup 想改进 C 语言时相同的方法：开始一种新的语言并将代码翻译成以前的语言。因此，CppFront 是一个小型转译器，它接收 Cpp2 代码（Herb的新语言）并输出常规的 C++ 代码。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9QKk&quot;&gt;&lt;span&gt;Herb 还设定了一些指标，我们可以用这些指标来评估这个实验是否成功。更安全50倍（也就是减少98%的CVE），更简单10倍（减少90%的教学指导）。预先定义指标是一个很好的策略，能够评估实验的成功；我非常喜欢这个想法。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;so7t&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;向后兼容性和互操作性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;cWzL&quot;&gt;&lt;span&gt;通过放弃向后兼容性，Cpp2 可以比 C++ 更简单。这最终允许该语言删除那些被认为是有害的功能，并重新审视一些被证明是次优的设计选择。通过放弃向后兼容性，Cpp2 最终可以解决 C++ 中几十年积累的技术债务。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;2DY9&quot;&gt;&lt;span&gt;说实话，在 C++ 中优先考虑向后兼容性优先于语言发展并不是一个可靠的例子。每次我们为语言添加一个主要的功能（例如，概念、程序、模块等）时，我们实际上是在语言中创造一个新的时代。新的代码可以与旧的代码互动，但旧代码不能简单地依赖用新特性编写的新代码。尽管 C++ 标准没有正式提及语言时代，但是在语言中有一个底层的时代系统，由新特性的发布所决定。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;n1ho&quot;&gt;&lt;span&gt;可以将 Cpp2 看作是 C++ 的一个主要新特性。在互操作性和工具方面，事情要复杂一些，但本质是一样的。在同一个应用程序中，旧式 C++ 不能与 Cpp2 共存，这在技术上没有充分的理由。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZJJj&quot;&gt;&lt;span&gt;按照设计，Cpp2 在语义上与 C++ 接近；这使得互操作性更容易。另一方面，这也会阻止 Cpp2 拥有与 C++ 完全不同的特性。例如，Cpp2 就很难使用 C++ 0x 式的泛型。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;ZJJj&quot;&gt;&lt;strong&gt;&lt;span&gt;解决安全问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;eGKI&quot;&gt;&lt;span&gt;安全性提高 50 倍的目标听起来令人印象深刻。如果 Cpp2 能够实现这个目标，我相信大多数语言的用户都会感到高兴。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;mBB8&quot;&gt;&lt;span&gt;让我们从这个数字的角度来全面了解其影响。这意味着 98% 的 C++ 应用程序如果被翻译成 Cpp2 就不会再崩溃了（假设崩溃只由不安全的应用程序产生）。或者说，98% 的 C++ 网络应用不会有漏洞（如果没有其他非C++的漏洞）。这将大幅减少崩溃和安全漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;wKef&quot;&gt;&lt;span&gt;这似乎好得令人难以置信。实际上，如果我们更详细地分析，这些数字似乎太高了。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;3mH5&quot;&gt;&lt;span&gt;首先，如果讨论安全问题，需要清楚地知道什么是安全。安全性包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;类型安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;边界安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生命周期安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初始化安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对象访问安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;算术安全&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;BC7j&quot;&gt;&lt;span&gt;Herb 在他的主题演讲中提到了上述的前4个项目。然而，这些安全项目的所有方面并没有得到解决。作为一个主要的例子，在存在原始 pointer 时不能保证生命周期安全；仅仅检查 pointer 是远远不够的。也没有任何一个功能来检测 pointer .null 的使用后删除情况。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;t49H&quot;&gt;&lt;span&gt;Cpp2，正如 CppCon 主题演讲中所描述的，无法检测到这段代码的问题：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vec.push_back(vec.front());&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;LJgf&quot;&gt;&lt;span&gt;Herb 定义了他的安全指标，包括前四个安全组件；故意忽略其他类型的安全似乎很奇怪。尤其是如果被忽略的安全成分很重要的话。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;raN6&quot;&gt;&lt;span&gt;对象访问安全是指受对象访问模式影响的安全规则。一般来说，这一类的不安全代码可以转化为类型安全、边界安全或生命周期安全。无效迭代器的规则是这个类别中很好的例子。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dhYV&quot;&gt;&lt;span&gt;线程安全是 C++ 的一个大问题，Herb 完全没有提到。在她 2021 年的 C++ Now 演讲中，Anastasia Kazakova 展示了数据，显示在 C++ 社区中，并发安全占用户 setback 的 27%。相比之下，边界安全问题只占 16%，使用后删除问题占用户 setback 的 15%。并发安全是安全性方面最大的痛点，而这一点没有在 Herb 的列表中得到体现。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;oZeH&quot;&gt;&lt;span&gt;Herb 在他的幻灯片上表示，Cpp2 获得了 &quot;结构安全&quot;。这不可能是真的。结构安全性应该是指语言的构建方式总是能够导致安全的构造（除非程序员真的忽略了类型系统并将安全性掌握在自己手中）——类似于 Val 或 Rust 的构建方式。但 Cpp2 并没有这样做；它只是对一些常见的不安全行为的来源增加了更多的安全检查。如果你看过 Dave Abrahams 和 Dimitri Racordon 的演讲，以及 Sean Parent 的演讲，这一点应该马上就能看出来。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;JYsk&quot;&gt;&lt;span&gt;这让我相信，在安全性上提高 50 倍是不可能实现的目标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;JYsk&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关于目标的可衡量性 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;grr3&quot;&gt;&lt;span&gt;理论上，在任何时候，我们都可以根据这些指标来衡量进展，可以评估这个实验是否成功或能否成功。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;GiSu&quot;&gt;&lt;span&gt;让我们从第二个指标开始：简单 10 倍，就像我们需要在 C++ 书籍中教授的指导中衡量的那样。在这个实验被证明是成功之前，人们不太可能写关于 Cpp2 的书，但可以想象这样一本书的内容是什么。可以确定哪些是我们需要教授的关于 Cpp2 的一系列概念，并且我们可以将其与我们目前正在教授的关于 C++ 的内容清单进行比较。因此，我们可以衡量这个指标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;bYgp&quot;&gt;&lt;span&gt;这并不像人们想象的那样简单。C++ 有很长的历史；因此我们知道它的陷阱，人们在 C++ 书籍中记录了这些陷阱。但是，Cpp2 没有这么丰富的历史，所以，人们总是怀疑我们不知道它的所有陷阱。然而，Cpp2 与 C++ 如此接近，我真诚地相信可以排除这些顾虑，得到一个关于简单性的准确测量。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;hFvs&quot;&gt;&lt;span&gt;但是，我不能对第二个指标说同样的话。我们如何衡量 CVE 和安全漏洞的百分比？首先需要有一个足够大的 Cpp2 程序的语料库，由大量的程序员和公司编写。然而，为了实现这一点，Cpp2 需要被认为是一种成功——一种循环的依赖。因此，在 Herb 的演讲中定义的安全度量并不是衡量实验成功的指标。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lpE0&quot;&gt;&lt;span&gt;在主流语言使用一段时间后，使用这个指标来评估语言是有意义的，但不能判断实验的成功。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;lpE0&quot;&gt;&lt;strong&gt;&lt;span&gt;有还是没有 monads&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;P6q2&quot;&gt;&lt;span&gt;在主题演讲的1小时33分（以YouTube视频为参考）中，Herb Sutter 骄傲地说：&quot;我没有说过一次 monads 这个词&quot;。然后他继续解释说，Cpp2 是关于我们目前在 C++ 中使用的语言理念；而不是来自其他语言的奇怪的外来术语。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;gIQc&quot;&gt;&lt;span&gt;虽然这句话可能会吸引 C++ 社区中以自我为中心的部分人，但我认为它对社区的伤害要大于帮助。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Ho1o&quot;&gt;&lt;span&gt;首先，C++ 到处都在使用 monads。新的 C+ +23 特性可能是使用 monads 的一个已知例子，但 C++ 从根本上说是围绕着 monads 建立的。当我们调用可能抛出异常的函数时，我们隐含地使用了 monads 。也就是说，几乎到处都是。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;8Tma&quot;&gt;&lt;span&gt;其次，它在语言用户中创造了一种自给自足的感觉。这样的声明不是向社区开放新的想法，而是传递了一个信息：C++ 不需要向其他语言学习。但是，该语言拥有的大量技术债务，以及三种继任语言的出现，证明了这一点。&lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;比较&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dj7V&quot;&gt;&lt;span&gt;下面的表中试图提供三种语言之间的比较；C++ 也是一个基准。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;FEKn&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5104761904761905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuga5vFb8DjTIq6SZicSg2Yy81IlxpQA7xDTCeKJaqFNRjxlT5613Q9WnnRka4Ov9qwOnoItLUD37mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;525&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;Bum6&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;今年宣布的 3 种 C++ 继任语言都被认为是试验品。并没有很好的指标表明它们是否真的能成功地吸引足够数量的编码人员/代码库，在生产环境中使用它们。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;nF6r&quot;&gt;&lt;span&gt;看看 GitHub 上的星星数量，我们看到 Carbon 是这群人中的佼佼者，与其他两个相比，有很大的差距。Carbon 已经成功地在社区内进行了更多的炒作；对包容性的关注和治理模式可能对此有贡献。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;EzKI&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5583333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pn4Sm0RsAuga5vFb8DjTIq6SZicSg2Yy8JKfPKNN4mNddMwQqlXR84R1TjvTd5OoplSXMpqCuMaicv1YnW1sDOIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;56oZ&quot; ql-global=&quot;true&quot;&gt;&lt;span&gt;这三种语言也在它们与 C++ 的相似程度方面有所区别。正如所料，Cpp2 是三种语言中最接近 C++ 的。Carbon 似乎离 C++ 更远，但使用了与 C++ 相同的基本构件块；在 Carbon 中，用户的思考方式与他们在 C++ 中的方式基本相同。由于可变值语义，Val 程序员在编程时需要有一个稍微不同的思维模型，这可能使 Val 成为一种离 C++ 更远的语言。另一方面，如果我们看一下 Val 的快速定义口号，特别是在默认安全和简单的背景下，该语言的原则似乎可以很好地转化为 C++ 的受众。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;9Q70&quot;&gt;&lt;span&gt;在这三种新的语言中，Val 是唯一一种能够支持其安全承诺的语言。其他两种语言试图改变一些最不安全的操作的默认值；目前还不清楚这是否有很大的区别。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;1LT0&quot;&gt;&lt;span&gt;就语言特性的一致性而言，这三种语言似乎都比 C++ 更好。但在语言的连贯性方面，改变默认值并不能让你走得那么远。在这里，与 Carbon 和 Cpp2 相比，Val 的方法似乎更有连贯性。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;wTGl&quot;&gt;&lt;span&gt;最后，我认为在我们这样的工程学科中很重要的一点是：有多少语言设计决定是由某种科学支持的？在这方面，Val 似乎是唯一有一些理论基础的。这可以为其用户提供真正的保证。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;放弃还为时过早&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;dlVA&quot;&gt;&lt;span&gt;Herb 在他的主题演讲中呼吁不要放弃 C++。这是一个来自 C++ 的领导层的证明，人们正在考虑放弃 C++。在一年内出现了三种 C++ 的继任语言，正好证实了这一想法。C++ 是否开始默默无闻还不得而知，但我们大概可以认为，今年是 C++ 未来的一个拐点。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;0m2c&quot;&gt;&lt;span&gt;目前，要判断这些实验是否会成功还为时过早。所有的语言都有优点，也都有弱点。如果其中至少有一种成功了，我相信我们会推进编程语言的实践；这可能意味着在整个软件行业的积极影响。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;U7Ue&quot;&gt;&lt;span&gt;在这次比较中，尽可能地保持了客观，但我确实有自己的偏见。我希望这些偏见不会妨碍在比较这些语言时做得很好。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;P6ci&quot;&gt;&lt;span&gt;说到偏见，我确实需要承认：在业余时间，我已经开始与 Val 团队合作，推动语言的核心理念。对我来说，这些想法，如果能在实践中得到完善和成功采用，比特定的语言更重要。如果 Val 作为一种编程语言消亡了，但它的所有想法都被纳入了 C++，那么我会很高兴。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;6fWi&quot;&gt;&lt;span&gt;自从我看到 Dave 和 Dimitri 在 C++ Now 上的演讲录音后，我就被可变值语义的思想所吸引。在 2022 年的 CppCon 上，我见到了 Dave 和 Dimitri，并和他们一起探讨了一些细节，使我相信 Val 背后的想法是深刻的，经过深思熟虑的，值得密切关注。&lt;/span&gt;&lt;/p&gt;&lt;p ql-global-para=&quot;true&quot; line=&quot;mw7L&quot;&gt;&lt;span&gt;看一下流行的数字，Val 的表现并不那么好。可能其中一个原因是，好的想法需要时间来沉淀。套用一个著名的演讲，我选择为 Val 工作，不是因为它容易，而是因为它困难；因为 Val 的目标是值得的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引用：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[ADSP22] Connor Hoekstra, Bryce Adelstein Lelbach, Connor, Sean Baxter, ADSP: The Podcast, Episode 97: ‘C++ vs Carbon vs Circle vs CppFront with Sean Baxter’, 2022, https://adspthepodcast.com/2022/09/30/Episode-97.html&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Abrahams22a] Dave Abrahams, A Future of Value Semantics and Generic Programming (part 1), C++ Now 2022,&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.youtube.com/watch?v=4Ri8bly-dJs&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Abrahams22b] Dave Abrahams, Dimitri Racordon, A Future of Value Semantics and Generic Programming (part 2), C++ Now 2022, https://www.youtube.com/watch?v=GsxYnEAZoNI&amp;amp;list=WL&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Abrahams22c] Dave Abrahams, ‘Values: Safety, Regularity, Independence, and the Future of Programming’, CppCon 2022&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Carbon] GitHub, Carbon Language: An experimental successor to C++, https://github.com/carbon-language/carbon-lang&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Carruth22] Chandler Carruth, ‘Carbon Language: An experimental successor to C++’, CppNorth 2022, https://www.youtube.com/watch?v=omrY53kbVoA&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Kazakova21] Anastasia Kazakova, ‘Code Analysis++’, CppNow, 2021, https://www.youtube.com/watch?v=qUmG61aQyQE&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Parent22] Sean Parent, ‘Exceptions the Other Way Around’, https://www.youtube.com/watch?v=mkkaAWNE-Ig&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Racordon22a] Dimitri Racordon, Denys Shabalin, Daniel Zheng, Dave Abrahams, Brennan Saeta, ‘Implementation Strategies for Mutable Value Semantics’&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.jot.fm/issues/issue_2022_02/article2.pdf&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Racordon22b] Dimitri Racordon, ‘Val Wants To Be Your Friend: The design of a safe, fast, and simple programming language’, CppCon 2022, https://www.youtube.com/watch?v=ELeZAKCN4tY&amp;amp;list=WL&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Stroustrup94] Bjarne Stroustrup, The Design and Evolution of C++, Addison-Wesley Professional, 1994&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Sutter22] Herb Sutter, ‘Can C++ be 10× simpler &amp;amp; safer … ?’, CppCon 2022, https://www.youtube.com/watch?v=ELeZAKCN4tY&amp;amp;list=WL&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[TIOBE22] TIOBE, TIOBE Index for October 2022, October 2022, https://www.tiobe.com/tiobe-index/ (last accessed October 2022)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Wikipedia] Wikipedia, C++, https://en.wikipedia.org/wiki/C%2B%2B#Criticism&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Val] The Val Programming Language, https://www.val-lang.dev/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;[Zverovich22] Victor Zverovich, ‘Google will soon have…’, Twitter, 2022, https://twitter.com/vzverovich/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Lucian Radu Teodorescu has a PhD in programming languages and is a Staff Engineer at Garmin. He likes challenges; and understanding the essence of things (if there is one) constitutes the biggest challenge of all&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link&quot; data-miniprogram-appid=&quot;wx4b74228baa15489a&quot; data-miniprogram-path=&quot;lib/item/dist/pages/index/index?pfr=foot&amp;amp;itemID=4798764408&amp;amp;itemId=4798764408&quot; data-miniprogram-nickname=&quot;微店+&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot; href=&quot;&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/75TZzMDzrHicTrtHkyYXHIRic2geP6qAw6lfdtTnXRmutUVYGby51FaoYicN77sh5Z1VGmQ0rmXpsVtlR4hLAOicQw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;0、&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0OTkwMA==&amp;amp;mid=2651204107&amp;amp;idx=1&amp;amp;sn=6fedd722bf9021e9b94e356be7f3759b&amp;amp;chksm=bd6e76488a19ff5ef41bb5e61d0d95483a2306de3c919a59a37b81ba87816aa48e7da6225e17&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;极客专属：几十款程序员秒懂的‍卫衣&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;极客专属：几十款程序员秒懂的卫衣&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0OTkwMA==&amp;amp;mid=2651204755&amp;amp;idx=1&amp;amp;sn=a4b4a855b4b0232e3cfefd2af7cb7a3c&amp;amp;chksm=bd6e70d08a19f9c6abef2d61bd7b2fea1e7e408c32c291bbe7f54c24a5658c2e94f297736a68&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;大厂都病了！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大厂都病了！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0OTkwMA==&amp;amp;mid=2651204781&amp;amp;idx=1&amp;amp;sn=5019e4eff4dd3d2a6e0ef2561d960399&amp;amp;chksm=bd6e70ee8a19f9f80f449b1122b49577a017aaeb0669039c1e64a2ebdde0d60bde77c1091187&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;祖师爷香农，到底有多神？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;祖师爷香农，到底有多神？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MzA0OTkwMA==&amp;amp;mid=2651204797&amp;amp;idx=1&amp;amp;sn=6092fe880805227ff70c6092aac9858d&amp;amp;chksm=bd6e70fe8a19f9e881d8929c673f19d0cdf259b4bccb74046e9243eefa2d58f64947a0c530b5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;曾经对程序员最好的公司，倒下了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;曾经对程序员最好的公司，倒下了&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;伯乐在线&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;分享IT互联网职场和精选干货文章（原域名已不再维护）。组织&lt;/span&gt;维护10万+star的开源技术资源库，包括：Python, Java, C/C++, Go, JS, CSS, Node.js, PHP, .NET 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;回复 &lt;/span&gt;&lt;span&gt;资源&lt;/span&gt;&lt;span&gt; 获取10万+star开源资源&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MjM5MzA0OTkwMA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KovAgJ2aWyaPst9OYjHrAqibrbuoMgeibF7wVjf3CtwH61t8vcpADVpKupekBvic4gX8Ku7Hene4MU6aKMTcE3Z2g/0?wx_fmt=png&quot; data-nickname=&quot;伯乐在线&quot; data-alias=&quot;jobbole&quot; data-signature=&quot;伯乐在线分享IT互联网职场和精选干货文章（原域名已不再维护）。组织维护10万+star的开源技术资源库，包括：Python, Java, C/C++, Go, JS, CSS, Node.js, PHP, .NET 等&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8778903f75b7e353c36c25a664789266</guid>
<title>关于数仓基础知识的超全概括</title>
<link>https://toutiao.io/k/cclpwhh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据仓库，英文名称为Data Warehouse，可简写为DW或DWH。&lt;/strong&gt;数据仓库，是为企业所有级别的决策制定过程，提供所有类型数据支持的战略集合。它出于分析性报告和决策支持目的而创建。为需要业务智能的企业，提供指导业务流程改进、监视时间、成本、质量以及控制。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据仓库能干什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;136&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;span&gt;一个电商网站订单的完成包括：浏览、下单、支付、物流，其中物流环节可能和中通、申通、韵达等快递公司合作。快递公司每派送一个订单，都会有订单派送的确认时间，可以根据订单派送时间来分析哪个快递公司比较快捷高效，从而选择与哪些快递公司合作，剔除哪些快递公司，增加用户友好型。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据仓库的特点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. 数据仓库的数据是面向主题的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;与传统数据库面向应用进行数据组织的特点相对应，&lt;strong&gt;&lt;span&gt;数据仓库中的数据是面向主题进行组织的。&lt;/span&gt;&lt;/strong&gt;什么是主题呢？首先，主题是一个抽象的概念，是较高层次上企业信息系统中的数据综合、归类并进行分析利用的抽象。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在逻辑意义上，它是对应企业中某一宏观分析领域所涉及的分析对象。面向主题的数据组织方式，就是在较高层次上对分析对象的数据的一个完整、一致的描述，能完整、统一地刻划各个分析对象所涉及的企业的各项数据，以及数据之间的联系。&lt;span&gt;&lt;strong&gt;所谓较高层次是相对面向应用的数据组织方式而言的，&lt;/strong&gt;&lt;/span&gt;是指按照主题进行数据组织的方式具有更高的数据抽象级别。说白了就个写作文一样，写什么你总的有个主题思想啊！&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 数据仓库的数据是集成的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据仓库的数据是从原有的分散的数据库数据抽取来的。&lt;/strong&gt;操作型数据与分析型数据之间差别甚大。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;这一步是数据仓库建设中最关键、最复杂的一步，所要完成的工作有：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;要统一解决源数据中所有矛盾之处，如字段的同名异义、异名同义、单位不统一、字长不一致等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进行数据综合和计算。数据仓库中的数据综合工作可以在从原有数据库抽取数据时生成，但许多是在数据仓库内部生成的，即进入数据仓库以后进行综合生成的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;大部分情况下一般数仓的建立是由大数据部门负责构建，而别的分析业务部门是无权直接用线上的table的&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3. 数据仓库的数据是不可更新的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据仓库的数据主要供企业决策分析之用，所涉及的数据操作主要是数据查询，&lt;/strong&gt;一般情况下并不进行修改操作。数据仓库的数据反映的是一段相当长的时间内历史数据的内容，是不同时点的数据库快照的集合，以及基于这些快照进行统计、综合和重组的导出数据，而不是联机处理的数据。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库中进行联机处理的数据经过集成输入到数据仓库中，&lt;strong&gt;&lt;span&gt;一旦数据仓库存放的数据已经超过数据仓库的数据存储期限，这些数据将从当前的数据仓库中删去。&lt;/span&gt;&lt;/strong&gt;因为数据仓库只进行数据查询操作，所以数据仓库管理系统相比数据库管理系统而言要简单得多。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4. 数据仓库的数据是随时间不断变化的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据仓库中的数据不可更新是针对应用来说的，&lt;/span&gt;&lt;/strong&gt;也就是说，数据仓库的用户进行分析处理时是不进行数据更新操作的。但并不是说，在从数据集成输入数据仓库开始到最终被删除的整个数据生存周期中，所有的数据仓库数据都是永远不变的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据仓库的数据是随时间的变化而不断变化的，这是数据仓库数据的第四个特征。&lt;strong&gt;这一特征表现在以下3方面：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据仓库发展历程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0964749536178107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j216Z17DjWKia10PIj9gXffDCYaW6o7qPXee0mRbo8VEZQ2ZXWaJXLRCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据库与数据仓库的区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.4052953156822812&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2Kjo1FLcwVIX6ZstciaMbNTicvgBTJjzMnoMPc1RO0dUkylmdvwrssmIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;OLTP跟OLAP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库与数据仓库的区别实际讲的是OLTP与OLAP的区别。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7587412587412588&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2hU7o69ibiajOZ3KIkpGIYlyDO8YeY9eexuepAHYlU7QzmicdQpd1VtP4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;7&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;数据仓库架构分层(重点)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. 数据仓库架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;数据仓库标准上可以分为四层：&lt;/strong&gt;ODS（临时存储层）、PDW（数据仓库层）、DM（数据集市层）、APP（应用层）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.665625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2JDACRYs36xDytmiaspFNjES9uRMfOS4LoX7SfhRicfajZVLeRBGOFHkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;各个系统的元数据通过ETL同步到操作性数据仓库ODS中，对ODS数据进行面向主题域建模形成DW（数据仓库），DM是针对某一个业务领域建立模型，具体用户（决策层）查看DM生成的报表。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;217&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;DW :&lt;/strong&gt; Data Warehouse 翻译成数据仓库，DW由下到上分为 DWD、DWB、DWS。DWD：Warehouse Detail 细节数据层，有的也称为 ODS层，是业务层与数据仓库的隔离层 DWB：Data Warehouse Base 基础数据层，存储的是客观数据，一般用作中间层，可以认为是大量指标的数据层。DWS：Data Warehouse Service 服务数据层，基于DWB上的基础数据，整合汇总成分析某一个主题域的服务数据，一般是宽表。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 为什么要对数据仓库分层？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;用空间换时间，通过大量的预处理来提升应用系统的用户体验（效率），因此&lt;strong&gt;&lt;span&gt;数据仓库会存在大量冗余的数据&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;解偶，如果不分层的话，如果源业务系统的业务规则发生变化将会影响整个数据清洗过程，工作量巨大&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过数据分层管理可以简化数据清洗的过程，因为把原来一步的工作分到了多个步骤去完成，相当于把一个复杂的工作拆成了多个简单的工作，把一个大的黑盒变成了一个白盒，每一层的处理逻辑都相对简单和容易理解，这样我们比较容易保证每一个步骤的正确性，当数据发生错误的时候，往往我们只需要局部调整某个步骤即可。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;8&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;span&gt;&lt;strong&gt;元数据介绍&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当需要了解某地企业及其提供的服务时，电话黄页的重要性就体现出来了。元数据(Metadata)类似于这样的电话黄页。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. 元数据的定义&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7599067599067599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pDnsbKziazM6cOSayIdBqszTwM6uptibUh3m1CPQMr7L2icUOzgU1fPnbXAAEqfrdn0lLq6XA0iaibCSfibE6rCrjkPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7599067599067599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pDnsbKziazM6cOSayIdBqszTwM6uptibUh3m1CPQMr7L2icUOzgU1fPnbXAAEqfrdn0lLq6XA0iaibCSfibE6rCrjkPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.634375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2vQ1uFMBmiacJpngicGnbutib3ekTtdPsHS8iaYC2LW0PpxmvQ5KrJvvRog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 元数据的存储方式&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8945538818076477&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pDnsbKziazM6cOSayIdBqszTwM6uptibUhFEicCff3IHiaIUmQpMkN1JVYbwst9ezQxp9GQG0CiaW7BibyODyOVIbGvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;863&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3. 元数据的作用&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/pDnsbKziazM6cOSayIdBqszTwM6uptibUhOHEsIPy5QOTLpGHphWVFXJUsalf91OdxBJIePSpMb8kmLFFuaCpgvA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;733&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;253.52867383512546&quot; data-ratio=&quot;0.3451568894952251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/yAyQKzCbAHajpb23XsFiaE0VD6sNzcoTLicnnIAianBHuwQKYLj0bcNW6fTo8LMQMz6NrtvRYjDVoytGf4sTu9QeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3755040&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;paragraph&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;us-3745050&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot; mpa-none-contnet=&quot;t&quot;&gt;9&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-width=&quot;20%&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;星型模型和雪花模型&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在多维分析的商业智能解决方案中，根据事实表和维度表的关系，&lt;strong&gt;&lt;span&gt;又可将常见的模型分为星型模型和雪花型模型。&lt;/span&gt;&lt;/strong&gt;在设计逻辑型数据的模型的时候，就应考虑数据是按照星型模型还是雪花型模型进行组织。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. 星型模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当所有维表都直接连接到事实表上时，整个图解就像星星一样，故将该模型称为&lt;span&gt;&lt;strong&gt;星型模型。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2biaiaDFlOd5j5QI9EmZLbicA6nCAObY7FSeqPMVOIDHYJytHe09vGjQXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;星型架构是一种非正规化的结构，多维数据集的每一个维度都直接与事实表相连接，不存在渐变维度，所以数据有一定的冗余，如在地域维度表中，存在国家A 省B的城市C以及国家A省B的城市D两条记录，那么国家A和省B的信息分别存储了两次，即存在冗余。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 雪花模型&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当有一个或多个维表没有直接连接到事实表上，而是通过其他维表连接到事实表上时，&lt;strong&gt;其图解就像多个雪花连接在一起，故称雪花模型。雪&lt;/strong&gt;花模型是对星型模型的扩展。它对星型模型的维表进一步层次化，原有的各维表可能被扩展为小的事实表，形成一些局部的层次 区域，这些被分解的表都连接到主维度表而不是事实表。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如图所示，将地域维表又分解为国家，省份，城市等维表。它的优点是：&lt;strong&gt;&lt;span&gt;通过最大限度地减少数据存储量以及联合较小的维表来改善查询性能。&lt;/span&gt;&lt;/strong&gt;雪花型结构去除了数据冗余。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TEMFmlppic0Yhy99P1ysNKFWNEVj7e1j2GEPYYDicsxrKs06iaz76pT81WNcT0Pib8Z5E2bso8W0qHzYjxibhVjNib2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花型模型要高。星型结构不用考虑很多正规化的因素，设计与实现都比较简单。雪花型模型由于去除了冗余，有些统计就需要通过表的联接才能产生，所以效率不一定有星型模型高。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;正规化也是一种比较复杂的过程，相应的数据库结构设计、数据的 ETL、以及后期的维护都要复杂一些。因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3. 星型模型和雪花模型对比&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;星形模型和雪花模型是数据仓库中常用到的两种方式，而它们之间的对比要从四个角度来进行讨论。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>