<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>410b33aba7a9684e88952fd24b9fa416</guid>
<title>内部分享讲解DevOps后，我再组织成文</title>
<link>https://toutiao.io/k/asi9e5r</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot; class=&quot;zh_CN wx_wap_page &amp;#10;&amp;#10;                                            wx_wap_desktop_fontsize_2    mm_appmsg&amp;#10; comment_feature&amp;#10; discuss_tab appmsg_skin_default appmsg_style_default&quot;&gt;
    





    






    






&lt;p class=&quot;wx_network_msg_wrp&quot; id=&quot;js_network_msg_wrp&quot;/&gt;

















&lt;div id=&quot;js_pc_weapp_code&quot; class=&quot;weui-desktop-popover weui-desktop-popover_pos-up-center weui-desktop-popover_img-text weapp_code_popover&quot;&gt;
  &lt;div class=&quot;weui-desktop-popover__inner&quot;&gt;
      &lt;div class=&quot;weui-desktop-popover__desc&quot;&gt;
          &lt;img id=&quot;js_pc_weapp_code_img&quot;/&gt;&lt;p&gt;
          微信扫一扫&lt;/p&gt;&lt;p&gt;使用小程序&lt;/p&gt;&lt;span id=&quot;js_pc_weapp_code_des&quot;/&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;





    
    

&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_colon&quot;&gt;：&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_comma&quot;&gt;，&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_period&quot;&gt;。&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_space&quot;&gt; &lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_video&quot;&gt;视频&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_weapp&quot;&gt;小程序&lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_txt&quot;&gt;赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_tips&quot;&gt;，轻点两下取消赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_txt&quot;&gt;在看&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_tips&quot;&gt;，轻点两下取消在看&lt;/span&gt;

    
    
    













    






  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4de814265e5f6501881f3661f5293ef3</guid>
<title>分支路径图调度框架在 vivo 效果广告业务的落地实践</title>
<link>https://toutiao.io/k/iw73z1g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作者：&lt;/p&gt;&lt;p&gt;vivo 互联网AI团队- Liu Zuocheng、Zhou Baojian&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本文根据周保建老师在“2022 vivo开发者大会&quot;现场演讲内容整理而成。公众号回复【2022 VDC】获取互联网技术分会场议题相关资料。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;使用基于有限有向图的调度框架，可以控制在线服务中异步调度的流程，但这对分支路径的管理不够友好，随着节点增多，调度流程会越来越复杂而难以控制。因此我们实现了支持分支路径的图调度框架，解决普通图调度框架可扩展性差的问题。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、图调度框架简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;span&gt;1.1 vivo效果广告预估服务&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicCCm6SbEhBriau9IiaYrxuiaVUMUSoERqN0yFxjlqIvV7ULSD294Eibvf5A/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;95.2249134948097&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic2XkWcn1EcAmEibBO3iaicia41uPcJxKAXafe5yQ88bwp5DsyCUt9dPw6Zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;vivo效果广告实时在线服务是提供实时AI算法推荐的服务。在广告投放场景，承载了一天百亿级别数量的请求，支持vivo广告收入。在可用性、可扩展性等方面具有非常高的要求。服务中起到调度作用的模块，上下游依赖特别多，比如特征服务、ABT实验平台、实时数据流、模型计算模块等等。调度模块在请求下游服务的方式都是采用异步的方式。那么我们是怎么管理这么多异步请求的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步调用已成为系统设计中的主流方法。虽然异步调度提升了系统性能，提升了资源的利用率，但却对系统的可扩展性和可维护性提出了挑战。回忆历史中用过的异步管理方法有以下三种。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicicDVxBuPygiawZXibicVs5VN8w56DnpsqVqhZ5VZHhibfBHb6KPxJBpHyLw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;97.43944636678202&quot; data-cropy2=&quot;719.7231833910035&quot; data-ratio=&quot;0.48671875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicnHTBU9Pve9XjAQzKp606ltt0CCx7jSf3ib1QqBSXNVo0y1CRsBfD3icw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;单纯使用&lt;strong&gt;面向过程的方法&lt;/strong&gt;，简单却粗放，随着下游服务增多，代码逻辑中产生大量的callback函数和类使，得系统调度过程繁杂无序，可扩展性和可维护性变差。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;树调度方法&lt;/strong&gt;，使得异步调度进入框架调控的新阶段。可扩展性方面较面向过程的方法要好很多。但树结构不能准确描述复杂服务的调用流程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;有限有向图&lt;/strong&gt;，是目前使用最为广泛的方法。扩展性较好，能管理复杂的调用流程。但这是否是一种完美的方法呢？不是的。有限有向图，对图中节点是全路径访问，对分支路径的管理不够友好。因此我们依然要探索新的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了解释有限有向图在实时在线服务中的局限性，我们以vivo效果广告预估服务的调度流程为例，进行说明。把调度流程经过抽象后，调度流程如左图一样简洁明了，但这只是理想状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic1eSnH8JiciciaVUy7ibgZvzV333pNlm0nfnuaWwPLfFnADjRvia8JDpdx7w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic9iaNopmBPBjgtKXKEt6t60sicgoQsfaCo94ayCECicjIZCPK9JuHbfnmQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么现实状况又是什么样子的呢？大家来看，和所有的实时在线服务一样，我们在系统设计时，为了系统健壮，总要和大量的异常和超时做斗争。并且除了异常和超时，系统还需要有兜底逻辑。上一个简洁明了的有限有向图已经不复存在。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了进一步说明，有限有向图不能完全把控在线服务中异步调度的流程。我们依据刚才展示的流程调度图，做了一个状态转换图。在这个图中，展示了系统中各个状态的流转路径，总数达到了7条之多。有限有向图是一种全路径图调度框架，已经难以适用复杂度不断增长的系统。&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、分支路径图调度框架的实现&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicF5oNbfjIDbRAw98QnzDhXeZAIWHyvL9Og4ouoPWMHpj309tnMmyOfA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;全路径图调度框架具体有什么痛点，逼迫让我们去寻找新的方法。具体原因就在这里，有限有向图在落地实践中，使用skip状态变量约束路径。系统在处理一次任务的过程中，不经过的路径上的所有节点状态都会被设置为skip。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全路径的图调度框架中，每增添一个节点，会导致：控制变量数量 +1，状态全集 x2， 复杂度成指数增长。在如此状态下，对复杂系统添加流程或调整流程，就会变成工程师的噩梦。设计开发时必须小心甚微，上线时则如履薄冰。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicFicvZ2wHI0nbAbG0AwYNgCCMbBxXC75VjDrMe9tjjW0TVKHGtAicEF1w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;为了安全开发和提升迭代效率，新的调度方法被迫切地创建出来，那就支持分支路径的图调度框架。它的原理，则是在原有的图调度框架中，添加两处功能，一是加入了分支节点，二是对于图中节点的触发和激活支持“与”激活和“或”激活。是不是像极了逻辑电路呢？&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic7xuwDM46jSV979k5mIQk4mCIviaJnv7c9NP8k2nkCkib4ib1BKKWy4MGQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;大家是否有疑问，添加两处修改就可以了吗？这样做真的有效吗？其实依据，就来自于我们的《编译原理》里的常见概念和常见规律。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有限有向图，是一种NFA，即不确定的有限自动机。我们都知道，在实践中NFA实现难度很大，它不如DFA简洁和简单。所以结论呼之欲出，支持分支路径的图调度框架，则是把图变成DFA。我们还给它起了新名字，DDAG。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicqdhdz2ibMBONDQ5xqNE2lDcibqWKrIRgf7uPUOlx44UTjc5yEBtGd8QQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、在vivo 效果广告推荐系统中的落地过程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;实践是检验真理的唯一标准，我们再通过实际的落地过程看，分支路径调度框架是否满足我们的预期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们回忆一下vivo效果广告预估服务的调度流程，那一个充满着异常、超时、兜底逻辑的调用图。为了便于说明，我们把它化简了一下，变成一个流程图，如左图，目前它还是一个全路径的调度图。使用分支路径调度框架改造后，变成右图，图中添加了判断节点，具体路径的走向则由判断逻辑来控制。大量Skip的状态控制变量依然不复存在。图中蓝、青、红分别代表了3条路径，让路径和流程一目了然。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkicqEPE2T95JJJy5y2vJ8kkNibENlD2H9KdiaFK7taQ5LXEUCrficqQjFRMA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当图与实时在线系统融合在一起的时候，我们发现了分支路径图调度框架更多的提升空间。比如，图的整体的超时、异常管理，图中节点的超时、异常管理，以及复杂图结构的自动化简，会成为我们以后进一步升级的空间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分支路径图调度框架在vivo效果广告预估服务中做了一次成功的实践。它帮助工程师降低在开发过程中的风险，提速在项目中的迭代效率。让算法预估服务的飞轮越转越快！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7wRzzngARjKz3H7Z0LnTkic0YwccibE90FtrfOgjicLQWXQdfe2INFeRCHHIQaahZCBn97hKJxPnPAA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;END&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:38.title1&quot;&gt;&lt;p&gt;猜你喜欢&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weuitheme=&quot;light&quot; data-id=&quot;MzI4NjY4MTU5Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt45QXJZicZ9gaNU2mRSlvqhQd94MJ7oQh4QFj1ibPV66xnUiaKoicSatwaGXepL5sBDSDLEckicX1ttibHg/0?wx_fmt=png&quot; data-nickname=&quot;vivo互联网技术&quot; data-alias=&quot;vivoVMIC&quot; data-signature=&quot;分享 vivo 互联网技术干货与沙龙活动，推荐最新行业动态与热门会议。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>94430b09f6d762d80a8e181ef358e333</guid>
<title>Spring的秒表StopWatch优雅的程序计时器 -第455篇</title>
<link>https://toutiao.io/k/oklr59n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.514344262295082&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOQNnicxuET8WwCPlYFwhHxn97woTzcXP9zlxC37m3pApVz47ZPY318Hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1952&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;历史文章（&lt;strong&gt;&lt;span&gt;文章&lt;/span&gt;&lt;/strong&gt;累计450+）&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447533342&amp;amp;idx=1&amp;amp;sn=7fe54ec9948ace1c8e1568531d55678b&amp;amp;chksm=843bb90fb34c3019aa7f654da387d30aaf7c14e2798fc1dc846ea05521ba9e8fc108e97c99e9&amp;amp;token=848719710&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;国内最全的Spring Boot系列之一&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447533861&amp;amp;idx=1&amp;amp;sn=11f6e9afb4cf3ba0aca4330f5b11dc0e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;国内最全的Spring Boot系列之二&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447534510&amp;amp;idx=1&amp;amp;sn=05079e6c4a355dfde41cbd36aed36b03&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;国内最全的Spring Boot系列之三&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447535839&amp;amp;idx=1&amp;amp;sn=21776e7ceee5a705d588e647590cea27&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;国内最全的Spring Boot系列之四&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447536783&amp;amp;idx=1&amp;amp;sn=82677579faabd7e7bf71756835f5139f&amp;amp;chksm=843bae9eb34c2788a1a02e09850cf973660686a9a541f708e319d8060f97f4483e31b4f7b881&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍国内最全的Spring Boot系列之&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;span&gt;&lt;span&gt;国内最全的Spring Boot&lt;/span&gt;&lt;span&gt;系列之&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;五&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537355&amp;amp;idx=1&amp;amp;sn=88ebbaf946cdbfa45123949703bb2afa&amp;amp;chksm=843ba8dab34c21cc64334a111f0c6c8b94398f39e145207d2899679ab7c465a252a0aad0cb85&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;走进MyBatis源码一探Spring扩展点「知识点多多」「扩展点实战系列」- 第449篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;走进MyBatis源码一探Spring扩展点「知识点多多」「扩展点实战系列」- 第449篇&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537381&amp;amp;idx=1&amp;amp;sn=0ee3cf301eb5441bc0261d5f12a9a325&amp;amp;chksm=843ba8f4b34c21e26f7d61fe8f0040dc07852d0b1b80e7897868589bbde000988399d4f1d790&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;走进SpringBoot源码吃透Spring扩展点「扩展点实战系列」- 第450篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;走进SpringBoot源码吃透Spring扩展点「扩展点实战系列」- 第450篇&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537388&amp;amp;idx=1&amp;amp;sn=805cf809a5af69db7bf71c3a3a77f931&amp;amp;chksm=843ba8fdb34c21ebba4f978b80102c704285820daf83fc32bb0e4a920ecba8baac963db484a2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;5个月的精华：Spring/SpringBoot扩展点手册：手册在手，编码无忧：全网独一份 - 第451篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;5个月的精华：Spring/SpringBoot扩展点手册：手册在手，编码无忧：全网独一份 - 第451篇&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537398&amp;amp;idx=1&amp;amp;sn=c988173bdd37c93dfab5dce0fba41221&amp;amp;chksm=843ba8e7b34c21f1c6f7148aab20d85a84acfd6b5f828e1efbace1f84d96be378200b7fa05f9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot添加外部jar包及打包(亲测有效) - 第452篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;SpringBoot添加外部jar包及打包(亲测有效) - 第452篇&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537417&amp;amp;idx=1&amp;amp;sn=fc701e635b03a429b9cba195c9541c6b&amp;amp;chksm=843ba918b34c200e2b9f8fd44872e658d02d220ce8e3ed87bb79a917d00ecbe5e299a7b60f2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot引入外部jar包，项目打包成war包发布(亲测有效) - 第453篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SpringBoot引入外部jar包，项目打包成war包发布(亲测有效) - 第453篇&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4ODIyMzEwMg==&amp;amp;mid=2447537428&amp;amp;idx=1&amp;amp;sn=be590863eeedd1c4090679f0bc4de548&amp;amp;chksm=843ba905b34c2013d1653a8c738f8cbbb53a9b009eee95c75606098a3645c7c734d6215bc4d2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;SpringBoot中使用Spring-Retry重试框架 - 第454篇&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SpringBoot中使用Spring-Retry重试框架 - 第454篇&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;悟纤：最近代码逻辑，添加了很多的耗时的代码，感觉写的不是很好，师傅有更好的方案吗？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：这个倒是有一个秒表&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;，可以稍微优化代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：那师傅介绍一下，让徒儿也增长下功力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6021276595744681&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOEI2K1IyoZK2WsCmAAqqwxqQQa422SFWWQrIJHPEao6Kiao8UB5XrgpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：要不我直接把内里传给你吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6141732283464567&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOTVAA7ll1ibvbOdS6yRwbMHcmTgGdCDKd0qiafKRuhYLyQxL8bia1TpwWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：那最好不过了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：你想太多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：看来是电视看多了，这个时代，增加内力还得靠自己，木有办法，宝宝苦，宝宝累，宝宝好难受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOucedTzB9Q3Tk9qnqgvn9qckibDOCQ7z9P7zuNh4hqNC8uwSCgezHapQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;师傅：这个或许是你老了之后，你值得回忆的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悟纤：那也是噢&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5648535564853556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOhmneMaATAAox8Vwu2ePBjNGkQ8SeIy3YI4641XjhbOrVzNfF4bmI6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1434&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span lang=&quot;EN-US&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果想知道一个方法的执行耗时时长，一般的思路是：记录开始时间，执行业务代码，记录结束时间，方法的耗时就等于&lt;span lang=&quot;EN-US&quot;&gt;=&lt;/span&gt;结束时间&lt;span lang=&quot;EN-US&quot;&gt;-&lt;/span&gt;开始时间。这种方式可以实现基本的统计需求，如果要统计各个任务的占比，那么代码的复杂度就会增加，当然你封装出来一个类专门来处理执行耗时类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果使用了&lt;span lang=&quot;EN-US&quot;&gt;Spring&lt;/span&gt;框架，那么&lt;span lang=&quot;EN-US&quot;&gt;Spring&lt;/span&gt;已经提供了一个秒表工具&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;原生方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式最最简单，最好理解，经常会这么来写：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test1&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; endTime = System.currentTimeMillis(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;程序运行时间：&quot;&lt;/span&gt; + (endTime - startTime) + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ms&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大多数时候我们使用&lt;span lang=&quot;EN-US&quot;&gt;ms&lt;/span&gt;来表示即可，但是这么写缺乏灵活性。倘若我们要展示成纳秒、秒、甚至分钟，还得我们自己处理（把毫秒值拿来进行转换&lt;span lang=&quot;EN-US&quot;&gt;~ &lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然可能到了&lt;span lang=&quot;EN-US&quot;&gt;JDK8&lt;/span&gt;以后，我们这么做能变得稍微灵活一些：可以这么处理：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test2&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Instant start = Instant.now();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Instant end = Instant.now();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Duration duration = Duration.between(start, end);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;程序运行时间(毫秒) = &quot;&lt;/span&gt; + duration.toMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;程序运行时间(纳秒) = &quot;&lt;/span&gt; + duration.toNanos());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个比上面灵活度强一些，但还是有一定的缺点：步骤稍显复杂，总体上还是不够优雅，也不是那么的灵活，多个任务的时候编写不方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么本文针对此问题介绍一个工具：&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;执行时间监视器。借助它来统计我们程序的执行时间，带给非常多的方便和优雅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、秒表&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工具类&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;，秒表工具，执行时间监视器，用来统计任务的耗时的工具类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.1 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;工具类提供者&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不单单只有&lt;span lang=&quot;EN-US&quot;&gt;spring&lt;/span&gt;提供了这个工具类，&lt;span lang=&quot;EN-US&quot;&gt;apache&lt;/span&gt;，&lt;span lang=&quot;EN-US&quot;&gt;google&lt;/span&gt;也提供了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;com.google.common.base.Stopwatch;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;org.apache.commons.lang3.time.StopWatch;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;springframework.util.StopWatch&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.2 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;工具类使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;span lang=&quot;EN-US&quot;&gt;Spring Watch&lt;/span&gt;的使用很简单，直接看下代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test3&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;) throws InterruptedException&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    StopWatch stopWatch = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; StopWatch(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;用户注册&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    stopWatch.start(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;保存用户信息&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    stopWatch.stop();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    stopWatch.start(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;创建用户钱包信息&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    TimeUnit.SECONDS.sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    stopWatch.stop();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(stopWatch.prettyPrint());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;所有任务总耗时（毫秒）：&quot;&lt;/span&gt; + stopWatch.getTotalTimeMillis());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;任务总数：&quot;&lt;/span&gt; + stopWatch.getTaskCount());&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    System.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;.println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;所有任务详情：&quot;&lt;/span&gt; + stopWatch.getTaskInfo()); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;控制台打印：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40481927710843374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOYZAficSQgc5tXhGFcYLxHO06YykIMhicnC0PxSn0praUc6XA70jFlwtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的单位是&lt;span lang=&quot;EN-US&quot;&gt;ns&lt;/span&gt;（纳秒）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;1s=1000ms&lt;/span&gt;&lt;span&gt;（毫秒）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;1ms=1000us&lt;/span&gt;&lt;span&gt;（微妙）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;1us=1000ns&lt;/span&gt;&lt;span&gt;（纳秒）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在一个大任务下，可能有多个小的步骤任务，而我们需要知道各个步骤任务的用时情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.4 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）&lt;span lang=&quot;EN-US&quot;&gt;Spring&lt;/span&gt;自带工具类，可直接使用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）代码实现简单，使用更简单&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）统一归纳，展示每项任务耗时与占用总时间的百分比，展示结果直观，性能消耗相对较小，并且最大程度的保证了&lt;span lang=&quot;EN-US&quot;&gt;start&lt;/span&gt;与&lt;span lang=&quot;EN-US&quot;&gt;stop&lt;/span&gt;之间的时间记录的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;）可在&lt;span lang=&quot;EN-US&quot;&gt;start&lt;/span&gt;时直接指定任务名字，从而更加直观的显示记录结果（也可以不指定，但最好指定下，比较直观）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于以上的优点，我觉得最重要的是第（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）点，任务耗比以及直观的展示（&lt;span lang=&quot;EN-US&quot;&gt;prettyPrint()&lt;/span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）一个&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;实例一次只能开启一个&lt;span lang=&quot;EN-US&quot;&gt;task&lt;/span&gt;，不能同时&lt;span lang=&quot;EN-US&quot;&gt;start&lt;/span&gt;多个&lt;span lang=&quot;EN-US&quot;&gt;task&lt;/span&gt;，并且在该&lt;span lang=&quot;EN-US&quot;&gt;task&lt;/span&gt;未&lt;span lang=&quot;EN-US&quot;&gt;stop&lt;/span&gt;之前不能&lt;span lang=&quot;EN-US&quot;&gt;start&lt;/span&gt;一个新的&lt;span lang=&quot;EN-US&quot;&gt;task&lt;/span&gt;，必须在该&lt;span lang=&quot;EN-US&quot;&gt;task stop&lt;/span&gt;之后才能开启新的&lt;span lang=&quot;EN-US&quot;&gt;task&lt;/span&gt;，若要一次开启多个，需要&lt;span lang=&quot;EN-US&quot;&gt;new&lt;/span&gt;不同的&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;实例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）代码侵入式使用，需要改动多处代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.5 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;开发小建议&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你可以使用拦截器或者过滤器，在起始的时候将&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;对象放入&lt;span lang=&quot;EN-US&quot;&gt;ThreadLocal&lt;/span&gt;中，然后封装一个工具类，就可以在业务代码的任何地方&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;打点&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;了，在过滤器或拦截器的收尾处打印计时统计。这样用来做代码性能分析应该不错。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;2.6 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;看看源码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;实现起来还是很简单的，其实你自己也完全可以搞定一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先定义了几个关键的变量：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7518072289156627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOXDdUoiboLLOrqC1h7xYhJLBu6bC2k0jxZichEyH0jVz0ydhvdEey6JOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看&lt;/span&gt;&lt;span&gt;下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;start()&lt;/span&gt;&lt;span&gt;方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22409638554216868&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOzKRJ2nHMcNWgLvgPKk2LmD8Ja4n0XHA02sZjuSLILOCrf33JIpXgug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看下&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;stop()&lt;/span&gt;&lt;span&gt;方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.42650602409638555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOniaHhmnlXFRztKgyzyZUhhfrosMrFiamb5ddTjjo4LeY4PcKUlQ86hMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;TaskInfo&lt;/span&gt;&lt;span&gt;就在&lt;/span&gt;&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;&lt;span&gt;类中，是一个内部静态类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6337349397590362&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeOvXiafPqiaEkLO4CPQpILDRk6icMUicibUzDZEb7ibFWrcAGHcUR1xgicaiaVCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里普及一个知识点，内部静态类，要是咱们自己实现使用内部类就可以了，这里要了解下内部静态类的一些概念，才能理解这么写的好处了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要设计&lt;span lang=&quot;EN-US&quot;&gt;Java&lt;/span&gt;内部类？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么要将一个类设计成内部类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象那个的信息相互独立；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;4&lt;/span&gt;）方便编写事件驱动程序；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;5&lt;/span&gt;）方便编写线程代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后我们再来说说为什么又将内部类设计为静态内部类与内部类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）首先来看一下静态内部类的特点：我是静态内部类，只不过是想借你的外壳用一下。本身来说，我和你没有什么&lt;span lang=&quot;EN-US&quot;&gt;“&lt;/span&gt;强依赖&lt;span lang=&quot;EN-US&quot;&gt;”&lt;/span&gt;上的关系。没有你，我也可以创建实例。那么，在设计内部类的时候我们就可以做出权衡：如果我内部类与你外部类关系不紧密，耦合程度不高，不需要访问外部类的所有属性或方法，那么我就设计成静态内部类。而且，由于静态内部类与外部类并不会保存相互之间的引用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）既然上面已经说了什么时候应该用静态内部类，那么如果你的需求不符合静态内部类所提供的一切好处，你就应该考虑使用内部类了。最大的特点就是：你在内部类中需要访问有关外部类的所有属性及方法，我知晓你的一切&lt;span lang=&quot;EN-US&quot;&gt;... ...&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单理解就是：如果把类比喻成鸡蛋，内部类为蛋黄&lt;span lang=&quot;EN-US&quot;&gt;,&lt;/span&gt;外部类是蛋壳。那么静态类相当于熟鸡蛋，就算蛋壳破碎（外部类没有实例化），蛋黄依然完好（内部类可以实例化）；而非静态类相当于生鸡蛋，蛋壳破碎（无实例化），蛋黄也会跟着&lt;span lang=&quot;EN-US&quot;&gt;xx&lt;/span&gt;（不能实例化）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;那静态内部类与普通内部类有什么区别呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）静态内部类不持有外部类的引用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在普通内部类中，我们可以直接访问外部类的属性、方法，即使是&lt;span lang=&quot;EN-US&quot;&gt;private&lt;/span&gt;类型也可以访问，这是因为内部类持有一个外部类的引用，可以自由访问。而静态内部类，则只可以访问外部类的静态方法和静态属性（如果是&lt;span lang=&quot;EN-US&quot;&gt;private&lt;/span&gt;权限也能访问，这是由其代码位置所决定的），其他则不能访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）静态内部类不依赖外部类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;普通内部类与外部类之间是相互依赖的关系，内部类实例不能脱离外部类实例，也就是说它们会同生同死，一起声明，一起被垃圾回收器回收。而静态内部类是可以独立存在的，即使外部类消亡了，静态内部类还是可以存在的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;3&lt;/span&gt;）普通内部类不能声明&lt;span lang=&quot;EN-US&quot;&gt;static&lt;/span&gt;的方法和变量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;普通内部类不能声明&lt;span lang=&quot;EN-US&quot;&gt;static&lt;/span&gt;的方法和变量，注意这里说的是变量，常量（也就是&lt;span lang=&quot;EN-US&quot;&gt;final static&lt;/span&gt;修饰的属性）还是可以的，而静态内部类形似外部类，没有任何限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;）可以看出&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;对于记录程序运行时间提供了多个&lt;span lang=&quot;EN-US&quot;&gt;api&lt;/span&gt;，方便按任务（比如业务&lt;span lang=&quot;EN-US&quot;&gt;A B&lt;/span&gt;）进行时间统计，并提供整个运行过程的概览（最后的统计部分）。总结来说我们也可以使用基础的&lt;span lang=&quot;EN-US&quot;&gt;java api&lt;/span&gt;封装出类似的功能，但已有轮子，就没必要重复造了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;）&lt;span lang=&quot;EN-US&quot;&gt;StopWatch&lt;/span&gt;的使用要点：使用&lt;span lang=&quot;EN-US&quot;&gt;start(taskName)&lt;/span&gt;开启一个任务，使用&lt;span lang=&quot;EN-US&quot;&gt;stop()&lt;/span&gt;结束任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;\(^o^)/~&lt;/span&gt;&lt;span&gt;&lt;span&gt;你的小小鼓励，是博主坚持的动力，如果本文你有收获，点个赞再走呗&lt;span&gt;&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8527027027027027&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/P13HW4Fm1HWPobJPHkhjAh6T6V6BSaeO0oaiaZRuO6iafUwIdnQ62mujSlsrvlGBvawuLuoiaqn4wUs9O4JLwt4icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>338996dae56993f1a1d98a7000e94c18</guid>
<title>一文弄懂 React ref 原理</title>
<link>https://toutiao.io/k/43sfdbp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Ref 理解与使用，一些读者可能还停留在用 ref 获取真实 DOM 元素和获取类组件实例层面上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 ref 除了这两项常用功能之外，还有很多别的小技巧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过本篇文章的学习，你将收获 React ref 的基本和进阶用法，并且能够明白 React 内部是如何处理 ref 的，并通过一个小 Demo + 提问的方式带你更加深刻地理解 ref 的底层原理&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. ref 的理解与使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Ref 的理解，要从两个角度去分析：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Ref 对象的创建：使用 &lt;code&gt;createRef&lt;/code&gt; 或 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 本身对 Ref 的处理：对于标签中的 ref 属性，React 是如何处理的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1. ref 对象的创建&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1.1. createRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类组件中，我们会通过 &lt;code&gt;createRef&lt;/code&gt; 去创建一个 Ref 对象，其会被保存在类组件实例上，它的实现很简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react/src/ReactCreateRef.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createRef&lt;/span&gt;(): &lt;span&gt;RefObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; refObject = {&lt;br/&gt;    &lt;span&gt;current&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; refObject&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，就是创建了一个包含 &lt;code&gt;current&lt;/code&gt; 属性的对象，仅此而已&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1.2. useRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着我们不能在函数组件中使用 &lt;code&gt;createRef&lt;/code&gt;，因为每次函数组件渲染都是一次新的函数执行，每次执行 &lt;code&gt;createRef&lt;/code&gt; 得到的都是一个新的对象，无法保留其原来的引用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在函数组件中，我们会使用 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象，React 会将 useRef 和函数组件对应的 fiber 对象关联，将 &lt;code&gt;useRef&lt;/code&gt; 创建的 ref 对象挂载到对应的 fiber 对象上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来每次函数组件执行，只要函数组件不被销毁，那么对应的 fiber 对象实例也会一直存在，所以 ref 也能够被保留下来&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2. React 对标签中 ref 属性的处理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要明确一个结论，在 React 中获取 DOM 元素或者组件实例并不是只能通过 ref 对象获取！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说并不是只能通过先调用 &lt;code&gt;createRef&lt;/code&gt; 创建 ref 对象，然后将它赋值到要获取的元素或组件实例的 ref 属性上，实际上还有别的方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::tip&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有类组件才有获取组件实例这一说法，函数组件没有实例，不能被 ref 标记，但是可以通过 &lt;code&gt;forwardRef&lt;/code&gt; 结合 &lt;code&gt;useImperativeHandle&lt;/code&gt; 给函数组件赋予 ref 标记的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.1. string ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们给元素或类组件标签中的 ref 属性传递字符串时，能够在组件实例的 &lt;code&gt;this.refs&lt;/code&gt; 中访问到&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class Child extends React.Component&amp;lt;PropsWithChildren&amp;gt; {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { children } = this.props&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;Child&amp;lt;/p&amp;gt;&lt;br/&gt;        {children}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/** @description ref 属性传递字符串 */&lt;br/&gt;class RefDemo1 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo1&#x27;)&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refs)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref=&quot;refDemo1DOM&quot;&amp;gt;ref 属性传递字符串获取 DOM 元素&amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;Child ref=&quot;refDemo1Component&quot;&amp;gt;ref 属性传递字符串获取类组件实例&amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1775244299674267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6BLqstJPR3RVglgaDBQCTmfF02ExzRbtpdtkQEHsHq2GmL2L7iaZiagyQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;614&quot;/&gt;&lt;figcaption&gt;ref属性传递字符串&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::warning&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式已经被 React 官方废弃，尽量不要使用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.2. callback ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref 属性传递函数时，会在 commit 阶段创建真实 DOM 时执行 ref 指定的函数，并将元素作为第一个参数传入，此时我们就可以利用它进行赋值以获取 DOM 元素或组件实例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description ref 属性传递函数 */&lt;br/&gt;class RefDemo2 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo2&#x27;)&lt;br/&gt;&lt;br/&gt;  refDemo2DOM: HTMLElement | null = null&lt;br/&gt;  refDemo2Component: Child | null = null&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refDemo2DOM)&lt;br/&gt;    this.logger.log(this.refDemo2Component)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref={(el) =&amp;gt; (this.refDemo2DOM = el)}&amp;gt;&lt;br/&gt;          ref 属性传递函数获取 DOM 元素&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;Child ref={(child) =&amp;gt; (this.refDemo2Component = child)}&amp;gt;&lt;br/&gt;          ref 属性传递函数获取类组件实例&lt;br/&gt;        &amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1772357723577236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6oOFzckUwtLOp8dharIicEcibuQZW6KPnAkgfOASX5iaPcboTqFjVdlbFw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;615&quot;/&gt;&lt;figcaption&gt;ref属性传递函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.3. object ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式就是我们最常用的方式了，使用 &lt;code&gt;createRef&lt;/code&gt; 或者 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象，并将其传给标签的 ref 属性即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式获取到的 ref 需要先调用 &lt;code&gt;current&lt;/code&gt; 属性才能获取到对应的 DOM 元素或组件实例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description ref 属性传递对象 */&lt;br/&gt;class RefDemo3 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo3&#x27;)&lt;br/&gt;&lt;br/&gt;  refDemo3DOM = React.createRef&amp;lt;HTMLDivElement&amp;gt;()&lt;br/&gt;  refDemo3Component = React.createRef&amp;lt;Child&amp;gt;()&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refDemo3DOM)&lt;br/&gt;    this.logger.log(this.refDemo3Component)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref={this.refDemo3DOM}&amp;gt;ref 属性传递对象获取 DOM 元素&amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;Child ref={this.refDemo3Component}&amp;gt;&lt;br/&gt;          ref 属性传递对象获取类组件实例&lt;br/&gt;        &amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. ref 高阶用法&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1. forwardRef 转发 ref&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.1. 跨层级获取&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要在爷组件中通过在子组件中传递 ref 获取到孙组件的某个元素，也就是在爷组件中获取到了孙组件的元素，是一种跨层级获取&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description 孙组件 */&lt;br/&gt;const Child: React.FC&amp;lt;{ grandRef: LegacyRef&amp;lt;HTMLDivElement&amp;gt; }&amp;gt; = (props) =&amp;gt; {&lt;br/&gt;  const { grandRef } = props&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;Child&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div ref={grandRef}&amp;gt;要获取的目标元素&amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @description 父组件&lt;br/&gt; *&lt;br/&gt; * 第一个泛型参数是 ref 的类型&lt;br/&gt; * 第二个泛型参数是 props 的类型&lt;br/&gt; */&lt;br/&gt;const Father = forwardRef&amp;lt;HTMLDivElement, {}&amp;gt;((props, ref) =&amp;gt; {&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;Child grandRef={ref} /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;/** @description 爷组件 */&lt;br/&gt;const GrandFather: React.FC = () =&amp;gt; {&lt;br/&gt;  let grandChildDiv: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(grandChildDiv)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;Father ref={(el) =&amp;gt; (grandChildDiv = el)} /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.2. 合并转发自定义 ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;forwardRef 不仅可以转发 ref 获取 DOM 元素和组件实例，还可以转发合并后的自定义 ref&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是“合并后的自定义 ref”呢？通过一个场景来看看就明白了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::info{title=场景}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过给 Foo 组件绑定 ref，获取多个内容，包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;子组件 Bar 的组件实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bar 组件中的 DOM 元素 button&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;孙组件 Baz 的组件实例&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种在一个 ref 里能够访问多个元素和实例的就是“合并后的自定义 ref”&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description 自定义 ref 的类型 */&lt;br/&gt;interface CustomRef {&lt;br/&gt;  bar: Bar&lt;br/&gt;  barButton: HTMLButtonElement&lt;br/&gt;  baz: Baz&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class Baz extends React.Component {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return &amp;lt;div&amp;gt;Baz&amp;lt;/div&amp;gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class Bar extends React.Component&amp;lt;{&lt;br/&gt;  customRef: ForwardedRef&amp;lt;CustomRef&amp;gt;&lt;br/&gt;}&amp;gt; {&lt;br/&gt;  buttonEl: HTMLButtonElement | null = null&lt;br/&gt;  bazInstance: Baz | null = null&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    const { customRef } = this.props&lt;br/&gt;&lt;br/&gt;    if (customRef) {&lt;br/&gt;      ;(customRef as MutableRefObject&amp;lt;CustomRef&amp;gt;).current = {&lt;br/&gt;        bar: this,&lt;br/&gt;        barButton: this.buttonEl!,&lt;br/&gt;        baz: this.bazInstance!,&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render() {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;button ref={(el) =&amp;gt; (this.buttonEl = el)}&amp;gt;Bar button&amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;Baz ref={(instance) =&amp;gt; (this.bazInstance = instance)} /&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;const FowardRefBar = forwardRef&amp;lt;CustomRef&amp;gt;((props, ref) =&amp;gt; (&lt;br/&gt;  &amp;lt;Bar {...props} customRef={ref} /&amp;gt;&lt;br/&gt;))&lt;br/&gt;&lt;br/&gt;const Foo: React.FC = () =&amp;gt; {&lt;br/&gt;  const customRef = useRef&amp;lt;CustomRef&amp;gt;(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(customRef.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;FowardRefBar ref={customRef} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20593080724876442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6KQ4OoZAp3JibXtGicWV8yhz65UNnkTovRQflcfqOgicClz7fgwP1mqNUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;607&quot;/&gt;&lt;figcaption&gt;合并转发自定义ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.3. 高阶组件转发 ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在高阶组件中直接使用 ref，它会直接指向 WrapComponent&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class TestComponent extends React.Component {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return &amp;lt;p&amp;gt;TestComponent&amp;lt;/p&amp;gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/** @description 不使用 forwardRef 转发 HOC 中的 ref */&lt;br/&gt;const HOCWithoutForwardRef = (Component: typeof React.Component) =&amp;gt; {&lt;br/&gt;  class WrapComponent extends React.Component {&lt;br/&gt;    render(): React.ReactNode {&lt;br/&gt;      return (&lt;br/&gt;        &amp;lt;div&amp;gt;&lt;br/&gt;          &amp;lt;p&amp;gt;WrapComponent&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;Component /&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      )&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  return WrapComponent&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const HOCComponent1 = HOCWithoutForwardRef(TestComponent)&lt;br/&gt;const RefHOCWithoutForwardRefDemo = () =&amp;gt; {&lt;br/&gt;  const logger = createLoggerWithScope(&#x27;RefHOCWithoutForwardRefDemo&#x27;)&lt;br/&gt;  const wrapRef = useRef(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    // wrapRef 指向的是 WrapComponent 实例 而不是 HOCComponent1 实例&lt;br/&gt;    logger.log(wrapRef.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;HOCComponent1 ref={wrapRef} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4414715719063545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq646mMr5SBBmkGXvkr94EDPdkbItIO7EztOiavr86xwRsTjX3RDrOq4kA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;HOC中直接使用ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们希望 &lt;code&gt;ref&lt;/code&gt; 指向的是被包裹的 TestComponent 而不是 HOC 内部的 WrapComponent 时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就可以用 forwardRef 进行转发了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description HOC 中使用 forwardRef 转发 ref */&lt;br/&gt;const HOCWithForwardRef = (Component: typeof React.Component) =&amp;gt; {&lt;br/&gt;  class WrapComponent extends React.Component&amp;lt;{&lt;br/&gt;    forwardedRef: LegacyRef&amp;lt;any&amp;gt;&lt;br/&gt;  }&amp;gt; {&lt;br/&gt;    render(): React.ReactNode {&lt;br/&gt;      const { forwardedRef } = this.props&lt;br/&gt;&lt;br/&gt;      return (&lt;br/&gt;        &amp;lt;div&amp;gt;&lt;br/&gt;          &amp;lt;p&amp;gt;WrapComponent&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;Component ref={forwardedRef} /&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      )&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  return React.forwardRef((props, ref) =&amp;gt; (&lt;br/&gt;    &amp;lt;WrapComponent forwardedRef={ref} {...props} /&amp;gt;&lt;br/&gt;  ))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const HOCComponent2 = HOCWithForwardRef(TestComponent)&lt;br/&gt;const RefHOCWithForwardRefDemo = () =&amp;gt; {&lt;br/&gt;  const logger = createLoggerWithScope(&#x27;RefHOCWithForwardRefDemo&#x27;)&lt;br/&gt;  const hocComponent2Ref = useRef(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    // hocComponent2Ref 指向的是 HOCComponent2 实例&lt;br/&gt;    logger.log(hocComponent2Ref.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;HOCComponent2 ref={hocComponent2Ref} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42483660130718953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6hSVnEzJaQDxKsE4bCoic6Exwp99sDXJBegnlDCnonQ1Ykjic7icbgAOZw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;612&quot;/&gt;&lt;figcaption&gt;HOC中使用forwardRef转发ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2. ref 实现组件通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们可以通过父组件改变子组件 props 的方式触发子组件的更新渲染完成组件间通信&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们不希望通过这种改变子组件 props 的方式的话还能有别的办法吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 ref 获取子组件实例，然后子组件暴露出通信的方法，父组件调用该方法即可触发子组件的更新渲染&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于函数组件，由于其不存在组件实例这样的说法，但我们可以通过 &lt;code&gt;useImperativeHandle&lt;/code&gt; 这个 hook 来指定 ref 引用时得到的属性和方法，下面我们分别用类组件和函数组件都实现一遍&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.1. 类组件 ref 暴露组件实例&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * 父 -&amp;gt; 子 使用 ref&lt;br/&gt; * 子 -&amp;gt; 父 使用 props 回调&lt;br/&gt; */&lt;br/&gt;class CommunicationDemoFather extends React.Component&amp;lt;&lt;br/&gt;  {},&lt;br/&gt;  CommunicationDemoFatherState&lt;br/&gt;&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;CommunicationDemoFatherState&amp;gt; = {&lt;br/&gt;    fatherToChildMessage: &#x27;&#x27;,&lt;br/&gt;    childToFatherMessage: &#x27;&#x27;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  childRef = React.createRef&amp;lt;CommunicationDemoChild&amp;gt;()&lt;br/&gt;&lt;br/&gt;  /** @description 提供给子组件修改父组件中的状态 */&lt;br/&gt;  handleChildToFather = (message: string) =&amp;gt; {&lt;br/&gt;    this.setState((state) =&amp;gt; ({&lt;br/&gt;      ...state,&lt;br/&gt;      childToFatherMessage: message,&lt;br/&gt;    }))&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  constructor(props: {}) {&lt;br/&gt;    super(props)&lt;br/&gt;    this.handleChildToFather = this.handleChildToFather.bind(this)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { fatherToChildMessage, childToFatherMessage } = this.state&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div className={s.father}&amp;gt;&lt;br/&gt;        &amp;lt;h3&amp;gt;父组件&amp;lt;/h3&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;子组件对我说：{childToFatherMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;        &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;          &amp;lt;section&amp;gt;&lt;br/&gt;            &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对子组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              type=&quot;text&quot;&lt;br/&gt;              id=&quot;to-child&quot;&lt;br/&gt;              onChange={(e) =&amp;gt;&lt;br/&gt;                this.setState((state) =&amp;gt; ({&lt;br/&gt;                  ...state,&lt;br/&gt;                  fatherToChildMessage: e.target.value,&lt;br/&gt;                }))&lt;br/&gt;              }&lt;br/&gt;            /&amp;gt;&lt;br/&gt;          &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;          {/* 父 -&amp;gt; 子 -- 使用 ref 完成组件通信 */}&lt;br/&gt;          &amp;lt;button&lt;br/&gt;            onClick={() =&amp;gt;&lt;br/&gt;              this.childRef.current?.setFatherToChildMessage(&lt;br/&gt;                fatherToChildMessage,&lt;br/&gt;              )&lt;br/&gt;            }&lt;br/&gt;          &amp;gt;&lt;br/&gt;            发送&lt;br/&gt;          &amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;CommunicationDemoChild&lt;br/&gt;          ref={this.childRef}&lt;br/&gt;          onChildToFather={this.handleChildToFather}&lt;br/&gt;        /&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;interface CommunicationDemoChildProps {&lt;br/&gt;  onChildToFather: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;// 子组件自己维护状态 不依赖于父组件 props&lt;br/&gt;interface CommunicationDemoChildState {&lt;br/&gt;  fatherToChildMessage: string&lt;br/&gt;  childToFatherMessage: string&lt;br/&gt;}&lt;br/&gt;class CommunicationDemoChild extends React.Component&amp;lt;&lt;br/&gt;  CommunicationDemoChildProps,&lt;br/&gt;  CommunicationDemoChildState&lt;br/&gt;&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;CommunicationDemoChildState&amp;gt; = {&lt;br/&gt;    fatherToChildMessage: &#x27;&#x27;,&lt;br/&gt;    childToFatherMessage: &#x27;&#x27;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  /** @description 暴露给父组件使用的 API -- 修改父到子的消息 fatherToChildMessage */&lt;br/&gt;  setFatherToChildMessage(message: string) {&lt;br/&gt;    this.setState((state) =&amp;gt; ({ ...state, fatherToChildMessage: message }))&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { onChildToFather: emitChildToFather } = this.props&lt;br/&gt;    const { fatherToChildMessage, childToFatherMessage } = this.state&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div className={s.child}&amp;gt;&lt;br/&gt;        &amp;lt;h3&amp;gt;子组件&amp;lt;/h3&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;父组件对我说：{fatherToChildMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;        &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;          &amp;lt;section&amp;gt;&lt;br/&gt;            &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对父组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              type=&quot;text&quot;&lt;br/&gt;              id=&quot;to-father&quot;&lt;br/&gt;              onChange={(e) =&amp;gt;&lt;br/&gt;                this.setState((state) =&amp;gt; ({&lt;br/&gt;                  ...state,&lt;br/&gt;                  childToFatherMessage: e.target.value,&lt;br/&gt;                }))&lt;br/&gt;              }&lt;br/&gt;            /&amp;gt;&lt;br/&gt;          &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;          {/* 子 -&amp;gt; 父 -- 使用 props 回调完成组件通信 */}&lt;br/&gt;          &amp;lt;button onClick={() =&amp;gt; emitChildToFather(childToFatherMessage)}&amp;gt;&lt;br/&gt;            发送&lt;br/&gt;          &amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5104408352668214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6JoWX6Ej0LqicqZrc1fQSxUq0Wibv8eTmbiadh0PCfUtt3SJM53O7Goichw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;862&quot;/&gt;&lt;figcaption&gt;使用ref完成类组件间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.2. 函数组件 ref 暴露指定方法&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;useImperativeHandle&lt;/code&gt; hook 可以让我们指定 ref 引用时能获取到的属性和方法，个人认为相比类组件的 ref，使用这种方式能够更加好的控制组件想暴露给外界的 API&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而不像类组件那样直接全部暴露出去，当然，如果你想在类组件中只暴露部分 API 的话，可以用前面说的合并转发自定义 ref 的方式去完成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就用 &lt;code&gt;useImperativeHandle&lt;/code&gt; hook 改造上面的类组件实现的 demo 吧&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface ChildRef {&lt;br/&gt;  setFatherToChildMessage: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 父 -&amp;gt; 子 使用 ref&lt;br/&gt; * 子 -&amp;gt; 父 使用 props 回调&lt;br/&gt; */&lt;br/&gt;const CommunicationDemoFunctionComponentFather: React.FC = () =&amp;gt; {&lt;br/&gt;  const [fatherToChildMessage, setFatherToChildMessage] = useState(&#x27;&#x27;)&lt;br/&gt;  const [childToFatherMessage, setChildToFatherMessage] = useState(&#x27;&#x27;)&lt;br/&gt;&lt;br/&gt;  const childRef = useRef&amp;lt;ChildRef&amp;gt;(null)&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.father}&amp;gt;&lt;br/&gt;      &amp;lt;h3&amp;gt;父组件&amp;lt;/h3&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;子组件对我说：{childToFatherMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;        &amp;lt;section&amp;gt;&lt;br/&gt;          &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对子组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;          &amp;lt;input&lt;br/&gt;            type=&quot;text&quot;&lt;br/&gt;            id=&quot;to-child&quot;&lt;br/&gt;            onChange={(e) =&amp;gt; setFatherToChildMessage(e.target.value)}&lt;br/&gt;          /&amp;gt;&lt;br/&gt;        &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;        {/* 父 -&amp;gt; 子 -- 使用 ref 完成组件通信 */}&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt;&lt;br/&gt;            childRef.current?.setFatherToChildMessage(fatherToChildMessage)&lt;br/&gt;          }&lt;br/&gt;        &amp;gt;&lt;br/&gt;          发送&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;      &amp;lt;CommunicationDemoFunctionComponentChild&lt;br/&gt;        ref={childRef}&lt;br/&gt;        onChildToFather={(message) =&amp;gt; setChildToFatherMessage(message)}&lt;br/&gt;      /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;interface CommunicationDemoFunctionComponentChildProps {&lt;br/&gt;  onChildToFather: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;const CommunicationDemoFunctionComponentChild = forwardRef&amp;lt;&lt;br/&gt;  ChildRef,&lt;br/&gt;  CommunicationDemoFunctionComponentChildProps&lt;br/&gt;&amp;gt;((props, ref) =&amp;gt; {&lt;br/&gt;  const { onChildToFather: emitChildToFather } = props&lt;br/&gt;&lt;br/&gt;  // 子组件自己维护状态 不依赖于父组件 props&lt;br/&gt;  const [fatherToChildMessage, setFatherToChildMessage] = useState(&#x27;&#x27;)&lt;br/&gt;  const [childToFatherMessage, setChildToFatherMessage] = useState(&#x27;&#x27;)&lt;br/&gt;&lt;br/&gt;  // 定义暴露给外界的 API&lt;br/&gt;  useImperativeHandle(ref, () =&amp;gt; ({ setFatherToChildMessage }))&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.child}&amp;gt;&lt;br/&gt;      &amp;lt;h3&amp;gt;子组件&amp;lt;/h3&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;父组件对我说：{fatherToChildMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;        &amp;lt;section&amp;gt;&lt;br/&gt;          &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对父组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;          &amp;lt;input&lt;br/&gt;            type=&quot;text&quot;&lt;br/&gt;            id=&quot;to-father&quot;&lt;br/&gt;            onChange={(e) =&amp;gt; setChildToFatherMessage(e.target.value)}&lt;br/&gt;          /&amp;gt;&lt;br/&gt;        &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;        {/* 子 -&amp;gt; 父 -- 使用 props 回调完成组件通信 */}&lt;br/&gt;        &amp;lt;button onClick={() =&amp;gt; emitChildToFather(childToFatherMessage)}&amp;gt;&lt;br/&gt;          发送&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3. 函数组件缓存数据&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在函数组件中如果数据更新后不希望视图改变，也就是说视图不依赖于这个数据，这个时候可以考虑用 &lt;code&gt;useRef&lt;/code&gt; 对这种数据进行缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 &lt;code&gt;useRef&lt;/code&gt; 可以对数据进行缓存？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前说的 useRef 在函数组件中的作用原理吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 会将 useRef 和函数组件对应的 fiber 对象关联，将 useRef 创建的 ref 对象挂载到对应的 fiber 对象上，这样一来每次函数组件执行，只要函数组件不被销毁，那么对应的 fiber 对象实例也会一直存在，所以 ref 也能够被保留下来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用这个特性，我们可以将数据放到 &lt;code&gt;useRef&lt;/code&gt; 中，由于它在内存中一直都是同一块内存地址，所以无论如何变化都不会影响到视图的改变&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::warning{title=注意}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一定要看清前提，只适用于与视图无关的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一个简单的 demo 来更清楚地体会下这个应用场景&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我有一个 &lt;code&gt;todoList&lt;/code&gt; 列表，视图上会把这个列表渲染出来，并且有一个数据 activeTodoItem 是控制当前选中的是哪个 todoItem&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 todoItem 会切换这个 activeTodoItem，但是并不需要在视图上作出任何变化，如果使用 &lt;code&gt;useState&lt;/code&gt; 去保存 activeTodoItem，那么当其变化时会导致函数组件重新执行，视图重新渲染，但在这个场景中我们并不希望更新视图&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对的，我们希望这个 activeTodoItem 数据被缓存起来，不会随着视图的重新渲染而导致其作为 &lt;code&gt;useState&lt;/code&gt; 的执行结果重新生成一遍，因此我们可以改成用 &lt;code&gt;useRef&lt;/code&gt; 实现，因为其在内存中一直都是同一块内存地址，这样就不会因为它的改变而更新视图了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，在 useEffect 中如果使用到了 useRef 的数据，也不需要将其声明到 deps 数组中，因为其内存地址不会变化，所以每次在 useEffect 中获取到的 ref 数据一定是最新的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface TodoItem {&lt;br/&gt;  id: number&lt;br/&gt;  name: string&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const todoList: TodoItem[] = [&lt;br/&gt;  {&lt;br/&gt;    id: 1,&lt;br/&gt;    name: &#x27;coding&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 2,&lt;br/&gt;    name: &#x27;eating&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 3,&lt;br/&gt;    name: &#x27;sleeping&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 4,&lt;br/&gt;    name: &#x27;playing&#x27;,&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;br/&gt;const CacheDataWithRefDemo: React.FC = () =&amp;gt; {&lt;br/&gt;  const activeTodoItem = useRef(todoList[0])&lt;br/&gt;&lt;br/&gt;  // 模拟 componentDidUpdate -- 如果改变 activeTodoItem 后组件没重新渲染，说明视图可以不依赖于 activeTodoItem 数据&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(&#x27;检测组件是否有更新&#x27;)&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.container}&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.list}&amp;gt;&lt;br/&gt;        {todoList.map((todoItem) =&amp;gt; (&lt;br/&gt;          &amp;lt;div&lt;br/&gt;            key={todoItem.id}&lt;br/&gt;            className={s.item}&lt;br/&gt;            onClick={() =&amp;gt; (activeTodoItem.current = todoItem)}&lt;br/&gt;          &amp;gt;&lt;br/&gt;            &amp;lt;p&amp;gt;{todoItem.name}&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;/div&amp;gt;&lt;br/&gt;        ))}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;      &amp;lt;button onClick={() =&amp;gt; logger.log(activeTodoItem.current)}&amp;gt;&lt;br/&gt;        控制台输出最新的 activeTodoItem&lt;br/&gt;      &amp;lt;/button&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3648124191461837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6Hbv7y5fEbBHsaibDcnuLDGXyeN52icbIs4FmXRgWhBDNTzLXRsjRxcqg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1546&quot;/&gt;&lt;figcaption&gt;使用ref缓存函数组件数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 通过 callback ref 探究 ref 原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先先看一个关于 callback ref 的小 Demo 来引出我们后续的内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface RefDemo8State {&lt;br/&gt;  counter: number&lt;br/&gt;}&lt;br/&gt;class RefDemo8 extends React.Component&amp;lt;{}, RefDemo8State&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;RefDemo8State&amp;gt; = {&lt;br/&gt;    counter: 0,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  el: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;div&lt;br/&gt;          ref={(el) =&amp;gt; {&lt;br/&gt;            this.el = el&lt;br/&gt;            console.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;          }}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          ref element&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt; this.setState({ counter: this.state.counter + 1 })}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          add&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17685589519650655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6d3IP3wvfBExBtibUpu0lY0RwrRpoj1GLNibQHNjvNfeEEju9vEaAliaRQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;916&quot;/&gt;&lt;figcaption&gt;ref执行两次的现象&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会执行两次？为什么第一次 &lt;code&gt;this.el === null&lt;/code&gt;？为什么第二次又正常了？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1. ref 的底层原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得 React 底层是有 render 阶段和 commit 阶段的吗？关于 ref 的处理逻辑就在 commit 阶段进行的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 底层有两个关于 ref 的处理函数 -- &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的 Demo 中 callback ref 执行了两次正是对应着这两次函数的调用，大致来讲可以理解为 &lt;strong&gt;&lt;code&gt;commitDetachRef&lt;/code&gt; 在 DOM 更新之前执行，&lt;code&gt;commitAttachRef&lt;/code&gt; 在 DOM 更新之后执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就不难理解为什么会有上面 Demo 中的现象了，但我们还是要结合源码来看看，加深自己的理解&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1. commitDetachRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新版本的 React 源码中它改名为了 safelyDetachRef，但是核心逻辑没变，这里我将核心逻辑简化出来供大家阅读：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitDetachRef&lt;/span&gt;(&lt;span&gt;current: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// current 是已经调和完了的 fiber 对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentRef = current.ref&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (currentRef !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; currentRef === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// callback ref 和 string ref 执行时机&lt;/span&gt;&lt;br/&gt;      currentRef(&lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// object ref 处理时机&lt;/span&gt;&lt;br/&gt;      currentRef.current = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，就是从 fiber 中取出 ref，然后根据 callback ref、string ref、object ref 的情况进行处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且也能看到 &lt;code&gt;commitDetachRef&lt;/code&gt; 主要是将 ref 置为 null，这也就是为什么 &lt;code&gt;RefDemo8&lt;/code&gt; 中第一次执行的 callback ref 中看到的 this.el 是 null 了&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2. commitAttachRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心逻辑代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitAttachRef&lt;/span&gt;(&lt;span&gt;finishedWork: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = finishedWork.ref&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ref !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; instance = finishedWork.stateNode&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; instanceToUse&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理 ref 来源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (finishedWork.tag) {&lt;br/&gt;      &lt;span&gt;// HostComponent 代表 DOM 元素类型的 tag&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; HostComponent:&lt;br/&gt;        instanceToUse = getPublicInstance(instance)&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 类组件使用组件实例&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        instanceToUse = instance&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ref === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// callback ref 和 string ref&lt;/span&gt;&lt;br/&gt;      ref(instanceToUse)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// object ref&lt;/span&gt;&lt;br/&gt;      ref.current = instanceToUse&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2. 为什么 string ref 也是以函数的方式调用？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的核心源码中能看到，对于 &lt;code&gt;callback ref&lt;/code&gt; 和 &lt;code&gt;string ref&lt;/code&gt;，都是统一以函数的方式调用，将 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;instanceToUse&lt;/code&gt; 传入&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;callback ref&lt;/code&gt; 这样做还能理解，但是为什么 &lt;code&gt;string ref&lt;/code&gt; 也是这样处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当 React 检测到是 &lt;code&gt;string ref&lt;/code&gt; 时，会自动绑定一个函数用于处理 &lt;code&gt;string ref&lt;/code&gt;，核心源码逻辑如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactChildFiber.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 从元素上获取 ref&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; mixedRef = element.ref&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; stringRef = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + mixedRef&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ref = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;value&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// resolvedInst 就是组件实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; refs = resolvedInst.refs&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (value === &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt; refs[stringRef]&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    refs[stringRef] = value&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来 string ref 也变成了一个函数了，从而可以在 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 中被执行，并且也能印证为什么 &lt;code&gt;string ref&lt;/code&gt; 会在类组件实例的 &lt;code&gt;refs&lt;/code&gt; 属性中获取到&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3. ref 的执行时机&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在 RefDemo8 中我们每次点击按钮时都会触发 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 呢？这就需要聊聊 ref 的执行时机了，而从上文也能够了解到，ref 底层实际上是由 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 在处理核心逻辑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们就得来看看这两个函数的执行时机才能行&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1. commitDetachRef 执行时机&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitMutationEffectsOnFiber&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  finishedWork: Fiber,&lt;br/&gt;  root: FiberRoot,&lt;br/&gt;  lanes: Lanes,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; current = finishedWork.alternate&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; flags = finishedWork.flags&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; Ref) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (current !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 也就是 commitDetachRef&lt;/span&gt;&lt;br/&gt;      safelyDetachRef(current, current.return)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2. commitAttachRef 执行时机&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitLayoutEffectOnFiber&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  finishedRoot: FiberRoot,&lt;br/&gt;  current: Fiber | null,&lt;br/&gt;  finishedWork: Fiber,&lt;br/&gt;  committedLanes: Lanes,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; flags = finishedWork.flags&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; Ref) {&lt;br/&gt;    safelyAttachRef(finishedWork, finishedWork.return)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.3. fiber 何时打上 Ref tag?&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，只有当 fiber 被打上了 &lt;code&gt;Ref&lt;/code&gt; 这个 flag tag 时才会去执行 &lt;code&gt;commitDetachRef&lt;/code&gt;/&lt;code&gt;commitAttachRef&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么时候会标记 Ref tag 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberBeginWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;markRef&lt;/span&gt;(&lt;span&gt;current: Fiber | null, workInProgress: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = workInProgress.ref&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;// current === null 意味着是初次挂载，fiber 首次调和时会打上 Ref tag&lt;/span&gt;&lt;br/&gt;    (current === &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ref !== &lt;span&gt;null&lt;/span&gt;) ||&lt;br/&gt;    &lt;span&gt;// current !== null 意味着是更新，此时需要 ref 发生了变化才会打上 Ref tag&lt;/span&gt;&lt;br/&gt;    (current !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.ref !== ref)&lt;br/&gt;  ) {&lt;br/&gt;    &lt;span&gt;// Schedule a Ref effect&lt;/span&gt;&lt;br/&gt;    workInProgress.flags |= Ref&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.4. 为什么每次点击按钮 callback ref 都会执行？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在再回过头来思考 &lt;code&gt;RefDemo8&lt;/code&gt; 中为什么每次点击按钮都会执行 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们使用 &lt;code&gt;callback ref&lt;/code&gt; 的时候是如何使用的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;div&lt;br/&gt;  ref={(el) =&amp;gt; {&lt;br/&gt;    this.el = el&lt;br/&gt;    console.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;  }}&lt;br/&gt;&amp;gt;&lt;br/&gt;  ref element&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是直接声明了一个箭头函数，这样的方式会导致每次渲染这个 div 元素时，给 ref 赋值的都是一个新的箭头函数，尽管函数的内容是一样的，但内存地址不同，因而 &lt;code&gt;current.ref !== ref&lt;/code&gt; 这个判断条件会成立，从而每次都会触发更新&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.5. 如何解决？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么要如何解决这个问题呢？既然我们已经知道了问题的原因，那么就好说了，只要让每次赋值给 ref 的函数都是同一个就可以了呗~&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const logger = createLoggerWithScope(&#x27;RefDemo9&#x27;)&lt;br/&gt;&lt;br/&gt;interface RefDemo9Props {}&lt;br/&gt;interface RefDemo9State {&lt;br/&gt;  counter: number&lt;br/&gt;}&lt;br/&gt;class RefDemo9 extends React.Component&amp;lt;RefDemo9Props, RefDemo9State&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;RefDemo9State&amp;gt; = {&lt;br/&gt;    counter: 0,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  el: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  constructor(props: RefDemo9Props) {&lt;br/&gt;    super(props)&lt;br/&gt;    this.setElRef = this.setElRef.bind(this)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  setElRef(el: HTMLDivElement | null) {&lt;br/&gt;    this.el = el&lt;br/&gt;    logger.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;div ref={this.setElRef}&amp;gt;ref element&amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt; this.setState({ counter: this.state.counter + 1 })}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          add&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16304347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6I6NVM5LKRLVHeREvHiaf8v6Ru3jMicVriaURSRgzHjAFMAkTjBnKOlFUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;修复点击按钮后ref多次执行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就完美解决啦，既修复了 bug，又搞懂了 ref 的底层原理，一举两得！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章我们学习到了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ref 的理解与使用，包括如何创建 ref 对象，以及除了 object ref 之外的 string ref 和 callback ref 的方式去使用 ref&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ref 的高阶用法，包括 forwardRef 转发 ref、ref 实现组件通信、利用 ref 在函数组件中缓存数据等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过一个简单的 callback ref 的 Demo 研究 ref 的底层原理，string ref 为何也是以函数的方式被调用，以及 ref 的执行时机&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d973719e0005ac1e3c6ca792f334f30</guid>
<title>有趣的 Go HttpClient 超时机制</title>
<link>https://toutiao.io/k/l30t274</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是既写 Java 又写 Go 的小楼，在写 Go 的过程中我经常对比这两种语言的特性，踩了不少坑，也发现了不少有意思的地方，今天就来聊聊 Go 自带的 HttpClient 的超时机制。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java HttpClient 超时底层原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍 Go 的 HttpClient 超时机制之前，我们先看看 Java 是如何实现超时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一个 Java 原生的 HttpClient，设置连接超时、读取超时时间分别对应到底层的方法分别是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4959871589085072&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTU3nYSO6mYGKgvR6iaUriaiblDicHrFt5iaiaKEzj5OwzlO7e4SiceiaZq83mVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再追溯到 JVM 源码，发现是对系统调用的封装，其实不光是 Java，大部分的编程语言都借助了操作系统提供的超时能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而 Go 的 HttpClient 却提供了另一种超时机制，挺有意思，我们来盘一盘。但在开始之前，我们先了解一下 Go 的 Context。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go Context 简介&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Go 源码的注释：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;// A Context carries a deadline, a cancellation signal, and other values across
// API boundaries.
// Context&#x27;s methods may be called by multiple goroutines simultaneously.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 简单来说是一个可以携带超时时间、取消信号和其他数据的接口，Context 的方法会被多个协程同时调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 有点类似 Java 的ThreadLocal，可以在线程中传递数据，但又不完全相同，它是显示传递，ThreadLocal 是隐式传递，除了传递数据之外，Context 还能携带超时时间、取消信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 只是定义了接口，具体的实现在 Go 中提供了几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Background ：空的实现，啥也没做&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TODO：还不知道用什么 Context，先用 TODO 代替，也是啥也没做的空 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cancelCtx：可以取消的 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timerCtx：主动超时的 Context&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 Context 的三个特性，可以通过 Go 提供的 Context 实现以及源码中的例子来进一步了解下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 三个特性例子&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的例子来源于 Go 的源码，位于 &lt;code&gt;src/context/example_test.go&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;携带数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;context.WithValue&lt;/code&gt; 来携带，使用  &lt;code&gt;Value&lt;/code&gt; 来取值，源码中的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; favContextKey &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; f := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, k favContextKey)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v := ctx.Value(k); v != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;found value:&quot;&lt;/span&gt;, v)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;key not found:&quot;&lt;/span&gt;, k)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; k := favContextKey(&lt;span&gt;&quot;language&quot;&lt;/span&gt;)&lt;br/&gt; ctx := context.WithValue(context.Background(), k, &lt;span&gt;&quot;Go&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; f(ctx, k)&lt;br/&gt; f(ctx, favContextKey(&lt;span&gt;&quot;color&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// found value: Go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// key not found: color&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先起一个协程执行一个死循环，不停地往 channel 中写数据，同时监听 &lt;code&gt;ctx.Done()&lt;/code&gt; 的事件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;gen := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  dst := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  n := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// returning not to leak the goroutine&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; dst &amp;lt;- n:&lt;br/&gt;     n++&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dst&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 &lt;code&gt;context.WithCancel&lt;/code&gt; 生成一个可取消的 Context，传入 &lt;code&gt;gen&lt;/code&gt; 方法，直到 &lt;code&gt;gen&lt;/code&gt; 返回 5 时，调用 &lt;code&gt;cancel&lt;/code&gt; 取消 &lt;code&gt;gen&lt;/code&gt; 方法的执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;ctx, cancel := context.WithCancel(context.Background())&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; cancel() &lt;span&gt;// cancel when we are finished consuming integers&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;range&lt;/span&gt; gen(ctx) {&lt;br/&gt; fmt.Println(n)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n == &lt;span&gt;5&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，可以简单理解为在一个协程的循环中埋入结束标志，另一个协程去设置这个结束标志。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 cancel 的铺垫，超时就好理解了，cancel 是手动取消，超时是自动取消，只要起一个定时的协程，到时间后执行 cancel 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置超时时间有2种方式：&lt;code&gt;context.WithTimeout&lt;/code&gt; 与 &lt;code&gt;context.WithDeadline&lt;/code&gt;，WithTimeout 是设置一段时间后，WithDeadline 是设置一个截止时间点，WithTimeout 最终也会转换为 WithDeadline。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithTimeout&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Pass a context with a timeout to tell a blocking function that it&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// should abandon its work after the timeout elapses.&lt;/span&gt;&lt;br/&gt; ctx, cancel := context.WithTimeout(context.Background(), shortDuration)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;1&lt;/span&gt; * time.Second):&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;overslept&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  fmt.Println(ctx.Err()) &lt;span&gt;// prints &quot;context deadline exceeded&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go HttpClient 的另一种超时机制&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Context 可以设置任意代码段执行的超时机制，就可以设计一种脱离操作系统能力的请求超时能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 Go 的 HttpClient 超时配置说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Second,&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// ... 省略其他字段&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Timeout specifies a time limit for requests made by this&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Client. The timeout includes connection time, any&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// redirects, and reading the response body. The timer remains&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// running after Get, Head, Post, or Do return and will&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interrupt reading of the Response.Body.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// A Timeout of zero means no timeout.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The Client cancels requests to the underlying Transport&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// as if the Request&#x27;s Context ended.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// For compatibility, the Client will also use the deprecated&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// CancelRequest method on Transport if found. New&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// RoundTripper implementations should use the Request&#x27;s Context&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for cancellation instead of implementing CancelRequest.&lt;/span&gt;&lt;br/&gt; Timeout time.Duration&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译一下注释：&lt;code&gt;Timeout&lt;/code&gt; 包括了连接、redirect、读取数据的时间，定时器会在 Timeout 时间后打断数据的读取，设为0则没有超时限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说这个超时是一个请求的&lt;strong&gt;总体超时时间&lt;/strong&gt;，而不必再分别去设置连接超时、读取超时等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于使用者来说可能是一个更好的选择，大部分场景，使用者不必关心到底是哪部分导致的超时，而只是想这个 HTTP 请求整体什么时候能返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制底层原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个最简单的例子来阐述超时机制的底层原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我起了一个本地服务，用 Go HttpClient 去请求，超时时间设置为 10 分钟，建议使 Debug 时设置长一点，否则可能超时导致无法走完全流程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Minute,&lt;br/&gt; }&lt;br/&gt; resp, err := client.Get(&lt;span&gt;&quot;http://127.0.0.1:81/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 根据 timeout 计算出超时的时间点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;deadline = c.deadline()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 设置请求的 cancel&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;stopTimer, didTimeout := setRequestCancel(req, rt, deadline)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里返回的 stopTimer 就是可以手动 cancel 的方法，didTimeout 是判断是否超时的方法。这两个可以理解为回调方法，调用 stopTimer() 可以手动 cancel，调用 didTimeout() 可以返回是否超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置的主要代码其实就是将请求的 Context 替换为 cancelCtx，后续所有的操作都将携带这个 cancelCtx：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; cancelCtx &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; oldCtx := req.Context(); timeBeforeContextDeadline(deadline, oldCtx) {&lt;br/&gt; req.ctx, cancelCtx = context.WithDeadline(oldCtx, deadline)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，再起一个定时器，当超时时间到了之后，将 timedOut 设置为 true，再调用 doCancel()，doCancel() 是调用真正 RoundTripper （代表一个 HTTP 请求事务）的 CancelRequest，也就是取消请求，这个跟实现有关。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;timer := time.NewTimer(time.Until(deadline))&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timedOut atomicBool&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-initialReqCancel:&lt;br/&gt;  doCancel()&lt;br/&gt;  timer.Stop()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-timer.C:&lt;br/&gt;  timedOut.setTrue()&lt;br/&gt;  doCancel()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-stopTimerCh:&lt;br/&gt;  timer.Stop()&lt;br/&gt; }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 默认 RoundTripper CancelRequest 实现是关闭这个连接&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest cancels an in-flight request by closing its connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest should only be called after RoundTrip has returned.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *Transport)&lt;/span&gt; &lt;span&gt;CancelRequest&lt;/span&gt;&lt;span&gt;(req *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; t.cancelRequest(cancelKey{req}, errRequestCanceled)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 获取连接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  req.closeBody()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, ctx.Err()&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; pconn, err := t.getConn(treq, cm)&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的开头监听 ctx.Done，如果超时则直接返回，使用 for 循环主要是为了请求的重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续的 getConn 是阻塞的，代码比较长，挑重点说，先看看有没有空闲连接，如果有则直接返回&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for idle connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; delivered := t.queueForIdleConn(w); delivered {&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; pc, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有空闲连接，起个协程去异步建立，建立成功再通知主协程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for permission to dial.&lt;/span&gt;&lt;br/&gt;t.queueForDial(w)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着是一个 select 等待连接建立成功、超时或者主动取消，这就实现了在连接过程中的超时&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait for completion or cancellation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-w.ready:&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; w.pc, w.err&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Cancel:&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errRequestCanceledConn&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Context().Done():&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, req.Context().Err()&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; err := &amp;lt;-cancelc:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == errRequestCanceled {&lt;br/&gt;  err = errRequestCanceledConn&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 读写数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一条连接建立的时候，每个链接还偷偷起了两个协程，一个负责往连接中写入数据，另一个负责读数据，他们都监听了相应的 channel。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.readLoop()&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.writeLoop()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 wirteLoop 监听来自主协程的数据，并往连接中写入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(pc *persistConn)&lt;/span&gt; &lt;span&gt;writeLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(pc.writeLoopDone)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; wr := &amp;lt;-pc.writech:&lt;br/&gt;   startBytesWritten := pc.nwrite&lt;br/&gt;   err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))&lt;br/&gt;   &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    pc.&lt;span&gt;close&lt;/span&gt;(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-pc.closech:&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，readLoop 读取响应数据，并写回主协程。读与写的过程中如果超时了，连接将被关闭，报错退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的这种请求超时机制，可随时终止请求，可设置整个请求的超时时间。其实现主要依赖协程、channel、select 机制的配合。总结出套路是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主协程生成 cancelCtx，传递给子协程，主协程与子协程之间用 channel 通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主协程 select channel 和 cancelCtx.Done，子协程完成或取消则 return&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环任务：子协程起一个循环处理，每次循环开始都 select cancelCtx.Done，如果完成或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞任务：子协程 select 阻塞任务与 cancelCtx.Done，阻塞任务处理完或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以循环任务为例&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1331747919143875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTzoeScE46RINHUASNk1EKNfbucMYT7752Ogyk26kHicEXLuKtVkHibgbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java 能实现这种超时机制吗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接说结论：暂时不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 Java 的线程太重，像 Go 这样一次请求开了这么多协程，换成线程性能会大打折扣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次 Go 的 channel 虽然和 Java 的阻塞队列类似，但 Go 的 select 是多路复用机制，Java 暂时无法实现，即无法监听多个队列是否有数据到达。所以综合来看 Java 暂时无法实现类似机制。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 Go 另类且有趣的 HTTP 超时机制，并且分析了底层实现原理，归纳出了这种机制的套路，如果我们写 Go 代码，也可以如此模仿，让代码更 Go。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>