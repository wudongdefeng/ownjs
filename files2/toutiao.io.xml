<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>410b33aba7a9684e88952fd24b9fa416</guid>
<title>内部分享讲解DevOps后，我再组织成文</title>
<link>https://toutiao.io/k/asi9e5r</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot; class=&quot;zh_CN wx_wap_page &amp;#10;&amp;#10;                                            wx_wap_desktop_fontsize_2    mm_appmsg&amp;#10; comment_feature&amp;#10; discuss_tab appmsg_skin_default appmsg_style_default&quot;&gt;
    





    






    






&lt;p class=&quot;wx_network_msg_wrp&quot; id=&quot;js_network_msg_wrp&quot;/&gt;

















&lt;div id=&quot;js_pc_weapp_code&quot; class=&quot;weui-desktop-popover weui-desktop-popover_pos-up-center weui-desktop-popover_img-text weapp_code_popover&quot;&gt;
  &lt;div class=&quot;weui-desktop-popover__inner&quot;&gt;
      &lt;div class=&quot;weui-desktop-popover__desc&quot;&gt;
          &lt;img id=&quot;js_pc_weapp_code_img&quot;/&gt;&lt;p&gt;
          微信扫一扫&lt;/p&gt;&lt;p&gt;使用小程序&lt;/p&gt;&lt;span id=&quot;js_pc_weapp_code_des&quot;/&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;





    
    

&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_colon&quot;&gt;：&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_comma&quot;&gt;，&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_period&quot;&gt;。&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_space&quot;&gt; &lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_video&quot;&gt;视频&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_type_weapp&quot;&gt;小程序&lt;/span&gt;


&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_txt&quot;&gt;赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_zan_btn_tips&quot;&gt;，轻点两下取消赞&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_txt&quot;&gt;在看&lt;/span&gt;
&lt;span aria-hidden=&quot;true&quot; class=&quot;weui-a11y_ref&quot; id=&quot;js_a11y_like_btn_tips&quot;&gt;，轻点两下取消在看&lt;/span&gt;

    
    
    













    






  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa809bc6771cd51a2849454b0297270b</guid>
<title>【深入浅出Spring原理及实战】「技术原理」Spring Security的核心功能和加载运行流程的原理分析_洛神灬殇的博客-CSDN博客</title>
<link>https://toutiao.io/k/69smrwo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;SpringSecurity_0&quot;/&gt;SpringSecurity的架构总览&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b1d24680d9f4fe071e264abed5a55e9c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Spring_Security_4&quot;/&gt;Spring Security的简介说明&lt;/h3&gt; 
&lt;p&gt;Spring Security对认证、授权和常见漏洞保护提供了全方位支持。使用的版本为：Spring Security 5.5.2。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_8&quot;/&gt;概念释义&lt;/h4&gt; 
 
&lt;h4&gt;&lt;a id=&quot;_17&quot;/&gt;技术原理&lt;/h4&gt; 
&lt;p&gt;Spring Security 在基于Servlet应用中，其底层是采用了Filter机制实现了对请求的认证、授权和漏洞防御等功能。&lt;/p&gt; 
&lt;p&gt;简单来说，可以理解为给Servlet设置一些Filters，这些Filters就构成了一个FilterChain。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_23&quot;/&gt;请求拦截处理&lt;/h5&gt; 
&lt;p&gt;每次当请求进来时，首先会被FilterChain中的Filters 依次捕获得到，每个Filter可以对请求进行一些预处理或对响应进行一些后置处理，最后才会到达Servlet。具体流程如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5f95762f6542e2834bb763095a5d2980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;FilterChain_29&quot;/&gt;FilterChain的实例对象&lt;/h5&gt; 
&lt;p&gt;FilterChain中的Filter主要有两方面作用：&lt;/p&gt; 
 
&lt;h5&gt;&lt;a id=&quot;DelegatingFilterProxy_37&quot;/&gt;DelegatingFilterProxy&lt;/h5&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;基于Servlet规范，我们可以为 Servlet容器 注入一些自定义Filters，但是在 Spring 应用中，实现了Filter接口的Bean无法被 Servlet容器 感知到，没有调用ServletContext#addFilter方法注册到FilterChain中。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Spring 提供了一个DelegatingFilterProxy代理类，DelegatingFilterProxy实现了Filter，因此它可以被注入到FilterChain中，同时，当请求到来时，它会把请求转发到Spring容器 中实现了Filter接口的 Bean 实体，所以DelegatingFilterProxy桥接了 Servlet容器 和 Spring容器。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;DelegatingFilterProxy作用示意图大致如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/a94aad295230237c98435ebdda5180ea.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当请求到来时，DelegatingFilterProxy会从ApplicationContext中获取FilterBean 实体，然后将请求转发给到它，伪代码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletResponse&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FilterChain&lt;/span&gt; chain&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    
    
    &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; delegate &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilterBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someBeanName&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    delegate&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;doFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;request&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; response&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;h4&gt;&lt;a id=&quot;FilterChainProxy_59&quot;/&gt;FilterChainProxy&lt;/h4&gt; 
&lt;p&gt;Spring容器中的Filters Bean实体可以注入到Servlet容器中的FilterChain功能，基于此，Spring Security向Spring容器提供了一个FilterChainProxy Bean 实体，该FilterChainProxy实现了Filter接口，因此，请求就会被FilterChainProxy捕获到，这样 Spring Security 就可以开始工作了。&lt;/p&gt; 
&lt;p&gt;默认情况下，DelegatingFilterProxy从Spring容器中获取得到的就是FilterChainProxy实体，而FilterChainProxy也是一个代理类，它最终会将请求转发到 Spring Security 提供的SecurityFilterChain中，流程示意图如下所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/64ebc3a442f53ae44191b02542101649.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注：FilterChainProxy就是 Spring Security 真正的入口起始点，调式代码时，将断点设置在FilterChainProxy#doFilter就可以追踪 Spring Security 完整调用流程。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;SecurityFilterChain_69&quot;/&gt;SecurityFilterChain&lt;/h4&gt; 
&lt;p&gt;SecurityFilterChain作用其实跟Servlet的FilterChain一样，同样维护了很多Filters，这些Filters 是由Spring Security提供的，每个 Security Filter 都有不同的职能，比如登录认证、CSRF防御…如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/76bfe46b8029d629c867fe838dae3d6c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;同时，Spring Security 支持添加多个SecurityFilterChain，每个SecurityFilterChain负责不同的请求（比如依据请求地址进行区分），这样可以为不同的请求设置不同的认证规则。其源码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityFilterChain&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;matches&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;HttpServletRequest&lt;/span&gt; request&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilters&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;具体来说，当请求到达FilterChainProxy时，其内部会根据当前请求匹配得到对应的SecurityFilterChain，然后将请求依次转发给到该SecurityFilterChain中的所有 Security Filters。如下图所示：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b648173f4ecb8f49aa454ec953d17660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Security_Filters_90&quot;/&gt;Security Filters&lt;/h3&gt; 
&lt;p&gt;Spring Security 最终对请求进行处理的就是某个SecurityFilterChain中的 Security Filters，这些Filter都设置为 Bean 注入到 Spring容器中，且这些Filters 的先后顺序很重要。以下是 Spring Security 内置的完整 Security Filter 顺序列表：&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;ChannelProcessingFilter：确保请求投递到要求渠道。最常见的使用场景就是指定哪些请求必须使用HTTPS 协议，哪些请求必须使用 HTTP 协议，哪些请求随便使用哪种协议均可。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;WebAsyncManagerIntegrationFilter：集成SecurityContext到 Spring Web 异步请求机制中的WebAsyncManager。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：SecurityContext就是 安全上下文，主要职能就是用于存储用户认证的一些信息。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SecurityContextPersistenceFilter：在每次请求处理之前，从 Session（默认使用HttpSessionSecurityContextRepository）中获取SecurityContext，然后将其设置给到SecurityContextHolder；在请求结束后，就会将SecurityContextHolder中存储的SecurityContext重新保存到 Session 中，并且清除SecurityContextHolder中的SecurityContext。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SecurityContextPersistenceFilter可以通过HttpSecurity#securityContext()及相关方法引入其配置对象SecurityContextConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;HeaderWriterFilter：该过滤器可为响应添加一些响应头，比如添加X-Frame-Options，X-XSS-Protection和X-Content-Type-Options等响应头，让浏览器开启保护功能。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;HeaderWriterFilter可以通过HttpSecurity#headers()来定制。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CorsFilter：处理跨域资源共享（CORS）。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;CorsFilter可以通过HttpSecurity#cors()来定制。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CsrfFilter：处理跨站请求伪造(CSRF)。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;CsrfFilter可以通过HttpSecurity#csrf()来开启或关闭。在前后端分离项目中，不需要使用 CSRF。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;LogoutFilter：处理退出登录请求。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;LogoutFilter可以通过HttpSecurity#logout()来定制退出逻辑。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2AuthorizationRequestRedirectFilter：用于构建 OAuth 2.0 认证请求，将用户请求重定向到该认证请求接口。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：该过滤器需要添加spring-security-oauth2等相关模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Saml2WebSsoAuthenticationRequestFilter：基于 SAML 的 SSO 单点登录认证请求过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：Saml2WebSsoAuthenticationRequestFilter需要添加 Spring Security SAML 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;X509AuthenticationFilter：X509 认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;X509AuthenticationFilter可以通过SecurityContext#X509()来启用和配置相关功能。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;AbstractPreAuthenticatedProcessingFilter：认证预处理请求过滤器基类，其中认证主体已经由外部系统进行了身份验证。目的只是从传入请求中提取主体上的必要信息，而不是对它们进行身份验证。可以继承该类进行具体实现并通过HttpSecurity#addFilter方法来添加个性化的AbstractPreAuthenticatedProcessingFilter。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;CasAuthenticationFilter：用于处理 CAS 单点登录认证。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注： CasAuthenticationFilter需要添加 Spring Security CAS 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2LoginAuthenticationFilter：OAuth2.0 登录认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注： OAuth2LoginAuthenticationFilter需要添加spring-security-oauth2等相关模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;Saml2WebSsoAuthenticationFilter：基于 SAML 的 SSO 单点登录认证过滤器。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;注：Saml2WebSsoAuthenticationFilter需要添加 Spring Security SAML 模块。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;UsernamePasswordAuthenticationFilter：用于处理表单登录认证。默认处理接口为/login，表单必须提供两个参数：用户名 和 密码，默认的参数名(key)为username和password，可以通过usernameParameter和passwordParameter方法进行修改。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;UsernamePasswordAuthenticationFilter可以通过HttpSecurity#formLogin()及相关方法引入其配置对象FormLoginConfigurer来进行配置。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;OpenIDAuthenticationFilter：基于 OpenID 认证协议的认证过滤器。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DefaultLoginPageGeneratingFilter：如果没有配置登录页面，那么就会默认采用该过滤器生成一个登录表单页面。&lt;/p&gt; 
   &lt;/li&gt;&lt;li&gt; &lt;p&gt;DefaultLogoutPageGeneratingFilter：生成默认退出登录页面。&lt;/p&gt; 
   &lt;/li&gt;&lt;li&gt; &lt;p&gt;ConcurrentSessionFilter：主要用来判断 Session 是否过期以及更新最新访问时间。该过滤器可能会被多次执行。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DigestAuthenticationFilter：用于处理 HTTP 头部显示的摘要式身份验证凭据。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;DigestAuthenticationFilter可以通过HttpSecurity#addFilter()来启用和配置相关功能。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;BearerTokenAuthenticationFilter：处理 Token 认证。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;BasicAuthenticationFilter：用于检测和处理 Http Baisc 认证。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;BasicAuthenticationFilter可以通过HttpSecurity#httpBasic()及相关方法引入其配置对象HttpBaiscConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;RequestCacheAwareFilter：用于用户认证成功后，重新恢复因为登录被打断的请求。当匿名访问一个需要授权的资源时。会跳转到认证处理逻辑，此时请求被缓存。在认证逻辑处理完毕后，从缓存中获取最开始的资源请求进行再次请求。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;RequestCacheAwareFilter可以通过HttpSecurity#requestCache()及相关方法引入其配置对象RequestCacheConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SecurityContextHolderAwareRequestFilter：对请求对象进行包装，增加了一些安全相关方法。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SecurityContextHolderAwareRequestFilter可以通过HttpSecurity#servletApi()及相关方法引入其配置对象ServletApiConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;JaasApiIntegrationFilter：适用于 JAAS （Java 认证授权服务）。如果SecurityContextHolder中拥有的Authentication是一个JaasAuthenticationToken，那么该JaasApiIntegrationFilter将使用包含在JaasAuthenticationToken中的Subject继续执行FilterChain。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;RememberMeAuthenticationFilter：当用户没有登录而直接访问资源时，从 cookie 里找出用户的信息，如果 Spring Security 能够识别出用户提供的 remember me cookie，用户将不必填写用户名和密码，而是直接登录进入系统。它先分析 SecurityContext 里有没有Authentication对象，如果有，则不做任何操作，直接跳到下一个过滤器；如果没有，则检查请求里有没有包含 remember-me 的 cookie 信息。如果有，则解析出 cookie 里的验证信息，判断是否有权限。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;RememberMeAuthenticationFilter可以通过HttpSecurity#rememberMe()及相关方法引入其配置对象RememberMeConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;AnonymousAuthenticationFilter：匿名认证过滤器，检测SecurityContextHolder中是否存在Authentication对象，如果不存在，就生成一个匿名Authentication对象。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;AnonymousAuthenticationFilter可以通过HttpSecurity#anonymous()及相关方法引入其配置对象AnonymousConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;OAuth2AuthorizationCodeGrantFilter：OAuth 2.0 授权码模式，用于处理 OAuth 2.0 授权码响应。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SessionManagementFilter：检测用户是否通过认证，如果已认证，就通过SessionAuthenticationStrategy进行 Session 相关管理操作。&lt;/p&gt; 
  &lt;ul&gt;&lt;li&gt;SessionManagementFilter可以通过HttpSecurity#sessionManagement()及相关方法引入其配置对象SessionManagementConfigurer来进行配置。&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;ExceptionTranslationFilter：可以用于捕获FilterChain上所有的异常，但只处理AccessDeniedException和AuthenticationException异常。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;FilterSecurityInterceptor：对 web资源 进行一些安全保护操作。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;SwitchUserFilter：主要用来作用户切换。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;h3&gt;&lt;a id=&quot;_201&quot;/&gt;自动配置&lt;/h3&gt; 
&lt;p&gt;依据 Spring Boot 自动配置原理，其会自动加载spring-boot-autoconfigure.jar中/META-INF/spring.factories内键值org.springframework.boot.autoconfigure.EnableAutoConfiguration指定的自动配置类。查看该文件，可以看到，与 Spring Security 相关的自动配置类有如下几个：&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,                                      \
org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,                            \
org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,                                \
org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,                             \
org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,                   \
org.springframework.boot.autoconfigure.security.rsocket.RSocketSecurityAutoConfiguration,                               \
org.springframework.boot.autoconfigure.security.saml2.Saml2RelyingPartyAutoConfiguration,                               \
org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,                    \
org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,           \
org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,          \
org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration, \
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;每个配置类都为 Spring Security 注入不同的 Bean 到 Spring容器中。这里我们着重介绍一下SecurityFilterAutoConfiguration和SecurityAutoConfiguration配置类，因为这两个配置类会自动装配DelegatingFilterProxy和FilterChain到 Spring容器 中。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;FilterChainProxy_221&quot;/&gt;自动装配FilterChainProxy&lt;/h4&gt; 
&lt;p&gt;下面介绍下配置类SecurityAutoConfiguration，具体如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SpringBootWebSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityEnablerConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;SecurityDataConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityAutoConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;AuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;authenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ApplicationEventPublisher&lt;/span&gt; publisher&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultAuthenticationEventPublisher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;publisher&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;SecurityAutoConfiguration导入了3个配置类，注重看WebSecurityEnablerConfiguration。&lt;br/&gt; 查看WebSecurityEnablerConfiguration配置类，其源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;springSecurityFilterChain&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;EnableWebSecurity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConditionalOnWebApplication&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;Type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVLET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableWebSecurity&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityEnablerConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;当 Spring容器 中没有名称为springSecurityFilterChain的 Bean 等条件时，就会加载该配置类，此时@EnableWebSecurity注解生效：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Retention&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;RetentionPolicy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;RUNTIME&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Target&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;ElementType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;TYPE&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Documented&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Import&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SpringWebMvcImportSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;OAuth2ImportSelector&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;HttpSecurityConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableGlobalAuthentication&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token annotation punctuation&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;EnableWebSecurity&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;注解@EnableWebSecurity又导入了4个配置类，这里着重看下WebSecurityConfiguration：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;WebSecurityConfiguration&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ImportAware&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BeanClassLoaderAware&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;springSecurityFilterChain&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;springSecurityFilterChain&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Exception&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;webSecurity&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到，WebSecurityConfiguration#springSecurityFilterChain()最终生成了一个名称为springSecurityFilterChain的 Bean 实体，该 Bean 的实际类型其实为FilterChainProxy，是由WebSecurity#build()方法创建的。&lt;/p&gt; 
&lt;p&gt;综上，SecurityAutoConfiguration配置类生成了很多 Bean 实体，其中最重要的一个是名称为springSecurityFilterChain的FilterChainProxy对象。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;DelegatingFilterProxy_292&quot;/&gt;自动装配DelegatingFilterProxy&lt;/h4&gt; 
&lt;p&gt;下面介绍下配置类SecurityFilterAutoConfiguration，其源码如下所示：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token annotation punctuation&quot;&gt;@Configuration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proxyBeanMethods &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnWebApplication&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;type &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Type&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token constant&quot;&gt;SERVLET&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@EnableConfigurationProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnClass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;AbstractSecurityWebApplicationInitializer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SessionCreationPolicy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token annotation punctuation&quot;&gt;@AutoConfigureAfter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SecurityAutoConfiguration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SecurityFilterAutoConfiguration&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;token annotation punctuation&quot;&gt;@ConditionalOnBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;name &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; “springSecurityFilterChain”&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxyRegistrationBean&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;securityFilterChainRegistration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;SecurityProperties&lt;/span&gt; securityProperties&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;可以看到，要加载SecurityFilterAutoConfiguration前，必须先加载配置类SecurityAutoConfiguration，该配置类前面已经详细介绍了，主要功能就是注入了一个名称为springSecurityFilterChain的 Bean，因此，此时SecurityFilterAutoConfiguration#securityFilterChainRegistration就会生效，最终生成一个DelegatingFilterProxyRegistrationBean实体。DelegatingFilterProxyRegistrationBean实现了ServletContextInitializer接口，当系统执行ServletWebServerApplicationContext.selfInitialize()进行初始化时，会依次调用到：RegistrationBean.onStartup() --&amp;gt; DynamicRegistrationBean.register() --&amp;gt; AbstractFilterRegistrationBean.addRegistration()，其中，AbstractFilterRegistrationBean#addRegistration()源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Dynamic&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;addRegistration&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt; description&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletContext&lt;/span&gt; servletContext&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Filter&lt;/span&gt; filter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; servletContext&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;addFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getOrDeduceName&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; filter&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;this.getFilter()实际调用的是DelegatingFilterProxyRegistrationBean#getFilter()方法，其内部会创建一个DelegatingFilterProxy实例并返回，源码如下：&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxy&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;getFilter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DelegatingFilterProxy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;targetBeanName&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;getWebApplicationContext&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;initFilterBean&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;throws&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ServletException&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;因此，AbstractFilterRegistrationBean#addRegistration()最终就是通过ServletContext#addFilter将一个DelegatingFilterProxy实例注入到 Servlet 的FilterChain中。&lt;/p&gt; 
&lt;p&gt;以上，就是 Spring Boot 中自动装配 Spring Security 相关配置源码分析，更加详细内容，可参考：&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_337&quot;/&gt;总结&lt;/h3&gt; 
&lt;p&gt;Spring Security 作用机制大致如下：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;注册标准Filter：首先，Spring 会自动注入一个DelegatingFilterProxy到 Servlet 的FilterChain中。&lt;/li&gt;&lt;li&gt;请求转发到 Spring Security：当请求到来时，DelegatingFilterProxy就会自动在 Spring容器 中搜索名称为springSecurityFilterChain的Filter实体，其实际类型为FilterChainProxy。DelegatingFilterProxy最终会将请求转发给到FilterChainProxy。&lt;/li&gt;&lt;li&gt;找到匹配请求处理的SecurityFilterChain：FilterChainProxy内部维护了一系列SecurityFilterChains，他会依据请求内容找到对应处理该请求的SecurityFilterChain。&lt;/li&gt;&lt;li&gt;请求处理：找到能处理请求的第一个SecurityFilterChain后，就会遍历该SecurityFilterChain内部维护的一系列Filters，依次让这些 Security Filter 处理该请求，完成认证、授权等功能。&lt;/li&gt;&lt;/ol&gt; 
&lt;h3&gt;&lt;a id=&quot;Spring_Security__347&quot;/&gt;Spring Security 架构简单示意图&lt;/h3&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/65312106d28bbccda30c6e41f3d25826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22435efb620166627d3c22a02c8011f7</guid>
<title>并发提升 10 倍，运算延时降低 70%，领健从 ClickHouse 和 Kudu 到 Apache Doris 数仓升级实践</title>
<link>https://toutiao.io/k/wx2ausy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSbFMFYjNSPkl5icLOQmTF0gtgtnfFcqXCM8rseMTv5WAh97v9jK9MR7FSN7cxlPu9FM7E1XpnyNbTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template-id=&quot;1159112&quot; data-mpa-category=&quot;fav&quot;&gt;&lt;section&gt;&lt;section data-tools-id=&quot;21516&quot;&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;KolEditor.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;导读：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;领健&lt;/span&gt;&lt;span&gt;最初使用 Apache Doris 替代了 ClickHouse，应用在为客户提供的增值报表服务中，解决了ClickHouse 并发宕机问题；在项目服务中发掘出 Doris 查询性能优异、简单易用、部署成本低等诸多优势，在 2021 年10月，领健决定将 Doris 引入到公司的数仓替代 Kudu，在 Doris 社区及 SelectDB 专业技术团队的支持下，业务逐步从 Kudu 迁移到 Doris，并在最近升级到 1.1.4 向量化版本。我们将通过本文为大家详细介绍领健基于 Doris 的演进实践及数仓构建的经验。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;｜&lt;/span&gt;&lt;/span&gt;&lt;span&gt;领健资深大数据开发工程师 &lt;span&gt;杨鷖&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;领健是健康科技行业 SaaS 软件的引领者，专注于消费医疗口腔和医美行业，为口腔诊所、医美机构、生美机构提供经营管理一体化系统，提供了覆盖单店管理、连锁管理、健康档案/电子病历、客户关系管理、智能营销、B2B交易平台、进销存、保险支付、影像集成、BI商业智能等覆盖机构业务全流程的一体化SaaS软件。同时通过开放平台连接产业上下游，与优质的第三方平台合作，为机构提供完整配套的一站式服务。截至当前，领健已经在全国设立了 20 余个分支机构，超过 30000 多家中高端以及连锁机构正在使用其服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;874&quot; data-ratio=&quot;0.8092592592592592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBe2XHPRwjPXZ17hOW8r4iayoVzMSsjlsT7mJbTbMcVt27SxDRKzRXCiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Doris 在领健的演进历程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进入正文之前，简单了解一下 Doris 在领健的发展历程。最初 Doris 替代 ClickHouse 被应用到数据服务项目中，该项目是领健为旗下客户提供的增值报表服务；&lt;/span&gt;&lt;span&gt;后在项目服务中发掘出 Doris 查询性能优异、简单易用、部署成本低等诸多优势，在 2021 年10月，我们决定扩大 Doris 应用范围，将 Doris 引入到公司的数仓中，在 Doris 社区及 SelectDB 专业技术团队的支持下，业务逐步从 Kudu 迁移到 Doris，并在最近升级到 1.1.4 向量化版本。我们将通过本文为大家详细介绍领健基于 Doris 的演进实践及数仓构建的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;728&quot; data-ratio=&quot;0.4899057873485868&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBHBQEqg4QXia8azGKGibU35Hffzjbuopbib7lPnZrSmiaCibwkma5s9gvuNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1486&quot; data-width=&quot;1486&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;数据服务架构演进&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2/&gt;&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;项目需求&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;领健致力于为医疗行业客户提供精细化门店运营平台，为客户提供了数据报表工具，该工具可实现自助式拖拽设计图表、支持多种自带函数自建、数据实时更新等功能，可以支持门店订单查询、客户管理、收入分析等，以推动门店数字化转型，辅助门店科学决策。为更好实现以上功能，数据报表工具需满足以下特点：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;支持复杂查询&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：客户进行自助拖拽设计图表时，将生成一段复杂的 SQL 查询语句直查数据库，且语句复杂度未知，这将对数据库带来不小的压力，从而影响查询性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高并发低延时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：至少可以支撑 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;100 &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;个&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;并发，并在 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;1 秒&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;内得到查询结果；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据实时同步：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;报表数据源自于 SaaS 系统，当客户对系统中的历史数据进行修改后，报表数据也要进行同步更改，保持一致，这就要求报表数据要与系统实现实时同步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;低成本易部署：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;SaaS 业务存在私有云客户，为降低私有化部署的人员及成本投入，这要求架构部署及运维要足够简单。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;ClickHouse 遭遇并发宕机&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h2&gt;&lt;span&gt;最初项目选用 ClickHouse 来提供数据查询服务，&lt;strong&gt;但在运行过程中 ClickHouse 遭遇了严重的并发问题，即 10 个并发就会导致 ClickHouse 宕机&lt;/strong&gt;，这使其无法正常为客户提供服务，这是迫使我们寻找可以替代 ClickHouse 产品的关键因素。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;除此之外还有 2 个较为棘手的问题：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;技术选型&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;针对存在的问题及需求，我们决定进行技术选型，分别对 Doris（0.14）、ClickHouse、Kudu 这 3 个产品展开的调研测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;698&quot; data-ratio=&quot;0.45265888456549935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB3pL4HRuox21XUUNyZNVWNJkrKEEPwkKmz9rUvibI24TeChIWPl6RPgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot; data-width=&quot;1542&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上表所示，我们对这 3 个产品进行了横向比较，可以看出 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 在多方面表现优异&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;高并发：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 并发性好，可支持上百甚至上千并发，轻松解决 10 并发导致 ClickHouse 宕机问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询性能：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 可实现毫秒级查询响应，在单表查询中，虽 Doris 与 ClickHouse 查询性能基本持平，但在多表查询中，Doris 远胜于 ClickHouse ，Doris 可以实现在较高的并发下，QPS 不下降。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据更新：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 的数据模型可以满足我们对数据更新的需求，以保障系统数据和业务数据的一致性，下文将详细介绍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用成本：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 架构简单，整体部署简单快速，具有完备的导入功能，很好的弹性伸缩能力；同时， Doris 内部可以自动做副本平衡，运维成本极低。而 Clickouse 及 Kudu 对组件依赖较高，在使用上需要做许多准备工作，这就要求具备一支专业的运维支持团队来处理大量的日常运维工作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标准 SQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;L：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Doris 兼容 MySQL 协议，使用标准 SQL，开发人员上手简单，不需要付出额外的学习成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式 Join&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;strong&gt;：&lt;/strong&gt;Doris 支持分布式 Join，而 ClickHouse 由于 Join 查询限制、函数局限性、以及可维护性较差等原因，不满足我们当前的业务需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;社区活跃：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Apache Doris 是国内自研数据库，开源社区相当活跃，同时 SelectDB 为 Doris 社区提供了专业且全职团队做技术支持，遇到问题可以直接与社区联系沟通，并能得到快速解决，这对于国外的项目，很大地降低与社区沟通的语言与时间成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;从以上调研中可以发现，Doris 各方面能力优秀，十分符合我们对选型产品的需求，因此&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我们使用 Doris 替代了 ClickHouse ，解决了ClickHouse 并发性能差、宕机等问题，很好的支撑了数据报表查询服务。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;数仓架构演进&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在数据报表的使用过程中，我们逐渐发掘出 Doris 诸多优势，因此决定扩大 Doris 应用范围，将 Doris 引入到公司的数仓中来。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;接下来将为大家介绍公司数仓从 Kudu 到 Doris 的演进历程，以及在搭建过程中的优化实践分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;早期数仓架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;早期的公司数仓架构使用 Kudu、Impala 来作为运算存储引擎，整体架构如下图所示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBfeescauLzJ4Vfj36rKib8cYgUkOrkmNfuJKLS5pf040E9tmokIZiaLSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1188&quot; data-width=&quot;1188&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可知，数据通过 Kafka Consumer 进入 ODS 层；通过 Kudu 层满足数据更新需要；运用 Impala 来执行数据运算和查询；通过自研平台 DMEP 进行任务调度。在 ETL 代码中会使用大量的 Upsert 对数据进行 Merge 操作，那么引入 Doris 的首要问题就是要如何实现 Merge 操作，支持业务数据更新，下文中将进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;新数仓架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;690&quot; data-ratio=&quot;0.5390625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBpDVdNlfLIQTqKpXfw2czBMbx0cazULwRrpty31FfdhM3XxJ92SPztQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;如上图所示，在新架构设计中使用 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Apache Doris 负责数仓存储及数据运算&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;；实时数据、 ODS数据的同步从 Kafka Consumter 改为 Flink ；流计算平台使用团队自研的 Duckula；任务调度则引入最新 的 DolphinSchedular，Dolphin schedule 几乎涵盖了自研 DMEP 的大部分功能，同时可以很方便拓展 ETL 的方式，可调度很多不同的任务。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;优化实践&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;数据模型选择&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;上文中提到，当客户对系统中的历史数据修改后，报表数据也要进行同步更改，同时，客户有时只更改某一列的数值，这要求我们需要选择合适的 Doris 模型来满足这些需求。我们在测试中发现，通过 Aggregate 聚合模型+&lt;/span&gt;&lt;code&gt;Replace_if_not_null&lt;/code&gt;&lt;span&gt;方式进行数据更新时，可以实现单独更新一列，代码如下：&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;drop table test.expamle_tbl2&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;CREATE TABLE IF NOT EXISTS test.expamle_tbl2&lt;br/&gt;(&lt;br/&gt;    `user_id` LARGEINT NOT &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户id&quot;&lt;/span&gt;,&lt;br/&gt;    `date` DATE NOT &lt;span&gt;NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;数据灌入日期时间&quot;&lt;/span&gt;,&lt;br/&gt;    `city` VARCHAR(&lt;span&gt;20&lt;/span&gt;) COMMENT &lt;span&gt;&quot;用户所在城市&quot;&lt;/span&gt;,&lt;br/&gt;    `age` SMALLINT COMMENT &lt;span&gt;&quot;用户年龄&quot;&lt;/span&gt;,&lt;br/&gt;    `sex` TINYINT COMMENT &lt;span&gt;&quot;用户性别&quot;&lt;/span&gt;,&lt;br/&gt;    `last_visit_date` DATETIME &lt;span&gt;&lt;strong&gt;REPLACE_IF_NOT_NULL&lt;/strong&gt;&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最后一次访问时间&quot;&lt;/span&gt;,&lt;br/&gt;    `cost` BIGINT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户总消费&quot;&lt;/span&gt;,&lt;br/&gt;    `max_dwell_time` INT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最大停留时间&quot;&lt;/span&gt;,&lt;br/&gt;    `min_dwell_time` INT &lt;span&gt;REPLACE_IF_NOT_NULL&lt;/span&gt; COMMENT &lt;span&gt;&quot;用户最小停留时间&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;AGGREGATE &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt;(`user_id`, `date`, `city`, `age`, `sex`)&lt;/span&gt;&lt;br/&gt;DISTRIBUTED BY &lt;span&gt;HASH&lt;/span&gt;&lt;span&gt;(`user_id`)&lt;/span&gt; BUCKETS 1&lt;br/&gt;&lt;span&gt;PROPERTIES&lt;/span&gt; &lt;span&gt;(&lt;br/&gt;&lt;span&gt;&quot;replication_allocation&quot;&lt;/span&gt; = &lt;span&gt;&quot;tag.location.default: 1&quot;&lt;/span&gt;&lt;br/&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;insert into test.&lt;span&gt;expamle_tbl2 &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;&lt;span&gt;(&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;&#x27;2017-10-01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;北京&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;&#x27;017-10-01 06:00:00&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;10&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;select * from test.expamle_tbl ;&lt;br/&gt;&lt;br/&gt;insert into test.expamle_tbl2 (user_id,date,city,age,sex,cost)&lt;br/&gt;values(&lt;span&gt;10000&lt;/span&gt;,&lt;span&gt;&#x27;2017-10-01&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;北京&#x27;&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;50&lt;/span&gt;);&lt;br/&gt;select * from test.expamle_tbl ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如下图所示，当写 50 进去，可以实现只覆盖&lt;/span&gt;&lt;code&gt;Cost&lt;/code&gt;&lt;span&gt;列，其他列保持不变。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;252&quot; data-ratio=&quot;0.196875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBQJsU0GUUmanh6ozL2NicdBJGEUzEqfykXNIBLVv43sxzZT5gntE0h6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;242&quot; data-ratio=&quot;0.1890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBDosJZiblOQliaAYZkl0bD5xEbLF7mdxc2HTzQqpuPibaaq8R79Zc1LEPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris Compaction 优化&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;当 Flink 抽取业务库全量数据、持续不断高频写入 Doris 时，将产生了大量数据版本，&lt;strong&gt;Doris 的 Compaction 合并版本速度跟不上新版本生成速度，从而造成数据版本堆积&lt;/strong&gt;。从下图可看出，BE Compaction Score 分数很高，最高可以达到 400，而健康状态分数应在 100 以下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;719&quot; data-ratio=&quot;0.56171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB3V1eE0Pq4zia8jtWGG8y9MpAcBibcYKwIHS1dYLjBRADPoNZjG94ic95A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对以上问题我们做了以下调整：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;全量数据不&lt;strong&gt;使用实时写入的方式&lt;/strong&gt;，先导出到 CSV，再通过 Stream Load 写入 Doris；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降低 Flink 写入频率，增大 Flink 单一批次数据量&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；该调整会降低数据的实时性，需与业务侧进行沟通，根据业务方对实时性的要求调整相关数值，最大程度的降低写入压力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;调节 Doris BE 参数&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，使更多 CPU 资源参与到 Compaction 操作中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;compaction_task_num_per_disk&lt;/code&gt;&lt;span&gt;单磁盘 Compaction 任务线程数默认值 2，提升后会大量占用CPU资源，阿里云 16 核，提升 1 个线程多占用 6% 左右 CPU。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;max_compaction_threads compaction&lt;/code&gt;&lt;span&gt;线程总数默认为10。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;max_cumulative_compaction_num_singleton_deltas&lt;/span&gt;&lt;span&gt; 参数控制一个 CC 任务最多合并 1000 个数据版本，适当改小后单个 Compaction 任务的执行时间变短，执行频率变高，集群整体版本数会更加稳定。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过调整集群， &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Compaction Score 稳定在了 50-100，有效解决了版本堆积问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;467&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBK1pTxxtXmfm2Kbls9mwwkFxbBGDP2djAibiaqKP0KOicnVgscHKiaXbXnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;值得关注的是，在 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 1.1 版本中对 Compaction 进行了一系列的优化&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在&lt;strong&gt;任务调度层面&lt;/strong&gt;，增加了主动触发式的 Compaction 任务调度，结合原有的被动式扫描，高效的感知数据版本的变化，主动触发Compaction。在&lt;strong&gt;任务执行层面&lt;/strong&gt;，对资源进行隔离，将重量级的 Base Compaction 和轻量级的Cumulative Compaction 进行了物理分离，防止任务的互相影响。同时，&lt;strong&gt;针对高频小文件的导入&lt;/strong&gt;，优化文件合并策略，采用梯度合并的方式，保证单次合并的文件都属于同一数量级，逐渐有层次的进行数据合并，减少单个文件参与合并的次数，大幅节省系统消耗。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;负载隔离&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;最初我们只有 1 个 Doris 集群，Doris 集群要同时支持高频实时写、 高并发查询、ETL 处理以及Adhoc 查询等功能。其中高频实时写对 CPU 的占用很高，而 CPU 的上限决定高并发查询的能力，另外 Adhoc 查询无法预知 SQL 的复杂度，当复杂度过高时也会占用较高的内存资源，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这就导致了资源竞争，业务之间互相影响的问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。为解决这些问题，我们进行了以下探索优化。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;666&quot; data-ratio=&quot;0.5203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aB7Oiabtc7n8ibNn5p6ZZuvVRL8Pm7iaQiaibtjD6ENKOq4Yh3AE3lMiatRzHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. Doris 集群拆分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最初我们尝试对 Doris 集群进行拆分，我们把 1 个集群拆分为 3 个集群，分别为 ODS 集群、DW 集群、ADS 集群。我们将 CPU 负载最高的 ODS 层分离出去， ETL 时，通过 Doris 外表连接另一个 Doris 集群抽取数据；同时也将 BI 应用访问的集群分离出去，独立为业务提供数据查询。&lt;strong&gt;如下所示为各集群负责的任务&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ODS 集群：数仓 ODS 层，Flink 写数据集中在此层进行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DW 集群：数仓 DW 层，DIM 层，主要负责 ETL 处理，Adhoc 查询任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;ADS 集群：数仓 ADS 层，主要支持 Web 应用的数据查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;359&quot; data-ratio=&quot;0.43833943833943834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBCTGFpvcaXpBYnvL75wib1DuSeXSmzNFOqr4gJibRET8o52w1yqlpwgiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot; data-width=&quot;819&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通过集群拆分，有效降低各个资源间的相互影响，保证每个业务运转都有较充足的资源。但是&lt;strong&gt;集群的拆分也存在集群之间数据同步 ETL 时间较长、从 ADS 到 ODS 跨3个集群的数据校验复杂度较高等问题&lt;/strong&gt;。直到 Doris 0.15 发布后，这些问题也得到了相对有效的解决。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 资源隔离优化集群资源&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Doris 0.15 版本&lt;strong&gt;新增了资源标签功能以及查询 Block 功能&lt;/strong&gt;，资源标签功能允许 Doris 集群实现资源隔离，该功能有效减少集群之间同步数据的时间，降低了跨集群数据校验复杂度。其次查询 Block 功能的上线，可以对 SQL 进行查询审计，阻塞简单/不合规的查询语句，降低资源占用率，提升查询性能。除此之外，通过资源隔离的方式，我们将 3 个集群合并成 1 个集群，被合并的 6 个入口节点 FE 被释放掉，将节省的资源加到核心的运算节点上来。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;升级到 Doris 0.15 后，我们将 ODS 表的副本修改为&lt;/span&gt;&lt;code&gt;group_ods&lt;/code&gt;&lt;span&gt;3 &lt;/span&gt;&lt;span&gt;份，&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt;3 份。&lt;/span&gt;&lt;span&gt;Flink 写入时只写&lt;/span&gt;&lt;code&gt;group_ods&lt;/code&gt;&lt;span&gt; 资源组的节点，数据写入后，得益于 D&lt;/span&gt;&lt;span&gt;oris 内部的副本同步机制，数据会自动实时同步到&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt; 资源组。&lt;/span&gt;&lt;span&gt;ETL 则可以使用&lt;/span&gt;&lt;code&gt;default&lt;/code&gt;&lt;span&gt;资源组的节点资源取用 ODS 数据，进行查询和数据处理。&lt;/span&gt;&lt;span&gt;同理 ADS 也做了相同处理，原先需要通过外表进行数据抽取同步的表，均被做成了副本跨资源组的形式。&lt;/span&gt;&lt;span&gt;此方式有效缩短了跨集群数据同步的 ETL 时长 。&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;720&quot; data-ratio=&quot;0.7272727272727273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBia7HnQTypwvLx90SuDUOAGvC7jnPH0BdVqUdNwtsGr2N148c1JcXr7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot; data-width=&quot;990&quot;/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;离线 ETL 内存高&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们使用的是离线 ETL 方式直接在 Doris 上做 ETL 操作，在 Join 时，如果右表数据量比较大的情况下会消耗大量的内存，从而造成 OOM。在 1.0 版本之前内存跟踪能力较弱，容易造成 BE 节点超出 Linux 限制，导致进程被关闭 ，这时候会收到以下报错信息：&lt;/span&gt;&lt;code&gt;Host is down&lt;/code&gt;&lt;span&gt; 或者&lt;/span&gt;&lt;code&gt;Fail to initialize storage reader&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在1.0 及更高版本中， Doris 由于优化了内存跟踪，则容易见到以下报错：&lt;/span&gt;&lt;span&gt;Memory exceed limit. Used: XXXX ,Limit XXXX.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对内存受限问题，我们开始寻找优化方案，另外由于公司内部资源受限，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;优化方案必须在不增加集群成本的情况下把超出集群负荷的任务跑通&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。这里为大家介绍 2 个解决方法：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 优化调整 Join 的方式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Doris 内部 Join 分为 4 种，其内存开销以及优先级如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;303&quot; data-ratio=&quot;0.23671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSZIPMgp5ELLpv6xWkzBS8aBhky46Fj1F7abF9mnKK4S3fJs4CXBqlT3871pnPqh3XBwqibX3LCcoBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图可知，Join 类型优先级从左往右依次变低，Shuffle 的优先级最低，排在 Broadcast 之后。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;值得注意的是&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;， Broadcast 内存开销非常大，它将右表广播到所有 BE 节点，这相当于每个 BE 节点会消耗一个右表的内存，这将造成很大的内存开销。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;针对 Broadcast 比较大的内存开销，我们通过 Hint 条件强制 Join 类型的方式，使 Join 语句跳过 Broadcast 到 Shuffle Join ，从而降低内存消耗&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; a &lt;span&gt;join&lt;/span&gt; [shuffle] b &lt;span&gt;on&lt;/span&gt; a.k1 = b.k1;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 数据分批处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们尝试将数据按照时间分批，每批涵盖某一个或某几个时间段的数据，分批进行 ETL，有效降低内存消耗，避免 OOM 。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分批须知：&lt;/strong&gt;需要将分批的标记列放在主键中，最大程度提升搜索数据的效率；注意分桶和分区的设置方式，保证每个分区的数据量都比较均衡，避免个别分区内存占用较高的问题。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;新架构收益&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;基于 Doris 的新数仓架构不再依赖 Hadoop 生态组件，运维简单，维护成本低。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;具有更高性能，使用更少的服务器资源，提供更强的数据处理能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持高并发，能直接支持 WebApp 的查询服务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持外表，可以很方便的进行数据&lt;/span&gt;&lt;span&gt;发布，将数据推送其他数据库中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持动态扩容，数据自动平衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多种联邦查询方式，支持 Hive、ES、MySQL 等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;得益于新架构的优异能力，我们所用集群从&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 18 台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 16C128G 减少到 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;12 台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 16C128G，集群资源较之前&lt;/span&gt;&lt;span&gt;&lt;strong&gt;节省了34%&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，大大降低了投入成本；并且运算性能得到大幅提升，在 Kudu 上&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 3 小时&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即可完成的 ETL 任务， Doris 只需要 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;1 小时&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;即可完成 。除此之外，高频更新的场景下，Kudu 内部数据碎片文件不能进行自动合并，表的性能会越来越差，需要定期重建；而 Doris 内部的 Compaction 机制可以有效避免此问题。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;社区寄语&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;首先，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 的使用成本很低&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，仅需要 3 台低配服务器、甚至是台式机，就能相对容易的部署一套基于 Doris 的数仓作为数据中台基础；我认为对于想要进行数字化，但介于资源投入有限而又不想落后于市场的企业来说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;非常建议尝试使用 Apache Doris ，Doris 可以助力企业低成本跑通整个数据中台&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其次，Doris 是一款国人自研的的 MPP 架构分析型数据库，这令我感到很自豪，同时其社区十分活跃、便于沟通，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Doris 背后的商业化公司 SelectDB 为社区组建了一支专职技术团队，任何问题都能在 1 小时内得到响应，近 1 年社区更是在 SelectDB 的持续推动下，推出了一系列十分抗打的新特性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。另外社区在版本迭代时会认真考虑中国人的使用习惯，这些会为我们的使用带来很多便利。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，感谢 Doris 社区和 SelectDB 团队的全力支持，也欢迎开发者以及各企业多多了解 Doris、使用 Doris，支持国产数据！&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;Doris 1.2.0 传送门&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache Doris 于 2022 年 12 月 7 日迎来 1.2.0 Release 版本的正式发布！新版本中实&lt;/span&gt;&lt;span&gt;&lt;strong&gt;现了全面的向量化&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;、实现多场景查询性能 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;3-11 倍的提升&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，在 Unique Key 模型上实现了 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Merge-on-Write &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的数据更新模式、数据高频更新时查询性能&lt;/span&gt;&lt;span&gt;&lt;strong&gt;提升达 3-6 倍&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，增加了 Multi-Catalog 多源数据目录&lt;/span&gt;&lt;span&gt;&lt;strong&gt;、提供了无缝接入 Hive、ES、Hudi、Iceberg 等外部数据源的能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，引入了&lt;/span&gt;&lt;span&gt;&lt;strong&gt; Light Schema Change &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;轻量表结构变更、实现毫秒级的 Schema Change 操作并可以借助 Flink CDC &lt;/span&gt;&lt;span&gt;&lt;strong&gt;自动同步上游数据库的 DML 和 DDL 操作&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，以 JDBC 外部表替换了过去的 ODBC 外部表，支持了 Java UDF 和 Romote UDF 以及 Array 数组类型和 JSONB 类型，修复了诸多之前版本的性能和稳定性问题，推荐大家下载和使用！&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;下载安装：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（复制到浏览器打开）&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;GitHub下载：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/apache/doris/releases&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官网下载页：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://doris.apache.org/download&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;源码地址：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/apache/doris/releases/tag/1.2.0-rc04&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;— &lt;/span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;span&gt; —&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;p&gt;&lt;span&gt;最后，欢迎更多的开源技术爱好者加入 Apache Doris 社区，携手成长，共建社区生态。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Apache Doris 社区当前已容纳了上万名开发者和使用者，承载了 30+ 交流社群&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，如果你也是 Apache Doris 的爱好者，扫码加入 Apache Doris 社区用户交流群，在这里你可以获得：&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;专业全职团队技术支持&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;直接和社区专家交流，获取免费且专业回复&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;认识不同行业的开发者，收获知识以及合作机会&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Apache Doris 最新版本优先体验权&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取一手干货和资讯以及活动优先参与权&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Uecg6b8kbSZL3g8IxEf9VAjtemticsF1WyBwBN6z3icVk0MMQdU0zd2pHs7Q3essrpUiaibaCRnicapRxZYXfEP33gA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-docs-delta=&quot;[[20,{&amp;quot;gallery&amp;quot;:&amp;quot;https://uploader.shimo.im/f/s3aWTKah9u80nENw.png!thumbnail&amp;quot;},&amp;quot;29:0|30:0|3:\&amp;quot;281px\&amp;quot;|4:\&amp;quot;281px\&amp;quot;|crop:\&amp;quot;\&amp;quot;|frame:\&amp;quot;none\&amp;quot;|ori-height:\&amp;quot;700\&amp;quot;|ori-width:\&amp;quot;700\&amp;quot;&amp;quot;]]&quot; data-copy-origin=&quot;https://shimo.im&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.0027322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSYap6EMzpzneBwO7zZ5Ub2EX6IBBXldWaI0L3XmHO9kvcJwdWHJBI8LX7Ndr0OfOxMT61bjpVlD3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;大家都在看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;strong&gt;&lt;sup&gt;&lt;span&gt;✦&lt;/span&gt;&lt;/sup&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247512119&amp;amp;idx=1&amp;amp;sn=289a2e465f9692e0fbe80055bba2dd14&amp;amp;chksm=cf2fbe30f8583726c879069cf2a0a9e544b5c539f9a2d7a5adaaaa9ada44b52d9035b900d5ab&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;全面进化！Apache Doris 1.2.0 Release 版本正式发布｜版本通告&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;全面进化！Apache Doris 1.2.0 Release 版本正式发布&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247509133&amp;amp;idx=1&amp;amp;sn=a1c5a66404c0ceb0cd3015a4f2e13b9a&amp;amp;chksm=cf2faa8af858239c761a46e4f729191cce45cd8cd0e5e1dfd78e8a7263f32661814c590306af&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DDL 毫秒级同步，Light Schema Change 的设计与实现｜新版本揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;DDL 毫秒级同步，Light Schema Change 的设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;▶&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3Njc2NDAwOA==&amp;amp;mid=2247512201&amp;amp;idx=1&amp;amp;sn=13e743781165eb3b28cef0a98aa09902&amp;amp;chksm=cf2fbe8ef858379879dcb3769285759c74515b6a7d069cea8e445c5200e053e4da44e8ff4b17&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;10x 查询性能提升，全新 Unique Key 的设计与实现｜新特性解读&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;10x 查询性能提升，全新 Unique Key 的设计与实现&lt;/a&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.425&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Uecg6b8kbSalrjO7TiclL5OVBFxomNGLsiaZbfGlmh1zVQbNvzGHR2Bspb5rqZ52m9dhCVO3bY9p2dia1owD3595Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;▼   点击阅读原文，给 Doris 点个赞吧！&lt;/span&gt;&lt;/h4&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d973719e0005ac1e3c6ca792f334f30</guid>
<title>有趣的 Go HttpClient 超时机制</title>
<link>https://toutiao.io/k/l30t274</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是既写 Java 又写 Go 的小楼，在写 Go 的过程中我经常对比这两种语言的特性，踩了不少坑，也发现了不少有意思的地方，今天就来聊聊 Go 自带的 HttpClient 的超时机制。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java HttpClient 超时底层原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍 Go 的 HttpClient 超时机制之前，我们先看看 Java 是如何实现超时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写一个 Java 原生的 HttpClient，设置连接超时、读取超时时间分别对应到底层的方法分别是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4959871589085072&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTU3nYSO6mYGKgvR6iaUriaiblDicHrFt5iaiaKEzj5OwzlO7e4SiceiaZq83mVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再追溯到 JVM 源码，发现是对系统调用的封装，其实不光是 Java，大部分的编程语言都借助了操作系统提供的超时能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而 Go 的 HttpClient 却提供了另一种超时机制，挺有意思，我们来盘一盘。但在开始之前，我们先了解一下 Go 的 Context。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go Context 简介&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 Go 源码的注释：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;// A Context carries a deadline, a cancellation signal, and other values across
// API boundaries.
// Context&#x27;s methods may be called by multiple goroutines simultaneously.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 简单来说是一个可以携带超时时间、取消信号和其他数据的接口，Context 的方法会被多个协程同时调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 有点类似 Java 的ThreadLocal，可以在线程中传递数据，但又不完全相同，它是显示传递，ThreadLocal 是隐式传递，除了传递数据之外，Context 还能携带超时时间、取消信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Context 只是定义了接口，具体的实现在 Go 中提供了几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Background ：空的实现，啥也没做&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TODO：还不知道用什么 Context，先用 TODO 代替，也是啥也没做的空 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cancelCtx：可以取消的 Context&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;timerCtx：主动超时的 Context&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 Context 的三个特性，可以通过 Go 提供的 Context 实现以及源码中的例子来进一步了解下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Context 三个特性例子&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的例子来源于 Go 的源码，位于 &lt;code&gt;src/context/example_test.go&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;携带数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;context.WithValue&lt;/code&gt; 来携带，使用  &lt;code&gt;Value&lt;/code&gt; 来取值，源码中的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; favContextKey &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; f := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, k favContextKey)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; v := ctx.Value(k); v != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   fmt.Println(&lt;span&gt;&quot;found value:&quot;&lt;/span&gt;, v)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;key not found:&quot;&lt;/span&gt;, k)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; k := favContextKey(&lt;span&gt;&quot;language&quot;&lt;/span&gt;)&lt;br/&gt; ctx := context.WithValue(context.Background(), k, &lt;span&gt;&quot;Go&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; f(ctx, k)&lt;br/&gt; f(ctx, favContextKey(&lt;span&gt;&quot;color&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// found value: Go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// key not found: color&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先起一个协程执行一个死循环，不停地往 channel 中写数据，同时监听 &lt;code&gt;ctx.Done()&lt;/code&gt; 的事件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;gen := &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  dst := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;  n := &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;// returning not to leak the goroutine&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; dst &amp;lt;- n:&lt;br/&gt;     n++&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; dst&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过 &lt;code&gt;context.WithCancel&lt;/code&gt; 生成一个可取消的 Context，传入 &lt;code&gt;gen&lt;/code&gt; 方法，直到 &lt;code&gt;gen&lt;/code&gt; 返回 5 时，调用 &lt;code&gt;cancel&lt;/code&gt; 取消 &lt;code&gt;gen&lt;/code&gt; 方法的执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;ctx, cancel := context.WithCancel(context.Background())&lt;br/&gt;&lt;span&gt;defer&lt;/span&gt; cancel() &lt;span&gt;// cancel when we are finished consuming integers&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;range&lt;/span&gt; gen(ctx) {&lt;br/&gt; fmt.Println(n)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; n == &lt;span&gt;5&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么看起来，可以简单理解为在一个协程的循环中埋入结束标志，另一个协程去设置这个结束标志。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 cancel 的铺垫，超时就好理解了，cancel 是手动取消，超时是自动取消，只要起一个定时的协程，到时间后执行 cancel 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置超时时间有2种方式：&lt;code&gt;context.WithTimeout&lt;/code&gt; 与 &lt;code&gt;context.WithDeadline&lt;/code&gt;，WithTimeout 是设置一段时间后，WithDeadline 是设置一个截止时间点，WithTimeout 最终也会转换为 WithDeadline。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/context/example_test.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ExampleWithTimeout&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Pass a context with a timeout to tell a blocking function that it&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// should abandon its work after the timeout elapses.&lt;/span&gt;&lt;br/&gt; ctx, cancel := context.WithTimeout(context.Background(), shortDuration)&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancel()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-time.After(&lt;span&gt;1&lt;/span&gt; * time.Second):&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;overslept&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  fmt.Println(ctx.Err()) &lt;span&gt;// prints &quot;context deadline exceeded&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Output:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// context deadline exceeded&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go HttpClient 的另一种超时机制&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Context 可以设置任意代码段执行的超时机制，就可以设计一种脱离操作系统能力的请求超时能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 Go 的 HttpClient 超时配置说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Second,&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt; &lt;span&gt;type&lt;/span&gt; Client &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// ... 省略其他字段&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Timeout specifies a time limit for requests made by this&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Client. The timeout includes connection time, any&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// redirects, and reading the response body. The timer remains&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// running after Get, Head, Post, or Do return and will&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// interrupt reading of the Response.Body.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// A Timeout of zero means no timeout.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The Client cancels requests to the underlying Transport&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// as if the Request&#x27;s Context ended.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// For compatibility, the Client will also use the deprecated&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// CancelRequest method on Transport if found. New&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// RoundTripper implementations should use the Request&#x27;s Context&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// for cancellation instead of implementing CancelRequest.&lt;/span&gt;&lt;br/&gt; Timeout time.Duration&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻译一下注释：&lt;code&gt;Timeout&lt;/code&gt; 包括了连接、redirect、读取数据的时间，定时器会在 Timeout 时间后打断数据的读取，设为0则没有超时限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说这个超时是一个请求的&lt;strong&gt;总体超时时间&lt;/strong&gt;，而不必再分别去设置连接超时、读取超时等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于使用者来说可能是一个更好的选择，大部分场景，使用者不必关心到底是哪部分导致的超时，而只是想这个 HTTP 请求整体什么时候能返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制底层原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个最简单的例子来阐述超时机制的底层原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我起了一个本地服务，用 Go HttpClient 去请求，超时时间设置为 10 分钟，建议使 Debug 时设置长一点，否则可能超时导致无法走完全流程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; client := http.Client{&lt;br/&gt;  Timeout: &lt;span&gt;10&lt;/span&gt; * time.Minute,&lt;br/&gt; }&lt;br/&gt; resp, err := client.Get(&lt;span&gt;&quot;http://127.0.0.1:81/hello&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 根据 timeout 计算出超时的时间点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;deadline = c.deadline()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 设置请求的 cancel&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;stopTimer, didTimeout := setRequestCancel(req, rt, deadline)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里返回的 stopTimer 就是可以手动 cancel 的方法，didTimeout 是判断是否超时的方法。这两个可以理解为回调方法，调用 stopTimer() 可以手动 cancel，调用 didTimeout() 可以返回是否超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置的主要代码其实就是将请求的 Context 替换为 cancelCtx，后续所有的操作都将携带这个 cancelCtx：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; cancelCtx &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; oldCtx := req.Context(); timeBeforeContextDeadline(deadline, oldCtx) {&lt;br/&gt; req.ctx, cancelCtx = context.WithDeadline(oldCtx, deadline)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，再起一个定时器，当超时时间到了之后，将 timedOut 设置为 true，再调用 doCancel()，doCancel() 是调用真正 RoundTripper （代表一个 HTTP 请求事务）的 CancelRequest，也就是取消请求，这个跟实现有关。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 来自 src/net/http/client.go&lt;/span&gt;&lt;br/&gt;timer := time.NewTimer(time.Until(deadline))&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timedOut atomicBool&lt;br/&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-initialReqCancel:&lt;br/&gt;  doCancel()&lt;br/&gt;  timer.Stop()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-timer.C:&lt;br/&gt;  timedOut.setTrue()&lt;br/&gt;  doCancel()&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-stopTimerCh:&lt;br/&gt;  timer.Stop()&lt;br/&gt; }&lt;br/&gt;}()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 默认 RoundTripper CancelRequest 实现是关闭这个连接&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest cancels an in-flight request by closing its connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// CancelRequest should only be called after RoundTrip has returned.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(t *Transport)&lt;/span&gt; &lt;span&gt;CancelRequest&lt;/span&gt;&lt;span&gt;(req *Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; t.cancelRequest(cancelKey{req}, errRequestCanceled)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 获取连接&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;br/&gt;  req.closeBody()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, ctx.Err()&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; pconn, err := t.getConn(treq, cm)&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码的开头监听 ctx.Done，如果超时则直接返回，使用 for 循环主要是为了请求的重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续的 getConn 是阻塞的，代码比较长，挑重点说，先看看有没有空闲连接，如果有则直接返回&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for idle connection.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; delivered := t.queueForIdleConn(w); delivered {&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; pc, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有空闲连接，起个协程去异步建立，建立成功再通知主协程&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Queue for permission to dial.&lt;/span&gt;&lt;br/&gt;t.queueForDial(w)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着是一个 select 等待连接建立成功、超时或者主动取消，这就实现了在连接过程中的超时&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait for completion or cancellation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-w.ready:&lt;br/&gt; &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; w.pc, w.err&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Cancel:&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, errRequestCanceledConn&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; &amp;lt;-req.Context().Done():&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, req.Context().Err()&lt;br/&gt;&lt;span&gt;case&lt;/span&gt; err := &amp;lt;-cancelc:&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err == errRequestCanceled {&lt;br/&gt;  err = errRequestCanceledConn&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 读写数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一条连接建立的时候，每个链接还偷偷起了两个协程，一个负责往连接中写入数据，另一个负责读数据，他们都监听了相应的 channel。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.readLoop()&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; pconn.writeLoop()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 wirteLoop 监听来自主协程的数据，并往连接中写入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 位于 src/net/http/transport.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(pc *persistConn)&lt;/span&gt; &lt;span&gt;writeLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; &lt;span&gt;close&lt;/span&gt;(pc.writeLoopDone)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; wr := &amp;lt;-pc.writech:&lt;br/&gt;   startBytesWritten := pc.nwrite&lt;br/&gt;   err := wr.req.Request.write(pc.bw, pc.isProxy, wr.req.extra, pc.waitForContinue(wr.continueCh))&lt;br/&gt;   &lt;span&gt;// ... &lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    pc.&lt;span&gt;close&lt;/span&gt;(err)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &amp;lt;-pc.closech:&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，readLoop 读取响应数据，并写回主协程。读与写的过程中如果超时了，连接将被关闭，报错退出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;超时机制小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的这种请求超时机制，可随时终止请求，可设置整个请求的超时时间。其实现主要依赖协程、channel、select 机制的配合。总结出套路是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主协程生成 cancelCtx，传递给子协程，主协程与子协程之间用 channel 通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主协程 select channel 和 cancelCtx.Done，子协程完成或取消则 return&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;循环任务：子协程起一个循环处理，每次循环开始都 select cancelCtx.Done，如果完成或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;阻塞任务：子协程 select 阻塞任务与 cancelCtx.Done，阻塞任务处理完或取消则退出&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;以循环任务为例&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1331747919143875&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0S4J5l00Jh0SzC1tk2AmuxTzoeScE46RINHUASNk1EKNfbucMYT7752Ogyk26kHicEXLuKtVkHibgbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java 能实现这种超时机制吗&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接说结论：暂时不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先 Java 的线程太重，像 Go 这样一次请求开了这么多协程，换成线程性能会大打折扣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次 Go 的 channel 虽然和 Java 的阻塞队列类似，但 Go 的 select 是多路复用机制，Java 暂时无法实现，即无法监听多个队列是否有数据到达。所以综合来看 Java 暂时无法实现类似机制。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了 Go 另类且有趣的 HTTP 超时机制，并且分析了底层实现原理，归纳出了这种机制的套路，如果我们写 Go 代码，也可以如此模仿，让代码更 Go。&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>338996dae56993f1a1d98a7000e94c18</guid>
<title>一文弄懂 React ref 原理</title>
<link>https://toutiao.io/k/43sfdbp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Ref 理解与使用，一些读者可能还停留在用 ref 获取真实 DOM 元素和获取类组件实例层面上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 ref 除了这两项常用功能之外，还有很多别的小技巧&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过本篇文章的学习，你将收获 React ref 的基本和进阶用法，并且能够明白 React 内部是如何处理 ref 的，并通过一个小 Demo + 提问的方式带你更加深刻地理解 ref 的底层原理&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. ref 的理解与使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 Ref 的理解，要从两个角度去分析：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Ref 对象的创建：使用 &lt;code&gt;createRef&lt;/code&gt; 或 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 本身对 Ref 的处理：对于标签中的 ref 属性，React 是如何处理的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1. ref 对象的创建&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1.1. createRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在类组件中，我们会通过 &lt;code&gt;createRef&lt;/code&gt; 去创建一个 Ref 对象，其会被保存在类组件实例上，它的实现很简单&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react/src/ReactCreateRef.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createRef&lt;/span&gt;(): &lt;span&gt;RefObject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; refObject = {&lt;br/&gt;    &lt;span&gt;current&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; refObject&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，就是创建了一个包含 &lt;code&gt;current&lt;/code&gt; 属性的对象，仅此而已&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1.2. useRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着我们不能在函数组件中使用 &lt;code&gt;createRef&lt;/code&gt;，因为每次函数组件渲染都是一次新的函数执行，每次执行 &lt;code&gt;createRef&lt;/code&gt; 得到的都是一个新的对象，无法保留其原来的引用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在函数组件中，我们会使用 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象，React 会将 useRef 和函数组件对应的 fiber 对象关联，将 &lt;code&gt;useRef&lt;/code&gt; 创建的 ref 对象挂载到对应的 fiber 对象上&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来每次函数组件执行，只要函数组件不被销毁，那么对应的 fiber 对象实例也会一直存在，所以 ref 也能够被保留下来&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2. React 对标签中 ref 属性的处理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先要明确一个结论，在 React 中获取 DOM 元素或者组件实例并不是只能通过 ref 对象获取！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说并不是只能通过先调用 &lt;code&gt;createRef&lt;/code&gt; 创建 ref 对象，然后将它赋值到要获取的元素或组件实例的 ref 属性上，实际上还有别的方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::tip&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有类组件才有获取组件实例这一说法，函数组件没有实例，不能被 ref 标记，但是可以通过 &lt;code&gt;forwardRef&lt;/code&gt; 结合 &lt;code&gt;useImperativeHandle&lt;/code&gt; 给函数组件赋予 ref 标记的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.1. string ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们给元素或类组件标签中的 ref 属性传递字符串时，能够在组件实例的 &lt;code&gt;this.refs&lt;/code&gt; 中访问到&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class Child extends React.Component&amp;lt;PropsWithChildren&amp;gt; {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { children } = this.props&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;Child&amp;lt;/p&amp;gt;&lt;br/&gt;        {children}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/** @description ref 属性传递字符串 */&lt;br/&gt;class RefDemo1 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo1&#x27;)&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refs)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref=&quot;refDemo1DOM&quot;&amp;gt;ref 属性传递字符串获取 DOM 元素&amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;Child ref=&quot;refDemo1Component&quot;&amp;gt;ref 属性传递字符串获取类组件实例&amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1775244299674267&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6BLqstJPR3RVglgaDBQCTmfF02ExzRbtpdtkQEHsHq2GmL2L7iaZiagyQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;614&quot;/&gt;&lt;figcaption&gt;ref属性传递字符串&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::warning&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式已经被 React 官方废弃，尽量不要使用&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.2. callback ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ref 属性传递函数时，会在 commit 阶段创建真实 DOM 时执行 ref 指定的函数，并将元素作为第一个参数传入，此时我们就可以利用它进行赋值以获取 DOM 元素或组件实例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description ref 属性传递函数 */&lt;br/&gt;class RefDemo2 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo2&#x27;)&lt;br/&gt;&lt;br/&gt;  refDemo2DOM: HTMLElement | null = null&lt;br/&gt;  refDemo2Component: Child | null = null&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refDemo2DOM)&lt;br/&gt;    this.logger.log(this.refDemo2Component)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref={(el) =&amp;gt; (this.refDemo2DOM = el)}&amp;gt;&lt;br/&gt;          ref 属性传递函数获取 DOM 元素&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;Child ref={(child) =&amp;gt; (this.refDemo2Component = child)}&amp;gt;&lt;br/&gt;          ref 属性传递函数获取类组件实例&lt;br/&gt;        &amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1772357723577236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6oOFzckUwtLOp8dharIicEcibuQZW6KPnAkgfOASX5iaPcboTqFjVdlbFw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;615&quot;/&gt;&lt;figcaption&gt;ref属性传递函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2.3. object ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式就是我们最常用的方式了，使用 &lt;code&gt;createRef&lt;/code&gt; 或者 &lt;code&gt;useRef&lt;/code&gt; 创建 Ref 对象，并将其传给标签的 ref 属性即可&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式获取到的 ref 需要先调用 &lt;code&gt;current&lt;/code&gt; 属性才能获取到对应的 DOM 元素或组件实例&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description ref 属性传递对象 */&lt;br/&gt;class RefDemo3 extends React.Component {&lt;br/&gt;  logger = createLoggerWithScope(&#x27;RefDemo3&#x27;)&lt;br/&gt;&lt;br/&gt;  refDemo3DOM = React.createRef&amp;lt;HTMLDivElement&amp;gt;()&lt;br/&gt;  refDemo3Component = React.createRef&amp;lt;Child&amp;gt;()&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    this.logger.log(this.refDemo3DOM)&lt;br/&gt;    this.logger.log(this.refDemo3Component)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;div ref={this.refDemo3DOM}&amp;gt;ref 属性传递对象获取 DOM 元素&amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;Child ref={this.refDemo3Component}&amp;gt;&lt;br/&gt;          ref 属性传递对象获取类组件实例&lt;br/&gt;        &amp;lt;/Child&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. ref 高阶用法&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1. forwardRef 转发 ref&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.1. 跨层级获取&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要在爷组件中通过在子组件中传递 ref 获取到孙组件的某个元素，也就是在爷组件中获取到了孙组件的元素，是一种跨层级获取&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description 孙组件 */&lt;br/&gt;const Child: React.FC&amp;lt;{ grandRef: LegacyRef&amp;lt;HTMLDivElement&amp;gt; }&amp;gt; = (props) =&amp;gt; {&lt;br/&gt;  const { grandRef } = props&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;Child&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div ref={grandRef}&amp;gt;要获取的目标元素&amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * @description 父组件&lt;br/&gt; *&lt;br/&gt; * 第一个泛型参数是 ref 的类型&lt;br/&gt; * 第二个泛型参数是 props 的类型&lt;br/&gt; */&lt;br/&gt;const Father = forwardRef&amp;lt;HTMLDivElement, {}&amp;gt;((props, ref) =&amp;gt; {&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;Child grandRef={ref} /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;/** @description 爷组件 */&lt;br/&gt;const GrandFather: React.FC = () =&amp;gt; {&lt;br/&gt;  let grandChildDiv: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(grandChildDiv)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div&amp;gt;&lt;br/&gt;      &amp;lt;Father ref={(el) =&amp;gt; (grandChildDiv = el)} /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.2. 合并转发自定义 ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;forwardRef 不仅可以转发 ref 获取 DOM 元素和组件实例，还可以转发合并后的自定义 ref&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是“合并后的自定义 ref”呢？通过一个场景来看看就明白了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::info{title=场景}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过给 Foo 组件绑定 ref，获取多个内容，包括：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;子组件 Bar 的组件实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bar 组件中的 DOM 元素 button&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;孙组件 Baz 的组件实例&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种在一个 ref 里能够访问多个元素和实例的就是“合并后的自定义 ref”&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description 自定义 ref 的类型 */&lt;br/&gt;interface CustomRef {&lt;br/&gt;  bar: Bar&lt;br/&gt;  barButton: HTMLButtonElement&lt;br/&gt;  baz: Baz&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class Baz extends React.Component {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return &amp;lt;div&amp;gt;Baz&amp;lt;/div&amp;gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class Bar extends React.Component&amp;lt;{&lt;br/&gt;  customRef: ForwardedRef&amp;lt;CustomRef&amp;gt;&lt;br/&gt;}&amp;gt; {&lt;br/&gt;  buttonEl: HTMLButtonElement | null = null&lt;br/&gt;  bazInstance: Baz | null = null&lt;br/&gt;&lt;br/&gt;  componentDidMount(): void {&lt;br/&gt;    const { customRef } = this.props&lt;br/&gt;&lt;br/&gt;    if (customRef) {&lt;br/&gt;      ;(customRef as MutableRefObject&amp;lt;CustomRef&amp;gt;).current = {&lt;br/&gt;        bar: this,&lt;br/&gt;        barButton: this.buttonEl!,&lt;br/&gt;        baz: this.bazInstance!,&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render() {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;&amp;gt;&lt;br/&gt;        &amp;lt;button ref={(el) =&amp;gt; (this.buttonEl = el)}&amp;gt;Bar button&amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;Baz ref={(instance) =&amp;gt; (this.bazInstance = instance)} /&amp;gt;&lt;br/&gt;      &amp;lt;/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;const FowardRefBar = forwardRef&amp;lt;CustomRef&amp;gt;((props, ref) =&amp;gt; (&lt;br/&gt;  &amp;lt;Bar {...props} customRef={ref} /&amp;gt;&lt;br/&gt;))&lt;br/&gt;&lt;br/&gt;const Foo: React.FC = () =&amp;gt; {&lt;br/&gt;  const customRef = useRef&amp;lt;CustomRef&amp;gt;(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(customRef.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;FowardRefBar ref={customRef} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20593080724876442&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6KQ4OoZAp3JibXtGicWV8yhz65UNnkTovRQflcfqOgicClz7fgwP1mqNUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;607&quot;/&gt;&lt;figcaption&gt;合并转发自定义ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.3. 高阶组件转发 ref&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在高阶组件中直接使用 ref，它会直接指向 WrapComponent&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;class TestComponent extends React.Component {&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return &amp;lt;p&amp;gt;TestComponent&amp;lt;/p&amp;gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/** @description 不使用 forwardRef 转发 HOC 中的 ref */&lt;br/&gt;const HOCWithoutForwardRef = (Component: typeof React.Component) =&amp;gt; {&lt;br/&gt;  class WrapComponent extends React.Component {&lt;br/&gt;    render(): React.ReactNode {&lt;br/&gt;      return (&lt;br/&gt;        &amp;lt;div&amp;gt;&lt;br/&gt;          &amp;lt;p&amp;gt;WrapComponent&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;Component /&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      )&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  return WrapComponent&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const HOCComponent1 = HOCWithoutForwardRef(TestComponent)&lt;br/&gt;const RefHOCWithoutForwardRefDemo = () =&amp;gt; {&lt;br/&gt;  const logger = createLoggerWithScope(&#x27;RefHOCWithoutForwardRefDemo&#x27;)&lt;br/&gt;  const wrapRef = useRef(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    // wrapRef 指向的是 WrapComponent 实例 而不是 HOCComponent1 实例&lt;br/&gt;    logger.log(wrapRef.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;HOCComponent1 ref={wrapRef} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4414715719063545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq646mMr5SBBmkGXvkr94EDPdkbItIO7EztOiavr86xwRsTjX3RDrOq4kA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;598&quot;/&gt;&lt;figcaption&gt;HOC中直接使用ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们希望 &lt;code&gt;ref&lt;/code&gt; 指向的是被包裹的 TestComponent 而不是 HOC 内部的 WrapComponent 时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候就可以用 forwardRef 进行转发了&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/** @description HOC 中使用 forwardRef 转发 ref */&lt;br/&gt;const HOCWithForwardRef = (Component: typeof React.Component) =&amp;gt; {&lt;br/&gt;  class WrapComponent extends React.Component&amp;lt;{&lt;br/&gt;    forwardedRef: LegacyRef&amp;lt;any&amp;gt;&lt;br/&gt;  }&amp;gt; {&lt;br/&gt;    render(): React.ReactNode {&lt;br/&gt;      const { forwardedRef } = this.props&lt;br/&gt;&lt;br/&gt;      return (&lt;br/&gt;        &amp;lt;div&amp;gt;&lt;br/&gt;          &amp;lt;p&amp;gt;WrapComponent&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;Component ref={forwardedRef} /&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      )&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  return React.forwardRef((props, ref) =&amp;gt; (&lt;br/&gt;    &amp;lt;WrapComponent forwardedRef={ref} {...props} /&amp;gt;&lt;br/&gt;  ))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const HOCComponent2 = HOCWithForwardRef(TestComponent)&lt;br/&gt;const RefHOCWithForwardRefDemo = () =&amp;gt; {&lt;br/&gt;  const logger = createLoggerWithScope(&#x27;RefHOCWithForwardRefDemo&#x27;)&lt;br/&gt;  const hocComponent2Ref = useRef(null)&lt;br/&gt;&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    // hocComponent2Ref 指向的是 HOCComponent2 实例&lt;br/&gt;    logger.log(hocComponent2Ref.current)&lt;br/&gt;  }, [])&lt;br/&gt;&lt;br/&gt;  return &amp;lt;HOCComponent2 ref={hocComponent2Ref} /&amp;gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42483660130718953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6hSVnEzJaQDxKsE4bCoic6Exwp99sDXJBegnlDCnonQ1Ykjic7icbgAOZw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;612&quot;/&gt;&lt;figcaption&gt;HOC中使用forwardRef转发ref&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2. ref 实现组件通信&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们可以通过父组件改变子组件 props 的方式触发子组件的更新渲染完成组件间通信&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们不希望通过这种改变子组件 props 的方式的话还能有别的办法吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 ref 获取子组件实例，然后子组件暴露出通信的方法，父组件调用该方法即可触发子组件的更新渲染&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于函数组件，由于其不存在组件实例这样的说法，但我们可以通过 &lt;code&gt;useImperativeHandle&lt;/code&gt; 这个 hook 来指定 ref 引用时得到的属性和方法，下面我们分别用类组件和函数组件都实现一遍&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.1. 类组件 ref 暴露组件实例&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;/**&lt;br/&gt; * 父 -&amp;gt; 子 使用 ref&lt;br/&gt; * 子 -&amp;gt; 父 使用 props 回调&lt;br/&gt; */&lt;br/&gt;class CommunicationDemoFather extends React.Component&amp;lt;&lt;br/&gt;  {},&lt;br/&gt;  CommunicationDemoFatherState&lt;br/&gt;&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;CommunicationDemoFatherState&amp;gt; = {&lt;br/&gt;    fatherToChildMessage: &#x27;&#x27;,&lt;br/&gt;    childToFatherMessage: &#x27;&#x27;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  childRef = React.createRef&amp;lt;CommunicationDemoChild&amp;gt;()&lt;br/&gt;&lt;br/&gt;  /** @description 提供给子组件修改父组件中的状态 */&lt;br/&gt;  handleChildToFather = (message: string) =&amp;gt; {&lt;br/&gt;    this.setState((state) =&amp;gt; ({&lt;br/&gt;      ...state,&lt;br/&gt;      childToFatherMessage: message,&lt;br/&gt;    }))&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  constructor(props: {}) {&lt;br/&gt;    super(props)&lt;br/&gt;    this.handleChildToFather = this.handleChildToFather.bind(this)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { fatherToChildMessage, childToFatherMessage } = this.state&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div className={s.father}&amp;gt;&lt;br/&gt;        &amp;lt;h3&amp;gt;父组件&amp;lt;/h3&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;子组件对我说：{childToFatherMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;        &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;          &amp;lt;section&amp;gt;&lt;br/&gt;            &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对子组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              type=&quot;text&quot;&lt;br/&gt;              id=&quot;to-child&quot;&lt;br/&gt;              onChange={(e) =&amp;gt;&lt;br/&gt;                this.setState((state) =&amp;gt; ({&lt;br/&gt;                  ...state,&lt;br/&gt;                  fatherToChildMessage: e.target.value,&lt;br/&gt;                }))&lt;br/&gt;              }&lt;br/&gt;            /&amp;gt;&lt;br/&gt;          &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;          {/* 父 -&amp;gt; 子 -- 使用 ref 完成组件通信 */}&lt;br/&gt;          &amp;lt;button&lt;br/&gt;            onClick={() =&amp;gt;&lt;br/&gt;              this.childRef.current?.setFatherToChildMessage(&lt;br/&gt;                fatherToChildMessage,&lt;br/&gt;              )&lt;br/&gt;            }&lt;br/&gt;          &amp;gt;&lt;br/&gt;            发送&lt;br/&gt;          &amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;        &amp;lt;CommunicationDemoChild&lt;br/&gt;          ref={this.childRef}&lt;br/&gt;          onChildToFather={this.handleChildToFather}&lt;br/&gt;        /&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;interface CommunicationDemoChildProps {&lt;br/&gt;  onChildToFather: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;// 子组件自己维护状态 不依赖于父组件 props&lt;br/&gt;interface CommunicationDemoChildState {&lt;br/&gt;  fatherToChildMessage: string&lt;br/&gt;  childToFatherMessage: string&lt;br/&gt;}&lt;br/&gt;class CommunicationDemoChild extends React.Component&amp;lt;&lt;br/&gt;  CommunicationDemoChildProps,&lt;br/&gt;  CommunicationDemoChildState&lt;br/&gt;&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;CommunicationDemoChildState&amp;gt; = {&lt;br/&gt;    fatherToChildMessage: &#x27;&#x27;,&lt;br/&gt;    childToFatherMessage: &#x27;&#x27;,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  /** @description 暴露给父组件使用的 API -- 修改父到子的消息 fatherToChildMessage */&lt;br/&gt;  setFatherToChildMessage(message: string) {&lt;br/&gt;    this.setState((state) =&amp;gt; ({ ...state, fatherToChildMessage: message }))&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    const { onChildToFather: emitChildToFather } = this.props&lt;br/&gt;    const { fatherToChildMessage, childToFatherMessage } = this.state&lt;br/&gt;&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div className={s.child}&amp;gt;&lt;br/&gt;        &amp;lt;h3&amp;gt;子组件&amp;lt;/h3&amp;gt;&lt;br/&gt;        &amp;lt;p&amp;gt;父组件对我说：{fatherToChildMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;        &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;          &amp;lt;section&amp;gt;&lt;br/&gt;            &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对父组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;            &amp;lt;input&lt;br/&gt;              type=&quot;text&quot;&lt;br/&gt;              id=&quot;to-father&quot;&lt;br/&gt;              onChange={(e) =&amp;gt;&lt;br/&gt;                this.setState((state) =&amp;gt; ({&lt;br/&gt;                  ...state,&lt;br/&gt;                  childToFatherMessage: e.target.value,&lt;br/&gt;                }))&lt;br/&gt;              }&lt;br/&gt;            /&amp;gt;&lt;br/&gt;          &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;          {/* 子 -&amp;gt; 父 -- 使用 props 回调完成组件通信 */}&lt;br/&gt;          &amp;lt;button onClick={() =&amp;gt; emitChildToFather(childToFatherMessage)}&amp;gt;&lt;br/&gt;            发送&lt;br/&gt;          &amp;lt;/button&amp;gt;&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5104408352668214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6JoWX6Ej0LqicqZrc1fQSxUq0Wibv8eTmbiadh0PCfUtt3SJM53O7Goichw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;862&quot;/&gt;&lt;figcaption&gt;使用ref完成类组件间通信&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.2. 函数组件 ref 暴露指定方法&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;useImperativeHandle&lt;/code&gt; hook 可以让我们指定 ref 引用时能获取到的属性和方法，个人认为相比类组件的 ref，使用这种方式能够更加好的控制组件想暴露给外界的 API&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而不像类组件那样直接全部暴露出去，当然，如果你想在类组件中只暴露部分 API 的话，可以用前面说的合并转发自定义 ref 的方式去完成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们就用 &lt;code&gt;useImperativeHandle&lt;/code&gt; hook 改造上面的类组件实现的 demo 吧&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface ChildRef {&lt;br/&gt;  setFatherToChildMessage: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 父 -&amp;gt; 子 使用 ref&lt;br/&gt; * 子 -&amp;gt; 父 使用 props 回调&lt;br/&gt; */&lt;br/&gt;const CommunicationDemoFunctionComponentFather: React.FC = () =&amp;gt; {&lt;br/&gt;  const [fatherToChildMessage, setFatherToChildMessage] = useState(&#x27;&#x27;)&lt;br/&gt;  const [childToFatherMessage, setChildToFatherMessage] = useState(&#x27;&#x27;)&lt;br/&gt;&lt;br/&gt;  const childRef = useRef&amp;lt;ChildRef&amp;gt;(null)&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.father}&amp;gt;&lt;br/&gt;      &amp;lt;h3&amp;gt;父组件&amp;lt;/h3&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;子组件对我说：{childToFatherMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;        &amp;lt;section&amp;gt;&lt;br/&gt;          &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对子组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;          &amp;lt;input&lt;br/&gt;            type=&quot;text&quot;&lt;br/&gt;            id=&quot;to-child&quot;&lt;br/&gt;            onChange={(e) =&amp;gt; setFatherToChildMessage(e.target.value)}&lt;br/&gt;          /&amp;gt;&lt;br/&gt;        &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;        {/* 父 -&amp;gt; 子 -- 使用 ref 完成组件通信 */}&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt;&lt;br/&gt;            childRef.current?.setFatherToChildMessage(fatherToChildMessage)&lt;br/&gt;          }&lt;br/&gt;        &amp;gt;&lt;br/&gt;          发送&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;      &amp;lt;CommunicationDemoFunctionComponentChild&lt;br/&gt;        ref={childRef}&lt;br/&gt;        onChildToFather={(message) =&amp;gt; setChildToFatherMessage(message)}&lt;br/&gt;      /&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;interface CommunicationDemoFunctionComponentChildProps {&lt;br/&gt;  onChildToFather: (message: string) =&amp;gt; void&lt;br/&gt;}&lt;br/&gt;const CommunicationDemoFunctionComponentChild = forwardRef&amp;lt;&lt;br/&gt;  ChildRef,&lt;br/&gt;  CommunicationDemoFunctionComponentChildProps&lt;br/&gt;&amp;gt;((props, ref) =&amp;gt; {&lt;br/&gt;  const { onChildToFather: emitChildToFather } = props&lt;br/&gt;&lt;br/&gt;  // 子组件自己维护状态 不依赖于父组件 props&lt;br/&gt;  const [fatherToChildMessage, setFatherToChildMessage] = useState(&#x27;&#x27;)&lt;br/&gt;  const [childToFatherMessage, setChildToFatherMessage] = useState(&#x27;&#x27;)&lt;br/&gt;&lt;br/&gt;  // 定义暴露给外界的 API&lt;br/&gt;  useImperativeHandle(ref, () =&amp;gt; ({ setFatherToChildMessage }))&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.child}&amp;gt;&lt;br/&gt;      &amp;lt;h3&amp;gt;子组件&amp;lt;/h3&amp;gt;&lt;br/&gt;      &amp;lt;p&amp;gt;父组件对我说：{fatherToChildMessage}&amp;lt;/p&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.messageInputBox}&amp;gt;&lt;br/&gt;        &amp;lt;section&amp;gt;&lt;br/&gt;          &amp;lt;label htmlFor=&quot;to-father&quot;&amp;gt;我对父组件说：&amp;lt;/label&amp;gt;&lt;br/&gt;          &amp;lt;input&lt;br/&gt;            type=&quot;text&quot;&lt;br/&gt;            id=&quot;to-father&quot;&lt;br/&gt;            onChange={(e) =&amp;gt; setChildToFatherMessage(e.target.value)}&lt;br/&gt;          /&amp;gt;&lt;br/&gt;        &amp;lt;/section&amp;gt;&lt;br/&gt;&lt;br/&gt;        {/* 子 -&amp;gt; 父 -- 使用 props 回调完成组件通信 */}&lt;br/&gt;        &amp;lt;button onClick={() =&amp;gt; emitChildToFather(childToFatherMessage)}&amp;gt;&lt;br/&gt;          发送&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3. 函数组件缓存数据&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在函数组件中如果数据更新后不希望视图改变，也就是说视图不依赖于这个数据，这个时候可以考虑用 &lt;code&gt;useRef&lt;/code&gt; 对这种数据进行缓存&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 &lt;code&gt;useRef&lt;/code&gt; 可以对数据进行缓存？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前说的 useRef 在函数组件中的作用原理吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 会将 useRef 和函数组件对应的 fiber 对象关联，将 useRef 创建的 ref 对象挂载到对应的 fiber 对象上，这样一来每次函数组件执行，只要函数组件不被销毁，那么对应的 fiber 对象实例也会一直存在，所以 ref 也能够被保留下来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用这个特性，我们可以将数据放到 &lt;code&gt;useRef&lt;/code&gt; 中，由于它在内存中一直都是同一块内存地址，所以无论如何变化都不会影响到视图的改变&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::warning{title=注意}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一定要看清前提，只适用于与视图无关的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;:::&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一个简单的 demo 来更清楚地体会下这个应用场景&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我有一个 &lt;code&gt;todoList&lt;/code&gt; 列表，视图上会把这个列表渲染出来，并且有一个数据 activeTodoItem 是控制当前选中的是哪个 todoItem&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 todoItem 会切换这个 activeTodoItem，但是并不需要在视图上作出任何变化，如果使用 &lt;code&gt;useState&lt;/code&gt; 去保存 activeTodoItem，那么当其变化时会导致函数组件重新执行，视图重新渲染，但在这个场景中我们并不希望更新视图&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对的，我们希望这个 activeTodoItem 数据被缓存起来，不会随着视图的重新渲染而导致其作为 &lt;code&gt;useState&lt;/code&gt; 的执行结果重新生成一遍，因此我们可以改成用 &lt;code&gt;useRef&lt;/code&gt; 实现，因为其在内存中一直都是同一块内存地址，这样就不会因为它的改变而更新视图了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，在 useEffect 中如果使用到了 useRef 的数据，也不需要将其声明到 deps 数组中，因为其内存地址不会变化，所以每次在 useEffect 中获取到的 ref 数据一定是最新的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface TodoItem {&lt;br/&gt;  id: number&lt;br/&gt;  name: string&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const todoList: TodoItem[] = [&lt;br/&gt;  {&lt;br/&gt;    id: 1,&lt;br/&gt;    name: &#x27;coding&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 2,&lt;br/&gt;    name: &#x27;eating&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 3,&lt;br/&gt;    name: &#x27;sleeping&#x27;,&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    id: 4,&lt;br/&gt;    name: &#x27;playing&#x27;,&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;br/&gt;const CacheDataWithRefDemo: React.FC = () =&amp;gt; {&lt;br/&gt;  const activeTodoItem = useRef(todoList[0])&lt;br/&gt;&lt;br/&gt;  // 模拟 componentDidUpdate -- 如果改变 activeTodoItem 后组件没重新渲染，说明视图可以不依赖于 activeTodoItem 数据&lt;br/&gt;  useEffect(() =&amp;gt; {&lt;br/&gt;    logger.log(&#x27;检测组件是否有更新&#x27;)&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  return (&lt;br/&gt;    &amp;lt;div className={s.container}&amp;gt;&lt;br/&gt;      &amp;lt;div className={s.list}&amp;gt;&lt;br/&gt;        {todoList.map((todoItem) =&amp;gt; (&lt;br/&gt;          &amp;lt;div&lt;br/&gt;            key={todoItem.id}&lt;br/&gt;            className={s.item}&lt;br/&gt;            onClick={() =&amp;gt; (activeTodoItem.current = todoItem)}&lt;br/&gt;          &amp;gt;&lt;br/&gt;            &amp;lt;p&amp;gt;{todoItem.name}&amp;lt;/p&amp;gt;&lt;br/&gt;          &amp;lt;/div&amp;gt;&lt;br/&gt;        ))}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;&lt;br/&gt;      &amp;lt;button onClick={() =&amp;gt; logger.log(activeTodoItem.current)}&amp;gt;&lt;br/&gt;        控制台输出最新的 activeTodoItem&lt;br/&gt;      &amp;lt;/button&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3648124191461837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6Hbv7y5fEbBHsaibDcnuLDGXyeN52icbIs4FmXRgWhBDNTzLXRsjRxcqg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1546&quot;/&gt;&lt;figcaption&gt;使用ref缓存函数组件数据&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 通过 callback ref 探究 ref 原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先先看一个关于 callback ref 的小 Demo 来引出我们后续的内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;interface RefDemo8State {&lt;br/&gt;  counter: number&lt;br/&gt;}&lt;br/&gt;class RefDemo8 extends React.Component&amp;lt;{}, RefDemo8State&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;RefDemo8State&amp;gt; = {&lt;br/&gt;    counter: 0,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  el: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;div&lt;br/&gt;          ref={(el) =&amp;gt; {&lt;br/&gt;            this.el = el&lt;br/&gt;            console.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;          }}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          ref element&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt; this.setState({ counter: this.state.counter + 1 })}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          add&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17685589519650655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6d3IP3wvfBExBtibUpu0lY0RwrRpoj1GLNibQHNjvNfeEEju9vEaAliaRQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;916&quot;/&gt;&lt;figcaption&gt;ref执行两次的现象&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会执行两次？为什么第一次 &lt;code&gt;this.el === null&lt;/code&gt;？为什么第二次又正常了？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1. ref 的底层原理&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得 React 底层是有 render 阶段和 commit 阶段的吗？关于 ref 的处理逻辑就在 commit 阶段进行的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React 底层有两个关于 ref 的处理函数 -- &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的 Demo 中 callback ref 执行了两次正是对应着这两次函数的调用，大致来讲可以理解为 &lt;strong&gt;&lt;code&gt;commitDetachRef&lt;/code&gt; 在 DOM 更新之前执行，&lt;code&gt;commitAttachRef&lt;/code&gt; 在 DOM 更新之后执行&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就不难理解为什么会有上面 Demo 中的现象了，但我们还是要结合源码来看看，加深自己的理解&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1. commitDetachRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在新版本的 React 源码中它改名为了 safelyDetachRef，但是核心逻辑没变，这里我将核心逻辑简化出来供大家阅读：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitDetachRef&lt;/span&gt;(&lt;span&gt;current: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// current 是已经调和完了的 fiber 对象&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentRef = current.ref&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (currentRef !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; currentRef === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// callback ref 和 string ref 执行时机&lt;/span&gt;&lt;br/&gt;      currentRef(&lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// object ref 处理时机&lt;/span&gt;&lt;br/&gt;      currentRef.current = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，就是从 fiber 中取出 ref，然后根据 callback ref、string ref、object ref 的情况进行处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且也能看到 &lt;code&gt;commitDetachRef&lt;/code&gt; 主要是将 ref 置为 null，这也就是为什么 &lt;code&gt;RefDemo8&lt;/code&gt; 中第一次执行的 callback ref 中看到的 this.el 是 null 了&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2. commitAttachRef&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心逻辑代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitAttachRef&lt;/span&gt;(&lt;span&gt;finishedWork: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = finishedWork.ref&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ref !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; instance = finishedWork.stateNode&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; instanceToUse&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理 ref 来源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; (finishedWork.tag) {&lt;br/&gt;      &lt;span&gt;// HostComponent 代表 DOM 元素类型的 tag&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;case&lt;/span&gt; HostComponent:&lt;br/&gt;        instanceToUse = getPublicInstance(instance)&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;// 类组件使用组件实例&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;        instanceToUse = instance&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ref === &lt;span&gt;&#x27;function&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// callback ref 和 string ref&lt;/span&gt;&lt;br/&gt;      ref(instanceToUse)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// object ref&lt;/span&gt;&lt;br/&gt;      ref.current = instanceToUse&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2. 为什么 string ref 也是以函数的方式调用？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的核心源码中能看到，对于 &lt;code&gt;callback ref&lt;/code&gt; 和 &lt;code&gt;string ref&lt;/code&gt;，都是统一以函数的方式调用，将 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;instanceToUse&lt;/code&gt; 传入&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;callback ref&lt;/code&gt; 这样做还能理解，但是为什么 &lt;code&gt;string ref&lt;/code&gt; 也是这样处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为当 React 检测到是 &lt;code&gt;string ref&lt;/code&gt; 时，会自动绑定一个函数用于处理 &lt;code&gt;string ref&lt;/code&gt;，核心源码逻辑如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactChildFiber.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 从元素上获取 ref&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; mixedRef = element.ref&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; stringRef = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + mixedRef&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; ref = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;value&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// resolvedInst 就是组件实例&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; refs = resolvedInst.refs&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (value === &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;delete&lt;/span&gt; refs[stringRef]&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    refs[stringRef] = value&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来 string ref 也变成了一个函数了，从而可以在 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 中被执行，并且也能印证为什么 &lt;code&gt;string ref&lt;/code&gt; 会在类组件实例的 &lt;code&gt;refs&lt;/code&gt; 属性中获取到&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3. ref 的执行时机&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么在 RefDemo8 中我们每次点击按钮时都会触发 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 呢？这就需要聊聊 ref 的执行时机了，而从上文也能够了解到，ref 底层实际上是由 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 在处理核心逻辑&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们就得来看看这两个函数的执行时机才能行&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1. commitDetachRef 执行时机&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitMutationEffectsOnFiber&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  finishedWork: Fiber,&lt;br/&gt;  root: FiberRoot,&lt;br/&gt;  lanes: Lanes,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; current = finishedWork.alternate&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; flags = finishedWork.flags&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; Ref) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (current !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 也就是 commitDetachRef&lt;/span&gt;&lt;br/&gt;      safelyDetachRef(current, current.return)&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2. commitAttachRef 执行时机&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberCommitWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitLayoutEffectOnFiber&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  finishedRoot: FiberRoot,&lt;br/&gt;  current: Fiber | null,&lt;br/&gt;  finishedWork: Fiber,&lt;br/&gt;  committedLanes: Lanes,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; flags = finishedWork.flags&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; Ref) {&lt;br/&gt;    safelyAttachRef(finishedWork, finishedWork.return)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.3. fiber 何时打上 Ref tag?&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，只有当 fiber 被打上了 &lt;code&gt;Ref&lt;/code&gt; 这个 flag tag 时才会去执行 &lt;code&gt;commitDetachRef&lt;/code&gt;/&lt;code&gt;commitAttachRef&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么时候会标记 Ref tag 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;packages/react-reconciler/src/ReactFiberBeginWork.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;markRef&lt;/span&gt;(&lt;span&gt;current: Fiber | null, workInProgress: Fiber&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ref = workInProgress.ref&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;// current === null 意味着是初次挂载，fiber 首次调和时会打上 Ref tag&lt;/span&gt;&lt;br/&gt;    (current === &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ref !== &lt;span&gt;null&lt;/span&gt;) ||&lt;br/&gt;    &lt;span&gt;// current !== null 意味着是更新，此时需要 ref 发生了变化才会打上 Ref tag&lt;/span&gt;&lt;br/&gt;    (current !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; current.ref !== ref)&lt;br/&gt;  ) {&lt;br/&gt;    &lt;span&gt;// Schedule a Ref effect&lt;/span&gt;&lt;br/&gt;    workInProgress.flags |= Ref&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.4. 为什么每次点击按钮 callback ref 都会执行？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么现在再回过头来思考 &lt;code&gt;RefDemo8&lt;/code&gt; 中为什么每次点击按钮都会执行 &lt;code&gt;commitDetachRef&lt;/code&gt; 和 &lt;code&gt;commitAttachRef&lt;/code&gt; 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们使用 &lt;code&gt;callback ref&lt;/code&gt; 的时候是如何使用的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;div&lt;br/&gt;  ref={(el) =&amp;gt; {&lt;br/&gt;    this.el = el&lt;br/&gt;    console.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;  }}&lt;br/&gt;&amp;gt;&lt;br/&gt;  ref element&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是直接声明了一个箭头函数，这样的方式会导致每次渲染这个 div 元素时，给 ref 赋值的都是一个新的箭头函数，尽管函数的内容是一样的，但内存地址不同，因而 &lt;code&gt;current.ref !== ref&lt;/code&gt; 这个判断条件会成立，从而每次都会触发更新&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.5. 如何解决？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么要如何解决这个问题呢？既然我们已经知道了问题的原因，那么就好说了，只要让每次赋值给 ref 的函数都是同一个就可以了呗~&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;const logger = createLoggerWithScope(&#x27;RefDemo9&#x27;)&lt;br/&gt;&lt;br/&gt;interface RefDemo9Props {}&lt;br/&gt;interface RefDemo9State {&lt;br/&gt;  counter: number&lt;br/&gt;}&lt;br/&gt;class RefDemo9 extends React.Component&amp;lt;RefDemo9Props, RefDemo9State&amp;gt; {&lt;br/&gt;  state: Readonly&amp;lt;RefDemo9State&amp;gt; = {&lt;br/&gt;    counter: 0,&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  el: HTMLDivElement | null = null&lt;br/&gt;&lt;br/&gt;  constructor(props: RefDemo9Props) {&lt;br/&gt;    super(props)&lt;br/&gt;    this.setElRef = this.setElRef.bind(this)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  setElRef(el: HTMLDivElement | null) {&lt;br/&gt;    this.el = el&lt;br/&gt;    logger.log(&#x27;this.el -- &#x27;, this.el)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  render(): React.ReactNode {&lt;br/&gt;    return (&lt;br/&gt;      &amp;lt;div&amp;gt;&lt;br/&gt;        &amp;lt;div ref={this.setElRef}&amp;gt;ref element&amp;lt;/div&amp;gt;&lt;br/&gt;        &amp;lt;button&lt;br/&gt;          onClick={() =&amp;gt; this.setState({ counter: this.state.counter + 1 })}&lt;br/&gt;        &amp;gt;&lt;br/&gt;          add&lt;br/&gt;        &amp;lt;/button&amp;gt;&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16304347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKk4wjeeicGNfibCz6Ue0ReXq6I6NVM5LKRLVHeREvHiaf8v6Ru3jMicVriaURSRgzHjAFMAkTjBnKOlFUg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;修复点击按钮后ref多次执行&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就完美解决啦，既修复了 bug，又搞懂了 ref 的底层原理，一举两得！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章我们学习到了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ref 的理解与使用，包括如何创建 ref 对象，以及除了 object ref 之外的 string ref 和 callback ref 的方式去使用 ref&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ref 的高阶用法，包括 forwardRef 转发 ref、ref 实现组件通信、利用 ref 在函数组件中缓存数据等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过一个简单的 callback ref 的 Demo 研究 ref 的底层原理，string ref 为何也是以函数的方式被调用，以及 ref 的执行时机&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>