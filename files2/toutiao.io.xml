<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>09656ad2193226ceb6618ab42a51dcb2</guid>
<title>Solidity 非权威开发指南（5）：合约升级</title>
<link>https://toutiao.io/k/trqwnd7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;markdown编辑器&quot; data-website=&quot;https://markdown.com.cn/editor&quot;&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;所有以太坊开发者都清楚以太坊世界的一条铁律：合约一旦发布就无法修改。因此，对于合约的发布基本上都采用一种慎之又慎的态度，期望在发布前可以做到尽善尽美，力争合约能正常运行一万年。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;可是，智者千虑必有失，合约发布百分百不出问题几乎是不可能任务。一些小问题或许还可以通过类似口头约定的方式让大家克服克服，但对于重大问题，恐怕就不得不重新发布新版了。于是乎，一系列连带更新也随之而来：合约调用方、封装合约的 SDK/API 方……搞不好还会牵涉到下一级的连带更新。比如，调用该合约的合约将地址硬编码到代码里且没有提供 setter 来改变该值……太麻烦啦！&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;鉴于此，可升级合约的呼声越来越高，同时也衍生了各类方案。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是可升级合约&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;“可升级”意味着可修改，这似乎与以太坊强调的 immutable 相矛盾。但让我们再深入思考一下“可升级”的内涵：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;合约地址不能变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合约状态不能丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合约的行为可变&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;编程经验丰富的老兵此时应该会拍大腿大声叫道：&lt;strong&gt;引入一个中间层就可以做到！&lt;/strong&gt; 的确如此，可升级合约技术方案的本质就是：proxy + implementation 的分离，见下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2857142857142857&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Kh4dSb0w5FXRLVJ5w6iathtd2kDwxUehoA4OplgaGe3ktaiaJhEoNSSMic7JhacibDZn8PnUJ6j3Nl17N4oqVLsgIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其中：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;proxy 作为调用方和实现方的中间人使“地址不变”成为可能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 implementation 的状态保存于 proxy 中使“状态不丢失”成为可能，这一点只需在 proxy 中使用 &lt;code&gt;fallback&lt;/code&gt; + &lt;code&gt;delegatecall&lt;/code&gt; 将调用转发给 implementation 即可实现。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可动态注入不同的 implementation 使得“行为可变”成为可能。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;可参见本系列的第二篇快速了解 solidity 语法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;How-To&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;使用 OpenZepplin Upgrade Plugin 可以让编写可升级合约的事情变得简单，并且考虑到 OpenZepplin 已成为合约开发中事实上的标准库以及编写可升级合约的种种限制，建议无脑采用，最简例子见下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContract is Initializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function initialize(uint256 _x) public initializer {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        x = _x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// SPDX-License-Identifier: UNLICENSED&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;./MyContract.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContractV2 is MyContract {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public y;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import { ethers, upgrades } from &quot;hardhat&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async function main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const MC = await ethers.getContractFactory(&quot;MyContract&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const mc = await upgrades.deployProxy(MC, [42]);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  await mc.deployed();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  console.log(&quot;MyContract deployed to:&quot;, mc.address);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;main();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import { ethers, upgrades } from &quot;hardhat&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const MC_ADDRESS = &quot;部署脚本显示的地址&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;async function main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  const MCV2 = await ethers.getContractFactory(&quot;MyContractV2&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  await upgrades.upgradeProxy(MC_ADDRESS, MCV2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  console.log(&quot;MyContract upgraded&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;main();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;注意事项：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;记得在 &lt;code&gt;hardhat.config.ts&lt;/code&gt; 中引入下面语句完成初始化。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ts&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/hardhat-upgrades&quot;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;上述脚本需要 network 参数，即至少要运行本地测试网络：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;npx hardhat node&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;编程限制&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;编写可升级合约并不是 free style，必须遵循一定的规矩。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 1：跟构造函数 say no&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因在于两点：&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从语言限制上来讲，构造函数在合约部署后不属于合约的 runtime bytecode，可简单理解为部署后就消失不见了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从逻辑上来讲，构造函数的执行应该只有一次，即使在升级的背景下，也应遵循这个原则。但是，升级合约的实质是“部署并替换”，这种情况下无法保证这一点。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;因此，可以看到，在上面的例子中都没有使用构造函数，转而使用所谓的 &lt;code&gt;initialize()&lt;/code&gt; 来完成初始化。同时，为了保证该函数只运行一次，还使用了 OpenZepplin 提供的 &lt;code&gt;initializer&lt;/code&gt; modifier。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;同理，也不要使用初始化声明，即类似下面的语句：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;uint256 public hasInitialValue = 42; // X&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;但是，&lt;code&gt;constant&lt;/code&gt; 例外，即以下语句没有问题：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;uint256 public constant hasInitialValue = 42 // √&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 2：initialize() 只能执行一次&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因：见上。代码实现的注意点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;合约继承 &lt;code&gt;Initializable&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;initializer&lt;/code&gt; modifier&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用依赖注入来获得灵活性，上例就是如此，避免在该函数中使用硬编码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在合约构造函数中调用 &lt;code&gt;_disableInitializers()&lt;/code&gt;，这主要是出于安全考虑。这时构造函数为：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/// @custom:oz-upgrades-unsafe-allow constructor&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;constructor() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _disableInitializers();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 3：父合约的初始化也遵循 1&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因依旧同 1。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于父合约，同样不能有构造函数，所有的初始化代码需挪到 &lt;code&gt;initialize()&lt;/code&gt; 中，只是此时不能使用 &lt;code&gt;initializer&lt;/code&gt; modifier，而需用 &lt;code&gt;onlyInitializing&lt;/code&gt; modifier 来代替。原因也很简单：若是前者，一旦被子合约的初始化函数调用，父合约的初始化函数就只能执行一次，显然不合继承的语义。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;OpenZepplin 提供了 @openzeppelin/contracts-upgradeable 来帮助已经熟悉了 @openzeppelin/contracts 的开发人员来编写可升级合约。前者提供了后者合约的可升级版，如 &lt;code&gt;ERC721Upgradeable.sol&lt;/code&gt; 对应 &lt;code&gt;ERC721.sol&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 4：可兼容的存储布局&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其中原因在于 solidity 的语言技术细节，未来会有专文细说。在此只需记住以下规则：相对于老版本合约，&lt;/p&gt;&lt;ol data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新版本合约中的变量声明&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;当继承多个合约时，新版本的继承顺序不变&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;父合约中的变量声明同样需要遵循：&lt;/section&gt;&lt;/li&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;注意&lt;/p&gt;&lt;p&gt;规则 3 于 1 的区别：没有“只增不删”！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其原因很容易理解，因为在父合约中新增变量后会破坏子合约的存储布局。但问题是父合约本身也会演化，必然也有新增变量的需求。为了解决这个问题，可以使用 storage gap 的技巧来解决。说白了，就是：预留存储。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// v1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract Base {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256[49] __gap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// v2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract Base {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 base2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256[48] __gap;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;上述代码中，v1 和 v2 的 Base 是存储布局兼容的。&lt;/p&gt;&lt;blockquote data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;p&gt;注意&lt;/p&gt;&lt;p&gt;变量类型的长度关系重大，若使用 uint128，则可用两个。即：用连续两个 uint128 变量替代一个 uint256 变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 5：不要在子合约使用危险操作，如 &lt;code&gt;delegatecall&lt;/code&gt; 和 &lt;code&gt;selfdestruct&lt;/code&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;原因：当 implementation 地址已知后，其他第三方可以不通过 proxy 直接调用它。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;虽然你可以在 implementation 里限制调用方的地址，但并不是所有情况下都可以这么做。因此避免危险操作是上策。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;限制 6：确保使用可升级库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;范围： import 的合约和 lib，确保它们可以正常工作于可升级场景。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;除了 OpenZeppelin，还可以看看这个库 solidstate-solidity。正如其 readme 所言：&lt;strong&gt;Upgradeable-first Solidity smart contract development library .&lt;/strong&gt; 未来或许有介绍它的专门文章。&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Proxy Patterns&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;proxy 是可升级合约的底层技术基础，了解其典型模式有助于更好地编程。典型的 proxy pattern 有：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Diamond&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;OpenZeppelin 对于前三者提供了支持，暂时不支持 diamond。相比起前三者，diamond 更复杂并且野心也更大，期望提供一种通用的支持可扩展合约开发的架构模式，它在 solidstate 中得到了广泛的应用。但由于相对复杂，此文略过。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;对于前三种：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Beacon 的应用范围不如前两种广泛，但它支持不同代理升级到不同实现；&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但个人认为，若真是有这样的需求，不如直接采用 diamond 可能更好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy 拥有更长的历史，OpenZeppelin 的可升级库最早基于它完成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS 则属于后起之秀，相比 Transparent Proxy，它更轻量也更通用，这也意味着它的升级逻辑更便宜。因此 OpenZeppelin 推荐优先使用它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;在 OpenZeppelin 合约库中，三种 proxy pattern 都有对应的实现，并且文档也提供了相应的示例和部署/升级脚本，在此就不再赘述。由于文档中并没有给出 UUPS 的范例，这里简单的描述一下。针对前面的例子：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sol&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pragma solidity ^0.8.9;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol&quot;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;contract MyContractUups is UUPSUpgradeable, OwnableUpgradeable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    uint256 public x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function initialize(uint256 _x) public initializer {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        x = _x;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        __Ownable_init();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;其他的 v2 合约和部署/更新几乎一样。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;Transparent Proxy、UUPS 和 Beacon 的主要区别主要两点：&lt;/p&gt;&lt;ul data-tool=&quot;markdown.com.cn编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是否需要 proxy admin&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在 Transparent Proxy 中，该组件负责完成 upgrade 逻辑。但 UUPS 和 Beacon 中都没有它。因此，Transparent Proxy 存在有 admin owner 的概念，同时其 ownership 也可以转移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UUPS 的升级逻辑由 implementation 完成，可以看到上面的代码示例中，它覆盖了 &lt;code&gt;_authorizeUpgrade&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon 的升级逻辑则由 beacon 的 owner 完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;在哪存放 implementation 的地址&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Transparent Proxy 和 UUPS 都将该地址存在 proxy 合约中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Beacon 则将其存放在 beacon 合约里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其余细节&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;EIP1882&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;支撑 UUPS 的标准是 EIP1822，有兴趣的可以自行了解。此外，从 OpenZepplin 的接口文档和代码也可了解其细节。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;EIP1967&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;关于 implementation 的地址保存，前文说过：它存放于 proxy 合约中。但同时，支撑 proxy 的技术基础又是 delegatecall。它的特性是执行的上下文是 caller 的上下文而非 callee 的上下文。即，任何状态的变化其实发生在 caller 的空间。&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;那么随之而来的问题是：如果 proxy 中自己有变量定义，同时将调用转发给 implementation 时又会保留它的状态，那么此时必然会导致有冲突。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Kh4dSb0w5FXRLVJ5w6iathtd2kDwxUehoZXjplcfFqqAw04NvZibsGo59YIxMUJOJOmA3Jic9ZV402Nda5UNfxiaDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;EIP1967 便是为了解决这个问题，定义了一组标准存储槽来解决这个问题。本质上是对 proxy 中的变量存储槽进行了伪随机化处理。&lt;/p&gt;&lt;h3 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;函数冲突&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;即 proxy 和 implementation 中出现同名函数时，到底该不该转发？这可以通过 caller 来处理，以 Transparant Proxy 为例：&lt;/p&gt;&lt;h2 data-tool=&quot;markdown.com.cn编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;markdown.com.cn编辑器&quot;&gt;至此，关于可升级合约的基本要点已经罗列完成，剩下的就是去挖掘相关的代码和文档啦！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f79fea7d8b1da936bfcd133e98f24c86</guid>
<title>从 Kubernetes 争霸过程看 Google 开源套路</title>
<link>https://toutiao.io/k/kqd2i5k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3718120805369127&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/K1sI6IqaK7bHboPiaLKm8MMRaf1aURSewatq3uvicibjDQyjPVIEzc5k5oDKaURKAs4vuXIgrrvWEK0uT2yMDXXUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;745&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、先说结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;首先、&lt;span&gt;云原生时代到&lt;/span&gt;&lt;span&gt;了，大家已经不再仅仅满足于Docker构建镜像，企业用户更需要编排、管理和调度。其次，而Kubernetes作为Google内部秘密从头开发的 Borg2.0 版本，一诞生就具有完整的功能和良好的扩展架构，很多方面都已经吊打其他0.1版本的竞品了。不仅仅如此，Kubernetes的金主爸爸拥有如此核弹头级别的大杀器，为了占领市场居然完全不要钱完全开源免费白送（这和早期微软系统在国内坐视盗版免费占领市场有类似的效果）。不仅不要钱，还拉帮结派找了红帽等很多小弟构建CNCF基金会（是不是很安卓的开放手机联盟很像），生生造出一个基金会标准和生态降维打击竞品。真是占据了天时（云原生时代）地利（Brog2.0）人和（开源+基金会）等要素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，其中也有劣势：就是Docker和Hadoop等开源项目抢了Google内部系统的风头，提前占领了开源屌丝市场（这也正是Google后来在开源疯狂砸钱的原因，当然最近已经控制了云原生平台后就开始砍开源经费了）。Docker通过内置的Swarm来获得前期的竞争优势。正如大家害怕微软IE一家独大的局面再次上演，Google敏锐地抓住了这个机会很好地通过合纵连横策略打败了Docker。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、Kubernetes争霸简史&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker是一个开发、交付和运行应用程序的开放平台，开发者可以在此打包他们的应用及依赖到一个可移植的容器中，然而发布到运行平台上。&lt;/span&gt;&lt;span&gt;在Docker走红之前LXC已经在一些公司内部得到应用。&lt;/span&gt;&lt;span&gt;比如，2008年Google推出的PaaS平台 GAE（Google App Engine）就采用了LXC。&lt;/span&gt;&lt;span&gt;在GAE中Google使用了一个能够对LXC进行编排和调度的工具Borg——后来Kubernetes借鉴了它的很多设计。&lt;/span&gt;&lt;span&gt;整体而言LXC的应用范围不广，主要是一些有技术实力的大公司在应用。&lt;/span&gt;&lt;span&gt;LXC虽然解决了应用的隔离，但并没有解决可移植性问题，而这个问题被Docker完美地解决了。&lt;/span&gt;&lt;span&gt;Docker有三个最重要的概念：&lt;/span&gt;&lt;span&gt;镜像、仓库、容器，其中镜像是基石，也是Docker最重要的创新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，Docker只是满足了应用软件生命周期中的一部分需求，随着越来越多的企业开始采用Docker技术来开发和部署应用，特别是要规模化部署应用，它们发现自己面临一个现实的问题，就是要对多个容器进行编排、管理和调度。&lt;/span&gt;&lt;span&gt;就在这个时候，Google带着Kubernetes下场了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Google是云计算概念的最早提出者，不仅有PaaS平台GAE，还有Google云GCP，但提到云计算人们首先提到的却是AWS，Google的存在感很弱。&lt;/span&gt;&lt;span&gt;多年运行GCP和Borg的经验，使得Google非常认可容器技术，也深知目前Docker在规模化使用场景下的不足。&lt;/span&gt;&lt;span&gt;Google从当时大火的容器市场看到了机会，而且这里也存在一些商业机会：&lt;/span&gt;&lt;span&gt;如果容器得到广泛应用，那些在AWS运行的应用就有可能自由地移植到GAE和Google云上运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2013年夏天，Kubernetes联合创始人Craig McLuckie和Joe Beda、Brendan Burns等开始讨论容器编排系统的开发，并决定采用开源的方式来开发这个系统。&lt;/span&gt;&lt;span&gt;经过多次找机会向Google高层游说，最后这个项目终于被Google批准开源。&lt;/span&gt;&lt;span&gt;并首次在2014年6月举行的DockerCon 2014大会上正式发布。&lt;/span&gt;&lt;span&gt;实际上并不是只有Google看到了容器市场的新需求，就在DockerCon 2014大会上，就有多家公司推出了自己的容器编排系统。&lt;/span&gt;&lt;span&gt;其中有影响力的还有Docker、Mesos等，而Google的进场让原本就竞争激烈的容器编排市场火上浇油。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;D&lt;/span&gt;&lt;span&gt;ocker也希望提供更多平台层能力，向PaaS进化，为企业最终要部署的网站、服务、数据库，是云计算业务提供解决方案——这才是Docker的目标。&lt;/span&gt;&lt;span&gt;2014年7月，Docker收购OrchardLabs正式开始涉足容器编排领域，Orchard Labs的容器编排工具fig当时很有名，这个fig就是DockerCompose的前身。&lt;/span&gt;&lt;span&gt;Docker Compose虽然能编排多个容器，但是只能对单个服务器上的容器进行操作，而不能实现在多个机器上进行容器的创建和管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2015年初Docker发布Swarm，算是正式向Kubernetes宣战了。&lt;/span&gt;&lt;span&gt;在容器规模较小的场景下，许多用户更喜欢使用Docker Swarm，因为它平滑地内置于Docker平台中。&lt;/span&gt;&lt;span&gt;如果Docker Swarm能成功，那Docker就将通吃容器市场，这就和CoreOS、Red Hat等一些公司产生了利益冲突，这为Docker后来的败退埋下了伏笔。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;Kubernetes的成长过程中，CoreOS发挥了重要作用。&lt;/span&gt;&lt;span&gt;Docker容器发布以后，CoreOS将这一技术集成到自己的操作系统中，2014年发布了自己容器编排框架fleet，这是最早提供云环境自动部署和调度集群资源的容器软件之一。&lt;/span&gt;&lt;span&gt;Kubernetes出现后，CoreOS放弃了fleet而转向了Kubernetes，并后来推出了容器运行时rkt来替换Docker的容器运行时RunC。&lt;/span&gt;&lt;span&gt;2018 年1月30日，红帽斥资 2.5 亿美元收购了CoreOS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Kubernetes项目中，红帽是仅次于Google的重要角色。&lt;/span&gt;&lt;span&gt;红帽的OpenShift是最早一批PaaS平台（2011年发布，和Cloud Foundry同一年）之一。&lt;/span&gt;&lt;span&gt;2013年9月，Docker大火的时候，红帽将Docker嵌入到红帽Linux企业版RHEL中，并完全重建了OpenShift。&lt;/span&gt;&lt;span&gt;作为一个PaaS平台，也需要容器编排功能，红帽需要选一个。&lt;/span&gt;&lt;span&gt;红帽在得知Kubernetes项目并最终开源后果断放弃和Mesos合作选择了Kubernetes。&lt;/span&gt;&lt;span&gt;2015年6月，OpenShift Enterprise 3在红帽峰会上发布，其中内嵌了Docker和Kubernetes，这给Kubernetes后来的成功打下了坚实的基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mesos是容器编排市场上另一个主要玩家。&lt;/span&gt;&lt;span&gt;Mesos最初是加州大学伯克利分校的一个项目，目的是创建下一代集群管理器，一直在努力提高集群的利用效率和性能。&lt;/span&gt;&lt;span&gt;作为一个面向资源管理的项目，容器编排其实只是其中的一个功能模块，叫Marathon。&lt;/span&gt;&lt;span&gt;Mesos在2014年成为首批支持Docker容器的容器编排框架之一。&lt;/span&gt;&lt;span&gt;实际上Mesos不仅仅可以支持Docker，还可以支持Java应用集群。&lt;/span&gt;&lt;span&gt;Mesos的最大优势是它在运行关键任务时的成熟度，它比其他许多的容器技术更成熟，2015年Kubernetes 1.0刚出来时也只具有管理100台服务器的能力，而Mesos当时已经有管理上万台机器的案例。&lt;/span&gt;&lt;span&gt;Mesos被Twitter、苹果（Siri）、Netflix等公司所采用。&lt;/span&gt;&lt;span&gt;相比Docker与Kubernetes，Mesos侧重在传统的资源管理，不如前两者天生是面向多云和集群的，它在应对多云和集群管理时面临很多新的挑战。&lt;/span&gt;&lt;span&gt;后来随着外部竞争的恶化逐渐淡出了历史舞台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kubernetes脱胎于已经在Google内部运行了多年的Borg项目，但并没有直接延用Borg，属于Borg2.0版本。&lt;/span&gt;&lt;span&gt;Kubernetes设计了一套稳定可扩展的API接口、预置服务发现、容器网络、及可扩展等关键特性。&lt;/span&gt;&lt;span&gt;其概念抽象非常符合理想的分布式调度系统。&lt;/span&gt;&lt;span&gt;Kubernetes的一个成功之处就是提供了一个规范，可以让你描述集群的架构、定义服务的最终状态，由它来帮助你的系统达到和维持在这个状态。&lt;/span&gt;&lt;span&gt;同时和Docker、Mesos相比，Kubernetes强大的生态为应用程序开发人员提供了丰富强大的工具，用于编排无状态的Docker容器，让开发人员减少了对基础设施和操作团队的依赖。&lt;/span&gt;&lt;span&gt;另外，Kubernetes作为CNCF下的开源项目，使得它与Docker相比更容易得到认可和支持。&lt;/span&gt;&lt;span&gt;相比Docker后来将Swarm全部内置到Docker项目，完全是和Kubernetes整个社区竞争。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Docker虽然以创新性的技术通过开源社区取得了巨大的成功，但是在独自对抗Google、红帽巨头乃至整个云计算产业最后以失败收场。&lt;/span&gt;&lt;span&gt;不仅仅是Docker，其他云厂商也失去了一家独大的可能，而 Google 则成为了云原生的最大赢家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、类似案例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;类似的案例还有很多，比如Chrome、Firefox通过免费打败IE，比如安卓联盟通过开放手机联盟打败诺基亚、Windows Phone，WASM通过免费/标准在浏览器领域打败Flash、JVM、ActiveX。而作为一个反面教材，Qt因为缺少真正的盟友而失去了进一步发展壮大的机会。总结而言，首先东西要好，但不能吃独食，所以还需要一个不差钱的金主爸爸。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5057471264367817&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/K1sI6IqaK7a9yqzqNrGQzz5syNFibkOyDxRn4uEFpsricnNLBiaefqqgxlB9wDibGHhHiaM5PVtBHaY2obIhpSCnicdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8312a4598cf3a7194a444ef9f7b2268f</guid>
<title>Java 应用上云后被 kill 问题分析与解决</title>
<link>https://toutiao.io/k/th616z9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;246&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt7tV2c2jtpwQxziaCpO0DmgAv1lgEN2niayVWYbKUYxmqpM2AWAlkpTrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92600&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;circle&quot; data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7lCBD0jNG4KrPrs1QcStP0KfRK1jwkibIiauY5Xyib2044asfJy5gUjkiadibhTGKzJFeF6YkIadfcFoicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;80&quot; title=&quot;微信图片_20230112103059.jpg&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;李杰&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;2020年2月份加入去哪儿旅行酒店报价中心研发团队，云原生SIG成员，主要负责国内酒店报价实时和离线计算模块的研发和维护。喜欢钻研云原生相关开发，完成JVM参数校验功能，解决容器应用的OOM被kill等问题。&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自从公司 2021 年 11 月份开始全面容器化后，酒店报价中心团队快速响应，迁移了 98% 的应用，由原来的 kvm 或实体机器到容器上，我们的多个应用出现了频繁被 kill 的情况，主要包括两大类：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本文主要介绍发现问题以及解决问题的过程。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题一：应用长时间 GC&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应用 GC 时间长导致 k8s 检活失败，k8s 会 kill 掉业务应用。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;182&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.315625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtxN7TpY8pVRBmv3Me4qpyRpuXEceqRFmicZZicqjiaYr1Rtia2GKHYorbUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当时我们团队的两个应用在发布到 docker上以后，出现了频繁重启的现象，发布后一天内重启次数高达 29 次左右，提示也仅仅是 “时间：2021-11-25T21:34:58+08:00 原因：Error kill” 看不到具体的问题，只能到对应的容器内部去寻找线索了。具体排查过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1、确认为啥会被 kill ？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;164&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.2836676217765043&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtVwUKT6VhaBCg06eGfvlmOPDCygQiaZtmdQMtNicx8uvMfATibu4SiaFUKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;215&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.37265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFticcRoakF9mzX3eod2eBxOPy3Dv0aTTwJ0UNMqhPAiama52R7EC9Bxm8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先通过 dmesg 命令，查看容器所在主机上的日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现是存在 OOM kill 掉的 Java 应用，但是对比了下这个 total-vm 和我们自己的应用配置发现差别很大，不是我们的应用进程，我们的配置是：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;153&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.26484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtzAzbJA7tZ9iasxlOfuyXibvK4YX10ibrT2J8ypLGxanaspudJw2nib81MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;舍弃了这个方向后转向了 k8s 的日志（ps：为啥第一次不看这个，是因为这个日志的查看时需要权限的，前期没有权限，只能自己动手先看方便的），发现了在被 kill 之前出现了3次 unhealthy 的 k8s 日志，且返回请求状态不是200。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;250&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.4328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtTfdaVT9INjS9TK93mtWo8cHht0bU9t42vACLhmx9kSDJhnNhLeKJbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看下为什么会有检活请求异常，检查业务访问日志，发现这个时间点是有接收到请求，手动访问也是成功的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是当时为啥会有访问状态不是 200 的问题呢？怀疑当时业务进程是有大量任务在跑，响应超时问题导致， 所以开始排查业务的具体日志。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、发现问题&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在排查日志的时候发现了导致该问题的根本原因，本质是 GC 时间过长导致。查看重启前的容器 GC 日志：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;260&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.44921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtGal2ibYtQIBhz12Y1jIn2ZNAu2BLgd1On1aWgdSIgxLLj9R8I1Kmtkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;容器被重启是在 2021-11-25T21:34:58+08:00 重启的。在这个时间点前，也就是被 kill 之前的一次 GC 时间高达 18s + 7s 。至此，原因就很清晰了：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为应用进程的 GC 导致服务不能正常响应 k8s 的检活请求，k8s 认为应用“死”了，触发了 kill 和重启操作！&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 GC 日志，分析主要耗时点。推荐 GC 分析工具：https://gceasy.io/，调整 JVM参数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;k8s 调整了检活机制，由原来超时 10s、20s，最后调整为 2min。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过分析日志发现主要的长时 GC 是因为新生代晋升失败，扩大 young 区和堆大小优化 JVM 参数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题二：内存碎片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;问题现象是应用管理平台上出现了容器 “OOM kill” 的提示。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;49&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.08515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtzmLzR0bOWPWdjOfnheJSicGLWcg1cu69LmSaib9mzBfz5p9K1DS1DghQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于 OOM kill 的提示，开始分析应用日志，发现堆区、栈区并没有出现 OOM 的问题，怀疑是堆外内存内存溢出导致，因此，尝试添加相应的JVM参数以观察堆外内存的使用情况。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;95&quot; data-backw=&quot;300&quot; data-ratio=&quot;0.31666666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtU1Joo1oXwFHbQ9LqK4GcRxJw4D2jCEDA7rEqMz8q41gaaKwxDcFMhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;观察是否是有堆外内存没有释放，再加上 OOM 没有明显征兆，写了脚本定时 30s 看下使用情况。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;363&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6290322580645161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt5qL4wGf5AORmL2BXOia0hpuKDe5RyRCAexTiboxzrNfjfiar6QkVnmiaiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图是在容器启动后的 1 分钟 到 容器即将被 kill 时的 JVM 内存分配对比图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;282&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.48828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtMSLERcBwRWC6snj00VtXnAurgJDGibjuNzcrFicsXB5NEibQSPLH8O4OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;187&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.32421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtXiaG8WmiaAYo0n3c428KDZP9lpXNica9ZO6F5DnTt7SzRPbjS4NoqQaPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现 JVM 的使用内存并没有明显变化（12491M→ 12705M），且整体没有超过 docker 分配的内存限制（docker limit Memory:12G），但是为什么会有 OOM 呢？哪块的内存使用升高导致了 OOM 呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;查询了大量的资料，排查方向转向内存这块。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用 pmap 分析 Java 进程的内存映射关系：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;177&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.30546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtZxBdrDApKC1lBzv2WMGbZwlqBzIIG41ibt39cebVibabGeXsQFuX9TkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;369&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFthC5EmEDvnl7wvTQich7ZWiay3X8yFP65Fc4qPXTNibvMLyxGeNCeQFK9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pmap说明&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Address: 内存开始地址&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Kbytes: 占用内存的字节数（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;RSS: 保留内存的字节数（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Dirty: 脏页的字节数（包括共享和私有的）（KB）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Mode: 内存的权限：read、write、execute、shared、private (写时复制)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Offset: 文件偏移&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;Device: 设备名 (major:minor)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现可疑的地方有两个 1029712KB（1005M）的内存块和较多64M内存块，linux 默认使用的 glibc 的 ptmalloc 内存分配器，有这个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Glibc为什么会有64M的内存块的问题？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在进程申请内存时，根据需要分配的内存大小由内存分配器来想内核申请具体的内存区域，那么为什么会有内存分配器来申请内存，而不是进程直接向系统申请呢？因为系统调用的开销比较大，这样做是非常不值的。同时，在 linux下分配堆内存需要使用 brk系统调用，而这个系统调用只是简单地改变堆顶指针而已，也就是将堆扩大或者缩小。举个例子，进程分别申请了 M2 和 M1 两块内存，运行了一段时间后，M2 内存不需要了，需要回收了。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;315&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtOoH1dDE3ZbIxOb8hR9rZNZJlSx4PC8wfdaAriaGcamicYyOgwDznqYQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用系统处理的话，只能使用 brk 移动指针，那么 M1 也会被回收掉，这样显然是不行的。所以引入内存分配器，把 M2 的内存缓存下来，等到进程需要再次申请内存空间时不需要使用系统调用，而是直接从缓存中分配，这个动作就是由内存分配器完成的。内存分配器不仅提升了运行效率，还提高了内存的使用率。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;195&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtpADTYiazRiau2SL1dHxonCuTvGpZXXUxrqD8DU8mNex8QvQNiaIztfrLg/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1180&quot; data-cropy1=&quot;38.78892733564014&quot; data-cropy2=&quot;436.88581314878894&quot; data-ratio=&quot;0.33728813559322035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtP5XcxLs0MM253LpUfK5vhOiaSSmSbxPdVkq4YTKUssO4WL4voYY4W2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1180&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;glibc 的内存分配器（ptmalloc）的结构如图所示，一个进程就有一个主分配区和若干个从分配区。所有的线程申请内存时，都要经过主分配区申请，多线程时就需要通过锁机制来保证分配的正确性，从分区就应运而生了，ptmalloc 根据系统对分配区的争用情况动态增加分配区的数量。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;323&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtB8yx5gQeYnjxIAaGWqvwLdbmHMKtMiaLANAoJYEuAYob6wnplZib3xhw/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;46.50519031141869&quot; data-cropy2=&quot;761.7993079584776&quot; data-ratio=&quot;0.559375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtf5DL8ZXS5Gcib2DhSurSbtibr1vDpf6kmqkfvacbFBytNvFfO8tCC6OA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在申请内存时，glibc 每次申请新的内存时，主分配区是可以通过 brk 或者 mmap 来向系统申请的，但是非主分配的内存只能通过 mmap 申请了，在64位机器上每次申请的虚拟内存区块大小是 64MB ，最大为8倍的 CPU 数量。且从分配区一旦创建，就不会被回收了。这个就是该问题中发现的 64MB 内存块产生的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;进程申请内存的简单步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 通过 fastbins 查找合适内存块，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 1没有，从 small bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 2没有，从 unsorted bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 3没有，从 large bin 中获取，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 4没有，从 top chunk 中，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;6. 5不够，向系统申请 brk/mmap。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内存回收的简单步骤如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1. 判断是否是 mmap 映射，是直接回收&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 判断是否邻近 top chunk&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. 不是2，根据 size 放到不同的 bins 中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 是2，判断 top chunk 中邻近内存是否在使用 是 合并 top chunk&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;5. 合并后判断 top chunk 大小，超过阈值（默认128k），但是开始分配128k不会回收。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过翻阅资料发现，现在市面上有不少内存分配器的实现，如 tcmalloc ，jemalloc 等，在这里我们选择了 jemalloc。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;jemalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;jemalloc 是一个通用的 malloc(3) 实现，强调碎片避免和可扩展的并发支持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;避免内存碎片和性能点提升&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;性能对比&lt;/span&gt;&lt;/em&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;419&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.72421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtGFhO9VbmS0lDQvYxXnrJRUgsNnHIhdtVBA18CRgUKoLgliaO2JKyCWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在灰度环境尝试替换为 jemalloc 的内存管理器：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;安装 jemalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;125&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.215625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt3ftebN2axibmticbwDMImNfZAia9LdeiaFwfvC7mB6uxAk0E1BKmXqYukA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;也可尝试安装 tcmalloc&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;83&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.14453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtAavAQTGR8mvDF8R8GB3WX2NQDdGFTdecfl4tBicpPwrTyBgMTLWLcAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;验证下是否使用成功了&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.43666666666666665&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt1PicjGcJlFGhlFrXxibSianAQ3aKptG9oia8CUUPoqsgWWLkt0YKqZMMOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;发现 &#x27;64MB&#x27; 的空间映射已经不存在了，且在观察时间范围内还有一次内存的下降， 观察一周一直平稳运行，没有出现 OOM kill 的问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;295&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtb6zmT6XuxPH5icW8ia2kGYv8D0GgucUPjicXMUqGuxDq0A1sSbdGTv9Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;140&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.24296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFticHia3RiaChXvfsXVm4JiaBw5MnfoibHYkPrV6GWSQDY7OibVQMXMjhHiaibjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;问题处理流程&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;705&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.220458553791887&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtl42R11h0B6W4vrdVmfOsJWhIKnicGFxuPDaFPtRjqV4dDnFDaicFeyZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;发现问题，就是个人前进的一大步。要发现问题，就要抓细节，不放弃再加上有头脑的处理问题！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;工具优化&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;340&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.58828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFtd2ke3fIYJPfQzfYIVBJPt4KUQeNMwTqWfGTySJs7KDK7sK38jz1sYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考文件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;华庭 ：《Glibc内存管理-Ptmalloc2 源代码分析》&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JeMalloc-UncP 知乎&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://jemalloc.net/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;splitline&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;116417&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;splitline&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;116349&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.06201550387596899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7nml5suWQsia3dK2WjlMVGFt0AwrkK9RA0HZUV67P2ib1y67NNCibcMbMfX5hwG4A3hwx7qDleYfa36Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot; draggable=&quot;true&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4746666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7lmPPfFYjwklIwjg232Sqg8q81Q0AdYRBAcCOA8dsorJIGEu7Ln2Tht5jthVsykWiavcoONdDoia1iag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YE1dmj1Pw7mKjQn2D8icpMz0hEWr0b0HpdmRw30s4KMuOvYEEvKDavzDFHzq0niavVRibVDdUCalyjb1ibj6cHsXhQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2b81198bdea50cffa96baed8b4f2144b</guid>
<title>一看就懂！任务提交的资源判断在 Taier 中的实践</title>
<link>https://toutiao.io/k/680fwur</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4255556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGdQLc0HmssKnfVOGLsN4k8CKMSYfLGF9RT5SS7p7w9BicuHpSYpVeGLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;作者 / 月白&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编辑 / 阿晗&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 介绍&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Taier 是袋鼠云开源项目之一，是一个分布式可视化的DAG任务调度系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;旨在降低ETL开发成本、提高大数据平台稳定性，大数据开发人员可以在 Taier 直接进行业务逻辑的开发，而不用关心任务错综复杂的依赖关系与底层的大数据平台的架构实现，将工作的重心更多地聚焦在业务之中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;项目地址：&lt;span&gt;https://github.com/DTStack/Taier&lt;/span&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;563&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;462&quot; data-ratio=&quot;0.9734375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGpeHhHxfZCyJf1tibBRphZiaImuPYztdhB24hp6oMuzNoRrOgELoMY6RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 资源判断&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Taier 基于插件式架构设计，用户在界面开发任务并提交运行。提交运行插件又划分为worker-plugins、datasource-plugins双插件类型。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在任务提交的时候，Taier需要判断是否有足够的资源来执行，否则一股脑地提交任务，最终会拖垮环境，导致服务的不可用。&lt;span&gt;&lt;strong&gt;根据环境资源的剩余情况来动态调整提交任务的速率&lt;/strong&gt;&lt;/span&gt;是Taier必不可少的一项功能，那么Taier究竟是怎么来判断资源的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;什么是资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对一个系统而言，首先要定义出资源的种类，然后将每种资源量化，才能进行管理，这就是资源抽象的过程。那么，想回答上文中「Taier是如何判断资源」的这个问题，就需要先理清楚，在一个分布式、多环境的系统中，什么是资源，又为什么要有“资源”这个概念？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们通常所说的“资源”都是硬件资源，包括CPU使用/内存使用/磁盘用量/IO/网络流量等等，这是比较粗粒度的。也可以是抽象层次更高的TPS/请求数之类的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;资源可以用来衡量系统的瓶颈。系统能否充分利用资源，什么时候可以持续提交任务，什么时候需要暂停提交任务，比如当总体资源充裕时，可以把对应的任务全部提交上去。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;&lt;span&gt;● &lt;span&gt;以Yarn框架介绍为例&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6189711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGXgqVrqy1ueBZtB0zTGWfGqc20I252ibwRwO42ePTXkUwtX9qudML53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ResourceManager 是一个全局的资源管理器，负责整个系统的资源管理和分配，包括 scheduler 、Application Manager和 Node Manager。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对调度器来说，YARN 提供了多种直接可用的调度器， Fair Scheduler 和 Capacity Scheduler 等。调度器仅根据各个应用程序的资源需求进行资源分配,分配的基本单位是Container，而容器里面是将内存、CPU、网络、磁盘封装到一起。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在Yarn的web 界面，我们可以直观的看到当前Yarn集群剩余的内存、CPU核数、运行的Container数量。对提交到yarn上的任务来说，资源就是：内存、CPU、磁盘等可用信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2703379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGW3nZiaxBMv7kGb32ceXe1qgYz24Vbek99xjJOyt3rLNDUCdxhNj9Qgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;799&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;所以在提交到Yarn上执行的任务，我们可以根据ResourceManager 获取Yarn集群当前剩余的内存、CPU核数来进行判断，任务能否满足提交条件等规则。其中，最基本的规则就是:&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• Yarn集群剩余的内存  &amp;gt;= 当前任务所需的内存&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• Yarn集群剩余的CPU核数 &amp;gt;= 当前任务所需的CPU核数&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;何时去判断资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;任务在界面开发完成之后，点击运行的按钮，开始从等待提交的状态切换。在提交运行的时候，任务组装好集群配置信息进入下一个阶段——&lt;strong&gt;&lt;span&gt;资源判断&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个阶段开始判断资源是否满足任务提交。如果任务满足则进行提交，如果任务不满足，则定时、延时、重试直到资源满足任务执行条件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2038217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG75ttVKwDib8v8nyPDiaToCbTmw05SAwX4ibGVG7oN5W9qXYu2SGx0umlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;怎样去判断资源？&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在worker-plugins提交的抽象类中，有一个通用的方法judgeSlots 去判断资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;judgeSlots 的判断结果分为以下四种:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• &lt;strong&gt;OK: &lt;/strong&gt;资源判断满足，任务可以提交&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;NOT_OK: &lt;/strong&gt;不满足任务所需资源，需要延时重试&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;LIMIT_ERROR: &lt;/strong&gt;任务参数设置错误: CPU核数或内存为0等场景&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• &lt;strong&gt;EXCEPTION:&lt;/strong&gt; 任务资源判断异常: ResourceManager连接异常等场景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGE7SmI2XT3vwNGUR4yWrV73icQSTbibP5GrKnQypKWko7DfiaGYfgLn88Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;strong&gt;&lt;span&gt;● 以Spark任务为例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;下文我们以Spark任务为例，看看Spark的提交插件是如何获取对应的ResourceManager信息并进行资源判断的。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGMaHdthxsA33WUyNUbe0pu6hu3Ns1ua0BefAPkOpVkZow6xT7yIiawicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;可以看到根据Yarn集群信息获取了以下信息：&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;  //  &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;• 根据Yarn集群信息初始化YarnClient&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 获取Yarn集群队列下的ACCEPTED状态任务，是否大于控制台yarnAccepterTaskNumber 参数设置&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;• 获取Yarn集群队列的剩余CPU核数和内存信息&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2415131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGpaIXHs5ZM3nPU3DxbGQpV8X7bbsmQUENWtEXprkfmOJWFxxl0v5rqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;然后根据JobClient所携带的任务参数信息，获取了Driver、Executor 的相关内存和CPU信息并进行计算。&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.254386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGibrcLoK7d1Fz34g87zTEuxlCEAVDeYkJsmDhSALhXC0dBMic4NhSDDng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;798&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最后将获取到的Yarn集群信息和任务所需的资源信息按照固定规则进行比对，返回对应的资源判断结果。资源判断的结果将会实时在 Taier 的界面上展示，所以在任务处于等待提交状态的时候，可以去控制台-&amp;gt;队列，管理并查看该任务资源判断信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.275&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGeyXeLFRbofHia65ZuC1wV3iaZEPOTVTgX8ye35WickN6Yd5u2UDMrp7aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Taier 未来规划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;展望未来，为进一步提升Taier的使用场景，同时也为了减少Hadoop生态在Taier中的依赖，&lt;strong&gt;&lt;span&gt;Taier后续会扩展更多的任务类型&lt;/span&gt;&lt;/strong&gt;。除了支持对接Hadoop集群外，Taier也会陆续支持相关类型的local模式运行，完善更多的场景使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Taier团队非常期待得到每一个人的反馈，能够和其他优秀开发者共同合作，进一步推动Taier的技术发展。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果您对Taier有兴趣，希望可以参与到我们的建设中来，一起交流，一起进步，为 Taier变得更好贡献一点你的代码和意见，这将是我们，同时也是 Taier莫大的荣幸。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;＋&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG7hcau6vHI8BNUtCRzovUknsC7qjwzJMOx5iaD8rh5bhaI2e7z3E0O5Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494989&amp;amp;idx=1&amp;amp;sn=43d754d9895f2b40e6f7b3d78b9c7ee3&amp;amp;chksm=fe43f654c9347f429e92760d30db923ee42fcbd9ee7d8cb3625092b00b6f6ff25746eb6af2f9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;DAG任务调度系统 Taier 演进之道，探究DataSourceX 模块&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;DAG任务调度系统 Taier 演进之道，探究DataSourceX 模块&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494697&amp;amp;idx=1&amp;amp;sn=2b0d4144249ea9a12550daa446dbf768&amp;amp;chksm=fe43f730c9347e2690de5d66a3d39b4e21db99018b66beec0419376a6f646d28365646328d1b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;官宣！Taier1.3新版本正式发布，新鲜功能抢先体验&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;官宣！Taier1.3新版本正式发布，新鲜功能抢先体验&lt;/a&gt;&lt;/p&gt;&lt;p&gt;▫ &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247494417&amp;amp;idx=1&amp;amp;sn=7151e3a47d59a557b5e13954792ed29e&amp;amp;chksm=fe43f008c934791e874dd28e8286615c1756d3dadd1382fd93d18be807178400b64978435079&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一文读懂：开源大数据调度系统Taier1.2版本新增的「工作流」到底是什么？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;一文读懂：开源大数据调度系统Taier1.2版本新增的「工作流」到底是什么？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▫ &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU5ODYyNTkxMA==&amp;amp;mid=2247493745&amp;amp;idx=2&amp;amp;sn=0b7ed813dd5298b41eed663a46eabe8d&amp;amp;chksm=fe43f368c9347a7ea9c947275d151c7a1e296787a14c883031258630c989b9574451c29e4e80&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;任务or实例 详解大数据DAG调度系统Taier任务调度丨直播回顾&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;任务or实例 详解大数据DAG调度系统Taier任务调度丨直播回顾&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p powered-by=&quot;xiumi.us&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;开&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;源&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;交&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● ChunJun&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/chunjun&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/chunjun&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● Taier&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/Taier&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/taier&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● ChengYing&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/chengying&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/chengying&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt; ● Molecule&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;https://github.com/DTStack/molecule&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://gitee.com/dtstack_dev_0/molecule&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG4klDpcKicL2rCjdBJ6FA7icVr5NFk4Q62AN0FEtk25sgehOT0opsnW3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;袋鼠云开源技术框架交流群&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;钉钉群｜30537511&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.3333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfG50aDClVlK4jnuxHEco8KhhBRcibf2BhicjzaOWy4Tn2CMVyYGMoJbugw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;点击&lt;span&gt;“阅读原文”&lt;/span&gt;，直达开源社区！&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.04&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Xxm5O5TNdibhcc89ogFBr7kbSzxnu0JfGX9wDOtuGq4l2jWxDVcBC0If6MHktToFzjUWkKkXwQ0eY4uGXicnDRRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40b540b14b166f94b54eda35069c569b</guid>
<title>灵魂拷问：JS 为什么是单线程？</title>
<link>https://toutiao.io/k/recvtja</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkyOTE5NzQ2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/MDPRplBm9ZVicvbRDVk8icbaWUEAAx9CnmXUiaRLuNLTYSbfJQHeuJJ4uzmS0Ipy2IgK8He2AUSD4sUaGYk7kRFtw/0?wx_fmt=png&quot; data-nickname=&quot;前端界&quot; data-alias=&quot;&quot; data-signature=&quot;高质量文章分享、实践干货、技术前沿、学习资料， 你感兴趣的都在前端界&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;关注公众号 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;前端界&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，回复“&lt;/span&gt;&lt;span data-style=&quot;color: rgb(255, 0, 0); letter-spacing: 0.544px; word-spacing: 2px; font-size: 14px; visibility: visible;&quot; data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(255, 0, 0)&quot;&gt;加群&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;加入我们一起学习，天天进步&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前述&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要对&lt;code&gt;js&lt;/code&gt;与&lt;code&gt;浏览器&lt;/code&gt;之间的进程与线程开展，业务之余丰富一些认知~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程与线程&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是进程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，&lt;code&gt;CPU&lt;/code&gt;是计算机的核心，承担所有的计算任务官网说法，&lt;code&gt;进程&lt;/code&gt;是&lt;code&gt;CPU&lt;/code&gt;资源分配的最小单位字面意思就是进行中的程序，可以将它理解为一个&lt;code&gt;可以独立运行且拥有自己的资源空间的任务程序``进程&lt;/code&gt;包括运行中的程序和程序所使用到的内存和系统资源&lt;code&gt;CPU&lt;/code&gt;可以有很多进程，我们的电脑每打开一个软件就会产生一个或多个&lt;code&gt;进程&lt;/code&gt;，为什么电脑运行的软件多就会卡，是因为&lt;code&gt;CPU&lt;/code&gt;给每个&lt;code&gt;进程&lt;/code&gt;分配资源空间，但是一个&lt;code&gt;CPU&lt;/code&gt;一共就那么多资源，分出去越多，越卡，每个&lt;code&gt;进程&lt;/code&gt;之间是相互独立的，&lt;code&gt;CPU&lt;/code&gt;在运行一个&lt;code&gt;进程&lt;/code&gt;时，其他的进程处于非运行状态，&lt;code&gt;CPU&lt;/code&gt;使用 &lt;span&gt;时间片轮转调度算法&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 来实现同时运行多个&lt;code&gt;进程&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是线程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;线程&lt;/code&gt;是&lt;code&gt;CPU&lt;/code&gt;调度的最小单位&lt;code&gt;线程&lt;/code&gt;是建立在&lt;code&gt;进程&lt;/code&gt;的基础上的一次程序运行单位，通俗点解释&lt;code&gt;线程&lt;/code&gt;就是程序中的一个执行流，一个&lt;code&gt;进程&lt;/code&gt;可以有多个&lt;code&gt;线程&lt;/code&gt;一个&lt;code&gt;进程&lt;/code&gt;中只有一个执行流称作&lt;code&gt;单线程&lt;/code&gt;，即程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行一个&lt;code&gt;进程&lt;/code&gt;中有多个执行流称作&lt;code&gt;多线程&lt;/code&gt;，即在一个程序中可以同时运行多个不同的&lt;code&gt;线程&lt;/code&gt;来执行不同的任务， 也就是说允许单个程序创建多个并行执行的&lt;code&gt;线程&lt;/code&gt;来完成各自的任务&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进程和线程的区别&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程是操作系统&lt;code&gt;分配资源&lt;/code&gt;的最小单位，线程是&lt;code&gt;程序执行&lt;/code&gt;的最小单位一个进程由一个或多个线程组成，线程可以理解为是一个进程中代码的不同执行路线进程之间&lt;code&gt;相互独立&lt;/code&gt;，但同一进程下的各个线程间&lt;code&gt;共享程序的内存空间&lt;/code&gt;(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)调度和切换：线程上下文&lt;code&gt;切换&lt;/code&gt;比进程上下文切换要快得多&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;多进程和多线程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多进程：多进程指的是在同一个时间里，同一个计算机系统中如果允许两个或两个以上的进程处于运行状态。多进程带来的好处是明显的，比如大家可以在网易云听歌的同时打开编辑器敲代码，编辑器和网易云的进程之间不会相互干扰多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JS为什么是单线程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。JS的单线程，与它的&lt;code&gt;用途&lt;/code&gt;有关。作为浏览器脚本语言，JavaScript的主要用途是与&lt;code&gt;用户互动，以及操作DOM&lt;/code&gt;。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？还有人说js还有&lt;code&gt;Worker线程&lt;/code&gt;，对的，为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程是完 全受主线程控制的，而且不得操作DOM 所以，这个标准并没有改变JavaScript是单线程的本质了解了进程和线程之后，接下来看看浏览器解析，浏览器之间也是有些许差距的，不过大致是差不多的，下文我们皆用市场占有比例最大的Chrome为例&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器是多进程的&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为前端，免不了和浏览器打交道，浏览器是多进程的，拿Chrome来说，我们每打开一个Tab页就会产生一个进程，我们使用Chrome打开很多标签页不关，电脑会越来越卡，不说其他，首先就很耗CPU&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;浏览器包含哪些进程&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Browser进程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器的主进程(负责协调、主控)，该进程只有一个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负责浏览器界面显示，与用户交互。如前进，后退等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负责各个页面的管理，创建和销毁其他进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将渲染(Renderer)进程得到的内存中的Bitmap(位图)，绘制到用户界面上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络资源的管理，下载等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第三方插件进程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;GPU进程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;渲染进程(重)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;即通常所说的浏览器内核(Renderer进程，内部是多线程)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个Tab页面都有一个渲染进程，互不影响&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主要作用为页面渲染，脚本执行，事件处理等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么浏览器要多进程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们假设浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差同理如果插件崩溃了也会影响整个浏览器当然多进程还有其它的诸多优势，不过多阐述浏览器进程有很多，每个进程又有很多线程，都会占用内存这也意味着内存等资源消耗会很大，有点拿空间换时间的意思到此可不只是为了让我们理解为何Chrome运行时间长了电脑会卡，哈哈，第一个重点来了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简述渲染进程Renderer(重)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页面的渲染，JS的执行，事件的循环，都在渲染进程内执行，所以我们要重点了解渲染进程渲染进程是多线程的，我们来看渲染进程的一些常用较为主要的线程&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;渲染进程Renderer的主要线程&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.60625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKntlVGVJwYjMwuP4ss6icD5iaAicnADoKdUvO1ZhB5auaNDicL4Ywydm6libDrhTiaUpOHWlKLx6OQXg88Q/640?wx_fmt=jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;GUI渲染线程&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解析html代码(HTML代码本质是字符串)转化为浏览器认识的节点，生成DOM树，也就是DOM Tree&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解析css，生成CSSOM(CSS规则树)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把DOM Tree 和CSSOM结合，生成Rendering Tree(渲染树)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们修改了一些元素的颜色或者背景色，页面就会重绘(Repaint)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当我们修改元素的尺寸，页面就会回流(Reflow)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当页面需要Repaing和Reflow时GUI线程执行，绘制页面&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;回流(Reflow)比重绘(Repaint)的成本要高，我们要尽量避免Reflow和Repaint&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;GUI渲染线程与JS引擎线程是互斥的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当JS引擎执行时GUI线程会被挂起(相当于被冻结了)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;JS引擎线程&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JS引擎线程就是JS内核，负责处理Javascript脚本程序(例如V8引擎)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JS引擎线程负责解析Javascript脚本，运行代码&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JS引擎一直等待着任务队列中任务的到来，然后加以处理&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器同时只能有一个JS引擎线程在运行JS程序，所以js是单线程运行的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个Tab页(renderer进程)中无论什么时候都只有一个JS线程在运行JS程序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;GUI渲染线程与JS引擎线程是互斥的，js引擎线程会阻塞GUI渲染线程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;就是我们常遇到的JS执行时间过长，造成页面的渲染不连贯，导致页面渲染加载阻塞(就是加载慢)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例如浏览器渲染的时候遇到&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，就会停止GUI的渲染，然后js引擎线程开始工作，执行里面的js代码，等js执行完毕，js引擎线程停止工作，GUI继续渲染下面的内容。所以如果js执行时间太长就会造成页面卡顿的情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;事件触发线程&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;属于浏览器而不是JS引擎，用来控制事件循环，并且管理着一个事件队列(task queue)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当js执行碰到事件绑定和一些异步操作(如setTimeOut，也可来自浏览器内核的其他线程，如鼠标点击、AJAX异步请求等)，会走事件触发线程将对应的事件添加到对应的线程中(比如定时器操作，便把定时器事件添加到定时器线程)，等异步事件有了结果，便把他们的回调操作添加到事件队列，等待js引擎线程空闲时来处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为JS是单线程，所以这些待处理队列中的事件都得排队等待JS引擎处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;定时触发器线程&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;setInterval&lt;/code&gt;与&lt;code&gt;setTimeout&lt;/code&gt;所在线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器定时计数器并不是由JavaScript引擎计数的(因为JavaScript引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过单独线程来计时并触发定时(计时完毕后，添加到事件触发线程的事件队列中，等待JS引擎空闲后执行)，这个线程就是定时触发器线程，也叫定时器线程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;W3C在HTML标准中规定，规定要求&lt;code&gt;setTimeout&lt;/code&gt;中低于4ms的时间间隔算为4ms&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;异步http请求线程&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在XMLHttpRequest在连接后是通过浏览器新开一个线程请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由JavaScript引擎执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简单说就是当执行到一个http异步请求时，就把异步请求事件添加到异步请求线程，等收到响应(准确来说应该是http状态变化)，再把回调函数添加到事件队列，等待js引擎线程来执行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴可以浏览下以下系列相关文章，后续会深入浏览器的解析渲染进行展开（欢迎点赞+关注）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于本文&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：凌凌柒哦&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;https://juejin.cn/post/7137955193009733646&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;h2 data-id=&quot;heading-13&quot;&gt;最后&lt;/h2&gt;&lt;pre&gt;&lt;p data-darkmode-color-16057140139831=&quot;rgb(162, 162, 162)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(68, 68, 68)&quot; data-style=&quot;padding-top: 7px; padding-bottom: 7px; color: rgb(68, 68, 68); font-size: 14px; line-height: 1.8; font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Lucida Grande&amp;quot;, Arial, &amp;quot;Hiragino Sans GB&amp;quot;, 微软雅黑, &amp;quot;WenQuanYi Micro Hei&amp;quot;, STHeiti, SimSun, sans-serif; text-align: center;&quot;&gt;&lt;span&gt;加我微信，拉你进前端进阶、面试交流群，互相监督学习进步等！&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(63, 63, 63)&quot; data-style=&quot;color: rgb(63, 63, 63); font-family: monospace; font-size: 20px; letter-spacing: 0.544px; white-space: pre-wrap; widows: 1; caret-color: rgb(51, 51, 51);&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2842304060434373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/MDPRplBm9ZWibjvKriapPYw7494Tah6ESd6hXNqYLibwXYc1dJy9myWia0wImNM8RaGu8pkibaywtKMXOVGu8pfOOQg/640?wx_fmt=jpeg&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;jpeg&quot; data-w=&quot;1059&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐链接&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&amp;amp;mid=2247485013&amp;amp;idx=1&amp;amp;sn=9324e663eb2d6ed02a2f167e12b56692&amp;amp;chksm=c20c7aa1f57bf3b7f7e00ecc07d753a201ea08da5ad083dc5f70adc8553ef731f9e295afe8a2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;TypeScript中 interface 和 type 的区别，你真的懂了吗&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;TypeScript中 interface 和 type 的区别，你真的懂了吗&lt;/a&gt;？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkyOTE5NzQ2Nw==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=09322752bb7e63dea5286f9a0c51164a&amp;amp;chksm=c20c7a59f57bf34f2142aef77367ec01e1cd2471637920f48f53552eafcca8b35f93625eaec9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2022年，前端er们都在看哪些网站？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;2022年，前端er们都在看哪些网站？&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li/&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile data-index=&quot;1&quot; data-id=&quot;MzkyOTE5NzQ2Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/MDPRplBm9ZVicvbRDVk8icbaWUEAAx9CnmXUiaRLuNLTYSbfJQHeuJJ4uzmS0Ipy2IgK8He2AUSD4sUaGYk7kRFtw/0?wx_fmt=png&quot; data-nickname=&quot;前端界&quot; data-alias=&quot;&quot; data-signature=&quot;高质量文章分享、实践干货、技术前沿、学习资料， 你感兴趣的都在前端界&quot; data-origin_num=&quot;10&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot; class=&quot;js_wx_tap_highlight&quot; data-from=&quot;2&quot; has-insert-preloading=&quot;1&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创作不易，&lt;/span&gt;&lt;strong&gt;加个&lt;/strong&gt;&lt;strong&gt;点赞、在看&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;支持一下&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>