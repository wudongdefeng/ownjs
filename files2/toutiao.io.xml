<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c1beff8dd6b77ee3f3d1c287aad90ca2</guid>
<title>彻底学透 Redis，建议收藏</title>
<link>https://toutiao.io/k/dtraxtu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你好，我叫码哥，可以叫我靓仔&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 管道&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们通常使用 Redis 的方式是，发送命令，命令排队，Redis 执行，然后返回结果，这个过程称为Round trip time(简称RTT, 往返时间)。但是如果有多条命令需要执行时，需要消耗 N 次 RTT，经过 N 次 IO 传输，这样效率明显很低。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是 Redis 管道（pipeline）便产生了，一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将&lt;em&gt;多个命令&lt;/em&gt;发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），减少了 RTT，提升了效率&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;重要说明&lt;/strong&gt;: 使用管道发送命令时，服务器将被迫回复一个队列答复，占用很多内存。所以，如果你需要发送大量的命令，最好是把他们按照合理数量分批次的处理，例如10K的命令，读回复，然后再发送另一个10k的命令，等等。这样速度几乎是相同的，但是在回复这10k命令队列需要非常大量的内存用来组织返回数据内容。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 发布订阅&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;发布订阅是一种消息模式，发送者（sub）发送消息，订阅者（pub）接收消息&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7328687572590011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jZCicJY2ug3olFfZ7m0Y8IQI3icBoURp9Ihp5wllFxAf96ssnIu9gfWvw/640?wx_fmt=png&amp;amp;random=0.16124612770612146&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示，发布订阅基于频道实现的，同一个频道可以有多个订阅者，多个发布者。其中任意一个发布者发布消息到频道中，所以订阅者都可以收到该消息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;发布订阅 Redis 演示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我在服务器上启动了 4 个 Redis 客户端，2 个订阅者，2 个发布者，订阅者订阅的频道为 channel01&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3234946871310508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jZkaOyHtyr5unPFBibkhESFX0kiby74uJPpEMQ8Jl4qFoT2icZ7UuD1aTw/640?wx_fmt=png&amp;amp;random=0.5331072286879976&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：发布者 1 往 channel01 中发送消息 &quot;wugongzi&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35798319327731093&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j7miciciaZQjnwXw4LDiaPmlhs6PYNeJRf2cYw4piaewmCQB2MgoMMvfBLxA/640?wx_fmt=png&amp;amp;random=0.7107839681184107&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 1 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6912114014251781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jxjicZXU82hzuFmLIdswWegyic7icGswyE0IEsV3JPQ3lESZGJVvaPPN9w/640?wx_fmt=png&amp;amp;random=0.932801702642438&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;421&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 2 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7142857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j2jeG6bmibrRhMkKrvqo9G2jH3GsZbu0hOOFHVoib5sqwkSHjKYQOPKKA/640?wx_fmt=png&amp;amp;random=0.2957567053663015&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：发布者 2 往频道中发布消息 &quot;hello-redis&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2148962148962149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jhl56JNzQ6mZDdibwT1K4FnEv2A48IMGhbtPWtWQl0OBosZaOrTShIBg/640?wx_fmt=png&amp;amp;random=0.4554117703504412&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 1 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9268867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jVYoianCF0YXJIePphNuxXKSq3NoZnzMZ7QjZS2vkbs2CRZRLlwt0p2w/640?wx_fmt=png&amp;amp;random=0.4084262064096338&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;订阅者 2 收到消息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9147465437788018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jNwN3gyNJSDbJX0kNhsEkZeciaiaZZ6t0gmAR7cRMwNTuRTKbwsDXIgEw/640?wx_fmt=png&amp;amp;random=0.0549752796242815&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 同时支持订阅多个频道：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7017114914425427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jic6iaicrMLMmLmWDYHicbiakibiaBYWl2XRaRJGv3YicT8icICWicuhpicscfpIqg/640?wx_fmt=png&amp;amp;random=0.3368015515822096&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 过期策略&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过期时间使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 可以给每个 key 都设置一个过期时间，过期时间到达后，Redis 会自动删除这个 key。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际生产中，我们还是要求必须要为每个 Redis 的 Key 设置一个过期时间，如果不设置过期时间，时间一久，Redis 内存就会满了，有很多冷数据，依然存在。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设置过期时间的命令：EXPIRE key seconds&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用过程中有一点需要注意，就是在每次更新 Redis 时，都需要重新设置过期时间，如果不设置，那个 key 就是永久的，下面给大家演示一下如何使用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.475177304964539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jyoMGV6MiaehDicQx1iaesvbNnb7nklDYoTBdzz6JY3aw2HvD8OuHuUiaicw/640?wx_fmt=png&amp;amp;random=0.5586942244204203&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;423&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过期删除策略&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis keys过期有两种方式：被动和主动方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一些客户端尝试访问过期 key 时，Redis 发现 key 已经过期便删除掉这些 key&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，这样是不够的，因为有些过期的 keys，可能永远不会被访问到。 无论如何，这些 keys 应该过期，所以 Redis 会定时删除这些 key&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体就是Redis每秒10次做的事情：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;测试随机的20个keys进行相关过期检测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除所有已经过期的keys。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果有多于25%的keys过期，重复步奏1&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个平凡的概率算法，基本上的假设是，Redis的样本是这个密钥控件，并且我们不断重复过期检测，直到过期的keys的百分百低于25%,这意味着，在任何给定的时刻，最多会清除1/4的过期keys。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事务基本使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务可以一次执行多条命令，Redis 事务有如下特点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 事务通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MULTI&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;EXEC&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;DISCARD&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;WATCH&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 几个命令来实现，MULTI 命令用于开启事务，EXEC 用于提交事务，DISCARD 用于放弃事务，WATCH 可以为 Redis 事务提供 check-and-set （CAS）行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0227920227920229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jL1W3E9nJM0b4s8Sic8deBmks2FaeKKiaIEzzg0vvvfxHEv6OITCyjodQ/640?wx_fmt=png&amp;amp;random=0.3889124070730787&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事务发生错误&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reids 事务发生错误分为两种情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：事务提交前发生错误，也就是在发送命令过程中发生错误，看演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5039494470774092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j6gpNicNVZgpHlZR3J0iaQSicqtFylGhZ7NlMcZofnMeqQaZnNcWdJI0Jg/640?wx_fmt=png&amp;amp;random=0.5303901933630635&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我故意将 incr 命令写错，从结果我们可以看到，这条 incr 没有入队，并且事务执行失败，k1 和 k2 都没有值&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：事务提交后发生错误，也就是在执行命令过程中发生错误，看演示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5287569573283859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0juz7HgSwuGGlnicmR86kauLxjIMniaiae1y8eicHZIHK4VicStOs0oZZcPLQ/640?wx_fmt=png&amp;amp;random=0.6915067831550987&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的事务命令中，我给 k1 设置了一个 d，然后执行自增命令，最后获取 k1 的值，我们发现第二条命令执行发生了错误，但是整个事务依然提交成功了，从上面现象中可以得出，&lt;strong&gt;Redis 事务不支持回滚操作&lt;/strong&gt;。如果支持的话，整个事务的命令都不应该被执行。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么 Redis 不支持回滚&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下是这种做法的优点：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 incr 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 incr ， 回滚是没有办法处理这些情况的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;放弃事务&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当执行 discard 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0038022813688212&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jMTgZ90Zl59k768hnd4d0Ja0C8T1hrBAF0V7ZiagKmYtRlicOeeelibvPQ/640?wx_fmt=png&amp;amp;random=0.4380218120697472&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;263&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WATCH 命令使用&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;watch 使得 exec 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8434504792332268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jvEgFnL0ia3puuA1ZkSFbd5fZ91W20Ev5QDdibqibvyK37SgUjOLNvLyXQ/640?wx_fmt=png&amp;amp;random=0.7640523923259128&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;313&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面我用 watch 命令监听了 k1 和 k2，然后开启事务，在事务提交之前，k1 的值被修改了，watch 监听到 k1 值被修改，所以事务没有被提交。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 脚本和事务&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reids 持久化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么需要持久化&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道 Redis 是内存数据库，主打高性能，速度快。相比 Redis 而言，MySQL 的数据则是保存再硬盘中（其实也有内存版的 MySQL 数据库，但是价格极其昂贵，一般公司不会使用），速度慢，但是稳定性好。你想想 Redis 数据保存在内存中，一旦服务器宕机了，数据岂不是全部都没了，这将会出现很大问题。所以 Redis 为了弥补这一缺陷，提供数据持久化机制，即使服务器宕机，依然可以保证数据不丢失。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;持久化简介&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 提供了两种持久化机制 RDB 和 AOF，适用于不同场景&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据,AOF命令以redis协议追加保存每次写的操作到文件末尾.Redis还能对AOF文件进行后台重写,使得AOF文件的体积不至于过大&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB 持久化是通过在指定时间间隔对数据进行快照，比如在 8 点钟对数据进行持久化，那么 Redis 会 fork 一个子进程将 8 点那一刻内存中的数据持久化到磁盘上。触发 RDB 持久化有以下几种方法&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 持久化方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、执行 save 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行 save 命令进行持久会阻塞 Redis，备份期间 Redis 无法对外提供服务，&lt;strong&gt;一般不建议使用&lt;/strong&gt;，使用场景为 Redis 服务器需要停机维护的情况下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、执行 bgsave 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;bgsave 命令不会阻塞 Redis 主进程，持久化期间 Redis 依然可以正常对外提供服务&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、通过配置文件中配置的 save 规则来触发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4558303886925795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j4LhazAicrsjibhdSwxVGRsv47NQX7iazEHWELzBztT7uvibFoib1TwianFsQ/640?wx_fmt=png&amp;amp;random=0.16968829594073265&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;283&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 900 1：900s 内有 1 个 key 发生变化，则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 300 10：300s 内有 10 个 key 发生变化，则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save 60 10000：60s 内有 10000 个 key 发生变化（新增、修改、删除），则触发 RDB 快照&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;save &quot;&quot;：该配置表示关闭 RDB 持久化&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 持久化原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 进行 RDB 时，会 fork 一个子进程来进行数据持久化，这样不妨碍 Redis 继续对外提供服务，提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;曾经面试官出过这样面试题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如 Redis 在 8 点触发了 RDB 持久化，持久化用时 2 分钟，在持久化期间，Redis 中有 100 个 key 被修改了，那么 RDB 文件中的 key 是 8 点那一刻的数据，还是变化的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先不要看答案，自己思考 1 分钟，一个问题只有你自己思考了，才能印象深刻。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，下面我们一起来看下这张图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5009107468123861&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jl5WibYNL8NC5GMbBswQcTiawQeqMgqY8Hjs40snVYjYtOVEAc0L3BovA/640?wx_fmt=png&amp;amp;random=0.4056195687710038&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1098&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中我们可以清晰的看到，Redis 备份时，fork 了一个子进程，子进程去做持久化的工作，子进程中的 key 指向了 8 点那一刻的数据，后面 k1 的值修改了，redis 会在内存中创建一个新的值，然后主进程 k1 指针指向新的值，子进程 k1 指针依然指向 19，这样 Redis 持久化的就是 8 点那一刻的数据，不会发生变化。同时，从图中我们也可以看到，Redis 持久化时并不是将内存中数据全部拷贝一份进行备份。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB 优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;RDB是一个非常紧凑的文件,它保存了某个时间点得数据集,非常适用于数据集的备份,比如你可以在每个小时报保存一下过去24小时内的数据,同时每天保存过去30天的数据,这样即使出了问题你也可以根据需求恢复到不同版本的数据集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程,接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果备份间隔时间较长，RDB 会丢失较多的数据。比如 8 点备份一次，8 点半服务器宕机，那么这半小时内的数据就会丢失了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF 持久化是通过日志的方式，记录每次 Redis 的写操作。当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以Redis 协议追加保存每次写的操作到文件末尾。Redis 还能对 AOF 文件进行后台重写，使得 AOF 文件的体积不至于过大&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 持久化配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 是否开启 aof no：关闭；yes: 开启&lt;/span&gt;&lt;br/&gt;appendonly no&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 文件名&lt;/span&gt;&lt;br/&gt;appendfilename &lt;span&gt;&quot;appendonly.aof&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 同步策略&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# appendfsync always  # 每个命令都写入磁盘，性能较差&lt;/span&gt;&lt;br/&gt;appendfsync everysec  &lt;span&gt;# 每秒写一次磁盘，Redis 默认配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# appendfsync no      # 由操作系统执行，默认Linux配置最多丢失30秒&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 重写期间是否同步&lt;/span&gt;&lt;br/&gt;no-appendfsync-on-rewrite no&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 重写触发策略&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-percentage 100 &lt;span&gt;# 触发重写百分比 （指定百分比为0，将禁用aof自动重写功能）&lt;/span&gt;&lt;br/&gt;auto-aof-rewrite-min-size 64mb &lt;span&gt;# 触发自动重写的最低文件体积（小于64mb不自动重写）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加载aof时如果有错如何处理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 no ，发现错误就会停止，必须修复后才能重新加载。&lt;/span&gt;&lt;br/&gt;aof-load-truncated yes&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# aof 中是否使用 rdb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 开启该选项，触发AOF重写将不再是根据当前内容生成写命令。而是先生成RDB文件写到开头，再将RDB生成期间的发生的增量写命令附加到文件末尾。&lt;/span&gt;&lt;br/&gt;aof-use-rdb-preamble yes&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 文件写入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;aof 文件是命令追加的方式，先将命令写入缓冲区，时间到了再写如磁盘中&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;appendfsync always    &lt;span&gt;# 每个命令都写入磁盘，性能较差&lt;/span&gt;&lt;br/&gt;appendfsync everysec  &lt;span&gt;# 每秒写一次磁盘，Redis 默认配置&lt;/span&gt;&lt;br/&gt;appendfsync no        &lt;span&gt;# 由操作系统执行，默认Linux配置最多丢失30秒&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面配置就是何时写入磁盘中&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 重写&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;aof 文件虽然丢失的数据少，但是随着时间的增加，aof 文件体积越来越大，占用磁盘空间越来越大，恢复时间长。所以 redis 会对 aof 文件进行重写，以减少 aof 文件体积&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面以一个例子说明&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-- 重写前的 aof&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 20&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 40&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 35&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k3 34&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 19&lt;br/&gt;&lt;br/&gt;-- 这里 k1 最终的值为 35，k2 最终值为 19，所以不需要写入两个命令&lt;br/&gt;-- 重写后&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k1 35&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k3 34&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; k2 19&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;混合持久化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Redis 4.0 版本开始，引入了混合持久化机制，纯AOF方式、RDB+AOF方式，这一策略由配置参数&lt;/span&gt;&lt;code&gt;&lt;span&gt;aof-use-rdb-preamble&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（使用RDB作为AOF文件的前半段）控制，默认关闭(no)，设置为yes可开启&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;no：按照AOF格式写入命令，与4.0前版本无差别；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;yes：先按照RDB格式写入数据状态，然后把重写期间AOF缓冲区的内容以AOF格式写入，文件前半部分为RDB格式，后半部分为AOF格式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混合持久化优点如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;大大减少了 aof 文件体积&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快了 aof 文件恢复速度，前面是 rdb ，恢复速度快&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 数据恢复&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一种：纯 AOF&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恢复时，取出 AOF 中命令，一条条执行恢复&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二种：RDB+AOF&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先执行 RDB 加载流程，执行完毕后，再取出余下命令，开始一条条执行&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF 优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 实时性更好，丢失数据更少&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 已经支持混合持久化，文件大小可以有效控制，并提高了数据加载时的效率&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于相同的数据集合，AOF 文件通常会比 RDB 文件大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在特定的 fsync 策略下，AOF 会比 RDB 略慢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AOF 恢复速度比 RDB 慢&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式锁介绍&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;学习过 Java 的同学，应该对锁都不陌生。Java 中多个线程访问共享资源时，会出现并发问题，我们通常利用 synchronized 或者 Lock 锁来解决多线程并发访问从而出现的安全问题。细心的同学可能已经发现了， synchronized 或者 Lock 锁解决线程安全问题在单节点情况下是可行的，但是如果服务部署在多台服务器上，本地锁就失效了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式场景下，需要采用新的解决方案，就是今天要说的 Redis 分布式锁。日常业务中，类似抢红包，秒杀等场景都可以使用 Redis 分布式锁来解决并发问题。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式锁特点&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式在保障安全、高可用的情况下需要具备以下特性&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;互斥性：任意一个时刻，只能有一个客户端获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性：锁只能被持久的客户端删除，不能被其他人删除&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高可用，高性能：加锁和解锁消耗的性能少，时间短&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;锁超时：当客户端获取锁后出现故障，没有立即释放锁，该锁要能够在一定时间内释放，否则其他客户端无法获取到锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可重入性：客户端获取到锁后，在持久锁期间可以再次获取到该锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案一：SETNX 命令&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 提供了一个获取分布式锁的命令 SETNX&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;setnx key value&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果获取锁成功，redis 返回 1，获取锁失败 redis 返回 0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5354523227383863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jdqtYzLiaT4G7HKEIx52aSSTWcIm8e5Ze7Auu7lfiazAMQZh04Y2SAoUQ/640?wx_fmt=png&amp;amp;random=0.18636350476979135&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;客户端使用伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1,v1) == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 执行逻辑&lt;/span&gt;&lt;br/&gt;     ....&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt;() {&lt;br/&gt;        &lt;br/&gt;    }&lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 执行完成后释放锁&lt;/span&gt;&lt;br/&gt;        del k1;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个命令看似可以达到我们的目的，但是不符合分布式锁的特性，如果客户端在执行业务逻辑过程中，服务器宕机了，finally 中代码还没来得及执行，锁没有释放，也就意味其他客户端永远无法获取到这个锁&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案二：SETNX + EXPIRE&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该方案获取锁之后，立即给锁加上一个过期时间，这样即使客户端没有手动释放锁，锁到期后也会自动释放&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0223463687150838&quot; data-type=&quot;png&quot; data-w=&quot;358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jSRSFuy6ic1onxOznjH5phM2mbMiaia7xibPJ7ZAjMjnLG50jIgkprUPJibw/640?wx_fmt=png&amp;amp;random=0.7840977315093971&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们来看下伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1, v1) == &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    expire(key, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;//.... 你的业务逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个方案很完美，既可以获取到，又不用担心客户端宕机。等等，这里面真的没有问题吗？再仔细瞅瞅，一瞅就瞅出问题来了&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (setnx(k1, v1) == &lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;// 再刚获取锁之后，想要给锁设置过期时间，此时服务器挂了&lt;/span&gt;&lt;br/&gt;    expire(key, &lt;span&gt;10&lt;/span&gt;); &lt;span&gt;// 这条命令没有执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;//.... 你的业务逻辑&lt;/span&gt;&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的 setnx 命令和 expire 命令不是原子性的，他们之间执行需要一定的等等时间，虽然这个时间很短，但是依然有极小概率出现问题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;使用 Lua 脚本&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然 setnx 和 expire 两个命令非原子性，那么我们让其符合原子性即可，通过 Lua 脚本即可实现。Redis 使用单个 Lua 解释器去运行所有脚本，并且， Redis 也保证脚本会以原子性(atomic)的方式执行： 当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体实现如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&#x27;setnx&#x27;&lt;/span&gt;,KEYS[1],ARGV[1]) == 1 &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;   redis.call(&lt;span&gt;&#x27;expire&#x27;&lt;/span&gt;,KEYS[1],ARGV[2])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样应该没问题了吧，看似上面的几个问题都很好解决了。不对，再想想，肯定还有没考虑到的&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再来看一段伪代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// 执行 lua 脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取 k1 锁，过期时间 10 s&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (execlua()==&lt;span&gt;1&lt;/span&gt;){&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        buyGoods();&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        del(key);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6255380200860832&quot; data-type=&quot;png&quot; data-w=&quot;1394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j0hPSJVFIcbu3icBuSMmr1ajZuPSEMbjePz9a9tS9E3OvhzSplxB8n3Q/640?wx_fmt=png&amp;amp;random=0.6737068050849393&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中我们可以很清晰发现问题所在&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;客户端 A 还未执行完毕，客户端 B 就获取到了锁，这样就可能导致并发问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端 A 执行完毕，开始删除锁。但此时的锁为 B 所有，相当于删除了属于客户端 B 的锁，这样肯定会发生问题&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;方案四：SET EX PX NX + 校验唯一随机值，再删除&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然锁有可能被别的客户端删除，那么在删除锁的时候我们加上一层校验，判断释放锁是当前客户端持有的，如果是当前客户端，则允许删除，否则不允许删除。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;EX second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：设置键的过期时间为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 秒。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value EX second&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SETEX key second value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PX millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：设置键的过期时间为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 毫秒。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value PX millisecond&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PSETEX key millisecond value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：只在键不存在时，才对键进行设置操作。 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SET key value NX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 效果等同于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SETNX key value&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;XX&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ：只在键已经存在时，才对键进行设置操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;（jedis.set(resource_name, random_value, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;EX&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;s) == &lt;span&gt;1&lt;/span&gt;）{ &lt;span&gt;//加锁, value 传入一个随机数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;do&lt;/span&gt; something  &lt;span&gt;//业务处理&lt;/span&gt;&lt;br/&gt;    }&lt;span&gt;catch&lt;/span&gt;(){&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;       &lt;span&gt;// 判断 value 是否相等, 相等才释放锁, 这里判断和删除是非原子性, 真实场景下可以将这两步放入 Lua 脚本中执行&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;if&lt;/span&gt; (random_value.equals(jedis.get(resource_name))) {&lt;br/&gt;         jedis.del(lockKey); &lt;span&gt;//释放锁&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lua 脚本如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; redis.call(&lt;span&gt;&quot;get&quot;&lt;/span&gt;,KEYS[1]) == ARGV[1] &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; redis.call(&lt;span&gt;&quot;del&quot;&lt;/span&gt;,KEYS[1])&lt;br/&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0&lt;br/&gt;end&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此方案解决了锁被其他客户端解除的问题，但是依然没有解决锁过期释放，但是业务还没有执行完成的问题&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redisson框架&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案四中并没有解决方法未执行完成，锁就超时释放的问题。这里有个方案大家比较容易想到，那就是锁的超时时间设置长一点，比如2min，一个接口执行时间总不能比 2 min 还长，那你就等着领盒饭吧，哈哈哈。但是这么做，一来是不能每个锁都设置这么久超时时间，二来是如果接口出现异常了，锁只能 2 min 后才能释放，其他客户端等待时间较长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题早就有人想到了，并给出了解决方案，开源框架 Redisson 解决了这个问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5883084577114428&quot; data-type=&quot;png&quot; data-w=&quot;804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j6WBlCKQ5WddXCQFOAIE7oWCIsCDGU8FrgBEW3fL3jyx6R1xISsaQtw/640?wx_fmt=png&amp;amp;random=0.8792207864280699&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redisson 在方法执行期间，会不断的检测锁是否到期，如果发现锁快要到期，但是方法还没有执行完成，便会延长锁的过期时间，从而解决了锁超时释放问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redlock&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面所介绍的分布式锁，都是在单台 Redis 服务器下的解决方案。真实的生产环境中，我们通常会部署多台 Redis 服务器，也就是集群模式，这种情况上述解决方案就失效了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于集群 Redis，Redis 的作者 antirez 提出了另一种解决方案，Redlock 算法&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redlock 算法大致流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7625&quot; data-type=&quot;png&quot; data-w=&quot;640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0juIt0zaKPMW5QHFXuLrUe8MG8y4T6LQF8TaHxWKjdftANuoHw4A4Qow/640?wx_fmt=png&amp;amp;random=0.4016757215005047&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、获取当前Unix时间，以毫秒为单位。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、如果因为某些原因，获取锁失败（&lt;em&gt;没有&lt;/em&gt;在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt; 简单总结一下就是客户端向 Redis 集群中所有服务器发送获取锁的请求，只有半数以上的锁获取成功后，才代表锁获取成功，否则锁获取失败。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群的三种模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在生产环境中，我们使用 Redis 通常采用集群模式，因为单机版 Redis 稳定性可靠性较低，而且存储空间有限。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 支持三种集群模式&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制模式，有一个主，多个从，从而实现读写分离。主机负责写请求，从机负责读请求，减轻主机压力&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26366120218579236&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jhhYEMnsCdQJzn6pe3icLwxfZWjAgSd1PQuRVeibKfHx39c44eHsdymRg/640?wx_fmt=png&amp;amp;random=0.22686800259705708&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5512295081967213&quot; data-type=&quot;png&quot; data-w=&quot;976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTOcoPpZzhQLHqvVOh5yd9giaCFbXNEfqUgXIN8IohEpwkvaVibz74MaA/640?wx_fmt=png&amp;amp;random=0.6779851845067002&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从数据库启动成功后，连接主数据库，发送 SYNC 命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库接收到 SYNC 命令后，开始执行 BGSAVE 命令生成 RDB 文件并使用缓冲区记录此后执行的所有写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库 BGSAVE 执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库收到快照文件后丢弃所有旧数据，载入收到的快照；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库完成对快照的载入，开始接收命令请求，并执行来自主数据库缓冲区的写命令；（&lt;strong&gt;从数据库初始化完成&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令（&lt;strong&gt;从数据库初始化完成后的操作&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出现断开重连后，2.8之后的版本会将断线期间的命令传给重数据库，增量复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。Redis 的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从复制优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持主从复制，主机会自动将数据同步到从机，可以进行读写分离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Slave 同样可以接受其它 Slaves 的连接和同步请求，这样可以有效的分载 Master 的同步压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Master Server 是以非阻塞的方式为 Slaves 提供服务。所以在 Master-Slave 同步期间，客户端仍然可以提交查询或修改请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主从不具备容错和恢复能力，一旦主机挂了，那么整个集群处理可读状态，无法处理写请求，会丢失数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主机宕机后无法自动恢复，只能人工手动恢复&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群存储容量有限，容量上线就是主库的内存的大小，无法存储更多内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;###哨兵集群&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵，我们经常在电视剧中看到一些放哨的，哨兵的作用和这些放哨的差不多，起到监控作用。一旦 Redis 集群出现问题了，哨兵会立即做出相应动作，应对异常情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式是基于主从复制模式上搭建的，因为主从复制模式情况下主服务器宕机，会导致整个集群不可用，需要人工干预，所以哨兵模式在主从复制模式下引入了哨兵来监控整个集群，哨兵模式架构图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7422818791946308&quot; data-type=&quot;png&quot; data-w=&quot;745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jtuMzqm4enkY4fyBYEmbsVaXhcnAC1QS0jmahdLD5DQfyjGg27HP4Zw/640?wx_fmt=png&amp;amp;random=0.378912921304267&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;监控（Monitoring）&lt;/strong&gt;：哨兵会不断地检查主节点和从节点是否运作正常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;自动故障转移（Automatic failover）&lt;/strong&gt;：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;配置提供者（Configuration provider）&lt;/strong&gt;：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;通知（Notification）&lt;/strong&gt;：哨兵可以将故障转移的结果发送给客户端。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;下线判断&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 下线分为主观下线和客观下线两种&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主观下线：单台哨兵任务主库处于不可用状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客观下线：整个哨兵集群半数以上的哨兵都认为主库处于可不用状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵集群中任意一台服务器判断主库不可用时，此时会发送命令给哨兵集群中的其他服务器确认，其他服务器收到命令后会确认主库的状态，如果不可用，返回 YES，可用则返回 NO，当有半数的服务器都返回 YES，说明主库真的不可用，此时需要重新选举&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5426356589147286&quot; data-type=&quot;jpeg&quot; data-w=&quot;2322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jnlOibfic8iblejg3B4kibY2nP67I9bN0jhoHd8p3WgXLwdtsGP40qqm1vg/640?wx_fmt=jpeg&amp;amp;random=0.9688652998736997&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主库选举&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当哨兵集群判定主库下线了，此时需要重新选举出一个新的主库对外提供服务。那么该由哪个哨兵来完成这个新库选举和切换的动作呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意：这里不能让每个哨兵都去选举，可能会出现每个哨兵选举出的新主库都不同，这样就没法判定，所以需要派出一个代表&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵代表选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵的选举机制其实很简单，就是一个Raft选举算法： &lt;strong&gt;选举的票数大于等于num(sentinels)/2+1时，将成为领导者，如果没有超过，继续选举&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;任何一个想成为 Leader 的哨兵，要满足两个条件：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第一，拿到半数以上的赞成票；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以 3 个哨兵为例，假设此时的 quorum 设置为 2，那么，任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;新库选择&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面已经选举出了哨兵代表，此时代表需要完成新主库的选择，新库的选择需要满足以下几个标准&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新库需要处于健康状态，也就是和哨兵之间保持正常的网络连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择&lt;/span&gt;&lt;code&gt;&lt;span&gt;salve-priority&lt;/span&gt;&lt;/code&gt;&lt;span&gt;从节点优先级最高（redis.conf）的&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择复制偏移量最大，只复制最完整的从节点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面一小节哨兵已经选举出了新的主库，故障转移要实现新老主库之间的切换&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;故障转移流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5997830802603037&quot; data-type=&quot;png&quot; data-w=&quot;922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTia9m3qSAe6O5Q689Hxricjmpl4Hib4hEOuDd5QLicBjHQKbt1ybeloIuw/640?wx_fmt=png&amp;amp;random=0.5338738046927538&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵模式优缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;实现了集群的监控，故障转移，实现了高可用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥有主从复制模式的所有优点&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;集群存储容量有限，容量上线就是主库的内存的大小，无法存储更多内容&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cluser 集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 的哨兵模式实现了高可用了，但是每台 Redis 服务器上存储的都是相同的数据，浪费内存，而且很难实现容量上的扩展。所以在 redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，&lt;strong&gt;也就是说每台 Redis 节点上存储不同的内容&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Redis 集群的数据分片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群没有使用一致性hash, 而是引入了 &lt;strong&gt;哈希槽&lt;/strong&gt;的概念.&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;节点 A 包含 0 到 5500号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点 B 包含5501 到 11000 号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;节点 C 包含11001 到 16384号哈希槽.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我想移除节点A,需要将A中的槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 集群实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;环境：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vmware 虚拟机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CentOS 7&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis 6.0.6&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为我是在本机上演示的，所以用的虚拟机&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集群信息如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置文件&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;master&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6379.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6380.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6381.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：准备三个 redis.conf 配置文件，配置文件信息如下&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# redis6379.conf    master&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 包含命令，有点复用的意思&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6379.pid&lt;br/&gt;port    6379&lt;br/&gt;dbfilename dump6379.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6379.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis6380.conf    slave1&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6380.pid&lt;br/&gt;port    6380&lt;br/&gt;dbfilename dump6380.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6380.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 最后一行设置了主节点的 ip 端口&lt;/span&gt;&lt;br/&gt;replicaof 127.0.0.1 6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# redis6381.conf    slave2&lt;/span&gt;&lt;br/&gt;include /soft/redis6.0.6/bin/redis.conf&lt;br/&gt;pidfile redis_6381.pid&lt;br/&gt;port    6381&lt;br/&gt;dbfilename dump6381.rdb&lt;br/&gt;logfile &lt;span&gt;&quot;redis-6381.log&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 最后一行设置了主节点的 ip 端口&lt;/span&gt;&lt;br/&gt;replicaof 127.0.0.1 6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;## 注意 redis.conf 要调整一项，设置后台运行，对咱们操作比较友好&lt;/span&gt;&lt;br/&gt;daemonize yes&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：启动服务器&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-- 首先启动 6379 这台服务器，因为他是主库（启动命令在 redis 安装目录的 bin 目录下）&lt;br/&gt;../bin/redis-server redis6379.conf&lt;br/&gt;-- 接口启动 6380 和 6381&lt;br/&gt;../bin/redis-server redis6380.conf&lt;br/&gt;../bin/redis-server redis6381.conf&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三步：用客户端连接服务器&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;cd&lt;/span&gt; bin&lt;br/&gt;redis-cli -p 6379&lt;br/&gt;redis-cli -p 6380&lt;br/&gt;redis-cli -p 6381&lt;br/&gt;&lt;br/&gt;这里我开了三个窗口分别连接三台 redis 服务器，方便查看&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 6379 客户端输入命令： info replication 可用查看集群信息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6642201834862386&quot; data-type=&quot;png&quot; data-w=&quot;545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jfKj0UTbV8cKA47Hn7zTDA7TzXwXMAtWb8VDSgMDukYUCZ40TchBwjQ/640?wx_fmt=png&amp;amp;random=0.4535142205236311&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第四步：数据同步&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在集群已经搭建好了，我们在 6379 服务器写入几条数据，看下可不可以同步到 6380 和 6381&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6379：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35128205128205126&quot; data-type=&quot;png&quot; data-w=&quot;390&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jwn62a33KeOC57m4Q2jEXwEbwfWFQHHVUWhdbmicyAhyqkGPS0LPUY4g/640?wx_fmt=png&amp;amp;random=0.7336346243927414&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6380：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5749318801089919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jWtAUeJZiaF0XPxtxDn889IefibLrBRd2y2MhC9TJOkiaxXbkmVckgsQyg/640?wx_fmt=png&amp;amp;random=0.9077540820945631&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;367&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;6381：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.361244019138756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jYe6b47x9SpoTEPwBpNMYpXib1BZnwxj6gV2285UnRiaEsDRMuzGpK98w/640?wx_fmt=png&amp;amp;random=0.7282853023446518&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;418&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中可用看出，数据已经成功同步了&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵集群是在主从复制的基础上构建的，相当于是主从+哨兵&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搭建哨兵模式分为两步：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;搭建主从复制集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加哨兵配置&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵模式节点信息如下，一主二从，三个哨兵组成一个哨兵集群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;master&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6379.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6380.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;slave2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis6381.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;6381&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel1.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26379&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel2.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26380&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;sentinel3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;sentinel3.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;26381&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从复制集群的配置同上，这里就不再赘述，下面主要介绍下哨兵的配置，哨兵的配置文件其实非常简单&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 文件内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# sentinel1.conf&lt;/span&gt;&lt;br/&gt;port 26379&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;span&gt;# sentinel2.conf&lt;/span&gt;&lt;br/&gt;port 26380&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;span&gt;# sentinel3.conf&lt;/span&gt;&lt;br/&gt;port 26381&lt;br/&gt;sentinel monitor mymaster 127.0.0.1 6379 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件创建好了以后就可以启动了，首先启动主从服务器，然后启动哨兵&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;../bin/redis-server redis6379.conf&lt;br/&gt;../bin/redis-server redis6380.conf&lt;br/&gt;../bin/redis-server redis6381.conf&lt;br/&gt;&lt;br/&gt;-- 启动哨兵&lt;br/&gt;../bin/redis-sentinel sentinel1.conf &lt;br/&gt;../bin/redis-sentinel sentinel2.conf &lt;br/&gt;../bin/redis-sentinel sentinel3.conf &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.377491961414791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0j5aIY6nOeibMW54njDI1Z0a5xIkFr6kP615AAWC3OoIDnMTVaSibagiaJA/640?wx_fmt=png&amp;amp;random=0.9036448846001819&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1555&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从哨兵的启动日志中我们可用看到主从服务器的信息，以及其他哨兵节点的信息&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从同步功能上面已经演示过了，这里主要测试一下哨兵的故障转移&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我手动将主节点停掉，在 6379 上执行 shutdown 命令&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时我们观察一下哨兵的页面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4626865671641791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jqADulpCE8oxo8hptgF6yh6RY9ZC1y45DewUv40dUB6O8nFfKMTcciaQ/640?wx_fmt=png&amp;amp;random=0.819906181075247&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1273&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵检测到了 6379 下线，然后选举出了新的主库 6380&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时我们通过 info replication 命令查看集群信息，发现 6380 已经是主库了，他有一个从节点 6381&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5098360655737705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jNEZLboicBicmLJEeDX7ibaPxjZxMw4DDW6Fk3fhpkibWiaArxtkD5CF6kyQ/640?wx_fmt=png&amp;amp;random=0.7949051846788313&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我手动将 6379 启动，看下 6379 会不会重新变成主库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4847605224963715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jYyhnHuDlLYlffBd0wQOcPHTWYLPdiaTkTo4u09wIia88JKGFsjx8tpBQ/640?wx_fmt=png&amp;amp;random=0.9967648860480147&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;689&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重新启动后，我们发现 6379 变成了 80 的从库&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cluser 集群&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官方推荐，Cluser 集群至少要部署 3 台以上的 master 节点，最好使用 3 主 3 从&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7001.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7001&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7002.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7002&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-master3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7003.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7003&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave1&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7004.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7004&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave2&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7006.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7005&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;cluster-slave3&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;redis7006.conf&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;7006&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置文件内容如下，6 个配置文件信息基本相同，编辑好一份后其他文件直接复制修改端口即可&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 端口&lt;/span&gt;&lt;br/&gt;port 7001  &lt;br/&gt;&lt;span&gt;# 启用集群模式&lt;/span&gt;&lt;br/&gt;cluster-enabled yes &lt;br/&gt;&lt;span&gt;# 根据你启用的节点来命名，最好和端口保持一致，这个是用来保存其他节点的名称，状态等信息的&lt;/span&gt;&lt;br/&gt;cluster-config-file nodes_7001.conf &lt;br/&gt;&lt;span&gt;# 超时时间&lt;/span&gt;&lt;br/&gt;cluster-node-timeout 5000&lt;br/&gt;appendonly yes&lt;br/&gt;&lt;span&gt;# 后台运行&lt;/span&gt;&lt;br/&gt;daemonize yes&lt;br/&gt;&lt;span&gt;# 非保护模式&lt;/span&gt;&lt;br/&gt;protected-mode no &lt;br/&gt;pidfile  redis_7001.pid&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后分别启动 6 个节点&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;../bin/redis-server redis7001.conf&lt;br/&gt;../bin/redis-server redis7002.conf&lt;br/&gt;../bin/redis-server redis7003.conf&lt;br/&gt;../bin/redis-server redis7004.conf&lt;br/&gt;../bin/redis-server redis7005.conf&lt;br/&gt;../bin/redis-server redis7006.conf&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动集群&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 执行命令&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# --cluster-replicas 1 命令的意思是创建master的时候同时创建一个slave&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006  --cluster-replicas 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动过程有个地方需要输入 yes 确认：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15089163237311384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jOLiavc7PkNSqb6mfNtTLjk6YeoI7fA2iafJsOIWnGGwJ3yYhTLPQomEA/640?wx_fmt=png&amp;amp;random=0.4605689354700546&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;启动成功后可用看到控制台输出结果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12996632996632998&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jHDj1JZ5qbGE2AVKBwbhedFFrCIcFF19KHbxas7XctfiaPQbWGrmzm5w/640?wx_fmt=png&amp;amp;random=0.04272848378632821&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1485&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 个 master 节点，3 个 slave 节点，&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[0]槽位：0-5460&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[1]槽位：5461-10922&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;master[2]槽位：10923-16383&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;数据验证&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;连接 7001 服务器&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis-cli -p 7001 -c 集群模式下需要加上 -c 参数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31281198003327787&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jTuUMTBctN3pIbSGoiblzHXp1RcKXBiakYJ4BnKstiaXSGJ9pPygcRNaicg/640?wx_fmt=png&amp;amp;random=0.9317448817045257&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;601&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从图中可用看出，k1 被放到 7003 主机上了，我们此时获取 k1 ，可用正常获取到&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;登录 7003 也可以正常拿到数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23382045929018788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaQurMdlahuWxJ6MGMIROg0jnNfzesxPoNsqKcbpNquBAxYwDSjBtLib7JcPrlFnZibUupxf30uX6Opg/640?wx_fmt=png&amp;amp;random=0.8581943808899719&amp;amp;tp=wxpic&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis 缓存问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在服务端中，数据库通常是业务上的瓶颈，为了提高并发量和响应速度，我们通常会采用 Redis 来作为缓存，让尽量多的数据走 Redis 查询，不直接访问数据库。同时 Redis 在使用过程中也会出现各种各样的问题，面对这些问题我们该如何处理？&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透是指，当缓存和数据中都没有对应记录，但是客户端却一直在查询。比如黑客攻击系统，不断的去查询系统中不存在的用户，查询时先走缓存，缓存中没有，再去查数据库；或者电商系统中，用户搜索某类商品，但是这类商品再系统中根本不存在，这次的搜索应该直接返回空&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;网关层增加校验，进行用户鉴权，黑名单控制，接口流量控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于同一类查询，如果缓存和数据库都没有获取到数据，那么可用用一个空缓存记录下来，过期时间 60s，下次遇到同类查询，直接取出缓存中的空数据返回即可&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用布隆过滤器，布隆过滤器可以用来判断某个元素是否存在于集合中，利用布隆过滤器可以过滤掉一大部分无效请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿是指，缓存中数据失效，在高并发情况下，所有用户的请求全部都打到数据库上，短时间造成数据库压力过大&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;接口限流、熔断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加锁，当第一个用户请求到时，如果缓存中没有，其他用户的请求先锁住，第一个用户查询数据库后立即缓存到 Redis，然后释放锁，这时候其他用户就可以直接查询缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存雪崩&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存雪崩是指 Redis 中大批量的 key 在同一时间，或者某一段时间内一起过期，造成多个 key 的请求全部无法命中缓存，这些请求全部到数据库中，给数据库带来很大压力。与缓存击穿不同，击穿是指一个 key 过期，雪崩是指很多 key 同时过期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存过期时间设置成不同时间，不要再统一时间过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存污染&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、定义&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存污染是指，由于历史原因，缓存中有很多 key 没有设置过期时间，导致很多 key 其实已经没有用了，但是一直存放在 redis 中，时间久了，redis 内存就被占满了&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、解决方案&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;缓存尽量设置过期时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置缓存淘汰策略为最近最少使用的原则，然后将这些数据删除&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;转自：wugongzi&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;链接：https://www.cnblogs.com/wugongzi/p/16827473.html&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247497323&amp;amp;idx=1&amp;amp;sn=387d84d644ce6351a05ebca8f8c46df5&amp;amp;chksm=c27fb45df5083d4ba108d4583e019c33941d7d1bd1d6d3f41edd03c0bf81185e43af8861f43c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;把Redis当作队列来用，真的合适‍吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;把Redis当作队列来用，真的合适吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkzMDI1NjcyOQ==&amp;amp;mid=2247501704&amp;amp;idx=1&amp;amp;sn=af9a053eb008905af604265600fa50f9&amp;amp;chksm=c27f85bef5080ca8c0ae469a1bc673dc295955c8ac5e59b76a22cdfa48a2653ff749960e032d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;掘地三尺搞定 Redis 与 MySQL ‍数据一致性问题&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;掘地三尺搞定 Redis 与 MySQL 数据一致性问题&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「码哥字节」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzkzMDI1NjcyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/EoJib2tNvVtf7icAmS0BQH6oDVG37Q8NzcfdguS5qAqOhfxvZyIKqmuX5BbnDjynrBbZzktp1EiaeFLzapp1nHysw/0?wx_fmt=png&quot; data-nickname=&quot;码哥字节&quot; data-alias=&quot;MageByte&quot; data-signature=&quot;拥抱硬核技术和对象，面向人民币编程。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4af6e7f5a3eafcdb3be254778b60654e</guid>
<title>如何设计组件化链路？</title>
<link>https://toutiao.io/k/quzh3k0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-msg__text-area&quot;&gt;
                    &lt;p class=&quot;weui-msg__title warn&quot;&gt;The content has been deleted by the author.&lt;/p&gt;
            &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8500a5a12c13d6b4af963f41a99877a4</guid>
<title>百万并发场景中倒排索引与位图计算的实践</title>
<link>https://toutiao.io/k/dfgdurs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h6&gt;作者：京东物流 郎元辉&lt;/h6&gt;

&lt;h2&gt;背景&lt;/h2&gt;

&lt;p&gt;Promise时效控单系统作为时效域的控制系统，在用户下单前、下单后等多个节点均提供服务，是用户下单黄金链路上的重要节点；控单系统主要逻辑是针对用户请求从规则库中找出符合条件的最优规则，并将该规则的时效控制结果返回客户端，比如因为临时疫情等原因针对仓、配、商家、客户四级地址等不同维度进行精细粒度的时效控制。&lt;/p&gt;

&lt;p&gt;该系统也是Promise侧并发量最大的系统，双11高峰集群流量TPS在百万级别，对系统的性能要求非常高，SLA要求在5ms以内，因此&lt;strong&gt;对海量请求在规则库(几十万)中如何快速正确匹配规则是该系统的技术挑战点&lt;/strong&gt;。&lt;/p&gt;

&lt;h2&gt;朴素的解决方案&lt;/h2&gt;

&lt;p&gt;按照朴素的思想，在工程建设上，通过异步方式将规则库逐行缓存到Redis，Key为规则条件,Value为规则对应结果；当用户请求过来时，对请求Request(a,b,c,d..)中的参数做全组合，根据全组合出的Key尝试找出所有可能命中的规则，再从中筛选出最优的规则。如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e67282f34ac4ab09513d8d8e5cc78b0%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;31.png&quot;/&gt;
﻿﻿&lt;/p&gt;

&lt;p&gt;该方案面临的问题是全组合的时间复杂度是2&lt;strong&gt;n,n≈12；&lt;/strong&gt;算法的时间复杂度高且算法稳定性差**，最差情况一次请求需要4096次计算和读取操作。当然在工程上我们可以使用本地缓存做一些优化，但是无法解决最根本的性能问题。架构简图如下所示：&lt;/p&gt;

&lt;p&gt;[]()&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ad4bf2cef04104b0a098b7497c7f00%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;32.png&quot;/&gt;
﻿﻿&lt;/p&gt;

&lt;h2&gt;新的解决方案&lt;/h2&gt;

&lt;p&gt;上面方案是从行的角度看待匹配定位的，能够命中的行的每一列必然也是符合条件的，这里面存在某种隐约的内在联系。能否反过来思考这个问题，为此我们尝试进行新的方案，当然架构简图依然如上图所示，核心优化的是命中算法。&lt;/p&gt;

&lt;p&gt;新的方案整体采用&lt;strong&gt;列的倒排索引和倒排索引位运算&lt;/strong&gt;的方式，使得&lt;strong&gt;计算复杂度由原来的2&lt;/strong&gt;n降至n**，且算法稳定性有非常好的保证。其中列的倒排索引是对每列的值和所分布的行ID(即Posting List)建立KV关系，倒排索引位运算是对符合条件的列倒排索引进行列间的位运算，即通过联合查询以便快速找到符合条件的规则行。&lt;/p&gt;

&lt;h2&gt;算法详细设计&lt;/h2&gt;

&lt;h3&gt;1.预计算生成列的倒排索引和位图&lt;/h3&gt;

&lt;p&gt;通过对每列的值进行分组合并生成Posting List，建立列值和Posting List的KV关系。以下图为例,列A可生成的倒排索引为：301={1},201={2,3,4,5}等，需要说明的一点，空值也是一种候选项，也需要生成KV关系，如nil={7}。&lt;/p&gt;

&lt;p&gt;﻿﻿&lt;br/&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da5be9d1ad444642902b0dd12f924d43%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;33.png&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.生成列的倒排索引对应位图&lt;/h3&gt;

&lt;p&gt;将步骤1的倒排索引转成成位图，方便后续的位图计算，转换规则为行ID对应位图的下标位（步骤1、2可以合并操作）。&lt;/p&gt;

&lt;p&gt;﻿&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1137f2a3e8c4d6396f1a713d29ecd5c%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;34.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;h3&gt;3.根据用户请求查找列位图，通过位图计算生成候选规则集&lt;/h3&gt;

&lt;p&gt;将用户请求中的入参作为Key，查找符合条件的位图，对每一列进行列内和空值做||运算，最后列间位图做&amp;amp;运算，得到的结果是候选规则集，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/132a206090f948d59fce31522a8475f3%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;45.png&quot;/&gt;
[]()&lt;/p&gt;

&lt;p&gt;﻿﻿  &lt;/p&gt;

&lt;h3&gt;4.从候选规则库中，根据业务优先级排序，查找最优的规则&lt;/h3&gt;

&lt;p&gt;以候选规则为基点，按照业务优先级排序，进行逐级位运算&amp;amp;，当遍历完或位运算为0时，找到最后不为空的即为最优规则，该过程是从候选规则库逐渐缩小最优范围的过程。需要说明某列当用户请求位图不存在时，需要使用对应的空位图进行参与，以B列为例，入参B_1102不存在，需要使用B_nil参与&amp;amp;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ecd134aaba54ecdada9c4f6678f67c4%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;56.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;h2&gt;复杂度分析&lt;/h2&gt;

&lt;p&gt;通过上面的例子我们可以看到，在时间复杂度方面查找候选规则集时，进行一轮||运算，一轮&amp;amp;运算；在查找最优规则时进行一轮&amp;amp;运算，所以&lt;strong&gt;整体复杂度是3n≈n&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在空间复杂度方面，相比原来的行式存储，倒排索引的存储方式，每列都需要存储行ID，相当于多了 &lt;strong&gt;(n-1)*Posting List存储空间&lt;/strong&gt;，当然这是粗略计算，因为实际上行ID的存储最终转换为位图存储，在空间上有非常大的压缩空间。&lt;/p&gt;

&lt;h2&gt;工程问题-压缩位图&lt;/h2&gt;

&lt;p&gt;如果倒排索引位图非常稀疏，系统会存在非常大的空间浪费。我们举一个极端case，若千万规则库中命中的行ID是第1000万位，按照传统方式BitSet进行存储，需要消耗1.2MB空间，在内存中占用存在严重浪费，有没有压缩优化方案，在RoaringBitMap压缩位图方案中我们找到，相同场景在压缩位图方式下仅占144bytes；即使在1000万的位图空间，我们随机存储1万个值，两者比也是在31K vs 2MB，&lt;strong&gt;近100倍的差距&lt;/strong&gt;，总的来说RoaringBitMap压缩率非常大。&lt;/p&gt;

&lt;p&gt;RoaringBitMap本质上是将大块的bitmap拆分成各个小块，其中每个小块在需要存储数据的时候才会存在，所以当进行交集或并集运算的时候，RoaringBitMap只需要去计算存在的块而不需要像bitmap那样对整个大块进行计算，既做到了压缩的存储又做到计算性能的提升。&lt;/p&gt;

&lt;p&gt;以下图821697800为例，对应的16进制数为30FA1D08， 其中高16 位为30FA，低16位为1D08。先用二分查找从一级索引（即Container Array）中找到数值为 30FA 的容器，该容器是一个Bitmap容器,然后在该容器查找低16位的数值1D08，即十进制下7432，在Bitmap中找到相应的位置，将其置为1即可。&lt;/p&gt;

&lt;p&gt;﻿
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10a65df52f9c45dda9e33aa780889e74%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;57.png&quot;/&gt;
﻿﻿  &lt;/p&gt;

&lt;p&gt;﻿  &lt;/p&gt;

&lt;h2&gt;适用场景分析&lt;/h2&gt;

&lt;p&gt;回顾上面的设计方案我们可以看到，这种方式仅适用于PostingList简单如行ID的形式，如果是复杂对象就不适合用位图来存储。另外仅适用于等值查询，不适用于like、in的范围查询，为什么有这种局限性？因为这种方式依赖于搜索条件的空间，在方案中我们将值的条件作为搜索的Key，值的条件空间希望尽可能是一个有限的、方便穷举的、小的空间。而范围查询导致这个空间变成难以穷举、近乎无限扩张的、所以不适用。&lt;/p&gt;

&lt;h2&gt;其他优化方式&lt;/h2&gt;

&lt;p&gt;除了使用位运算的方式对倒排索引加速，考虑到Posting List的有序性，还有其他的方式比如使用跳表、Hash表等方式，以ES中采用的跳表为例，进行&amp;amp;运算实际就是在查找两个有序Posting List公共部分，以相互二分查找的形式，将时间复杂度控制在log(n)的级别。&lt;/p&gt;

&lt;p&gt;具体参见&lt;a href=&quot;https://time.geekbang.org/column/article/221292?utm_source=related_read&amp;amp;utm_medium=article&amp;amp;utm_term=related_read&quot;&gt;工业界如何利用跳表、哈希表、位图进行倒排索引加速？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02c121b520dd4af3823805ee026a68f8%7Etplv-k3u1fbpfcp-watermark.image?&quot; alt=&quot;38.png&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb5825c1fecde118a1aed6004a9ff69a</guid>
<title>写给大忙人看的 Go 语言快速指南（中文翻译）</title>
<link>https://toutiao.io/k/a60flbu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry marked-body js-toc-content&quot; itemprop=&quot;articleBody&quot;&gt;&lt;p&gt;Go是一种非常受欢迎的编程语言，它具有内置的并发支持和众多其他优秀的特性。在众多现代语言中，Go在基本语言设计方面格外出众。&lt;/p&gt;&lt;p&gt;首先，Go是一种非常简洁的语言，它的简洁性使其与像Lua这样的简单语言相似。Go设计时十分注重简洁主义 &amp;amp;mldr;&lt;/p&gt;&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;&lt;p&gt;Go是一种非常受欢迎的编程语言，它具有内置的并发支持和众多其他优秀的特性。在众多现代语言中，Go在基本语言设计方面格外出众。&lt;/p&gt;&lt;p&gt;首先，Go是一种非常简洁的语言，它的简洁性使其与像Lua这样的简单语言相似。Go设计时十分注重简洁主义。&lt;/p&gt;&lt;p&gt;其次，Go非常重视语言的稳定性，与许多其他语言形成了鲜明的对比。Go更像C语言，自从40多年前创建以来几乎没有任何改变。&lt;/p&gt;&lt;p&gt;最近Go 1.18中引入的泛型是一个例外，但这显然是必要的改变。&lt;/p&gt;&lt;p&gt;第三，在标准库方面，Go是一种&quot;综合性&quot;编程语言，它提供了开发专业软件所需的所有功能，而无需过多依赖外部库。&lt;/p&gt;&lt;p&gt;本书是Go编程语言的&quot;迷你&quot;语言参考手册，它概述了现代Go编程语言（1.18和1.19）的所有基本功能。虽然它是作为参考手册而写的，但你几乎可以从头到尾阅读它，并且应该能够了解Go语言的整体概念（但不一定是所有的细节）。&lt;/p&gt;&lt;p&gt;值得注意的是，与教程风格的书籍不同，本书有大量交叉引用，如果您之前没有使用Go编程的经验，可能会发现很难阅读本书的某些部分。&lt;/p&gt;&lt;p&gt;本书也是我在2022年自由职业期间翻译的一本书，借此机会巩固自己对Go的相关知识。&lt;/p&gt;&lt;h1 id=&quot;阅读地址&quot;&gt;阅读地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://code-zatan.gitbook.io/a-quick-guide-to-the-go-programming-language-for-busy-coders/&quot;&gt;写给大忙人看的Go语言快速指南&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ec15747097d50bb625b2767b41736b9c</guid>
<title>阿里是如何进行单元测试培训的？（附回放视频）</title>
<link>https://toutiao.io/k/gugu3s3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X9055oUNdqjLrC1rJ8MLpQHhicOibmOib10zpfic0nzZRPCKSvZ3Uibyjhmc6Ig/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;写在前面：写这个文章的主要原因是刚给国际供应链的团队做了单元测试课程培训，感觉此次线下课程效果不错，也有直播录像，所以分享给有兴趣的同学。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;整个培训课程大约2个小时左右，可以配合直播回放使用。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe wxw_wechannel_card_horizontal&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAHzA6fEuxfQAAAAstQy6ubaLX4KHWvLEZgBPEn4J0D2EjeoWBzNPgMIv0MnXttf5KZW9w16JMYYGT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaAlR1hBjz32rsGNn8D0s1NBJEF3PicX3jSMXsDjDvpVzgOdUaZlk9DFZxTuO9o2nvBomP3c7wibT06u2XXic1Q986A&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibA4QORwAbicwia653ibGsnWgWt7l7qvUVx9Bia9roKR9gkOpr8EiamoDFkpAiaOebdaX7l4w&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/3Lqm1xHojtYXeKK6Y1AMKJOKC03LmV8kOb2ZFkFA6VB2mmSkj6ytHw/0&quot; data-username=&quot;v2_060000231003b20faec8c5e58d11c0dcce00e533b077dd360e2525c401b1dc3fc2d60962425b@finder&quot; data-nickname=&quot;阿里云开发者&quot; data-desc=&quot;单元测试课程直播-1&quot; data-nonceid=&quot;30877826269950068&quot; data-type=&quot;video&quot; data-authiconurl=&quot;https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、什么是单元测试？（10 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;维基百科中是这样描述的：在计算机编程中，单元测试又称为模块测试，是针对程序模块来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类、抽象类、或者派生类中的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;单元测试和集成测试的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回到测试的本质来看，测试工作就是模拟真实环境，在代码正式上线前进行验证的工作，即使没有任何工具和方法，这项工作也能够通过人工操作来手动完成。但这种方式显然不符合软件从业者的习惯，于是开始出现了各种各样的自动化测试方法，框架和工具。单元测试和集成测试使用的测试框架和工具大部分是相同的，而社区中对集成测试的介绍不尽相同，导致很多看过不同文章的同学对这两种测试的认知存在争议。首先需要达成一致的是，无论是单元测试还是集成测试，它们都是自动化测试。为了更好地区分，我们可以这样理解：和生产代码以及单元测试代码在同一个代码仓库中，由开发同学自己编写的，对外部环境（数据库、文件系统、外部系统、消息队列等）有真实调用的测试就是集成测试。下表中也从各种角度来对比了单元测试、集成测试和系统级别测试（包括端到端测试、链路测试、自动化回归测试、UI测试等）的区别。&lt;/span&gt;&lt;/section&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;单元测试&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;集成测试&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;系统级别测试&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;编写人员&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;开发&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;开发&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;开发 / 测试&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;编写场地&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;生产代码仓库内&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;生产代码仓库内&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;生产代码仓库内 / 生产代码仓库外&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;编写时间&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;代码发布前&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;代码发布前&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;代码发布前 / 代码发布后&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;编写成本&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;低&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;中&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;高&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;编写难度&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;低&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;中&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;高&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;反馈速度&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;极快，秒级&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;较慢，分钟级&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;慢，天级别&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;覆盖面积&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;代码行覆盖60-80% 分支覆盖40-60%&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;功能级别覆盖HappyPath&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;核心保障链路&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;环境依赖&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;代码级别，不依赖环境&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;依赖日常或本地环境&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;依赖预发或生产环境&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;外部依赖模拟&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;全部模拟&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;部分模拟&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;td&gt;&lt;section&gt;&lt;span&gt;不模拟，完全使用真实环境&lt;/span&gt;&lt;/section&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;小互动（10 min）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;上手题 - 用于查看目前大家的单测理解和技能水平&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;以下是一个简单的服务代码，请认真观看后写下你认为应该写的单元测试。&lt;/span&gt;&lt;/h3&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;@Service&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Autowired&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; UserDAO userDAO;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; startIndex 开始序号&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; pageSize 分页大小&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * &lt;span class=&quot;code-snippet__doctag&quot;&gt;@return&lt;/span&gt; 用户分页数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; PageDataVO&amp;lt;UserVO&amp;gt; queryUser(Long companyId, Long startIndex, Integer pageSize) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;//入参校验&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(ValidationUtil.validate(companyId)){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InvalidRequestException(companyId, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Invalid company Id&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 查询用户数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 查询用户数据: 总共数量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long totalSize = userDAO.countByCompany(companyId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 查询接口数据: 数据列表&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;UserVO&amp;gt; dataList = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (NumberHelper.isPositive(totalSize)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            dataList = userDAO.queryByCompany(companyId, startIndex, pageSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 返回分页数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; PageDataVO&amp;lt;&amp;gt;(totalSize, dataList);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;随机问题：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你觉得针对这段代码，应该需要写几个单元测试？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;你觉得这个单元测试的行覆盖率理论值可以达到多少？我们一般需要达到多少？如果要达到你的目标，投入的工作量是多少？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单测的代码量和原业务代码量的比值应该是多少比较合适？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;答案（仅供参考）：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RunWith&lt;/span&gt;(MockitoJUnitRunner.class)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; UserServiceTest {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 定义静态常量 */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 资源路径 */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; RESOURCE_PATH = &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testUserService/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 模拟依赖对象 */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 用户DAO */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Mock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; UserDAO userDAO;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 定义测试对象 */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/** 用户服务 */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@InjectMocks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; UserService userService;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * 测试: 查询用户-无数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; testQueryUser_Succeed_NoData() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 模拟依赖方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 模拟依赖方法: userDAO.countByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long companyId = &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long startIndex = &lt;span class=&quot;code-snippet__number&quot;&gt;90&lt;/span&gt;L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Integer pageSize = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.doReturn(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;L).when(userDAO).countByCompany(companyId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 调用测试方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; path = RESOURCE_PATH + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testQueryUserWithoutData/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PageDataVO&amp;lt;UserVO&amp;gt; pageData = userService.queryUser(companyId, startIndex, pageSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; text = ResourceHelper.getResourceAsString(getClass(), path + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pageData.json&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Assert.assertEquals(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;分页数据不一致&quot;&lt;/span&gt;, text, &lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.toJSONString(pageData));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖方法: userDAO.countByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.verify(userDAO).countByCompany(companyId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.verifyNoMoreInteractions(userDAO);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     * 测试: 查询用户-有数据&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; testQueryUser_Succeed_WithData() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 模拟依赖方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; path = RESOURCE_PATH + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;testQueryUserWithData/&quot;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 模拟依赖方法: userDAO.countByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long companyId = &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.doReturn(&lt;span class=&quot;code-snippet__number&quot;&gt;91&lt;/span&gt;L).when(userDAO).countByCompany(companyId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 模拟依赖方法: userDAO.queryByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Long startIndex = &lt;span class=&quot;code-snippet__number&quot;&gt;90&lt;/span&gt;L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Integer pageSize = &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; text = ResourceHelper.getResourceAsString(getClass(), path + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;dataList.json&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        List&amp;lt;UserVO&amp;gt; dataList = &lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.parseArray(text, UserVO.class);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.doReturn(dataList).when(userDAO).queryByCompany(companyId, startIndex, pageSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 调用测试方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        PageDataVO&amp;lt;UserVO&amp;gt; pageData = userService.queryUser(companyId, startIndex, pageSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        text = ResourceHelper.getResourceAsString(getClass(), path + &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;pageData.json&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Assert.assertEquals(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;分页数据不一致&quot;&lt;/span&gt;, text, &lt;span class=&quot;code-snippet__built_in&quot;&gt;JSON&lt;/span&gt;.toJSONString(pageData));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖方法&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖方法: userDAO.countByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.verify(userDAO).countByCompany(companyId);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖方法: userDAO.queryByCompany&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.verify(userDAO).queryByCompany(companyId, startIndex, pageSize);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__comment&quot;&gt;// 验证依赖对象&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Mockito.verifyNoMoreInteractions(userDAO);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;void&lt;/span&gt; testQueryUser_Fail_WithBadInput() {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;抢答题：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;请问这个是单元测试吗？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RunWith&lt;/span&gt;(MockitoJUnitRunner.class)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SpringDalTest&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DBClient dbClient;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;testGetDate_success_getFromDB&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      String result = dbClient.getDate(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      Assert.equals(result,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;ExpectedResults&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;请问这个是单元测试吗？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-language=&quot;java&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RunWith&lt;/span&gt;(MockitoJUnitRunner.class)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DemoControllerTest&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Mock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DemoTairClient tairClient;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Mock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DemoDBMapper dbMapper;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@InjectMocks&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DemoController demoController;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Test&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;testGetResult_succeed_getFromCache&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        when(tairClient.getCache(anyString())).thenReturn(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getCacheResponse&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        when(dbMapper.queryData(anyString())).thenReturn(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;queryDataResponse&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        String result = demoController.getResult(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Assert.assertEquals(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;getCacheResponse&quot;&lt;/span&gt;, result);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;请问这个是单元测试吗？&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@RunWith(PandoraBootRunner.class)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@DelegateTo(SpringJUnit4ClassRunner.class)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@PropertySource(value = {&lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;classpath:test.properties&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__meta-string&quot;&gt;&quot;classpath:landlord.properties&quot;&lt;/span&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@SpringBootTest(classes = Application.class)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SanityTest&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__meta&quot;&gt;@Resource&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      InfoService infoService1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__meta&quot;&gt;@Mock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      InfoService infoService2;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void testGetInfo_succeed_giveValidRequest(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          String result1 = infoService1.getInfo(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          String result2 = infoService2.getInfo(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Request&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          Assert.equals(result1,result2);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;二、为什么要写单元测试？（10 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;反例：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;现在，领导要响应集团提高代码质量的号召，需要提升单元测试的代码覆盖率。当然，我们不能让领导失望，那就加班加点地补充单元测试用例，努力提高单元测试的代码覆盖率。至于单元测试用例的有效性，我们大抵是不用关心的，因为我们只是面向指标编程。1230 提升到 LV3，331 提升团队成为卓越工程 LV4， FY23 KPI 完成了，岂不是___，___，____?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;正例：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为我是一名专业的计算机工程师。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;理论上单元测试带来的好处有：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单测成本低，速度快。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单测是最佳的、自动化的、可执行的文档。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试的要诀是：测试你最担心出错的部分，这样你就能从测试工作中得到最大的利益，100%覆盖率的单测会逐渐消磨开发人员对测试的耐心和好感。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单测驱动设计，提升代码简洁度，确保安全重构，代码修改后，单测仍然能通过，能够增强开发者的信心。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速反馈，更快的发现问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;定位缺陷比集成测试更快更准确，降低修复成本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;实际上通过 2 个公司内部的例子来证明：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;例子 1&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;菜鸟 GOC 提供的一个外部 BU 的例子，仅供参考（对照组数据不够严谨，数据还待完善，结论进一步佐证中）&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;外BU：采销供应链--&lt;strong&gt;网络&amp;amp;权限&amp;amp;商家&amp;amp;采购&amp;amp;物流协同（后面简称伍道团队)&lt;/strong&gt;单测&lt;strong&gt;缩短了变更的开发和测试总时长&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、变更开发测试时长领先&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从阿里大脑获取到 FY22 5月-10月采购供应链-伍道团队，和供应链BU变更开发测试时长对比趋势的客观数据，如下图所示。对比6个月平均数来看，伍道团队变更开发测试时长平均领先供应链BU 3.1天。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6086261980830671&quot; data-type=&quot;png&quot; data-w=&quot;1252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X9055icGDic989zXKMNEY0WGx7LyQ0vLKxhmOYL6KexShscv0fmQ3NtEsReQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2、交付质量高&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：变更折返修改代码再部署次数更低&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;采购供应链的有变更发布的全应用和BU内非采购供应链全应用，将变更平均从预发环境折返修改代码重部署次数做对比——&lt;strong&gt;5-10月份采购供应链“变更平均从预发环境折返修改代码重部署”次数为X次，同BU其他部门平均次数Y次，相比低40%。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14285714285714285&quot; data-type=&quot;png&quot; data-w=&quot;1246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905BCTMytYxEXAnFQPhGM0bQQw6qTxqsC0SrHjjURtSe4dTRfuicSQqqWQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从Aone中应用，针对5-10月供应链BU在预发环境有发布成功的变更的核心应用，我们将非采购供应链所有核心应用49个(Aone未观察有UT覆盖率)，和采购供应链主版本应用中，单测行覆盖率超60%的7个核心应用做参照对比。&lt;strong&gt;说明进行单测并没有使得变更的开发和测试时长变长，反而因为提升了代码内建质量，缩短了变更的开发和测试总时长。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6191446028513238&quot; data-type=&quot;png&quot; data-w=&quot;982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905xkoWibJSsw4gONRNSTqlSbxywyn2jFNcLMlf2GAzSTiaZuzDcIsLgPWw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;例子 2&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;菜鸟&amp;amp;企业智能：&lt;strong&gt;企业智能&lt;/strong&gt;单测&lt;strong&gt;减少了变更从预发环境平均折返修改代码重部署次数&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;菜鸟整体（单测一般）、企业智能（单测好）、A&amp;amp;B团队（单测差），对比7-10月变更从预发环境平均折返修改代码重部署次数。—— &lt;strong&gt;企业智能返工次数明显低于菜鸟整体，低于菜鸟整体35%，低于单测建设薄弱团队整体45%。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25949367088607594&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905kGcXXWOkMs49vGVLmSrIvmaosjJXeyCSGAPUW6NA42ibKvCW7iceicicFg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6203522504892368&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905R9A8hlkQXNiaLpwyfV7zaULVcAnunZgdPU0OTxURB3zGMmcR3PgoDEA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7-10月，企业智能5个BU核心应用平均全量行覆盖≥60% 以及 菜鸟其他团队 5个 无单测建设的BU核心应用对比变更从预发环境平均折返修改代码重部署次数。——变更平均从预发环境折返修改代码重部署次数为X，低于5个无单测应用对照组的Y，说明经过充分的单测的变更的内建质量更好，因而在预发环境折返修改代码重部署次数比对照组低52%&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.584518167456556&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905ZoErj5fzQou9vkAeDvKh0QLiaoFCku7GBh0rt6dWaHEibjj5nk9TaAbA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、怎么写单元测试？（50 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3278236914600551&quot; data-type=&quot;png&quot; data-w=&quot;1089&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905YB034h7QOEOYPavGpv4HWjzIIlSJr0sfLuN3rkM31xwpQgZibeypanw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基础单测套餐：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;JUnit4 - &lt;/span&gt;&lt;span&gt;https://github.com/junit-team/junit4/wiki&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Mockito2/3 - &lt;/span&gt;&lt;span&gt;https://site.mockito.org/&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;1. 定义对象阶段&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;定义对象阶段主要包括：定义被测对象、模拟依赖对象（类成员）、注入依赖对象（类成员）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5330243337195828&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905zR5aicX3QrlMZxg3fat0ibYmdgnBCxW9pWTr71rXJVf9sicgYslMoja6A/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2. 模拟方法阶段&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;模拟方法阶段主要包括：模拟依赖对象（参数、返回值和异常）、模拟依赖方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16775956284153004&quot; data-type=&quot;png&quot; data-w=&quot;1830&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905EGWy8JUvRFGd2Rw0suobuZklXRvlwZBj1yUUQeawt2YGvAYHbzx7Iw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3. 调用方法阶段&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;调用方法阶段主要包括：模拟依赖对象（参数）、调用被测方法、验证参数对象（返回值和异常）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17058823529411765&quot; data-type=&quot;png&quot; data-w=&quot;1870&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X9052eDm20UamBHq9C4IttnKvkibAB6d4VCTjfboyAyuia8MFJHnroNuBAFA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4. 验证方法阶段&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;验证方法阶段主要包括：验证依赖方法、验证数据对象（参数）、验证依赖对象 。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30849889624724064&quot; data-type=&quot;png&quot; data-w=&quot;1812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905nQ9GxzpJ35o3SIicl9VOq3nbIH8XmoXMTTj4b2WSzN8DDbWVAp4DXCQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;大互动&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看了这个理论知识，下面我们开始时间实操：&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Before&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;需要 Maven 如何配置，要引入什么？&lt;/span&gt;&lt;/section&gt;&lt;pre data-language=&quot;xml&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;junit&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;junit&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.13.1&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mockito&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mockito-core&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.3.3&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.powermock&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;powermock-module-junit4&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.9&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.powermock&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;powermock-api-mockito2&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.0.9&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;Test&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;（现场指导和实操环节，附带提问和一对一指导，内容都在代码里）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;请下载：&lt;/span&gt;&lt;span&gt;https://github.com/Lukegogogo/unit-test-training-demo/tree/mainline&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;现场演示怎么写单元测试，9 种通用场景。&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【无依赖 难度：🌟🌟】最简单的 Helper/Util/Validation 层 &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【有些许依赖 难度：🌟🌟🌟】稍复杂 Service/Controller 层&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【有很多依赖 难度：🌟🌟🌟🌟】更复杂的 Biz 逻辑层&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【难度：🌟🌟】如何测试 Exception&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【难度：🌟】AssertJ 的使用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【难度：🌟🌟】Verify 的使用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【难度：🌟🌟🌟】Argument Captor 的使用&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;【难度：🌟】 静态类的 mock&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【难度：🌟🌟🌟🌟】依赖里面的 Lambda 表达式内的逻辑怎么执行？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe videosnap_video_iframe wxw_wechannel_card_horizontal&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAALuoCPp09YgAAAAstQy6ubaLX4KHWvLEZgBPEtoIMFFJNe4WBzNPgMItWVKzbn3fvdXvtheO7h2xT&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaHTwKtZLkY1sDMficuelBljb1PPS8sg8XeoBbmcltLhyONqnFia61lSsORu4Yzk8WtL0HEsdoH8icLF8mgWnBzsMTQ&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdX3qethuBL3zPNtdGlmsOJZwyQPyz9BRwSqVJibpc88WL0m0BbfDGibo5JoZGxXwYnD8&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/3Lqm1xHojtYXeKK6Y1AMKJOKC03LmV8kOb2ZFkFA6VB2mmSkj6ytHw/0&quot; data-username=&quot;v2_060000231003b20faec8c5e58d11c0dcce00e533b077dd360e2525c401b1dc3fc2d60962425b@finder&quot; data-nickname=&quot;阿里云开发者&quot; data-desc=&quot;单元测试课程直播-2&quot; data-nonceid=&quot;3239115290426063914&quot; data-type=&quot;video&quot; data-authiconurl=&quot;https://dldir1v6.qq.com/weixin/checkresupdate/icons_filled_channels_authentication_enterprise_a2658032368245639e666fb11533a600.png&quot; data-width=&quot;1920&quot; data-height=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、单测开发规范 （15 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;单测代码规范要求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】好的单元测试必须遵守AIR原则。&lt;strong&gt;说明：&lt;/strong&gt;单元测试在线上运行时，感觉像空气（AIR）一样感觉不到，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;A&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Automatic（自动化）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;I&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Independent（独立性）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;R&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Repeatable（可重复）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。&lt;strong&gt;反例&lt;/strong&gt;：method2需要依赖method1的执行，将执行结果做为method2的参数输入。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】单元测试是可以重复执行的，不能受到外界环境的影响。&lt;strong&gt;说明&lt;/strong&gt;：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境(网络、服务、中间件等)有依赖，容易导致持续集成机制的不可用。&lt;strong&gt;正例&lt;/strong&gt;：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。&lt;strong&gt;说明&lt;/strong&gt;：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。&lt;strong&gt;说明&lt;/strong&gt;：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。&lt;strong&gt;说明&lt;/strong&gt;：源码编译时会跳过此目录，而单元测试框架默认是扫描此目录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100%。&lt;strong&gt;说明&lt;/strong&gt;：在工程规约&amp;gt;应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;B&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;C&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Correct，正确的输入，并得到预期的结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;D&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Design，与设计文档相结合，来编写单元测试。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;E&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ol start=&quot;10&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。&lt;strong&gt;反例&lt;/strong&gt;：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。&lt;strong&gt;正例&lt;/strong&gt;：在企业智能事业部的内部单元测试中，使用ENTERPRISE_INTELLIGENCE_UNIT_TEST_的前缀来标识单元测试相关代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】对于不可测的代码在适当时机做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例（UC）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【推荐】单元测试作为一种质量保障手段，在项目提测前完成单元测试，不建议项目发布后补充单元测试用例。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【参考】为了更方便地进行单元测试，业务代码应避免以下情况：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol start=&quot;16&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;【参考】不要对单元测试存在如下误解：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;ul ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;那是测试同学干的事情。本文是开发规约，凡是本文出现的内容都是与开发同学强相关的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单元测试代码是多余的。软件系统的整体功能是否正常，与各单元部件的测试正常与否是强相关的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;单元测试代码不需要维护。一年半载后，那么单元测试几乎处于废弃状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单元测试与线上故障没有辩证关系。好的单元测试能够最大限度地规避线上故障。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;研发流程规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;技术方案编写: 无论日需还是项目，无论改动大小 ，一定要进行技术方案编写，按照技术方案模板对照本次改动是否涉及，如有则填写详情设计；如无，则表明不涉及；技术方案是你对需求的理解和分析，是对本次需求转变成技术设计的思考过程，请尽量详细编写技术方案，进行必要的代码设计，做到技术方案可直接coding的程度。在技术方案中，包含单测范围和工时评估。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;本地写单测UT&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;： 提交增量UT扫描任务，&lt;strong&gt;确保增量单测覆盖率80%(不要仅数字，重点关注单测有效性和质量)，测试用例须全部通过。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.465818759936407&quot; data-type=&quot;png&quot; data-w=&quot;2516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905sDbXeLPHlHBVjODu0hyeS1pmg52wxGzYrNxOLaO9ClGWlFDcrPYFtw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;提交CodeReview&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：日需和中小项目，在CR前必须完成步骤1&amp;amp;2，检查入口：CR-&amp;gt;质量扫描&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2381300219138057&quot; data-type=&quot;png&quot; data-w=&quot;2738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905PeL5aMyRm3Or0AtW1MTcf7rmqFEw23z0xSlEvicp6aIkF4YuibFEMIKA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;研发提测：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;pipeline增加单测通过率和增量行覆盖率展示&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Aone提测&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4118486795146324&quot; data-type=&quot;png&quot; data-w=&quot;2802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905EDiaWma91BGb0uUSOPo5vSzM2ahVzgOyoTmDnJFgNmYNHqIbRKemibxw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、有没有什么神器？（5 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7224622030237581&quot; data-type=&quot;png&quot; data-w=&quot;926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKwtCK8CCeGIzTrX8u9X905A4lg4Wl5oHGib2ZHKFj5UlRR2crZTnyp7lBjCZeic8ZU29l2h4V2JNCQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一款好用的插件(TestMe)，能够自动生成单元测试代码，且智能分析当前被测服务所需的依赖，并分析注入mock依赖，可以大大提高单元测试的效率。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;装好之后在你要测试的类里面按⌘+N，再选testme，就直接帮你生成好了&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;六、Q &amp;amp; A（10 min）&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;现场有同学在问：随着单测覆盖增加，单测性能怎么提升？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目前已有完善的方案分享给大家： &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.将配置升级至更好性能的机器（包括编译升级一起） &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2.测试分组并发运行。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;两者加起来，预计一般都可以降低到10分钟内。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;七、课后作业&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析团队核心应用的核心链路，整理出单元测试作战计划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;针对应用的核心链路：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;ol ne-level=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务逻辑层，写一个类的单元测试，测试 case &amp;gt; 5, 覆盖率达到 80%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中间件层，写一个类的单元测试，覆盖率达到 90%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对自动生成的代码，学会使用 exclude；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/ol&gt;&lt;section/&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>