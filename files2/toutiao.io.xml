<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a0596d7aeb052d67e342ed0c2a3ded15</guid>
<title>GOLANG 协程调度</title>
<link>https://toutiao.io/k/zxo0fle</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;本文基于go1.17.6&lt;/p&gt;&lt;h2&gt;&lt;span&gt;1.什么是协程？&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;协程，英文Coroutines，是一种基于线程之上，但又比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做『用户空间线程』，&lt;br/&gt;具有对内核来说不可见的特性。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.1 协程的特点&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程的切换由操作系统负责调度，协程由用户自己进行调度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程的默认Stack大小是MB级别，而协程更轻量，接近KB级别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在同一个线程上的多个协程，访问某些资源可以不需要锁&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;适用于被阻塞的，且需要大量并发的场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;1.2 Golang的GMP模型&lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQJIicpicy43ogomvCdfM4s3asgOV4mbX7iaDd54Ffqo6rHAresFhUCiclNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; title=&quot;GMP模型&quot;/&gt;&lt;figcaption&gt;GMP模型&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU驱动线程上的任务执行&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;线程由操作系统内核进行调度，Goroutine由Golang运行时(runtime)进行调度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;P的 &lt;code&gt;local runnable queue&lt;/code&gt;是无锁的，&lt;code&gt;global runnable queue&lt;/code&gt;是有锁的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;P的 &lt;code&gt;local runnable queue&lt;/code&gt;长度限制为256&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;注意&lt;/strong&gt;:&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. M和P是绑定关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. M和G是绑定关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. P只是暂存G，他们之间不是绑定关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;E-R图&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5769764216366158&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQicOaOpZB5mXDPxib7ibU0AsRdSDiaspviaqTFiafibrsGzekZDpREaiardNn3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;721&quot; title=&quot;E-R图&quot;/&gt;&lt;figcaption&gt;E-R图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;简化后的E-R图&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8207171314741036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQq978wibABwIiczacXQWdXGI3DuqYK0qlByIGHBmFaiaS6NFfqR8dtUYHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;251&quot; title=&quot;E-R图简化后&quot;/&gt;&lt;figcaption&gt;E-R图简化后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 后面为了书写简单直接将&lt;/p&gt;&lt;h3&gt;&lt;span&gt;延伸&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;timer的四叉堆和内存分配器使用的mcache也是每个P一个&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Q: 为什么默认情况下P的数量与CPU数量一致？&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;A:&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;这样可以避免把CPU时间浪费在上线文切换上&lt;/p&gt;&lt;h3&gt;&lt;span&gt;1.3 协程和线程的资源消耗对比&lt;/span&gt;&lt;/h3&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类别&lt;/th&gt;&lt;th&gt;栈内存&lt;/th&gt;&lt;th&gt;上下文切换&lt;/th&gt;&lt;th&gt;备注&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Thread&lt;/td&gt;&lt;td&gt;1MB&lt;/td&gt;&lt;td&gt;1us&lt;/td&gt;&lt;td&gt;内存占用使用的是Java线程的默认栈大小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Goroutine&lt;/td&gt;&lt;td&gt;4KB&lt;/td&gt;&lt;td&gt;0.2us&lt;/td&gt;&lt;td&gt;内存占用使用的是Linux+x86下的栈大小&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;span&gt;2. 常见的Goroutine 让出/调度/抢占场景&lt;/span&gt;&lt;/h2&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.631424375917768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQZfObQhoLiaicZZdJ9jwpGdfZc8VxMSKunibns4sZOUyLpy9zhubBo8QJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;681&quot; title=&quot;Goroutine状态机&quot;/&gt;&lt;figcaption&gt;Goroutine状态机&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;2.1 协程被创建&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;2.2 主动让出&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;2.2.1 使用runtime.Gosched&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;gosched.go&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;        fmt.Println(&lt;span&gt;&quot;Goroutine1:&quot;&lt;/span&gt;, i)&lt;br/&gt;        &lt;span&gt;//time.Sleep(500 * time.Millisecond)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; i == &lt;span&gt;5&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;                    fmt.Println(&lt;span&gt;&quot;Goroutine2:&quot;&lt;/span&gt;, i)&lt;br/&gt;                    &lt;span&gt;//time.Sleep(500 * time.Millisecond)&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }()&lt;br/&gt;            runtime.Gosched()&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体执行流程&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1.&lt;/span&gt;Gosched() -&amp;gt; &lt;span&gt;2.&lt;/span&gt;mcall(fn &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(*g)&lt;/span&gt;) -&amp;gt; 3.&lt;span&gt;gosched_m&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt; -&amp;gt;&lt;br/&gt;4.&lt;span&gt;goschedImpl&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt; -&amp;gt;  &lt;span&gt;dropg&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;                          &lt;span&gt;globrunqput&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;br/&gt;                          &lt;span&gt;schedule&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;step2 mcall(fn func(*g))&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;mcall函数是通过汇编实现的，&lt;br/&gt;在 asm_amd64.s 中&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：每个m上都有一个自己g0，仅用于调度，不指向任何可执行的函数&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;mcall returns to the original goroutine g later, when g has been rescheduled.&lt;br/&gt;fn must not return at all; typically it ends by calling schedule, to let the m&lt;br/&gt;run other goroutines.&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;span&gt;step4 goschedImpl(gp *g)&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1)修改Goroutine的状态 _Grunning -&amp;gt; _Grunnable&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2)dropg() 将G和M解绑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3)globrunqput(gp) 将G放入全局runnable队列&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4)schedule()&lt;br/&gt;进行一轮调度，寻找一个runnable的G，并执行它，&lt;strong&gt;函数不会返回&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;step4-4 schedule()&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;schedule&lt;/span&gt;() –&amp;gt; 1&lt;span&gt;.findrunnable&lt;/span&gt;()&lt;br/&gt;              2&lt;span&gt;.execute&lt;/span&gt;() –&amp;gt;&lt;span&gt;gogo&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5&gt;&lt;span&gt;step4-4 schedule() --&amp;gt; findrunnable()&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;&lt;code&gt;gogo()&lt;/code&gt;&lt;br/&gt;汇编实现，用于恢复现场(PC/SP)，运行上一步找到的新的可运行的G&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Q:为什么一定要单独设置一个g0来执行goschedImpl(gp *g)&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;A:  schedule()会将G的stack搞乱&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;另外有些文章说g0的栈会使用操作系统分配的线程栈，但是根据萌叔的研究，这个与操作系统有关的。&lt;br/&gt;macOS是使用的线程栈(8MB)，但是linux下g0的栈初始大小只有8KB。&lt;br/&gt;runtime/proc.go&lt;/p&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;//&lt;/span&gt; In case &lt;span&gt;of&lt;/span&gt; cgo &lt;span&gt;or&lt;/span&gt; Solaris &lt;span&gt;or&lt;/span&gt; illumos &lt;span&gt;or&lt;/span&gt; Darwin, pthread_create will make us a stack.&lt;br/&gt;    &lt;span&gt;//&lt;/span&gt; Windows &lt;span&gt;and&lt;/span&gt; Plan &lt;span&gt;9&lt;/span&gt; will layout sched stack &lt;span&gt;on&lt;/span&gt; OS stack.&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; iscgo || mStackIsSystemAllocated() {&lt;br/&gt;        mp.g0 = malg(&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        mp.g0 = malg(&lt;span&gt;8192&lt;/span&gt; * sys.StackGuardMultiplier)&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// mStackIsSystemAllocated indicates whether this runtime starts on a&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// system-allocated stack.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;mStackIsSystemAllocated&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; GOOS {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;aix&quot;&lt;/span&gt;, &lt;span&gt;&quot;darwin&quot;&lt;/span&gt;, &lt;span&gt;&quot;plan9&quot;&lt;/span&gt;, &lt;span&gt;&quot;illumos&quot;&lt;/span&gt;, &lt;span&gt;&quot;ios&quot;&lt;/span&gt;, &lt;span&gt;&quot;solaris&quot;&lt;/span&gt;, &lt;span&gt;&quot;windows&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;openbsd&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; GOARCH {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;386&quot;&lt;/span&gt;, &lt;span&gt;&quot;amd64&quot;&lt;/span&gt;, &lt;span&gt;&quot;arm&quot;&lt;/span&gt;, &lt;span&gt;&quot;arm64&quot;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2.2.2 任务执行完毕&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;goexit1() -&amp;gt; mcall(fn &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(*g)&lt;/span&gt;) -&amp;gt; &lt;span&gt;goexit0&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// goexit continuation on g0.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;goexit0&lt;/span&gt;&lt;span&gt;(gp *g)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    _g_ := getg()&lt;br/&gt;    casgstatus(gp, _Grunning, _Gdead)&lt;br/&gt;    gp.m = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;    dropg()&lt;br/&gt;    gfput(_g_.m.p.ptr(), gp)&lt;br/&gt;    schedule()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;2.3 抢占式调度&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;抢占式调度是由守护进程 sysmon() 触发的&lt;br/&gt;sysmon()是一个特殊的m，它不需要和P进行绑定。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sysmon&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 1. 运行计时器&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 2. 检查网络轮询器(netpoll)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 3. 触发抢占式调度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 4. 触发GC&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最大时间片是10ms&lt;/p&gt;&lt;h4&gt;&lt;span&gt;推荐观看  幼麟实验室的视频&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;深度探索Go语言：抢占式调度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;深度探索Go语言：抢占式调度(2)&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;2.3.1 基于协作的抢占式调度&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;依赖栈增长监测代码&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.810126582278481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQBPTyFGOVUQOglhNsQZ8AlibaRJs0gCc1JQbDVEnUXeYkwVP1pgSeicicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;pre&gt;&lt;code&gt;sysmon() -&amp;gt; retake() -&amp;gt; preemptone()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; g &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    stackguard0 &lt;span&gt;uintptr&lt;/span&gt; &lt;span&gt;// offset known to liblink&lt;/span&gt;&lt;br/&gt;    preempt     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;// preemption signal, duplicates stackguard0 = stackpreempt&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2.3.2 基于信号的抢占式调度&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;发出信号&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;sysmon() -&amp;gt; retake() -&amp;gt; preemptone() -&amp;gt; signalM(mp, sigPreempt)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;preemptone&lt;/span&gt;&lt;span&gt;(_p_ *p)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    mp := _p_.m.ptr()&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; mp == &lt;span&gt;nil&lt;/span&gt; || mp == getg().m {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    gp := mp.curg&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; gp == &lt;span&gt;nil&lt;/span&gt; || gp == mp.g0 {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    gp.preempt = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Every call in a goroutine checks for stack overflow by&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// comparing the current stack pointer to gp-&amp;gt;stackguard0.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// Setting gp-&amp;gt;stackguard0 to StackPreempt folds&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// preemption into the normal stack overflow check.&lt;/span&gt;&lt;br/&gt;    gp.stackguard0 = stackPreempt&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Request an async preemption of this P.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; preemptMSupported &amp;amp;&amp;amp; debug.asyncpreemptoff == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        _p_.preempt = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        preemptM(mp)&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;接收到信号&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;sighandler() -&amp;gt; doSigPreempt() -&amp;gt; asyncPreempt()-&amp;gt;  globalrunqput()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;asyncPreempt由汇编实现 preempt_amd64.s&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.4 hand off p&lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5653225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQrJ0oyhdEjFqszJVXIcCDGXoz4mjWSojOOhD8HjVuEt2481IruXQ0Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;disk io引起golang线程数暴涨的问题&lt;/p&gt;&lt;h4&gt;&lt;span&gt;场景读写磁盘文件&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;涉及syscall.Syscall()&lt;/p&gt;&lt;h4&gt;&lt;span&gt;注意:&lt;/span&gt;&lt;/h4&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于handeroff机制的存在，读写磁盘文件的过程中，如果IO的压力过大可能会导致大量的系统线程被创建&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在Golang中(Linux平台)，读写网络连接是非阻塞式系统调用，并且是边缘触发&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在Golang中(Linux平台)，读写磁盘文件是阻塞式系统调用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;.Read&lt;/span&gt;() &lt;span&gt;-&lt;/span&gt;&amp;gt; &lt;span&gt;poll&lt;/span&gt;&lt;span&gt;.FD&lt;/span&gt;&lt;span&gt;.Read&lt;/span&gt;() &lt;span&gt;-&lt;/span&gt;&amp;gt; &lt;span&gt;syscall&lt;/span&gt;&lt;span&gt;.Read&lt;/span&gt;() &lt;span&gt;-&lt;/span&gt;&amp;gt; &lt;span&gt;syscall&lt;/span&gt;&lt;span&gt;.Syscall&lt;/span&gt;()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;poll/fd_unix.go&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Read implements io.Reader.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(fd *FD)&lt;/span&gt; &lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(p []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        n, err := ignoringEINTRIO(syscall.Read, fd.Sysfd, p) &lt;span&gt;// 执行syscall&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            n = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err == syscall.EAGAIN &amp;amp;&amp;amp; fd.pd.pollable() {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; err = fd.pd.waitRead(fd.isFile); err == &lt;span&gt;nil&lt;/span&gt; { &lt;span&gt;// gopark&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        err = fd.eofError(n, err)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; n, err&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(fd &lt;span&gt;int&lt;/span&gt;, p []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; _p0 unsafe.Pointer&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(p) &amp;gt; &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        _p0 = unsafe.Pointer(&amp;amp;p[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        _p0 = unsafe.Pointer(&amp;amp;_zero)&lt;br/&gt;    }&lt;br/&gt;    r0, _, e1 := Syscall(SYS_READ, &lt;span&gt;uintptr&lt;/span&gt;(fd), &lt;span&gt;uintptr&lt;/span&gt;(_p0), &lt;span&gt;uintptr&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(p)))&lt;br/&gt;    n = &lt;span&gt;int&lt;/span&gt;(r0)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; e1 != &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;        err = errnoErr(e1)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;Syscall和RawSyscall的源码&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQPicQflhnMM41SrxIJXURlXTsnzciaOnOS5ticBQTIxfUH3qngvRP9P0rA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;2.4.1 entersyscall()&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;.设置_g&lt;span&gt;_&lt;/span&gt;.m.locks++，禁止g被强占&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;.设置_g&lt;span&gt;_&lt;/span&gt;.stackguard&lt;span&gt;0&lt;/span&gt; = stackPreempt，禁止调用任何会导致栈增长/分裂的函数&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;.保存现场，在 &lt;span&gt;syscall&lt;/span&gt; 之后会依据这些数据恢复现场&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;.更新G的状态为_Gsyscall&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;.释放局部调度器P：解绑P与M的关系；&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;.更新P状态为_Psyscall&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;.g.m.locks–解除禁止强占。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进入系统调用的goroutine会阻塞，导致内核M会阻塞。此时P会被剥离掉， 所以P可以继续去获取其余的空闲M执行其余的goroutine。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.4.2 阻塞式系统调用长期运行将会导致的流程&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;sysmon() -&amp;gt; retake() -&amp;gt; handoffp()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果P的本地队列不为空，handoffp()会尝试获取一个M来运行P&lt;br/&gt;M有2种来源:&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.4.3 exitsyscall()&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;1.设置 &lt;span&gt;g&lt;/span&gt;&lt;span&gt;.m&lt;/span&gt;&lt;span&gt;.locks&lt;/span&gt;++ 禁止强占&lt;br/&gt;2.调用 &lt;span&gt;exitsyscallfast&lt;/span&gt;() 快速退出系统调用&lt;br/&gt;    2&lt;span&gt;.1&lt;/span&gt;. &lt;span&gt;Try&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;re-acquire&lt;/span&gt; &lt;span&gt;the&lt;/span&gt; &lt;span&gt;last&lt;/span&gt; &lt;span&gt;P&lt;/span&gt;，如果成功就直接接&lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    2&lt;span&gt;.2&lt;/span&gt;. &lt;span&gt;Try&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;get&lt;/span&gt; &lt;span&gt;any&lt;/span&gt; &lt;span&gt;other&lt;/span&gt; &lt;span&gt;idle&lt;/span&gt; &lt;span&gt;P&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;allIdleP&lt;/span&gt; &lt;span&gt;list&lt;/span&gt;;&lt;br/&gt;    2&lt;span&gt;.3&lt;/span&gt;. 没有获取到空闲的&lt;span&gt;P&lt;/span&gt;&lt;br/&gt;3.如果快速获取到了&lt;span&gt;P&lt;/span&gt;：&lt;br/&gt;    3&lt;span&gt;.1&lt;/span&gt;. 更新&lt;span&gt;G&lt;/span&gt; 的状态是_&lt;span&gt;Grunning&lt;/span&gt;&lt;br/&gt;    3&lt;span&gt;.2&lt;/span&gt;. 与&lt;span&gt;G&lt;/span&gt;绑定的&lt;span&gt;M&lt;/span&gt;会在退出系统调用之后继续执行&lt;br/&gt;4. 没有获取到空闲的&lt;span&gt;P&lt;/span&gt;：&lt;br/&gt;    4&lt;span&gt;.1&lt;/span&gt;. 调用&lt;span&gt;mcall&lt;/span&gt;()函数切换到&lt;span&gt;g0&lt;/span&gt;的栈空间；&lt;br/&gt;    4&lt;span&gt;.2&lt;/span&gt;. 调用&lt;span&gt;exitsyscall0&lt;/span&gt;函数：&lt;br/&gt;        4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;. 更新&lt;span&gt;G&lt;/span&gt; 的状态是_&lt;span&gt;Gwaiting&lt;/span&gt;&lt;br/&gt;        4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;. 调用&lt;span&gt;dropg&lt;/span&gt;()：解除当前&lt;span&gt;g&lt;/span&gt;与&lt;span&gt;M&lt;/span&gt;的绑定关系；&lt;br/&gt;        4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;. 调用&lt;span&gt;globrunqput&lt;/span&gt;将&lt;span&gt;G&lt;/span&gt;插入&lt;span&gt;global&lt;/span&gt; &lt;span&gt;queue&lt;/span&gt;的队尾，&lt;br/&gt;        4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.4&lt;/span&gt;. 调用&lt;span&gt;stopm&lt;/span&gt;()释放&lt;span&gt;M&lt;/span&gt;，将&lt;span&gt;M&lt;/span&gt;加入全局的&lt;span&gt;idel&lt;/span&gt; &lt;span&gt;M&lt;/span&gt;列表，这个调用会阻塞，知道获取到可用的&lt;span&gt;P&lt;/span&gt;。&lt;br/&gt;        4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.5&lt;/span&gt;. 如果4&lt;span&gt;.2&lt;/span&gt;&lt;span&gt;.4&lt;/span&gt;中阻塞结束，&lt;span&gt;M&lt;/span&gt;获取到了可用的&lt;span&gt;P&lt;/span&gt;，会调用&lt;span&gt;schedule&lt;/span&gt;()函数，执行一次新的调度。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;2.5 系统调用&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;以netpoll为例，linux操作系统下，netpoll基于epoll实现的&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;#include &amp;lt;sys/epoll.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;epoll_create&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; size&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;epoll_ctl&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; epfd, &lt;span&gt;int&lt;/span&gt; op, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;struct&lt;/span&gt; epoll_event *&lt;span&gt;event&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;epoll_wait&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; epfd, &lt;span&gt;struct&lt;/span&gt; epoll_event * events, &lt;span&gt;int&lt;/span&gt; maxevents, &lt;span&gt;int&lt;/span&gt; timeout&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5661914460285132&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQkDvrXywAXiaPLCMYiaFMWgCEnJM91rRoOJc7Gb4JVXvOBu9GF0svkcZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;2.5.1 让出流程&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;pollDesc.waitRead() -&amp;gt; runtime.poll_runtime_pollWait() -&amp;gt; runtime.gopark()&lt;br/&gt;-&amp;gt; mcall(fn func(*g)) -&amp;gt; park_m(gp *g)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;gopark()主要流程&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;2.5.2 放回 主动触发netpoll()&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;findrunnable()-&amp;gt;netpoll()-&amp;gt;injectglist()-&amp;gt;globrunqputbatch()/runqputbatch()&lt;br/&gt;pollWork()&lt;br/&gt;startTheWorldWithSema&lt;br/&gt;sysmon()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: netpoll函数是非阻塞的&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.6 定时器&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;time&lt;/span&gt;.Sleep(&lt;span&gt;1&lt;/span&gt; * &lt;span&gt;time&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.868995633187773&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQrqzZaZpY5tD6APt4zQ9lfeYficLexQsphob8NX2UQicWqiaBDBIRvXO7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;458&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;2.6.1 让出&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;time.Sleep() -&amp;gt; runtime.timeSleep() -&amp;gt; mcall() -&amp;gt; park_m()&lt;br/&gt;-&amp;gt; resetForSleep() -&amp;gt; resettimer() -&amp;gt; doaddtimer()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2.6.2 唤醒&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;checkTimers() -&amp;gt; runtimer() -&amp;gt; runOneTimer() -&amp;gt; goready() -&amp;gt; systemstack() -&amp;gt; ready()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;goready()主要流程&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: mcall()和systemstack()是对应的&lt;/p&gt;&lt;h3&gt;&lt;span&gt;2.7 Channel&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;场景&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;ch &amp;lt;- &lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37900128040973113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQ9dTOEYrsenibicOiasjUUULandjLPfXibvPAT2Td2KhCph1ibxTx2rZ3R2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;2.7.1 写入channel并阻塞&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;chansend1() -&amp;gt; chansend() -&amp;gt;  hchan.sendq.enqueue() -&amp;gt; gopark()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;2.7.2 就绪&lt;/span&gt;&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;chanrecv1() -&amp;gt; chanrecv() -&amp;gt;  hchan.sendq.dequeue() -&amp;gt; recv() -&amp;gt; goready()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;2.8 同步原语&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;互斥锁与2.6、2.7的情况非常类似，只是G会存储在Treap中&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Treap是一种平衡二叉查找树&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;semaRoot 是全局唯一的&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1146616541353382&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQu3aNoqVCQN3CQJ9VTyZsamky3iad7swDyFF25fRbSDlpciboXcNKZDUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;532&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;3.参考资料&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1.g0-特殊的goroutine&lt;br/&gt;2.golang syscall原理&lt;br/&gt;3.Linux中的EAGAIN含义&lt;br/&gt;4.Golang-gopark函数和goready函数原理分析&lt;br/&gt;5.幼麟实验室-协程让出、抢占、监控和调度&lt;br/&gt;6.Golang 调度器 GMP 原理与调度全分析&lt;br/&gt;7.time.Sleep(1) 后发生了什么&lt;br/&gt;8.mcall systemstack等汇编函数&lt;/p&gt;&lt;hr/&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.396078431372549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/7K8YaGnlhQj5jbkmq1j5IxsZjFtJic6FQvSym7s3AAONnSPqibW0dkF4SCgMibPZ3zF2PenCKnxfl4bCpzrV0BurA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1020&quot; title=&quot;微信公众号&quot;/&gt;&lt;figcaption&gt;微信公众号&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>077cb0c7a530651d6fb60b88b681f8bb</guid>
<title>接口优化的常见方案实战总结</title>
<link>https://toutiao.io/k/0kwkbbt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;一、背景&lt;/h2&gt;

&lt;p&gt;针对老项目，去年做了许多降本增效的事情，其中发现最多的就是接口耗时过长的问题，就集中搞了一次接口性能优化。本文将给小伙伴们分享一下接口优化的通用方案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-15-15-20mNcnFhZrHpX157Uj.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二、接口优化方案总结&lt;/h2&gt;

&lt;h3&gt;1.批处理&lt;/h3&gt;

&lt;p&gt;批量思想：批量操作数据库，这个很好理解，我们在循环插入场景的接口中，可以在批处理执行完成后一次性插入或更新数据库，避免多次IO。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//for循环单笔入库
list.stream().forEatch(msg-&amp;gt;{
    insert();
});
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;//批量入库
batchInsert();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.异步处理&lt;/h3&gt;

&lt;p&gt;异步思想：针对耗时比较长且不是结果必须的逻辑，我们可以考虑放到异步执行，这样能降低接口耗时。&lt;/p&gt;

&lt;p&gt;例如一个理财的申购接口，&lt;strong&gt;入账&lt;/strong&gt;和&lt;strong&gt;写入申购文件&lt;/strong&gt;是同步执行的，因为是T+1交易，后面这两个逻辑其实不是结果必须的，我们并不需要关注它的实时结果，所以我们考虑把&lt;strong&gt;入账&lt;/strong&gt;和&lt;strong&gt;写入申购文件&lt;/strong&gt;改为异步处理。如图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-15-15-41I90KhqlWAKdH6DX.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至于异步的实现方式，可以用线程池，也可以用消息队列，还可以用一些调度任务框架。&lt;/p&gt;

&lt;h3&gt;3.空间换时间&lt;/h3&gt;

&lt;p&gt;一个很好理解的&lt;strong&gt;空间换时间&lt;/strong&gt;的例子是合理使用缓存，针对一些频繁使用且不频繁变更的数据，可以提前缓存起来，需要时直接查缓存，避免频繁地查询数据库或者重复计算。&lt;/p&gt;

&lt;p&gt;需要注意的事，这里用了合理二字，因为空间换时间也是一把双刃剑，需要综合考虑你的使用场景，毕竟缓存带来的数据一致性问题也挺令人头疼。&lt;/p&gt;

&lt;p&gt;这里的缓存可以是R2M，也可以是本地缓存、memcached，或者Map。&lt;/p&gt;

&lt;p&gt;举一个股票工具的查询例子：&lt;/p&gt;

&lt;p&gt;因为策略轮动的调仓信息，每周只更新一次，所以原来的调接口就去查库的逻辑并不合理，而且拿到调仓信息后，需要经过复杂计算，最终得出回测收益和跑赢沪深指数这些我们想要的结果。如果我们把查库操作和计算结果放入缓存，可以节省很多的执行时间。如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-15-15-53eCnCl9ecwF9wgX53.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;4.预处理&lt;/h3&gt;

&lt;p&gt;也就是预取思想，就是提前要把查询的数据，提前计算好，放入缓存或者表中的某个字段，用的时候会大幅提高接口性能。跟上面那个例子很像，但是关注点不同。&lt;/p&gt;

&lt;p&gt;举个简单的例子：理财产品，会有根据净值计算年化收益率的数据展示需求，利用净值去套用年化收益率计算公式计算的逻辑我们可以采用预处理，这样每一次接口调用直接取对应字段就可以了。&lt;/p&gt;

&lt;h3&gt;5.池化思想&lt;/h3&gt;

&lt;p&gt;我们都用过数据库连接池，线程池等，这就是池思想的体现，它们解决的问题就是避免重复创建对象或创建连接，可以重复利用，避免不必要的损耗，毕竟创建销毁也会占用时间。&lt;/p&gt;

&lt;p&gt;池化思想包含但并不局限于以上两种，总的来说池化思想的本质是&lt;strong&gt;预分配与循环使用，&lt;/strong&gt;明白这个原理后，我们即使是在做一些业务场景的需求时，也可以利用起来。&lt;/p&gt;

&lt;p&gt;比如：对象池&lt;/p&gt;

&lt;h3&gt;6.串行改并行&lt;/h3&gt;

&lt;p&gt;串行就是，当前执行逻辑必须等上一个执行逻辑结束之后才执行，并行就是两个执行逻辑互不干扰，所以并行相对来说就比较节省时间，当然是建立在没有结果参数依赖的前提下。&lt;/p&gt;

&lt;p&gt;比如，理财的持仓信息展示接口，我们既需要查询用户的账户信息，也需要查询商品信息和banner位信息等等来渲染持仓页，如果是串行，基本上接口耗时就是累加的。如果是并行，接口耗时将大大降低。&lt;/p&gt;

&lt;p&gt;如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-15-16-27TZL2iuGmfo15UJc8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;7.索引&lt;/h3&gt;

&lt;p&gt;加索引能大大提高数据查询效率，这个在接口设计之出也会考虑到，这里不再多赘述，随着需求的迭代，我们重点整理一下索引不生效的一些场景，希望对小伙伴们有所帮助。&lt;/p&gt;

&lt;p&gt;具体不生效场景不再一一举例，后面有时间的话，单独整理一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://s3.cn-north-1.jdcloud-oss.com/shendengbucket1/2023-02-15-16-34ng34XPW6B9U8nTWR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;8.避免大事务&lt;/h3&gt;

&lt;p&gt;所谓大事务问题，就是&lt;strong&gt;运行时间较长的事务，&lt;/strong&gt;由于事务一致不提交，会导致数据库连接被占用，影响到别的请求访问数据库，影响别的接口性能。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Transactional(value = &quot;taskTransactionManager&quot;, propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, rollbackFor = {RuntimeException.class, Exception.class})
    public BasicResult purchaseRequest(PurchaseRecord record) {
        BasicResult result = new BasicResult();
        //插入账户任务
        taskMapper.insert(ManagerParamUtil.buildTask(record, TaskEnum.Task_type.pension_account.type(), TaskEnum.Account_bizType.purchase_request.type()));
        //插入同步任务
        taskMapper.insert(ManagerParamUtil.buildTask(record, TaskEnum.Task_type.pension_sync.type(), TaskEnum.Sync_bizType.purchase.type()));
        //插入影像件上传任务
        taskMapper.insert(ManagerParamUtil.buildTask(record, TaskEnum.Task_type.pension_sync.type(), TaskEnum.Sync_bizType.cert.type()));
        result.setInfo(ResultInfoEnum.SUCCESS);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这块代码主要是申购申请完成后，执行一系列的后续操作，如果现在新增申购完成后，发送push通知用户的需求。很有可能我们会在后面直接追加，如下图所示：事务中嵌套RPC调用，即非DB操作，这些非DB操作如果耗时较大的话，可能会出现大事务问题。大数据引发的问题主要有：死锁、接口超时、主从延迟等。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Transactional(value = &quot;taskTransactionManager&quot;, propagation = Propagation.REQUIRED, isolation = Isolation.READ_COMMITTED, rollbackFor = {RuntimeException.class, Exception.class})
    public BasicResult purchaseRequest(PurchaseRecord record) {
        BasicResult result = new BasicResult();
        ...
        pushRpc.doPush(record);        
        result.setInfo(ResultInfoEnum.SUCCESS);
        return result;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以为避免大事务问题，我们可以通过以下方案规避：&lt;/p&gt;

&lt;p&gt;1，RPC调用不放到事务里面&lt;/p&gt;

&lt;p&gt;2，查询操作尽量放到事务之外&lt;/p&gt;

&lt;p&gt;3，事务中避免处理太多数据&lt;/p&gt;

&lt;h3&gt;9.优化程序结构&lt;/h3&gt;

&lt;p&gt;程序结构问题一般出现在多次需求迭代后，代码叠加形成。会造成一些重复查询、多次创建对象等耗时问题。在多人维护一个项目时比较多见。解决起来也比较简单，我们需要针对接口整体做重构，评估每个代码块的作用和用途，调整执行顺序。&lt;/p&gt;

&lt;h3&gt;10.深分页问题&lt;/h3&gt;

&lt;p&gt;深分页问题比较常见，分页我们一般最先想到的就是 limit ，为什么会慢，我们可以看下这个SQL：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    select * from purchase_record where productCode = &#x27;PA9044&#x27; and status=4 order by orderTime desc limit 100000,200 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;limit 100000,200 意味着会扫描100200行，然后返回200行，丢弃掉前100000行。所以执行速度很慢。一般可以采用标签记录法来优化，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    select * from purchase_record where productCode = &#x27;PA9044&#x27; and status=4 and id &amp;gt; 100000 limit 200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样优化的好处是命中了主键索引，无论多少页，性能都还不错，但是局限性是需要一个连续自增的字段&lt;/p&gt;

&lt;h3&gt;11.SQL优化&lt;/h3&gt;

&lt;p&gt;sql优化能大幅提高接口的查询性能，由于本文重点讲述接口优化的方案，具体sql优化不再一一列举，小伙伴们可以结合索引、分页、等关注点考虑优化方案。&lt;/p&gt;

&lt;h3&gt;12.锁粒度避免过粗&lt;/h3&gt;

&lt;p&gt;锁一般是为了在高并发场景下保护共享资源采用的一种手段，但是如果锁的粒度太粗，会很影响接口性能。&lt;/p&gt;

&lt;p&gt;关于锁粒度：就是你要锁的范围有多大，不管是synchronized还是redis分布式锁，只需要在临界资源处加锁即可，不涉及共享资源的，不必要加锁，就好比你要上卫生间，只需要把卫生间的门锁上就可以，不需要把客厅的门也锁上。&lt;/p&gt;

&lt;p&gt;错误的加锁方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        //非共享资源
        private void notShare(){
        }
        //共享资源
        private void share(){
        }
        private int wrong(){
            synchronized (this) {
                share();
                notShare();
            }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正确的加锁方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       //非共享资源
        private void notShare(){
        }
        //共享资源
        private void share(){
        }
        private int right(){
            notShare();
            synchronized (this) {
                share();

            }
        } 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三、最后&lt;/h2&gt;

&lt;h3&gt;接口性能问题形成的原因思考&lt;/h3&gt;

&lt;p&gt;我相信很多接口的效率问题不是一朝一夕形成的，在需求迭代的过程中，为了需求快速上线，采取直接累加代码的方式去实现功能，这样会造成以上这些接口性能问题。&lt;/p&gt;

&lt;p&gt;变换思路，更高一级思考问题，站在接口设计者的角度去开发需求，会避免很多这样的问题，也是降本增效的一种行之有效的方式。&lt;/p&gt;

&lt;p&gt;以上，共勉！&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aa67190d046f9a8679d3075dbaa684ec</guid>
<title>身处职场，一定要落落大方，不要畏手畏脚</title>
<link>https://toutiao.io/k/5s657wp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p data-track=&quot;3&quot; data-pm-slice=&quot;1 1 []&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作社区签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-track=&quot;3&quot; data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;  hello，大家好，我是张张，「架构精进之路」公号作者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记得刚参加工作的时候，胆小怕事，看到领导就害怕，躲得远远的，脸皮薄，还自尊心强，特别在意同事们的眼光，不敢得罪任何人，&lt;/span&gt;&lt;span&gt;对谁都低三下四的，做事畏手畏脚，工作干的那叫一个卑微。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;科室里一个要退休的老同事实在看不下去了，退休之前和我聊了许多，让我受益匪浅。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大体意思就是，在体制内工作，只要不犯原则性错误，就没有人能把你开除了，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;做事情一定要落落大方，而不是畏手畏脚，那样只会让别人更加看不起，让领导认为你懦弱无能，让同事对你得寸进尺！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTpClHffIiae28puR3niclC0pZvWwXGFrE6dKxNX80RTYPIIdibqb1SgQ7lRz0Wice828hNI1xIX5ZDrA/640?wx_fmt=jpeg&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; &lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;不要怕做抛头露面的事情&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;会议上，领导让你汇报工作，不要扭扭捏捏的，大大方方的讲出来，就像公务员面试一样；&lt;/span&gt;&lt;span&gt;酒桌上，该说说，该笑笑，不要小家子气，该敬酒敬酒，该轮圈轮圈，偶尔喝多了也无所谓。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多抛头露面的事情都是一回生，二回熟，时间长了也就锻炼出来了！&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; &lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;不要在意别人的目光和议论&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;每个单位都有一些人喜欢嚼舌根，只要他们看不上你，无论你做什么，他们都会认为你是错的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你和领导走的近了，他们说你拍马屁；&lt;/span&gt;&lt;span&gt;你努力认真工作，他们说你装样子；&lt;/span&gt;&lt;span&gt;你帮助别人，他们说你假慈悲……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以不要在意他们的胡言乱语，做好自己的事情，&lt;/span&gt;&lt;span&gt;时间长了，大家也就知道了你的为人，这些谎言也就不攻自破！&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; &lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;不要害怕和领导交流&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在体制内工作，吃亏的往往是只会低头拉车，不会抬头看路的人。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;害怕和领导交流，不会和领导套近乎，即使再埋头苦干，最终吃亏的还是自己。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以要把领导当作一名长者，尊敬但不要畏惧，见面要打招呼，积极去汇报工作，私下也要经常来往，维持好关系，只有这样，你才能会被重用，或者躺的舒服。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; &lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;你遇到的大多数人，这辈子都不可能见到第二面&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;比如，地铁上的人，路边的人，你们永远只是擦肩而过。而剩下的小部分人里的大部分，就算你们现在经常见面，未来也不可能再见。比如，公司大部分同事，离职之后这辈子不会再见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，你为什么要在意他们的眼光和看法？为什么要因为他们而改变你的人生选择?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想明白这件事之后，你就会“放肆”很多。我第一年工作时连带个饭上班都觉得不好意思偷偷摸摸的,但是后来敢在会议上提出自己的看法。&lt;/span&gt;&lt;span&gt;只要在规则允许的范围内，穿你爱穿的衣服，做你想做的事情，世界就是你的游乐场。&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; 5&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;不要害怕得罪老油条&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为什么一些人被称为老油条，就是因为他们又老又油、又硬！工作时间长，年龄大，晋升无望，所以不好好工作，每天就混日子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这些老油条完全不用搭理他们，他们只会欺软怕硬，你越不想得罪他们，他们越是把工作和责任推给你，所以该怼的时候就怼过去，即使闹到领导那里，也大可不必担心，因为领导也知道是怎么回事。&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; 6&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;别人对你的方式，都是被你惯的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当对方的语言，脱离事情本身，而是人身攻击时，必须给予反击。很多人讲话，都是在拿你出气，宣泄自己的情绪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;你过度&lt;/span&gt;地&lt;span&gt;忍让，只会换来别人的变本加厉。&lt;/span&gt;&lt;span&gt;优秀的人一定很强势，世界上不存在不强势而&lt;/span&gt;又&lt;span&gt;优秀的人。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; 7&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;不要被动工作&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;总有人摆脱不了“学生”标签，万事只会等待而又畏手畏脚，总希望有人可以来告诉自己下一步做什么。这样的结果就是，老司机们忙到死，自己却总感觉手上没活，慌到不行。不光如此，总是需要别人来询问自己的工作进度，开始不懂得做好计划，中间不记得实时监控，事后不会总结复盘。像一支牙膏，挤一下出一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自己和老板是雇佣关系而非师徒关系，不能积极主动创造价值，总抱着学习的心态等待分配的，只会黯然离场。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; 8&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;允许自己犯错&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从小我们都被教育别犯错，错了就会挨骂，以至于很多人成年之后总是生怕自己犯错，不敢轻易做选择，不敢表现。不要对自己要求太严格，承认自己也是个普通人吧。谁不是一边犯错一边成长呢?从错误中获得成长，也许比任何方式都更快。&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;28357&quot; data-type=&quot;lspecial02,lspecial06&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-bastyle=&quot;width:24px;height:24px;background-color: #666666;border-radius: 50%;&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt; 9&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9d6cd&quot;&gt;&lt;p data-md5=&quot;9d6cd&quot;&gt;&lt;strong data-md5=&quot;9d6cd&quot;&gt;远离身边负能量的人&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;常常释放负能量的人，大多数是见不得身边的人过的比 ta好，所以把负能量分享给你，让你和ta一样满载。&lt;/span&gt;&lt;span&gt;当你身边亲朋好友总以玩笑名义一句句伤害你，嘲讽打击你，“就你?你可以吗?”久而久之你会更自卑敏感，&lt;/span&gt;&lt;span&gt;因为你觉得你们很亲近，他们不可能害你，所以你从没怀疑过他们的看法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;尝试和他们保持距离，悄悄努力，不试怎么知道不行呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;667&quot; data-ratio=&quot;0.667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTpClHffIiae28puR3niclC0pgVLScEqFudr16Nr4PfPRzScgE5fRAfOh7mcoUF6XYWjkEfc2giadn5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot; data-width=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家，InfoQ写作社区签约作者。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;1&quot; data-origin_num=&quot;109&quot; data-isban=&quot;0&quot; data-weui-theme=&quot;light&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领学习资料&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;28&quot;&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;如果您觉得还不错，欢迎关注和转发~     &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5163398692810458&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9TPn66HT930CzevNBb2yMhKjOn9yuJqsCPbyzicCBx6Zm9sNJCWibo6VzGRYbxrSfjJaaGibSRuyZFQmr3KcX07sw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53b84133614bbda946fa9635266dbb23</guid>
<title>Linux I/O 原理和 Zero-copy 技术全面揭秘</title>
<link>https://toutiao.io/k/lfo4bhe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;K4SWAFwx&quot;&gt;作者：allanpan，腾讯 IEG 后台开发工程师&lt;/p&gt;&lt;blockquote data-pid=&quot;lXLWq2n9&quot;&gt; 两万字长文从虚拟内存、I/O 缓冲区，用户态&amp;amp;内核态以及 I/O 模式等等知识点全面而又详尽地剖析 Linux 系统的 I/O 底层原理，分析了 Linux 传统的 I/O 模式的弊端，进而引入 Linux Zero-copy 零拷贝技术的介绍和原理解析，将零拷贝技术和传统的 I/O 模式进行区分和对比，帮助读者理解 Linux 内核对 I/O 模块的优化改进思路。 全网最深度和详尽的 Linux I/O 及零拷贝技术的解析文章&lt;br/&gt; &lt;/blockquote&gt;&lt;h3&gt;&lt;b&gt;导言&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;_rY0kQ3G&quot;&gt;如今的网络应用早已从 CPU 密集型转向了 I/O 密集型，网络服务器大多是基于 &lt;code&gt;C-S&lt;/code&gt; 模型，也即 &lt;code&gt;客户端 - 服务端&lt;/code&gt; 模型，客户端需要和服务端进行大量的网络通信，这也决定了现代网络应用的性能瓶颈：I/O。&lt;/p&gt;&lt;p data-pid=&quot;jPH4X4Pl&quot;&gt;传统的 Linux 操作系统的标准 I/O 接口是基于数据拷贝操作的，即 I/O 操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间进行传输。设置缓冲区最大的好处是可以减少磁盘 I/O 的操作，如果所请求的数据已经存放在操作系统的高速缓冲存储器中，那么就不需要再进行实际的物理磁盘 I/O 操作；然而传统的 Linux I/O 在数据传输过程中的数据拷贝操作深度依赖 CPU，也就是说 I/O 过程需要 CPU 去执行数据拷贝的操作，因此导致了极大的系统开销，限制了操作系统有效进行数据传输操作的能力。&lt;/p&gt;&lt;p data-pid=&quot;pU2jMweo&quot;&gt;I/O 是决定网络服务器性能瓶颈的关键，而传统的 Linux I/O 机制又会导致大量的数据拷贝操作，损耗性能，所以我们亟需一种新的技术来解决数据大量拷贝的问题，这个答案就是零拷贝(Zero-copy)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;计算机存储器&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;6vQteNnU&quot;&gt;既然要分析 Linux I/O，就不能不了解计算机的各类存储器。&lt;/p&gt;&lt;p data-pid=&quot;5THxKOq8&quot;&gt;存储器是计算机的核心部件之一，在完全理想的状态下，存储器应该要同时具备以下三种特性：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;MYNZ9l-D&quot;&gt;速度足够快：存储器的存取速度应当快于 CPU 执行一条指令，这样 CPU 的效率才不会受限于存储器&lt;/li&gt;&lt;li data-pid=&quot;KrjmYEhz&quot;&gt;容量足够大：容量能够存储计算机所需的全部数据&lt;/li&gt;&lt;li data-pid=&quot;pDqnW4zd&quot;&gt;价格足够便宜：价格低廉，所有类型的计算机都能配备&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;Z8P79TRa&quot;&gt;但是现实往往是残酷的，我们目前的计算机技术无法同时满足上述的三个条件，于是现代计算机的存储器设计采用了一种分层次的结构：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-4dc6ed4e227738402c59084dbd7c3828_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-4dc6ed4e227738402c59084dbd7c3828_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;306&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-4dc6ed4e227738402c59084dbd7c3828_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-4dc6ed4e227738402c59084dbd7c3828_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ycrlELXn&quot;&gt;从顶至底，现代计算机里的存储器类型分别有：寄存器、高速缓存、主存和磁盘，这些存储器的速度逐级递减而容量逐级递增 。存取速度最快的是寄存器，因为寄存器的制作材料和 CPU 是相同的，所以速度和 CPU 一样快，CPU 访问寄存器是没有时延的，然而因为价格昂贵，因此容量也极小，一般 32 位的 CPU 配备的寄存器容量是 32✖️32 Bit，64 位的 CPU 则是 64✖️64 Bit，不管是 32 位还是 64 位，寄存器容量都小于 1 KB，且寄存器也必须通过软件自行管理。&lt;/p&gt;&lt;p data-pid=&quot;WcTKxPlo&quot;&gt;第二层是高速缓存，也即我们平时了解的 CPU 高速缓存 L1、L2、L3，一般 L1 是每个 CPU 独享，L3 是全部 CPU 共享，而 L2 则根据不同的架构设计会被设计成独享或者共享两种模式之一，比如 Intel 的多核芯片采用的是共享 L2 模式而 AMD 的多核芯片则采用的是独享 L2 模式。&lt;/p&gt;&lt;p data-pid=&quot;-wjI-c-U&quot;&gt;第三层则是主存，也即主内存，通常称作随机访问存储器（Random Access Memory, RAM）。是与 CPU 直接交换数据的内部存储器。它可以随时读写（刷新时除外），而且速度很快，通常作为操作系统或其他正在运行中的程序的临时资料存储介质。&lt;/p&gt;&lt;p data-pid=&quot;mNM-kcx8&quot;&gt;最后则是磁盘，磁盘和主存相比，每个二进制位的成本低了两个数量级，因此容量比之会大得多，动辄上 GB、TB，而问题是访问速度则比主存慢了大概三个数量级。机械硬盘速度慢主要是因为机械臂需要不断在金属盘片之间移动，等待磁盘扇区旋转至磁头之下，然后才能进行读写操作，因此效率很低。&lt;/p&gt;&lt;p data-pid=&quot;mgQBQMGV&quot;&gt;&lt;b&gt;主内存是操作系统进行 I/O 操作的重中之重，绝大部分的工作都是在用户进程和内核的内存缓冲区里完成的，因此我们接下来需要提前学习一些主存的相关原理。&lt;/b&gt;&lt;/p&gt;&lt;h3&gt;&lt;b&gt;物理内存&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;Wba-S-At&quot;&gt;我们平时一直提及的物理内存就是上文中对应的第三种计算机存储器，RAM 主存，它在计算机中以内存条的形式存在，嵌在主板的内存槽上，用来加载各式各样的程序与数据以供 CPU 直接运行和使用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;虚拟内存&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;5B19nXM9&quot;&gt;在计算机领域有一句如同摩西十诫般神圣的哲言：&quot;&lt;b&gt;计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决&lt;/b&gt;&quot;，从内存管理、网络模型、并发调度甚至是硬件架构，都能看到这句哲言在闪烁着光芒，而虚拟内存则是这一哲言的完美实践之一。&lt;/p&gt;&lt;p data-pid=&quot;SDyLkTq-&quot;&gt;虚拟内存是现代计算机中的一个非常重要的存储器抽象，主要是用来解决应用程序日益增长的内存使用需求：现代物理内存的容量增长已经非常快速了，然而还是跟不上应用程序对主存需求的增长速度，对于应用程序来说内存还是不够用，因此便需要一种方法来解决这两者之间的容量差矛盾。&lt;/p&gt;&lt;p data-pid=&quot;KruUapjT&quot;&gt;计算机对多程序内存访问的管理经历了 &lt;code&gt;静态重定位&lt;/code&gt; --&amp;gt; &lt;code&gt;动态重定位&lt;/code&gt; --&amp;gt; &lt;code&gt;交换(swapping)技术&lt;/code&gt; --&amp;gt; &lt;code&gt;虚拟内存&lt;/code&gt;，最原始的多程序内存访问是直接访问绝对内存地址，这种方式几乎是完全不可用的方案，因为如果每一个程序都直接访问物理内存地址的话，比如两个程序并发执行以下指令的时候：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bx&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ax&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;y_SZRksm&quot;&gt;这一段汇编表示在地址 1000:0 处存入数值 2，然后在后面的逻辑中把该地址的值取出来乘以 2，最终存入 ax 寄存器的值就是 4，如果第二个程序存入 cx 寄存器里的值是 3，那么并发执行的时候，第一个程序最终从 ax 寄存器里得到的值就可能是 6，这就完全错误了，得到脏数据还顶多算程序结果错误，要是其他程序往特定的地址里写入一些危险的指令而被另一个程序取出来执行，还可能会导致整个系统的崩溃。所以，为了确保进程间互不干扰，每一个用户进程都需要实时知晓当前其他进程在使用哪些内存地址，这对于写程序的人来说无疑是一场噩梦。&lt;/p&gt;&lt;p data-pid=&quot;-pMjD4qz&quot;&gt;因此，操作绝对内存地址是完全不可行的方案，那就只能用操作相对内存地址，我们知道每个进程都会有自己的进程地址，从 0 开始，可以通过相对地址来访问内存，但是这同样有问题，还是前面类似的问题，比如有两个大小为 16KB 的程序 A 和 B，现在它们都被加载进了内存，内存地址段分别是 0 ~ 16384，16384 ~ 32768。A 的第一条指令是 &lt;code&gt;jmp 1024&lt;/code&gt;，而在地址 1024 处是一条 &lt;code&gt;mov&lt;/code&gt; 指令，下一条指令是 &lt;code&gt;add&lt;/code&gt;，基于前面的 &lt;code&gt;mov&lt;/code&gt; 指令做加法运算，与此同时，B 的第一条指令是 &lt;code&gt;jmp 1028&lt;/code&gt;，本来在 B 的相对地址 1028 处应该也是一条 &lt;code&gt;mov&lt;/code&gt; 去操作自己的内存地址上的值，但是由于这两个程序共享了段寄存器，因此虽然他们使用了各自的相对地址，但是依然操作的还是绝对内存地址，于是 B 就会跳去执行 &lt;code&gt;add&lt;/code&gt; 指令，这时候就会因为非法的内存操作而 crash。&lt;/p&gt;&lt;p data-pid=&quot;qS0bfFYC&quot;&gt;有一种&lt;code&gt;静态重定位&lt;/code&gt;的技术可以解决这个问题，它的工作原理非常简单粗暴：当 B 程序被加载到地址 16384 处之后，把 B 的所有相对内存地址都加上 16384，这样的话当 B 执行 &lt;code&gt;jmp 1028&lt;/code&gt; 之时，其实执行的是 &lt;code&gt;jmp 1028+16384&lt;/code&gt;，就可以跳转到正确的内存地址处去执行正确的指令了，但是这种技术并不通用，而且还会对程序装载进内存的性能有影响。&lt;/p&gt;&lt;p data-pid=&quot;Xck_mxO5&quot;&gt;再往后，就发展出来了存储器抽象：地址空间，就好像进程是 CPU 的抽象，地址空间则是存储器的抽象，每个进程都会分配独享的地址空间，但是独享的地址空间又带来了新的问题：如何实现不同进程的相同相对地址指向不同的物理地址？最开始是使用&lt;code&gt;动态重定位&lt;/code&gt;技术来实现，这是用一种相对简单的地址空间到物理内存的映射方法。基本原理就是为每一个 CPU 配备两个特殊的硬件寄存器：基址寄存器和界限寄存器，用来动态保存每一个程序的起始物理内存地址和长度，比如前文中的 A，B 两个程序，当 A 运行时基址寄存器和界限寄存器就会分别存入 0 和 16384，而当 B 运行时则两个寄存器又会分别存入 16384 和 32768。然后每次访问指定的内存地址时，CPU 会在把地址发往内存总线之前自动把基址寄存器里的值加到该内存地址上，得到一个真正的物理内存地址，同时还会根据界限寄存器里的值检查该地址是否溢出，若是，则产生错误中止程序，&lt;code&gt;动态重定位&lt;/code&gt;技术解决了&lt;code&gt;静态重定位&lt;/code&gt;技术造成的程序装载速度慢的问题，但是也有新问题：每次访问内存都需要进行加法和比较运算，比较运算本身可以很快，但是加法运算由于进位传递时间的问题，除非使用特殊的电路，否则会比较慢。&lt;/p&gt;&lt;p data-pid=&quot;OIKAI_UN&quot;&gt;然后就是 &lt;code&gt;交换（swapping）&lt;/code&gt;技术，这种技术简单来说就是动态地把程序在内存和磁盘之间进行交换保存，要运行一个进程的时候就把程序的代码段和数据段调入内存，然后再把程序封存，存入磁盘，如此反复。为什么要这么麻烦？因为前面那两种重定位技术的前提条件是计算机内存足够大，能够把所有要运行的进程地址空间都加载进主存，才能够并发运行这些进程，但是现实往往不是如此，内存的大小总是有限的，所有就需要另一类方法来处理内存超载的情况，第一种便是简单的交换技术：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-339fc1c254df291ad7eb12008f38a4ef_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1450&quot; data-rawheight=&quot;648&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-339fc1c254df291ad7eb12008f38a4ef_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1450&quot; data-rawheight=&quot;648&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-339fc1c254df291ad7eb12008f38a4ef_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-339fc1c254df291ad7eb12008f38a4ef_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;CVr0BEKF&quot;&gt;先把进程 A 换入内存，然后启动进程 B 和 C，也换入内存，接着 A 被从内存交换到磁盘，然后又有新的进程 D 调入内存，用了 A 退出之后空出来的内存空间，最后 A 又被重新换入内存，由于内存布局已经发生了变化，所以 A 在换入内存之时会通过软件或者在运行期间通过硬件（基址寄存器和界限寄存器）对其内存地址进行重定位，多数情况下都是通过硬件。&lt;/p&gt;&lt;p data-pid=&quot;mEI4jKkQ&quot;&gt;另一种处理内存超载的技术就是&lt;code&gt;虚拟内存&lt;/code&gt;技术了，它比&lt;code&gt;交换（swapping）&lt;/code&gt;技术更复杂而又更高效，是目前最新应用最广泛的存储器抽象技术：&lt;/p&gt;&lt;p data-pid=&quot;SA0y1mOv&quot;&gt;虚拟内存的核心原理是：为每个程序设置一段&quot;连续&quot;的虚拟地址空间，把这个地址空间分割成多个具有连续地址范围的页 (page)，并把这些页和物理内存做映射，在程序运行期间动态映射到物理内存。当程序引用到一段在物理内存的地址空间时，由硬件立刻执行必要的映射；而当程序引用到一段不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3743073fa3f83c50434b4c02b44dd769_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;904&quot; data-rawheight=&quot;1118&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3743073fa3f83c50434b4c02b44dd769_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;904&quot; data-rawheight=&quot;1118&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3743073fa3f83c50434b4c02b44dd769_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3743073fa3f83c50434b4c02b44dd769_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;4KXksyJj&quot;&gt;虚拟地址空间按照固定大小划分成被称为页（page）的若干单元，物理内存中对应的则是页框（page frame）。这两者一般来说是一样的大小，如上图中的是 4KB，不过实际上计算机系统中一般是 512 字节到 1 GB，这就是虚拟内存的分页技术。因为是虚拟内存空间，每个进程分配的大小是 4GB (32 位架构)，而实际上当然不可能给所有在运行中的进程都分配 4GB 的物理内存，所以虚拟内存技术还需要利用到前面介绍的&lt;code&gt;交换（swapping）&lt;/code&gt;技术，在进程运行期间只分配映射当前使用到的内存，暂时不使用的数据则写回磁盘作为副本保存，需要用的时候再读入内存，动态地在磁盘和内存之间交换数据。&lt;/p&gt;&lt;p data-pid=&quot;4KLs60Bm&quot;&gt;其实虚拟内存技术从某种角度来看的话，很像是糅合了基址寄存器和界限寄存器之后的新技术。它使得整个进程的地址空间可以通过较小的单元映射到物理内存，而不需要为程序的代码和数据地址进行重定位。&lt;/p&gt;&lt;p data-pid=&quot;8J1r2I1i&quot;&gt;进程在运行期间产生的内存地址都是虚拟地址，如果计算机没有引入虚拟内存这种存储器抽象技术的话，则 CPU 会把这些地址直接发送到内存地址总线上，直接访问和虚拟地址相同值的物理地址；如果使用虚拟内存技术的话，CPU 则是把这些虚拟地址通过地址总线送到内存管理单元（Memory Management Unit，MMU），MMU 将虚拟地址映射为物理地址之后再通过内存总线去访问物理内存：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-9a6c68bfcddbc196a091ee8ed7a509ad_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-9a6c68bfcddbc196a091ee8ed7a509ad_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;502&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-9a6c68bfcddbc196a091ee8ed7a509ad_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-9a6c68bfcddbc196a091ee8ed7a509ad_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;vV6jxd_X&quot;&gt;虚拟地址（比如 16 位地址 8196=0010 000000000100）分为两部分：虚拟页号（高位部分）和偏移量（低位部分），虚拟地址转换成物理地址是通过页表（page table）来实现的，页表由页表项构成，页表项中保存了页框号、修改位、访问位、保护位和 &quot;在/不在&quot; 位等信息，从数学角度来说页表就是一个函数，入参是虚拟页号，输出是物理页框号，得到物理页框号之后复制到寄存器的高三位中，最后直接把 12 位的偏移量复制到寄存器的末 12 位构成 15 位的物理地址，即可以把该寄存器的存储的物理内存地址发送到内存总线：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-1fa456ede3dc9c8e6f950f5ca97713d7_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1052&quot; data-rawheight=&quot;1270&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-1fa456ede3dc9c8e6f950f5ca97713d7_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1052&quot; data-rawheight=&quot;1270&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-1fa456ede3dc9c8e6f950f5ca97713d7_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-1fa456ede3dc9c8e6f950f5ca97713d7_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;AkGAs-OS&quot;&gt;在 MMU 进行地址转换时，如果页表项的 &quot;在/不在&quot; 位是 0，则表示该页面并没有映射到真实的物理页框，则会引发一个&lt;b&gt;缺页中断&lt;/b&gt;，CPU 陷入操作系统内核，接着操作系统就会通过页面置换算法选择一个页面将其换出 (swap)，以便为即将调入的新页面腾出位置，如果要换出的页面的页表项里的修改位已经被设置过，也就是被更新过，则这是一个脏页 (dirty page)，需要写回磁盘更新改页面在磁盘上的副本，如果该页面是&quot;干净&quot;的，也就是没有被修改过，则直接用调入的新页面覆盖掉被换出的旧页面即可。&lt;/p&gt;&lt;p data-pid=&quot;rX7iiriq&quot;&gt;最后，还需要了解的一个概念是转换检测缓冲器（Translation Lookaside Buffer，TLB），也叫快表，是用来加速虚拟地址映射的，因为虚拟内存的分页机制，页表一般是保存内存中的一块固定的存储区，导致进程通过 MMU 访问内存比直接访问内存多了一次内存访问，性能至少下降一半，因此需要引入加速机制，即 TLB 快表，TLB 可以简单地理解成页表的高速缓存，保存了最高频被访问的页表项，由于一般是硬件实现的，因此速度极快，MMU 收到虚拟地址时一般会先通过硬件 TLB 查询对应的页表号，若命中且该页表项的访问操作合法，则直接从 TLB 取出对应的物理页框号返回，若不命中则穿透到内存页表里查询，并且会用这个从内存页表里查询到最新页表项替换到现有 TLB 里的其中一个，以备下次缓存命中。&lt;/p&gt;&lt;p data-pid=&quot;7a0aMX82&quot;&gt;至此，我们介绍完了包含虚拟内存在内的多项计算机存储器抽象技术，虚拟内存的其他内容比如针对大内存的多级页表、倒排页表，以及处理缺页中断的页面置换算法等等，以后有机会再单独写一篇文章介绍，或者各位读者也可以先行去查阅相关资料了解，这里就不再深入了。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;用户态和内核态&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;nsg0yzyQ&quot;&gt;一般来说，我们在编写程序操作 Linux I/O 之时十有八九是在用户空间和内核空间之间传输数据，因此有必要先了解一下 Linux 的用户态和内核态的概念。&lt;/p&gt;&lt;p data-pid=&quot;zmM8_Qlx&quot;&gt;首先是用户态和内核态：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ada8c33007ca9e0fa0af6d1c3a061a03_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ada8c33007ca9e0fa0af6d1c3a061a03_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;960&quot; data-rawheight=&quot;720&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ada8c33007ca9e0fa0af6d1c3a061a03_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ada8c33007ca9e0fa0af6d1c3a061a03_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ejy3jhkA&quot;&gt;从宏观上来看，Linux 操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。内核从本质上看是一种软件 —— 控制计算机的硬件资源，并提供上层应用程序 (进程) 运行的环境。用户态即上层应用程序 (进程) 的运行空间，应用程序 (进程) 的执行必须依托于内核提供的资源，这其中包括但不限于 CPU 资源、存储资源、I/O 资源等等。&lt;/p&gt;&lt;p data-pid=&quot;g0FxYOAE&quot;&gt;现代操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 2^32 B = 4G。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。&lt;/p&gt;&lt;p data-pid=&quot;cUbc8OBB&quot;&gt;因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的系统资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux 的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。Intel 的 x86 架构的 CPU 提供了 0 到 3 四个特权级，数字越小，特权越高，Linux 操作系统中主要采用了 0 和 3 两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如 C 函数库中的内存分配函数 malloc()，它具体是使用 sbrk() 系统调用来分配内存，当 malloc 调用 sbrk() 的时候就涉及一次从用户态到内核态的切换，类似的函数还有 printf()，调用的是 wirte() 系统调用来输出字符串，等等。&lt;/p&gt;&lt;p data-pid=&quot;F-7lYnNS&quot;&gt;用户进程在系统中运行时，大部分时间是处在用户态空间里的，在其需要操作系统帮助完成一些用户态没有特权和能力完成的操作时就需要切换到内核态。那么用户进程如何切换到内核态去使用那些内核资源呢？答案是：1) 系统调用（trap），2) 异常（exception）和 3) 中断（interrupt）。&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;EcSrOtt6&quot;&gt;&lt;b&gt;系统调用&lt;/b&gt;：用户进程主动发起的操作。用户态进程发起系统调用主动要求切换到内核态，陷入内核之后，由操作系统来操作系统资源，完成之后再返回到进程。&lt;/li&gt;&lt;li data-pid=&quot;Kkdm2xi0&quot;&gt;&lt;b&gt;异常&lt;/b&gt;：被动的操作，且用户进程无法预测其发生的时机。当用户进程在运行期间发生了异常（比如某条指令出了问题），这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也即是切换到了内核态。异常包括程序运算引起的各种错误如除 0、缓冲区溢出、缺页等。&lt;/li&gt;&lt;li data-pid=&quot;-pv52JXd&quot;&gt;&lt;b&gt;中断&lt;/b&gt;：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令是用户态下的程序，那么转换的过程自然就会是从用户态到内核态的切换。中断包括 I/O 中断、外部信号中断、各种定时器引起的时钟中断等。中断和异常类似，都是通过中断向量表来找到相应的处理程序进行处理。区别在于，中断来自处理器外部，不是由任何一条专门的指令造成，而异常是执行当前指令的结果。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;DUtrGDIp&quot;&gt;通过上面的分析，我们可以得出 Linux 的内部层级可分为三大部分：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5eee491b948a08c4fb9ffc95dda72578_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;842&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5eee491b948a08c4fb9ffc95dda72578_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;842&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5eee491b948a08c4fb9ffc95dda72578_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5eee491b948a08c4fb9ffc95dda72578_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;Linux I/O&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;I/O 缓冲区&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2d74d7110e0d7496e99a047768d9e626_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1567&quot; data-rawheight=&quot;1352&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2d74d7110e0d7496e99a047768d9e626_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1567&quot; data-rawheight=&quot;1352&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2d74d7110e0d7496e99a047768d9e626_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2d74d7110e0d7496e99a047768d9e626_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;lv4xRPOt&quot;&gt;在 Linux 中，当程序调用各类文件操作函数后，用户数据（User Data）到达磁盘（Disk）的流程如上图所示。&lt;/p&gt;&lt;p data-pid=&quot;2M2oJY4U&quot;&gt;图中描述了 Linux 中文件操作函数的层级关系和内存缓存层的存在位置，中间的黑色实线是用户态和内核态的分界线。&lt;/p&gt;&lt;p data-pid=&quot;L45RVBBe&quot;&gt;&lt;code&gt;read(2)/write(2)&lt;/code&gt; 是 Linux 系统中最基本的 I/O 读写系统调用，我们开发操作 I/O 的程序时必定会接触到它们，而在这两个系统调用和真实的磁盘读写之间存在一层称为 &lt;code&gt;Kernel buffer cache&lt;/code&gt; 的缓冲区缓存。在 Linux 中 I/O 缓存其实可以细分为两个：&lt;code&gt;Page Cache&lt;/code&gt; 和 &lt;code&gt;Buffer Cache&lt;/code&gt;，这两个其实是一体两面，共同组成了 Linux 的内核缓冲区（Kernel Buffer Cache）：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;XdR4wP4o&quot;&gt;&lt;b&gt;读磁盘&lt;/b&gt;：内核会先检查 &lt;code&gt;Page Cache&lt;/code&gt; 里是不是已经缓存了这个数据，若是，直接从这个内存缓冲区里读取返回，若否，则穿透到磁盘去读取，然后再缓存在 &lt;code&gt;Page Cache&lt;/code&gt; 里，以备下次缓存命中；&lt;/li&gt;&lt;li data-pid=&quot;G_VX3ZU5&quot;&gt;&lt;b&gt;写磁盘&lt;/b&gt;：内核直接把数据写入 &lt;code&gt;Page Cache&lt;/code&gt;，并把对应的页标记为 dirty，添加到 dirty list 里，然后就直接返回，内核会定期把 dirty list 的页缓存 flush 到磁盘，保证页缓存和磁盘的最终一致性。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;ee4eEsWU&quot;&gt;&lt;code&gt;Page Cache&lt;/code&gt; 会通过页面置换算法如 LRU 定期淘汰旧的页面，加载新的页面。可以看出，所谓 I/O 缓冲区缓存就是在内核和磁盘、网卡等外设之间的一层缓冲区，用来提升读写性能的。&lt;/p&gt;&lt;p data-pid=&quot;f_yGPj7Z&quot;&gt;在 Linux 还不支持虚拟内存技术之前，还没有页的概念，因此 &lt;code&gt;Buffer Cache&lt;/code&gt; 是基于操作系统读写磁盘的最小单位 -- 块（block）来进行的，所有的磁盘块操作都是通过 &lt;code&gt;Buffer Cache&lt;/code&gt; 来加速，Linux 引入虚拟内存的机制来管理内存后，页成为虚拟内存管理的最小单位，因此也引入了 &lt;code&gt;Page Cache&lt;/code&gt; 来缓存 Linux 文件内容，主要用来作为文件系统上的文件数据的缓存，提升读写性能，常见的是针对文件的 &lt;code&gt;read()/write()&lt;/code&gt; 操作，另外也包括了通过 &lt;code&gt;mmap()&lt;/code&gt; 映射之后的块设备，也就是说，事实上 Page Cache 负责了大部分的块设备文件的缓存工作。而 &lt;code&gt;Buffer Cache&lt;/code&gt; 用来在系统对块设备进行读写的时候，对块进行数据缓存的系统来使用，实际上负责所有对磁盘的 I/O 访问：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e5dcc4158c745179454a4add2794fbcb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;758&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e5dcc4158c745179454a4add2794fbcb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;758&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e5dcc4158c745179454a4add2794fbcb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e5dcc4158c745179454a4add2794fbcb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;LNT-gI6l&quot;&gt;因为 &lt;code&gt;Buffer Cache&lt;/code&gt; 是对粒度更细的设备块的缓存，而 &lt;code&gt;Page Cache&lt;/code&gt; 是基于虚拟内存的页单元缓存，因此还是会基于 &lt;code&gt;Buffer Cache&lt;/code&gt;，也就是说如果是缓存文件内容数据就会在内存里缓存两份相同的数据，这就会导致同一份文件保存了两份，冗余且低效。另外一个问题是，调用 &lt;code&gt;write&lt;/code&gt; 后，有效数据是在 &lt;code&gt;Buffer Cache&lt;/code&gt; 中，而非 &lt;code&gt;Page Cache&lt;/code&gt; 中。这就导致 &lt;code&gt;mmap&lt;/code&gt; 访问的文件数据可能存在不一致问题。为了规避这个问题，所有基于磁盘文件系统的 &lt;code&gt;write&lt;/code&gt;，都需要调用 &lt;code&gt;update_vm_cache()&lt;/code&gt; 函数，该操作会把调用 &lt;code&gt;write&lt;/code&gt; 之后的 &lt;code&gt;Buffer Cache&lt;/code&gt; 更新到 &lt;code&gt;Page Cache&lt;/code&gt; 去。由于有这些设计上的弊端，因此在 Linux 2.4 版本之后，kernel 就将两者进行了统一，&lt;code&gt;Buffer Cache&lt;/code&gt; 不再以独立的形式存在，而是以融合的方式存在于 &lt;code&gt;Page Cache&lt;/code&gt; 中：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;758&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;758&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-92f0fd4f60c9ce2b21ec6fd32c75d35d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ps6hNSBX&quot;&gt;融合之后就可以统一操作 &lt;code&gt;Page Cache&lt;/code&gt; 和 &lt;code&gt;Buffer Cache&lt;/code&gt;：处理文件 I/O 缓存交给 &lt;code&gt;Page Cache&lt;/code&gt;，而当底层 RAW device 刷新数据时以 &lt;code&gt;Buffer Cache&lt;/code&gt; 的块单位来实际处理。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;I/O 模式&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;ml7zVRCt&quot;&gt;在 Linux 或者其他 Unix-like 操作系统里，I/O 模式一般有三种：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;9UvH4pir&quot;&gt;程序控制 I/O&lt;/li&gt;&lt;li data-pid=&quot;hIx6QV82&quot;&gt;中断驱动 I/O&lt;/li&gt;&lt;li data-pid=&quot;lFPv-ZNp&quot;&gt;DMA I/O&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;GgGVElrM&quot;&gt;下面我分别详细地讲解一下这三种 I/O 模式。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;程序控制 I/O&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;fxMBC7sT&quot;&gt;这是最简单的一种 I/O 模式，也叫忙等待或者轮询：用户通过发起一个系统调用，陷入内核态，内核将系统调用翻译成一个对应设备驱动程序的过程调用，接着设备驱动程序会启动 I/O 不断循环去检查该设备，看看是否已经就绪，一般通过返回码来表示，I/O 结束之后，设备驱动程序会把数据送到指定的地方并返回，切回用户态。&lt;/p&gt;&lt;p data-pid=&quot;GXPilIar&quot;&gt;比如发起系统调用 &lt;code&gt;read()&lt;/code&gt;：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-42fdd6deb027842d849b5ee7e2b92bba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1826&quot; data-rawheight=&quot;960&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-42fdd6deb027842d849b5ee7e2b92bba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1826&quot; data-rawheight=&quot;960&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-42fdd6deb027842d849b5ee7e2b92bba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-42fdd6deb027842d849b5ee7e2b92bba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;中断驱动 I/O&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;1girAnQo&quot;&gt;第二种 I/O 模式是利用中断来实现的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-31c98b8d3f28acd6558aa06cec952709_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-31c98b8d3f28acd6558aa06cec952709_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-31c98b8d3f28acd6558aa06cec952709_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-31c98b8d3f28acd6558aa06cec952709_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;sMIhCy6z&quot;&gt;流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;C_RfH40T&quot;&gt;用户进程发起一个 &lt;code&gt;read()&lt;/code&gt; 系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设备驱动程序向设备寄存器写入一个通知信号，告知设备控制器 (我们这里是磁盘控制器)要读取数据；&lt;/li&gt;&lt;li data-pid=&quot;2_IHEzMd&quot;&gt;磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里；&lt;/li&gt;&lt;li data-pid=&quot;ghNzc6Sn&quot;&gt;完成拷贝之后磁盘控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而磁盘控制器会在后面持续发送中断信号直至中断控制器受理；&lt;/li&gt;&lt;li data-pid=&quot;KVJzX70L&quot;&gt;中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个磁盘设备的编号，表示这次中断需要关注的设备是磁盘；&lt;/li&gt;&lt;li data-pid=&quot;b9fkPdVS&quot;&gt;中断控制器向 CPU 置起一个磁盘中断信号；&lt;/li&gt;&lt;li data-pid=&quot;9mru6z4C&quot;&gt;CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行磁盘中断服务，把数据从磁盘控制器的缓冲区拷贝到主存里的内核缓冲区；&lt;/li&gt;&lt;li data-pid=&quot;kRNrqQX_&quot;&gt;最后 CPU 再把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，&lt;code&gt;read()&lt;/code&gt; 返回，切换回用户态。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;DMA I/O&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;jHD1MpVE&quot;&gt;并发系统的性能高低究其根本，是取决于如何对 CPU 资源的高效调度和使用，而回头看前面的中断驱动 I/O 模式的流程，可以发现第 6、7 步的数据拷贝工作都是由 CPU 亲自完成的，也就是在这两次数据拷贝阶段中 CPU 是完全被占用而不能处理其他工作的，那么这里明显是有优化空间的；第 7 步的数据拷贝是从内核缓冲区到用户缓冲区，都是在主存里，所以这一步只能由 CPU 亲自完成，但是第 6 步的数据拷贝，是从磁盘控制器的缓冲区到主存，是两个设备之间的数据传输，这一步并非一定要 CPU 来完成，可以借助 DMA 来完成，减轻 CPU 的负担。&lt;/p&gt;&lt;p data-pid=&quot;bLKi790k&quot;&gt;DMA 全称是 Direct Memory Access，也即直接存储器存取，是一种用来提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。整个过程无须 CPU 参与，数据直接通过 DMA 控制器进行快速地移动拷贝，节省 CPU 的资源去做其他工作。&lt;/p&gt;&lt;p data-pid=&quot;s1RKjYT8&quot;&gt;目前，大部分的计算机都配备了 DMA 控制器，而 DMA 技术也支持大部分的外设和存储器。借助于 DMA 机制，计算机的 I/O 过程就能更加高效：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-99408f5d660858c994024b55aaa26514_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1465&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-99408f5d660858c994024b55aaa26514_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1465&quot; data-rawheight=&quot;643&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-99408f5d660858c994024b55aaa26514_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-99408f5d660858c994024b55aaa26514_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;SFt1-q3_&quot;&gt;DMA 控制器内部包含若干个可以被 CPU 读写的寄存器：一个主存地址寄存器 MAR（存放要交换数据的主存地址）、一个外设地址寄存器 ADR（存放 I/O 设备的设备码，或者是设备信息存储区的寻址信息）、一个字节数寄存器 WC（对传送数据的总字数进行统计）、和一个或多个控制寄存器。&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;EC3s5g6Y&quot;&gt;用户进程发起一个 &lt;code&gt;read()&lt;/code&gt; 系统调用读取磁盘文件，陷入内核态并由其所在的 CPU 通过设置 DMA 控制器的寄存器对它进行编程：把内核缓冲区和磁盘文件的地址分别写入 MAR 和 ADR 寄存器，然后把期望读取的字节数写入 WC 寄存器，启动 DMA 控制器；&lt;/li&gt;&lt;li data-pid=&quot;fqvUR3KP&quot;&gt;DMA 控制器根据 ADR 寄存器里的信息知道这次 I/O 需要读取的外设是磁盘的某个地址，便向磁盘控制器发出一个命令，通知它从磁盘读取数据到其内部的缓冲区里；&lt;/li&gt;&lt;li data-pid=&quot;2vq6fKx4&quot;&gt;磁盘控制器启动磁盘读取的过程，把数据从磁盘拷贝到磁盘控制器缓冲区里，并对缓冲区内数据的校验和进行检验，如果数据是有效的，那么 DMA 就可以开始了；&lt;/li&gt;&lt;li data-pid=&quot;V3XyUEqL&quot;&gt;DMA 控制器通过总线向磁盘控制器发出一个读请求信号从而发起 DMA 传输，这个信号和前面的中断驱动 I/O 小节里 CPU 发给磁盘控制器的读请求是一样的，它并不知道或者并不关心这个读请求是来自 CPU 还是 DMA 控制器；&lt;/li&gt;&lt;li data-pid=&quot;tfI-TEP5&quot;&gt;紧接着 DMA 控制器将引导磁盘控制器将数据传输到 MAR 寄存器里的地址，也就是内核缓冲区；&lt;/li&gt;&lt;li data-pid=&quot;TiY0Cuke&quot;&gt;数据传输完成之后，返回一个 ack 给 DMA 控制器，WC 寄存器里的值会减去相应的数据长度，如果 WC 还不为 0，则重复第 4 步到第 6 步，一直到 WC 里的字节数等于 0；&lt;/li&gt;&lt;li data-pid=&quot;DCVtnQuC&quot;&gt;收到 ack 信号的 DMA 控制器会通过总线发送一个中断信号到中断控制器，如果此时中断控制器手头还有正在处理的中断或者有一个和该中断信号同时到达的更高优先级的中断，则这个中断信号将被忽略，而 DMA 控制器会在后面持续发送中断信号直至中断控制器受理；&lt;/li&gt;&lt;li data-pid=&quot;KjqPjNTI&quot;&gt;中断控制器收到磁盘控制器的中断信号之后会通过地址总线存入一个主存设备的编号，表示这次中断需要关注的设备是主存；&lt;/li&gt;&lt;li data-pid=&quot;P2bFFE-5&quot;&gt;中断控制器向 CPU 置起一个 DMA 中断的信号；&lt;/li&gt;&lt;li data-pid=&quot;UjonpY5H&quot;&gt;CPU 收到中断信号之后停止当前的工作，把当前的 PC/PSW 等寄存器压入堆栈保存现场，然后从地址总线取出设备编号，通过编号找到中断向量所包含的中断服务的入口地址，压入 PC 寄存器，开始运行 DMA 中断服务，把数据从内核缓冲区拷贝到用户缓冲区，完成读取操作，&lt;code&gt;read()&lt;/code&gt; 返回，切换回用户态。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;传统 I/O 读写模式&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;hBhgiEPw&quot;&gt;Linux 中传统的 I/O 读写是通过 &lt;code&gt;read()/write()&lt;/code&gt; 系统调用完成的，&lt;code&gt;read()&lt;/code&gt; 把数据从存储器 (磁盘、网卡等) 读取到用户缓冲区，&lt;code&gt;write()&lt;/code&gt; 则是把数据从用户缓冲区写出到存储器：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;unistd.h&amp;gt;

ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;upQuHB9j&quot;&gt;一次完整的读磁盘文件然后写出到网卡的底层传输过程如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-cadabc5672c37a84a83ee837de545be5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-cadabc5672c37a84a83ee837de545be5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-cadabc5672c37a84a83ee837de545be5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-cadabc5672c37a84a83ee837de545be5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;fXsL3O4K&quot;&gt;可以清楚看到这里一共触发了 4 次用户态和内核态的上下文切换，分别是 &lt;code&gt;read()/write()&lt;/code&gt; 调用和返回时的切换，2 次 DMA 拷贝，2 次 CPU 拷贝，加起来一共 4 次拷贝操作。&lt;/p&gt;&lt;p data-pid=&quot;xZD8mTwf&quot;&gt;通过引入 DMA，我们已经把 Linux 的 I/O 过程中的 CPU 拷贝次数从 4 次减少到了 2 次，但是 CPU 拷贝依然是代价很大的操作，对系统性能的影响还是很大，特别是那些频繁 I/O 的场景，更是会因为 CPU 拷贝而损失掉很多性能，我们需要进一步优化，降低、甚至是完全避免 CPU 拷贝。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;零拷贝 (Zero-copy)&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;Zero-copy 是什么？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;_7h6ea_Z&quot;&gt;Wikipedia 的解释如下：&lt;/p&gt;&lt;blockquote data-pid=&quot;72FSqdSu&quot;&gt; &quot;&lt;b&gt;Zero-copy&lt;/b&gt;&quot; describes computer operations in which the &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Central_processing_unit&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CPU&lt;/a&gt;&lt;/b&gt; does not perform the task of copying data from one &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/RAM&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;memory&lt;/a&gt;&lt;/b&gt; area to another. This is frequently used to save CPU cycles and memory bandwidth when transmitting a file over a network.&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;aV6M5KC1&quot;&gt;零拷贝技术是指计算机执行操作时，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E4%25B8%25AD%25E5%25A4%25AE%25E5%25A4%2584%25E7%2590%2586%25E5%2599%25A8&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;CPU&lt;/a&gt;&lt;/b&gt;不需要先将数据从某处&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%259A%258F%25E6%259C%25BA%25E5%25AD%2598%25E5%258F%2596%25E5%25AD%2598%25E5%2582%25A8%25E5%2599%25A8&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;内存&lt;/a&gt;&lt;/b&gt;复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省 CPU 周期和&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2586%2585%25E5%25AD%2598%25E5%25B8%25A6%25E5%25AE%25BD&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;内存带宽&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Zero-copy 能做什么？&lt;/b&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li data-pid=&quot;UTYgRdJa&quot;&gt;减少甚至完全避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作，从而减少用户态 -- 内核态上下文切换带来的系统开销。&lt;/li&gt;&lt;li data-pid=&quot;t4IbaFhd&quot;&gt;减少甚至完全避免操作系统内核缓冲区之间进行数据拷贝操作。&lt;/li&gt;&lt;li data-pid=&quot;wSoTbRGO&quot;&gt;帮助用户进程绕开操作系统内核空间直接访问硬件存储接口操作数据。&lt;/li&gt;&lt;li data-pid=&quot;v3rW2XmI&quot;&gt;利用 DMA 而非 CPU 来完成硬件接口和内核缓冲区之间的数据拷贝，从而解放 CPU，使之能去执行其他的任务，提升系统性能。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Zero-copy 的实现方式有哪些？&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;mbwdFLle&quot;&gt;从 zero-copy 这个概念被提出以来，相关的实现技术便犹如雨后春笋，层出不穷。但是截至目前为止，并没有任何一种 zero-copy 技术能满足所有的场景需求，还是计算机领域那句无比经典的名言：&quot;There is no silver bullet&quot;!&lt;/p&gt;&lt;p data-pid=&quot;xQ2lT09g&quot;&gt;而在 Linux 平台上，同样也有很多的 zero-copy 技术，新旧各不同，可能存在于不同的内核版本里，很多技术可能有了很大的改进或者被更新的实现方式所替代，这些不同的实现技术按照其核心思想可以归纳成大致的以下三类：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;Q03cD2Hu&quot;&gt;&lt;b&gt;减少甚至避免用户空间和内核空间之间的数据拷贝&lt;/b&gt;：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 &lt;code&gt;Page Cache&lt;/code&gt; 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是通过增加新的系统调用来完成的，比如 Linux 中的 mmap()，sendfile() 以及 splice() 等。&lt;/li&gt;&lt;li data-pid=&quot;y4SmcrP7&quot;&gt;&lt;b&gt;绕过内核的直接 I/O&lt;/b&gt;：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。&lt;/li&gt;&lt;li data-pid=&quot;HJlqGkv0&quot;&gt;&lt;b&gt;内核缓冲区和用户缓冲区之间的传输优化&lt;/b&gt;：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bec2c4d064d8c3b019b38949006ff0b8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2040&quot; data-rawheight=&quot;1264&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-bec2c4d064d8c3b019b38949006ff0b8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2040&quot; data-rawheight=&quot;1264&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-bec2c4d064d8c3b019b38949006ff0b8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bec2c4d064d8c3b019b38949006ff0b8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;减少甚至避免用户空间和内核空间之间的数据拷贝&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;mmap()&lt;/b&gt;&lt;/h3&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;sys/mman.h&amp;gt;

void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;yPRSOEF6&quot;&gt;一种简单的实现方案是在一次读写过程中用 Linux 的另一个系统调用 &lt;code&gt;mmap()&lt;/code&gt; 替换原先的 &lt;code&gt;read()&lt;/code&gt;，&lt;code&gt;mmap()&lt;/code&gt; 也即是内存映射（memory map）：把用户进程空间的一段内存缓冲区（user buffer）映射到文件所在的内核缓冲区（kernel buffer）上。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-80018696eff24ce1e4b9e9b5e127416b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-80018696eff24ce1e4b9e9b5e127416b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-80018696eff24ce1e4b9e9b5e127416b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-80018696eff24ce1e4b9e9b5e127416b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;kxcUbZqW&quot;&gt;利用 &lt;code&gt;mmap()&lt;/code&gt; 替换 &lt;code&gt;read()&lt;/code&gt;，配合 &lt;code&gt;write()&lt;/code&gt; 调用的整个流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;E5TuGw4X&quot;&gt;用户进程调用 &lt;code&gt;mmap()&lt;/code&gt;，从用户态陷入内核态，将内核缓冲区映射到用户缓存区；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;r7tXDMtF&quot;&gt;DMA 控制器将数据从硬盘拷贝到内核缓冲区；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;oHRafR3Z&quot;&gt;&lt;code&gt;mmap()&lt;/code&gt; 返回，上下文从内核态切换回用户态；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;g94shhQL&quot;&gt;用户进程调用 &lt;code&gt;write()&lt;/code&gt;，尝试把文件数据写到内核里的套接字缓冲区，再次陷入内核态；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;9dAgBRR2&quot;&gt;CPU 将内核缓冲区中的数据拷贝到的套接字缓冲区；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;P07xep4b&quot;&gt;DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；&lt;br/&gt; &lt;/li&gt;&lt;li data-pid=&quot;t1OLU-zb&quot;&gt;&lt;code&gt;write()&lt;/code&gt; 返回，上下文从内核态切换回用户态。&lt;br/&gt; &lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;udR8bDZX&quot;&gt;通过这种方式，有两个优点：一是节省内存空间，因为用户进程上的这一段内存是虚拟的，并不真正占据物理内存，只是映射到文件所在的内核缓冲区上，因此可以节省一半的内存占用；二是省去了一次 CPU 拷贝，对比传统的 Linux I/O 读写，数据不需要再经过用户进程进行转发了，而是直接在内核里就完成了拷贝。所以使用 &lt;code&gt;mmap()&lt;/code&gt; 之后的拷贝次数是 2 次 DMA 拷贝，1 次 CPU 拷贝，加起来一共 3 次拷贝操作，比传统的 I/O 方式节省了一次 CPU 拷贝以及一半的内存，不过因为 &lt;code&gt;mmap()&lt;/code&gt; 也是一个系统调用，因此用户态和内核态的切换还是 4 次。&lt;/p&gt;&lt;p data-pid=&quot;yAF9Mp5i&quot;&gt;&lt;code&gt;mmap()&lt;/code&gt; 因为既节省 CPU 拷贝次数又节省内存，所以比较适合大文件传输的场景。虽然 &lt;code&gt;mmap()&lt;/code&gt; 完全是符合 POSIX 标准的，但是它也不是完美的，因为它并不总是能达到理想的数据传输性能。首先是因为数据数据传输过程中依然需要一次 CPU 拷贝，其次是内存映射技术是一个开销很大的虚拟存储操作：这种操作需要修改页表以及用内核缓冲区里的文件数据汰换掉当前 TLB 里的缓存以维持虚拟内存映射的一致性。但是，因为内存映射通常针对的是相对较大的数据区域，所以对于相同大小的数据来说，内存映射所带来的开销远远低于 CPU 拷贝所带来的开销。此外，使用 &lt;code&gt;mmap()&lt;/code&gt; 还可能会遇到一些需要值得关注的特殊情况，例如，在 &lt;code&gt;mmap()&lt;/code&gt; --&amp;gt; &lt;code&gt;write()&lt;/code&gt; 这两个系统调用的整个传输过程中，如果有其他的进程突然截断了这个文件，那么这时用户进程就会因为访问非法地址而被一个从总线传来的 SIGBUS 中断信号杀死并且产生一个 core dump。有两种解决办法：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;AlVSxkTG&quot;&gt;设置一个信号处理器，专门用来处理 SIGBUS 信号，这个处理器直接返回， &lt;code&gt;write()&lt;/code&gt; 就可以正常返回已写入的字节数而不会被 SIGBUS 中断，errno 错误码也会被设置成 success。然而这实际上是一个掩耳盗铃的解决方案，因为 BIGBUS 信号的带来的信息是系统发生了一些很严重的错误，而我们却选择忽略掉它，一般不建议采用这种方式。&lt;/li&gt;&lt;li data-pid=&quot;Kl15Q1EJ&quot;&gt;通过内核的文件租借锁（这是 Linux 的叫法，Windows 上称之为机会锁）来解决这个问题，这种方法相对来说更好一些。我们可以通过内核对文件描述符上读/写的租借锁，当另外一个进程尝试对当前用户进程正在进行传输的文件进行截断的时候，内核会发送给用户一个实时信号：RT_SIGNAL_LEASE 信号，这个信号会告诉用户内核正在破坏你加在那个文件上的读/写租借锁，这时 &lt;code&gt;write()&lt;/code&gt; 系统调用会被中断，并且当前用户进程会被 SIGBUS 信号杀死，返回值则是中断前写的字节数，errno 同样会被设置为 success。文件租借锁需要在对文件进行内存映射之前设置，最后在用户进程结束之前释放掉。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;sendfile()&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;2crP6Thc&quot;&gt;在 Linux 内核 2.1 版本中，引入了一个新的系统调用 &lt;code&gt;sendfile()&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;#include &amp;lt;sys/sendfile.h&amp;gt;

ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;t9UJU-ix&quot;&gt;从功能上来看，这个系统调用将 &lt;code&gt;mmap()&lt;/code&gt; + &lt;code&gt;write()&lt;/code&gt; 这两个系统调用合二为一，实现了一样效果的同时还简化了用户接口，其他的一些 Unix-like 的系统像 BSD、Solaris 和 AIX 等也有类似的实现，甚至 Windows 上也有一个功能类似的 API 函数 &lt;code&gt;TransmitFile&lt;/code&gt;。&lt;/p&gt;&lt;p data-pid=&quot;adma7w2T&quot;&gt;out_fd 和 in_fd 分别代表了写入和读出的文件描述符，in_fd 必须是一个指向文件的文件描述符，且要能支持类 &lt;code&gt;mmap()&lt;/code&gt; 内存映射，不能是 Socket 类型，而 out_fd 在 Linux 内核 2.6.33 版本之前只能是一个指向 Socket 的文件描述符，从 2.6.33 之后则可以是任意类型的文件描述符。off_t 是一个代表了 in_fd 偏移量的指针，指示 &lt;code&gt;sendfile()&lt;/code&gt; 该从 in_fd 的哪个位置开始读取，函数返回后，这个指针会被更新成 &lt;code&gt;sendfile()&lt;/code&gt; 最后读取的字节位置处，表明此次调用共读取了多少文件数据，最后的 count 参数则是此次调用需要传输的字节总数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-17ce86192cb8e4d88282aaf9a7c844a3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-17ce86192cb8e4d88282aaf9a7c844a3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-17ce86192cb8e4d88282aaf9a7c844a3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-17ce86192cb8e4d88282aaf9a7c844a3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;l7-7MaHB&quot;&gt;使用 &lt;code&gt;sendfile()&lt;/code&gt; 完成一次数据读写的流程如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;fVeN3KpC&quot;&gt;用户进程调用 &lt;code&gt;sendfile()&lt;/code&gt; 从用户态陷入内核态；&lt;/li&gt;&lt;li data-pid=&quot;8H5oAkEB&quot;&gt;DMA 控制器将数据从硬盘拷贝到内核缓冲区；&lt;/li&gt;&lt;li data-pid=&quot;txNL-ViH&quot;&gt;CPU 将内核缓冲区中的数据拷贝到套接字缓冲区；&lt;/li&gt;&lt;li data-pid=&quot;ayGq9d0T&quot;&gt;DMA 控制器将数据从套接字缓冲区拷贝到网卡完成数据传输；&lt;/li&gt;&lt;li data-pid=&quot;y7a2FFam&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt; 返回，上下文从内核态切换回用户态。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;wPSuZ6Vo&quot;&gt;基于 &lt;code&gt;sendfile()&lt;/code&gt;， 整个数据传输过程中共发生 2 次 DMA 拷贝和 1 次 CPU 拷贝，这个和 &lt;code&gt;mmap()&lt;/code&gt; + &lt;code&gt;write()&lt;/code&gt; 相同，但是因为 &lt;code&gt;sendfile()&lt;/code&gt; 只是一次系统调用，因此比前者少了一次用户态和内核态的上下文切换开销。读到这里，聪明的读者应该会开始提问了：&quot;&lt;code&gt;sendfile()&lt;/code&gt; 会不会遇到和 &lt;code&gt;mmap()&lt;/code&gt; + &lt;code&gt;write()&lt;/code&gt; 相似的文件截断问题呢？&quot;，很不幸，答案是肯定的。&lt;code&gt;sendfile()&lt;/code&gt; 一样会有文件截断的问题，但欣慰的是，&lt;code&gt;sendfile()&lt;/code&gt; 不仅比 &lt;code&gt;mmap()&lt;/code&gt; + &lt;code&gt;write()&lt;/code&gt; 在接口使用上更加简洁，而且处理文件截断时也更加优雅：如果 &lt;code&gt;sendfile()&lt;/code&gt; 过程中遭遇文件截断，则 &lt;code&gt;sendfile()&lt;/code&gt; 系统调用会被中断杀死之前返回给用户进程其中断前所传输的字节数，errno 会被设置为 success，无需用户提前设置信号处理器，当然你要设置一个进行个性化处理也可以，也不需要像之前那样提前给文件描述符设置一个租借锁，因为最终结果还是一样的。&lt;/p&gt;&lt;p data-pid=&quot;AF-3iBgC&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt; 相较于 &lt;code&gt;mmap()&lt;/code&gt; 的另一个优势在于数据在传输过程中始终没有越过用户态和内核态的边界，因此极大地减少了存储管理的开销。即便如此，&lt;code&gt;sendfile()&lt;/code&gt; 依然是一个适用性很窄的技术，最适合的场景基本也就是一个静态文件服务器了。而且根据 Linus 在 2001 年和其他内核维护者的邮件列表内容，其实当初之所以决定在 Linux 上实现 &lt;code&gt;sendfile()&lt;/code&gt; 仅仅是因为在其他操作系统平台上已经率先实现了，而且有大名鼎鼎的 Apache Web 服务器已经在使用了，为了兼容 Apache Web 服务器才决定在 Linux 上也实现这个技术，而且 &lt;code&gt;sendfile()&lt;/code&gt; 实现上的简洁性也和 Linux 内核的其他部分集成得很好，所以 Linus 也就同意了这个提案。&lt;/p&gt;&lt;p data-pid=&quot;qHJlGQv8&quot;&gt;然而 &lt;code&gt;sendfile()&lt;/code&gt; 本身是有很大问题的，从不同的角度来看的话主要是：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;m9O0quhe&quot;&gt;首先一个是这个接口并没有进行标准化，导致 &lt;code&gt;sendfile()&lt;/code&gt; 在 Linux 上的接口实现和其他类 Unix 系统的实现并不相同；&lt;/li&gt;&lt;li data-pid=&quot;rPidn8NT&quot;&gt;其次由于网络传输的异步性，很难在接收端实现和 &lt;code&gt;sendfile()&lt;/code&gt; 对接的技术，因此接收端一直没有实现对应的这种技术；&lt;/li&gt;&lt;li data-pid=&quot;j-ugKC5o&quot;&gt;最后从性能方面考量，因为 &lt;code&gt;sendfile()&lt;/code&gt; 在把磁盘文件从内核缓冲区（page cache）传输到到套接字缓冲区的过程中依然需要 CPU 参与，这就很难避免 CPU 的高速缓存被传输的数据所污染。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;IajX8rFJ&quot;&gt;此外，需要说明下，&lt;code&gt;sendfile()&lt;/code&gt; 的最初设计并不是用来处理大文件的，因此如果需要处理很大的文件的话，可以使用另一个系统调用 &lt;code&gt;sendfile64()&lt;/code&gt;，它支持对更大的文件内容进行寻址和偏移。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;sendﬁle() with DMA Scatter/Gather Copy&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;jCUpkxM7&quot;&gt;上一小节介绍的 &lt;code&gt;sendfile()&lt;/code&gt; 技术已经把一次数据读写过程中的 CPU 拷贝的降低至只有 1 次了，但是人永远是贪心和不知足的，现在如果想要把这仅有的一次 CPU 拷贝也去除掉，有没有办法呢？&lt;/p&gt;&lt;p data-pid=&quot;einyTiM3&quot;&gt;当然有！通过引入一个新硬件上的支持，我们可以把这个仅剩的一次 CPU 拷贝也给抹掉：Linux 在内核 2.4 版本里引入了 DMA 的 scatter/gather -- 分散/收集功能，并修改了 &lt;code&gt;sendfile()&lt;/code&gt; 的代码使之和 DMA 适配。scatter 使得 DMA 拷贝可以不再需要把数据存储在一片连续的内存空间上，而是允许离散存储，gather 则能够让 DMA 控制器根据少量的元信息：一个包含了内存地址和数据大小的缓冲区描述符，收集存储在各处的数据，最终还原成一个完整的网络包，直接拷贝到网卡而非套接字缓冲区，避免了最后一次的 CPU 拷贝：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0d99113bd0d67e41d288b1f1034d4704_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-0d99113bd0d67e41d288b1f1034d4704_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-0d99113bd0d67e41d288b1f1034d4704_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0d99113bd0d67e41d288b1f1034d4704_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;wj0MWd1M&quot;&gt;&lt;code&gt;sendfile() + DMA gather&lt;/code&gt; 的数据传输过程如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;_ohcSBFA&quot;&gt;用户进程调用 &lt;code&gt;sendfile()&lt;/code&gt;，从用户态陷入内核态；&lt;/li&gt;&lt;li data-pid=&quot;uCghbOyv&quot;&gt;DMA 控制器使用 scatter 功能把数据从硬盘拷贝到内核缓冲区进行离散存储；&lt;/li&gt;&lt;li data-pid=&quot;yD4TtJ2F&quot;&gt;CPU 把包含内存地址和数据长度的缓冲区描述符拷贝到套接字缓冲区，DMA 控制器能够根据这些信息生成网络包数据分组的报头和报尾&lt;/li&gt;&lt;li data-pid=&quot;1BqWfw5f&quot;&gt;DMA 控制器根据缓冲区描述符里的内存地址和数据大小，使用 scatter-gather 功能开始从内核缓冲区收集离散的数据并组包，最后直接把网络包数据拷贝到网卡完成数据传输；&lt;/li&gt;&lt;li data-pid=&quot;aQpFCeZL&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt; 返回，上下文从内核态切换回用户态。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;_0TviDaj&quot;&gt;基于这种方案，我们就可以把这仅剩的唯一一次 CPU 拷贝也给去除了（严格来说还是会有一次，但是因为这次 CPU 拷贝的只是那些微乎其微的元信息，开销几乎可以忽略不计），理论上，数据传输过程就再也没有 CPU 的参与了，也因此 CPU 的高速缓存再不会被污染了，也不再需要 CPU 来计算数据校验和了，CPU 可以去执行其他的业务计算任务，同时和 DMA 的 I/O 任务并行，此举能极大地提升系统性能。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;splice()&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LFZ6BKy-&quot;&gt;&lt;code&gt;sendfile()&lt;/code&gt; + DMA Scatter/Gather 的零拷贝方案虽然高效，但是也有两个缺点：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;EIIUxAa3&quot;&gt;这种方案需要引入新的硬件支持；&lt;/li&gt;&lt;li data-pid=&quot;FLUb-CLW&quot;&gt;虽然 &lt;code&gt;sendfile()&lt;/code&gt; 的输出文件描述符在 Linux kernel 2.6.33 版本之后已经可以支持任意类型的文件描述符，但是输入文件描述符依然只能指向文件。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;37NbBQgi&quot;&gt;这两个缺点限制了 &lt;code&gt;sendfile()&lt;/code&gt; + DMA Scatter/Gather 方案的适用场景。为此，Linux 在 2.6.17 版本引入了一个新的系统调用 &lt;code&gt;splice()&lt;/code&gt;，它在功能上和 &lt;code&gt;sendfile()&lt;/code&gt; 非常相似，但是能够实现在任意类型的两个文件描述符时之间传输数据；而在底层实现上，&lt;code&gt;splice()&lt;/code&gt;又比 &lt;code&gt;sendfile()&lt;/code&gt; 少了一次 CPU 拷贝，也就是等同于 &lt;code&gt;sendfile()&lt;/code&gt; + DMA Scatter/Gather，完全去除了数据传输过程中的 CPU 拷贝。&lt;/p&gt;&lt;p data-pid=&quot;HyfeFA7f&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 系统调用函数定义如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;cp&quot;/&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pipe2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipefd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;q-Xv6gEO&quot;&gt;fd_in 和 fd_out 也是分别代表了输入端和输出端的文件描述符，这两个文件描述符必须有一个是指向管道设备的，这也是一个不太友好的限制，虽然 Linux 内核开发的官方从这个系统调用推出之时就承诺未来可能会重构去掉这个限制，然而他们许下这个承诺之后就如同石沉大海，如今 14 年过去了，依旧杳无音讯...&lt;/p&gt;&lt;p data-pid=&quot;d-SUQwsd&quot;&gt;off_in 和 off_out 则分别是 fd_in 和 fd_out 的偏移量指针，指示内核从哪里读取和写入数据，len 则指示了此次调用希望传输的字节数，最后的 flags 是系统调用的标记选项位掩码，用来设置系统调用的行为属性的，由以下 0 个或者多个值通过『或』操作组合而成：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;ngxIfAqa&quot;&gt;SPLICE_F_MOVE：指示 &lt;code&gt;splice()&lt;/code&gt; 尝试仅仅是移动内存页面而不是复制，设置了这个值不代表就一定不会复制内存页面，复制还是移动取决于内核能否从管道中移动内存页面，或者管道中的内存页面是否是完整的；这个标记的初始实现有很多 bug，所以从 Linux 2.6.21 版本开始就已经无效了，但还是保留了下来，因为在未来的版本里可能会重新被实现。&lt;/li&gt;&lt;li data-pid=&quot;5IEe5X_b&quot;&gt;SPLICE_F_NONBLOCK：指示 &lt;code&gt;splice()&lt;/code&gt; 不要阻塞 I/O，也就是使得 &lt;code&gt;splice()&lt;/code&gt; 调用成为一个非阻塞调用，可以用来实现异步数据传输，不过需要注意的是，数据传输的两个文件描述符也最好是预先通过 O_NONBLOCK 标记成非阻塞 I/O，不然 &lt;code&gt;splice()&lt;/code&gt; 调用还是有可能被阻塞。&lt;/li&gt;&lt;li data-pid=&quot;9zsLztsZ&quot;&gt;SPLICE_F_MORE：通知内核下一个 &lt;code&gt;splice()&lt;/code&gt; 系统调用将会有更多的数据传输过来，这个标记对于输出端是 socket 的场景非常有用。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Pb7yZwSb&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 是基于 Linux 的管道缓冲区 (pipe buffer) 机制实现的，所以 &lt;code&gt;splice()&lt;/code&gt; 的两个入参文件描述符才要求必须有一个是管道设备，一个典型的 &lt;code&gt;splice()&lt;/code&gt; 用法是：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;file_fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4096&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPLICE_F_MOVE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;socket_fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPLICE_F_MOVE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPLICE_F_MORE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;LgC4rErD&quot;&gt;数据传输过程图：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e179bc30903178cec7e9324d628f33a5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e179bc30903178cec7e9324d628f33a5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e179bc30903178cec7e9324d628f33a5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e179bc30903178cec7e9324d628f33a5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;FJlHJ-NM&quot;&gt;使用 &lt;code&gt;splice()&lt;/code&gt; 完成一次磁盘文件到网卡的读写过程如下：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;wtRNF5B9&quot;&gt;用户进程调用 &lt;code&gt;pipe()&lt;/code&gt;，从用户态陷入内核态，创建匿名单向管道，&lt;code&gt;pipe()&lt;/code&gt; 返回，上下文从内核态切换回用户态；&lt;/li&gt;&lt;li data-pid=&quot;x7EWiopr&quot;&gt;用户进程调用 &lt;code&gt;splice()&lt;/code&gt;，从用户态陷入内核态；&lt;/li&gt;&lt;li data-pid=&quot;mjzfH_5t&quot;&gt;DMA 控制器将数据从硬盘拷贝到内核缓冲区，从管道的写入端&quot;拷贝&quot;进管道，&lt;code&gt;splice()&lt;/code&gt; 返回，上下文从内核态回到用户态；&lt;/li&gt;&lt;li data-pid=&quot;Lt-ylXDE&quot;&gt;用户进程再次调用 &lt;code&gt;splice()&lt;/code&gt;，从用户态陷入内核态；&lt;/li&gt;&lt;li data-pid=&quot;W5IjY99R&quot;&gt;内核把数据从管道的读取端&quot;拷贝&quot;到套接字缓冲区，DMA 控制器将数据从套接字缓冲区拷贝到网卡；&lt;/li&gt;&lt;li data-pid=&quot;qlsoxWG_&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 返回，上下文从内核态切换回用户态。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;tqnkWOgv&quot;&gt;相信看完上面的读写流程之后，读者肯定会非常困惑：说好的 &lt;code&gt;splice()&lt;/code&gt; 是 &lt;code&gt;sendfile()&lt;/code&gt; 的改进版呢？&lt;code&gt;sendfile()&lt;/code&gt; 好歹只需要一次系统调用，&lt;code&gt;splice()&lt;/code&gt; 居然需要三次，这也就罢了，居然中间还搞出来一个管道，而且还要在内核空间拷贝两次，这算个毛的改进啊？&lt;/p&gt;&lt;p data-pid=&quot;zryqPggp&quot;&gt;我最开始了解 &lt;code&gt;splice()&lt;/code&gt; 的时候，也是这个反应，但是深入学习它之后，才渐渐知晓个中奥妙，且听我细细道来：&lt;/p&gt;&lt;p data-pid=&quot;WEbWiZ2W&quot;&gt;先来了解一下 pipe buffer 管道，管道是 Linux 上用来供进程之间通信的信道，管道有两个端：写入端和读出端，从进程的视角来看，管道表现为一个 FIFO 字节流环形队列：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;691&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;691&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9f9f00d7645cf1aebe3843c2dcf44bc3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;JSw4yZ2m&quot;&gt;管道本质上是一个内存中的文件，也就是本质上还是基于 Linux 的 VFS，用户进程可以通过 &lt;code&gt;pipe()&lt;/code&gt; 系统调用创建一个匿名管道，创建完成之后会有两个 VFS 的 file 结构体的 inode 分别指向其写入端和读出端，并返回对应的两个文件描述符，用户进程通过这两个文件描述符读写管道；管道的容量单位是一个虚拟内存的页，也就是 4KB，总大小一般是 16 个页，基于其环形结构，管道的页可以循环使用，提高内存利用率。 Linux 中以 pipe_buffer 结构体封装管道页，file 结构体里的 inode 字段里会保存一个 pipe_inode_info 结构体指代管道，其中会保存很多读写管道时所需的元信息，环形队列的头部指针页，读写时的同步机制如互斥锁、等待队列等：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_buffer&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 内存页结构
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 偏移量，长度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_buf_operations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;wait_queue_head_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nrbufs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;curbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waiting_writers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp_page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fasync_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fasync_readers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fasync_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fasync_writers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bufs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;B5XVgJ3O&quot;&gt;pipe_buffer 中保存了数据在内存中的页、偏移量和长度，以这三个值来定位数据，注意这里的页不是虚拟内存的页，而用的是物理内存的页框，因为管道时跨进程的信道，因此不能使用虚拟内存来表示，只能使用物理内存的页框定位数据；管道的正常读写操作是通过 pipe_write()/pipe_read() 来完成的，通过把数据读取/写入环形队列的 pipe_buffer 来完成数据传输。&lt;/p&gt;&lt;p data-pid=&quot;SHCGRqm7&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 是基于 pipe buffer 实现的，但是它在通过管道传输数据的时候却是零拷贝，因为它在写入读出时并没有使用 pipe_write()/pipe_read() 真正地在管道缓冲区写入读出数据，而是通过把数据在内存缓冲区中的物理内存页框指针、偏移量和长度赋值给前文提及的 pipe_buffer 中对应的三个字段来完成数据的&quot;拷贝&quot;，也就是其实只拷贝了数据的内存地址等元信息。&lt;/p&gt;&lt;p data-pid=&quot;o9frJ8YC&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 在 Linux 内核源码中的内部实现是 &lt;code&gt;do_splice()&lt;/code&gt; 函数，而写入读出管道则分别是通过 &lt;code&gt;do_splice_to()&lt;/code&gt; 和 &lt;code&gt;do_splice_from()&lt;/code&gt;，这里我们重点来解析下写入管道的源码，也就是 &lt;code&gt;do_splice_to()&lt;/code&gt;，我现在手头的 Linux 内核版本是 v4.8.17，我们就基于这个版本来分析，至于读出的源码函数 &lt;code&gt;do_splice_from()&lt;/code&gt;，原理是相通的，大家举一反三即可。&lt;/p&gt;&lt;p data-pid=&quot;VrIJkd4z&quot;&gt;&lt;code&gt;splice()&lt;/code&gt; 写入数据到管道的调用链式：&lt;code&gt;do_splice()&lt;/code&gt; --&amp;gt; &lt;code&gt;do_splice_to()&lt;/code&gt; --&amp;gt; &lt;code&gt;splice_read()&lt;/code&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_splice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;// 判断是写出 fd 是一个管道设备，则进入数据写入的逻辑
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_out&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ESPIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FMODE_PREAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy_from_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 调用 do_splice_to 把文件内容写入管道
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;do_splice_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copy_to_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;off_in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EFAULT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EINVAL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;Dkt2ibGl&quot;&gt;进入 &lt;code&gt;do_splice_to()&lt;/code&gt; 之后，再调用 &lt;code&gt;splice_read()&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_splice_to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ppos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loff_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_mode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FMODE_READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EBADF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rw_verify_area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;READ&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_RW_COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_RW_COUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;// 判断文件的文件的 file 结构体的 f_op 中有没有可供使用的、支持 splice 的 splice_read 函数指针
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt; &lt;span class=&quot;c1&quot;&gt;// 因为是 splice() 调用，因此内核会提前给这个函数指针指派一个可用的函数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f_op&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;default_file_splice_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splice_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ppos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;YZIhcetO&quot;&gt;&lt;code&gt;in-&amp;gt;f_op-&amp;gt;splice_read&lt;/code&gt; 这个函数指针根据文件描述符的类型不同有不同的实现，比如这里的 in 是一个文件，因此是 &lt;code&gt;generic_file_splice_read()&lt;/code&gt;，如果是 socket 的话，则是 &lt;code&gt;sock_splice_read()&lt;/code&gt;，其他的类型也会有对应的实现，总之我们这里将使用的是 &lt;code&gt;generic_file_splice_read()&lt;/code&gt; 函数，这个函数会继续调用内部函数 &lt;code&gt;__generic_file_splice_read&lt;/code&gt; 完成以下工作：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;up6QVzJW&quot;&gt;在 page cache 页缓存里进行搜寻，看看我们要读取这个文件内容是否已经在缓存里了，如果是则直接用，否则如果不存在或者只有部分数据在缓存中，则分配一些新的内存页并进行读入数据操作，同时会增加页框的引用计数；&lt;/li&gt;&lt;li data-pid=&quot;FSEathyU&quot;&gt;基于这些内存页，初始化 splice_pipe_desc 结构，这个结构保存会保存文件数据的地址元信息，包含有物理内存页框地址，偏移、数据长度，也就是 pipe_buffer 所需的三个定位数据的值；&lt;/li&gt;&lt;li data-pid=&quot;k5PAllU9&quot;&gt;最后，调用 &lt;code&gt;splice_to_pipe()&lt;/code&gt;，splice_pipe_desc 结构体实例是函数入参。&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;ssize_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;splice_to_pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_inode_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;splice_pipe_desc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;send_sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGPIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EPIPE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrbufs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newbuf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curbuf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrbufs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe_buffer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bufs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newbuf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;c1&quot;&gt;// 写入数据到管道，没有真正拷贝数据，而是内存地址指针的移动，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;c1&quot;&gt;// 把物理页框、偏移量和数据长度赋值给 pipe_buffer 完成数据入队操作
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;partial&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;page_nr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ops&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SPLICE_F_GIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PIPE_BUF_FLAG_GIFT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrbufs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;page_nr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;do_wakeup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr_pages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nrbufs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pipe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;dmwLFJsS&quot;&gt;这里可以清楚地看到 &lt;code&gt;splice()&lt;/code&gt; 所谓的写入数据到管道其实并没有真正地拷贝数据，而是玩了个 tricky 的操作：只进行内存地址指针的拷贝而不真正去拷贝数据。所以，数据 &lt;code&gt;splice()&lt;/code&gt; 在内核中并没有进行真正的数据拷贝，因此 &lt;code&gt;splice()&lt;/code&gt; 系统调用也是零拷贝。&lt;/p&gt;&lt;p data-pid=&quot;IkTAXEGO&quot;&gt;还有一点需要注意，前面说过管道的容量是 16 个内存页，也就是 16 * 4KB = 64 KB，也就是说一次往管道里写数据的时候最好不要超过 64 KB，否则的话会 &lt;code&gt;splice()&lt;/code&gt; 会阻塞住，除非在创建管道的时候使用的是 &lt;code&gt;pipe2()&lt;/code&gt; 并通过传入 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 属性将管道设置为非阻塞。&lt;/p&gt;&lt;p data-pid=&quot;AAFge1SH&quot;&gt;即使 &lt;code&gt;splice()&lt;/code&gt; 通过内存地址指针避免了真正的拷贝开销，但是算起来它还要使用额外的管道来完成数据传输，也就是比 &lt;code&gt;sendfile()&lt;/code&gt; 多了两次系统调用，这不是又增加了上下文切换的开销吗？为什么不直接在内核创建管道并调用那两次 &lt;code&gt;splice()&lt;/code&gt;，然后只暴露给用户一次系统调用呢？实际上因为 &lt;code&gt;splice()&lt;/code&gt; 利用管道而非硬件来完成零拷贝的实现比 &lt;code&gt;sendfile()&lt;/code&gt; + DMA Scatter/Gather 的门槛更低，因此后来的 &lt;code&gt;sendfile()&lt;/code&gt; 的底层实现就已经替换成 &lt;code&gt;splice()&lt;/code&gt; 了。&lt;/p&gt;&lt;p data-pid=&quot;_cOweNNU&quot;&gt;至于说 &lt;code&gt;splice()&lt;/code&gt; 本身的 API 为什么还是这种使用模式，那是因为 Linux 内核开发团队一直想把基于管道的这个限制去掉，但不知道因为什么一直搁置，所以这个 API 也就一直没变化，只能等内核团队哪天想起来了这一茬，然后重构一下使之不再依赖管道，在那之前，使用 &lt;code&gt;splice()&lt;/code&gt; 依然还是需要额外创建管道来作为中间缓冲，如果你的业务场景很适合使用 &lt;code&gt;splice()&lt;/code&gt;，但又是性能敏感的，不想频繁地创建销毁 pipe buffer 管道缓冲区，那么可以参考一下 HAProxy 使用 &lt;code&gt;splice()&lt;/code&gt; 时采用的优化方案：预先分配一个 pipe buffer pool 缓存管道，每次调用 &lt;code&gt;spclie()&lt;/code&gt; 的时候去缓存池里取一个管道，用完就放回去，循环利用，提升性能。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;send() with MSG_ZEROCOPY&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;FbJCob2q&quot;&gt;Linux 内核在 2017 年的 v4.14 版本接受了来自 Google 工程师 Willem de Bruijn 在 TCP 网络报文的通用发送接口 &lt;code&gt;send()&lt;/code&gt; 中实现的 zero-copy 功能 (MSG_ZEROCOPY) 的 patch，通过这个新功能，用户进程就能够把用户缓冲区的数据通过零拷贝的方式经过内核空间发送到网络套接字中去，这个新技术和前文介绍的几种零拷贝方式相比更加先进，因为前面几种零拷贝技术都是要求用户进程不能处理加工数据而是直接转发到目标文件描述符中去的。Willem de Bruijn 在他的论文里给出的压测数据是：采用 netperf 大包发送测试，性能提升 39%，而线上环境的数据发送性能则提升了 5%~8%，官方文档陈述说这个特性通常只在发送 10KB 左右大包的场景下才会有显著的性能提升。一开始这个特性只支持 TCP，到内核 v5.0 版本之后才支持 UDP。&lt;/p&gt;&lt;p data-pid=&quot;L5V2tiE9&quot;&gt;这个功能的使用模式如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setsockopt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket_fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOL_SOCKET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SO_ZEROCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;setsockopt zerocopy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;socket_fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MSG_ZEROCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;39vBMMxJ&quot;&gt;首先第一步，先给要发送数据的 socket 设置一个 SOCK_ZEROCOPY option，然后在调用 &lt;code&gt;send()&lt;/code&gt; 发送数据时再设置一个 MSG_ZEROCOPY option，其实理论上来说只需要调用 &lt;code&gt;setsockopt()&lt;/code&gt; 或者 &lt;code&gt;send()&lt;/code&gt; 时传递这个 zero-copy 的 option 即可，两者选其一，但是这里却要设置同一个 option 两次，官方的说法是为了兼容 &lt;code&gt;send()&lt;/code&gt; API 以前的设计上的一个错误：&lt;code&gt;send()&lt;/code&gt; 以前的实现会忽略掉未知的 option，为了兼容那些可能已经不小心设置了 MSG_ZEROCOPY option 的程序，故而设计成了两步设置。不过我猜还有一种可能：就是给使用者提供更灵活的使用模式，因为这个新功能只在大包场景下才可能会有显著的性能提升，但是现实场景是很复杂的，不仅仅是全部大包或者全部小包的场景，有可能是大包小包混合的场景，因此使用者可以先调用 &lt;code&gt;setsockopt()&lt;/code&gt; 设置 SOCK_ZEROCOPY option，然后再根据实际业务场景中的网络包尺寸选择是否要在调用 &lt;code&gt;send()&lt;/code&gt; 时使用 MSG_ZEROCOPY 进行 zero-copy 传输。&lt;/p&gt;&lt;p data-pid=&quot;o8UVD3th&quot;&gt;因为 &lt;code&gt;send()&lt;/code&gt; 可能是异步发送数据，因此使用 MSG_ZEROCOPY 有一个需要特别注意的点是：调用 &lt;code&gt;send()&lt;/code&gt; 之后不能立刻重用或释放 buffer，因为 buffer 中的数据不一定已经被内核读走了，所以还需要从 socket 关联的错误队列里读取一下通知消息，看看 buffer 中的数据是否已经被内核读走了：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;&lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;events&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pfd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;revents&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLERR&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;poll&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recvmsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MSG_ERRQUEUE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;recvmsg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;read_notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_notification&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msghdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock_extended_err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmsghdr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;cm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMSG_FIRSTHDR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmsg_level&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SOL_IP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmsg_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IP_RECVERR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cmsg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;n&quot;&gt;serr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CMSG_DATA&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ee_errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;serr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ee_origin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SO_EE_ORIGIN_ZEROCOPY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;serr&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ee&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;JLGtuONw&quot;&gt;这个技术是基于 redhat 红帽在 2010 年给 Linux 内核提交的 virtio-net zero-copy 技术之上实现的，至于底层原理，简单来说就是通过 &lt;code&gt;send()&lt;/code&gt; 把数据在用户缓冲区中的分段指针发送到 socket 中去，利用 page pinning 页锁定机制锁住用户缓冲区的内存页，然后利用 DMA 直接在用户缓冲区通过内存地址指针进行数据读取，实现零拷贝；具体的细节可以通过阅读 Willem de Bruijn 的&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//netdevconf.org/2.1/papers/netdev.pdf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;论文 (PDF)&lt;/a&gt;&lt;/b&gt; 深入了解。&lt;/p&gt;&lt;p data-pid=&quot;CywTdxlh&quot;&gt;目前来说，这种技术的主要缺陷有：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;eOEgwAU4&quot;&gt;只适用于大文件 (10KB 左右) 的场景，小文件场景因为 page pinning 页锁定和等待缓冲区释放的通知消息这些机制，甚至可能比直接 CPU 拷贝更耗时；&lt;/li&gt;&lt;li data-pid=&quot;ymYJq519&quot;&gt;因为可能异步发送数据，需要额外调用 &lt;code&gt;poll()&lt;/code&gt; 和 &lt;code&gt;recvmsg()&lt;/code&gt; 系统调用等待 buffer 被释放的通知消息，增加代码复杂度，以及会导致多次用户态和内核态的上下文切换；&lt;/li&gt;&lt;li data-pid=&quot;wjMZ7Si3&quot;&gt;MSG_ZEROCOPY 目前只支持发送端，接收端暂不支持。&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;绕过内核的直接 I/O&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;n21JTKqF&quot;&gt;可以看出，前面种种的 zero-copy 的方法，都是在想方设法地优化减少或者去掉用户态和内核态之间以及内核态和内核态之间的数据拷贝，为了实现避免这些拷贝可谓是八仙过海，各显神通，采用了各种各样的手段，那么如果我们换个思路：其实这么费劲地去消除这些拷贝不就是因为有内核在掺和吗？如果我们绕过内核直接进行 I/O 不就没有这些烦人的拷贝问题了吗？这就是&lt;b&gt;绕过内核直接 I/O&lt;/b&gt; 技术：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-89e764295fa13980880679ff5c5a63e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-89e764295fa13980880679ff5c5a63e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;684&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-89e764295fa13980880679ff5c5a63e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-89e764295fa13980880679ff5c5a63e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;F39iWbGr&quot;&gt;这种方案有两种实现方式：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;fC13zqr1&quot;&gt;用户直接访问硬件&lt;/li&gt;&lt;li data-pid=&quot;a0wkWzRF&quot;&gt;内核控制访问硬件&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;用户直接访问硬件&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;VD1bg9g1&quot;&gt;这种技术赋予用户进程直接访问硬件设备的权限，这让用户进程能有直接读写硬件设备，在数据传输过程中只需要内核做一些虚拟内存配置相关的工作。这种无需数据拷贝和内核干预的直接 I/O，理论上是最高效的数据传输技术，但是正如前面所说的那样，并不存在能解决一切问题的银弹，这种直接 I/O 技术虽然有可能非常高效，但是它的适用性也非常窄，目前只适用于诸如 MPI 高性能通信、丛集计算系统中的远程共享内存等有限的场景。&lt;/p&gt;&lt;p data-pid=&quot;pSLraIg5&quot;&gt;这种技术实际上破坏了现代计算机操作系统最重要的概念之一 —— 硬件抽象，我们之前提过，抽象是计算机领域最最核心的设计思路，正式由于有了抽象和分层，各个层级才能不必去关心很多底层细节从而专注于真正的工作，才使得系统的运作更加高效和快速。此外，网卡通常使用功能较弱的 CPU，例如只包含简单指令集的 MIPS 架构处理器（没有不必要的功能，如浮点数计算等），也没有太多的内存来容纳复杂的软件。因此，通常只有那些基于以太网之上的专用协议会使用这种技术，这些专用协议的设计要比远比 TCP/IP 简单得多，而且多用于局域网环境中，在这种环境中，数据包丢失和损坏很少发生，因此没有必要进行复杂的数据包确认和流量控制机制。而且这种技术还需要定制的网卡，所以它是高度依赖硬件的。&lt;/p&gt;&lt;p data-pid=&quot;CgD1WXt0&quot;&gt;与传统的通信设计相比，直接硬件访问技术给程序设计带来了各种限制：由于设备之间的数据传输是通过 DMA 完成的，因此用户空间的数据缓冲区内存页必须进行 page pinning（页锁定），这是为了防止其物理页框地址被交换到磁盘或者被移动到新的地址而导致 DMA 去拷贝数据的时候在指定的地址找不到内存页从而引发缺页错误，而页锁定的开销并不比 CPU 拷贝小，所以为了避免频繁的页锁定系统调用，应用程序必须分配和注册一个持久的内存池，用于数据缓冲。&lt;/p&gt;&lt;p data-pid=&quot;fJBa0wd3&quot;&gt;用户直接访问硬件的技术可以得到极高的 I/O 性能，但是其应用领域和适用场景也极其的有限，如集群或网络存储系统中的节点通信。它需要定制的硬件和专门设计的应用程序，但相应地对操作系统内核的改动比较小，可以很容易地以内核模块或设备驱动程序的形式实现出来。直接访问硬件还可能会带来严重的安全问题，因为用户进程拥有直接访问硬件的极高权限，所以如果你的程序设计没有做好的话，可能会消耗本来就有限的硬件资源或者进行非法地址访问，可能也会因此间接地影响其他正在使用同一设备的应用程序，而因为绕开了内核，所以也无法让内核替你去控制和管理。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;内核控制访问硬件&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;XGCt4kf5&quot;&gt;相较于用户直接访问硬件技术，通过内核控制的直接访问硬件技术更加的安全，它比前者在数据传输过程中会多干预一点，但也仅仅是作为一个代理人这样的角色，不会参与到实际的数据传输过程，内核会控制 DMA 引擎去替用户进程做缓冲区的数据传输工作。同样的，这种方式也是高度依赖硬件的，比如一些集成了专有网络栈协议的网卡。这种技术的一个优势就是用户集成去 I/O 时的接口不会改变，就和普通的 &lt;code&gt;read()/write()&lt;/code&gt; 系统调用那样使用即可，所有的脏活累活都在内核里完成，用户接口友好度很高，不过需要注意的是，使用这种技术的过程中如果发生了什么不可预知的意外从而导致无法使用这种技术进行数据传输的话，则内核会自动切换为最传统 I/O 模式，也就是性能最差的那种模式。&lt;/p&gt;&lt;p data-pid=&quot;BnAaX0kJ&quot;&gt;这种技术也有着和用户直接访问硬件技术一样的问题：DMA 传输数据的过程中，用户进程的缓冲区内存页必须进行 page pinning 页锁定，数据传输完成后才能解锁。CPU 高速缓存内保存的多个内存地址也会被冲刷掉以保证 DMA 传输前后的数据一致性。这些机制有可能会导致数据传输的性能变得更差，因为 &lt;code&gt;read()/write()&lt;/code&gt; 系统调用的语义并不能提前通知 CPU 用户缓冲区要参与 DMA 数据传输传输，因此也就无法像内核缓冲区那样可依提前加载进高速缓存，提高性能。由于用户缓冲区的内存页可能分布在物理内存中的任意位置，因此一些实现不好的 DMA 控制器引擎可能会有寻址限制从而导致无法访问这些内存区域。一些技术比如 AMD64 架构中的 IOMMU，允许通过将 DMA 地址重新映射到内存中的物理地址来解决这些限制，但反过来又可能会导致可移植性问题，因为其他的处理器架构，甚至是 Intel 64 位 x86 架构的变种 EM64T 都不具备这样的特性单元。此外，还可能存在其他限制，比如 DMA 传输的数据对齐问题，又会导致无法访问用户进程指定的任意缓冲区内存地址。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;内核缓冲区和用户缓冲区之间的传输优化&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;LI_ijLVy&quot;&gt;到目前为止，我们讨论的 zero-copy 技术都是基于减少甚至是避免用户空间和内核空间之间的 CPU 数据拷贝的，虽然有一些技术非常高效，但是大多都有适用性很窄的问题，比如 &lt;code&gt;sendfile()&lt;/code&gt;、&lt;code&gt;splice()&lt;/code&gt; 这些，效率很高，但是都只适用于那些用户进程不需要直接处理数据的场景，比如静态文件服务器或者是直接转发数据的代理服务器。&lt;/p&gt;&lt;p data-pid=&quot;1Qs_13Jw&quot;&gt;现在我们已经知道，硬件设备之间的数据可以通过 DMA 进行传输，然而却并没有这样的传输机制可以应用于用户缓冲区和内核缓冲区之间的数据传输。不过另一方面，广泛应用在现代的 CPU 架构和操作系统上的虚拟内存机制表明，通过在不同的虚拟地址上重新映射页面可以实现在用户进程和内核之间虚拟复制和共享内存，尽管一次传输的内存颗粒度相对较大：4KB 或 8KB。&lt;/p&gt;&lt;p data-pid=&quot;Ne1B7xGF&quot;&gt;因此如果要在实现在用户进程内处理数据（这种场景比直接转发数据更加常见）之后再发送出去的话，用户空间和内核空间的数据传输就是不可避免的，既然避无可避，那就只能选择优化了，因此本章节我们要介绍两种优化用户空间和内核空间数据传输的技术：&lt;/p&gt;&lt;ol&gt;&lt;li data-pid=&quot;3Tq9Tzdv&quot;&gt;动态重映射与写时拷贝 (Copy-on-Write)&lt;/li&gt;&lt;li data-pid=&quot;caC8OsJu&quot;&gt;缓冲区共享 (Buffer Sharing)&lt;/li&gt;&lt;/ol&gt;&lt;h3&gt;&lt;b&gt;动态重映射与写时拷贝 (Copy-on-Write)&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;17N81k56&quot;&gt;前面我们介绍过利用内存映射技术来减少数据在用户空间和内核空间之间的复制，通常简单模式下，用户进程是对共享的缓冲区进行同步阻塞读写的，这样不会有 data race 问题，但是这种模式下效率并不高，而提升效率的一种方法就是异步地对共享缓冲区进行读写，而这样的话就必须引入保护机制来避免数据冲突问题，写时复制 (Copy on Write) 就是这样的一种技术。&lt;/p&gt;&lt;blockquote data-pid=&quot;3ltIvhmI&quot;&gt;&lt;b&gt;写入时复制&lt;/b&gt;（&lt;b&gt;Copy-on-write&lt;/b&gt;，&lt;b&gt;COW&lt;/b&gt;）是一种计算机&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E7%25A8%258B%25E5%25BC%258F%25E8%25A8%25AD%25E8%25A8%2588&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;程序设计&lt;/a&gt;&lt;/b&gt;领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2580%258F%25E6%2598%258E&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;透明&lt;/a&gt;&lt;/b&gt;的。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。&lt;br/&gt; &lt;/blockquote&gt;&lt;p data-pid=&quot;CJQgTEe_&quot;&gt;举一个例子，引入了 COW 技术之后，用户进程读取磁盘文件进行数据处理最后写到网卡，首先使用内存映射技术让用户缓冲区和内核缓冲区共享了一段内存地址并标记为只读 (read-only)，避免数据拷贝，而当要把数据写到网卡的时候，用户进程选择了异步写的方式，系统调用会直接返回，数据传输就会在内核里异步进行，而用户进程就可以继续其他的工作，并且共享缓冲区的内容可以随时再进行读取，效率很高，但是如果该进程又尝试往共享缓冲区写入数据，则会产生一个 COW 事件，让试图写入数据的进程把数据复制到自己的缓冲区去修改，这里只需要复制要修改的内存页即可，无需所有数据都复制过去，而如果其他访问该共享内存的进程不需要修改数据则可以永远不需要进行数据拷贝。&lt;/p&gt;&lt;p data-pid=&quot;V3IdcfGz&quot;&gt;COW 是一种建构在虚拟内存冲映射技术之上的技术，因此它需要 MMU 的硬件支持，MMU 会记录当前哪些内存页被标记成只读，当有进程尝试往这些内存页中写数据的时候，MMU 就会抛一个异常给操作系统内核，内核处理该异常时为该进程分配一份物理内存并复制数据到此内存地址，重新向 MMU 发出执行该进程的写操作。&lt;/p&gt;&lt;p data-pid=&quot;aV_62BRL&quot;&gt;COW 最大的优势是节省内存和减少数据拷贝，不过却是通过增加操作系统内核 I/O 过程复杂性作为代价的。当确定采用 COW 来复制页面时，重要的是注意空闲页面的分配位置。许多操作系统为这类请求提供了一个空闲的页面池。当进程的堆栈或堆要扩展时或有写时复制页面需要管理时，通常分配这些空闲页面。操作系统分配这些页面通常采用称为&lt;b&gt;按需填零&lt;/b&gt;的技术。按需填零页面在需要分配之前先填零，因此会清除里面旧的内容。&lt;/p&gt;&lt;p data-pid=&quot;wwHi7Jsk&quot;&gt;&lt;b&gt;局限性&lt;/b&gt;：&lt;/p&gt;&lt;p data-pid=&quot;Ru-m9A13&quot;&gt;COW 这种零拷贝技术比较适用于那种多读少写从而使得 COW 事件发生较少的场景，因为 COW 事件所带来的系统开销要远远高于一次 CPU 拷贝所产生的。此外，在实际应用的过程中，为了避免频繁的内存映射，可以重复使用同一段内存缓冲区，因此，你不需要在只用过一次共享缓冲区之后就解除掉内存页的映射关系，而是重复循环使用，从而提升性能，不过这种内存页映射的持久化并不会减少由于页表往返移动和 TLB 冲刷所带来的系统开销，因为每次接收到 COW 事件之后对内存页而进行加锁或者解锁的时候，页面的只读标志 (read-ony) 都要被更改为 (write-only)。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;缓冲区共享 (Buffer Sharing)&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;xgCybGke&quot;&gt;从前面的介绍可以看出，传统的 Linux I/O 接口，都是基于复制/拷贝的：数据需要在操作系统内核空间和用户空间的缓冲区之间进行拷贝。在进行 I/O 操作之前，用户进程需要预先分配好一个内存缓冲区，使用 &lt;code&gt;read()&lt;/code&gt; 系统调用时，内核会将从存储器或者网卡等设备读入的数据拷贝到这个用户缓冲区里；而使用 &lt;code&gt;write()&lt;/code&gt; 系统调用时，则是把用户内存缓冲区的数据拷贝至内核缓冲区。&lt;/p&gt;&lt;p data-pid=&quot;rdQwjfhs&quot;&gt;为了实现这种传统的 I/O 模式，Linux 必须要在每一个 I/O 操作时都进行内存虚拟映射和解除。这种内存页重映射的机制的效率严重受限于缓存体系结构、MMU 地址转换速度和 TLB 命中率。如果能够避免处理 I/O 请求的虚拟地址转换和 TLB 刷新所带来的开销，则有可能极大地提升 I/O 性能。而缓冲区共享就是用来解决上述问题的一种技术。&lt;/p&gt;&lt;p data-pid=&quot;OmFnh_ji&quot;&gt;最早支持 Buffer Sharing 的操作系统是 Solaris。后来，Linux 也逐步支持了这种 Buffer Sharing 的技术，但时至今日依然不够完整和成熟。&lt;/p&gt;&lt;p data-pid=&quot;nhlNVYc1&quot;&gt;操作系统内核开发者们实现了一种叫 fbufs 的缓冲区共享的框架，也即&lt;b&gt;快速缓冲区（ Fast Buffers ）&lt;/b&gt;，使用一个 fbuf 缓冲区作为数据传输的最小单位，使用这种技术需要调用新的操作系统 API，用户区和内核区、内核区之间的数据都必须严格地在 fbufs 这个体系下进行通信。fbufs 为每一个用户进程分配一个 buffer pool，里面会储存预分配 (也可以使用的时候再分配) 好的 buffers，这些 buffers 会被同时映射到用户内存空间和内核内存空间。fbufs 只需通过一次虚拟内存映射操作即可创建缓冲区，有效地消除那些由存储一致性维护所引发的大多数性能损耗。&lt;/p&gt;&lt;p data-pid=&quot;XOmOFmsZ&quot;&gt;传统的 Linux I/O 接口是通过把数据在用户缓冲区和内核缓冲区之间进行拷贝传输来完成的，这种数据传输过程中需要进行大量的数据拷贝，同时由于虚拟内存技术的存在，I/O 过程中还需要频繁地通过 MMU 进行虚拟内存地址到物理内存地址的转换，高速缓存的汰换以及 TLB 的刷新，这些操作均会导致性能的损耗。而如果利用 fbufs 框架来实现数据传输的话，首先可以把 buffers 都缓存到 pool 里循环利用，而不需要每次都去重新分配，而且缓存下来的不止有 buffers 本身，而且还会把虚拟内存地址到物理内存地址的映射关系也缓存下来，也就可以避免每次都进行地址转换，从发送接收数据的层面来说，用户进程和 I/O 子系统比如设备驱动程序、网卡等可以直接传输整个缓冲区本身而不是其中的数据内容，也可以理解成是传输内存地址指针，这样就就避免了大量的数据内容拷贝：用户进程/ IO 子系统通过发送一个个的 fbuf 写出数据到内核而非直接传递数据内容，相对应的，用户进程/ IO 子系统通过接收一个个的 fbuf 而从内核读入数据，这样就能减少传统的 &lt;code&gt;read()/write()&lt;/code&gt; 系统调用带来的数据拷贝开销：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9b6aace364e295bd5a6271c146d477ab_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;640&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9b6aace364e295bd5a6271c146d477ab_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1200&quot; data-rawheight=&quot;640&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9b6aace364e295bd5a6271c146d477ab_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9b6aace364e295bd5a6271c146d477ab_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;ol&gt;&lt;li data-pid=&quot;GssQfh6i&quot;&gt;发送方用户进程调用 &lt;code&gt;uf_allocate&lt;/code&gt; 从自己的 buffer pool 获取一个 fbuf 缓冲区，往其中填充内容之后调用 &lt;code&gt;uf_write&lt;/code&gt; 向内核区发送指向 fbuf 的文件描述符；&lt;/li&gt;&lt;li data-pid=&quot;EKZFkLYI&quot;&gt;I/O 子系统接收到 fbuf 之后，调用 &lt;code&gt;uf_allocb&lt;/code&gt; 从接收方用户进程的 buffer pool 获取一个 fubf 并用接收到的数据进行填充，然后向用户区发送指向 fbuf 的文件描述符；&lt;/li&gt;&lt;li data-pid=&quot;vihkbRLB&quot;&gt;接收方用户进程调用 &lt;code&gt;uf_get&lt;/code&gt; 接收到 fbuf，读取数据进行处理，完成之后调用 &lt;code&gt;uf_deallocate&lt;/code&gt; 把 fbuf 放回自己的 buffer pool。&lt;/li&gt;&lt;/ol&gt;&lt;p data-pid=&quot;M256W96F&quot;&gt;&lt;b&gt;fbufs 的缺陷&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;G9HKGlSq&quot;&gt;共享缓冲区技术的实现需要依赖于用户进程、操作系统内核、以及 I/O 子系统 (设备驱动程序，文件系统等)之间协同工作。比如，设计得不好的用户进程容易就会修改已经发送出去的 fbuf 从而污染数据，更要命的是这种问题很难 debug。虽然这个技术的设计方案非常精彩，但是它的门槛和限制却不比前面介绍的其他技术少：首先会对操作系统 API 造成变动，需要使用新的一些 API 调用，其次还需要设备驱动程序配合改动，还有由于是内存共享，内核需要很小心谨慎地实现对这部分共享的内存进行数据保护和同步的机制，而这种并发的同步机制是非常容易出 bug 的从而又增加了内核的代码复杂度，等等。因此这一类的技术还远远没有到发展成熟和广泛应用的阶段，目前大多数的实现都还处于实验阶段。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h3&gt;&lt;p data-pid=&quot;sG_fkQQm&quot;&gt;本文中我主要讲解了 Linux I/O 底层原理，然后介绍并解析了 Linux 中的 Zero-copy 技术，并给出了 Linux 对 I/O 模块的优化和改进思路。&lt;/p&gt;&lt;p data-pid=&quot;ihqJeISe&quot;&gt;Linux 的 Zero-copy 技术可以归纳成以下三大类：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;bbTmnP06&quot;&gt;&lt;b&gt;减少甚至避免用户空间和内核空间之间的数据拷贝&lt;/b&gt;：在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 &lt;code&gt;Page Cache&lt;/code&gt; 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是是通过增加新的系统调用来完成的，比如 Linux 中的 mmap()，sendfile() 以及 splice() 等。&lt;/li&gt;&lt;li data-pid=&quot;sgG3enhs&quot;&gt;&lt;b&gt;绕过内核的直接 I/O&lt;/b&gt;：允许在用户态进程绕过内核直接和硬件进行数据传输，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。&lt;/li&gt;&lt;li data-pid=&quot;GeRCYmea&quot;&gt;&lt;b&gt;内核缓冲区和用户缓冲区之间的传输优化&lt;/b&gt;：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;EHBpRkou&quot;&gt;本文从虚拟内存、I/O 缓冲区，用户态&amp;amp;内核态以及 I/O 模式等等知识点全面而又详尽地剖析了 Linux 系统的 I/O 底层原理，分析了 Linux 传统的 I/O 模式的弊端，进而引入 Linux Zero-copy 零拷贝技术的介绍和原理解析，通过将零拷贝技术和传统的 I/O 模式进行区分和对比，带领读者经历了 Linux I/O 的演化历史，通过帮助读者理解 Linux 内核对 I/O 模块的优化改进思路，相信不仅仅是让读者了解 Linux 底层系统的设计原理，更能对读者们在以后优化改进自己的程序设计过程中能够有所启发。&lt;/p&gt;&lt;p data-pid=&quot;ptrELNJe&quot;&gt;&lt;b&gt;参考&amp;amp;延伸阅读&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;DQ5NueW6&quot;&gt;&lt;b&gt;更多干货尽在&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng&quot; class=&quot;internal&quot;&gt;腾讯技术&lt;/a&gt;，官方微信交流群已建立，交流讨论可加：Journeylife1900（备注腾讯技术） 。&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>90dbdd1a31389237c3478f120ad655d1</guid>
<title>没写过复杂 React 组件？来实现下 AntD 的 Space 组件吧</title>
<link>https://toutiao.io/k/plt53qi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 React 技术栈的小伙伴基本每天都在写 React 组件，但是大多是是业务组件，并不是很复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本就是传入 props，render 出最终的视图，用 hooks 组织下逻辑，最多再用下 context 跨层传递数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那相对复杂的组件是什么样子的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 antd 组件库里就有很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们就来实现一个 antd 组件库里的组件 -- Space 组件吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看下它是怎么用的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个布局组件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4683357879234168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3iaWcruvsK9qfGS0iciaU49ty1bLLCfGcPJtia7ibFgkpz02x2QiaDqggnibCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1358&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文档里介绍它是设置组件的间距的，还可以设置多个组件怎么对齐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如这样 3 个盒子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4816753926701571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3nc2aW1P25WYtYefnh5OO5hWFqYiaCiau9plA9icvPTdauC3FFYn9NrcdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3hUuZ7C0da13KvG6CMgVibhJTATTUjT8NvyX0bZId8kaexJcmPibDwOibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渲染出来是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2627737226277371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3tVfYq5Lrj9us0uRWj2cejYmuPhyWu6yWERfQZ6h4ACqzoYQWicLSJRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用 Space 组件包一下，设置方向为水平，就变成这样了（漏了一张代码截图，看后面的吧）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4319526627218935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3ZTx4qoKpdTZ4ic9AsQ9hpSN1f8libvJh52JUjRBytF1mAiaKSku6CH83Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，也可以竖直：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2824207492795389&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3EhIPVleHbpdXMvr44Mk1vS2lYFoW3TVqPU73ssAia4t97xlQ4s4S4icw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2082&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;水平和竖直的间距都可以通过 size 来设置：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42965116279069765&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3bO7T6mib8NDTgickkBXico5Mz2t0DJZo3lsFbOzDg0z4NAKcVt9h52oaw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1720&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以设置 large、middle、small 或者任意数值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个子节点可以设置对齐方式，比如 start、end、center 或者 baseline：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3VISQB98Lh6IpdmKJQiaHQUXhVD7fuo6uCHqQxSRB6hMtuqNtvKSLDTQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2080&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外子节点过多可以设置换行：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3925423728813559&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3fac3HFwBkIq7EUUW6bVhB7cyb4uqia2uK0wOB84teaiaiaEs8gQ145Pdw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1475&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;space 也可以单独设置行列的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40694789081885857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3DykibIChTPQBxic59wAdAa4xicpVNCO6zIVb8nCbZbnaOoiaY9stV7XeSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2418&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，它还可以设置 split 分割线部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3ibYk5WTon0TQeezxcW9443CJ1RfTrMFug55rIsPOicGFznXPaOS5o0vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2500&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你也可以不直接设置 size，而是通过 ConfigProvider 修改 context 中的默认值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3918791312559018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn397weOdkvKKpF3EeHzqIQOzeFBSsCMraxzwXm19EcUKZa8NksHSTgOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2118&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，Space 内部会读取 context 中的 size 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样如果有多个 Space 组件就不用每个都设置了，统一加个 ConfigProvider 就行了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4363459669582119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3MHsICMBX8IvH2BMq2o0sX5BDMaFfszV3MmdxFr0dibuKVbqptEfJdUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是 Space 组件的全部用法，简单回顾下这几个参数和用法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;direction: 设置子组件方向，水平还是竖直排列&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;size：设置水平、竖直的间距&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;align：子组件的对齐方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wrap：超过一屏是否换行，只在水平时有用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;split：分割线的组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多个 Space 组件的 size 可以通过 ConfigProvider 统一设置默认值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是过一遍就会用了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用起来还是挺简单的，但它的功能挺强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这样的布局组件是怎么实现的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看下它最终的 dom：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5539823008849557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3sLJQeWarw1OzibqWJztR0RQRCQjwyEz8mQylRhY19qGPvvOtIpIxeeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1130&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对每个 box 包了一层 div，设置了 ant-space-item 的 class。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 split 部分包了一层 span，设置了 ant-space-item-split 的 class。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最外层包了一层 div，设置了 ant-space 等 class。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些还是很容易想到的，毕竟设置布局嘛，不包一层怎么布局？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但虽然看起来挺简单，实现的话还是有不少东西的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来写一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先声明组件 props 的类型：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4394506866416979&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3xfJnnoibGuMXohicfjcd9TJF6MufQzKHkwgKEmeryT0ryuO1Ku2Cxtvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是 style 是 React.CSSProperties 类型，也就是各种 css 都可以写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;split 是 React.ReactNode 类型，也就是可以传入 jsx。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其余的参数的类型就是根据取值来，我们上面都测试过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Space 组件会对所有子组件包一层 div，所以需要遍历传入的 children，做下修改：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;props 传入的 children 要转成数组可以用 React.Children.toArray 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学说，children 不是已经是数组了么？为什么还要用 React.Children.toArray 转一下？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 toArray 可以对 children 做扁平化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4824824824824825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3fwMibdFs7iaLicMXFvibM5BibBNxeTmA8Y9J5ub6VatxacGXosibiafNuFVew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;999&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更重要的是直接调用 children.sort() 会报错：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3r62FdABH9PPSicgUhQ8dvdKTufLAr3Al3eaFKdagCJhjKJ9QLFMS8uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2480&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 toArray 之后就不会了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38275499474237645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3bqDvgRJlmWqbfAdNyuJb5aD4V7EmtqiaRKUnhxNsZMGUztcictXfg9XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，&lt;strong&gt;我们会用 React.Children.forEach，React.Children.map 之类的方法操作 children，而不是直接操作。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10119047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3eQGLsClWyaajVkVibmTGYbspA41TqjPs9QaiaVPCv2BP2dIk9wRpP28Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这里我们有一些特殊的需求，比如空节点不过滤掉，依然保留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以用 React.Children.forEach 自己实现一下 toArray：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.740506329113924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3icdF1xl4QxDVrPTW8SWV9aSSZQhGs6XpsMib4wqjTA4iagOr4wzicgv0aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1580&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分比较容易看懂，就是用 React.Children.forEach 遍历 jsx 节点，对每个节点做下判断，如果是数组或 fragment 就递归处理，否则 push 到数组里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保不保留空节点可以根据 keepEmpty 的 option 来控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11480865224625623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn32X5Awia3pTGWjYewpt9oAno3G39xGdURZ9oJhjQHJAnC4PDAuMR9gMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;children 就可以遍历渲染 item 了，这部分是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3867069486404834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3zRd5BYpmB33xJXfseGaHPd5xLQJBNiby4F3GJkFxIH3M674gmV6oIGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们单独封装个 Item 组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 childNodes 遍历渲染这个 Item 就可以了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8026706231454006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3RmHic5qicDH1V5uEEWJKxb0oNdqyrjEdQfIEeuuufMuyQ6en9Eialkz5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后把这所有的 Item 组件再放到最外层 div 里：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2099236641221374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3PmQYq7CIJasNVoiaf6CeWDicTgDbdHFlVak1erK9I2yrcjIPIia5Fb1MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以分别控制整体的布局和 Item 的布局了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的布局还是通过 className 和样式来的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;className 通过 props 计算而来：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5619834710743802&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3aRwV5KtUKzIeqSKWZYRB28mibWicHxJIM88MRVCNXe1VicODav8ozrtrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1210&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用到了 classnames 这个包，这个算是 react 生态很常用的包了，根据 props 动态生成 className 基本都用这个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个前缀是动态获取的，最终就是 ant-space 的前缀：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15897435897435896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3YpibvSsLUUL1uhiaeGScROvwChKKJcMwuodHa2ESHpVCxIJTRXZmLt9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这些 class 的样式也都定义好：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$&lt;span&gt;ant-prefix&lt;/span&gt;: &#x27;&lt;span&gt;ant&lt;/span&gt;&#x27;;&lt;br/&gt;&lt;br/&gt;$&lt;span&gt;space-prefix-cls&lt;/span&gt;: #{$ant-prefix}&lt;span&gt;-space&lt;/span&gt;;&lt;br/&gt;$&lt;span&gt;space-item-prefix-cls&lt;/span&gt;: #{$ant-prefix}&lt;span&gt;-space-item&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;.#{$space-prefix-cls} {&lt;br/&gt;  &lt;span&gt;display&lt;/span&gt;: inline-flex;&lt;br/&gt;&lt;br/&gt;  &amp;amp;-vertical {&lt;br/&gt;    &lt;span&gt;flex-direction&lt;/span&gt;: column;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &amp;amp;&lt;span&gt;-align&lt;/span&gt; {&lt;br/&gt;    &amp;amp;-center {&lt;br/&gt;      &lt;span&gt;align-items&lt;/span&gt;: center;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &amp;amp;&lt;span&gt;-start&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;align-items&lt;/span&gt;: flex-start;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &amp;amp;&lt;span&gt;-end&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;align-items&lt;/span&gt;: flex-end;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &amp;amp;&lt;span&gt;-baseline&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;align-items&lt;/span&gt;: baseline;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;.#{$space-prefix-cls} {&lt;br/&gt;  &amp;amp;-rtl {&lt;br/&gt;    &lt;span&gt;direction&lt;/span&gt;: rtl;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;整个容器 inline-flex，然后根据不同的参数设置 align-items 和 flex-direction 的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个 direction 的 css 可能大家没用过，是设置文本方向的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5205314009661836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3C8xywCibibXxuaTiatYeOa0DUQOUvLrWv8ibiaao1uBBj8Q5b6qCpvbkLLg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1656&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，就通过 props 动态给最外层 div 加上了相应的 className，设置了对应的样式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但还有一部分样式没设置，也就是间距：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这部分可以用 gap 设置：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7570621468926554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3dfIjqaLxHT57oJqncCYPKtXhNhw9WCbKLaibk7WfRwlOKFD10v8VOJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，用 margin 也可以，只不过那个要单独处理下最后一个元素，比较麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过 antd 这种组件自然要做的兼容性好点，所以两种都支持，支持 gap 就用 gap，否则用 margin。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，antd 是怎么检测浏览器是否支持 gap 样式的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是这么做的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.86084142394822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3OJibgejVib3gNZ7Bca8kmQtnTjaInwHhUoGJLRyGLFv3AoNgiapibAVNMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个 div，设置样式，加到 body 下，看看 scrollHeight 是多少，最后把这个元素删掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能判断是是否支持 gap、column 等样式，因为不支持的话高度会是 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它又提供了这样一个 hook：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4716981132075472&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3fhp9VXICFV8dxGdSk8tsR7nHWtZOkVTtpP8R7SdO44Owm47iciawukPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1378&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次会检测并设置 state 的值，之后直接返回这个检测结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样组件里就可以就可以用这个 hook 来判断是否支持 gap，从而设置不同的样式了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8677354709418837&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3Kg5LpCjXO6Tz3JfqjcbAwjG305HeViaWWd9OsibAtmB5tsibiaQgxnUQug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很巧妙？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，这个组件还会从 ConfigProvider 中取值，这个我们见到过：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4363459669582119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3MHsICMBX8IvH2BMq2o0sX5BDMaFfszV3MmdxFr0dibuKVbqptEfJdUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，再处理下这部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35165876777251187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3k8bgwG11xSJuhBiancSEyPOCf7NMmEZBmKXu6rlrRQk5wxCSDFGbuNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2110&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 useContext 读取 context 中的值，设置为 props 的解构默认值，这样如果传入了 props.size 就用传入的值，否则就用 context 里的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给 Item 子组件传递数据也是通过 context，因为 Item 组件不一定会在哪一层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 createContext 创建 context 对象：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30868761552680224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3icfazblIFXicfVnpEYjInLe21mxsAsQCVNbek9YupQqyZKZTTxTFkmTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把计算出的 size：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19579646017699115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3UDFG9o8QoiaL3IEd5SQFmTSkEOOnen5LqtzecytqMKAoZJTKSmrjgLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有其他的一些值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14596670934699105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3BJr3vdJY1smu6Cguheu8hvukyWZt3BMkjGoQWGZwGlXhrGYD46U4rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;都通过 Provider 设置到 spaceContext 中：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3733955659276546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3oeCQROTBS5eylgB8ia8UjUeqLB8PKlXfWaOwvDxMhWaTxUmBIiaC3TKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样子组件就能拿到 spaceContext 中的值了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 useMemo 很多同学不会用，其实很容易理解：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;props 变了会触发组件重新渲染，但有的时候 props 并不需要变化却每次都变，这样就可以通过 useMemo 来避免它没必要的变化了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;useCallback 也是同样的道理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算 size 的时候封装了一个 getNumberSize 方法，对于字符串枚举值设置了一些固定的数值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34913793103448276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3OQDJALznEeQj2og24NVNqYWX5ibA4WsiaibIWWNwrGunyt8136FNLtlGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1392&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，这个组件我们就完成了，当然，Item 组件还没展开讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来欣赏下这个 Space 组件的全部源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; classNames &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;classnames&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; * &lt;span&gt;as&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ConfigContext, SizeType } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./config-provider&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Item &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./Item&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; toArray &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./toArray&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;./index.scss&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; useFlexGapSupport &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./useFlexGapSupport&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; interface Option {&lt;br/&gt;  keepEmpty?: boolean;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; SpaceContext = React.createContext({&lt;br/&gt;  &lt;span&gt;latestIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;horizontalSize&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;verticalSize&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;supportFlexGap&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type SpaceSize = SizeType | number;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; interface SpaceProps extends React.HTMLAttributes&amp;lt;HTMLDivElement&amp;gt; {&lt;br/&gt;  className?: string;&lt;br/&gt;  style?: React.CSSProperties;&lt;br/&gt;  size?: SpaceSize | [SpaceSize, SpaceSize];&lt;br/&gt;  direction?: &lt;span&gt;&#x27;horizontal&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;vertical&#x27;&lt;/span&gt;;&lt;br/&gt;  align?: &lt;span&gt;&#x27;start&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;end&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;center&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;baseline&#x27;&lt;/span&gt;;&lt;br/&gt;  split?: React.ReactNode;&lt;br/&gt;  wrap?: boolean;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; spaceSize = {&lt;br/&gt;  &lt;span&gt;small&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;middle&lt;/span&gt;: &lt;span&gt;16&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;large&lt;/span&gt;: &lt;span&gt;24&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getNumberSize&lt;/span&gt;(&lt;span&gt;size: SpaceSize&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; size === &lt;span&gt;&#x27;string&#x27;&lt;/span&gt; ? spaceSize[size] : size || &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; Space: React.FC&amp;lt;SpaceProps&amp;gt; = &lt;span&gt;&lt;span&gt;props&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { getPrefixCls, space, &lt;span&gt;direction&lt;/span&gt;: directionConfig } = React.useContext(ConfigContext);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; {&lt;br/&gt;    size = space?.size || &lt;span&gt;&#x27;small&#x27;&lt;/span&gt;,&lt;br/&gt;    align,&lt;br/&gt;    className,&lt;br/&gt;    children,&lt;br/&gt;    direction = &lt;span&gt;&#x27;horizontal&#x27;&lt;/span&gt;,&lt;br/&gt;    split,&lt;br/&gt;    style,&lt;br/&gt;    wrap = &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    ...otherProps&lt;br/&gt;  } = props;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; supportFlexGap = useFlexGapSupport();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [horizontalSize, verticalSize] = React.useMemo(&lt;br/&gt;    &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;      ((&lt;span&gt;Array&lt;/span&gt;.isArray(size) ? size : [size, size]) &lt;span&gt;as&lt;/span&gt; [SpaceSize, SpaceSize]).map(&lt;span&gt;&lt;span&gt;item&lt;/span&gt; =&amp;gt;&lt;/span&gt;&lt;br/&gt;        getNumberSize(item),&lt;br/&gt;      ),&lt;br/&gt;    [size],&lt;br/&gt;  );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; childNodes = toArray(children, {&lt;span&gt;keepEmpty&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;});&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; mergedAlign = align === &lt;span&gt;undefined&lt;/span&gt; &amp;amp;&amp;amp; direction === &lt;span&gt;&#x27;horizontal&#x27;&lt;/span&gt; ? &lt;span&gt;&#x27;center&#x27;&lt;/span&gt; : align;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; prefixCls = getPrefixCls(&lt;span&gt;&#x27;space&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; cn = classNames(&lt;br/&gt;    prefixCls,&lt;br/&gt;    &lt;span&gt;`&lt;span&gt;${prefixCls}&lt;/span&gt;-&lt;span&gt;${direction}&lt;/span&gt;`&lt;/span&gt;,&lt;br/&gt;    {&lt;br/&gt;      [&lt;span&gt;`&lt;span&gt;${prefixCls}&lt;/span&gt;-rtl`&lt;/span&gt;]: directionConfig === &lt;span&gt;&#x27;rtl&#x27;&lt;/span&gt;,&lt;br/&gt;      [&lt;span&gt;`&lt;span&gt;${prefixCls}&lt;/span&gt;-align-&lt;span&gt;${mergedAlign}&lt;/span&gt;`&lt;/span&gt;]: mergedAlign,&lt;br/&gt;    },&lt;br/&gt;    className,&lt;br/&gt;  );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; itemClassName = &lt;span&gt;`&lt;span&gt;${prefixCls}&lt;/span&gt;-item`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; marginDirection = directionConfig === &lt;span&gt;&#x27;rtl&#x27;&lt;/span&gt; ? &lt;span&gt;&#x27;marginLeft&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;marginRight&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Calculate latest one&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; latestIndex = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; nodes = childNodes.map(&lt;span&gt;(&lt;span&gt;child: any, i&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (child !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; child !== &lt;span&gt;undefined&lt;/span&gt;) {&lt;br/&gt;      latestIndex = i;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; key = (child &amp;amp;&amp;amp; child.key) || &lt;span&gt;`&lt;span&gt;${itemClassName}&lt;/span&gt;-&lt;span&gt;${i}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;      &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Item&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{itemClassName}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;key&lt;/span&gt;=&lt;span&gt;{key}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;direction&lt;/span&gt;=&lt;span&gt;{direction}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;index&lt;/span&gt;=&lt;span&gt;{i}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;marginDirection&lt;/span&gt;=&lt;span&gt;{marginDirection}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;split&lt;/span&gt;=&lt;span&gt;{split}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;wrap&lt;/span&gt;=&lt;span&gt;{wrap}&lt;/span&gt;&lt;br/&gt;      &amp;gt;&lt;/span&gt;&lt;br/&gt;        {child}&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;Item&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    );&lt;br/&gt;  });&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; spaceContext = React.useMemo(&lt;br/&gt;    &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({ horizontalSize, verticalSize, latestIndex, supportFlexGap }),&lt;br/&gt;    [horizontalSize, verticalSize, latestIndex, supportFlexGap],&lt;br/&gt;  );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (childNodes.length === &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; gapStyle: React.CSSProperties = {};&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (wrap) {&lt;br/&gt;    gapStyle.flexWrap = &lt;span&gt;&#x27;wrap&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!supportFlexGap) {&lt;br/&gt;      gapStyle.marginBottom = -verticalSize;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (supportFlexGap) {&lt;br/&gt;    gapStyle.columnGap = horizontalSize;&lt;br/&gt;    gapStyle.rowGap = verticalSize;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt;&lt;br/&gt;        ...gapStyle,&lt;br/&gt;        ...style,&lt;br/&gt;      }}&lt;br/&gt;      {&lt;span&gt;...otherProps&lt;/span&gt;}&lt;br/&gt;    &amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;SpaceContext.Provider&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;{spaceContext}&lt;/span&gt;&amp;gt;&lt;/span&gt;{nodes}&lt;span&gt;&amp;lt;/&lt;span&gt;SpaceContext.Provider&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  );&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Space;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾下要点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于 React.Children.forEach 自己封装了 toArray 方法，做了一些特殊处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 childNodes 遍历之后，包裹了一层 Item 组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;封装了 useFlexGapSupport 的 hook，里面通过创建 div 检查 scrollHeight 的方式来确定是否支持 gap 样式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 useContext 读取 ConfigContext 的值，作为 props 的解构默认值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 createContext 创建 spaceContext，并通过 Provider 设置其中的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 useMemo 缓存作为参数的对象，避免不必要的渲染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 classnames 包来根据 props 动态生成 className&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路理的差不多了，再来看下 Item 的实现：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分比较简单，直接上全部代码了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import * as React from &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;import { SpaceContext } from &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; interface ItemProps {&lt;br/&gt;  className: string;&lt;br/&gt;  children: React.ReactNode;&lt;br/&gt;  index: number;&lt;br/&gt;  direction?: &lt;span&gt;&#x27;horizontal&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;vertical&#x27;&lt;/span&gt;;&lt;br/&gt;  marginDirection: &lt;span&gt;&#x27;marginLeft&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;marginRight&#x27;&lt;/span&gt;;&lt;br/&gt;  split?: string | React.ReactNode;&lt;br/&gt;  wrap?: boolean;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; Item({&lt;br/&gt;  className,&lt;br/&gt;  direction,&lt;br/&gt;  index,&lt;br/&gt;  marginDirection,&lt;br/&gt;  children,&lt;br/&gt;  split,&lt;br/&gt;  wrap,&lt;br/&gt;}: ItemProps) {&lt;br/&gt;  const { horizontalSize, verticalSize, latestIndex, supportFlexGap } =&lt;br/&gt;    React.useContext(SpaceContext);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;let&lt;/span&gt; style: React.CSSProperties = {};&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!supportFlexGap) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (direction === &lt;span&gt;&#x27;vertical&#x27;&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (index &amp;lt; latestIndex) {&lt;br/&gt;        style = { marginBottom: horizontalSize / (split ? 2 : 1) };&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      style = {&lt;br/&gt;        ...(index &amp;lt; latestIndex &amp;amp;&amp;amp; { [marginDirection]: horizontalSize / (split ? 2 : 1) }),&lt;br/&gt;        ...(wrap &amp;amp;&amp;amp; { paddingBottom: verticalSize }),&lt;br/&gt;      };&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (children === null || children === undefined) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;&amp;gt;&lt;br/&gt;      &amp;lt;div className={className} style={style}&amp;gt;&lt;br/&gt;        {children}&lt;br/&gt;      &amp;lt;/div&amp;gt;&lt;br/&gt;      {index &amp;lt; latestIndex &amp;amp;&amp;amp; split &amp;amp;&amp;amp; (&lt;br/&gt;        &amp;lt;span className={`&lt;span&gt;${className}&lt;/span&gt;-split`} style={style}&amp;gt;&lt;br/&gt;          {split}&lt;br/&gt;        &amp;lt;/span&amp;gt;&lt;br/&gt;      )}&lt;br/&gt;    &amp;lt;/&amp;gt;&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 useContext 从 SpaceContext 中取出 Space 组件里设置的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据是否支持 gap 来分别使用 gap 或者 margin、padding 的样式来设置间距。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个元素都用 div 包裹下，设置 className。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不是最后一个元素并且有 split 部分，就渲染 split 部分，用 span 包裹下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块还是比较清晰的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，还有 ConfigProvider 的部分没有看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分就是创建一个 context，并初始化一些值：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;react&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type DirectionType = &lt;span&gt;&#x27;ltr&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;rtl&#x27;&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; type SizeType = &lt;span&gt;&#x27;small&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;middle&#x27;&lt;/span&gt; | &lt;span&gt;&#x27;large&#x27;&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; interface ConfigConsumerProps {&lt;br/&gt;  &lt;span&gt;getPrefixCls&lt;/span&gt;: &lt;span&gt;(&lt;span&gt;suffixCls?: string&lt;/span&gt;) =&amp;gt;&lt;/span&gt; string;&lt;br/&gt;  direction?: DirectionType;&lt;br/&gt;  space?: {&lt;br/&gt;    size?: SizeType | number;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; defaultGetPrefixCls = &lt;span&gt;(&lt;span&gt;suffixCls?: string&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; suffixCls ? &lt;span&gt;`ant-&lt;span&gt;${suffixCls}&lt;/span&gt;`&lt;/span&gt; : &lt;span&gt;&#x27;ant&#x27;&lt;/span&gt;;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ConfigContext = React.createContext&amp;lt;ConfigConsumerProps&amp;gt;({&lt;br/&gt;    &lt;span&gt;getPrefixCls&lt;/span&gt;: defaultGetPrefixCls&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有感觉 antd 里用 context 简直太多了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为你不能保证组件和子组件隔着几层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Form 和 Form.Item：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1085450346420322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3ic8kpvraTpTqN9YdsuzYiafauEmk0Qc6BM59RKSgcmmldic5dYqU5BxWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;866&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 ConfigProvider 和各种组件（这里是 Space）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4363459669582119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3MHsICMBX8IvH2BMq2o0sX5BDMaFfszV3MmdxFr0dibuKVbqptEfJdUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有刚讲过的 Space 和 Item。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们能用 props 传数据么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不能，因为不知道隔几层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 antd 里基本都是用 cotnext 传数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会你在 antd 里会见到大量的用 createCotnext 创建 context，通过 Provider 修改 context 值，通过 Consumer 或者 useContext 读取 context 值的这类逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来测试下自己实现的这个 Space 组件吧：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; Space &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./space&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&#x27;./SpaceTest.css&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { ConfigContext, defaultGetPrefixCls,  } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./space/config-provider&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; SpaceTest = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;ConfigContext.Provider&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;getPrefixCls:&lt;/span&gt; &lt;span&gt;defaultGetPrefixCls&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;space:&lt;/span&gt; { &lt;span&gt;size:&lt;/span&gt; &#x27;&lt;span&gt;large&lt;/span&gt;&#x27;}&lt;br/&gt;    }&lt;br/&gt;  }&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Space&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;direction&lt;/span&gt;=&lt;span&gt;&quot;horizontal&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;align&lt;/span&gt;=&lt;span&gt;&quot;end&quot;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{height:&lt;/span&gt;&#x27;200px&#x27;}}&lt;br/&gt;      &lt;span&gt;split&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{background:&lt;/span&gt; &#x27;red&#x27;}}&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;} &lt;br/&gt;      wrap={true}&lt;br/&gt;    &amp;gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Space&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Space&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;direction&lt;/span&gt;=&lt;span&gt;&quot;horizontal&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;align&lt;/span&gt;=&lt;span&gt;&quot;end&quot;&lt;/span&gt; &lt;br/&gt;      &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{height:&lt;/span&gt;&#x27;200px&#x27;}}&lt;br/&gt;      &lt;span&gt;split&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt; &lt;span&gt;style&lt;/span&gt;=&lt;span&gt;{{background:&lt;/span&gt; &#x27;red&#x27;}}&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;} &lt;br/&gt;      wrap={true}&lt;br/&gt;    &amp;gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;Space&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;ConfigContext.Provider&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; SpaceTest;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分不咋用解释了。就是 ConfigProvider 包裹了俩 Space 组件，这俩 Space 组件没设置 size 值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置了 direction、align、split、wrap 等参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;渲染结果是对的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9743589743589743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YprkEU0TtGia0XOtYJf4I0mfN5OyDWUn3ibchXbbicMJH9qc4zVBVUKFkWzXHUYAdmqmWNe7aUYToS3w9YZz0vSSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，我们自己实现了 antd 的 Space 组件！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码在 github：https://github.com/QuarkGluonPlasma/my-antd-test&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一直写业务代码，可能很少写一些复杂的组件，而 antd 里就有很多复杂组件，我们挑 Space 组件来写了下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个布局组件，可以通过参数设置水平、竖直间距、对齐方式、分割线部分等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现这个组件的时候，我们用到了很多东西：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用 React.Children.forEach 的 api 来修改每个 childNode。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 useContext 读取 ConfigContext、SpaceContext 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 createContext 创建 SpaceContext，并用 Provider 修改其中的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 useMemo 来避免没必要的渲染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用 classnames 包来根据 props 动态生成 className&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己封装了一个检测样式是否支持的自定义 hook&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多同学不会封装布局组件，其实就是对整体和每个 item 都包裹一层，分别设置不同的 class，实现不同的间距等的设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想一下，这些东西以后写业务组件是不是也可以用上呢？&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>