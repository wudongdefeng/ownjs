<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>332efcb6ce38c30b8cdc09db8e1c367d</guid>
<title>一文带你彻底加强夯实底层原理之GC垃圾回收技术的分析指南（GC原理透析）</title>
<link>https://toutiao.io/k/rk24wbw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h2&gt;&lt;a id=&quot;_0&quot;/&gt;前提介绍&lt;/h2&gt; 
&lt;p&gt;很多小伙伴，都跟我反馈，说自己总是对JVM这一块的学习和认识不够扎实也不够成熟，因为JVM的一些特性以及运作机制总是混淆以及不确定，导致面试和工作实战中出现了很多的纰漏和短板，解决广大小伙伴痛点，我写了本篇文章，希望可以帮助大家夯实基础和锻造JVM技术功底。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;GC_4&quot;/&gt;什么是垃圾收集（GC)&lt;/h2&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;在JVM领域中GC（Garbage Collection）翻译为 “垃圾收集“，Garbage Collector翻译为 “垃圾收集器”&lt;/strong&gt;。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h2&gt;&lt;a id=&quot;Generational_Model_8&quot;/&gt;分代模型(Generational Model)&lt;/h2&gt; 
&lt;p&gt;我们都知道在JVM中，执行垃圾收集需要停止整个应用（STW）。对象越多则收集所有垃圾消耗的时间就越长。程序中的大多数可回收的内存可归为两类:&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;大部分对象很快就不再使用&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;还有一部分不会立即无用，但也不会持续(太)长时间&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;这形成了分代数据模型。基于这一结构, VM中的内存被分为年轻代(Young Generation)和老年代(Old Generation)，老年代有时候也称为年老区(Tenured)。如下所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5b883331f2c0540e7787bff480a559a3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;从上图可以看出拆分为这样两个可清理的单独区域，允许采用不同的算法来大幅提高GC的性能。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_21&quot;/&gt;分代模型出现问题&lt;/h3&gt; 
&lt;p&gt;在不同分代中的对象可能会互相引用, 在收集某一个分代时就会成为 “事实上的” GC root。当然，要着重强调的是，分代假设并不适用于所有程序。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_25&quot;/&gt;分代模型适合场景&lt;/h3&gt; 
&lt;p&gt;GC算法专门针对“总体生命周期较短”，“总体生命周期较长” 这类特征的对象来进行优化, JVM对收集那种存活时间半长不长的对象就显得非常尴尬了，如下图对象分布。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/d2eab11ca677fdf31811f7a1b8b08d4e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;堆内存中的内存池划分也是类似的。不太容易理解的地方在于各个内存池中的垃圾收集是如何运行的。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cb0be34c78434603e0ced4f25995c9bb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Eden_35&quot;/&gt;新生代(Eden,伊甸园)&lt;/h4&gt; 
&lt;p&gt;Eden是内存中的一个区域， 用来分配新创建的对象。通常会有多个线程同时创建多个对象，所以Eden区被划分为多个线程本地分配缓冲区(Thread Local Allocation Buffer, 简称TLAB)。通过这种缓冲区划分，大部分对象直接由JVM 在对应线程的TLAB中分配, 避免与其他线程的同步操作。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5c1e30c8a14c07d83be17ee74137985c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;如果 TLAB 中没有足够的内存空间, 就会在共享Eden区(shared Eden space)之中分配。如果共享Eden区也没有足够的空间, 就会触发一次 年轻代GC 来释放内存空间。如果GC之后 Eden 区依然没有足够的空闲内存区域, 则对象就会被分配到老年代空间(Old Generation)。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/c1fc909e877b7406842ec91e77cd68f6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;当Eden区进行垃圾收集时，GC将所有从root可达的对象过一遍, 并标记为存活对象。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b0123054f1d12fb0c91a23566f953d57.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;对象间可能会有跨代的引用，所以需要一种方法来标记从其他分代中指向Eden的所有引用。这样做又会遭遇各个分代之间一遍又一遍的引用。JVM在实现时采用了卡片标记(card-marking)。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;_51&quot;/&gt;卡片标记&lt;/h5&gt; 
&lt;p&gt;JVM只需要记住Eden区中 “脏”对象的粗略位置，可能有老年代的对象引用指向这部分区间。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Survivor_Spaces_55&quot;/&gt;存活区(Survivor Spaces)&lt;/h4&gt; 
&lt;p&gt;Eden区的旁边是两个存活区, 称为 from 空间和 to 空间。需要着重强调的的是, 任意时刻总有一个存活区是空的(empty)。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/74929ba76bac7a15a21b196e582075fa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;空的那个存活区用于在下一次年轻代GC时存放收集的对象。年轻代中所有的存活对象(包括Edenq区和非空的那个 “from” 存活区)都会被复制到 ”to“ 存活区。GC过程完成后, ”to“ 区有对象,而 ‘from’ 区里没有对象。两者的角色进行正好切换 。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/22985e27f15bf8e4e3088f8994d98c2f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;存活的对象会在两个存活区之间复制多次，直到某些对象的存活时间达到一定的阀值。分代理论假设, 存活超过一定时间的对象很可能会继续存活更长时间。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/78d8d1c57f227cbf7e0cf9c7ab84fc1d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;这类“ 年老” 的对象因此被提升(promoted )到老年代。提升的时候， 存活区的对象不再是复制到另一个存活区,而是迁移到老年代, 并在老年代一直驻留, 直到变为不可达对象。&lt;/p&gt; 
&lt;p&gt;此外GC会跟踪记录每个存活区对象存活的次数，每次分代GC完成后，存活对象的年龄就会+1。当年龄超过提升阈值(tenuring threshold)，就会被提升到老年代区域。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MaxTenuringThreshold_73&quot;/&gt;MaxTenuringThreshold的判定&lt;/h5&gt; 
&lt;p&gt;具体的提升阈值由JVM动态调整,但也可以用参数 &lt;code&gt;-XX:+MaxTenuringThreshold&lt;/code&gt;来指定上限。如果设置 &lt;code&gt;-XX:+MaxTenuringThreshold=0&lt;/code&gt; , 则GC时存活对象不在存活区之间复制，直接提升到老年代。现代 JVM 中这个阈值默认设置为15个GC周期。这也是HotSpot中的最大值。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Old_Generation_77&quot;/&gt;老年代(Old Generation)&lt;/h4&gt; 
&lt;p&gt;老年代内存空间一般情况下，里面的对象是垃圾的概率也更小。&lt;/p&gt; 
&lt;p&gt;老年代GC发生的频率比年轻代小很多。同时, 因为预期老年代中的对象大部分是存活的, 所以不再使用标记和复制(Mark and Copy)算法。而是采用移动对象的方式来实现最小化内存碎片。老年代空间的清理算法通常是建立在不同的基础上的。原则上,会执行以下这些步骤:&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt;通过标志位(marked bit),标记所有通过 GC roots 可达的对象.&lt;/li&gt;&lt;li&gt;删除所有不可达对象&lt;/li&gt;&lt;li&gt;整理老年代空间中的内容，方法是将所有的存活对象复制,从老年代空间开始的地方,依次存放。&lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;通过上面的描述可知, 老年代GC必须明确地进行整理,以避免内存碎片过多。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;PermGen_89&quot;/&gt;永久代(PermGen)&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;Java8之前有一个特殊的空间，称为“永久代”(Permanent Generation)。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;它存储元数据(metadata)的地方,比如 class 信息等。此外,这个区域中也保存有其他的数据和信息, 包括内部化的字符串(internalized strings)等等。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/b3503096919038a9eeb20ed07f6e2661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Metaspace_97&quot;/&gt;元数据区(Metaspace)&lt;/h4&gt; 
&lt;p&gt;Java 8直接删除了永久代(Permanent Generation)，改用Metaspace。将静态变量和字符串常量都放到其中。像类定义(class definitions)之类的信息会被加载到Metaspace 中。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/63a8463bf3eb527599bb9e6fba3e7059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;元数据区位于本地内存(native memory)，不再影响到普通的Java对象。默认情况下, Metaspace的大小只受限于Java进程可用的本地内存。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_105&quot;/&gt;常见的垃圾回收思想的误区&lt;/h3&gt; 
&lt;p&gt;在我们的日常生活中垃圾收集主要就是找到垃圾并进行清理，这与我们JVM的运作机制恰恰相反，JVM中的垃圾收集器跟踪和标记所有正在使用的对象，并把其余部分的对象当做垃圾对象。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;所以这里一定要区分清楚，我们这里的标记：是指&lt;strong&gt;标记可用对象，而不是垃圾对象&lt;/strong&gt;。常常会有人吧这两者理解错误和混乱。&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;记住这一点以后，我们再深入讲解内存自动回收的原理，探究JVM中垃圾收集的具体实现。先从基础开始, 介绍垃圾收集的一般特征、核心概念以及实现算法。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_113&quot;/&gt;常见的垃圾回收类型&lt;/h3&gt; 
&lt;p&gt;垃圾回收类型主要是通过回收的范围进行界定和划分。具体的JVM回收区域如下图所示。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Java8_117&quot;/&gt;Java8之前&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/44190f13591d80bda1b79d6f218ffe88.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Java8_121&quot;/&gt;Java8之后&lt;/h4&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/8f34a62b21efa1f283a72b89af66e953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;垃圾收集（Garbage Collection）通常分为：Minor GC - Major GC - Full GC 。接下来介绍这些事件及其区别，然后你会发现这些区别也不是特别清晰。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;Minor GC：年轻代垃圾回收机制，属于轻量级GC，主要面向于年轻代区域的垃圾对象进行回收。&lt;/li&gt;&lt;li&gt;Major GC：老年代垃圾回收机制，属于重量级GC，主要面向于老年代区域的垃圾对象进行回收。&lt;/li&gt;&lt;li&gt;Full GC：完全化GC，属于全量极GC，大致角度而言&lt;strong&gt;Major GC&lt;/strong&gt;和&lt;strong&gt;Full GC&lt;/strong&gt;差不多，其实具体分析，FullGC的范围是面向于整体的Heap堆内存。&lt;/li&gt;&lt;/ul&gt; 
&lt;h2&gt;&lt;a id=&quot;GCGC_BenefitsCost_131&quot;/&gt;GC的优点和缺点（GC Benefits/Cost）&lt;/h2&gt; 
&lt;h3&gt;&lt;a id=&quot;_133&quot;/&gt;好处&lt;/h3&gt; 
&lt;ol&gt;&lt;li&gt;提高系统的可靠性和稳定性&lt;/li&gt;&lt;li&gt;内存管理与程序设计的解耦&lt;/li&gt;&lt;li&gt;调试内存错误所花费的时间更少&lt;/li&gt;&lt;li&gt;悬挂程序点/内存泄漏不会发生&lt;/li&gt;&lt;/ol&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;注意：Java程序没有内存泄漏；“不意味着对象存储地址”更准确）&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;h4&gt;&lt;a id=&quot;_142&quot;/&gt;坏处&lt;/h4&gt; 
 
&lt;h4&gt;&lt;a id=&quot;Minor_GC_147&quot;/&gt;Minor GC&lt;/h4&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;年轻代内存的垃圾收集称为Minor GC。那什么时候会触发MinorG以及出发MinorGC得我条件是什么？&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/bacb722b6107ab3070c5c79431bd6209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_153&quot;/&gt;触发MinorGC的时机&lt;/h5&gt; 
&lt;p&gt;当JVM无法为新对象分配Eden区的内存空间时/达到了Eden存放阈值的时候会触发 Minor GC，所以新对象分配频率越高，Minor GC的频率就越高。并且Minor GC每次都会引起全线停顿(stop-the-world )，暂停所有的应用线程，对大多数程序而言,暂停时长基本上是可以忽略不计的。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_157&quot;/&gt;MinorGC回收的瓶颈&lt;/h5&gt; 
&lt;p&gt;Eden区的对象基本上都是垃圾，也不怎么复制到Survior区/老年代。如果情况不是这样, 大部分新创建的对象不能被垃圾回收清理掉，则 Minor GC的停顿就会持续更长的时间。&lt;/p&gt; 
&lt;h5&gt;&lt;a id=&quot;MinorGC_161&quot;/&gt;MinorGC回收的范围&lt;/h5&gt; 
&lt;p&gt;Minor GC实际上忽略了老年代，主要面向的对象范围有两部分组成：&lt;/p&gt; 
&lt;ol&gt;&lt;li&gt; &lt;p&gt;主要是面向于老年代到年轻代的所引用的对象范围，例如，它会将从老年代指向年轻代的引用都被认为是GC Root，&lt;strong&gt;（而从年轻代指向老年代的引用在标记阶段全部被忽略）&lt;/strong&gt;。&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;&lt;strong&gt;主要面向的是Survior区之间的相互引用，此种场景的生命周期较短，属于年轻代之内的对象之间的引用关系。&lt;/strong&gt;&lt;/p&gt; &lt;/li&gt;&lt;/ol&gt; 
&lt;p&gt;所以，Minor GC的定义很简单、清理的就是年轻代，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/786ae73319e5064720ebc36a2e3a3713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Major_GC_vs_Full_GC_173&quot;/&gt;Major GC vs Full GC&lt;/h4&gt; 
&lt;p&gt;从上面我们知道了Minor GC清理的是年轻代空间(Young space)，相应的其他区域也有对应的回收机制和策略。&lt;/p&gt; 
 
&lt;h4&gt;&lt;a id=&quot;Minor_GCMajorGCFullGC_181&quot;/&gt;Minor GC、MajorGC和FullGC执行效果&lt;/h4&gt; 
&lt;p&gt;大部分情况下，发生在年轻代的Minor GC次数会很多，会引起STW，也就是全局化暂停执行业务线程的行为，但是时间很短（几乎可以忽略不计）。而Major GC和Full GC也会造成全局化暂停的效果。所以一般情况下尽可能减少MajorGC和FullGC是什么必要的，但是也不能“一棒子打死一船人”。必要的时候还是需要触发少量几次Major GC以及FullGC，进而释放一些RSS常驻内存。&lt;/p&gt; 
&lt;h2&gt;&lt;a id=&quot;GC_185&quot;/&gt;垃圾收集(GC)的原理&lt;/h2&gt; 
&lt;h3&gt;&lt;a id=&quot;Automated_Memory_Management_187&quot;/&gt;自动内存管理(Automated Memory Management)&lt;/h3&gt; 
&lt;p&gt;如果要显式地声明什么时候需要进行内存管理，实现自动进行收集垃圾，那样就太方便了，开发者不再耗费脑细胞去考虑要在何处进行内存清理。运行时环境会自动算出哪些内存不再使用，并将其释放，历史上第一款垃圾收集器是1959年为Lisp语言开发的。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Reference_Counting_191&quot;/&gt;引用计数(Reference Counting)&lt;/h4&gt; 
&lt;p&gt;共享指针方式的引用计数法， 可以应用到所有对象。许多语言都采用这种方法，包括 Perl、Python 和 PHP 等。下图很好地展示了这种方式：&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7352d93e8848363eaa1bad57b0662304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;p&gt;上图中所展示的GC ROOTS，表示程序正在使用的对象。主要（&lt;strong&gt;这里指的不是全部&lt;/strong&gt;）集中在于当前正在执行的方法中的局部变量或者是静态变量等。在这里主要我指的是Java。&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;蓝色的圆圈表示可以引用到的对象，里面的数字就是被引用计数器&lt;/strong&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;灰色的圆圈是各个作用域都不再引用的对象，可以被认为是垃圾，随时会被垃圾收集器清理。&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;detached_cycle_202&quot;/&gt;循环引用（detached cycle）的问题&lt;/h5&gt; 
&lt;p&gt;引用计数器无法针对于循环引用这种场景进行正确的处理和探测。任何作用域中都没有引用指向这些对象，但由于循环引用, 导致引用计数一直大于零，如下图所示。&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/f26c7fceb0bc9760e02565e488f98f94.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt;红色线路和红色圆圈对象实际上属于垃圾引用以及垃圾对象，但由于引用计数的局限，所以存在内存泄漏，永远都无法进行回收该区域的对象内存。&lt;/li&gt;&lt;/ul&gt; 
&lt;h5&gt;&lt;a id=&quot;detached_cycle_210&quot;/&gt;循环引用（detached cycle）的解决方案&lt;/h5&gt; 
&lt;p&gt;比如说可以针对于一些这种循环模式进行加入到 “弱引用”(‘weak’ references)的体系中，所以即使无法进行解决循环引用计数的场景，也可以通过弱引用实现内存回收。&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;精华推荐 | 【JVM深层系列】「GC底层调优系列」一文带你彻底加强夯实底层原理之GC垃圾回收技术的分析指南（GC算法分析）&lt;/p&gt; 
&lt;/blockquote&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c4f079334f13526fa614f6d95b36c20</guid>
<title>田螺哥的MySQL专栏！25篇，真香！</title>
<link>https://toutiao.io/k/w5t80m1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;捡田螺的小男孩&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;gh_51e0e901a289&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;专注后端技术栈，热爱分享，热爱交朋友，热爱工作总结。毕业于华南理工大学，软件工程专业~&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b512397cfdc658eb8dc7aa0a58cd4599</guid>
<title>定制一个 Vue 3 模板 - 集成 Vite, Pinia, Vue Router 与 Tailwind CSS</title>
<link>https://toutiao.io/k/585o10o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不久前，我意识到我正在用一些重复使用的后台基础模板，浪费了我一些摸鱼时间，我突然想到--为什么不把这些可重复使用的部分重新利用起来，把它们简单地堆在一个模板里呢？🤔&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;技术栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个后台模板中，用到了如下的框架或库：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Vite&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Pinia&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Router&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tailwind CSS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vite SVG loader&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始之前，首先要安装 Node.js，这个自行百度解决。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;快速入门 - Vue, Router &amp;amp; Store&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先从初始化模板开始：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm init vue@latest&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着输入项目名称 &lt;code&gt;vue3-boilerplate&lt;/code&gt;，然后在功能提示中选择安装 &lt;code&gt;Pinia&lt;/code&gt;和 &lt;code&gt;Vue Router&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;✔ Project name: vue3-boilerplate&lt;br/&gt;...&lt;br/&gt;✔ Add Vue Router &lt;span&gt;for&lt;/span&gt; Single Page Application development? Yes&lt;br/&gt;✔ Add Pinia &lt;span&gt;for&lt;/span&gt; state management? Yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据提示，选择所需功能后，执行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cd&lt;/span&gt; vue3-boilerplate&lt;br/&gt;npm install&lt;br/&gt;npm run dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行后在本地开发环境中查看 &lt;code&gt;http://127.0.0.1:5173&lt;/code&gt; 此示例页面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5628415300546448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wIDSOebZK4MfldLrvTZibMe789ibZAqYibcZwFibfJjBs1x2amfxdpuFl7TyzQwiaBibrHPv6y8Nhw8HOrHmeA6jnibzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加 Tailwind CSS&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了基础后，现在我们需要一些样式。按照这个指南，我们安装Tailwind CSS，然后初始化配置文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install -D tailwindcss postcss autoprefixer&lt;br/&gt;npx tailwindcss init -p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完后，在根目录中，会有一个 &lt;code&gt;tailwind.config.js&lt;/code&gt;文件，填充内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/** @&lt;span&gt;type&lt;/span&gt; {import(&lt;span&gt;&#x27;tailwindcss&#x27;&lt;/span&gt;).Config} */&lt;br/&gt;module.exports = {&lt;br/&gt;  content: [&lt;span&gt;&quot;./index.html&quot;&lt;/span&gt;, &lt;span&gt;&quot;./src/**/*.{vue,js,ts,jsx,tsx}&quot;&lt;/span&gt;],&lt;br/&gt;  theme: {&lt;br/&gt;    extend: {},&lt;br/&gt;  },&lt;br/&gt;  plugins: [],&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们需要加载 &lt;code&gt;@tailwind&lt;/code&gt; 指令，所以在 &lt;code&gt;/src/assets&lt;/code&gt; 文件夹中创建&lt;code&gt;tailwind.css&lt;/code&gt;，其中包含以下内容(指令):&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@tailwind base;&lt;br/&gt;@tailwind components;&lt;br/&gt;@tailwind utilities;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;/src/assets/main.css&lt;/code&gt; 顶部导入它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@import &lt;span&gt;&quot;./tailwind.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们已经在 &lt;code&gt;/src/main.js&lt;/code&gt; 中导入了 &lt;code&gt;/src/assets/main.css&lt;/code&gt; 文件，所以，现在就可以在项目中使用 Tailwind 的实用类了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在 &lt;code&gt;/src/views/AboutView.vue&lt;/code&gt; 中的 &lt;code&gt;h1&lt;/code&gt; 标签添加一些实用类来测试一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;  &amp;lt;div class=&lt;span&gt;&quot;about&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;h1 class=&lt;span&gt;&quot;text-xl font-medium text-white&quot;&lt;/span&gt;&amp;gt;This is an about page&amp;lt;/h1&amp;gt;&lt;br/&gt;  &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在下面单独定义我们的CSS属性。要做到这一点，需要安装这个PostCSS插件 - &lt;code&gt;postcss-import&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install -D postcss-import&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，在实用类中使用 &lt;code&gt;@apply&lt;/code&gt;:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;style lang=&lt;span&gt;&quot;scss&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;.about {&lt;br/&gt;  @apply lg:min-h-screen lg:flex lg:items-center;&lt;br/&gt;  h1 {&lt;br/&gt;    @apply text-xl font-medium text-white;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;添加 SVG loader （可选）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我比较喜欢SVG，🥁恰好，我们新的模板可以很容易地导入SVG图像，但有一个问题--我们必须把它作为组件使用，这意味着需要手动在模板标签中添加SVG代码，然后像这样导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，有这样一个 vit-svg-loader 包，它基本上可以让我们在Vue模板中简单地导入 &lt;code&gt;.svg&lt;/code&gt; 文件作为组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，安装它：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install vite-svg-loader --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;vite.config.js&lt;/code&gt; 配置文件中添加这个插件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import svgLoader from &lt;span&gt;&#x27;vite-svg-loader&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default defineConfig({&lt;br/&gt;   plugins: [vue(), svgLoader()],&lt;br/&gt;   ...&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，为了测试，把&lt;code&gt;/src/assets/logo.svg&lt;/code&gt; 中的 Vue logo 代码改成这个，然后保存:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;svg xmlns=&lt;span&gt;&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt; xmlns:xlink=&lt;span&gt;&quot;http://www.w3.org/1999/xlink&quot;&lt;/span&gt; viewBox=&lt;span&gt;&quot;0 0 2454.32 2457.41&quot;&lt;/span&gt;&amp;gt;&amp;lt;defs&amp;gt;&amp;lt;linearGradient id=&lt;span&gt;&quot;a&quot;&lt;/span&gt; x1=&lt;span&gt;&quot;285.11&quot;&lt;/span&gt; y1=&lt;span&gt;&quot;1790.44&quot;&lt;/span&gt; x2=&lt;span&gt;&quot;285.7&quot;&lt;/span&gt; y2=&lt;span&gt;&quot;1789.74&quot;&lt;/span&gt; gradientTransform=&lt;span&gt;&quot;matrix(2454.32, 0, 0, -2187.24, -699180.9, 3916163.49)&quot;&lt;/span&gt; gradientUnits=&lt;span&gt;&quot;userSpaceOnUse&quot;&lt;/span&gt;&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#41d1ff&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;1&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#bd34fe&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/linearGradient&amp;gt;&amp;lt;linearGradient id=&lt;span&gt;&quot;b&quot;&lt;/span&gt; x1=&lt;span&gt;&quot;285.22&quot;&lt;/span&gt; y1=&lt;span&gt;&quot;1790.33&quot;&lt;/span&gt; x2=&lt;span&gt;&quot;285.29&quot;&lt;/span&gt; y2=&lt;span&gt;&quot;1789.46&quot;&lt;/span&gt; gradientTransform=&lt;span&gt;&quot;matrix(1125.42, 0, 0, -2051.66, -319596.68, 3673197.31)&quot;&lt;/span&gt; gradientUnits=&lt;span&gt;&quot;userSpaceOnUse&quot;&lt;/span&gt;&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffea83&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;0.08&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffdd35&quot;&lt;/span&gt;/&amp;gt;&amp;lt;stop offset=&lt;span&gt;&quot;1&quot;&lt;/span&gt; stop-color=&lt;span&gt;&quot;#ffa800&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/linearGradient&amp;gt;&amp;lt;/defs&amp;gt;&amp;lt;path d=&lt;span&gt;&quot;M2464.14,381.6,1311.22,2443.21c-23.8,42.57-85,42.82-109.12.46L26.33,381.79C0,335.63,39.47,279.72,91.78,289.08L1245.93,495.37a62.88,62.88,0,0,0,22.27,0l1130-206C2450.35,279.87,2490,335.35,2464.14,381.6Z&quot;&lt;/span&gt; transform=&lt;span&gt;&quot;translate(-17.94 -17.87)&quot;&lt;/span&gt; style=&lt;span&gt;&quot;fill:url(#a)&quot;&lt;/span&gt;/&amp;gt;&amp;lt;path d=&lt;span&gt;&quot;M1795.71,18.48,942.53,185.66a31.33,31.33,0,0,0-25.25,28.9L864.8,1101a31.33,31.33,0,0,0,29.41,33.14,31.77,31.77,0,0,0,8.91-.75l237.54-54.82a31.32,31.32,0,0,1,37.73,36.79l-70.57,345.59a31.33,31.33,0,0,0,39.8,36.24l146.72-44.57a31.34,31.34,0,0,1,39.79,36.32L1222,2031.73c-7,33.95,38.14,52.47,57,23.36l12.59-19.44L1986.77,648.19c11.65-23.23-8.44-49.72-33.94-44.79l-244.52,47.18a31.33,31.33,0,0,1-36-39.44L1831.86,57.91a31.34,31.34,0,0,0-36.14-39.43Z&quot;&lt;/span&gt; transform=&lt;span&gt;&quot;translate(-17.94 -17.87)&quot;&lt;/span&gt; style=&lt;span&gt;&quot;fill:url(#b)&quot;&lt;/span&gt;/&amp;gt;&amp;lt;/svg&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在 &lt;code&gt;/src/App.vue&lt;/code&gt; 文件中，把它作为SVG组件导入，并用&lt;code&gt;&amp;lt;img class=&quot;logo&quot; /&amp;gt;&lt;/code&gt;替换它。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script setup&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;   import LogoSVG from &lt;span&gt;&#x27;./assets/logo.svg?component&#x27;&lt;/span&gt;&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;template&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;   &amp;lt;LogoSVG alt=&lt;span&gt;&quot;Vite logo&quot;&lt;/span&gt; class=&lt;span&gt;&quot;logo&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;   ...&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，一个简单的模板框架就搭建完啦。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;下一步是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以将它，发布到 npm 上，然后可以类似的命令安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i @richardecom/vue3-boilerplate&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面还有份清单，你可以选择性添加进去：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;NuxtJS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Meta&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VeeValidate&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Vue Toastification&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;Mzg2NjY2NTcyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/TZL4BdZpLdjaCTEjQdxnaIlEWiaGcw9zNV7AHZGgp5q9U0zPf3cmcIgBRYG1n2ydEBHJGgl8nEA1bKiaj1fibK2EA/0?wx_fmt=png&quot; data-nickname=&quot;前端之神&quot; data-alias=&quot;Sunshine_Lin_God&quot; data-signature=&quot;一位前端小菜鸡，写过100多篇原创文章，全网有5w+个前端朋友，梦想是成为”前端之神“~&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26571307858daffc42ddaa94d87b4127</guid>
<title>Nephoo扩展Kubernetes解决云原生自动化</title>
<link>https://toutiao.io/k/4nrgtwd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-1g0fqss&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-first-child=&quot;&quot; data-pid=&quot;IMJupOYP&quot;&gt;Nephio项目由Linux基金会于2022年启动，该基金会与谷歌和一系列电信运营商、解决方案供应商和集成商一起，着手构建一个统一平台，使用Kubernetes为大规模5G电信网络部署提供意图驱动的云原生自动化。&lt;/p&gt;&lt;p data-pid=&quot;V9R_YzZi&quot;&gt;Nephoo社区的驱动力是在容器和虚拟机的大规模部署中，云原生自动化尚未完全实现。采用完全云原生堆栈仍然需要在资本和运营投资方面做出努力，而且对于采用者来说，结果并非100%完美。&lt;/p&gt;&lt;p data-pid=&quot;RSWIgwe0&quot;&gt;目前，Kubernetes的部署正在促进容器的带外自动化。Nephoo使Kubernetes能够：&lt;/p&gt;&lt;p data-pid=&quot;OC93nAXK&quot;&gt;——在其上部署云基础设施和网络功能，无需带外管理。&lt;/p&gt;&lt;p data-pid=&quot;QcXIahwH&quot;&gt;——管理其自身的基础设施和网络功能的配置，减少对外部编排的需求。&lt;/p&gt;&lt;p data-pid=&quot;ZUli5G1v&quot;&gt;Nephoo首先对Kubernetes的部署和配置进行了调整。我们知道，对于大型或电信网络，Kubernetes非常适合充当统一和自动化的控制平面，以配置可能分布的每个基础设施的所有方面和主机网络功能。&lt;/p&gt;&lt;p data-pid=&quot;P1D0sYqZ&quot;&gt;但据观察，Kubernetes并没有被用来自动执行云原生功能（CNF）和VNF。除了托管CNFs和VNFs（虚拟网络功能）之外，Nephoo架构还将在自动化方面使用Kubernetes。&lt;/p&gt;&lt;p data-pid=&quot;yGHCqxmS&quot;&gt;典型的大型电信网络涉及来自多个供应商和不同网络管理标准的网络功能。但是，如果我们从不同的供应商那里实现配置，并比较一个网络功能或云基础设施，情况就不一样了。例如，有O-RAN（开放无线接入网络）或3GPP等标准，但部署的配置有所不同。&lt;/p&gt;&lt;p data-pid=&quot;QTvZU_eh&quot;&gt;为了自动化供应，Nephoo将Kubernetes的声明性、主动协调的方法与机器可操作的配置相结合。它是声明性的，因为配置将作为基础设施自协调的意图提供，直到其达到预期状态（从观察到的状态进行检查）。&lt;/p&gt;&lt;p data-pid=&quot;HDElwEJ7&quot;&gt;此时，大多数现代基础设施管理员都在使用Helm图表进行复杂的Kubernetes工作负载部署和配置，但使用它们仍然很复杂。Helm图表是数千个嵌套的YAML模板文件。使用Helm图表的缺点是它会产生有条件生成的配置输出。&lt;/p&gt;&lt;p data-pid=&quot;BMvX_Fnr&quot;&gt;在Helm图表中，基于意图的连续协调是不可能实现的，因为它会生成带有条件的配置。对于Nepho，这种方法将被CRD（自定义资源定义）所取代。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;459&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;620&quot; data-rawheight=&quot;459&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-26603e4402ba1c830457f910dc5777de_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;JFKY7W8C&quot;&gt;为了解决大规模Kubernetes环境中的配置问题，Nephoo将为不同的网络功能生成CRD和operator，以管理生命周期和配置。此外，随Helm提供的基础设施即代码（IaaC）将被配置即数据（CaD）取代。这些将部署在公共和私有云基础设施中，以实现自动化。CRD和operator的实施将符合3GPP、ORAN、O2等标准。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p data-pid=&quot;TZkjS719&quot;&gt;原文链接：&lt;/p&gt;&lt;p data-pid=&quot;2wrJ2PHo&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//thenewstack.io/nephio-extends-kubernetes-to-solve-cloud-native-automation/&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;thenewstack.io/nephio-e&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;xtends-kubernetes-to-solve-cloud-native-automation/&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b72278e0b8ce11d13c6ab3d18bbf0930</guid>
<title>京东零售基于NLP的风控算法模型构建实践</title>
<link>https://toutiao.io/k/b2zc35t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-id=&quot;21706&quot; data-tools=&quot;小蚂蚁编辑器&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;fb7d2&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;fb7d2&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaf01yMSoia1PNR5mWWdbvTOXRVcO2XpickqjRuZtxR5jibJLSp5NljyIibribCsG0DoibBKU9PeFDpAT9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;本团队主要负责京东零售领域的风控算法模型构建，针对京东零售风控方面，业务要求不断地更新、模型失效快、更新迭代慢以及成本高昂等情况，我们提出了自己设计研发的 NLP 预训练架构模型和用户行为预训练模型，并进行预训练模型的平台化，方便一键部署开发，快速迭代，简单易用，推理速度提升等，有效解决了业务问题，并在公开数据集上也得到了很好的效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文将对我们的一些工作进行介绍，并对未来京东零售风控的发展方向进行展望。主要包括以下几部分：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NLP 预训练&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户行为预训练&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预训练平台化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分享嘉宾｜王三鹏 京东零售 风控算法架构负责人&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;编辑整理｜任文强 xtransfer&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;出品社区｜&lt;/span&gt;DataFun&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先介绍一下京东零售风控的背景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmFFgFEjKUpJ9CU8MotRUMGtcD6Dk70u5hxnjfsCCHOJ3F3uePYCeibmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，京东零售风控的任务是维护京东零售平台健康的交易生态环境，主要包括主站 APP、PC 端等。场景包括 C 端和 B 端两大部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C 端风控主要针对恶意刷券，使用外挂软件获取权益，比如用一些黑客软件抢茅台等，还有一些广告辱骂的内容，比如发小广告、不合规的内容等，以及价格方面的管控等。B 端风控主要是针对商家刷单行为、恶意套利行为，以及客服防骚扰。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmbC0auib2JW7l0tlKibCJb4qbuIvAhZ7ZL48qk2rTML2cOicGSzhLdcUibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如上图所示，零售风控算法能力整体上分为用户行为和文本两大部分。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;用户行为这一块，通过上面提到的场景，算法人员可以将这些场景的数据构建成统计特征、序列行为特征，比如浏览页面等。文本这一块，主要是内容风控，包含舆情，地址异常等场景识别作为基础，以 NLP 的文本特征作为识别的基础。风控领域相对于其他领域的 NLP 场景，其主要的特点是异音异形字的识别，比如加微信，如上图中所示，通过一些异形字体，+薇信，躲避文本的风控检测。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以上两大场景，存在以下几个问题：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，失效快，比如广告引流场景，模型很快就会有效果衰减，具体原因就是恶意攻击者，会反复尝试不同的字体和形式，用以破解算法模型，从而达到自己的目的，导致模型失效或者效果下降。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二，针对新的业务场景，需要大量的人工标注数据，人工标注的成本会非常高，而且耗时比较长。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三，建模的效率低，效果差，因为首先要做特征，特征完之后，再预训练模型，整个链条拉得非常长，等到模型做好之后，业务方可能不需要这个模型了，或是效果不能达到预期，有的模型效果要求准确率达到接近 100%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;针对这三个问题，我们做了一些思考研究。针对失效快的问题，是否可以建立一个长期有效的机制来解决；针对需要人工标注大量数据这个问题，是否可以建立一个小样本学习能力的模型，不需要标注那么多的标签数据，使用无监督的方式进行训练；针对建模效率低、效果差等，是否可建立一个特征，模型平台化自动生成的机制，使预训练模型和大模型更好地发挥作用，快速建模和生成模型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于以上思考，我们依赖于预训练技术，做了一些改进优化。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;NLP 预训练&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmhS2AKO828JyVoPpicQZAOupWGTh168FMe3pjh9Pfia8j4uVurcVgNTjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，NLP 是风控内容、舆情、地址等风控能力的基础，而且，近年来，&lt;strong&gt;预训练技术是处理 NLP 的最常用的方式。整体的流程如上图所示：首先数据采集，然后进行模型预训练，最后对模型进行微调。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmI8MwCA2WhPCu5QM9LJLmyuqF4l2ticIEtIVQbSCrpLia91WxuIYFk0wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，本团队也尝试在开源 Bert 上进行微调训练，发现效果很差，主要原因有三：第一，公开数据集覆盖的是普通文本，不是风控领域的数据，所以，收敛效果很差；第二，开源的数据集上没有生僻字等情况，导致训练出的模型容易失效，因为风控领域有很多的生僻字；第三，在小样本的训练集上效果不好。整体而言，就是数据偏差，即没有风控领域的数据进行训练，导致开源 bert 的效果无法发挥出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;首先，常见的 bert 改进分为三个方面：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一，数据方面，主要通过采用更多的数据集，或者有效数据的清洗策略；以及针对特殊领域引入领域内的数据，包括引入其他嵌入模型等，比如 Chinese-Bert,Ernie-T 等模型。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二，改变训练任务，从而提高模型的泛化能力。主体上的改进方向有以下几种：删减 NSP 预训练任务，比如 Roberta；基于实体的掩码语言模型，比如 BERT-wwm 等；以及引入其他有效的预训练任务等，比如 ERNIE 等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三，其他的应用方向，比如一些跨语言模型，跨模态模型等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;结合以上问题，以及常用的 BERT 改进方向，本团队设计出一个适用于风控领域的自适应模型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmA8cO1O4wbHB2l8tgUoctplbf9tIbqmOOZM4mMhdibIOR5BIHR0bVKFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，结合调研的情况，本团队在数据和字典这一块，做了风控领域的数据和字典。如上图左图所示，主要是零售领域的业务数据，以及电商领域的数据，为了具有泛化能力，需要社区互动、对话数据以及百度百科等的数据，总共采集了 10 亿条数据；在字典方面，如上图右图所示，增添了异音异形字、电商高频字、生僻字等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmdPRc0WT1N5s4B7v6ibo3UU9yKMburzHiahWOGuUAicosttSkUic4vquSzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如上图所示，&lt;strong&gt;第一步将语料和字典构建好&lt;/strong&gt;，但是，如果仅仅引入生僻字，还是不具备足够的泛化能力， 如果输入换了一批生僻字，还是不能很好的识别，本团队进行充分实验和调研，针对异音异形字，有很多情况是形不一样，但是音一样，比如“+”和“加”，是一个音，所以添加了拼音的编码。另一块就是字形，比如“京东”的“京”，再加一个单人旁，变成“倞”，和“京”很相似，&lt;/span&gt;&lt;span&gt;所以也引入了字形的编码，从而提高对异音异形字的识别。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmPZ57radGVef3cOmTM1Xb91axBys92LgueickolmmSOcEFNIRMjylPPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;接下来，针对任务调度进行规划&lt;/strong&gt;。引入任务调度，主要是为了解决不同的业务场景，比如评论、舆情、地址、咨询、直播等十几个场景效果不均衡的问题。如上图左图所示，是本团队调研的开源的解决方案。方案1主要是通过多任务的学习方式进行学习，所以，会导致不同任务的收敛程度不一致；方案2是通过持续学习，但是，但是，比如 task1 已经学习的非常好了，但因为后面的 task 并没有训练好，共享的BERT部分的参数还是会不断的调整，可能会破坏 task1 已经学到的特征；方案3是结合了方案1和方案2，有一定的优化，但是，task 的难易程度是人为定义的，具有很大的主观性，而且，也还是会存在 task1过度训练的情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;针对前面几个方案的分析，本团队提出了上图右图的方案，构建内循环可持续学习任务调度方案。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，针对不同的任务进行分组，然后在训练过程中，感知到不同的组的训练情况，比如某一个 task 的效果变差，即针对性的去训练这个组，从而提升模型的能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmqAKgpTmiacic29DPQo10z0nw0BCHVa1Mu2Wyu5vzbkazVN7E3kiavPA4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;接下来，如上图所示，是本团队针对训练加速的方案设计。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;如果按照传统的训练方式，从头训练一个亿级的规模模型需要十几天的时间，如果是 T5 模型需要几十天，耗时过长。本团队基于京东自己的架构，并对数据和模型进行改进。首先，使用 ZeRO 的框架，可以在不影响通信效率的情况下，让模型的内存均匀的分配到每个 GPU 上，减少单个 GPU 的显存个，提高并行效率。其次，在操作融合方面，通过将多个操作进行融合，一次执行多个计算逻辑，减少全局内存的访问，有效的提高训练吞吐。最后，基于多源头数据读取能力，充分发挥 A100 显卡潜能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibm8xbeblYv9qGbq2ib08EibxBAttvD8WMn2MS4vndw5C0GWvKibianDCU9AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推理加速方面，因为模型部署主要是实时场景，对时延要求比较高，所以需要对模型进行蒸馏，提高推理速度。基本上使用业界的主流方式，将模型参数压缩 90%，推理速度提升 3 倍，效果接近于原始预训练模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibm7Pw9YtEbBZcr15sJ7naGcc2V5qOicFNdmxJIeFEd44VmhiaBE1lScImQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上图是本团队预训练模型的效果展示。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;因为使用了开源数据集的缘故，所以具有泛化性，在开源的 6 个数据集上，基本上都达到了最好的效果。在内部数据集上，广告识别，以及异常地址识别，有非常明显的提升。在业务指标上，模型更新以及建模速度有了非常大的提升，并且小样本训练的效果有了非常大的提升。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户行为预训练&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmBKd3bv71Ct0gxuze6MN4baNDYiczoyrnAueB0RUJQ3PZQqPKSbN5B6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来介绍用户行为预训练。前面讲到，用户行为是风控能力识别能力的基础，行为模型的深度决定了风控能力的上限。预训练模型使用以前，不同的业务场景，会各自建设一个风控的模型，存在重复性的劳动，而且特征选择不尽相同，各个场景都是从 0 到 1 独立的建模。该方式存在的问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;预训练模型的特点，可以克服以上几个问题，毕竟预训练是站在巨人的肩膀上，底座模型加细分场景微调，可以快速建模；并且效果好，有监督、无监督预训练可以充分挖掘存量标签、数据知识等；&lt;/span&gt;&lt;span&gt;由于特征和模型统一建设，底层具有强支撑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5627208480565371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmBEOJwk3hAyib3sDzG2KiaLr6InYvvDrVibMoqKrEQ74f8HF1FjHGr7UwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2264&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预训练模型主要应用于 NLP 领域和 CV 领域，其他的领域方面，还处于起步阶段。在业界，谷歌和腾讯等有行为预训练在推荐和画像等场景有应用，但是行为预训练在风控领域处于空白状态。风控领域的用户行为特征，主要还是浏览、搜索等序列特征，以及大量手动设计的统计特征。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;326&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5646017699115045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibm3ofC53GXhfmg4sU9EuEYoswSjoXuroWhrOHVd5tKF210puUu5GnjEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2260&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上图展示了用户行为预训练模型的整体算法模型。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，将用户的行为、类别等多模态信息进行融合，通过 Transfermer 将其转化成统一的行为特征，输入到 bert 中进行预训练。总的参数量达到了 5 亿多，表达能力远超 Bert 模型。未来使用预训练模型达到业务目的，本团队也应用了很多对比学习的方法，比如 NSP、MLM、有监督等方法，放到内循环的学习系统里面，使模型充分地学习到数据的知识。下一个阶段，是进行微调。当微调的样本不是很多，由于参数量很大，为了防止微调调偏，需要定制化的操作，比如冻结部分参数等，使模型具有更好的泛化性能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmyh9jL5aMV6ibftJRk8COIpEY9RAPibyicJl85NsORN5NTK5lribF9CxALQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上图是整个用户行为预训练的框架。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;风控的场景有很多，比如恶意订单、刷单等，异常的散乱复杂，而且碎片化，每个场景的准确度、召回率等要求不尽相同，所以需要考虑框架的适用性和泛化性。如上图右边所示，在自动化数据转换过程中，直接将用户的数据封装起来，不同场景的输入，作为参数，输入到数据中，然后输出转换后的行为数据。并且将预训练模型训练过程也进行封装，主要是对微调阶段进行训练处理。在微调阶段，根据自定义模式，对模型进行微调，这样不管业务是几十个，甚至几百个场景，底层的训练是保持不变的，微调阶段可以部署到不同的业务场景。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmxibU27hQPhPe9Py4ScuSu4KCA0pswKb2T9LVXewVjFuL1rg2eiagDvLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;用户行为预训练模型的效果如上图所示。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先在效率方面，建模效率大大提升，周期降低 8 倍以上；其次，在效果上，模型效果长期稳定，鲁棒性非常强，而且在同等精度下，召回率提高一倍以上；在标注样本方面，支持小样本标注数据；在技术和数据沉淀方面，持续做大做强预训练模型，提升风控全场景识别能力。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;04&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;预训练平台化&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;预训练平台化的目的，是为了解决之前存在的问题：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;之前的模型框架的使用，只存在于代码阶段，存在阅读代码费时间、费人力，并且接口混乱，杂乱无章等问题。搭建平台之后，支持一键式使用，方便高效。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmQ4wQSDMfvD9xwibQP5o1sqOSfzeGW0zUksibbWxSxn13ZRicrhthZ9L2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，本团队将 NLP 这块的内容封装到 RiskNLP 包中，非常简单易用，而且功能十分健全，比如支持多种模型类型转化，多任务模型，NER 等复杂的功能，都可以一键式训练出来；并且训练速度，推理速度等，都可以一键式的配置，非常方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmEvkRW1iaGJ7AnVtaqWfWJcfLZiaaaVevd57za6zxmMfIib2azrlgwBOYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;上图是本团队提出的 RiskCDA 工具包，主要是提高异音异形字的对抗能力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。这个工具包，既支持 Python 安装包一键部署，还支持本地线上扩充方式，并且支持自定义词典，最重要的是支持多种基于深度学习的前沿扩充方式，比如 TextFooler 等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmZkjbEicq9loDHNhYppBacG657PLWGhARkGp4Qhzc4kTxF4n2QzuAr8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，如上图，是用户行为预训练模型的工具包——RiskBehavior 包。一键部署使用，与前面包所不同的地方就是这边的特征展出，也是部署成为服务的形式，针对内部需要的特征，都可以进行产出。并且在速度优化方面，也得到了很好地实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;05&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;展望&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625549370055669&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmUiak5YTkuUv8YNibKRGSYpvPQLlHYuIgDcWnpAvr12PEKogM5DiauEK9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3413&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于未来的展望，主要分为以下几个方面：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，预训练模型不能只停留在 NLP 和 CV 领域，可以在更多的领域，比如风控，多模态等特征，容纳更多的数据知识，赋能业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，更强大的模型，包括更大的参数、更强结构模型以及蒸馏能力等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，更强大的易用能力，更加快速便捷地应用到业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四，拥抱开源，将框架，以及数据和模型脱敏之后进行开源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;06&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问答环节&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q1：在用户行为预训练中，有多个 session 的 NSP 是怎么定义的？MLM 中的Mask 单元在你们模型中是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A1：多个 session 的 NSP 相对而言用的不多，因为 NSP 非常的长，在少数的联动场景，将一个序列作为下一个序列的上下句进行训练，主要还是通过 MLM 单元进行处理的。MLM 中的 Mask 单元在你们模型中是浏览的某个页面的数据。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q2：用户行为的预训练，现在的应用场景多吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;A2：现在做的用户行为预训练模型，是作为基础模型进行使用，换而言之，所有的业务场景，即本文提到的各个业务场景，比如订单，付款等几十个，上百个的业务场景，都会过一下这个基础模型，然后针对各个业务场景，再对这个预训练模型进行微调，所以，在京东零售这边，应用的落地场景还是很多的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-id=&quot;43285&quot; powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9cbb1&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;9cbb1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmZ0WnJFt2UuMfLkPSzHAxzM1TZXiaSzrfDSZ2qajcrb9a2icD8F0Md2bw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;｜分享嘉宾｜&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47148148148148145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPhTmnXByFPOlW0f48N6mqibmyGzkl21UkfFxmicypVftfkwQoA2DQn6yYSHsAsicMLliaDdtQoR1sB8Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;王三鹏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;京东零售 风控算法架构负责人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;京东零售风控算法架构负责人，负责底层算法架构搭建以及内容、订单、营销等相关场景的应用。曾就职宜信、美团从事风控算法研发工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;p data-md5=&quot;475ee&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;｜免费电子书｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;475ee&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;385&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;246&quot; data-ratio=&quot;0.66640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaf01yMSoia1PNR5mWWdbvTORdUWHenVNlibia0J0LCnnfWcZuEOsD6ibeNtMI7keYk15dZhRb5XxnLQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; title=&quot;活动banner图.png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;｜商务合作｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;220&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3814814814814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaf01yMSoia1PNR5mWWdbvTO63ibLl0ib3zicOQhnbaTXX5LiaKrw7uSx5W4w0ALOVhuqgDw2iacYqarHRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;商务合作.png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;｜往期文章精选｜&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247613548&amp;amp;idx=2&amp;amp;sn=d7d289f53cdcfd8f69e27062898081c5&amp;amp;chksm=fbd68e00cca107166dfe408f674644bde9bacc61020a1be778fb3bb2e329c8c3bbe3680d4f53&amp;amp;token=979417504&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1. 基于预训练语言模型的可控文本生成研究与应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;1. 基于预训练语言模型的可控文本生成研究与应用&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247611181&amp;amp;idx=2&amp;amp;sn=29d9ff884f3c8f28d1cd8754fadb1b1f&amp;amp;chksm=fbd68141cca10857a8be373bc97541f50c1cc77b145868afff127195c2bb04adc1e7b6153b6c&amp;amp;token=979417504&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2. 英伟达在自然语言生成领域的最新研究进展&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2. 英伟达在自然语言生成领域的最新研究进展&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247615875&amp;amp;idx=1&amp;amp;sn=178b7bb2d06ecbf583340229b6321964&amp;amp;chksm=fbd6b7efcca13ef99f4bb0d2904b72ec96d9bdaaa3fa48ffac8145dcf9a5b2c1a1b4e55b8800&amp;amp;token=979417504&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;3. 多模态预训练技术在OPPO的应用&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;3. 多模态预训练技术在OPPO的应用&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;关注公众号，阅读更多技术干货&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-weui-theme=&quot;light&quot; data-id=&quot;MzU1NTMyOTI4Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPh87SyjsEtoRFs9iaLyPXYh9ls0BcsiaPDnFkg72xgLsvku13ZRYibyq93DgRoCaTaTkbJj7Hia4dvI1w/0?wx_fmt=png&quot; data-nickname=&quot;DataFunTalk&quot; data-alias=&quot;datafuntalk&quot; data-signature=&quot;专注于大数据、人工智能技术应用的分享与交流。致力于成就百万数据科学家。定期组织技术分享直播，并整理大数据、推荐/搜索算法、广告算法、NLP 自然语言处理算法、智能风控、自动驾驶、机器学习/深度学习等技术应用文章。&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot; data-index=&quot;0&quot; data-origin_num=&quot;916&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;🧐 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&lt;span&gt;给个&lt;/span&gt;&lt;strong&gt;3连击&lt;/strong&gt;&lt;span&gt;呗！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>