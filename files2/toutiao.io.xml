<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cebbddf68496432499aa07df9f7016ec</guid>
<title>最强开源 OLAP 数据库，你应该选择的 10 个理由</title>
<link>https://toutiao.io/k/h1z5lkl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;col-md-10 col-sm-12&quot;&gt;
            &lt;h1&gt; 最强开源 OLAP 数据库，你应该选择的 10 个理由&lt;/h1&gt;
            &lt;hr/&gt;
            &lt;p&gt;作者: 康凯森&lt;/p&gt;
            &lt;p&gt;日期: 2022-12-13&lt;/p&gt;
            &lt;p&gt;分类: &lt;a href=&quot;../tag/OLAP.html&quot; target=&quot;_blank&quot;&gt;OLAP&lt;/a&gt;&lt;/p&gt;
            &lt;hr/&gt;
            


&lt;p&gt;2022 年即将结束，疫情持续了 3 年，StarRocks 也创立了快 3 年，今天就总结下 StarRocks 用户侧可以感知的十大 Fature 和 优化，也希望大家对 StarRocks 有一个更全面的认知。&lt;/p&gt;
&lt;h2 id=&quot;一-极速-olap&quot;&gt;一 极速 OLAP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16688670975989.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中是我们官网展示的 SSB 单表的查询性能对比，可以看到，相比业界其他优秀的 OLAP 数据库，我们 StarRcoks 在性能上有着明显的优势，不止是 SSB 单表查询，SSB 多表，TPC-H 查询，TPC-DS 等复杂的多表查询，我们同样拥有极致的性能。TPC-DS 查询在 100G 和 1T 规模下，StarRcoks 相比 Snowflake 有2到3倍的性能优势。&lt;/p&gt;
&lt;p&gt;极致的性能不仅可以带来更好的用户体验，让之前难以实现的需求可以实现，更重要的是，可以节省大量的机器，为企业降本增效。&lt;/p&gt;
&lt;p&gt;我们 StarRcoks 能拥有极致的 OLAP 分析性能，是因为2年多来，我们在以下几个方面做了大量持续深入的优化：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;MPP 分布式执行&lt;/strong&gt;：StarRocks 拥有 MPP 的分布式执行框架，保证了 StarRocks 可以充分发挥多机 scale out 的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Pipeline 并行执行框架&lt;/strong&gt;：我们从零打造了 pipeline 并行框架，可以让  StarRocks 充分发挥多核 scale up 的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;向量化执行&lt;/strong&gt;：我们从零打造了 StarRocks 的向量化执行引擎，让 StarRocks 单核可以拥有极致的执行性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CBO 优化器&lt;/strong&gt;：通过 MPP 分布式执行， Pipeline 并行执行 和 向量化执行，我们拥有了世界领先的查询执行器，但是对于复杂的SQL，优化器产生的 Plan 好坏对查询性能影响更大，所以我们又从零打造了 CBO 优化器，让 StarRocks 对于复杂查询可以产生足够好的 Plan，进而对于复杂查询，StarRocks 也可以拥有极佳的查询性能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Global Runtime Filter&lt;/strong&gt; : Runtime Filter 对复杂的join 查询影响极大，开关 Runtime filter，可以有几十倍的查询，我们在 Global 和 Local Runtime Filter 上都做了挺多深度优化和创新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局低基数字典优化&lt;/strong&gt;：目前主要是可以优化包含低基数字符串的各类查询，整体会有2到3倍的性能提升，面向的场景主要是业务的维表中有大量的低基数字符串列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对上面技术原理感兴趣的可以参考我们 StarRocks 官方微信公众号和 B 站的相关技术分享。&lt;/p&gt;
&lt;h2 id=&quot;二-极速数据湖分析&quot;&gt;二 极速数据湖分析&lt;/h2&gt;
&lt;p&gt;当我们拥有了一个极速的查询引擎，可以实现极速 Olap 分析后，一个自然而然的想法就是，我们是不是也可以直接查询 Apache Hive、Apache Iceberg 和 Apache Hudi 等开源数据湖或数据仓库的数据上呢？ 答案是 Yes ! 这样的一个巨大好处是用户省去了数据导入或者同步这个工作，对用户的易用性大大增强。&lt;/p&gt;
&lt;p&gt;所以从21年开始，我们就成立了专门的数据湖分析团队，致力于提供开箱即用的极速数据湖分析体验。一年多来，用户侧可以感知的优化和功能如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1 各种外部数据源接入更加简单&lt;/strong&gt;：开发了全新的 Connector 框架和 Catalog 机制，访问外部数据源变得很容易，只需要配置下 Catalog，就可以查询到对应 DB 下的所有表数据，而不是最初一张表一张表配置，极大提升了用户的易用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16688650649458.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2 更加极致的性能&lt;/strong&gt;：除了查询引擎本身的持续性能提升，数据湖分析额外在 Scan 算子和外表元数据访问上做了大量优化，在有 Local Cache的情况下，外表查询性能可以媲美本地的 OLAP 表。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16679830144946.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;3 更加弹性&lt;/strong&gt;： 当 BE 不负责数据存储时，就变成了一个无状态的计算节点，弹性伸缩就变得十分自然和容易，而且数据湖分析大多属于 Adhoc 查询，查询范式不固定，相比与传统的 Olap 查询，更需要弹性伸缩的能力。所以我们就新增了一种新的节点：Compute Node —— 是将 BE 的存储功能移除，只保留计算模块。 并和 K8S 结合，做到了弹性伸缩。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16709203320364.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;4 更加安全&lt;/strong&gt;： 我们更好地支持了 Kerberos 认证，接入了云厂商托管的 IAM 服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;三-主键更新&quot;&gt;三 主键更新&lt;/h2&gt;
&lt;p&gt;过去两年来，我们从零实现了全新的 基于列存的 Delete-and-Insert 模式的主键更新模型，可以同时支持实时更新和极致的查询性能，在大规模实时数据写入的同时，查询性能可以做到其他行业领先 OLAP 数据库的 3-5 倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16709237307812.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两年来，我们的主键模型做了如下优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主键索引持久化：减少了主键索引的内存使用量，可以支持更大数据量的单表&lt;/li&gt;
&lt;li&gt;部分列更新：以现有的 Delete + Insert 模式为基础，通过读取老版本数据，来填充缺失列&lt;/li&gt;
&lt;li&gt;条件更新：当满足某个固定条件时才更新对应行，否则就不更新&lt;/li&gt;
&lt;li&gt;高频导入优化：对 Publish version 过程，compaction 过程，合并事务数等优化&lt;/li&gt;
&lt;li&gt;Update 和 Delete 语句支持复杂表达式和子查询&lt;/li&gt;
&lt;li&gt;主键和排序键分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实时化是整个数据分析的大趋势，而更新的需求也越来越多，有了 StarRocks 优秀的主键模型，你可以更好的支持下面的业务场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CDC 实时同步 TP 数据到 StarRocks 中，这也是使用最广泛的场景&lt;/li&gt;
&lt;li&gt;数据处理范式从 ETL 变成 ELT，也需要强大的更新能力&lt;/li&gt;
&lt;li&gt;实时流中通过多表 Join 更新数据的场景，有了 Partial-Update，就可以代替部分多表 Join 的需求&lt;/li&gt;
&lt;li&gt;根据某个时间戳进行条件更新&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;四-资源隔离&quot;&gt;四 资源隔离&lt;/h2&gt;
&lt;p&gt;在生产环境中，大家一般都会遇到大查询的问题： 几个大查询吃满了整个集群的资源，影响了正常的小查询，大查询很难及时熔断和定位。 针对大查询的问题，我们从 2.3 版本开始，基于 Pipeline 执行引擎，实现了资源隔离。 目前 StarRocks 支持了内存资源的硬隔离，CPU 和 IO 资源的软隔离。&lt;/p&gt;
&lt;p&gt;我们引入了 Work Group 的概念，每个 Work Group 可以配置使用的 CPU 和 IO 比例，我们通过两级队列调度和类型 Linux CFS 调度的算法基本保证了每个 Work Group在查询运行时，使用的资源可以符合配置的比例。&lt;/p&gt;
&lt;p&gt;同时为了提高资源的利用率，在集群资源空闲时，每个 work group 可以使用到更多资源，对集群资源的利用率和隔离性进行了兼顾。&lt;/p&gt;
&lt;p&gt;对一些高优业务，用户可能期望隔离性更高，我们也支持了短查询 Work Group 的 CPU 硬隔离，任何情况下，其对应的 CPU 资源都不会被占用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/16709327441519.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五-物化视图&quot;&gt;五 物化视图&lt;/h2&gt;
&lt;p&gt;StarRocks 第一版的物化视图是从 Rollup 转换而来，只能用来透明加速查询，不能显示直接查询某个物化视图，也就是说物化视图只有物化的语义，没有视图的语义。&lt;/p&gt;
&lt;p&gt;我们物化视图 2.0 版本进行了5方面的加强：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;让物化视图可以直接被查询&lt;/strong&gt;：将物化视图也视为一张表，这样在复杂的 ELT 或者 ELT 的数据处理过程中，就可以使用物化视图来简化 SQL&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在数据建模场景下，支持任意复杂的SQL&lt;/strong&gt;：也就是说，物化视图里面可以定义任意复杂的SQL，但是不保证每个物化视图都支持透明的查询改写加速&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在透明加速场景下，支持更复杂的SQL:&lt;/strong&gt; 目前 StarRocks 已经可以支持 Aggregate, Join, Filter, Union 等复杂查询的物化视图透明改写&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持对数据湖上的数据建立物化视图&lt;/strong&gt;：对数据湖上的近期热点数据利用物化视图进行强有力的透明加速&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物化视图支持异步刷新和自动刷新&lt;/strong&gt;：让物化视图的创建过程和刷新过程更加简单&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 StarRocks 3.0 中，物化视图将会有一个质变，成为 StarRocks 的 Killer Feature，大家敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;六-tablet-level-query-cache&quot;&gt;六 Tablet Level Query Cache&lt;/h2&gt;
&lt;p&gt;在实时报表分析和时序查询中，大家经常会遇到分析最近某几天的数据，或者分析今天从零点一直到现在的数据这种场景，在这类查询中，最近某几天的分区 或者 最近某几个小时的数据可能被高频查询到，这种场景很适合 Query Cache 发挥作用，StarRocks 是基于 Tablet 粒度实现的 Query Cache，具有以下亮点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;media/16679811340710/44ebdb2c-950e-400f-8b68-aca5e7c8aa76.png&quot; alt=&quot;44ebdb2c-950e-400f-8b68-aca5e7c8aa76&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cache 命中率高&lt;/strong&gt; ：因为 Cache 粒度是 Tablet 粒度，比较细，不是整个查询结果集，或者某个分区的查询结果集，Cache 命中率理论上会更高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持多版本&lt;/strong&gt;：支持多版本有多个好处，首先是可以支持高频实时导入，因为 tablet 旧版本的对应的 Cache 内容可以复用，只需要旧版本的 Cache 结果和新版本的增量结果合并即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;支持 Join 等多表复杂查询的结果集Cache&lt;/strong&gt;：不像大多数系统只能支持单表查询的 Query Cache.&lt;/p&gt;
&lt;p&gt;StarRocks 的 Query Cache 已经在 2.5 版本发布，欢迎大家使用。&lt;/p&gt;
&lt;h2 id=&quot;七-半结构化数据分析&quot;&gt;七 半结构化数据分析&lt;/h2&gt;
&lt;p&gt;过去两年来，StarRocks 在持续完善半结构化数据分析能力：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;支持了 Array, Map, Struct, Json 数据类型&lt;/li&gt;
&lt;li&gt;支持了大量 Array, Map, Struct, Json 相关函数&lt;/li&gt;
&lt;li&gt;支持了 Lateral Join 和 Unnest Table Function，详情可以参考 &lt;a href=&quot;https://docs.starrocks.io/zh-cn/latest/using_starrocks/Lateral_join&quot;&gt;https://docs.starrocks.io/zh-cn/latest/using_starrocks/Lateral_join&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;支持了 Lambda 函数，  详情可以参考 StarRocks Lambda 函数用户文档&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有了这些基础能力，你可以用 StarRocks 做一些更强大的事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;StarRocks 可以更好地支持用户行为分析（留存及漏斗分析，路径分析等）&lt;/li&gt;
&lt;li&gt;StarRocks 可以更好地支持 Parquet, ORC 等文件导入和分析&lt;/li&gt;
&lt;li&gt;支持 Map 和 Json 类型可以让 StarRocks 更容易进行 Schema 变更&lt;/li&gt;
&lt;li&gt;支持 Json 类型让 StarRocks 对日志分析，事件分析等场景支持更加友好&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;StarRocks 明年也会持续在半结构化数据分析上发力。&lt;/p&gt;
&lt;h2 id=&quot;八-查询并行度自适应&quot;&gt;八 查询并行度自适应&lt;/h2&gt;
&lt;p&gt;StarRocks 的查询一开始是 Fragment 并行机制，将每个查询的并行度设置交给了用户，但是这个具体的并行度值用户很难设置，简单查询串行执行时并行度高点性能会好，但是高并发时，并行度高性能反而会更差，因为旧版的执行框架，是每个 fragment 一个执行线程，fragment 数越多，执行线程会更多，线程切换和竞争的开销会更大。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，StarRocks 一年多来分三步走解决了这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;实现 Pipeline 并行引擎&lt;/strong&gt;：将执行线程数固定成 CPU 核数，查询默认的并行度改成核数的一半，用户不需要再关心并行度的设置，但是还存在一些优化空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单 Tablet 内部并行&lt;/strong&gt;：支持单个 Tablet 可以并行查询，将查询的并行度和 Tablet 数解耦，解决了 Tablet 数较少时无法设置更高并行度的问题&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询并行度自适应（下个版本支持）&lt;/strong&gt;: 根据不同的集群复杂和查询类型，自动设置最合理的并行度。默认并行度设置成为核数，当数据量比较少时 或者 集群负载比较高时，自动减少并行度；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过这三步，当你在 StarRocks 时就再也不用自己操心查询并发度的设置了，无论是 Benchmark 场景，还是高并发场景，无论是复杂的大查询，还是简单的小查询，StarRocks 都会自动为你提供&lt;strong&gt;开箱即用的极致性能体验&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;九-云原生存储分离&quot;&gt;九 云原生存储分离&lt;/h2&gt;
&lt;p&gt;大家都知道，Cloud Native 是大势所趋，而要支持 Cloud Native，StarRocks 就必须从之前的 Shared-Nothing 架构转向存算分离架构。从 21 年初，StarRocks 就组建了专门的 Cloud 团队全力打造全新的存算分离架构，历经我们 Cloud 团队长达两年的设计和研发，存算分离的 StarRocks 第一版已经开发测试完成，目前已经交付部分用户进行试用测试，有想提前尝鲜的用户也欢迎联系我们。&lt;/p&gt;
&lt;p&gt;如上图所示（由于官方还未公开过图，我就不放了，大家可以根据 《Data-Parallel Actors：千行代码构建高性能 OLAP 数据库》一文中的描述脑补下），是我们 StarRocks 新一代的全新架构，我们新一代存算分离架构的核心是 StarOS, StarOS 一个极具野心的项目，简单来说，StarOS 会对分布式相关逻辑进行抽象和统一，对云上存储进行抽象和统一，让我们未来打造一个存算分离服务变得十分简单。 具体的技术内幕大家可以期待我们 Cloud 团队同学之后的深度分享。&lt;/p&gt;
&lt;p&gt;那么从用户视角来看，我们全新的存算分离架构会提供什么独特的优势呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在可以弹性伸缩的同时，可以提供媲美 Shared-Nothing 架构的性能&lt;/li&gt;
&lt;li&gt;依靠 StarOS, 同时支持云上部署和本地部署&lt;/li&gt;
&lt;li&gt;实时更新能力&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然，普遍存储架构的优点我们已经或即将具备：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;极致弹性&lt;/li&gt;
&lt;li&gt;更低成本&lt;/li&gt;
&lt;li&gt;多租户&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;Serverless&lt;/li&gt;
&lt;li&gt;。。。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;十-saas-byoc&quot;&gt;十 SAAS BYOC&lt;/h2&gt;
&lt;p&gt;所谓云原生的存算分离，我们除了存储分离的内核，还需要在云上将数据库服务化，所以在一边打造存算分离内核的同时，我们也成立了一个专门的团队在打造 SAAS 服务，我们目前已经推出了 BYOC 的 SASS 模式。 BYOC 是 bring-your-own-cloud 的缩写，也就是&lt;strong&gt;使用用户自己的云，这样会有更好的数据隐私，更好的安全性&lt;/strong&gt;。如图所示（由于官方还未公开过图，我就不放了），整个架构分为控制面板和数据面板，控制面板在 StarRocks 的 VPC， 数据面板在用户的 VPC，目前已经有多个用户在正式使用。&lt;/p&gt;
&lt;p&gt;我们即将迎来2023年，在新的一年里， StarRocks 会带来更多的 Killer Feature，也会大力提升稳定性和易用性，努力让 StarRocks 成为最受欢迎的 OLAP 数据库。&lt;/p&gt;

            &lt;hr/&gt;
            &lt;h3&gt;欢迎来知识星球和我交流&lt;/h3&gt;
            
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ceab79e45e658c44af1afa7f7c7b7063</guid>
<title>Go 编程语言与环境：万字长文复盘导致 Go 语言成功的那些设计决策（译）</title>
<link>https://toutiao.io/k/ffc9tj1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2022/05/04/the-paper-of-go-programming-language-and-environment&quot;&gt;本文永久链接&lt;/a&gt; – https://tonybai.com/2022/05/04/the-paper-of-go-programming-language-and-environment&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cacm.acm.org/&quot;&gt;美国计算机学会通讯(Communications of the ACM)&lt;/a&gt;期刊2022年5月第65卷第5期将发表一篇有关Go语言的综述类Paper：&lt;a href=&quot;https://cacm.acm.org//magazines/2022/5/260357-the-go-programming-language-and-environment/fulltext&quot;&gt;《Go编程语言与环境》&lt;/a&gt;，这类综述类文章只有资深的Go核心团队的人才“有资格”写，该文的作者列表印证了这一点，他们是Russ Cox，Robert Griesemer，Rob Pike，Ian Lance Taylor和Ken Thompson，都是Go语言核心团队耳闻能详的人物。&lt;/p&gt;
&lt;p&gt;这篇文章是&lt;strong&gt;Go核心团队对10多年来Go演化发展的复盘&lt;/strong&gt;，深入分析了那些对Go的成功最具决定性的设计哲学与决策，个人觉得这是Go诞生十多年来最重要的一篇文章。所以我建议Gopher们都能认真读一遍或几遍这篇文章。这里将其翻译为中文，方便大家enjoy it。&lt;/p&gt;
&lt;p&gt;原文pdf版在&lt;a href=&quot;https://cacm.acm.org/magazines/2022/5/260357-the-go-programming-language-and-environment/pdf&quot;&gt;这里&lt;/a&gt;可以下载。&lt;/p&gt;
&lt;hr/&gt;
&lt;blockquote&gt;
&lt;p&gt;Go是一种编程语言，于2007年底在Google(谷歌)创建，并在2009年11月作为以开放源代码形式发布。从那时起，它就一直被作为一个公共项目运作，有成千上万的个人和几十家公司为Go项目做出过贡献。Go已经成为构建云计算基础设施的一种流行语言。&lt;a href=&quot;https://tonybai.com/tag/docker&quot;&gt;Docker（一种Linux容器管理器）&lt;/a&gt;和&lt;a href=&quot;https://tonybai.com/tag/kubernetes&quot;&gt;Kubernetes（一种容器部署系统）&lt;/a&gt;都是用Go编写的核心云技术。今天，Go是每个主要的云供应商的关键基础设施的基础，&lt;a href=&quot;https://www.cncf.io&quot;&gt;云原生计算基金会(CNCF)&lt;/a&gt;托管孵化的大多数项目都是Go语言实现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;主要见解(key insights)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Go语言尽管没有什么技术上的突出进步，但却有着广泛的应用。并且，Go的成功在于专注于工程软件项目的整体环境。&lt;/li&gt;
&lt;li&gt;Go的做法是不会将语言特性视为比环境特性更重要，例如：谨慎处理依赖关系(译注：尤指最小版本选择MVS)、可规模化(scale)的开发和生产、默认安全的程序、工具辅助的测试和开发、对自动化修改的适应性以及&lt;a href=&quot;https://go.dev/doc/go1compat&quot;&gt;长期保证的兼容性&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2022/04/20/some-changes-in-go-1-18&quot;&gt;Go 1.18于2022年3月发布&lt;/a&gt;，增加了十年来第一个重要的新语言特性：参数化多态性，经裁剪后可以很好地适应Go语言的其他部分(译注：仍然可以保持向后兼容，满足Go1兼容性承诺)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;引子&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;早期用户被Go所吸引的原因有很多&lt;/strong&gt;。首先，一种支持&lt;a href=&quot;https://tonybai.com/2020/03/10/visualizing-memory-management-in-golang/&quot;&gt;垃圾回收&lt;/a&gt;、静态编译的系统级编程语言，其本身就是不寻常的。其次，Go对&lt;a href=&quot;https://tonybai.com/2015/06/23/concurrency-and-parallelism/&quot;&gt;并发(concurrency)和并行(parallelism)&lt;/a&gt;的原生支持有助于利用当时正在成为主流的多核机器的优势。再次，自包含的二进制文件(译注：无需依赖目标主机上的C运行库和其他系统库)和简单的&lt;a href=&quot;https://tonybai.com/2014/10/20/cross-compilation-with-golang/&quot;&gt;交叉编译&lt;/a&gt;简化了部署。最后，&lt;a href=&quot;https://tonybai.com/2012/10/08/the-new-age-of-programming-language/&quot;&gt;谷歌的名字无疑也是一个亮点&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;但为什么用户会留存下来呢？为什么Go可以越来越流行、越来越受欢迎而同期的其他语言项目却没有呢？我们相信，语言本身只是答案的一小部分。&lt;strong&gt;完整的故事(答案)必须涉及整个Go环境：库、工具、惯例和针对软件工程的整体做法&lt;/strong&gt;，它们都对使用Go语言编程提供了支持。我们在语言设计中做出的最重要的决定，就是使Go更适合大规模软件工程，并帮助我们吸引志同道合的开发者。&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们研究了我们认为对Go的成功最具决定性的那些设计决策，探讨了它们不仅适用于语言，而且适用于更广泛的环境的原因。然而，要分离并量化出某个具体设计决策的贡献度是很困难的，所以这篇文章不应该被理解为科学分析，而应该被理解为&lt;strong&gt;基于Go过去十年的经验和用户反馈的最佳理解的呈现&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;起源(Origins)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Go是在Google建立大规模分布式系统的经验中产生的&lt;/strong&gt;，在一个由成千上万的软件工程师共享的大型代码库中工作。我们希望为这种环境设计的语言和工具能够解决公司和整个行业所面临的挑战。由于开发工作和正在部署的生产系统的规模都很大，挑战因此出现了!&lt;/p&gt;
&lt;h4&gt;开发规模(Development scale)&lt;/h4&gt;
&lt;p&gt;在开发方面，谷歌在2007年有大约4000名活跃的用户在一个单一的、共享的、多语言（C++、Java、Python）的代码库中工作。单一的代码库使问题很容易修复，例如，使主网络服务器变慢的内存分配器中的问题。但是在开发一个库的时候，由于很难找到一个包的所有依赖关系，所以很容易在不知不觉中破坏了这个库的一个以前未知的用户。&lt;/p&gt;
&lt;p&gt;另外，在我们使用的现有语言中，导入一个库可能导致编译器递归加载所有导入的库。在2007年的一次C++编译中，我们观察到编译器（在#include预处理后）在编译一组总共4.2MB的文件时，居然读取了超过8GB的数据，在一个已经很大的程序上，扩展系数几乎达到2000。如果为编译一个给定的源文件而读取的头文件的数量随着源代码树线性增长，那么整个源树的编译成本就会呈现指数级增长。&lt;/p&gt;
&lt;p&gt;为了弥补速度的减慢，我们开始研究一个新的、大规模并行和可缓存的编译系统，它最终成为开源的Bazel编译系统。但是并行性和缓存对于修复低效的系统只能起到这么大的作用了，我们相信语言本身可以做更多的事情来为编译大型程序提供帮助。&lt;/p&gt;
&lt;h4&gt;生产规模(Production scale)&lt;/h4&gt;
&lt;p&gt;在生产方面，谷歌正在运行非常大的系统。例如，2005年3月，一个1500颗CPU的Sawzall日志分析系统集群处理了2.8PB的数据。2006年8月，谷歌的388个大表服务集群由24500个独立的tablet服务器组成，其中一组8069个服务器每秒处理了120万个请求。&lt;/p&gt;
&lt;p&gt;然而，谷歌和业界其他公司一样，都在努力编写高效的程序，以充分利用多核系统的优势。我们的许多系统不得不在一台机器上运行同一个二进制文件的多个副本，因为现有的多线程支持既笨重又低性能。庞大的、固定大小的线程栈，重量级的栈开关，以及用于创建新线程和管理它们之间交互的笨拙语法，都使得使用多核系统变得更加困难。但很明显，服务器中的cpu核数量只会越来越多。&lt;/p&gt;
&lt;p&gt;在这里，我们也相信语言本身可以通过提供轻量级的、易于使用的并发性原语来提供帮助。我们还在这些额外的cpu核中看到了一个机会：垃圾收集器可以在一个专用的核上与主程序并行运行，减少其延迟成本。&lt;/p&gt;
&lt;p&gt;为应对这些挑战而设计的编程语言可能是什么样子的呢？Go就是我们针对这一问题的回答。Go之所以受欢迎，部分原因无疑是整个科技行业现在每天都面临这些挑战。云计算供应商使最小的公司也有可能进行非常大的生产部署。虽然大多数公司没有成千上万的员工在写代码，但现在几乎所有的公司都依赖于由成千上万的程序员贡献的大量开源基础设施。&lt;/p&gt;
&lt;p&gt;本文的后续部分将研究具体的设计决策是如何解决这些开发和生产的规模化问题的。我们从语言核心本身开始，向外扩展到周围的环境。&lt;strong&gt;我们并不试图对该语言进行完整的介绍&lt;/strong&gt;。要想全面详细了解Go语言，请参见&lt;a href=&quot;https://go.dev/ref/spec&quot;&gt;Go语言规范&lt;/a&gt;或&lt;a href=&quot;http://www.gopl.io&quot;&gt;《Go程序设计语言》&lt;/a&gt;等书籍。&lt;/p&gt;
&lt;h3&gt;包(Packages)&lt;/h3&gt;
&lt;p&gt;一个Go程序是由一个或多个可导入的包组成的，每个包包含一个或多个文件。图1中的网络服务器说明了关于Go的包系统设计的许多重要细节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-4.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
&lt;/p&gt;&lt;center&gt;图1：Go Web服务器&lt;/center&gt;
&lt;p&gt;该程序启动了一个本地网络服务器（第9行），它通过调用hello函数来处理每个请求，hello函数用消息”hello, world”（第14行）作为响应。&lt;/p&gt;
&lt;p&gt;一个包使用显式的import语句导入另一个包（第3-6行），这与许多语言一样，但与C++的#include机制相反。不过，与大多数语言不同的是，Go安排每个导入语句只读取一个文件(译注：仅会读取依赖包对应的.a文件，以fmt为例，读取的是fmt.a)。例如，fmt包的公共API引用了io包的类型：fmt.Fprintf的第一个参数是io.Writer类型的接口值。在大多数语言中，编译器处理fmt包的导入时，也都会加载所有io的符号来满足fmt包的需要，这可能又需要加载额外的包来满足所有io包中符号的需要。依此类推，一条导入语句可能最终要加载并处理几十个甚至几百个包。&lt;/p&gt;
&lt;p&gt;Go通过采用与Modula-2语言类似的做法，即：使编译后的fmt包的元数据包含了了解其自身依赖关系所需的一切，例如io.Writer的定义，从而避免了上述这种问题。因此，编译import “fmt”语句时只需读取一个完全描述fmt及其依赖关系的文件(译注：这个文件指fmt.a)。 此外，这种“扁平化”处理是在编译fmt包时一次完成的，避免了每次导入时的多次加载。这种方法使编译器的工作更少，构建速度更快，有助于大规模开发。同时，包的导入循环是不允许的：&lt;strong&gt;即如果fmt包导入了io包，那么io包就不能导入fmt包，也不能导入任何其他导入fmt的包，即使是间接的导入&lt;/strong&gt;。这也使得编译器工作进一步减少，保证了一个特定的构建可以被分割为多个单独的包的编译。这也使得增量程序分析成为可能，我们甚至可以在运行测试之前就运行这种分析来捕捉错误。&lt;/p&gt;
&lt;p&gt;一个包导入fmt包并不能使io.Writer这个名字对当前这个包可用。如果main包想使用io.Writer这个类型，它必须自己使用import “io”语句导入io包。因此，一旦所有使用fmt限定名称的引用被从源文件中删除– 例如，如果上面例子中fmt.Fprintf的调用被删除，import “fmt”语句就可以安全地从源文件中删除，而无需做进一步分析。这个属性使得自动管理源代码中的导入语句成为可能。事实上，Go不允许未使用的导入，以避免将未使用的代码链接到程序中而产生的可执行文件膨胀。&lt;/p&gt;
&lt;p&gt;导入路径是带引号的字符串字面值，这使其解释具有灵活性。一个斜线分隔的路径在import语句中标识了导入的包，但随后源代码使用包声明语句中声明的短标识符来引用包。例如，import “net/http”提供了包的路径，但我们却使用其顶层名称http对其内容进行访问。在标准库之外，包由以域名开头的类似URL的路径来识别，如import “github.com/google/uuid”。我们将在后面对这类包进行更多的介绍。&lt;/p&gt;
&lt;p&gt;关于包的最后一个细节，请大家注意fmt.Fprintf和io.Writer这两个名字中的大写字母。Go使用一种&lt;strong&gt;命名惯例&lt;/strong&gt;来对C++和Java的public、private和protected概念和关键字进行模拟。首字母为大写字母的名字，如Printf和Writer，是”导出的”（公共的），其他的则不是。基于首字母大小写的、编译器强制执行的导出规则适用于常量、函数和类型等包级标识符；以及方法名和结构字字段名。我们采用这一规则是为了避免在公共API中涉及的每一个标识符旁边都写上一个像export这样的关键字的语法负担。 随着时间的推移，我们已经开始看重这种可以查看标识符是否在包之外可用或仅在内部使用的能力。&lt;/p&gt;
&lt;h3&gt;类型(Types)&lt;/h3&gt;
&lt;p&gt;Go提供了一套常见的基本类型：布尔(bool)，定长整型，如uint8和int32，非定长整型int和uint（32或64位，取决于机器大小），以及定长浮点类型(float32和float64)和复数类型(complex64和complex128)。Go还类似C语言那样提供了指针、固定大小的数组和结构体类型。Go还提供了一个内置的字符串类型(string)，一个被称为map类型的哈希表，以及称为slice类型的动态大小的数组。大多数Go程序都依赖于这些类型，Go没有其他特殊的容器类型了。&lt;/p&gt;
&lt;p&gt;Go没有提供类(class)，但允许将方法(method)绑定到任何类型上，包括结构体、数组、切片、map，甚至是基本类型，如整型。它没有类型层次体系；我们认为继承性往往会使程序在演化过程中更难适应。相反，&lt;strong&gt;Go鼓励类型的组合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Go通过其接口类型提供面向对象的多态性。就像Java接口或C++的抽象虚拟类一样，Go的接口包含一个方法名称和签名的列表。例如，前面提到的io.Writer接口在io包中的定义如图2所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-6.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
&lt;/p&gt;&lt;center&gt;图2：io包中的Writer接口定义&lt;/center&gt;
&lt;p&gt;Write方法接受一个字节切片，并返回一个整数和可能的错误。与Java和C++不同的是，任何Go类型如果拥有与某个接口相同名称和签名的方法集合，就被认为是实现了该接口，而无需额外的显式声明。例如，os.File类型有一个签名相同的Write方法，因此它实现了io.Writer，而没有使用像Java的”implements”进行显式指示。&lt;/p&gt;
&lt;p&gt;避免接口和实现之间的显式关联，允许Go程序员定义小型、灵活以及临时性的接口，而不是将它们作为复杂类型层次结构的基础构件。&lt;strong&gt;它鼓励捕捉开发过程中出现的关系和操作，而不是需要提前计划和定义它们&lt;/strong&gt;。这对大型程序尤其有帮助，因为在刚开始开发时，最终的结构是很难看清楚的。去除声明实现的簿记，鼓励使用精确的、只有一种或两种方法的接口，如Writer、Reader、Stringer（类似于Java的toString方法）等，这些接口在标准库中被广泛应用。&lt;/p&gt;
&lt;p&gt;初次学习Go的开发者常常担心一个类型会意外地实现一个接口。虽然很容易建立起这样的假设，但在实践中，不太可能为两个不兼容的操作选择相同的名称和签名，而且我们从未在实际的Go程序中看到这种情况发生。&lt;/p&gt;
&lt;h3&gt;并发(Concurrency)&lt;/h3&gt;
&lt;p&gt;当我们开始设计Go语言的时候，多核计算机已经开始广泛使用，但线程在所有流行的语言和操作系统中仍然是一个重量级的概念。创建、使用和管理线程的难度使其不受欢迎，这限制了对多核CPU能力的充分利用。&lt;strong&gt;解决这一矛盾是创建Go的主要动机之一&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Go语言中原生包含了多个并发控制线程的概念，称为&lt;strong&gt;goroutines&lt;/strong&gt;。goroutines在一个共享地址空间中运行，并能被有效地通过多路复用机制调度到操作系统线程上。对阻塞操作的调用，如从文件或网络中读取数据，只阻塞进行该操作的goroutine；该线程上的其他goroutine可能被移到另一个线程中，这样它们就可以在调用者被阻塞时继续执行。goroutine开始时只有几千字节的堆栈(译注：在Linux x86-64上默认是2KB)，它可以根据需要自动调整大小，而无需程序员参与。开发人员在设计程序结构时将Goroutines视作一种丰富的、廉价的原语。对于一个服务器程序来说，拥有数千甚至数百万个goroutines是很平常的，因为它们的使用成本比线程低得多。&lt;/p&gt;
&lt;p&gt;例如，net.Listener是一个带有Accept方法的接口，可以监听并返回客户端新发起的网络连接。图3显示了一个接受连接的函数listen，并为每个连接启动一个新的goroutine来运行服务函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-7.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
&lt;/p&gt;&lt;center&gt;图3：一个Go网络服务器&lt;/center&gt;
&lt;p&gt;listen函数主体中的无限for循环（第22-28行）中调用了listener.Accept方法，它返回两个值：连接和一个可能的错误。假设没有错误发生，go语句（第27行）在一个新的goroutine中启动其参数：一个函数调用serve(conn)，这类似于Unix shell命令的后缀&amp;amp;，但在同一个操作系统进程中。要调用的函数及其参数在原goroutine中被求值；这些值被复制以创建新goroutine的初始栈帧。因此，程序为每个新发起的网络连接运行一个独立的serve函数实例。每个serve的调用处理一个给定连接上的所有请求（第37行对handle(req)的调用没有以go为前缀）；每次serve调用都可以阻塞而不影响对其他网络连接的处理。&lt;/p&gt;
&lt;p&gt;在Go的内部，Go的实现使用了有效的多路复用操作，比如Linux的epoll，来处理并发的I/O操作，但用户看不到。Go的运行时库&lt;strong&gt;对用户呈现的是阻塞式I/O的抽象&lt;/strong&gt;，其中每个goroutine都是顺序执行的，不需要回调，这很容易理解。&lt;/p&gt;
&lt;p&gt;在创建了多个goroutine之后，一个程序必须经常在它们之间进行协调。Go提供了&lt;strong&gt;channel原语&lt;/strong&gt;，允许goroutine之间进行通信和同步：channel是一个单向的、大小有限的管道，在goroutine之间传输类型化的信息。Go还提供了一个多路选择原语&lt;strong&gt;select&lt;/strong&gt;，可以根据某channel上的通信是否可进行来控制执行。这些想法来自Hoare的”通信顺序过程(Communicating Sequential Processes)”和早期的语言实验，特别是Newsqueak、Alef和Limbo。&lt;/p&gt;
&lt;p&gt;图4显示了另一个版本的listen，它是为了限制任何时候可处理的连接数量而写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-8.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
&lt;/p&gt;&lt;center&gt;图4：一个Go网络服务器，将并发处理的能力限制在10个连接&lt;/center&gt;
&lt;p&gt;这个版本的listen首先创建了一个名为ch的channel（第42行），然后启动了一个由10个服务端goroutines组成的池（第44-46行），它们接收来自这个单一channel的连接。当新的连接被接受时，listen使用发送语句ch &amp;lt;- conn（第53行）在ch上发送每个连接。一个server执行接收表达式&amp;lt;- ch（第59行）完成了此次channel通信。这里创建的是无缓冲channel(Go默认如此)，ch没有空间来缓冲正在发送的值，所以在10个server忙完前10个连接后，第11个ch &amp;lt;-conn将被阻塞，直到一个server完成对serve函数的调用并执行新的接收。被阻塞的通信操作对Listener产生了隐性的压力，这回阻止Listener接受新的连接，直到前一个连接被处理完。&lt;/p&gt;
&lt;p&gt;请注意，这些程序中没有互斥或其他传统的同步机制。在channel上进行的数据值通信可以作为同步的一部分；按照惯例，在channel上发送数据会将所有权从发送方传给接收方。Go有提供互斥、条件变量、信号量和原子操作的库，供低级别互斥或同步使用，但channel往往是更好的选择。根据我们的经验，人们对消息传递–利用通信在goroutine之间转移所有权–的理解比对互斥和条件变量的理解更容易、更正确。早期流行的一句Go箴言是：”&lt;strong&gt;不要通过共享内存来通信，而是通过通信来共享内存&lt;/strong&gt;“。&lt;/p&gt;
&lt;p&gt;Go的垃圾收集器大大简化了并发API的设计，消除了关于哪个goroutine负责释放共享数据的问题。与大多数语言一样（但与Rust不同），可变数据的所有权不由类型系统静态跟踪。相反，Go集成了TSAN(ThreadSanitizer)，为测试和受限的生产使用提供了一个动态竞态检测器。&lt;/p&gt;
&lt;h3&gt;安全性(Security和Safety)&lt;/h3&gt;
&lt;p&gt;任何新语言诞生的部分原因都是为了解决以前语言的缺陷，对Go来说，这还包括影响网络软件安全的安全问题。Go删除了在C和C++程序中造成许多安全问题的未定义行为。整数类型不会自动相互强制转型。空指针解引用、越界的数组和切片索引会导致运行时异常。不存在进入栈帧的空悬指针。任何可能超出其栈帧范围的变量，例如在闭包中捕获的变量，将被移到堆中。在堆中也没有空悬的指针；使用垃圾收集器而不是手动内存管理可以消除使用后的错误。当然，Go并没有解决所有问题，有些东西被遗漏了，也许应该被解决。例如，整数溢出本可以被定义为运行时错误，而不是定义为绕过不处理。&lt;/p&gt;
&lt;p&gt;由于Go是一种系统级编程的语言(译注：Go最初被设计者们定位为一种系统级编程语言)，它可能需要破坏类型安全的机器级操作，因此它能够将指针从一种类型强制转换为另一种类型，并进行地址运算，但只能通过使用unsafe包及其受限制的特殊类型unsafe.Pointer。必须注意这种对类型系统的违反要与垃圾收集器保持兼容–例如，垃圾收集器必须始终能够识别一个特定的字(word)是一个整数还是一个指针。在实践中，unsafe包很少出现：安全Go是相当有效的。因此，看到import “unsafe”是一个信号，让我们更仔细地检查源文件是否存在安全问题。&lt;/p&gt;
&lt;p&gt;Go的安全属性(safety properties)使它比C或C++等语言更适合于编写加密和其他安全关键的代码。一个微不足道的错误，例如一个越界的数组索引，在C和C++中可能会导致敏感数据的泄露或远程执行，但在Go中会引起运行时异常，从而停止程序，大大限制了潜在的影响。Go中有一整套密码学库，包括对SSL/TLS的支持；Go标准库包括一个可用于生产的HTTPS客户端和服务器。事实上，Go的安全性、性能和高质量库的结合使其成为现代安全工作的热门试验场。例如，免费提供的证书授权机构Let’s Encrypt依靠Go来提供生产服务，并在最近跨越了一个里程碑，签发了10亿份证书。&lt;/p&gt;
&lt;h3&gt;完整性(Completeness)&lt;/h3&gt;
&lt;p&gt;Go在语言、库和工具层面上提供了现代开发所需的核心部分。这就需要小心翼翼地平衡，既要增加足够多的”开箱即用”的功能，又不能增加太多，以至于我们自己的开发过程因为要支持太多的功能而陷入困境。&lt;/p&gt;
&lt;p&gt;Go语言提供了内置的字符串、hash map和动态大小的数组等易于使用的数据类型。如前面所述，这些对于大多数Go程序来说已经足够了。其结果是Go程序之间有了更大的互操作性–例如，没有产生竞争性的字符串或hash map的实现来分裂包的生态系统。Go包含的goroutines和channel是另一种形式的完整性。这些功能提供了现代网络程序中所需要的核心并发功能。Go直接在语言中提供这些功能，而不是在库中提供，这样可以更容易地调整语法、语义和实现，使其尽可能地轻量和易于使用，同时为所有用户提供统一的方法。&lt;/p&gt;
&lt;p&gt;Go标准库包括一个生产就绪的HTTPS客户端和服务器。对于在互联网上与其他机器互动的程序来说，这一点至关重要。直接满足这一需求可以避免额外的碎片化。我们已经看到了io.Writer接口；任何输出数据流都按惯例实现了这个接口，并与所有其他I/O适配器进行互操作。图1中的ListenAndServe调用可作为另一个例子，它期望有一个http.Handler类型作为第二个参数，其定义如下图5所示。参数http.HandlerFunc(hello)通过调用hello实现了Handler的ServeHTTP方法。该库创建了一个新的goroutine来处理每个连接，就像本文”并发”部分中的Listener例子一样，所以handler可以用简单的阻塞风格来编写，服务器可以自动扩展以同时处理许多连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;
&lt;/p&gt;&lt;center&gt;图5：net/http包的Handler接口&lt;/center&gt;
&lt;p&gt;http包还提供了一个基本的分派器(dispatcher)，它本身就是Handler的另一个实现，它允许为不同的URL路径注册不同的handler。将Handler类型确立为约定俗成的接口，使得许多不同类型的HTTP服务器中间件(middleware)能够被创建并相互操作。我们不需要将所有这些实现添加到标准库中，但我们确实需要建立一个允许它们一起工作的接口。&lt;/p&gt;
&lt;p&gt;标准Go发行版还提供了对交叉编译、测试、性能剖析(profiling)、代码覆盖率、&lt;a href=&quot;https://tonybai.com/2021/12/01/first-class-fuzzing-in-go-1-18&quot;&gt;模糊测试&lt;/a&gt;等的集成支持。测试是另一个领域，在这个领域中，建立关于核心概念的协议–例如什么是测试用例以及如何运行–使得创建的自定义测试库和测试执行环境都能很好地互操作。&lt;/p&gt;
&lt;h3&gt;一致性(Consistency)&lt;/h3&gt;
&lt;p&gt;我们对Go的一个目标是&lt;strong&gt;让它在不同的实现、执行环境中，甚至在不同的时间内表现出相同的行为&lt;/strong&gt;。这种”无聊”的一致性行为使开发人员能够专注于他们的日常工作，并使Go隐退到后台。&lt;/p&gt;
&lt;p&gt;首先，Go语言尽可能地规定了一致的结果，即使是错误的行为，如本文的”安全性”部分所讨论的空指针解引用和数组索引越界。这种一致性行为的一个例外是对map的迭代。我们发现，程序员经常不经意地写下依赖于哈希函数的代码，导致在不同的架构或Go实现上出现不同的结果。&lt;/p&gt;
&lt;p&gt;为了使程序在任何地方都有相同的表现，一种选择是强制规定一个特定的哈希函数。相反，Go定义了map迭代是非确定的。该实现为每个map使用不同的随机种子，并从哈希表中的一个随机偏移量开始对地图进行每次迭代。其结果是，map在不同的实现中都是不可预知的。代码不能再意外地依赖于实现细节。与此类似，竞态检测器为调度决策增加了额外的随机性，创造了更多的机会来观察竞态行为。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/the-go-programming-language-and-environment-10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一致性的另一个方面是在程序的生命周期内的性能。使用传统的编译器而不是Java和Node.js等语言使用的JIT来实现Go的决策，可以在启动时和短生命周期的程序中提供了一致的性能。没有”慢启动”来惩罚每个进程生命周期的前几秒。这种快速启动使Go成为命令行工具（如上一节所述）以及谷歌应用引擎(Google App Engine)等规模化网络服务器的目标。&lt;/p&gt;
&lt;p&gt;稳定的性能包括垃圾收集的开销。最初的Go原型使用了一个基本的、停止世界(STW)的垃圾收集器，当然，它在网络服务器中引入了明显的尾部延时。今天，Go使用了一个完全并发的垃圾收集器，暂停时间不到一毫秒，通常只有几微秒，与堆的大小无关。最主要的延迟是操作系统向必须中断的线程传递信号所需的时间。&lt;/p&gt;
&lt;p&gt;最后一种一致性是语言和库随着时间的推移而产生的一致性。在Go诞生的前几年，我们在每周的发布中都会对它进行修补和调整。用户在更新到新的Go版本时，常常不得不改变他们的程序。我们提供自动工具以减少开发人员的负担，但手动调整依然是必要的。从2012年发布的Go 1.0开始，我们&lt;strong&gt;公开承诺只对语言和标准库进行向后兼容的修改&lt;/strong&gt;，这样程序在编译到较新的Go版本时可以继续运行而不发生变化。这一承诺对业界产生了吸引力，它不仅鼓励了那些长声明周期的工程项目，也鼓励了其他努力，如书籍、培训课程和第三方软件包的繁荣生态系统。&lt;/p&gt;
&lt;h3&gt;工具辅助开发(Tool-Aided Development)&lt;/h3&gt;
&lt;p&gt;大规模的软件开发需要大量的自动化和辅助工具。从一开始，Go的设计就是为了鼓励这种工具化，并使其易于创建。&lt;/p&gt;
&lt;p&gt;开发者对Go的日常体验是通过go命令进行的。与只编译或运行代码的语言命令不同，go命令为开发周期的所有关键部分提供了子命令：go build和go install构建和安装可执行文件，go test运行测试用例，go get添加新的依赖。go命令还提供了对构建细节的编程访问接口，例如软件包图，从而使得新工具的创建更加容易。&lt;/p&gt;
&lt;p&gt;其中一个工具是go vet，它可以执行增量的、每次打包的程序分析，可以像缓存编译的对象文件那样缓存，实现增量构建。go vet工具的目的是高精度地识别常见的正确性问题，这样开发人员就有条件地听从它的报告。简单的例子包括在调用fmt.Printf和相关函数时检查格式字符串和参数是否匹配，或者诊断对变量或结构体字段的未用的写入。这些不是编译器错误，因为我们不希望仅仅因为发现了一个新的可能的错误就停止编译旧代码。它们也不是编译器警告；用户要学会忽略这些。将这些检查放在一个单独的工具中，可以让它们在开发者方便的时候运行，而不干扰普通的构建过程。这也使得所有的开发者都可以使用同样的检查，即使是在使用Go编译器的另一种实现，如Gccgo或Gollvm。这种增量方法使这些静态检查足够高效，我们在go test期间自动运行它们，然后再运行测试本身。无论如何，测试是用户在寻找错误，测试报告往往有助于解释实际的测试失败。这个增量框架也可以被其他工具重复使用。&lt;/p&gt;
&lt;p&gt;分析程序的工具是很有帮助的，但是编辑程序的工具就更好了，特别是对于程序的维护，很多工具都是乏味的、可自动化运作的。&lt;/p&gt;
&lt;p&gt;Go程序源码的标准样式是通过算法定义的。一个名为gofmt的工具将源文件解析为抽象的语法树，然后使用一致的布局规则将其格式化为源代码。&lt;strong&gt;在Go中，在将代码存储到源码控制系统中之前将其格式化被认为是一种最佳做法&lt;/strong&gt;。这种方法使数以千计的开发人员能够在一个共享的代码库中工作，而不需要为大括号样式和其他细节进行争论，这些争论常伴随着这种大型项目。更重要的是，工具可以通过对抽象语法形式的操作来修改Go程序，然后用gofmt的printer输出结果。只有实际改变的部分才会被触及，产生的”差异”与人的手写结果是一致的。人和程序可以在同一个代码库中无缝协作。&lt;/p&gt;
&lt;p&gt;为了实现这种方法，Go的语法被设计为能够在没有类型信息或任何其他外部输入的情况下解析源文件，而且没有预处理器或其他宏系统。Go标准库提供了一些包，允许工具重新创建gofmt的输入和输出端，同时还有一个完整的类型检查器。&lt;/p&gt;
&lt;p&gt;在发布Go 1.0 –第一个稳定的Go版本之前，我们写了一个叫做gofix的重构工具，它就使用这些包来解析源代码、重写抽象语法树，并写出格式良好的代码。例如，当从map中删除一个条目的语法被改变时，我们就使用了gofix。每次用户更新到一个新版本时，他们可以在他们的源文件上运行gofix，自动应用更新到新版本所需的大部分变化。&lt;/p&gt;
&lt;p&gt;这些技术也适用于IDE插件和其他支持Go程序员的工具–profiler、调试器、分析器、构建自动程序、测试框架等等的构建。Go的常规语法、既定的算法代码布局惯例以及基于标准库的直接支持，使得这些工具的构建比其他方式要容易得多。因此，Go世界拥有一个丰富的、不断扩展的、可互操作的工具包。&lt;/p&gt;
&lt;h3&gt;库(Libraries)&lt;/h3&gt;
&lt;p&gt;在语言和工具之后，下一个用户关键体验是可用的Go库。作为一种分布式计算的语言，Go没有提供用于发布Go软件包的中央服务器。相反，每个以域名开始的导入路径都被解释为一个URL（有一个隐含的前导https://），提供远程源代码的位置。例如，导入 “github.com/google/uuid”可以获取托管在相应的GitHub仓库的代码。&lt;/p&gt;
&lt;p&gt;托管源代码最常见的方式是指向公共的Git或Mercurial服务器，但私人服务器也同样得到了很好的支持，作者可以选择发布一个静态的文件包，而不是开放对源码控制系统的访问。这种灵活的设计和发布库的便利性创造了一个繁荣的可导入Go包的社区。依靠域名，避免了在扁平的包名空间中急于索取有价值的条目(译注：应该是避免了导入路径冲突的问题)。&lt;/p&gt;
&lt;p&gt;仅仅下载软件包是不够的，我们还必须知道要使用哪些版本。Go将包分组为称为&lt;strong&gt;module&lt;/strong&gt;的版本单位。一个module可以为它的一个依赖关系指定一个最低要求的版本，但没有其他限制。当构建一个特定的程序时，Go通过选择最大版本来解决竞争的依赖module的所需版本：如果程序的一部分需要某个依赖module的1.2.0版本，而另一部分需要1.3.0版本，Go会选择1.3.0版本–也就是说，Go要求使用语义版本划分，其中1.3.0版本必须是1.2.0的直接替换(译注：1.3.0保持与1.2.0的兼容性)。另一方面，在这种情况下，即使1.4.0版本可用，Go也不会选择它，因为程序中没有任何部分明确要求使用该较新的版本。这个规则保持了构建的可重复性，并最大限度地减少了因意外破坏新版本所引入的变化而造成的潜在风险。&lt;/p&gt;
&lt;p&gt;在语义版本管理中，一个module只能在一个新的主要版本中引入有意的破坏性变化，比如2.0.0。在Go中，从2.0.0开始的每个主要版本在其导入路径中都有一个主要版本后缀，比如/v2。不同的主版本和其他不同名字的module一样被分开。这种方法不允许出现钻石依赖性问题，而且在实践中，它可以适应不兼容的情况，也可以适应具有更精细约束的系统。&lt;/p&gt;
&lt;p&gt;为了提高从互联网上下载软件包的构建的可靠性和可重现性，我们在Go工具链中运行了两个默认使用的服务：一个是可用的Go软件包的公共镜像，一个是其预期内容的加密签名的透明日志。即便如此，广泛使用从互联网上下载的软件包仍然存在安全和其他风险。我们正在努力使Go工具链能够主动识别并向用户报告有漏洞的软件包。&lt;/p&gt;
&lt;h3&gt;结论(Conclusion)&lt;/h3&gt;
&lt;p&gt;虽然大多数语言的设计都集中在语法、语义或类型的创新上，但&lt;strong&gt;Go的重点是软件开发过程本身&lt;/strong&gt;。Go语言高效、易学、免费，但&lt;strong&gt;我们认为它的成功之处在于它所采取的编写程序的方法，特别是多个程序员在一个共享代码库上工作时&lt;/strong&gt;。该语言本身的主要不寻常属性–并发性–解决了2010年代随着多核CPU的广泛应用而出现的问题。但更重要的是，早期的工作为打包、依赖关系、构建、测试、部署和软件开发领域的其他工作任务奠定了基础，这些方面在传统的语言设计中并没有受到应有的重视。&lt;/p&gt;
&lt;p&gt;这些想法吸引了志同道合的开发者，他们重视与努力的结果是：容易并发、明确的依赖关系、可扩展的开发和生产、安全的程序、简单的部署、自动代码格式化、工具辅助开发等等。这些早期的开发者帮助普及了Go，并播种了最初的Go包生态系统。他们还推动了该语言的早期发展，例如，将编译器和库移植到Windows和其他操作系统上（最初的版本只支持Linux和MacOS X）。&lt;/p&gt;
&lt;p&gt;不是每个人都喜欢–例如，有些人反对该语言省略了继承和泛型等常见功能。但是Go的以开发为中心的理念足够吸引人，也足够有效，以至于社区在保持最初推动Go存在的核心原则的同时，也得到了蓬勃发展。在很大程度上，由于该社区和它所建立的技术，Go现在是现代云计算环境的一个重要组成部分。&lt;/p&gt;
&lt;p&gt;自Go第一版发布以来，该语言几乎被冻结。然而，工具已经大大扩展，有了更好的编译器，更强大的构建和测试工具，以及改进的依赖性管理，更不用说支持Go的大量开源工具了。然而，变化正在到来。&lt;a href=&quot;https://tonybai.com/2022/04/20/some-changes-in-go-1-18&quot;&gt;2022年3月发布的Go 1.18&lt;/a&gt;包含了对语言的真正改变的第一个版本，一个被广泛要求的改变–参数化多态性的第一版实现。我们曾将任何形式的泛型排除在原始语言之外，因为我们敏锐地意识到，它很难设计好，而且在其他语言中，往往是复杂性而非生产力的来源。在Go的第一个十年中，我们考虑了很多设计，但直到最近才找到一个我们认为很适合Go的设计。在坚持一致性、完整性和社区原则的前提下进行如此大的语言变革，将是对该方法的严峻考验。&lt;/p&gt;
&lt;h3&gt;致谢(Acknowledgments)&lt;/h3&gt;
&lt;p&gt;Go最早的工作从Google的许多同事的建议和帮助中受益匪浅。自公开发布以来，由于Google的Go团队不断扩大，加上大量的开源贡献者，Go不断成长和改进。Go现在是由成千上万的人共同完成的，这里无法一一列举。我们感谢每一个帮助Go发展到今天的人。&lt;/p&gt;
&lt;h3&gt;参考资料(References)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Aas, J. and Gran, S. Let’s Encrypt has issued a billion certificates. Let’s Encrypt (2020), https://letsencrypt.org/2020/02/27/one-billion-certs.html.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Aas, J., et al. Let’s Encrypt: An automated certificate authority to encrypt the entire web. In Proceedings of the 2019 ACM SIGSAC Conf. on Computer and Communications Security, 2473–2487.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bloch, D. Life on the edge: Monitoring and running a very large Perforce installation. Presented at 2007 Perforce User Conf., https://go.dev/s/bloch2007.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chang, F., et al. Bigtable: A distributed storage system for structured data. In 7th USENIX Symposium on Operating Systems Design and Implementation (2006), 205–218.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cox, R. Introducing Gofix. The Go Blog (2011), https://go.dev/blog/introducing-gofix.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cox, R. The principles of versioning in Go. (2019), https://research.swtch.com/vgo-principles.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cox, R. Surviving software dependencies. Communications of the ACM 62, 9 (Aug. 2019), 36–43.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cox, R. Transparent logs for skeptical clients (2019), https://research.swtch.com/tlog.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cox, R. and Pike, R. Go programming. Presented at Google I/O (2010), https://www.youtube.com/watch?v=jgVhBThJdXc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crosby, S.A. and Wallach, D.S. Efficient data structures for tamper-evident logging. In Proceedings of the 18th USENIX Security Symp. (2009), 317–334.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Donovan, A.A.A. and Kernighan, B.W. The Go Programming Language. Addison-Wesley, USA (2015).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dorward, S., Pike, R., and Winterbottom, P. Programming in Limbo. In IEEE COMPCON 97 Proceedings (1997), 245–250.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Geissmann, L.B. Separate compilation in Modula-2 and the structure of the Modula-2 compiler on the personal computer Lilith. Ph.D. dissertation. Swiss Federal Institute of Technology (1983), https://www.cfbsoftware.com/modula2/ETH7286.pdf.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gerrand, A. Go fmt your code. The Go Blog (2013), https://go.dev/blog/gofmt.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go Project. Setting up and using gccgo. (2009), https://go.dev/doc/install/gccgo.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go Project. Go 1 and the future of Go programs. (2012), https://go.dev/doc/go1compat.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go Project. Gollvm, an LLVM-based Go compiler. (2017), https://go.googlesource.com/gollvm/.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go Project. The Go programming language specification. (2021), https://go.dev/ref/spec.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hoare, C.A.R. Communicating Sequential Processes. Prentice-Hall, Inc., USA (1985).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hockman, K. Go Module Proxy: Life of a query. Presented at GopherCon 2019, https://www.youtube.com/watch?v=KqTySYYhPUE&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hudson, R.L. Getting to Go: The journey of Go’s garbage collector. The Go Blog (2018), https://go.dev/blog/ismmkeynote.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Klabnik, S. and Nichols, C. The Rust Programming Language. No Starch Press, USA (2018).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lam, A. Using remote cache service for Bazel. Communications of the ACM 62, 1 (Dec. 2018), 38–42.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ousterhout, J. Why threads are a bad idea (for most purposes). (1995), https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pike, R. The implementation of Newsqueak. Software: Practice and Experience 20, 7 (1990), 649–659.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pike, R., Dorward, S., Griesemer, R., and Quinlan, S. Interpreting the data: Parallel analysis with Sawzall. Scientific Programming Journal 13 (2005), 277–298.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Preston-Werner, T. Semantic versioning 2.0.0. (2013), https://semver.org/&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Serebryany, K., Potapenko, A., Iskhodzhanov, T., and Vyukov, D. Dynamic race detection with LLVM compiler: Compile-time instrumentation for ThreadSanitizer. In Runtime Verification, S. Khurshid, and K. Sen (Eds.). Springer Berlin Heidelberg, Berlin, Heidelberg (2012), 110–114.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Stambler, R. Go, pls stop breaking my editor. Presented at GopherCon 2019, https://www.youtube.com/watch?v=EFJfdWzBHwE.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Symonds, D., Tao, N., and Gerrand, A. Go and Google App Engine. The Go Blog (2011), https://go.dev/blog/appengine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Winterbottom, P. Alef language reference manual. In Plan 9: Programmer’s Manual Volume 2. Harcourt Brace and Co., New York (1996).&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;作者(Authors)&lt;/h3&gt;
&lt;p&gt;Russ Cox (rsc@go.dev), Robert Griesemer, Rob Pike, Ian Lance Taylor, and Ken Thompson作为美国加州山景城的谷歌公司的软件工程师创造了Go编程语言和环境。Cox、Griesemer和Taylor继续在Google领导Go项目，而Pike和Thompson已经退休了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;https://wx.zsxq.com/dweb2/index/group/51284458844544&quot;&gt;“Gopher部落”知识星球&lt;/a&gt;旨在打造一个精品Go学习和进阶社群！高品质首发Go技术文章，“三天”首发阅读权，每年两期Go语言发展现状分析，每天提前1小时阅读到新鲜的Gopher日报，网课、技术专栏、图书内容前瞻，六小时内必答保证等满足你关于Go语言生态的所有需求！2022年，Gopher部落全面改版，将持续分享Go语言与Go应用领域的知识、技巧与实践，并增加诸多互动形式。欢迎大家加入！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.tonybai.com/img/tonybai/gopher-tribe-zsxq-small-card.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;http://image.tonybai.com/img/tonybai/go-programming-from-beginner-to-master-qr.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.tonybai.com/img/tonybai/go-first-course-banner.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;http://image.tonybai.com/img/tonybai/imooc-go-column-pgo-with-qr.jpg&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;br/&gt;
&lt;img src=&quot;http://image.tonybai.com/img/tonybai/imooc-k8s-practice-with-qr.jpg&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://51smspush.com/&quot;&gt;我爱发短信&lt;/a&gt;：企业级短信平台定制开发专家 https://51smspush.com/。smspush : 可部署在企业内部的定制化短信平台，三网覆盖，不惧大并发接入，可定制扩展； 短信内容你来定，不再受约束, 接口丰富，支持长短信，签名可选。2020年4月8日，中国三大电信运营商联合发布《5G消息白皮书》，51短信平台也会全新升级到“51商用消息平台”，全面支持5G RCS消息。&lt;/p&gt;
&lt;p&gt;著名云主机服务厂商DigitalOcean发布最新的主机计划，入门级Droplet配置升级为：1 core CPU、1G内存、25G高速SSD，价格5$/月。有使用DigitalOcean需求的朋友，可以打开这个&lt;a href=&quot;https://m.do.co/c/bff6eed92687&quot;&gt;链接地址&lt;/a&gt;：https://m.do.co/c/bff6eed92687 开启你的DO主机之路。&lt;/p&gt;
&lt;p&gt;Gopher Daily(Gopher每日新闻)归档仓库 – https://github.com/bigwhite/gopherdaily&lt;/p&gt;
&lt;p&gt;我的联系方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微博：https://weibo.com/bigwhite20xx&lt;/li&gt;
&lt;li&gt;微信公众号：iamtonybai&lt;/li&gt;
&lt;li&gt;博客：tonybai.com&lt;/li&gt;
&lt;li&gt;github: https://github.com/bigwhite&lt;/li&gt;
&lt;li&gt;“Gopher部落”知识星球：https://public.zsxq.com/groups/51284458844544&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://image.tonybai.com/img/tonybai/iamtonybai-wechat-qr.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;
&lt;p&gt;© 2022, &lt;a href=&quot;https://tonybai.com&quot;&gt;bigwhite&lt;/a&gt;. 版权所有. &lt;/p&gt;
&lt;p&gt;Related posts:&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2021/10/06/the-go-programming-language-and-environment/&quot; rel=&quot;bookmark&quot; title=&quot;Go语言之父谈Go编程语言与环境&quot;&gt;Go语言之父谈Go编程语言与环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2020/11/04/the-recommend-books-list-for-learning-go/&quot; rel=&quot;bookmark&quot; title=&quot;系统学习Go语言，有这几本书就够了！&quot;&gt;系统学习Go语言，有这几本书就够了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2019/05/03/go-is-on-a-trajectory-to-become-the-next-enterprise-programming-language/&quot; rel=&quot;bookmark&quot; title=&quot;Go正走在成为下一个企业级编程语言的轨道上&quot;&gt;Go正走在成为下一个企业级编程语言的轨道上&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2017/10/24/go-evolution-for-ten-years-an-interview-by-osc/&quot; rel=&quot;bookmark&quot; title=&quot;源创会开源访谈：十年成长，Go语言的演化之路&quot;&gt;源创会开源访谈：十年成长，Go语言的演化之路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2017/09/24/go-ten-years-and-climbing/&quot; rel=&quot;bookmark&quot; title=&quot;Go语言：成长的十年&quot;&gt;Go语言：成长的十年&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f79bc780e22524d5af8f1b0ae03c23c</guid>
<title>如何用 Java 实现一致性 hash 算法 (consistent hashing)（上）</title>
<link>https://toutiao.io/k/zcezqpo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content clearfix&quot;&gt;
        
        
                &lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-tomorrow-night&quot;&gt;
                    &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
                        &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5,0 0,2.5 5,5z&quot; id=&quot;raphael-marker-block&quot;/&gt;
                    &lt;/svg&gt;
                    &lt;h3&gt;&lt;a id=&quot;hash_0&quot;/&gt;一致性hash的历史&lt;/h3&gt; 
&lt;p&gt;【Consistent Hashing算法】早在 1997 年就在论文 Consistent hashing and random trees 中被提出，目前在 cache 系统中应用越来越广泛；&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;hash_4&quot;/&gt;一致性hash的目的&lt;/h3&gt; 
&lt;p&gt;一致性哈希算法是分布式系统中常用的算法，一致性哈希算法解决了普通余数Hash算法伸缩性差的问题，可以保证在上线、下线服务器的情况下尽量有多的请求命中原来路由到的服务器。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_8&quot;/&gt;问题背景&lt;/h3&gt; 
&lt;p&gt;业务开发中，我们常把数据持久化到数据库中，如果需要读取这些数据，除了直接从数据库中读取外，为了减轻数据库的访问压力以及提高访问速度，更多地引入缓存来对数据进行存取。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;_12&quot;/&gt;分布式缓存&lt;/h3&gt; 
&lt;p&gt;分布式缓存，不同机器上存储不同对象的数据。为了实现这些缓存机器的负载均衡，一般就会存在两种Hash算法进行均匀分配数据节点存储：普通Hash算法&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Hash_16&quot;/&gt;普通的Hash算法的&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;Hash_18&quot;/&gt;Hash取模做法的缺陷&lt;/h4&gt; 
&lt;p&gt;一个Redis集群中，如果我们把一条数据经过Hash，然后再根据集群节点数取模得出应该放在哪个节点，这种做法的缺陷在于：扩容(增加一个节点)之后，有大量缓存失效。&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;Hash_22&quot;/&gt;普通Hash的案例分析&lt;/h4&gt; 
&lt;p&gt;比如你有 N 个 cache 服务器（后面简称 cache ），那么如何将一个对象 object 映射到 N 个 cache 上呢，你很可能会采用类似下面的通用方法计算 object 的 hash 值，然后均匀的映射到到 N 个 cache ；&lt;/p&gt; 
&lt;pre&gt;&lt;code&gt;hash(object)%N 
&lt;/code&gt;&lt;/pre&gt; 
&lt;p&gt;一切都运行正常，再考虑如下的两种情况；&lt;/p&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;一个 cache 服务器 m down 掉了（在实际应用中必须要考虑这种情况），这样所有映射到 cache m 的对象都会失效，怎么办，需要把 cache m 从 cache 中移除，这时候 cache 是 N-1 台，映射公式变成了 hash(object)%(N-1) ；&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;由于访问加重，需要添加 cache ，这时候 cache 是 N+1 台，映射公式变成了 hash(object)%(N+1) ；&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;这意味着突然之间几乎所有的 cache 都失效了。对于服务器而言，这是一场灾难，洪水般的访问都会直接冲向后台服务器；（造成缓存雪崩机制）&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/630daeb47f55c834998ff223edd3b962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Hash_40&quot;/&gt;一致性Hash算法&lt;/h3&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;一致性hash算法正是为了解决此类问题的方法，它可以保证当机器增加或者减少时，对缓存访问命中的概率影响减至很小。下面我们来详细说一下一致性hash算法的具体过程。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;ul&gt;&lt;li&gt; &lt;p&gt;一致性hash算法通过一个叫作一致性hash环的数据结构实现。这个环的起点是0，终点是2^32 - 1，并且起点与终点连接，环的中间的整数按逆时针分布，故这个环的整数分布范围是[0, 2^32-1]&lt;/p&gt; &lt;/li&gt;&lt;li&gt; &lt;p&gt;整个哈希值空间组织成一个虚拟的圆环，将节点的IP地址或主机名作为关键字进行哈希计算，得出的结果作为节点在环上的位置。数据经过hash后按顺时针方向找到最近一个节点存放，如图data的hash位置，应该存放在node2。&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5c52e347ec775107e3ff9a8a3f4b05c3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
 
&lt;h3&gt;&lt;a id=&quot;Hash_54&quot;/&gt;改良版一致性Hash算法&lt;/h3&gt; 
&lt;h4&gt;&lt;a id=&quot;Hash___56&quot;/&gt;一致性Hash算法 + 虚拟节点&lt;/h4&gt; 
&lt;p&gt;为了解决数据分布不均的问题，我们引入虚拟节点的概念。我们对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。定位到虚拟节点的数据就存到该虚拟节点对应的真实节点上，这样数据分布就相对均匀了，虚拟节点数越多，分布越均匀。&lt;/p&gt; 
&lt;p&gt;引入“虚拟节点”后，映射关系就从 { 对象 -&amp;gt; 节点 } 转换到了 { 对象 -&amp;gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系&lt;/p&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/e8220e34bd5e99215199ec5828271951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;blockquote&gt; 
 &lt;p&gt;&lt;strong&gt;一般虚拟节点数32个以上，dubbo是160个。&lt;/strong&gt;&lt;/p&gt; 
&lt;/blockquote&gt; 
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/7dec7ba4b09e633d77c6684220b032e4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt; 
&lt;h4&gt;&lt;a id=&quot;_68&quot;/&gt;处理机器增减的情况&lt;/h4&gt; 
&lt;p&gt;对于线上的业务，增加或者减少一台机器的部署是常有的事情。&lt;/p&gt; 
&lt;p&gt;例如，增加机器c4的部署并将机器c4加入到hash环的机器c3与c2之间。这时，只有机器c3与c4之间的对象需要重新分配新的机器。对于我们的例子，只有对象o4被重新分配到了c4，其他对象仍在原有机器上。&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;Hash_75&quot;/&gt;一致性Hash算法的实现原理&lt;/h3&gt; 
&lt;p&gt;在业务开发中，我们常把数据持久化到数据库中。如果需要读取这些数据，除了直接从数据库中读取外，为了减轻数据库的访问压力以及提高访问速度，我们更多地引入缓存来对数据进行存取。读取数据的过程一般为：&lt;/p&gt; 
&lt;h3&gt;&lt;a id=&quot;JavaHash_79&quot;/&gt;Java代码实现Hash算法的实现&lt;/h3&gt; 
&lt;p&gt;用一个TreeMap来作为环，key为虚拟节点下标，value为真实节点的hash。个人感觉可以加一个Map&amp;lt;T, Set&amp;gt;来维护真实节点-虚拟节点的关系。&lt;/p&gt; 
&lt;pre&gt;&lt;code class=&quot;prism language-java&quot;&gt;
&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConsistentHash&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Serializable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;long&lt;/span&gt; serialVersionUID &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    
    &lt;span class=&quot;token class-name&quot;&gt;Hash32&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; hashFunc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SortedMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; circle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TreeMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConsistentHash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;numberOfReplicas &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hashFunc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; key &lt;span class=&quot;token operator&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HashUtil&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fnvHash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; node &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; nodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ConsistentHash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Hash32&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; hashFunc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; nodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;numberOfReplicas &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hashFunc &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hashFunc&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; node &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; nodes&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;put&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hashFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hash32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; node&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; numberOfReplicas&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;token operator&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hashFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hash32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;node&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Object&lt;/span&gt; key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; hash &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; hashFunc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hash32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;key&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token boolean&quot;&gt;false&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;containsKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hash&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;token class-name&quot;&gt;SortedMap&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; tailMap &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;tailMap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hash&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;   
            hash &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; tailMap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;isEmpty&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;firstKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; tailMap&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;firstKey&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
        
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hash&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
                &lt;/div&gt;
                
                
        &lt;/div&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b8f9fcdd8755de1c6e19688ad3743b30</guid>
<title>Linux 最常用命令：能解决 95% 以上的问题</title>
<link>https://toutiao.io/k/2q8zy8p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;操作系统概述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 操作系统安装&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 文件系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 命令操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 权限管理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 进程管理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 其他常用命令大全&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Linux 系统软件安装&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作系统概述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统 Operating System 简称 OS，通俗讲就是一款软件，不过和一般的软件不同，操作系统是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他的软件都必须在操作系统的支持下才能运行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 操作系统安装&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Linux 的安装看这篇——Linux的安装教程&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;https://blog.csdn.net/huaijiu123/article/details/82083452&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 文件系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/var&lt;/code&gt;：包含在正常操作中被改变的文件、假脱机文件、记录文件、加锁文件、临时文件和页格式化文件等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/home&lt;/code&gt;：包含用户的文件：参数设置文件、个性化文件、文档、数据、EMALL、缓存数据等，每增加一个用户，系统就会根据其用户名在 home 目录下新建和其他用户同名的文件夹，用于保存其用户配置。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/proc&lt;/code&gt;：包含虚幻的文件，他们实际上并不存在于磁盘上，也不占用任何空间（用 ls-l 可以显示它们的大小）当查看这些文件时，实际上是在访问存在内存中的信息，这些信息用于访问系统。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/bin&lt;/code&gt;：包含系统启动时需要的执行文件（二进制），这些文件可以被普通用户使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/etc&lt;/code&gt;：为操作系统的配置文件目录（防火墙、启动项）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/root&lt;/code&gt;：为系统管理员（也叫超级用户或根用户）的 Home 目录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;/dev&lt;/code&gt;：为设备目录，Linux 下设备被当成文件，这样一来硬件被抽象化、便于读写、网络共享以及需要临时装载到文件系统中，正常情况下，设备会有一个独立的子目录，这些设备的内容会出现在独立的子目录下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 命令操作&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看当前目录命令：&lt;code&gt;pwd&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;打开文件夹命令：&lt;code&gt;cd&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;打开指定文件夹：&lt;code&gt;cd [目录名称]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开当前用户的根目录：&lt;code&gt;cd ~&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回上级目录：&lt;code&gt;cd …&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回进入目录：&lt;code&gt;cd -&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打开根目录：&lt;code&gt;cd /&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;浏览目录下的文件列表命令：&lt;code&gt;ls&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;以列的方式查看当前目录下的文件列表：&lt;code&gt;ls -l&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查看当前目录下所有的文件（包括隐藏文件）：&lt;code&gt;ls -a&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;以列表的方式查看当前目录下的所有文件：&lt;code&gt;ls -la&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;创建文件目录命令：&lt;code&gt;mkdir&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;新建文件目录：&lt;code&gt;mkdir 文件夹名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归新建多级目录：&lt;code&gt;mkdir -p 文件夹名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;例如在用户目录下新建 test 目录，命令这样写：&lt;code&gt;mkdir -p test/test1/test2/test3&lt;/code&gt; 递归新建多级目录的写法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;删除文件目录命令：&lt;code&gt;rmkdir&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;删除指定目录：&lt;code&gt;rmkdir 目录名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;递归删除指定目录及中间目录：&lt;code&gt;rmdir -p 目录名称&lt;/code&gt; 这里没有写错，没有字母 k&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;删除文件或者目录命令：&lt;code&gt;rm&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;常用命令：&lt;code&gt;rm -rf [目录或文件]&lt;/code&gt; &lt;code&gt;rm -ri [目录或文件]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强制删除文件或目录：&lt;code&gt;rm -rf 目录或者文件&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在删除前询问是否确认删除：&lt;code&gt;rm -ri 目录或文件&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为强制删除的后果不太好，一般不建议使用 &lt;code&gt;rm -rf&lt;/code&gt; 进行文件删除&lt;/p&gt;&lt;p&gt;rm 命令中不跟 r 参数，无法删除目录，只能删除文件&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;复制文件或目录命令：&lt;code&gt;cp&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;递归复制目录1下的所有的文件和文件夹到目录2：&lt;code&gt;cp -r [目录1][目录2]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行复制操作时覆盖原有目录前询问用户：&lt;code&gt;cp -ri [目录1][目录2]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;移动文件、修改文件名命令：&lt;code&gt;mv&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将文件夹1名称更改为文件夹2：&lt;code&gt;mv 文件1 文件2&lt;/code&gt; (给文件更名)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将目录1的文件移动到目录2：&lt;code&gt;mv 目录2 目录2&lt;/code&gt; (将目录1的文件移动到目录2)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;创建文件命令：&lt;code&gt;touch&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看、编辑文件命令：&lt;code&gt;vi&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;vi 命令为 UNIX 操作系统或者类 UNIX 操作系统都有具有的功能强大的文件编辑命令，用户输入 vi ++ 文件名，便可以进入 vi 模式进行文件内容的查看和编辑，如果文件已经存在，则直接打开文件，如果文件不存在，则系统将打开一个全新的空文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vi 的三种模式如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;命令模式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户使用 vi 命令打开文件后，则进入命令模式，用户可以输入命令来执行各种功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.26140155728587317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAhuicP6icN2Z3pOgn9vOQ9FhiaSYG6SfJTEpvjjS7cFyTpHr6pQzshPOwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;899&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;输入模式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户要对文件做修改，则可以使用下面几种命令，进入输入模式，用户进入输入模式之后，可以任意修改文件，除了 Esc 键外，用户输入的任何字符都会被作为内容写入文件中，用户输入 Esc 可以对文件进行相关操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2203626220362622&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRA3IcL5vreJibBhZMJJk3dR43SKaiaC8LnCmIhCnCNeNgMXDDSNU2DfYmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;末行模式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户完成编辑命令，则可以按照 esc + “:” 进入末行模式，用户可以对文件内容继续进行搜索，也可以输入 “:wq!” 进行文件保存并退出，或者输入 “:q!” 强制退出文件编辑。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23696682464454977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRA1pv5MGYicSUfMnZkaTdTqvHAsuMZlSE25RkwqBGD9wH2KaPjm4h46Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看、编辑文件命令：&lt;code&gt;cat&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;显示一个小的文件的内容：&lt;code&gt;cat 文件名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建并打开一个新的文件：&lt;code&gt;cat &amp;gt; 文件名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看文件开头内容命令：&lt;code&gt;head&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，使用 head 命令显示某个文件开始的 n 行数据：&lt;code&gt;head -n 文件名称&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.147247119078105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAXgoqvUAiaiaSv1MgRwAbaQwLIeQe8GEhMmfOiaXIZYFZLAzzAVKKhFWnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看文件结尾内容命令：&lt;code&gt;tail&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;动态加载某个文件的内容（常用于查看日志文件）：&lt;code&gt;tail -f 文件名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;展示文件最后几行的数据：&lt;code&gt;tail -n 行数文件名称&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Linux 权限管理&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户和用户组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户是指在一个操作系统中，一系列权限的集合体，操作人员通过用户名和口令可以在系统中执行某一些被允许的操作。不同的用户可以具有不同的权限。Linux 操作系统中每个用户都具有唯一标识 UID，当使用命令创建用户时，如果不指定用户的 UID，则系统将自动为其分配 UID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户组就是具有相同特征的用户的集合体，在 Linux 系统中，每一个用户都属于至少一个用户组。Linux 操作系统中每个用户分组都具有唯一标识 GID，当使用命令创建用户组时，如果不指定用户组的 GID，则系统将自动为其分配 GID。当使用 -u 指定用户 id 时，用户 id 尽量大于500，以免冲突。因为 Linux 操作系统安装后，会默认建立一些用户，所以可能会占用 500 之内的 id 号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 权限机制有以下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;系统有一个权限最大的用户，其名称为 root ，root 用户属于 root 用户组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;系统默认只有 root 权限可以添加和删除用户。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;添加用户之后，如果没有给用户指定用户组，则系统会为用户添加一个同名的用户组，用户属于该组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;root 切换到普通用户无需登录，普通用户切换到 root 用户需要登陆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;root 可以给用户赋予和回收某一个文件的读、写、执行的权限。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;用户操作命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;切换用户命令：&lt;code&gt;su&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;su [用户名]&lt;/code&gt; 或者 &lt;code&gt;su -[用户名]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;su[用户名]&lt;/code&gt;和 &lt;code&gt;su -[用户名]&lt;/code&gt;都可以切换用户，前者类似于临时切换用户，当使用该命令进行切换新用户时，用户配置仍然沿用原来的用户配置，如环境变量、系统变量等。而后者进行切换用户时，环境变量、系统设置全部切换成新用户的用户配置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看当前登陆用户命令：&lt;code&gt;whoami&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看当前用户所属分组命令：&lt;code&gt;groups&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查看当前用户 UID 和 GID 命令：&lt;code&gt;id&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;添加新用户命令：&lt;code&gt;useradd&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32735961768219835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAAljfmvoqz0GlTTgRV6qopysxnicFibVrnxFr2pN2gproxnYiadaRicuSjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 操作系统中添加用户：&lt;code&gt;useradd 用户名&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 操作系统中添加用户并指定用户 UID：&lt;code&gt;useradd -u&lt;/code&gt; 指定的 UID 用户名&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修改用户密码命令：&lt;code&gt;passwd&lt;/code&gt;&lt;/strong&gt;例如：修改当前用户名为 sang 的用户密码：&lt;code&gt;passwd sang&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加用户之后，只有为其设置密码，用户才能登陆&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3411619283065513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRATetM0PqJcdSFUnf5ibhgKt4jxGcnnibQkl3qBfqYL4EIHHWfqgItibIUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;809&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;删除用户命令：&lt;code&gt;userdel&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;删除用户：&lt;code&gt;userdel 用户名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除用户并同时删除其登陆信息：&lt;code&gt;userdel -r 用户名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18951132300357568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAm4Ik1Wic2XtARX9MpxZJtJX8nACCyEfGSNo2clgCT9qFRxMMkj21VoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;839&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;修改用户信息命令：&lt;code&gt;usermod&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语法：&lt;code&gt;usermod [选项] [参数] [用户名]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改用户登录名：&lt;code&gt;usermod -l 新用户名 旧用户名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改用户所属分组：&lt;code&gt;usermod -g 新组名称 用户名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5017543859649123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAenicHeVwwKqSPO88vHnAhfZT7x9V7GINN5L8RgE6pf23RaOZ4Z76uLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;855&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;添加用户组命令：&lt;code&gt;groupadd&lt;/code&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语法：&lt;code&gt;groupadd [选项] [组名称]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改用户登陆名：&lt;code&gt;groupadd 组名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改用户所属分组：&lt;code&gt;groupadd -g 组 GID 组名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25224071702944945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAzRQWzicFTXjiayCTxsic2r3s9gjZr8BnibvwSODBicySnGCODwZJZ2pXV5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;权限操作&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 操作系统为文件定义了读、写、执行三种权限，不同的用户或者用户组可以具有不同的权限，系统采用 “r”、“w”、“x” 来分别表示文件的读、写、执行权限。使用 ls -l 命令可以查看到用户在当前目录或者文件的操作权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举列：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;drwxr -xr -x. 2 root root 4096 Sep 23 2011 bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从左至右分别表示如下含义：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;d&lt;/code&gt;：代表 bin 数目目录而不是文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;rwx&lt;/code&gt;：代表拥有者具有读、写、执行的权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;r -x&lt;/code&gt;：代表同组用户具有读、执行的权限，但是没有写权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;r -x&lt;/code&gt;：代表其他组用户具有读、执行权限，没有写权限&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的变更权限命令为：&lt;code&gt;chmod&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;语法：&lt;code&gt;chmod [选项] [参数]&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.24408468244084683&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAlGK1zvGzibmnP92LLEibGhcZyjBGInDANKsQeKhMxicOUrvqB0uIS9iaIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chmod 的参数可以分为两种，分别是权限模式和数字模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;权限模式：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限模式使用 u、g、o 分别代表拥有者、同组用户、其他组用户，使用 + 和一代表赋予和收回权限，使用 r、w、x 代表读、写、执行权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：将文件01的执行权限给当前用户，写权限赋给用户所在的用户组和其他用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod -r U+X,G+W F01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：将文件 f01 的读、写、执行的权限赋给当前用户，将读、写权限赋给用户所在的用户组和其他用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod -r u=rwx,g=rw,o=rw f01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数字模式：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了简化授权步骤，用户也可以采用数字模式进行授权，使用二进制的形式代表 r、w、x 三种权限，如 &lt;code&gt;101 (5) =r -x&lt;/code&gt;，&lt;code&gt;111 (7) =rwx&lt;/code&gt;，&lt;code&gt;100 (3) =r- -&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：将文件 f01 的读、写、执行的权限赋给当前用户，将读和执行权限赋给用户组、将写和执行权限赋给其他用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod 753 -r f01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：将文件 f01 的读、写、执行权限赋给所有用户。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod 777 -r f01&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 进程管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 的应用中，我们需要对进程进行管理，如查看某个进程是否启动、以及在必要的时刻，杀掉某个线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps 命令是 Linux 操作系统中查看进程的命令，通过 ps 命令我们可以查看 Linux 操作系统中正在运行的过程，并可以获得进程的 PID（进程的唯一标识），通过 PID 可以对进程进行相应的管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ps -ef | grep [进程关键字]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据进程关键词查看进程命令显示如下，显示的进程列表中第一列表示开启进程的用户，第二列表示进程唯一标识 PID，第三列表示父进程 PPID，第四列表示 CPU 占用资源比列，最后一列表示进程所执行程序的具体位置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[shang@localhost ~]$ ps -ef|grep sshd&lt;br/&gt;root 1829 1  0 May24 ?   00:00:00 /usr/sbin/sshd&lt;br/&gt;shang 24166 24100  0   20:17 pts/2  00:00:00      grep  sshd&lt;br/&gt;[shang@localhost ~]$&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统中有进程进入死循环，或者需要被关闭时，我们可以使用 kill 命令对其关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;kill -9 [PID]&lt;/code&gt; PID 为 Linux 操作系统中进程的标识&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 其他常用命令大全&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;清屏命令：clear&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查询命令详细参数命令：man&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;挂载命令：mnt&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远程连接服务 SSH 相关命令：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动 SSH 服务命令：&lt;code&gt;service sshd start&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重启 SSH 服务命令：&lt;code&gt;service sshd restart&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关闭 SSH 服务命令：&lt;code&gt;service sshd stop&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 大多数情况下都是远程服务器，开发者通过远程工具连接 Linux ，启动了某个项目的 JAR，一旦窗口关闭，JAR 也就停止运行了，因此一般通过如下命令启动 JAR：&lt;code&gt;nohup java -jar jar-0.0.1-SNAPSHOT.jar &amp;amp;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里多了 nohup ，表示当前窗口关闭时服务不挂起，继续在后台运行&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 系统软件安装&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用软件安装&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 下常用的软件安装方式有3种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;tar 安装&lt;/strong&gt;：如果开发商提供的是 tar、tar.gz、tar.bz 格式的包（其中 tar 格式的为打包后没有压缩的包，gz 结尾的是按照 gzip 打包并压缩的软件包，tar.bz 是按照二进制方式打包并压缩的软件包），可以采用 tar 包安装，tar 安装方式本质上是解压软件开发商提供的软件包，之后在通过相应配置，完成软件的安装。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;rpm 安装&lt;/strong&gt;：rpm 安装方式是 redhat Linux 系列推出的一个软件包管理器，类似于 Windows 下的 exe 安装程序，可以直接使用 rpm 命令安装。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;yum 安装&lt;/strong&gt;：yum 安装本质上依然是 rpm 包安装，和 rpm 安装方式的不同之处是用户可以通过 yum 参数，指定安装的软件包，系统将自动从互联网上下载相应的 rpm 软件包。而无须用户关心软件包的下载地址，以及软件包的依赖关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件安装常用命令&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;解压压缩命令：&lt;code&gt;tar&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;语法：&lt;code&gt;tar [选项] [压缩包]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解压 gzip 包：&lt;code&gt;tar -zxvf [包名]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解压 bz 包：&lt;code&gt;tar -jxvf [包名]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解压普通包：&lt;code&gt;tar -xvf [包名]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.533498759305211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRA2Eibiak8oCrCXafbcjDzWhbUINefxh8Duib8b9ib71TDhmFN9mrpoJRdrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;安装卸载命令：rpm&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;语法：&lt;code&gt;rpm [选项] [软件包]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查询是否已经安装了某软件包：&lt;code&gt;rpm -qa|grep [软件包关键词]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;卸载已经安装的软件包：&lt;code&gt;rpm -e 软件包全名&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安装软件包并查看进度：&lt;code&gt;rpm -ivh 软件包路径&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4280532043530834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufEQTRibHEQJMC2IfHT3YmRAb1icG3HB87Ox6bAq3uKNn2icc6G4gRE70L861YzphEyT8rSfmIph2jHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;827&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa78302f321d2e8611a0ab96f708d0af</guid>
<title>软件架构的 23 个基本原则</title>
<link>https://toutiao.io/k/9c0uz2q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件体系架构基于一组适用于各种软件系统的基本原则，有经验的架构师知道这些原则，并且能够在软件产品的正确位置实现特定的原则。下面我们快速浏览一下架构师日常遵循的基本原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 依赖倒置（Dependency Inversion）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一原则表明依赖的方向应该是抽象的，而不是具体实现。如果编译时依赖在运行时执行的方向上流动，就形成了直接依赖。通过依赖倒置，可以反转依赖控制的方向。下面的文章更深入的讨论了这一原则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/p/de6abf20e423&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 关注点分离（Separation of Concerns）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一原则指出，软件系统应该按照所做的工作类型来划分。比方说可以按照业务逻辑、基础设施或用户界面划分为不同的部分。通过将系统划分为基于不同活动区域的不同部分，使得开发/测试/部署更加容易。SoC是软件架构模式（如领域驱动设计、六边形架构、整洁架构）背后的驱动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3. 控制反转（Inversion of Control）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该原则类似于依赖倒置原则，但适用于更广泛的背景。IoC反转了由不同的第三方框架（如Spring Framework）管理的控制流。与传统Java EE程序（由开发工程师按程序初始化Beans）不同，Spring控制Bean的配置，这意味着控制倒置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4. 依赖注入（Dependency Injection）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该原则意味着依赖应该在运行时通过构造函数注入。在下面的例子中，Action Interface通过HumanAction Implementation注入到Human类中，从而决定在运行时实现哪个特定的动作。这种技术提供了控制依赖的灵活性：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; az.alizeynalli.di;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Action&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HumanAction&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Action&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.print(&lt;span&gt;&quot;run&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;     &lt;br/&gt;    Action action;&lt;br/&gt;     &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Human&lt;/span&gt;&lt;span&gt;(Action action)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.action = action;&lt;br/&gt;    }&lt;br/&gt; &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{        &lt;br/&gt;        actoin.&lt;span&gt;do&lt;/span&gt;();        &lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Human human = &lt;span&gt;new&lt;/span&gt; Human(&lt;span&gt;new&lt;/span&gt; HumanAction);&lt;br/&gt;        human.&lt;span&gt;do&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5. 单一职责（Single Responsibility）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该原则的主要思想是限定软件系统的每个构建块只承担唯一的责任。无论构建块的作用域是什么，是插件、包、类、函数，甚至是变量，应该只有一个职责。这篇文章更深入的讨论了这一原则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/p/6b886f6d943e&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;6. DRY（Don’t Repeat Yourself）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该原则旨在通过避免重复代码来消除冗余。如果存在针对某些行为的现有功能，则应该重复使用，而不是在多个实例中拷贝相同的代码片段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个知识片段在系统中都必须有单一、明确、权威的表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;7. 开闭原则（Open-Closed）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件构件应该对扩展开放，对修改关闭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一原理的简单描述首先是由Bertrand Meyer提出的。每次都需要修改的软件系统只会变得一团糟，并且这种混乱的程序很容易在每次修改时出现错误。每个新功能都应该最大限度的增加新代码，最小限度减少旧代码的更改，理想情况下对旧代码的更改为零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;8. 持久化透明（Persistence Ignorance）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;持久化透明的理念是，代码应该不受任何数据库或持久性技术的影响。业务逻辑应该与任何技术无关。如果明天，有更好、更有效、更便宜的持久化技术，应该能够以不影响上层抽象的方式改变系统的这一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;9. YAGNI&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;You ain’t gonna need it. 这一原则试图避免软件系统的过早优化。开发人员通常会在系统中过度设计一些东西，以期在将来的某个时候会有帮助，但这一时刻往往不会到来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;10. 童子军规则（Boy Scout Rule）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在离开的时候要让露营地比来的时候更干净。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的主要思想是，当开发时遇到反模式，要坚持重构代码。随着时间的推移，这会提高代码质量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;11. 里氏替换原则（Liskov-Subsititution）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对于每个类型为S的对象o1，都有一个类型为T的对象o2，这样对于用T定义的所有程序P，当o1取代o2时，P的行为不变，那么S就是T的子类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Barbara Liskov的这个定义可能听起来很混乱，但本质上这个原则简单易懂。如果重述上面的定义，该原则的意思是: 在使用继承时，继承的层次结构应该在功能和业务逻辑方面保持一致。子类应该是可以相互替换的，并且不能改变父类的行为。作为一个简单的例子，可以用“臭名昭著的正方形/矩形”问题。其中正方形不应该是矩形的子类型，因为这两个几何形状的高度和长度的定义是不同的（正方形的高度和长度是相等的，而矩形的高度和长度是不同的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;12. 封装（Encapsulation）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件系统的不同构建块应该通过封装来限制外界对其组件的访问，可以通过在类范围内设置组件为私有或在插件范围内设置访问限制来实现（就Java而言），从而隐藏信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;13. 松耦合（Loose Coupling）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件架构中最重要的原则之一是松耦合，这一原则表明软件系统的依赖关系应该松散，系统的一部分发生变化，对其他部分的影响应该最小。松耦合可以通过依赖倒置、异步消息中间件、事件源等实现。下面的文章深入探讨了软件工程中不同形式的耦合：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/p/4d5cf2b3e99e&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;14. 内聚（Cohesion）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内聚是指模块内的元素依赖的程度。某种意义上说，是对类的方法和数据以及该类所服务的某种统一目的或概念之间关系强度的度量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构建高内聚的类是一种最佳实践，有利于实现单一责任原则、松耦合等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;15. 接口隔离（Interface Segregation）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口隔离原则指出，不应强迫客户端依赖不使用的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该明确的是，这个原则主要适用于静态类型的编程语言，如Java、C等。在像Python或Ruby这样的动态类型语言中，这个原则没有太大意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以想象这样一种情况，我们的Income和Expense用例都依赖于支持这两种用例的业务逻辑功能。因此Income用例的很多依赖都和Expense用例相关，而Expense用例的依赖情况也有相同的问题。基于以上讨论，ISP违规情况如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; az.alizeynalli.cashflow.core.service;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConverterService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Income &lt;span&gt;convertIncome&lt;/span&gt;&lt;span&gt;(Income income)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;Expense &lt;span&gt;convertExpense&lt;/span&gt;&lt;span&gt;(Expense expense)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExpenseConverterServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConverterService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Income &lt;span&gt;convertIncome&lt;/span&gt;&lt;span&gt;(Income income)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Expense &lt;span&gt;convertExpense&lt;/span&gt;&lt;span&gt;(Expense expense)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// convert expense here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; expense;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;IncomeConverterServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ConverterService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Income &lt;span&gt;convertIncome&lt;/span&gt;&lt;span&gt;(Income income)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// convert income here&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; income;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Expense &lt;span&gt;convertExpense&lt;/span&gt;&lt;span&gt;(Expense expense)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;16. 限界上下文（Bounded Context）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;限界上下文是领域驱动设计的中心模式。通过将大型应用程序或组织分解为单独的概念模块，提供了一种处理复杂性的方法。每个概念模块代表一个上下文，该上下文与其他上下文分离（因此是有边界的），并且可以独立发展。理想情况下，每个限界上下文应该可以自由的为其中的概念选择自己的名称，并且应该独占的访问自己的持久化存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;17. 依赖稳定原则（Stable Dependencies）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一原则指出，软件系统的不同构建块应该只依赖于可靠、稳定的工件。这个原则在Docker镜像术语中更有意义，当我们从docker hub导入不同的依赖时，甚至不知道它们是否可靠/稳定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;18. 多态（Polymorphism）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这实际上属于面向对象编程的4大支柱，鼓励使用可以以多种形式提供的接口，多态性意味着具有多种形式的实体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;19. 模块化（Modularization）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模块化是将软件系统划分为多个独立模块的过程，每个模块独立工作。这一原则是应用于软件系统静态架构的单一职责分离原则的另一种形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;20. 抽象（Abstraction）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也属于面向对象编程的四大支柱:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在研究物体或系统时去除物理的、空间的或时间的细节或属性以集中注意力于更重要的部分，本质上与泛化过程相似。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;21. KISS（Keep It Simple, Stupid）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照字面意思理解，这一原则激励工程师保持代码简单和愚蠢（容易理解），避免他人误解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;22. 增量/迭代方法（Incremental/Iterative Approach）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一原则是敏捷软件开发宣言的基础，基于软件系统应该以增量和迭代的方式开发的思想，每一次迭代都会增加系统功能并保证其运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;23. 最少知识原则（Least Knowledge）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者叫信息嫉妒（information envying），是封装或信息隐藏原则的另一个术语，规定软件系统的不同部分应该只拥有需要的知识。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>