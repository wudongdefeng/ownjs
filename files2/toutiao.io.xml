<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9f1bc383f94dbc5f5b6e5cac9fa06e0d</guid>
<title>新来个技术总监，仅花 2 小时，撸出一个多线程永动任务，看完直接跪了，真牛逼</title>
<link>https://toutiao.io/k/6u3q7ke</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;今天教大家撸一个 Java 的多线程永动任务，&lt;/span&gt;&lt;strong&gt;这个示例的原型是公司自研的多线程异步任务项目&lt;/strong&gt;&lt;span&gt;，我把里面涉及到多线程的代码抽离出来，然后进行一定的改造。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面涉及的知识点非常多，特别适合有&lt;strong&gt;一定工作经验&lt;/strong&gt;的同学学习，或者可以直接拿到项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章结构非常简单：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5484261501210653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLFO4ibj0RiaKXib9VLSJxTaWCGyibRQyudY2hg9UV61hvpUE2KrlsEX7mvAVn4KMqyyqn0evPn8gZPHNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1652&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 功能说明&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做这个多线程异步任务，主要是因为我们有很多永动的异步任务，什么是永动呢？就是&lt;strong&gt;任务跑起来后，需要一直跑下去。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如消息 Push 任务，因为一直有消息过来，所以需要一直去消费 DB 中的未推送消息，就需要整一个 Push 的永动异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的需求其实不难，简单总结一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;能同时执行多个永动的异步任务&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个异步任务，支持开&lt;strong&gt;多个线程&lt;/strong&gt;去消费这个任务的数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持永动异步任务的&lt;strong&gt;优雅关闭&lt;/strong&gt;，即关闭后，需要把所有的数据消费完毕后，再关闭。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完成上面的需求，需要注意几个点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每个&lt;strong&gt;永动任务&lt;/strong&gt;，可以开一个线程去执行；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个&lt;strong&gt;子任务&lt;/strong&gt;，因为需要支持并发，需要用线程池控制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;永动任务的关闭，需要通知子任务的并发线程，并&lt;strong&gt;支持永动任务和并发子任务的优雅关闭&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 多线程任务示例&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 线程池&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于子任务，需要支持并发，如果每个并发都开一个线程，用完就关闭，对资源消耗太大，所以引入线程池：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TaskProcessUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 每个任务，都有自己单独的线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, ExecutorService&amp;gt; executors = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 初始化一个线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(String poolName, &lt;span&gt;int&lt;/span&gt; poolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(poolSize, poolSize,&lt;br/&gt;                &lt;span&gt;0L&lt;/span&gt;, TimeUnit.MILLISECONDS,&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ThreadFactoryBuilder().setNameFormat(&lt;span&gt;&quot;Pool-&quot;&lt;/span&gt; + poolName).setDaemon(&lt;span&gt;false&lt;/span&gt;).build(),&lt;br/&gt;                &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor.CallerRunsPolicy());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取线程池&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;span&gt;getOrInitExecutors&lt;/span&gt;&lt;span&gt;(String poolName,&lt;span&gt;int&lt;/span&gt; poolSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = executors.get(poolName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == executorService) {&lt;br/&gt;            &lt;span&gt;synchronized&lt;/span&gt; (TaskProcessUtil&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                executorService = executors.get(poolName);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; == executorService) {&lt;br/&gt;                    executorService = init(poolName, poolSize);&lt;br/&gt;                    executors.put(poolName, executorService);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; executorService;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 回收线程资源&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;releaseExecutors&lt;/span&gt;&lt;span&gt;(String poolName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ExecutorService executorService = executors.remove(poolName);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (executorService != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            executorService.shutdown();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个线程池的工具类，这里初始化线程池和回收线程资源很简单，我们主要讨论获取线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取线程池可能会存在并发情况，所以需要加一个 synchronized 锁，然后锁住后，需要对 executorService 进行二次判空校验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 单个任务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好讲解单个任务的实现方式，我们的任务主要就是把 Cat 的数据打印出来，Cat 定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String catName;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Cat &lt;span&gt;setCatName&lt;/span&gt;&lt;span&gt;(String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.catName = name;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个任务主要包括以下功能：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;获取永动任务数据&lt;/strong&gt;：这里一般都是扫描 DB，我直接就简单用 queryData() 代替。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;多线程执行任务&lt;/strong&gt;：需要把数据拆分成 4 份，然后分别由多线程并发执行，这里可以通过线程池支持；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;永动任务优雅停机&lt;/strong&gt;：当外面通知任务需要停机，需要执行完剩余任务数据，并回收线程资源，退出任务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;永动执行&lt;/strong&gt;：如果未收到停机命令，任务需要一直执行下去。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接看代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChildTask&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; POOL_SIZE = &lt;span&gt;3&lt;/span&gt;; &lt;span&gt;// 线程池大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SPLIT_SIZE = &lt;span&gt;4&lt;/span&gt;; &lt;span&gt;// 数据拆分大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String taskName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 接收jvm关闭信号，实现优雅停机&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; terminal = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ChildTask&lt;/span&gt;&lt;span&gt;(String taskName)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.taskName = taskName;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 程序执行入口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doExecute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;            System.out.println(taskName + &lt;span&gt;&quot;:Cycle-&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;-Begin&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;// 获取数据&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Cat&amp;gt; datas = queryData();&lt;br/&gt;            &lt;span&gt;// 处理数据&lt;/span&gt;&lt;br/&gt;            taskExecute(datas);&lt;br/&gt;            System.out.println(taskName + &lt;span&gt;&quot;:Cycle-&quot;&lt;/span&gt; + i + &lt;span&gt;&quot;-End&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (terminal) {&lt;br/&gt;                &lt;span&gt;// 只有应用关闭，才会走到这里，用于实现优雅的下线&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            i++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 回收线程池资源&lt;/span&gt;&lt;br/&gt;        TaskProcessUtil.releaseExecutors(taskName);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 优雅停机&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;terminal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 关机&lt;/span&gt;&lt;br/&gt;        terminal = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        System.out.println(taskName + &lt;span&gt;&quot; shut down&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doProcessData&lt;/span&gt;&lt;span&gt;(List&amp;lt;Cat&amp;gt; datas, CountDownLatch latch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Cat cat : datas) {&lt;br/&gt;                System.out.println(taskName + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + cat.toString() + &lt;span&gt;&quot;,ThreadName:&quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;br/&gt;                Thread.sleep(&lt;span&gt;1000L&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.out.println(e.getStackTrace());&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (latch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                latch.countDown();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 处理单个任务数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;taskExecute&lt;/span&gt;&lt;span&gt;(List&amp;lt;Cat&amp;gt; sourceDatas)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(sourceDatas)) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 将数据拆成4份&lt;/span&gt;&lt;br/&gt;        List&amp;lt;List&amp;lt;Cat&amp;gt;&amp;gt; splitDatas = Lists.partition(sourceDatas, SPLIT_SIZE);&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; CountDownLatch latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(splitDatas.size());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 并发处理拆分的数据，共用一个线程池&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; List&amp;lt;Cat&amp;gt; datas : splitDatas) {&lt;br/&gt;            ExecutorService executorService = TaskProcessUtil.getOrInitExecutors(taskName, POOL_SIZE);&lt;br/&gt;            executorService.submit(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    doProcessData(datas, latch);&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            latch.await();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.out.println(e.getStackTrace());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取永动任务数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Cat&amp;gt; &lt;span&gt;queryData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Cat&amp;gt; datas = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) {&lt;br/&gt;            datas.add(&lt;span&gt;new&lt;/span&gt; Cat().setCatName(&lt;span&gt;&quot;罗小黑&quot;&lt;/span&gt; + i));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; datas;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单解释一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;queryData&lt;/strong&gt;：用于获取数据，实际应用中其实是需要把 queryData 定为抽象方法，然后由各个任务实现自己的方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;doProcessData&lt;/strong&gt;：数据处理逻辑，实际应用中其实是需要把 doProcessData 定为抽象方法，然后由各个任务实现自己的方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;taskExecute&lt;/strong&gt;：将数据拆分成 4 份，获取该任务的线程池，并交给线程池并发执行，然后通过 latch.await() 阻塞。当这 4 份数据都执行成功后，阻塞结束，该方法才返回。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;terminal&lt;/strong&gt;：仅用于接受停机命令，这里该变量定义为 volatile，所以多线程内存可见；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;doExecute&lt;/strong&gt;：程序执行入口，封装了每个任务执行的流程，当 terminal=true 时，先执行完任务数据，然后回收线程池，最后退出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 任务入口&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接上代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LoopTask&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; List&amp;lt;ChildTask&amp;gt; childTasks;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initLoopTask&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        childTasks = &lt;span&gt;new&lt;/span&gt; ArrayList();&lt;br/&gt;        childTasks.add(&lt;span&gt;new&lt;/span&gt; ChildTask(&lt;span&gt;&quot;childTask1&quot;&lt;/span&gt;));&lt;br/&gt;        childTasks.add(&lt;span&gt;new&lt;/span&gt; ChildTask(&lt;span&gt;&quot;childTask2&quot;&lt;/span&gt;));&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;final&lt;/span&gt; ChildTask childTask : childTasks) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    childTask.doExecute();&lt;br/&gt;                }&lt;br/&gt;            }).start();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shutdownLoopTask&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!CollectionUtils.isEmpty(childTasks)) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (ChildTask childTask : childTasks) {&lt;br/&gt;                childTask.terminal();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String args[])&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;        LoopTask loopTask = &lt;span&gt;new&lt;/span&gt; LoopTask();&lt;br/&gt;        loopTask.initLoopTask();&lt;br/&gt;        Thread.sleep(&lt;span&gt;5000L&lt;/span&gt;);&lt;br/&gt;        loopTask.shutdownLoopTask();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个任务都开一个单独的 Thread，这里我初始化了 2 个永动任务，分别为 childTask1 和 childTask2，然后分别执行，后面 Sleep 了 5 秒后，再关闭任务，我们可以看看是否可以按照我们的预期优雅退出。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 结果分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;childTask1:Cycle-&lt;span&gt;0&lt;/span&gt;-Begin&lt;br/&gt;childTask2:Cycle-&lt;span&gt;0&lt;/span&gt;-Begin&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cycle-&lt;span&gt;0&lt;/span&gt;-End&lt;br/&gt;childTask2:Cycle-&lt;span&gt;1&lt;/span&gt;-Begin&lt;br/&gt;childTask1:Cycle-&lt;span&gt;0&lt;/span&gt;-End&lt;br/&gt;childTask1:Cycle-&lt;span&gt;1&lt;/span&gt;-Begin&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;4&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;0&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1 shut down&lt;br/&gt;childTask2 shut down&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;1&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;2&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask1&lt;br/&gt;childTask2:Cat(catName=罗小黑&lt;span&gt;3&lt;/span&gt;),ThreadName:Pool-childTask2&lt;br/&gt;childTask1:Cycle-&lt;span&gt;1&lt;/span&gt;-End&lt;br/&gt;childTask2:Cycle-&lt;span&gt;1&lt;/span&gt;-End&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;“Pool-childTask” 是线程池名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask” 是任务名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Cat(catName=罗小黑)” 是执行的结果；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask shut down” 是关闭标记；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“childTask:Cycle-X-Begin” 和“childTask:Cycle-X-End” 是每一轮循环的开始和结束标记。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分析一下执行结果：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;childTask1 和 childTask2 分别执行，在第一轮循环中都正常输出了 5 条罗小黑数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二轮执行过程中，我启动了关闭指令，这次第二轮执行没有直接停止，而是先执行完任务中的数据，再执行退出，所以完全符合我们的优雅退出结论。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 源码地址&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GitHub 地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https://github.com/lml200701158/java-study/tree/master/src/main/java/com/java/parallel/pool/ofc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 写在最后&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于这个经典的线程池使用示例，原项目是我好友&lt;/span&gt;&lt;strong&gt;一灰&lt;/strong&gt;&lt;span&gt;写的，技术水平对标阿里 P7，&lt;/span&gt;&lt;strong&gt;实现得也非常优雅，涉及的知识点非常多&lt;/strong&gt;&lt;span&gt;，非常值得大家学习。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ee6840568d33485a0f4fbec6c91809b</guid>
<title>如何优雅的解决线上问题？</title>
<link>https://toutiao.io/k/6u6eytw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;身为一个程序员，遇到线上问题那都是家常便饭的事儿。&lt;/p&gt;&lt;p&gt;如果你在深夜看到一群同事围在一起，他们是在共同探讨什么哲学问题么？非也，他们一定是遇到了线上BUG。&lt;/p&gt;&lt;p&gt;线上问题只要影响到了核心业务流程那便是事故，所以一旦事故发生，无论你在约会，还是周末打游戏，甚至是在睡觉，只要接到了来自公司的电话，那只能赶紧连上公司网络加班了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5036261079774376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCPVwHmVZXibnwXCNqe9ZGyQ9kzztrNiac4j98vcAJkwzvTiaSSZ8JsXI3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;BUG分类&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上问题是复杂多变的，我们一般将bug分为系统级别和业务级别bug。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;系统级别bug&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;业务部署在整套系统上运行，一旦出现系统级别bug则业务会被严重拖垮。如CPU爆满、服务不可用、甚至服务器宕机等都属于系统级别的bug。&lt;/p&gt;&lt;p&gt;如果是CPU100%，那是由哪个线程，哪个类，甚至是哪个方法导致的？&lt;/p&gt;&lt;p&gt;若是业务流程正常但是部分服务性能拉跨，那么如何快速定位到问题在哪儿？&lt;/p&gt;&lt;p&gt;因为是线上发生的事儿，所以重点在于如何&lt;span&gt;&lt;strong&gt;迅速解决&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;以下分享我最常用的一些问题排查工具。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;linux定位工具&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;1.CPU高负载，甚至100%？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;perf工具&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;perf是linux的性能分析工具，核心作用之一就是用来查看热点函数的分布情况。&lt;/p&gt;&lt;p&gt;用它可以生成&lt;strong&gt;火焰图&lt;/strong&gt;查看到函数的资源占用情况，函数的调用栈越深火焰就越高。所以对于异常的函数一眼就能看出。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1338212232096184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCpcCAzx7Wy8iaXrz0WJE1M60JuA9LFHGJyySD7zA6CcC3vbtMVZZSmDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3826&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如上图通过调用栈你可以看出Monitor管程在反复调用enter和wait，这种情况下就可以判断出该程序已经发生死锁且存在性能问题。假设有大量线程请求这段代码，那么CPU资源将被迅速打满！&lt;/p&gt;&lt;p&gt;在著名的“713B站事故”里技术团队在事故发生时就用到了当前工具生成了火焰图，快速地分析出了事故的根因也就是导致CPU100%的lua热点函数。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;2.某一进程存在异常嫌疑，想快速知道它的状态？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;ps命令&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们项目部署的服务器里在跑的进程老多了，java进程、nginx进程、redis、消息队列进程等等。&lt;/p&gt;&lt;p&gt;举个例子，假设在某一流量高峰期系统监控到整个服务性能下降5倍，业务被严重拖垮，在确定没有业务层面bug的情况下大概率就是因为服务性能达到瓶颈了。如何确定瓶颈在哪儿？&lt;/p&gt;&lt;p&gt;大部分情况下通过系统告警就可以知道大概问题所在。如发生消息堆积我们就该怀疑消息生产者和消费者的状态，这个时候就要具体去查看消息队列这一进程。&lt;/p&gt;&lt;p&gt;可以使用一些轻量级的linux命令，如&lt;span&gt;&lt;strong&gt;ps&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]&lt;span&gt;# ps -ef | grep queuejob&lt;/span&gt;&lt;br/&gt; root       &lt;span&gt;1303&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; Apr17 ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/queuejob&lt;br/&gt; root       &lt;span&gt;3260&lt;/span&gt;   &lt;span&gt;3087&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; Apr17 ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/bin/queuejob /bin/sh -c exec -l /bin/bash -c &lt;span&gt;&quot;env GNOME_SHELL_SESSION_MODE=classic gnome-session --session gnome-classic&quot;&lt;/span&gt;&lt;br/&gt; root      &lt;span&gt;24174&lt;/span&gt;  &lt;span&gt;19508&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto&lt;/span&gt; ssh&lt;br/&gt; [root@linux265 ~]# ps -aux | grep queueA&lt;br/&gt; root       &lt;span&gt;1303&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;82468&lt;/span&gt;  &lt;span&gt;1204&lt;/span&gt; ?        Ss   Apr17   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/sbin/queueA&lt;br/&gt; root       &lt;span&gt;3260&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;52864&lt;/span&gt;   &lt;span&gt;572&lt;/span&gt; ?        Ss   Apr17   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /usr/bin/queueA /bin/sh -c exec -l &lt;br/&gt; root      &lt;span&gt;24188&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt;  &lt;span&gt;0.0&lt;/span&gt; &lt;span&gt;112652&lt;/span&gt;   &lt;span&gt;956&lt;/span&gt; pts/&lt;span&gt;0&lt;/span&gt;    S+   &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; grep --color=&lt;span&gt;auto&lt;/span&gt; ssh&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该命令还可以用于对进程的资源使用情况进行排序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]# ps aux | sort -nk 3&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;[root@linuxfancy ~]&lt;span&gt;# ps aux | sort -rnk 4 &lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;3.我想知道内存&amp;amp;磁盘的使用情况？&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;vmstat命令&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写。&lt;/p&gt;&lt;p&gt;它是一个用于监控内存和磁盘使用情况的工具，但是也可以用来查看CPU的一些指标，如中断次数等。使用它可以查看内存使用的详细信息和磁盘的读/写情况。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36810344827586206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCuW5tFtxRRicv4GVqQEf1Mbz5bUNLn7ZEvpjZcogrbvmJdXD50zhl3yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;以上表头字段的说明如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Procs（进程）：&lt;br/&gt;&lt;br/&gt;r: 运行队列中进程数量&lt;br/&gt;&lt;br/&gt;b: 等待IO的进程数量&lt;br/&gt;&lt;br/&gt;Memory（内存）：&lt;br/&gt;&lt;br/&gt;swpd: 使用虚拟内存大小&lt;br/&gt;&lt;br/&gt;free: 可用内存大小&lt;br/&gt;&lt;br/&gt;buff: 用作缓冲的内存大小&lt;br/&gt;&lt;br/&gt;cache: 用作缓存的内存大小&lt;br/&gt;&lt;br/&gt;Swap(交换)：&lt;br/&gt;&lt;br/&gt;si: 每秒从交换区写到内存的大小&lt;br/&gt;&lt;br/&gt;so: 每秒写入交换区的内存大小IO：（现在的Linux版本块的大小为1024bytes）bi: 每秒读取的块数bo: 每秒写入的块数&lt;br/&gt;&lt;br/&gt;System(系统)：&lt;br/&gt;&lt;br/&gt;&lt;span&gt;in&lt;/span&gt;: 每秒中断数，包括时钟中断&lt;br/&gt;&lt;br/&gt;cs: 每秒上下文切换数&lt;br/&gt;&lt;br/&gt;CPU（以百分比表示）&lt;br/&gt;&lt;br/&gt;us: 用户进程执行时间(user time)&lt;br/&gt;&lt;br/&gt;sy: 系统进程执行时间(system time)&lt;br/&gt;&lt;br/&gt;id: 空闲时间(包括IO等待时间),中央处理器的空闲时间&lt;br/&gt;&lt;br/&gt;wa: IO等待时间&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从以上命令就可以很清晰地看出服务器的各方面性能情况。除此之外还有以下命令也可以在排查或者调优中使用：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7892644135188867&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCMV1OVD6d00DfHBm9ibkdY3icJ2zZ6ndltWL4xGVYPGS8gILADibA45RUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;span&gt;业务级别bug&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;如何定位到业务bug？&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;出现了业务bug那就纯纯的是开发或测试的锅了。&lt;/p&gt;&lt;p&gt;bug确定后第一步一定是&lt;span&gt;&lt;strong&gt;先看日志&lt;/strong&gt;&lt;/span&gt;，只要你写需求的时候日志打的全，一般出现了问题日志或者告警都会第一时间推送。&lt;/p&gt;&lt;p&gt;通过日志我们可以定位到bug对应代码的位置，但这仅仅是第一步，因为你只知道哪里出了问题，并不知道代码出了什么问题(除非一眼就能看出)。&lt;/p&gt;&lt;p&gt;所以下一步，&lt;span&gt;&lt;strong&gt;看数据&lt;/strong&gt;&lt;/span&gt;，数据是业务应用的核心。若通过日志和页面表现查看到你的主流程是没有问题的，那么下一步就是要确定表的数据是否有问题，数据存在bug的表现会是各方面的，可能是用户反馈，也可能是流程错误，这要取决于你表的设计。&lt;/p&gt;&lt;p&gt;切记！！线上数据是重中之重，当你决定要修复数据，在处理之前一定要做好备份，这样起码可以保证事情不会变的更糟。一般情况下修改线上数据这种活都需要你写好SQL，然后经过leader审批再交给DBA来操作，一定不要干出删库跑路这种事哟。&lt;/p&gt;&lt;p&gt;假设验证了你数据是OK的，那么问题就极大可能出现在了&lt;span&gt;&lt;strong&gt;代码层面&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;当代程序员最难过的瞬间无非就是有一个非常紧急的线上bug需要你来解决，但是摆在你面前的却是一堆屎山代码！！&lt;/p&gt;&lt;p&gt;修改业务bug最重要的是要将bug点修改掉并且保证其它业务还能正常运行，这是牵一发而动全身的事情，否则bug只会越改越多。&lt;/p&gt;&lt;p&gt;所以平时应该预知到这些风险，做好代码设计。总结一下定位业务bug的正确步骤：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27586206896551724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCXK1IdNLPXWqHnnsMA7GcJfexfsxEZFicQ6lbknbcVGI6mATD91cesMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;方案设计&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;代码设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;一般公司都有自己的代码设计规范。比如由外到里包装代码，每一个方法都要有对应的职责，并且一个方法不要超过100行，一个类不要超过1000行代码等。清晰的结构可以让你和他人更好地review代码，避免看起来一头雾水。&lt;/p&gt;&lt;p&gt;写业务逻辑有两种方式，一种就是简洁明了的线性逻辑，另一种就是通过封装代码来减少代码耦合提高内聚性，也就是我们说的设计模式的使用。两种方式各有优缺点，但是工作多年了咱写的代码也不能直里直气的，多少得带点”艺术“对吧？推荐一下我经常使用但是也不会特别复杂的设计模式。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;设计模式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;工厂模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这是最常使用的设计模式之一。&lt;/p&gt;&lt;p&gt;工厂模式分为简单工厂模式、工厂方法模式和抽象工厂模式。我们这里讲解简单工厂模式，因为后两个都是以其为基础做改进的。&lt;/p&gt;&lt;p&gt;其结构如下：&lt;/p&gt;&lt;p&gt;通过定义一个用以创建对象的接口, 让子类决定实例化哪个类。&lt;/p&gt;&lt;p&gt;所以其实质就是由一个&lt;span&gt;&lt;strong&gt;工厂类&lt;/strong&gt;&lt;/span&gt;根据传入的参数，动态决定应该创建哪一个&lt;span&gt;&lt;strong&gt;产品类&lt;/strong&gt;&lt;/span&gt;（这些产品类继承自一个父类或接口）的实例。&lt;/p&gt;&lt;p&gt;其包含以下角色：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;工厂（Creator）角色：工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;抽象产品（Product）角色：它负责描述所有实例所共有的公共接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;具体产品（Concrete Product）角色：创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7542662116040956&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCXIK0pgicLiaD7Z85x3iaOtf3o1kDZ52SXD1x0EJK9Rbfv4u8SwcK6VsFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当遇到&lt;span&gt;&lt;strong&gt;需要根据某个前提条件创建不同的类实现&lt;/strong&gt;&lt;/span&gt;时, 可以使用工厂模式。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;它是在不必改变原类结构和继承体系的情况下，&lt;span&gt;&lt;strong&gt;动态地扩展一个对象的功能&lt;/strong&gt;&lt;/span&gt;。通过创建一个包装对象来实现对功能的扩展，动态的给一个对象添加一些额外的职责。&lt;/p&gt;&lt;p&gt;所以装饰者模式分为主体和装饰者。&lt;/p&gt;&lt;p&gt;其包含角色如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;主体(Main)：业务主体逻辑、字段等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;主体具体实现类(MainComponent)：主体具体的实现类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者(Decorator)：要做的装饰扩展逻辑接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;装饰者具体实现类(DecoratorComponent)：扩展逻辑的具体实现类。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8079306071871127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCcgZEzhmfGdBJCh6Q81AMXdhic2ptOOFm3pC2oc2ZpbFT5wYoXYX8xGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;以上两种设计模式都有着”高扩展性“的特点，我们应该根据业务灵活设计接口，避免需求迭代导致的一坨坨又臭又长的代码。但是设计模式切勿用来炫技，一些较为冷门或者复杂的设计模式不推荐使用，否则当一套代码只有你能维护时，那将会是非常痛苦的。。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.048936170212766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCI02rkLsOYib9L96vwjmsEdIxgrs1PdPSK6Q5eBxlbhdQFOib33qia5pwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;当然了这也能够体现出你在公司的不可替代性！&lt;/p&gt;&lt;h2&gt;&lt;span&gt;架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;系统高性能 &amp;amp; 高可用&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用缓存：缓存的作用是为了系统的读能力。将用户经常访问的数据扔到缓存里面可以有效地提高访问速度并且减少数据库的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44224924012158057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC8n2ZyJe4ib4gfvmmnXdfe0poibt5ibTYJHwVv7FoPJkYCpfctzgwb7r7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;服务降级 &amp;amp; 限流：若短时间内流量激增影响到服务器性能，可考虑降级边缘业务以保证核心业务的可用性和性能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4322766570605187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC5tkzPCuatndJJX2bkxQDzgaM8UibMOv697hibibtohvRlvJzHcYEiaVceg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;分布式系统 &amp;amp; 服务拆分：&lt;/span&gt;&lt;span&gt;将整个系统拆分成不同的业务模块再部署到对应的服务器中，服务之间通过中间件通信，可以有效地避免&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;和减少单一服务故障对整体系统的影响。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8859934853420195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yCqQk284qq9Hlvwjq2FicBuoKxI5CAoLvFtF7ibNqNqRLZbIOJww1n0FwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;高可用架构：重要性不言而喻。同城多活、异地多活的架构部署可以保证单机房挂掉的情况下流量可以迅速切换到其他机房让核心业务不受影响。可谓是防止系统宕机必备良药啊！&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3461909353905497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LUuerhGpzYNTFARLAhPsL21hZ2wRF3yC7oHh2fLKwicHLEEOhH2Gibhyuv95YZJJ6pdfYXQwzeStv9UPBwbww9Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1037&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;&lt;span&gt;做好事故复盘&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;都说小事故伤身，大事故提桶。。一般发生事故后写一张事故单是不可避免的。除了详细描述好事故发生的经过，背锅人，解决方案，后续的事故跟进也是一系列流程的事，多则需要数周去跟进。事故的发生对于团队的技术发展和成型往往起着积极推进作用，所以对于每一个团队来说事故一定是不可避免的。每次事故发生我们都要思考如何完善系统，打破技术壁垒。并且遇到事儿也不要慌，如果是大问题，那么首先背锅的一定是leader！&lt;/p&gt;&lt;p&gt;其实呢一般公司最喜欢的是能快速解决问题的员工，即便这些问题可能是由你创造的。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4NjYyODc4OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/J4jTHmo8Xh6qM32ASOtVbXNoiaegrI26qLRw6r6FTI7dZw6TMT7vecvnjd1O8xSsM5MiajIuQZicxSC6KFK8TMpbg/0?wx_fmt=png&quot; data-nickname=&quot;java突击队&quot; data-alias=&quot;&quot; data-signature=&quot;技术经验分享&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;此外，我最近打算把新建的技术交流群，打造成一个活跃的高质量技术群。群里不定期有送书，发红包活动，工作中遇到的技术问题，都可以在里面咨询大家，还有工作内推的机会。有兴趣的小伙伴，欢迎加群。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;扫描回复：加群，即可入群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDE9vvfu1eb0KdQmjCiceE3xr7JF0cvK0z4UwCNyKO4UsMg5Urfro5qzoU2NWfgthCjwENmLxK6Nxyw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dc3f1c7d499ab2e15e7ae9d48d24d889</guid>
<title>使用 StringUtils.split 的坑</title>
<link>https://toutiao.io/k/0xsnf61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content             autoTypeSetting24psection&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/4lfok2icUkibRhulibg86OqauDH7x1pREibzO8LIVLibiaT6ibUnj1F8YsYE0Fhah3Y5ybQdiaAB1FHzzQDBmnCCBFroaA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;350&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;Apche Commons&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在日常的 Java 开发中，由于 JDK 未能提供足够的常用的操作类库，通常我们会引入 Apache Commons Lang 工具库或者 Google Guava 工具库简化开发过程。两个类库都为 &lt;code&gt;java.lang&lt;/code&gt; API 提供了很多实用工具，比如经常使用的字符串操作，基本数值操作、时间操作、对象反射以及并发操作等。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;org.apache.commons&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;commons-lang3&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;br/&gt;    &amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;3.12.0&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，最近在使用 Apache Commons Lang 工具库时&lt;strong&gt;踩了一个坑&lt;/strong&gt;，导致程序出现了意料之外的结果。&lt;/p&gt;&lt;h2&gt;StringUtils.split 的坑&lt;/h2&gt;&lt;p&gt;也是因为踩了这个坑，索性写下一篇文章好好介绍下 Apache Commons Lang 工具库中字符串操作相关 API。&lt;/p&gt;&lt;p&gt;先说坑是什么，我们都知道 String 类中到的 &lt;code&gt;split&lt;/code&gt; 方法可以分割字符串，比如字符串 &lt;code&gt;aabbccdd&lt;/code&gt; 根据 &lt;code&gt;bc&lt;/code&gt; 分割的结果应该是 &lt;code&gt;aab&lt;/code&gt; 和 &lt;code&gt;cdd&lt;/code&gt; 才对，这样的结果也很容易验证。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String s : str.split(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;)) {&lt;br/&gt;    System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 结果&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可能是因为 String 类中的 &lt;code&gt;split&lt;/code&gt; 方法的影响，我一直以为 &lt;code&gt;StringUtils.split&lt;/code&gt; 的效果应该相同，但其实完全不同，可以试着分析下面的三个方法输出结果是什么，StringUtils 是 Commons Lang 类库中的字符串工具类。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testA&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我对上面 testA 方法的预期是 &lt;code&gt;aab&lt;/code&gt; 和 &lt;code&gt;cdd&lt;/code&gt; ，但是实际上这个方法的运行结果是：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;// testA 输出&lt;br/&gt;aa&lt;br/&gt;dd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到 &lt;code&gt;b&lt;/code&gt; 和 &lt;code&gt;c&lt;/code&gt; 字母都不见了，只剩下了 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，这是已经发现问题了，查看源码后发现 &lt;code&gt;StringUtils.split&lt;/code&gt; 方法其实是按字符进行操作的，不会把分割字符串作为一个整体来看，返回的结果中不也会包含用于分割的字符。&lt;/p&gt;&lt;p&gt;验证代码：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testB&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;ac&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// testB 输出&lt;/span&gt;&lt;br/&gt;b&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;testC&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;abcd&quot;&lt;/span&gt;;&lt;br/&gt;    String[] resultArray = StringUtils.split(str, &lt;span&gt;&quot;ac&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;        System.out.println(s);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// testC 输出&lt;/span&gt;&lt;br/&gt;b&lt;br/&gt;d&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果和预期的一致了。&lt;/p&gt;&lt;h2&gt;StringUtils.split 源码分析&lt;/h2&gt;&lt;p&gt;点开源码一眼看下去，发现在方法注释中就已经进行提示了：&lt;strong&gt;返回的字符串数组中不包含分隔符&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;The separator is not included in the returned String array. Adjacent separators are treated as one separator. For more control over the split use the StrTokenizer class....&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;继续追踪源码，可以看到最终 split 分割字符串时入参有四个。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String[] splitWorker(&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; String str, &lt;span&gt;// 原字符串 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; String separatorChars,  &lt;span&gt;// 分隔符&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; max,  &lt;span&gt;// 分割后返回前多少个结果，-1 为所有&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; preserveAllTokens &lt;span&gt;// 暂不关注&lt;/span&gt;&lt;br/&gt;) {&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据分隔符的不同又分了三种情况。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 分隔符为 null&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;len&lt;/span&gt; = str.length();&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (len == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ArrayUtils.EMPTY_STRING_ARRAY;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ArrayList&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;sizePlus1&lt;/span&gt; = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;start&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;match&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;lastMatch&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (separatorChars == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;// Null separator means use whitespace&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (Character.isWhitespace(str.charAt(i))) { &lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens) {&lt;br/&gt;                lastMatch = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (sizePlus1++ == max) {&lt;br/&gt;                    i = len;&lt;br/&gt;                    lastMatch = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                list.add(str.substring(start, i));&lt;br/&gt;                match = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            start = ++i;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        lastMatch = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        match = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        i++;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens &amp;amp;&amp;amp; lastMatch) {&lt;br/&gt;            list.add(str.substring(start, i));&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到如果分隔符为 &lt;code&gt;null&lt;/code&gt; ，是按照空白字符 &lt;code&gt;Character.isWhitespace()&lt;/code&gt; 分割字符串的。分割的算法逻辑为：&lt;/p&gt;&lt;p&gt;a. 用于截取的开始下标置为 0 ，逐字符读取字符串。b. 碰到分割的目标字符，把截取的开始下标到当前字符之前的字符串截取出来。c. 然后用于截取的开始下标置为下一个字符，等到下一次使用。d. 继续逐字符读取字符串、&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 分隔符为单个字符&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;逻辑同上，只是判断逻辑 &lt;code&gt;Character.isWhitespace()&lt;/code&gt; 变为了指定字符判断。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Optimise 1 character case&lt;/span&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; &lt;span&gt;sep&lt;/span&gt; = separatorChars.charAt(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (str.charAt(i) == sep) { &lt;span&gt;// 直接比较&lt;/span&gt;&lt;br/&gt;      ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3. 分隔符为字符串&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;总体逻辑同上，只是判断逻辑变为包含判断。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// standard case&lt;/span&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; len) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (separatorChars.indexOf(str.charAt(i)) &amp;gt;= &lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;// 包含判断&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (match || preserveAllTokens) {&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;如何解决？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;1. 使用 &lt;code&gt;splitByWholeSeparator&lt;/code&gt; 方法。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们想要的是按整个字符串分割，StringUtils 工具类中已经存在具体的实现了，使用 &lt;code&gt;splitByWholeSeparator&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;String[] resultArray = StringUtils.splitByWholeSeparator(str, &lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String s : resultArray) {&lt;br/&gt;    System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;2. 使用 Google Guava 工具库&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;关于 Guava 工具库的使用，之前也写过一篇文章，可以参考：&lt;span&gt;Guava - 拯救垃圾代码&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;Iterable&amp;lt;String&amp;gt; iterable = Splitter.on(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;)&lt;br/&gt;    .omitEmptyStrings() &lt;span&gt;// 忽略空值&lt;/span&gt;&lt;br/&gt;    .trimResults() &lt;span&gt;// 过滤结果中的空白&lt;/span&gt;&lt;br/&gt;    .split(str);&lt;br/&gt;iterable.forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;3. JDK String.split 方法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用 String 中的 split 方法可以实现想要效果。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;aabbccdd&quot;&lt;/span&gt;;&lt;br/&gt;String[] res = str.split(&lt;span&gt;&quot;bc&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String re : res) {&lt;br/&gt;    System.out.println(re);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;aab&lt;br/&gt;cdd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是 String 的 split 方法也有一些坑，比如下面的输出结果。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt; &lt;span&gt;str&lt;/span&gt; = &lt;span&gt;&quot;,a,,b,&quot;&lt;/span&gt;;&lt;br/&gt;String[] splitArr = str.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;);&lt;br/&gt;Arrays.stream(splitArr).forEach(System.out::println);&lt;br/&gt;&lt;span&gt;// 输出&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;a&lt;br/&gt;&lt;br/&gt;b&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开头的逗号&lt;code&gt;,&lt;/code&gt;前出现了空格，末尾的逗号&lt;code&gt;,&lt;/code&gt;后却没有空格。&lt;/p&gt;&lt;p&gt;一如既往，文章中代码存放在 &lt;span&gt;Github.com/niumoo/javaNotes&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;.&lt;/p&gt;&lt;p&gt;&amp;lt;完&amp;gt;&lt;/p&gt;&lt;h4&gt;引用链接&lt;/h4&gt;&lt;p&gt;&lt;code&gt;[4]&lt;/code&gt; Guava - 拯救垃圾代码: &lt;em&gt;https://www.wdbyte.com/2020/10/develop/google-guava/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; Github.com/niumoo/javaNotes: &lt;em&gt;https://github.com/niumoo/JavaNotes/tree/master/tool-java-apache-common&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;span&gt;---- END ----&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Hello world : ) &lt;span&gt;这篇文章就到这里了，&lt;/span&gt;我是阿朗。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MDIxNjQ1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4lfok2icUkibQlzFGPibM1jmICzZmtYzRGMpP7suTs20SQKjwqgFWKKPcmAwzzeDZHE3fuhodU4oZsKQ3IibqYmibhg/0?wx_fmt=png&quot; data-nickname=&quot;程序猿阿朗&quot; data-alias=&quot;wdbyte&quot; data-signature=&quot;: ) 早睡早起，坚持不懈。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;点个在看，加油充电～&lt;/span&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;3&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff4f19069d80a8c8019636036493a4fe</guid>
<title>流程引擎的架构设计</title>
<link>https://toutiao.io/k/lyviyk3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 什么是流程引擎&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程引擎是一个底层支撑平台，是为提供流程处理而开发设计的。流程引擎和流程应用，以及应用程序的关系如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49528301886792453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNhSlL76qdQ67vFnU1tkqoY3EcF3uM6n7PZ2D5pSD0RJ3KzVSnRiax7HA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的支撑场景有：Workflow、BPM、流程编排等。本次分享，主要从 BPM 流程引擎切入，介绍流程引擎的架构设计方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 什么是流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来说，流程就是一系列活动的组合。比如，用于企业办公的 OA 系统中，就存在大量的申请审批类的流程。在生产制造业，有大量的从销售端的订单，到生产制造，再到签收回款的生产销售流程。在机器学习领域，有亚马逊 AWS Sagemaker 的大数据处理、机器学习的应用。综上，流程是一个概念，在和具体实现结合时，就产生了不同的流程产品，如 DevOps、Spring Data Stream 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在流程实现方面，主要可以分为 2 种实现方式，一种是用代码实现，比如：用代码实现一个加班申请，那么就要自己对接 SSO 进行单点登录，通过接口拿到发起人和审批人的信息，同时保存表单数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种方式是使用流程引擎来实现，流程引擎对接应用场景所需数据，如加班申请，流程引擎对接 SSO、OU、审批人配置、权限等，实现这样一个流程，只需要关心流程配置、流程节点和流程表单即可，流程流转以及流程的数据处理，都通过流程引擎来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程引擎可以快速落地流程实现，这也是流程引擎存在的价值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 什么是引擎&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，引擎是一个程序或一套系统的支持部分。常见的程序引擎有游戏引擎、搜索引擎、杀毒引擎等。引擎是脱离具体业务场景的某一类业务场景的高度抽象和封装。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;比如，某 OA 公司，封装了一套审批用的 workflow，实施人员只需要配置流程和表单即可交付项目。再比如，美国某公司做了一个 AI 引擎做 NBA（Next Best Action）推荐，封装了推荐领域的常用算法，在不同的场景自动选择和组合多种算法，进行智能推荐。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 流程设计器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程设计器是流程和引擎的连接方，用户通过流程设计器，将某种 layout 和 rule 固化成某种流程，然后通过数据和数据上下文，使用流程引擎自动按照某种固化的流程进行执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我将目前见到的流程设计器的理论基础，分为以下三类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;自定义系；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UML 中的活动图系；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BPMN 系。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.1 自定义系&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于 Sagemaker 等场景的 AWS Step Function（自定义流程节点）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNzjHMdzFTVVfse4L7PEHdXwJxWqwibofqFvg46AKFYRR9BazDckfDvQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.2 UML Activity Diagram&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Flowportal BPM 的流程设计器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49184782608695654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNicfcV1xnEkBPQxuUhJYVqe1NZgy2o6WcJeNRjM8Sw0jEbMgqvSFyPfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3.3 BPMN 系&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;activiti 的流程设计器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNUl5OibiatXZOBiboOCofcOp3osG9ueic5qFKYk02uc040ojE9TzM5icictkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;炎黄盈动的流程设计器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.604040404040404&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNpJnwnmkFiblIYXcFXoPp6ICN1YoZXqicPW9EYP1gLmVEQPvKN7gkeflA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;题外话：炎黄盈动的流程设计器，和 processon 中的流程设计器界面几乎一样，因为本质上是一家的。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 流程引擎的应用&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 Workflow&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作流管理联盟 (Workflow Management Coalition，WfMC) 作为工作流管理的标准化组织而成立。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WfMC 对工作流给出定义为：工作流是指一类能够完全自动执行的经营过程，根据一系列过程规则，将文档、信息或任务在不同的执行者之间进行传递与执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4385692068429238&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN5CNzAJ58wDY1N3bGS1sgocjWp9HWeHmsgPRhct7dSe82rEBfuMFvUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;643&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 workflow 中，流程引擎主要用于支撑流程审批和数据流转，应用场景非常广泛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国外产品（开源或商用）通常需求和操作比较简单，不会有国内的需求那么复杂。国内的产品，经历了众多客户的锤炼，功能目前都比较强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，workflow 使用场景最多的是 OA 产品。在 OA 办公中，包含了企业办公中的大量元素，这些元素足够形成特定的产品，比如门户系统、移动办公。在 OA 的项目落地过程中，结合行业、业务侧重点又可以形成行业解决方案和专题方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是某 OA 公司产品和解决方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8377321603128055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNG7JcDQP0CFZibqyv77tlxfI03EiaZubSwfIyR4aiaVjK34VKM2HlwalfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1023&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 BPM（Business Process Management）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Workflow 主要是解决审批和数据流转，而 BPM 主要是解决端到端、信息孤岛等问题而存在的。大多数用 BPM 产品的客户，都是在 BPM 基础上进行系统搭建，比如在 BPM 上面搭建 OA、CRM、HR 等系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BPM 的使用场景，比 Workflow 更广泛，BPM 产品中包含大量的和第三方系统交互的组件和自定义 SQL、代码组件。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;比如，BPM 系统中的文件触发器，可以在海关等交互场景下，通过监控 FTP 服务器中的文件，自动触发流程实例；可以通过定时器 Timer，自动每日执行数据同步，并通过 Mail 节点将同步结果通知到相关运营成员等。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5305555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNBWbgibRNfMeRpQFlBL41NZFibMKmvEPl3yC6C8ic7BJ4M9aSOkoYZc3Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5509259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNHG2owtRrMncIFPq7nibnbB6B8ytDNDrnDtiaprLBpiaRgjgOQz5Pgtquw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BPM 的应用，可以按照执行前、执行中和执行后来划分。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNbUxqdy3Wxl8lEP3BjqmHyWGiaYg02nA29FWDWq68ZjEnmdHu5WoyJKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 流程编排&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程编排是脱离流程业务领域的更高一层抽象，使用方可以通过流程编排系统，结合自己的业务场景进行业务定制。比如，可以将相关业务代码，封装成 function，然后通过云厂商平台的 FAAS 平台，将不同业务的 function 进行关联和调度，从而完成某项任务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 流程引擎的架构设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于一些朋友可能没有使用和接触过流程引擎，先介绍流程引擎的组成单元，再介绍基于某个 BPM 产品的项目是如何进行开发的。我们通过 BPM 项目开发，对流程引擎的作用有个初步的认识。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 BPM 流程引擎的组成单元&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;组织、角色、用户、成员的组织架构托管；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流程资源文件的配置、校验、存储和执行，对不同的流程节点，流程引擎自动结合配置、数据处理其对应的业务逻辑，流程数据自动处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表单配置、数据绑定，表单数据的根据流程配置自动处理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通用的数据接口；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1 组织架构的设计&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40370370370370373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN3mDriaQukiaibiamlIR1bWeaD1HOs8NpPNmMlCjvx7ugfCUdicPiaTN1rITA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2 流程设计器&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程设计器包含左侧的分组节点列表，和右侧的画布。左侧的节点可以如下进行设计。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8835051546391752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN4buWhuq2JXtcciahHs6spvUDYkSxwGVibIvBs8k6xtY0X25ibUDcGkiapg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;问题：对于一个 XML 或 JSON 格式的流程图，如何进行解析？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的节点，按照不同的业务场景，配置不同的配置项。比如，对于 Human Node 需要配置审批人，配置审批环节的展示表单，审批环节能够修改哪些字段，哪些字段的修改要进行留痕等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.3 表单设计器&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNQxOr8T1QpiaItVcAODoVofpcYzpF4EEYp95CQcpYwAyT4EnysKQQw1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.649074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNAsRw004Le9naJKq7gI6EVDah9V2HiaQQJ5ZLJrmonq0yulB47cSrZrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种是按照表单相关数据表，生成出一个表单，然后对表单字段进行配置和数据绑定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7152255639097744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNg2iabhDYjHOriaZEwjgCOibR3x8Wf428B81ADluvVJC9ytkR5J1ic2sS4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7136105860113422&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNwGMB7Uswl7tuNHjgQVqmpU5AYaEMcHuYaNrQ0g3jiaphLGOuVWcj3wQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种是 Drag&amp;amp;Drop 控件，然后配置控件的属性，如绑定字段等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5009259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNRgQR8ZQ2Yt7T6KUGYuO8CN4SPK1lzIGmBIwEgxSNE8mibLmaLcq4FHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种是 Drag&amp;amp;Drop 控件，无需关联数据库表字段的表单&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNNVNjAFlDT3j7ytVsJRp2f2ZT350xS2SU1hZibiaKJXv0tQsduKaDevzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据表生成表单的概要流程如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5175925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNnUPVYRho2fBLJKKKTHASY8cvHr4OahTHag0IEDnbFV6q86Pen4OqXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽控件绑定数据表字段的概要流程如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5398148148148149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNphZ6TqC31Y2NMctp5PukPZlLeUkXjDDKy9HUmmLlkJZREicbvfS0R6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拖拽控件无需绑定数据表字段的概要流程。使用 NoSQL 的 Document 记录或使用 RDS 提供的 JSON 类型进行保存会比较方便。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5277777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN4G3DjOhW7R04qMY1Oc9DQNZWmXvOiaeRwViaYicIiaiafAPLzoZ3tf8fWwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.4 接口设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合 Activity 的接口设计，如下图所示&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4027777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN36YByU57nyQbxcc3fibmOFTEU3VsqtGrvxwyd2NmdnpQLAXTkUpaWnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些系统在创建一个流程任务的时候，要先按照流程模板先创建一个应用示例，再关联发起人和备注，调用 &lt;code&gt;RuntimeService&lt;/code&gt;，执行到 StartNode，这类设计因人而异，这么做略显繁琐。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 基于流程引擎的项目开发实践&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1 流程项目实践流程&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确定组织架构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定流程，包括流程布局、审批人设置、权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定表单信息（字段、类型、数据源、校验规则）和表单样式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定页面布局、样式、数据字段、搜索、导入、导出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;报表&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2 组织架构&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组织架构实现，有两种方法，一种是按照维度进行数据管理，另一种是在同一棵组织架构树下进行管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照集团、公司、部门、用户等不同维度，进行数据管理，比较常见，这里不做讨论。下图为按维度维护数据的示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47685185185185186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNA0ctcgTflys5KCMK2YVrd4w0IXnjC96T6D46aWz40fKePuNJoiaAeQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照同一棵组织架构树进行数据维护，界面一般显示为左树右表。大多数商业化产品，都会将此组织架构树进行内存缓存，以方便审批人查找、开窗选择 OrgUnit、Role、User、Member 等场景。Member 的引入是为了解决一人多职等场景。一般发起流程的时候，需要带出发起人拥有的 Member 列表，从而后续节点取合适的审批人。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2824156305506217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN9sjDmUnHRdgiaCzUvJWMX32A6m5YxnA0ZJusq9b3Skg82l99SbZdKzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;563&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于组织架构而言，需要考虑，系统本身要具备 OU 存储的能力，对于没有组织架构的用户，可以直接在系统的组织架构中新建组织架构。同时，对于已有系统的客户，可以通过组织架构数据同步来进行数据自动维护。对于用 AD 域内部管控的客户来说，需要具备 AD 域身份认证的能力。对于复杂场景，比如用户是 SaaS 化等复杂场景，组织架构也需要在系统内部，支持使用 API 的方式来获取组织信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在组织架构设计的时候，要使用插件的方式来做，具体使用哪种插件，可以在配置文件中进行配置。以下为一个商业产品的组织架构操作界面示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNbZkppicRrg8ZjGWLP7HofR1QlLawpFVZoq05SSO0gyswmENNZvsyjSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的组织架构操作还有组织架构同步，比如流程系统同步微信企业号、钉钉等，这里不再展开。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.3 流程设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想象的流程，可能是向下面的这种简单流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49166666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNicbzePHUjzicemPDIMsl3mvfibyAxE7P720RxlJTqNlBvAVlBUEVBUicyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实际项目，碰到的流程，一般是如下图所示的情景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2851851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNzBjXkWwicnRoZeCmGtRiaSZJSRCtWo1RyEcD3aLzoia0DEcicmlxWqWj1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步看几个流程的模型文件是什么样的，先有个印象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9493029150823827&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNliadR9IrWz2MqnPibJZdvxcAWibeP0WNg9BrJOq430Xic51krliaFvpTLicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;definitions&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;definitions&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;targetNamespace&lt;/span&gt;=&lt;span&gt;&quot;http://activiti.org/bpmn20&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;xmlns&lt;/span&gt;=&lt;span&gt;&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;xmlns:activiti&lt;/span&gt;=&lt;span&gt;&quot;http://activiti.org/bpmn&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;process&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;vacationRequest&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Vacation request&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;startEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;request&quot;&lt;/span&gt; &lt;span&gt;activiti:initiator&lt;/span&gt;=&lt;span&gt;&quot;employeeName&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;numberOfDays&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Number of days&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;long&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;1&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;startDate&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;First day of holiday (dd-MM-yyy)&quot;&lt;/span&gt; &lt;span&gt;datePattern&lt;/span&gt;=&lt;span&gt;&quot;dd-MM-yyyy hh:mm&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;date&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;vacationMotivation&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Motivation&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;string&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;startEvent&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow1&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;request&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;handleRequest&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;handleRequest&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Handle vacation request&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;documentation&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;${employeeName} would like to take ${numberOfDays} day(s) of vacation (Motivation: ${vacationMotivation}).&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;documentation&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;vacationApproved&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Do you approve this vacation&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;enum&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:value&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Approve&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:value&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Reject&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;activiti:formProperty&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;managerMotivation&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Motivation&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;string&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;potentialOwner&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;resourceAssignmentExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;formalExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;management&lt;span&gt;&amp;lt;/&lt;span&gt;formalExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;resourceAssignmentExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;potentialOwner&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;userTask&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow2&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;handleRequest&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;requestApprovedDecision&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;exclusiveGateway&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;requestApprovedDecision&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Request approved?&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow3&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;requestApprovedDecision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;sendApprovalMail&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${vacationApproved == &#x27;true&#x27;}&lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;task&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;sendApprovalMail&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Send confirmation e-mail&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow4&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;sendApprovalMail&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;theEnd1&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;theEnd1&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow5&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;requestApprovedDecision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;adjustVacationRequestTask&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${vacationApproved == &#x27;false&#x27;}&lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;userTask&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;adjustVacationRequestTask&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Adjust vacation request&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;documentation&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;Your manager has disapproved your vacation request for ${numberOfDays} days.&lt;br/&gt;Reason: ${managerMotivation}&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;documentation&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;numberOfDays&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Number of days&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;${numberOfDays}&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;long&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;startDate&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;First day of holiday (dd-MM-yyy)&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;${startDate}&quot;&lt;/span&gt; &lt;span&gt;datePattern&lt;/span&gt;=&lt;span&gt;&quot;dd-MM-yyyy hh:mm&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;date&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;vacationMotivation&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Motivation&quot;&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;=&lt;span&gt;&quot;${vacationMotivation}&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;string&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:formProperty&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;resendRequest&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Resend vacation request to manager?&quot;&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;enum&quot;&lt;/span&gt; &lt;span&gt;required&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:value&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;true&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Yes&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;activiti:value&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;false&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;No&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;activiti:formProperty&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;extensionElements&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;humanPerformer&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;resourceAssignmentExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;formalExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;${employeeName}&lt;span&gt;&amp;lt;/&lt;span&gt;formalExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;resourceAssignmentExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;humanPerformer&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;userTask&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow6&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;adjustVacationRequestTask&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;resendRequestDecision&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;exclusiveGateway&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;resendRequestDecision&quot;&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;Resend request?&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow7&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;resendRequestDecision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;handleRequest&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${resendRequest == &#x27;true&#x27;}&lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;sequenceFlow&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;flow8&quot;&lt;/span&gt; &lt;span&gt;sourceRef&lt;/span&gt;=&lt;span&gt;&quot;resendRequestDecision&quot;&lt;/span&gt; &lt;span&gt;targetRef&lt;/span&gt;=&lt;span&gt;&quot;theEnd2&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;conditionExpression&lt;/span&gt; &lt;span&gt;xsi:type&lt;/span&gt;=&lt;span&gt;&quot;tFormalExpression&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;${resendRequest == &#x27;false&#x27;}&lt;span&gt;&amp;lt;/&lt;span&gt;conditionExpression&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;sequenceFlow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;endEvent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;theEnd2&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;process&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;definitions&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个屏幕截图都截不完的流程，如果用代码去实现整个流程，其工作量和效率，可想而知。而实际做项目，使用基于流程引擎的产品来做项目的时候，只需要确定节点、节点配置、数据配置和权限即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：一般流程，都带有邮件通知的节点，如何实现邮件通知节点？请考虑以下情景。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;p&gt;流程流转和执行的时候，会遇到各种情况的错误，比如找不到审批人等，此时流程引擎要对数据做 rollback，而邮件通知节点的业务逻辑已经执行过了。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限方面，对于流程资源，哪些部门可以申请，哪些角色不可申请，都应该做流程控制。而在流程执行过程中，流程数据、不是路程的相关人也都不应该看到流程，处理过流程的审批人，不可以再对流程进行处理等，都是权限方面要考虑的问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.4 表单设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示的表单，可以分析以下，一个流程表单有多个主表信息和多个子表信息。一般而言，如果是通过流程引擎做非流程的数据处理，子表通过主表 ID 来做关联，如果通过流程引擎做流程的数据处理，子表和主表通过 TaskId 来做关联。以下为示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5990740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN6EElyAuibeb1YMNwmtHkZfvX9kjqWQd3ryaqYicFKRe03hsUQL58Og4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程系统需要表单设计器，一个流程的不同节点可以挂接不同的表单，以方便不同角色的人关注不同维度的流程信息&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.5 页面设计&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，对于流程的发起、审批、历史记录等，都是通用的系统界面。而一些业务场景，需要单独做列表界面，以方便使用。对于已有门户系统的客户，需要融合其界面样式。以下为曾经做过的项目示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.462037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNXfNjABlDib7yzsqibbOOHKeRib5YeIjRMZgc8hiao8Mmib6gGDUXsTF41zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43425925925925923&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN8GyHAvyTusjahAWf33X3jE91u2dTddQpyF1wgA5ykqroI9zibicfAYBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.6 报表&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于不是所有客户都有报表系统，所以流程系统需要具备一个基本的报表功能。下图为示例。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4074074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgN2EU0mlresK9icqticYvvyu9vaVsoJIUhHwnyOGuB5ICRof5UP9s3GxQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有报表系统的客户，可以使用其商业版报表系统，获取（直接取、数仓）数据进行展示。常见的报表系统有 FineReport、Tableau、PowerBI 等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 BPM 流程引擎架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 流程引擎的架构设计&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0638297872340425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNqyMX4bgKIAic5K1ibJ4vrMjX3h54MHcb4FY4a7gqnFtqcf1BddYzY4OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;470&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 发起流程&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4113247863247863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgND8pZjrUpkLZlXnHxNxiaIlELAeUkvSkSb3Tocnxk7z3N065ZdDSx4iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程引擎处理过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNkT0j4iaqNs7K2ia6ruoRhLXDCaNiardWFe0FT8618s2PrtJ0wic4epwv5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行节点处理过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28703703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNovTNxpqWDMteIPLjItzxTEB4yjiciabMyjTc6PmzxVt1d8wIzeBhJbuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：在流程引擎处理过程中，如果一个节点有多条连线，如何寻找 FromNodeId 是某个 Node 的连线？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;人工处理时，指定连线 text&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 流程引擎架构设计&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8KKrHK5ic6XB1wZ7EYYsDxdBDx470NdgNQ8iczlmyKdU7HVRFKribt6OiaVBCltmkuLoQ9ic8ufDXnbQWJJ6zhd4cAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.1 业务识别&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;识别业务场景中的配置项，使用集合或分组的方式，让业务可配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支撑业务流程过程的可配置化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支撑业务场景中的数据，自动处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.2 流程引擎的实现&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;资源相关服务，资源加载，资源保存，资源加密等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置项相关服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PVM 虚拟机的实现，即通过某个节点（发起时为开始节点）作为初始节点，按照某个连线的 action 进行节点的自动执行的虚拟机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据配置、数据权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流程数据和业务数据的自动处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 商业机会&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Business Process Analysis (BPA) 流程分析，帮助企业进行流程调整和优化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Process Assets Library（PAL）流程资产库，对企业流程进行知识化沉淀，将制度和流程落地做绑定，让审批人知晓流程中对应的职责&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Process Simulate 流程模拟，自动化测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Process Forecast 流程预测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;低代码平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更广泛的机会，在于业务领域 + 流程引擎，比如：DevOps、RPA、应用与服务编排、数据编排、FaaS 编排等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5a782fb3050552fdd7889393a31c8d6</guid>
<title>Kubernetes 网络流量流转路径</title>
<link>https://toutiao.io/k/ty9p91p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 网络模型定义了一组基本规则：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在不使用网络地址转换 (NAT) 的情况下，集群中的 Pod 能够与任意其他 Pod 进行通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在不使用网络地址转换 (NAT) 的情况下，在集群节点上运行的程序能与同一节点上的任何 Pod 进行通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个 Pod 都有自己的 IP 地址（IP-per-Pod），并且任意其他 Pod 都可以通过相同的这个地址访问它。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些要求，不会将具体实现限制在某种解决方案上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，它们笼统地描述了集群网络的特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了满足这些限制，你必须解决以下挑战:&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如何确保同一个 Pod 中的容器行为就像它们在同一个主机上一样？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群中的 Pod 能否访问其他 Pod？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 可以访问服务吗？服务是负载均衡的吗？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 可以接收集群外部的流量吗？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本文中，将重点关注前三点，从 Pod 内的网络，容器到容器的通信说起。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Linux 网络命名空间如何在 Pod 中工作&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们来看一个运行应用的主容器和伴随一起的另一个容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在示例中，有一个带有 nginx 和 busybox 容器的 Pod:&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion: v1&lt;br/&gt;kind: Pod&lt;br/&gt;metadata:&lt;br/&gt;  name: multi-container-Pod&lt;br/&gt;spec:&lt;br/&gt;  containers:&lt;br/&gt;    - name: container-1&lt;br/&gt;      image: busybox&lt;br/&gt;      &lt;span&gt;command&lt;/span&gt;: [&lt;span&gt;&#x27;/bin/sh&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;-c&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sleep 1d&#x27;&lt;/span&gt;]&lt;br/&gt;    - name: container-2&lt;br/&gt;      image: nginx&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部署时，会发生以下事情：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 在节点上拥有独立的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配一个 IP 地址给 Pod ，两个容器之间共享端口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;两个容器共享相同的网络命名空间，并在本地彼此可见。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络配置在后台迅速完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，让我们退后一步，尝试理解为什么运行容器需要上述动作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Linux 中，网络命名空间是独立的、隔离的逻辑空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以将网络命名空间视为，将物理网络接口分割小块之后的独立部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个部分都可以单独配置，并拥有自己的网络规则和资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些包括防火墙规则、接口（虚拟的或物理的）、路由以及与网络相关的所有内容。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;物理网络接口持有根网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeCr3SXvIziagKibKWcJnJnG85lu6tjNZL9gxMlibtLXsQj4olSVK7A1GSQAM6pic8d9EF/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;   2. 你可以使用 Linux 网络命名空间来创建独立的网络。每个网络都是独立的，除非你进行配置，默认不会与其他网络互通。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeBxFxturq3UYicHkBejOicRxjfQLqYZ3iae2OTtGvMcB7yaicZuUcM7ia0yHCu3n3dSeDw/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但最终，还是需要物理接口处理所有真实的数据包，所有虚拟接口都是基于物理接口创建的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络命名空间可以通过 ip-netns 进行管理，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip netns list&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 可以列出主机上的命名空间。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;需要注意的是，创建的网络命名空间会出现在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/var/run/netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 下面，但 Docker 并没有遵循这一规则。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，这是 Kubernetes 节点的一些命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns list&lt;br/&gt;&lt;br/&gt;cni-0f226515-e28b-df13-9f16-dd79456825ac (id: 3)&lt;br/&gt;cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd (id: 4)&lt;br/&gt;cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e (id: 2)&lt;br/&gt;cni-7619c818-5b66-5d45-91c1-1c516f559291 (id: 1)&lt;br/&gt;cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8 (id: 0)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意 cni- 前缀；这意味着命名空间是由 CNI 插件创建的。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你创建一个 Pod，Pod 被分配给一个节点后，CNI 将：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 Pod 包含多个容器，那么这些容器都将被放在同一个命名空间中。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当创建 Pod 时，容器运行时会给容器创建一个网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BegSvV3vG5npW8KdmeCV7G7dFaPWGiaoeBMia6L2y2vnbPibFlMibT6jr7wsDkclmxWUrt/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 然后 CNI 负责给 Pod 分配一个 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bebia7oqUicByX4Ac2flVzh1UaRu4TVjLOCL9BMnnpV6nyvTc5K4Ykkiak0Iks79VHqSO/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. 最后 CNI 将容器连接到网络的其余部分。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be9a5micood7GQDpGiaS3KpUtribNhd8nFTbXia4x4csD86lGjRgs5A3UfOV9g5IALIdiaK/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，当你列出节点上的容器的命名空间会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以通过 SSH 连接到 Kubernetes 节点并查看命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ lsns -t net&lt;br/&gt;&lt;br/&gt;        NS TYPE NPROCS   PID USER     NETNSID NSFS                           COMMAND&lt;br/&gt;4026531992 net     171     1 root  unassigned /run/docker/netns/default      /sbin/init noembed norestore&lt;br/&gt;4026532286 net       2  4808 65535          0 /run/docker/netns/56c020051c3b /pause&lt;br/&gt;4026532414 net       5  5489 65535          1 /run/docker/netns/7db647b9b187 /pause&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;lsns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一个用于列出主机上所有可用命名空间的命令。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;请记住，Linux 中有多种命名空间类型。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx 容器在哪里？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那些 pause 容器是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;在 Pod 中，pause 容器创建了网络命名空间&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先列出节点上的所有命名空间，看看能否找到 Nginx 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ lsns&lt;br/&gt;        NS TYPE   NPROCS   PID USER            COMMAND&lt;br/&gt;&lt;span&gt;# truncated output&lt;/span&gt;&lt;br/&gt;4026532414 net         5  5489 65535           /pause&lt;br/&gt;4026532513 mnt         1  5599 root            sleep 1d&lt;br/&gt;4026532514 uts         1  5599 root            sleep 1d&lt;br/&gt;4026532515 pid         1  5599 root            sleep 1d&lt;br/&gt;4026532516 mnt         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;4026532517 uts         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;4026532518 pid         3  5777 root            nginx: master process nginx -g daemon off;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Nginx 容器在挂载 (&lt;/span&gt;&lt;code&gt;&lt;span&gt;mnt&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)、Unix time-sharing (&lt;/span&gt;&lt;code&gt;&lt;span&gt;uts&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 和 PID (&lt;/span&gt;&lt;code&gt;&lt;span&gt;pid&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 命名空间中，但不在网络命名空间 (&lt;/span&gt;&lt;code&gt;&lt;span&gt;net&lt;/span&gt;&lt;/code&gt;&lt;span&gt;) 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不幸的是，&lt;/span&gt;&lt;code&gt;&lt;span&gt;lsns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 只显示每个进程最小的 PID，但你可以根据这个进程 ID 进一步过滤。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用以下命令，在所有命名空间中检索 Nginx 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ sudo lsns -p 5777&lt;br/&gt;&lt;br/&gt;       NS TYPE   NPROCS   PID USER  COMMAND&lt;br/&gt;4026531835 cgroup    178     1 root  /sbin/init noembed norestore&lt;br/&gt;4026531837 user      178     1 root  /sbin/init noembed norestore&lt;br/&gt;4026532411 ipc         5  5489 65535 /pause&lt;br/&gt;4026532414 net         5  5489 65535 /pause&lt;br/&gt;4026532516 mnt         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;4026532517 uts         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;4026532518 pid         3  5777 root  nginx: master process nginx -g daemon off;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进程再次出现，它劫持了网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是怎么回事？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;集群中的每个 Pod 都有一个额外的隐藏容器在后台运行，称为 pause 容器。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列出在节点上运行的容器并获取 pause 容器：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ docker ps | grep pause&lt;br/&gt;&lt;br/&gt;fa9666c1d9c6   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_kube-dns-599484b884-sv2js…&lt;br/&gt;44218e010aeb   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_blackbox-exporter-55c457d…&lt;br/&gt;5fb4b5942c66   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_kube-dns-599484b884-cq99x…&lt;br/&gt;8007db79dcf2   k8s.gcr.io/pause:3.4.1  &lt;span&gt;&quot;/pause&quot;&lt;/span&gt;  k8s_POD_konnectivity-agent-84f87c…&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，节点上的每一个 Pod 都会有一个对应的 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pause&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 容器负责创建和维持网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层容器运行时会完成网络命名空间的创建，通常是由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;containerd&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CRI-O&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在部署 Pod 和创建容器之前，由运行时创建网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器运行时会自动完成这些，不需要手工执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip netns&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 创建命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;话题回到 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它包含非常少的代码，并且在部署后立即进入睡眠状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，它是必不可少的，并且在 Kubernetes 生态系统中起着至关重要的作用。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 Pod 时，容器运行时会创建一个带有睡眠容器的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeCVjs8AOVUdNOON0ste3qoVrqKLCtZTe2VmVC3I9qPdkGFLfuMQib086zhA4FSeqlf/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. Pod 中的其他容器都会加入由 pause 容器创建的网络名称空间。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeFuPxkjoSqg0YSBKonSYQV6h34JicvkQ1jxVzwdcYTicibCz4Gicsjwgoib6GcMEprqRjx/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. 此时，CNI 分配 IP 地址并将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BenHsjlEYNbanECNPicZuSYrylsdedDFiafO0dlCzs4IWWhHpdNOt6XU5V1ck8NicH6ux/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个进入睡眠状态的容器有什么用？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了理解它的用途，让我们想象一个 Pod 有两个容器，就像前面的例子一样，但没有 pause 容器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一旦容器启动，CNI 将会：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使 busybox 容器加入之前的网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将容器连接到网络。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 Nginx 崩溃了怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 将不得不再次执行所有步骤，并且两个容器的网络都将中断。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于睡眠容器不太可能有任何错误，因此创建网络命名空间通常是一种更安全、更健壮的选择。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;如果 Pod 中的一个容器崩溃了，剩下的仍然可以回复其他网络请求。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;分配一个 IP 地址给 Pod&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面我提到 Pod 和两个容器将具有同一个 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那是怎样配置的呢？&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;在 Pod 网络命名空间内，创建了一个接口，并分配了一个 IP 地址。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们验证一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，找到 Pod 的 IP 地址：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ kubectl get Pod multi-container-Pod -o jsonpath={.status.PodIP}&lt;br/&gt;&lt;br/&gt;10.244.4.40&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，找到相关的网络命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于网络命名空间是从物理接口创建的，需要先访问集群节点。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果你运行的是 minikube，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;minikube ssh&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 访问节点。如果在云厂中运行，那么应该有某种方法可以通过 SSH 访问节点。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进入后，找到最新创建的命名网络命名空间：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ls -lt /var/run/netns&lt;br/&gt;&lt;br/&gt;total 0&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 25 13:34 cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-4e4dfaac-89a6-2034-6098-dd8b2ee51dcd&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7e94f0cc-9ee8-6a46-178a-55c73ce58f2e&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-7619c818-5b66-5d45-91c1-1c516f559291&lt;br/&gt;-r--r--r-- 1 root root 0 Sep 24 09:39 cni-3004ec2c-9ac2-2928-b556-82c7fb37a4d8&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在示例中，就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。然后，可以在该命名空间内运行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;exec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip a&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# output truncated&lt;/span&gt;&lt;br/&gt;3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP group default&lt;br/&gt;    link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;br/&gt;    inet 10.244.4.40/32 brd 10.244.4.40 scope global eth0&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;    inet6 fe80::14a4:f8ff:fe4f:5677/64 scope link&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 IP 就是 Pod 的 IP 地址！通过查找 @if12 中的 12 找到网络接口&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link | grep -A1 ^12&lt;br/&gt;&lt;br/&gt;12: vethweplb3f36a0@if16: mtu 1376 qdisc noqueue master weave state UP mode DEFAULT group default&lt;br/&gt;    link/ether 72:1c:73:d9:d9:f6 brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你还可以验证 Nginx 容器是否监听了来自该命名空间内的 HTTP 流量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac netstat -lnp&lt;br/&gt;&lt;br/&gt;Active Internet connections (only servers)&lt;br/&gt;Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name&lt;br/&gt;tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      692698/nginx: master&lt;br/&gt;tcp6       0      0 :::80                   :::*                    LISTEN      692698/nginx: master&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果你无法通过 SSH 访问集群中的工作节点，你可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl exec&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 获取到 busybox 容器的 shell 并直接在内部使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;netstat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 命令。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;刚刚我们介绍了容器之间的通信，再来看看如何建立 Pod 到 Pod 的通信吧。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;查看集群中 Pod 到 Pod 的流量&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 到 Pod 的通信有两种可能的情况：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 流量的目的地是同一节点上的 Pod。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod 流量的目的地是在不同节点上的 Pod。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个工作流依赖于虚拟接口对和网桥，下面先来了解一下这部分的内容。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;为了让一个 Pod 与其他 Pod 通信，它必须先访问节点的根命名空间。&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过虚拟以太网对来实现 Pod 和根命名空间的连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些虚拟接口设备（veth 中的 v）连接并充当两个命名空间之间的隧道。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用此 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备，你将一端连接到 Pod 的命名空间，另一端连接到根命名空间。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BenHsjlEYNbanECNPicZuSYrylsdedDFiafO0dlCzs4IWWhHpdNOt6XU5V1ck8NicH6ux/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 可以帮你执行这些操作，但你也可以手动执行：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link add veth1 netns Pod-namespace &lt;span&gt;type&lt;/span&gt; veth peer veth2 netns root&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在 Pod 的命名空间有一个可以访问根命名空间的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;隧道&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点上，新建的每一个 Pod 都会设置这样的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个是，创建接口对；另一个是为以太网设备分配地址并配置默认路由。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面看看如何在 Pod 的命名空间中设置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip addr add 10.244.4.40/24 dev veth1&lt;br/&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip link &lt;span&gt;set&lt;/span&gt; veth1 up&lt;br/&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip route add default via 10.244.4.40&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在节点上，让我们创建另一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip addr add 169.254.132.141/16 dev veth2&lt;br/&gt;$ ip link &lt;span&gt;set&lt;/span&gt; veth2 up&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以像前面一样检查现有的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Pod 的命名空间中，检索 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口的后缀。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip netns &lt;span&gt;exec&lt;/span&gt; cni-0f226515-e28b-df13-9f16-dd79456825ac ip link show &lt;span&gt;type&lt;/span&gt; veth&lt;br/&gt;&lt;br/&gt;3: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default&lt;br/&gt;    link/ether 16:a4:f8:4f:56:77 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在这种情况下，可以使用命令 &lt;/span&gt;&lt;code&gt;&lt;span&gt;grep -A1 ^12&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查找（或滚动到目标所在处）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ ip link show &lt;span&gt;type&lt;/span&gt; veth&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# output truncated&lt;/span&gt;&lt;br/&gt;12: cali97e50e215bd@if3: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1450 qdisc noqueue state UP mode DEFAULT group default&lt;br/&gt;    link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netns cni-0f226515-e28b-df13-9f16-dd79456825ac&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;也可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ip -n cni-0f226515-e28b-df13-9f16-dd79456825ac link show type veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.命令&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意 &lt;/span&gt;&lt;code&gt;&lt;span&gt;3: eth0@if12和12: cali97e50e215bd@if3&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口上的符号。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Pod 命名空间，该 &lt;/span&gt;&lt;code&gt;&lt;span&gt;eth0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 接口连接到根命名空间的 12 号接口，因此是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@if12&lt;/span&gt;&lt;/code&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对的另一端，根命名空间连接到 Pod 命名空间的 3 号接口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来是连接 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对两端的桥接器。&lt;/span&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1666439149231&quot; data-category_id_list=&quot;1|16|17|2|21|24|28|29|31|35|36|37|39|41|42|43|46|47|48|5|50|51|55|56|57|58|59|6|60|61|62|63|64|65|66|7|8&quot; data-id=&quot;1666439149231&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;Pod 网络命名空间连接到以太网桥&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网桥会汇聚位于根命名空间中的每一个虚拟接口。这个网桥允许虚拟 pair 之间的流量，也允许穿过公共根命名空间的流量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;补充一下相关原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以太网桥位于 OSI 网络模型 的第 2 层。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以将网桥视为接受来自不同命名空间和接口的连接的虚拟交换机。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以太网桥可以连接节点上的多个可用网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，可以使用网桥连接两个接口，即 Pod 命名空间的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 连接到同一节点上另一个 Pod 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BesVkTOuAy5VJ1icLJVzo86su8sL1xyuIZkZhntHEf3dgGWwvZjMPbiboicwwg6IHVn1D/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，继续看网桥和 veth 对的用途。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;跟踪在同一节点上 Pod 到 Pod 的流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设同一个节点上有两个 Pod，Pod-A 向 Pod-B 发送消息。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于访问目标不在同一个命名空间，Pod-A 将数据包发送到其默认接口 eth0。这个接口与 veth 对的一端绑定，作为隧道。这样，数据包会被转发到节点上的根命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be6DJTlhC4RAiaoibys0EZCE3mAwvV1ULf9PuCgDq2SpVNgmpyAcHlIc176WhrPpjA4B/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 以太网网桥作为一个虚拟交换机，需要目标 Pod-B 的 MAC 地址才能工作。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeroUL1R12qsQ2gvv89EzB8ueEFkgy6B8sATfPA7cdwkoC42AuU1CPHIZibxTWWvdpK/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  3. ARP 协议会解决这个问题。当帧到达网桥时，会向所有连接的设备发送 ARP 广播。网桥广播询问持有 Pod-B 的 IP 地址&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be24RTlRG2RD2RrHbrQjJXD84LsnwMfhPSQ59ibdXkaRrOCZhZCFpQJib58zyLFc5agy/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  4. 此时会收到一个带有 Pod-B IP 的 MAC 地址应答，这条消息会被存储在桥接 ARP 缓存(查找表)中。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeZDcrV9CMqsaxNL2MQnrIuibqAxjsWP80OwibZicmIibH2XwI826iczkaee8PicZibQMoRoj/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  5. IP 地址和 MAC 地址的映射关系存储之后，网桥就在表中查找，并将数据包转发到正确的端点。数据包到达根命名空间内 Pod-B 的 veth 之后，很快又到达 Pod-B 命名空间内的 eth0 接口。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BehnS9AMQytNxnibGXNwdqYuNey26PZgBGB7IvEQl1fXXXuL626hWFE8icw7iakMEiaBicM/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，Pod-A 和 Pod-B 之间的通信就成功了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;跟踪不同节点上的 Pod 到 Pod 通信&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于跨节点 Pod 之间的通信，会经过额外的通信跳跃。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前几个步骤保持不变，直到数据包到达根命名空间并需要发送到 Pod-B。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeMHNq80v5zydC5zgZKtN3JC5uH9iaBjAZIqIlnQZLGl1Gg9iaRvAIOrdssTjZ0LaV3U/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  2. 当目的 IP 不在本地网络中时，报文被转发到节点的默认网关。节点的出口网关或默认网关，通常位于节点与网络相连的物理接口 eth0 上。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BelLgSxy61hibZZLo4xvkwWEuJqqMW3ZzwibVv2DSomW7FerZ5SEIiaKczQlrrXR5dZQD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时 不会发生 ARP 解析，因为源 IP 和目标 IP 不在同一个网段中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网段的检查是使用按位运算完成的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当目的 IP 不在当前网络段时，数据包被转发到节点的默认网关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;按位运算的工作原理&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在确定数据包的转发位置时，源节点必须执行位运算&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这也称为与操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复习一下，按位与运算的规则：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;0 AND 0 = 0&lt;br/&gt;0 AND 1 = 0&lt;br/&gt;1 AND 0 = 0&lt;br/&gt;1 AND 1 = 1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了 1 与 1 以外的都是 false。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果源节点的 IP 为 192.168.1.1，子网掩码为 /24，目标 IP 为 172.16.1.1/16，则按位与运算将得知它们位于不同的网段上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这意味着目标 IP 与数据包的源不在同一个网络上，数据包将通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数学时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们必须从二进制的 32 位地址开始进行 AND 操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先找出源 IP 网络和目标 IP 网段。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.00000000.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.0.0(/16)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000000.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.0.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;按位运算之后，需要将目标 IP 与数据包源节点的子网进行比较。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000001&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.1&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Network Result&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;10101100.00010000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;172.16.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运算的结果是 172.16.1.0，不等于 192.168.1.0（源节点的网络）。说明源 IP 地址和目标 IP 地址不在同一个网络上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果目标 IP 是 192.168.1.2，即与发送 IP 在同一子网中，则 AND 操作将得到节点的本地网络。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;Type&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Binary&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;Converted&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Dst. IP Address&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000010&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.2&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Src. Subnet Mask&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11111111.11111111.11111111.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;255.255.255.0(/24)&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Network&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;11000000.10101000.00000001.00000000&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;192.168.1.0&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进行逐位比较后，ARP 通过查找表查找默认网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有条目，将立即转发数据包。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;否则，先进行广播以找到网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;现在，数据包路由到另一个节点的默认接口，我们称为 Node-B。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeG4lRwtJlvFUKuDFY4Y0hD6PmNYmqqHeib9hicMhC7IMKZicuuO6HM35lQ18a5hMsLgz/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以相反的顺序。现在，数据包位于 Node-B 的根命名空间，并到达网桥，这里会进行 ARP 解析。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeyxibLXQLqIyDecl8Z9gicIhjxbWnrB5hgrrYFJYSs4w6VJgRfVbibVm82OwuvmSTibZX/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;路由系统将返回与 Pod-B 相连的接口的 MAC 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Begoj8lneQsiby4ywWW8Piaibd4m6zLo0t5UWFXKicNQkGneWOZeyHenBWSsHH38kcbgbk/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;  4. 网桥通过 Pod-B 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设备转发帧，并到达 Pod-B 的命名空间。&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeC17ZWWrGPVGAXLlwBic1A2ncic9U0Z9L8vKDKFOwExPuibpdqsASuCo6hGNFukWnZA0/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，你应该已经熟悉了 Pod 之间的流量是如何流转的。下面，让我们花点时间来看看 CNI 如何管理上诉内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;容器网络接口 - CNI&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器网络接口（CNI）主要关注的是当前节点中的网络。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeQZm9icrtWfmQ96WauD5QQYfl0GbiaawR7p0QIoNoSzAIvg2jtj9JTBuy0a2jtXnvC5/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以将 CNI 看作为解决 Kubernetes 网络需求，而遵循的一组规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有这些 CNI 实现可供使用：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Calico&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Cillium&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Flannel&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Weave Net&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其他网络插件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;他们都遵循相同的 CNI 标准。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有 CNI，你需要人工完成如下操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建接口。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 veth 对。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置网络命名空间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置静态路由。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;配置以太网桥。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分配 IP 地址。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建 NAT 规则。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;还有其他大量事情。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这还不包括，在删除或重启 Pod 时，需要进行类似的全部操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CNI 必须支持四种不同的操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ADD - 向网络添加一个容器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;DEL - 从网络中删除一个容器。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CHECK - 如果容器的网络出现问题，则返回错误。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;VERSION - 显示插件的版本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们一起看下，CNI 是如何工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Pod 被分配到特定节点时，Kubelet 自身不会初始化网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，Kubelet 将这个任务交给 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;em&gt;但是，Kubelet 以 JSON 格式指定配置并发送至 CNI 插件。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你可以进入节点上的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/etc/cni/net.d&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件夹，使用以下命令查看当前的 CNI 配置文件：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ cat 10-calico.conflist&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;k8s-Pod-network&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;cniVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;0.3.1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;calico&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;datastore_type&quot;&lt;/span&gt;: &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;mtu&quot;&lt;/span&gt;: 0,&lt;br/&gt;      &lt;span&gt;&quot;nodename_file_optional&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;log_level&quot;&lt;/span&gt;: &lt;span&gt;&quot;Info&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;log_file_path&quot;&lt;/span&gt;: &lt;span&gt;&quot;/var/log/calico/cni/cni.log&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;ipam&quot;&lt;/span&gt;: { &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;calico-ipam&quot;&lt;/span&gt;, &lt;span&gt;&quot;assign_ipv4&quot;&lt;/span&gt; : &lt;span&gt;&quot;true&quot;&lt;/span&gt;, &lt;span&gt;&quot;assign_ipv6&quot;&lt;/span&gt; : &lt;span&gt;&quot;false&quot;&lt;/span&gt;},&lt;br/&gt;      &lt;span&gt;&quot;container_settings&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;allow_ip_forwarding&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;policy&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;k8s&quot;&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;k8s_api_root&quot;&lt;/span&gt;:&lt;span&gt;&quot;https://10.96.0.1:443&quot;&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;&quot;kubeconfig&quot;&lt;/span&gt;: &lt;span&gt;&quot;/etc/cni/net.d/calico-kubeconfig&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;bandwidth&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: {&lt;span&gt;&quot;bandwidth&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;}&lt;br/&gt;    },&lt;br/&gt;    {&lt;span&gt;&quot;type&quot;&lt;/span&gt;: &lt;span&gt;&quot;portmap&quot;&lt;/span&gt;, &lt;span&gt;&quot;snat&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;&quot;capabilities&quot;&lt;/span&gt;: {&lt;span&gt;&quot;portMappings&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;}}&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个 CNI 插件都会使用不同类型的网络配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，Calico 使用基于 BGP 的三层网络连接 Pod&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Cilium 从三层到七层使用的是基于 eBPF 的 overlay 网络&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与 Calico 一样，Cilium 也支持通过配置网络策略来限制流量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么你应该使用哪一个呢？主要有两类 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在第一类中，使用基本网络设置（也称为平面网络），从集群的 IP 池为 Pod 分配 IP 地址的 CNI。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方式可能很快耗尽 IP 地址，而成为负担。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相反，另一类是使用 overlay 网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，overlay 网络是主（底层）网络之上的重建网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;overlay 网络通过封装来自底层网络的数据包工作，这些数据包被发送到另一个节点上的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;overlay 网络的一种流行技术是 VXLAN，它可以在 L3 网络上建立 L2 域的隧道。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么哪个更好呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没有单一的答案，这取决于你的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你是否正在构建具有数万个节点的大型集群？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;也许 overlay 网络更好。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你是否在意更简单的配置和审查网络流量，而不会愿意在复杂网络中丢失这种能力？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扁平网络更适合你。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们讨论完了 CNI，接着让我们来看看 Pod 到服务的通信是如何连接的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;检查 Pod 到 Service 的流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于 Pod 在 Kubernetes 中是动态的，分配给 Pod 的 IP 地址不是静态的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod 的 IP 是短暂的，每次创建或删除 Pod 时都会&lt;/span&gt;&lt;span&gt;发生变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中的 Service 解决了这个问题，为连接一组 Pod 提供了可靠的机制。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BesLEAKPUeuZ4YF1tkHT7IiaWHL76olXNFKHmrUgMQw3HNxAt8U67zvURqH0UBcNrH8/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认情况下，在 Kubernetes 中创建 Service 时，被分配一个虚拟 IP。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Service 中，可以使用选择器将 Service 与目标 Pod 相关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当删除或添加一个 Pod 时会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Service 的虚拟 IP 保持静态不变。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但流量可以再无需干预的情况下，到达新创建的 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;换句话说，Kubernetes 中的 Service 类似于负载均衡器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但它们是如何工作的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;使用 Netfilter 和 Iptables 拦截和重写流量&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Kubernetes 中的 Service 是基于 Linux 内核中的两个组件构建的：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;网络过滤器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Netfilter 是一个可以配置数据包过滤、创建 NAT 、端口转发规则以及管理网络中流量的框架&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，它可以屏蔽和禁止未经同意的访问。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另一方面，iptables 是一个用户态程序，可以用来配置 Linux 内核防火墙的 IP 数据包过滤规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;iptables 是作为不同的 Netfilter 模块实现的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以使用 iptables CLI 即时修改过滤规则，并将它们插入 netfilters 挂载点。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;过滤器配置在不同的表中，其中包含用于处理网络流量数据包的链。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同的协议使用不同的内核模块和程序。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;当提到 iptables 时，通常指的是 IPv4。对于 IPv6 ，终端工具是 ip6tables。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;iptables 有五种链，每一种链都直接映射到 Netfilter 的钩子上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 iptables 的角度来看，它们是：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;INPUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;FORWARD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;OUTPUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;POST_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们对应地映射到 Netfilter 钩子：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_LOCAL_IN&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_FORWARD&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_LOCAL_OUT&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;NF_IP_POST_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个数据包到达时，根据它所处的阶段，将 “触发” 一个 Netfilter 钩子。这个钩子会执行特定的 iptables 过滤规则。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeNzsOFCWdyOAxKFPL5ghCJlTYxWdtpnp3pgPQLOUE3p2hRKJJ1j43DQVNoiculxnFD/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哎呀！看起来很复杂！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过没什么好担心的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就是我们使用 Kubernetes 的原因，以上所有内容都是通过使用 Service 抽象出来的，并且一个简单的 YAML 定义可以自动设置这些规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你有兴趣查看 iptables 规则，可以连接到节点并运行：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ iptables-save&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你还可以使用这个工具来可视化节点上的 iptables 链。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是来自 GKE 节点上的可视化 iptables 链的示例图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BedtQUk0u83ibwK8m6POrS2gsneOJ1DY4GlQ5pAxF4FCkRL8O2aPT31EtsnUAP0sZh6/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意，这里可能配置了几百条规则，想想一下自己动手怎么配置！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我们已经了解了，相同节点上的 Pod 和不同节点上 Pod 之间是如何通信的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Pod 与 Service 的通信中，链路的前半部分是一样的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bex5aicXl6q5Tgscxlc1StCMru68bud4EUM8sxnpggX8qALyEHwjRcicwOvNUfWq60zib/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当请求从 Pod-A 走向 Pod-B 时，由于 Pod-B 在 Service 的 “后面”，在传输的过程中，会有一些不一样。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原始的请求，在 Pod-A 命名空间的 eth0 接口发出。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着，请求通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt;到达根名称空间的网桥。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一旦到达网桥，数据包就会立即通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与 Pod-to-Pod 部分一样，主机进行按位比较。由于服务的虚拟 IP 不是节点 CIDR 的一部分，因此数据包将立即通过默认网关转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果默认网关的 MAC 地址尚未出现在查找表中，则会进行 ARP 解析找出默认网关的 MAC 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在神奇的事情发生了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据包通过节点的路由之前，Netfilter 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;NF_IP_PRE_ROUTING&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 挂钩被触发，并执行 iptables 规则。这个规则会修改 Pod-A 数据包的目标 IP 地址 DNAT。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeLcmZIQemsib9micmpkp2dUZHib8EqgGVnQpjmyTLicniczyhgEjWxWeHC3TXqOYyFpmIz/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面服务的虚拟 IP 地址被重写为 Pod-B 的 IP 地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，数据包路由过程与 Pod 到 Pod 的通信一样。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Be7hqickzPFlfnFuwuDO6lZu9pJSgh7EOxPDVhUZCvvjCOD3XcNn1l4FF7MLRJ00UFC/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据包重写后，通信是 Pod 到 Pod。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然而，在所有这些通信中，使用了一个第三方的功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此功能称为 conntrack 或链路跟踪。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Pod-B 发回响应时，conntrack 会将数据包与链路相关联，并跟踪其来源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NAT 严重依赖于 conntrack。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有链路跟踪，将不知道将包含响应的数据包发回何处。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 conntrack 时，数据包的返回路径很容易设置为相同的源或目标 NAT 更改。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通信的另一部分与现在的链路相反。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod-B 接收并处理了请求，现在将数据发送回 Pod-A。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在会发生什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;检查来自服务的响应&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Pod-B 发送响应，将其 IP 地址设置为源地址，并将 Pod-A 的 IP 地址设置为目标地址。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeFzHenJSp8WjMRpeTS1lPVkLFdKWVjCG2jfasJ8bUjylvSiaWDU26LztAHn3ibK9Cue/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当数据包到达 Pod-A 所在节点的接口时，会发生另一个 NAT。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6BeS1wn2WowD4AS4Errtia3GfQdCwDCOUTv3ibqnfL4vJUIc56CsYz5kI0Za2O7asicv6m/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时，conntrack 开始工作，修改源 IP 地址，iptables 规则执行 SNAT，并将 Pod-B 的源 IP 地址修改为原始服务的虚拟 IP。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/eytJa9K5jkqKibwGy0jNADSV0jnNvo6Bepjky9nzc3KanppnRs1PpIIde7kcicd7gpEmxljVyZcFEAaGrGMwaZGQPicWPbuPwUo/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 Pod-A 来说，响应是来自于 Service 而不是 Pod-B。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其余的都是一样的。一旦 SNAT 完成，数据包就会到达根命名空间中的网桥，并通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;veth&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对转发到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pod-A&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总 结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们一起回顾下本文相关要点&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;容器如何在本地或 Pod 内通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在相同节点和不同节点上的 Pod 如何通信。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Pod-to-Service - Pod 如何将流量发送到 Kubernetes 中服务后面的 Pod 时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;什么是命名空间、veth、iptables、chains、conntrack、Netfilter、CNI、overlay 网络，以及 Kubernetes 网络工具箱中所需的一切。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>