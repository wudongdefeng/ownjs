<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ddd9ef3f1b5c49d139e4ba7fd56e06b9</guid>
<title>全网最全的权限系统设计方案（图解）</title>
<link>https://toutiao.io/k/lozkmee</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1 为什么需要权限管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常工作中权限的问题时时刻刻伴随着我们，程序员新入职一家公司需要找人开通各种权限，比如网络连接的权限、编码下载提交的权限、监控平台登录的权限、运营平台查数据的权限等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在很多时候我们会觉得这么多繁杂的申请给工作带来不便，并且如果突然想要查一些数据，发现没有申请过权限，需要再走审批流程，时间拉得会很长。那为什么还需要这么严格的权限管理呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，一家支付公司有运营后台，运营后台可以查到所有的商户信息，法人代表信息，交易信息以及费率配置信息，如果我们把这些信息不加筛选都给到公司的每一个小伙伴，那么跑市场的都可以操作商家的费率信息，如果一个不小心把费率改了会造成巨大的损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如商户的信息都是非常隐秘的，有些居心不良的小伙伴把这些信息拿出来卖给商家的竞争对手，会给商家造成严重的不良后果。虽然这么做都是个别人人为的过错，但是制度上如果本身这些信息不开放出来就能在很大程度上避免违法乱纪的事情发生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来讲&lt;strong&gt;权限管理是公司数据安全的重要保证，针对不同的岗位，不同的级别看到的数据是不一样的，操作数据的限制也是不一样的。&lt;/strong&gt;比如涉及到资金的信息只开放给财务的相关岗位，涉及到配置的信息只开放给运营的相关岗位，这样各司其职能避免很多不必要的安全问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如何让各个岗位的人在系统上各司其职，就是权限管理要解决的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2 权限模型&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 权限设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从业务分类上来讲权限可以分为数据查看权限，数据修改权限等，对应到系统设计中有页面权限、菜单权限、按钮权限等。菜单也分一级菜单、二级菜单甚至三级菜单，以csdn文章编辑页面左侧菜单栏为例是分了两级菜单。菜单对应的页面里又有很多按钮，我们在设计的时候最好把权限设计成树形结构，这样在申请权限的时候就可以一目了然的看到菜单的结构，需要哪些权限就非常的明了了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.563302752293578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7nn7wjVKBrX4icyVY40flLXqTVFQFjMTNx72QPVsseZ3mdrFPpwM8C1g/640?wx_fmt=png&amp;amp;random=0.3869801465108955&quot; data-type=&quot;png&quot; data-w=&quot;1090&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照这个架构，按钮的父级是二级菜单，二级菜单的父级是一级菜单，这样用户申请权限的时候非常清晰的看到自己需要哪些权限。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 为什么需要角色&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;权限结构梳理清晰之后，需要思考怎么把权限分配给用户，用户少的情况下，可以直接分配，一个用户可以有多个权限，统一一个权限可以被多个用户拥有，用户-权限的模型结构如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25984251968503935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq73HUxp4kSjepVXIibazxT1kcOnuZxf1jTL4mwLQwgYyX512p28fzOmNg/640?wx_fmt=png&amp;amp;random=0.12281593247417089&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;这种模型能够满足权限的基本分配能力，但是随着用户数量的增长，这种模型的弊端就凸显出来了，每一个用户都需要去分配权限，非常的浪费管理员的时间和精力，并且用户和权限杂乱的对应关系会给后期带来巨大的维护成本。用户-权限对应关系图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8726708074534162&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7mNU34iciasyLzPxZ0EMspjJ9sY47UyhSAl0MoQ2ukttkMrX7rzgf6SKw/640?wx_fmt=png&amp;amp;random=0.379500115530764&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;这种对应关系在用户多的情况下基本无法维护了。其实很多用户负责同一个业务模块所需要的权限是一样的，这样的话我们是不是可以借助第三个媒介，把需要相同的权限都分配给这个媒介，然后用户和媒介关联起来，用户就拥有了媒介的权限了。这就是经典的RBAC模型，其中媒介就是我们通常所说的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 权限模型的演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.1 RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了角色之后可以把权限分配给角色，需要相同权限的用户和角色对应起来就可以了，一个权限可以分配给多个角色，一个角色可以拥有多个权限，同样一个用户可以分配多个角色，一个角色也可以对应多个用户，对应模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17224080267558528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq70Pp3ia1T0qWCpcO3hoibptmXtfMFmuLV5R0pKdZpBibHLE6c5htVDUcUA/640?wx_fmt=png&amp;amp;random=0.7805500510170766&quot; data-type=&quot;png&quot; data-w=&quot;1196&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是经典的RBAC模型了（role-based-access-control），在这里面角色起到了桥梁左右，连接了用户和权限的关系，每个角色可以拥有多个权限，每个用户可以分配多个角色，这样用户就拥有了多个角色的多个权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时因为有角色作为媒介，大大降低了错综复杂的交互关系，比如一家有上万人的公司，角色可能只需要几百个就搞定了，因为很多用户需要的权限是一样的，分配一样的角色就可以了。这种模型的对应关系图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46864686468646866&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7SyN9SrzXEnBS0RDBVicmt3PlGDvovzf05C1ulRyVadO9oD6hYHbtP6A/640?wx_fmt=png&amp;amp;random=0.2863653075923056&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户和角色，角色和权限都是多对多的关系，这种模型是最通用的权限管理模型，节省了很大的权限维护成本， 但是实际的业务千变万化，权限管理的模型也需要根据不同的业务模型适当的调整，比如一个公司内部的组织架构是分层级的，层级越高权限越大，因为层级高的人不仅要拥有自己下属拥有的权限，二期还要有一些额外的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型可以给不同层级的人分配不同的角色，层级高的对应角色的权限就多，这样的处理方式可以解决问题，但是有没有更好的解决办法呢，答案肯定是有的，这就引出&lt;strong&gt;角色继承的RBAC模型&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.2 角色继承的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;角色继承的RBAC模型又称RBAC1模型。每个公司都有自己的组织架构，比如公司里管理财务的人员有财务总监、财务主管、出纳员等，财务主管需要拥有但不限于出纳员的权限，财务总监需要拥有但不限于财务主管的权限，像这种管理关系向下兼容的模式就需要用到角色继承的RBAC模型。&lt;strong&gt;角色继承的RBAC模型的思路是上层角色继承下层角色的所有权限，并且可以额外拥有其他权限。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7605363984674329&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Vz5WxDUJECmsqerotwzqLJXTVm2HDRkZGhc6OIfBmiaJiagYjiapXBFnQ/640?wx_fmt=png&amp;amp;random=0.01075333932726652&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;从模型图中可以看出下级角色拥有的权限，上级角色都拥有，并且上级角色可以拥有其他的权限。角色的层级关系可以分为两种，一种是下级角色只能拥有一个上级角色，但是上级角色可以拥有多个下级角色，这种结构用图形表示是一个树形结构，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5091911764705882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7vTkqibyicXmfwX5eQCzCFabxibpGUa2NG1LtAE55js6Gms3yPKxbSlHzg/640?wx_fmt=png&amp;amp;random=0.9664950058278607&quot; data-type=&quot;png&quot; data-w=&quot;1088&quot;/&gt;还有一种关系是下级角色可以拥有多个上级角色，上级角色也可以拥有多个下级角色，这种结构用图形表示是一个有向无环图，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5064456721915286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7BD3bNkYP7mqzTYEVhia1UJMiaokMSAlWdmobLACVu5CyItAWxrH1Cpsw/640?wx_fmt=png&amp;amp;random=0.04259729352510133&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;树形图是我们比较常用的，因为一个用户一般情况下不会同时有多个直属上级，比如财务部只能有一个财务总监，但是可以有多个财务主管和收纳员。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3.3 带约束的RBAC模型&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带约束的RBAC模型又成RBAC2模型。在实际工作中，为了安全的考虑会有很多约束条件，比如财务部里同一个人不能即是会计又是审核员，跟一个人同一时间不能即是运动员又是裁判员是一个道理的，又比如财务部的审核员不能超过2个，不能1个也没有。因为角色和权限是关联的，所以我们做好角色的约束就可以了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;常见的约束条件有：角色互斥、基数约束、先决条件约束等。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;角色互斥：&lt;/strong&gt; 如果角色A和角色B是互斥关系的话，那么一个用户同一时间不能即拥有角色A，又拥有角色B，只能拥有其中的一个角色。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如我们给一个用户赋予了会计的角色就不能同时再赋予审核员的角色，如果想拥有审核员的角色就必须先去掉会计的角色。假设提交角色和审核角色是互质的，我们可以用图形表示：&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3898989898989899&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7ZpUKnW9qWjqtpmH9pOic9ye6hAjz1IEFaSarNTwZTGbqibFva5ly7ODg/640?wx_fmt=png&amp;amp;random=0.5303696963485485&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;strong&gt;基数约束：&lt;/strong&gt; 同一个角色被分配的用户数量可以被限制，比如规定拥有超级管理员角色的用户有且只有1个；用户被分配的角色数量也需要被限制，角色被分配的权限数量也可以被限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;先决条件约束：&lt;/strong&gt;用户想被赋予上级角色，首先需要拥有下级角色，比如技术负责人的角色和普通技术员工角色是上下级关系，那么用户想要用户技术负责人的角色就要先拥有普通技术员工的角色。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 用户划分&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.1 用户组&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们创建角色是为了解决用户数量大的情况下，用户分配权限繁琐以及用户-权限关系维护成本高的问题。抽象出一个角色，把需要一起操作的权限分配给这个角色，把角色赋予用户，用户就拥有了角色上的权限，这样避免了一个个的给用户分配权限，节省了大量的资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的如果有一批用户需要相同的角色，我们也需要一个个的给用户分配角色，比如一个公司的客服部门有500多个人，有一天研发部研发了一套查询后台数据的产品，客服的小伙伴都需要使用，但是客服由于之前并没有统一的一个角色给到所有的客服小伙伴，这时候需要新加一个角色，把权限分配给该角色，然后再把角色一个个分配给客服人员，这时候会发现给500个用户一个个添加角色非常的麻烦。但是客服人员又有共同的属性，所以我们可以创建一个用户组，所有的客服人员都属于客服用户组，把角色分配给客服用户组，这个用户组下面的所有用户就拥有了需要的权限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型添加用户组之后的模型图如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44676409185803756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7AOXjfzkg6ayvFhyqFepD2iaTibyFXBlQwd0NeZn6OGQCkgCrJdMo7a0Q/640?wx_fmt=png&amp;amp;random=0.7284421954870555&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;很多朋友会问，用户组和角色有什么区别呢？简单的来说，&lt;strong&gt;用户组是一群用户的组合，而角色是用户和权限之间的桥梁。&lt;/strong&gt; 用户组把相同属性的用户组合起来，比如同一个项目的开发、产品、测试可以是一个用户组，同一个部门的相同职位的员工可以是一个用户组， 一个用户组可以是一个职级，可以是一个部门，可以是一起做事情的来自不同岗位的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户可以分组，权限也可以分组，权限特别多的情况下，可以把一个模块的权限组合起来成为一个权限组，权限组也是解决权限和角色对应关系复杂的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们定义权限的时候一级菜单、二级菜单、按钮都可以是权限，一个一级菜单下面有几十个二级菜单，每个二级菜单下面又有几十个按钮，这时候我们把权限一个个分配给角色也是非常麻烦的，可以采用分组的方法把权限分组，然后把分好的组赋予角色就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给权限分组也是个技术活，需要理清楚权限之间的关系，比如支付的运营后台我们需要查各种信息，账务的数据、订单的数据、商户的数据等等，这些查询的数据并不在一个页面，每个页面也有很多按钮，我们可以把这几个页面以及按钮对应的权限组合成一个权限组赋予角色。加入权限组之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44258872651356995&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7Nv23yWO5UqQ1pJfFZ91ibRRz9ebKWcECWctygzdANx1zvHFatVPRiaMw/640?wx_fmt=png&amp;amp;random=0.3565732072391419&quot; data-type=&quot;png&quot; data-w=&quot;958&quot;/&gt;实际工作中我们很少给权限分组，给用户分组的场景会多一些，有的时候用户组也可以直接和权限关联，这个看实际的业务场景是否需要，权限模型没有统一的，业务越复杂业务模型会约多样化。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.2 组织&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个公司都有自己的组织架构，很多时候权限的分配可以根据组织架构来划分。因为同一个组织内的小伙伴使用的大部分权限是一样的。如下所示一个公司的组织架构图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5008210180623974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7dbXNuYRGZNcaZib6H7oG4AgiaheboEicZStGr81tbUC5qOaiaJObnmONYw/640?wx_fmt=png&amp;amp;random=0.4545984963546068&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;按照这个组织架构，每一个组织里的成员使用的基础权限很可能是一样的，比如人力资源都需要看到人才招聘的相关信息，市场推广都需要看到行业分析的相关信息，按照组织来分配角色会有很多优势：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现权限分配的自动化：&lt;/strong&gt; 和组织关系打通之后，按照组织来分配角色，如果有新入职的用户，被划分在某个组织下面之后，会自动获取该组织下所有的权限，无需人工分配。又比如有用户调岗，只需要把组织关系调整就可以了，权限会跟着组织关系自动调整，也无需人工干预。这么做首先需要把权限和组织关系打通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;控制数据权限：&lt;/strong&gt; 把角色关联到组织，组织里的成员只能看到本组织下的数据，比如市场推广和大客定制，市场推广针对的是零散的客户，大可定制针对的是有一定体量的客户，相互的数据虽然在一个平台，但是只能看自己组织下的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加入组织之后的RBAC模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4425531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7lWt5ia70uWdoanLr5bhpA1vd8Mva67aEbFdiafTTPck10snrWwncNr7A/640?wx_fmt=png&amp;amp;random=0.43082287972094635&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;用户可以在多个组织中，因为组织也有层级结构，一个组织里只可以有多个用户，所以用户和组织的关系是多对多的关系，组织和角色的关系是一对一的关系。这个在工作中可以根据实际情况来确定对应关系。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.4.3 职位&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个组织下面会有很多职位，比如财务管理会有财务总监、财务主管、会计、出纳员等职位，每个职位需要的权限是不一样的，可以像组织那样根据职位来分配不同的角色，由于一个人的职位是固定的，所以用户跟职位的对应关系时一对一的关系，职位跟角色的对应关系可以是多对多的关系。加入职位的RBAC模型如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4451476793248945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kcXicbH94aqTjw4aRwMysbxhPvEwDnBicYYIZ551WZm4ib50Kfv38D7CA/640?wx_fmt=png&amp;amp;random=0.8327855836170899&quot; data-type=&quot;png&quot; data-w=&quot;948&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 理想的RBAC模型&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RBAC模型根据不同业务场景的需要会有很多种演变，实际工作中业务是非常复杂的，权限分配也是非常复杂的，想要做出通用且高效的模型很困难。我们把RBAC模型的演变汇总起来会是一个支撑大数据量以及复杂业务的理想的模型。把RBAC、RBAC1、RBAC2、用户组、组织、职位汇总起来的模型如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4702517162471396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7fzPfV1Lno8roOmeJ4gd3CKsr0iclcsviaTkJlIia3xLtn7gooooEs1vfA/640?wx_fmt=png&amp;amp;random=0.7807457219448579&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;按照这个模型基本上能够解决所有的权限问题，其中的对应关系可以根据实际的业务情况来确定，一般情况下，组织和职位是一对多的关系，特殊情况下可以有多对多的情况，需要根据实际情况来定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型并不是说我们一开始建权限模型就可以这么做，而是数据体量、业务复杂度达到一定程度之后可以使用这个模型来解决权限的问题，如果数据量特别少，比如刚成立的公司只有十几个人，那完全可以用用户-权限模型，都没有必要使用RBAC模型。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3 权限系统表设计&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 标准RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准RBAC模型的表是比较简单了，要表示&lt;code&gt;用户-角色-权限&lt;/code&gt;三者之前的关系，首先要创建用户表、角色表、权限表，用户和角色是多对多的关系，角色和权限是多对多的关系，需要再创建两章关系表，分别是用户-角色关系表和角色-权限关系表。这六张表的ER图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4920886075949367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7kgfe8UC7IVzSzSzqO6fn3SAZ7vw1l7PYiaNXCcTd5JajrEsseJpIAmw/640?wx_fmt=png&amp;amp;random=0.5719574040529976&quot; data-type=&quot;png&quot; data-w=&quot;1264&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 理想RBAC模型表设计&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的RBAC模型是标准RBAC模型经过多次扩展得到的，表结构也会比较复杂，因为要维护很多关系，如下图所示是理想的RBAC模型的ER图：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5965417867435159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbufvG3CicBF8k4RCzpxduTQq7icQjj6sPTuvRdUAjKc9icrkV7tQNwuic8HWOf2cfTGz7RwZBfzbjfuUcA/640?wx_fmt=png&amp;amp;random=0.021794103728019598&quot; data-type=&quot;png&quot; data-w=&quot;2082&quot;/&gt;这里面需要强调的是角色互斥表，互斥的关系可以放在角色上，也可以放在权限上，看实际工作的需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4 结语&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从易到难非常详细的介绍了权限模型的设计，在工作中需要根据实际情况来定义模型，千人以内的公司使用RBAC模型是完全够用的，没有必要吧权限模型设计的过于复杂。模型的选择要根据具体情况，比如公司体量、业务类型、人员数量等。总之最适合自己公司的模型就是最好的模型，权限模式和设计模式是一样的，都是为了更好的解决问题，不要为了使用模型而使用模型。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>83a5b260c1357d19c1fcf67438e4cf07</guid>
<title>麻了，代码改成多线程，竟有9大问题</title>
<link>https://toutiao.io/k/1lggdyi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;文末留言送书啦！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们为了提升接口的性能，会把之前&lt;code&gt;单线程同步&lt;/code&gt;执行的代码，改成&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查询用户信息接口，&lt;code&gt;同步调用&lt;/code&gt;三个接口获取数据，会非常耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常有必要把三个接口调用，改成&lt;code&gt;异步调用&lt;/code&gt;，最后&lt;code&gt;汇总结果&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如：注册用户接口，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该用户注册接口包含的业务逻辑比较多，如果在接口中同步执行这些代码，该接口响应时间会非常慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就需要把业务逻辑梳理一下，划分：&lt;code&gt;核心逻辑&lt;/code&gt;和&lt;code&gt;非核心逻辑&lt;/code&gt;。这个例子中的核心逻辑是：写用户表和分配权限，非核心逻辑是：配置用户导航页和发通知消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然&lt;code&gt;核心逻辑&lt;/code&gt;必须在接口中&lt;code&gt;同步执行&lt;/code&gt;，而&lt;code&gt;非核心逻辑&lt;/code&gt;可以&lt;code&gt;多线程异步&lt;/code&gt;执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要使用多线程的业务场景太多了，使用多线程异步执行的好处不言而喻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我要说的是，如果多线程没有使用好，它也会给我们带来很多意想不到的问题，不信往后继续看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天跟大家一起聊聊，代码改成多线程调用之后，带来的9大问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.获取不到返回值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你通过直接继承&lt;code&gt;Thread&lt;/code&gt;类，或者实现&lt;code&gt;Runnable&lt;/code&gt;接口的方式去创建&lt;code&gt;线程&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，恭喜你，你将没法获取该线程方法的返回值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用线程的场景有两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要关注线程方法的返回值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是不需要关注线程方法返回值的，但如果我们有些业务需要关注线程方法的返回值该怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询用户信息接口，需要返回用户基本信息、积分信息、成长值信息，而用户、积分和成长值，需要调用不同的接口获取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1QFBCIrAKapkFNx1jEiaRObHA0Im1rz2yYNvRfMdmhGppAqjfgsbvLZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;在Java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，&lt;code&gt;Fork/join&lt;/code&gt;框架也提供了执行任务并返回结果的能力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.数据丢失&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以注册用户接口为例，该接口主要包含：写用户表，分配权限，配置用户导航页，发通知消息等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中：写用户表和分配权限功能，需要在一个事务中同步执行。而剩余的配置用户导航页和发通知消息功能，使用多线程异步执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表面上看起来没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果前面的写用户表和分配权限功能成功了，用户注册接口就直接返回成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果后面异步执行的配置用户导航页，或发通知消息功能失败了，怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT14NOSxPsEFpU4ARFqEhZbMHZZmJECbmkkDZSJ8hx92sA1dicX1c7GveQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;该接口前面明明已经提示用户成功了，但结果后面又有一部分功能在多线程异步执行中失败了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该如何处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，你可以做&lt;code&gt;失败重试&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果重试了一定的次数，还是没有成功，这条请求数据该如何处理呢？如果不做任何处理，该数据是不是就丢掉了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止数据丢失，可以用如下方案：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用mq异步处理。在分配权限之后，发送一条mq消息，到mq服务器，然后在mq的消费者中使用多线程，去配置用户导航页和发通知消息。如果mq消费者中处理失败了，可以自己重试。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用job异步处理。在分配权限之后，往任务表中写一条数据。然后有个job定时扫描该表，然后配置用户导航页和发通知消息。如果job处理某条数据失败了，可以在表中记录一个重试次数，然后不断重试。但该方案有个缺点，就是实时性可能不太高。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.顺序问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用了多线程，就必须接受一个非常现实的问题，即&lt;code&gt;顺序问题&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如之前代码的执行顺序是：a,b,c，改成多线程执行之后，代码的执行顺序可能变成了：a,c,b。（这个跟cpu调度算法有关）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;c&lt;br/&gt;b&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，来自灵魂的一问：如何保证线程的顺序呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即线程启动的顺序是：a,b,c，执行的顺序也是：a,b,c。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1703296703296704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT12moFAiaOLH2D345zeSLOHsyNdW3BU8AYYbRpudZhU3yCqEg6fGJ2EDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 join&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;类的&lt;code&gt;join&lt;/code&gt;方法它会让主线程等待子线程运行结束后，才能继续运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    thread1.start();&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.start();&lt;br/&gt;    thread2.join();&lt;br/&gt;    thread3.start();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 newSingleThreadExecutor&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用JDK自带的&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法，创建一个&lt;code&gt;单线程&lt;/code&gt;的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;    Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    executorService.submit(thread1);&lt;br/&gt;    executorService.submit(thread2);&lt;br/&gt;    executorService.submit(thread3);&lt;br/&gt;&lt;br/&gt;    executorService.shutdown();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;Excutors&lt;/code&gt;类的&lt;code&gt;newSingleThreadExecutor&lt;/code&gt;方法创建的单线程的线程池，使用了&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;作为队列，而此队列按 &lt;code&gt;FIFO&lt;/code&gt;（先进先出）排序元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;添加到队列的顺序是a,b,c，则执行的顺序也是a,b,c。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 CountDownLatch&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        CountDownLatch latch1 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch2 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        CountDownLatch latch3 = &lt;span&gt;new&lt;/span&gt; CountDownLatch(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;        Thread thread1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch1, latch2, &lt;span&gt;&quot;a&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch2, latch3, &lt;span&gt;&quot;b&quot;&lt;/span&gt;));&lt;br/&gt;        Thread thread3 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; TestRunnable(latch3, latch3, &lt;span&gt;&quot;c&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;        thread3.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRunnable&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch1;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; CountDownLatch latch2;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String message;&lt;br/&gt;&lt;br/&gt;    TestRunnable(CountDownLatch latch1, CountDownLatch latch2, String message) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch1 = latch1;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.latch2 = latch2;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.message = message;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            latch1.await();&lt;br/&gt;            System.out.println(message);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        latch2.countDown();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果永远都是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a&lt;br/&gt;b&lt;br/&gt;c&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，使用&lt;code&gt;CompletableFuture&lt;/code&gt;的&lt;code&gt;thenRun&lt;/code&gt;方法，也能多线程的执行顺序，在这里就不一一介绍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.线程安全问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然使用了线程，伴随而来的还&lt;span&gt;会&lt;/span&gt;有线程安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如现在有这样一个需求：用多线程执行查询方法，然后把执行结果添加到一个list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list = Lists.newArrayList();&lt;br/&gt; dataList.stream()&lt;br/&gt;     .map(data -&amp;gt; CompletableFuture&lt;br/&gt;          .supplyAsync(() -&amp;gt; query(list, data), asyncExecutor)&lt;br/&gt;         ));&lt;br/&gt;CompletableFuture.allOf(futureArray).join();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;CompletableFuture&lt;/code&gt;异步多线程执行query方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;query&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; list, UserEntity condition)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   User user = queryByCondition(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.isNull(user)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   list.add(user);&lt;br/&gt;   UserExtend userExtend = queryByOther(condition);&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(userExtend)) {&lt;br/&gt;      user.setExtend(userExtend.getInfo());&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在query方法中，将获取的查询结果添加到list集合中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果list会出现线程安全问题，有时候会少数据，当然也不一定是必现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为&lt;code&gt;ArrayList&lt;/code&gt;是&lt;code&gt;非线程安全&lt;/code&gt;的，没有使用&lt;code&gt;synchronized&lt;/code&gt;等关键字修饰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;集合，代替普通的&lt;code&gt;ArrayList&lt;/code&gt;集合，CopyOnWriteArrayList是一个线程安全的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需一行小小的改动即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; list Lists.newCopyOnWriteArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨的提醒一下，这里创建集合的方式，用了google的collect包。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.ThreadLocal获取数据异常&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道&lt;code&gt;JDK&lt;/code&gt;为了解决线程安全问题，提供了一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal在普通中线程中，的确能够获取正确的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何获取&lt;code&gt;ThreadLocal&lt;/code&gt;对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接使用普通ThreadLocal，显然是获取不到正确数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先试试&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想进一步了解ThreadLocal的工作原理，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247494889&amp;amp;idx=1&amp;amp;sn=db15e438326c8e297eef739ec190971b&amp;amp;chksm=c0e83401f79fbd17143734d5dbb509f020553772e162d5895de8c8039d79a3cff8633bcf4bb8&amp;amp;token=1106409335&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;ThreadLocal夺命11连问&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.OOM问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，使用多线程可以提升代码执行效率，但也不是绝对的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一些耗时的操作，使用多线程，确实可以提升代码执行效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但线程不是创建越多越好，如果线程创建多了，也可能会导致&lt;code&gt;OOM&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Caused by: &lt;br/&gt;java.lang.OutOfMemoryError: unable to create &lt;span&gt;new&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; thread&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;JVM&lt;/code&gt;中创建一个线程，默认需要占用&lt;code&gt;1M&lt;/code&gt;的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果创建了过多的线程，必然会导致内存空间不足，从而出现OOM异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，如果使用线程池的话，特别是使用固定大小线程池，即使用&lt;code&gt;Executors.newFixedThreadPool&lt;/code&gt;方法创建的线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该线程池的&lt;code&gt;核心线程数&lt;/code&gt;和&lt;code&gt;最大线程数&lt;/code&gt;是一样的，是一个固定值，而存放消息的队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该队列的最大容量是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;，也就是说如果使用固定大小线程池，存放了太多的任务，有可能也会导致OOM异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.OutOfMemeryError:Java heap space&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.CPU使用率飙高&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有做过excel数据导入功能，需要将一批excel的数据导入到系统中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每条数据都有些业务逻辑，如果单线程导入所有的数据，导入效率会非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是改成了多线程导入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果excel中有大量的数据，很可能会出现CPU使用率飙高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，如果代码出现死循环，cpu使用率会飚的很多高。因为代码一直在某个线程中循环，没法切换到其他线程，cpu一直被占用着，所以会导致cpu使用率一直高居不下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而多线程导入大量的数据，虽说没有死循环代码，但由于多个线程一直在不停的处理数据，导致占用了cpu很长的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也会出现cpu使用率很高的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;Thread.sleep&lt;/code&gt;休眠一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在线程中处理完一条数据，休眠10毫秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然CPU使用率飙高的原因很多，多线程处理数据和死循环只是其中两种，还有比如：频繁GC、正则匹配、频繁序列化和反序列化等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面我会写一篇介绍CPU使用率飙高的原因的专题文章，感兴趣的小伙伴，可以关注一下我后续的文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.事务问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到&lt;code&gt;事务方法&lt;/code&gt;add中，调用了事务方法doOtherThing，但是&lt;code&gt;事务方法&lt;/code&gt;doOtherThing是在另外一个&lt;code&gt;线程&lt;/code&gt;中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的&lt;code&gt;数据库连接&lt;/code&gt;不一样，从而是两个不同的&lt;code&gt;事务&lt;/code&gt;。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是&lt;code&gt;数据源&lt;/code&gt;，value是&lt;code&gt;数据库连接&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的&lt;code&gt;同一个事务&lt;/code&gt;，其实是指&lt;code&gt;同一个数据库连接&lt;/code&gt;，只有拥有同一个数据库连接才能同时&lt;code&gt;提交&lt;/code&gt;和&lt;code&gt;回滚&lt;/code&gt;。如果在不同的&lt;code&gt;线程&lt;/code&gt;，拿到的&lt;code&gt;数据库连接&lt;/code&gt;肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;所以不要在事务中开启另外的线程，去处理业务逻辑，这样会导致事务失效。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.导致服务挂掉&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用多线程会导致服务挂掉，这不是危言耸听，而是确有其事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在有这样一种业务场景：在mq的消费者中需要调用订单查询接口，查到数据之后，写入业务表中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来是没啥问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;突然有一天，mq生产者跑了一个批量数据处理的job，导致mq服务器上堆积了大量的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，mq消费者的处理速度，远远跟不上mq消息的生产速度，导致的结果是出现了大量的消息堆积，对用户有很大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，mq消费者改成&lt;code&gt;多线程&lt;/code&gt;处理，直接使用了&lt;code&gt;线程池&lt;/code&gt;，并且&lt;code&gt;最大线程数&lt;/code&gt;配置成了20。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样调整之后，消息堆积问题确实得到了解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但带来了另外一个更严重的问题：订单查询接口并发量太大了，有点扛不住压力，导致部分节点的服务直接挂掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5266821345707656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5gWkq5XlVQMkYdPXkCsRcT1uhx7xe5SaRncT0IhIGSDXpWvpqNOrZqKYS533UG8DftiaUuX3v3cbcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;862&quot;/&gt;为了解决问题，不得不临时加服务节点。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在mq的消费者中使用多线程，调用接口时，一定要评估好接口能够承受的最大访问量，防止因为压力过大，而导致服务挂掉的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6091816cb071d7a6acc8584e9ca3c808</guid>
<title>高效能团队的Java研发规范(进阶版)</title>
<link>https://toutiao.io/k/nud1jt6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;markdown-body mt-4&quot;&gt;
        &lt;p&gt;目前大部分团队是使用的阿里巴巴Java开发规范，不过在日常开发中难免遇到覆盖不到的场景，本文在阿里巴巴Java开发规范基础上，补充一些常用的规范，用于提升代码质量及增强代码可读性。&lt;/p&gt;
&lt;h1 id=&quot;%E7%BC%96%E7%A8%8B%E8%A7%84%E7%BA%A6&quot; tabindex=&quot;-1&quot;&gt;编程规约&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;1、基础类型及操作&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;（1）转换&lt;/h3&gt;
&lt;h5 id=&quot;%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;基本类型转换&lt;/h5&gt;
&lt;p&gt;String类型转数字：使用apache common-lang3包中的工具类NumberUtils，优势：可设置默认值，转换出错时返回默认值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;NumberUtils.toInt(&quot;1&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拆箱：包装类转化为基本类型的时候，需要判定null，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;Integer numObject = param.get(0);
int num = numObject != null ? numObject : 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;对象类型转换&lt;/h5&gt;
&lt;p&gt;使用MapStruct工具，转换类后缀Convertor，所有转换操作都在转换类中操作，禁止在业务代码中编写大量set代码。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E5%88%A4%E6%96%AD&quot; tabindex=&quot;-1&quot;&gt;（2）判断&lt;/h3&gt;
&lt;h5 id=&quot;%E6%9E%9A%E4%B8%BE%E5%88%A4%E5%AE%9A&quot; tabindex=&quot;-1&quot;&gt;枚举判定&lt;/h5&gt;
&lt;p&gt;使用枚举判等，而非枚举对应的数字。因为枚举更直观，方便查看代码及调试，数字容易出错。&lt;/p&gt;
&lt;h5 id=&quot;%E5%88%A4%E7%A9%BA&quot; tabindex=&quot;-1&quot;&gt;判空&lt;/h5&gt;
&lt;p&gt;各种对象的判空：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;//对象判空&amp;amp;非空
Objects.isNull()
Objects.nonNull()

//String判空&amp;amp;非空
StringUtils.isEmpty()   //可匹配null和空字符串
StringUtils.isNotEmpty()
StringUtils.isBlank()   //可匹配null、空字符串、多个空白字符
StringUtils.isNotBlank()

//集合判空&amp;amp;非空
CollectionUtils.isEmpty()
CollectionUtils.isNotEmpty()

//Map判空&amp;amp;非空
MapUtils.isEmpty()
MapUtils.isNotEmpty()
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&quot;%E6%96%AD%E8%A8%80&quot; tabindex=&quot;-1&quot;&gt;断言&lt;/h5&gt;
&lt;p&gt;使用Guava里的Preconditions工具类，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;//如果是空则抛异常
Preconditions.checkNotNull()
//通用判断
Preconditions.checkArgument()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2%E3%80%81%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;2、集合处理&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89map%E5%BF%AB%E6%8D%B7%E6%93%8D%E4%BD%9C&quot; tabindex=&quot;-1&quot;&gt;（1）Map快捷操作&lt;/h3&gt;
&lt;p&gt;推荐：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//如果值不存在则计算
map.computeIfAbsent(&quot;key&quot;,k-&amp;gt; execValue(k));
//默认值
map.getOrDefault(&quot;key&quot;, DEFAULT_VALUE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//如果值不存在则计算
String v = map.get(&quot;key&quot;);
if(v == null){
    v = execValue(&quot;key&quot;);
    map.put(&quot;key&quot;, v);
}
//默认值
map.containsKey(&quot;key&quot;) ? map.get(&quot;key&quot;) : DEFAULT_VALUE
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1&quot; tabindex=&quot;-1&quot;&gt;（2）创建对象&lt;/h3&gt;
&lt;p&gt;构造方法或Builder模式，超过3个参数对象创建使用Builder模式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//Java11+:
List.of(1, 2, 3)  
Set.of(1, 2, 3)
Map.of(&quot;a&quot;, 1)

//Java8中不可变集合（需引入Guava）
ImmutableList.of(1,2,3)
ImmutableSet.of(1,2,3)
ImmutableMap.of(&quot;key&quot;,&quot;value&quot;)
//多值情况
ImmutableMap.builder()
    .put(&quot;key&quot;, &quot;value&quot;)
    .put(&quot;key2&quot;, &quot;value2&quot;)
    .build()

//Java8中可变集合（需引入Guava）
Lists.newArrayList(1, 2, 3)
Sets.newHashSet(1, 2, 3)
Maps.newHashMap(&quot;key&quot;, &quot;value&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;new ArrayList&amp;lt;&amp;gt;(){{
   add(1);
   add(2);
}};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;%EF%BC%883%EF%BC%89%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97&quot; tabindex=&quot;-1&quot;&gt;（3）集合嵌套&lt;/h3&gt;
&lt;p&gt;集合里的值如果是基础类型必须加上注释，说明集合里存的是什么，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//返回值: Map(key: 姓名, value: List(商品))
Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; res;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;超过2层集合对象封装必须封装成自定义类：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//推荐
Map&amp;lt;String, List&amp;lt;Node&amp;gt;&amp;gt; res;

@Value
public static class Node {
    /**
    * 备注说明字段
    */
    String name;
    /**
    * 备注说明字段2
    */
    List&amp;lt;Integer&amp;gt; subjectIds;
}

//反例
Map&amp;lt;String, List&amp;lt;Pair&amp;lt;String, List&amp;lt;Integer&amp;gt;&amp;gt;&amp;gt;&amp;gt; res;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E5%BC%82%E5%B8%B8%E5%8F%8A%E6%97%A5%E5%BF%97&quot; tabindex=&quot;-1&quot;&gt;异常及日志&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E5%BC%82%E5%B8%B8&quot; tabindex=&quot;-1&quot;&gt;1、异常&lt;/h2&gt;
&lt;p&gt;关于异常及错误码的思考，请参考笔者的另一篇文章：&lt;a href=&quot;https://lesofn.com/archives/errorcode-design&quot; target=&quot;_blank&quot;&gt;错误码设计思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;异常除了抛异常还有一种场景，即：上层发起多个必要调用，某些可能失败，需要上层自行决定处理策略，推荐使用vavr中的Either类，Either使用建议：通常我们使用左值表示异常，而右值表示正常调用后的返回结果，即: Either&amp;lt;Throwable, Data&amp;gt;&lt;/p&gt;
&lt;h2 id=&quot;2%E3%80%81%E6%97%A5%E5%BF%97&quot; tabindex=&quot;-1&quot;&gt;2、日志&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6&quot; tabindex=&quot;-1&quot;&gt;（1）日志文件&lt;/h3&gt;
&lt;p&gt;根据日志等级一般分为4个日志文件即可：debug.log、info.log、warn.log、error.log；&lt;/p&gt;
&lt;p&gt;如有特殊需求可根据场景单独建文件，比如请求日志：request.log、gc日志：gc.log等。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E6%97%A5%E5%BF%97%E9%83%BD%E8%A6%81%E6%9C%89%E8%BF%BD%E8%B8%AA%E5%AD%97%E6%AE%B5&quot; tabindex=&quot;-1&quot;&gt;（2）所有用户日志都要有追踪字段&lt;/h3&gt;
&lt;p&gt;追踪字段包括：traceId、userId等，推荐使用MDC，常用的日志框架：Log4j、Logback都支持。&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%883%EF%BC%89%E6%97%A5%E5%BF%97%E6%B8%85%E7%90%86%E5%8F%8A%E6%8C%81%E4%B9%85%E5%8C%96&quot; tabindex=&quot;-1&quot;&gt;（3）日志清理及持久化&lt;/h3&gt;
&lt;p&gt;本地日志根据磁盘大小，必须设置日志保存天数，否则有硬盘满风险；&lt;/p&gt;
&lt;p&gt;分布式环境为了方便查询，需要将日志采集到ES中查询；&lt;/p&gt;
&lt;p&gt;重要日志：比如审计日志、B端操作日志需要持久保存，一般是保存到Hive中；&lt;/p&gt;
&lt;h1 id=&quot;%E5%B7%A5%E5%85%B7%E7%AF%87&quot; tabindex=&quot;-1&quot;&gt;工具篇&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81json&quot; tabindex=&quot;-1&quot;&gt;1、JSON&lt;/h2&gt;
&lt;p&gt;推荐：使用Gson或Jackson；&lt;/p&gt;
&lt;p&gt;不推荐：Fastjson。Fastjson爆出的漏洞多。&lt;/p&gt;
&lt;h2 id=&quot;2%E3%80%81%E5%AF%B9%E8%B1%A1%E8%BD%AC%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;2、对象转换&lt;/h2&gt;
&lt;p&gt;推荐：MapStruct，根据注解编译成Java代码，没有反射，速度快；行为可预测，可查看编译后的Java代码查看转换逻辑；&lt;/p&gt;
&lt;p&gt;不推荐：BeanUtils、Dozer等。需要反射，行为不可预测，需要测试；&lt;/p&gt;
&lt;p&gt;不推荐：超过3个字段手动转换；&lt;/p&gt;
&lt;h2 id=&quot;3%E3%80%81%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;3、模板代码&lt;/h2&gt;
&lt;p&gt;推荐：Lombok，减少代码行数，提升开发效率，自动生成Java代码，没有性能损耗；&lt;/p&gt;
&lt;p&gt;不推荐：手动生成大量set、get方法；&lt;/p&gt;
&lt;h2 id=&quot;4%E3%80%81%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C&quot; tabindex=&quot;-1&quot;&gt;4、参数校验&lt;/h2&gt;
&lt;p&gt;推荐：hibernate Validation、spring-boot-starter-validation，可通过注解自动实现参数拦截；&lt;/p&gt;
&lt;p&gt;不推荐：每个入口（比如Controller）都copy大量重复的校验逻辑；&lt;/p&gt;
&lt;h2 id=&quot;5%E3%80%81%E7%BC%93%E5%AD%98&quot; tabindex=&quot;-1&quot;&gt;5、缓存&lt;/h2&gt;
&lt;p&gt;推荐：Spring Cache，通过注解控制缓存逻辑，适合常用的加缓存场景。&lt;/p&gt;
&lt;h1 id=&quot;%E8%AE%BE%E8%AE%A1%E7%AF%87&quot; tabindex=&quot;-1&quot;&gt;设计篇&lt;/h1&gt;
&lt;h2 id=&quot;1%E3%80%81%E6%AD%A3%E5%90%91%E8%AF%AD%E4%B9%89&quot; tabindex=&quot;-1&quot;&gt;1、正向语义&lt;/h2&gt;
&lt;p&gt;正向语义的好处在于使代码容易理解。 比如：&lt;strong&gt;if(judge()){…}&lt;/strong&gt;，很容易理解，即：判定成功则执行代码块。&lt;/p&gt;
&lt;p&gt;相反，如果是负向语义，思维还要转换一下，一般用于方法前置的参数校验。&lt;/p&gt;
&lt;p&gt;正向语义的应用场景有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法定义：方法名推荐：canPass、checkParam，返回true代表成功。 不推荐：比如isInvalidParam返回true代表失败，增加理解成本；&lt;/li&gt;
&lt;li&gt;Lambda表达式：filter 操作符中返回true是可以通过的元素；&lt;/li&gt;
&lt;li&gt;if和三目运算符：&lt;strong&gt;condition ?  doSomething() : doSomething2()&lt;/strong&gt; , 条件判定后紧跟的是判定成功后执行的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-&quot;&gt;if (!judge()) {
   doSomething2()
} else {
   doSomething()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2%E3%80%81%E9%98%B2%E5%BE%A1%E5%BC%8F%E7%BC%96%E7%A8%8B&quot; tabindex=&quot;-1&quot;&gt;2、防御式编程&lt;/h2&gt;
&lt;h3 id=&quot;%EF%BC%881%EF%BC%89%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C&quot; tabindex=&quot;-1&quot;&gt;（1）外部数据校验&lt;/h3&gt;
&lt;p&gt;外部传过来数据都需要校验，一般分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据流入：用户Http请求、RPC请求、MQ消费者等&lt;/li&gt;
&lt;li&gt;数据依赖：依赖的第三方RPC、数据库等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果是数据流入，一定要首先校验数据合法性再往下执行，推荐hibernate Validation这类工具，可以很方便的做数据校验&lt;/p&gt;
&lt;p&gt;数据是数据依赖，一定要考虑各种网络、限流、背压等场景，做好熔断、降级保障。推荐建立防腐层，将第三方的限界上下文语义转换为当前上下文语义，避免理解上的歧义；&lt;/p&gt;
&lt;h3 id=&quot;%EF%BC%882%EF%BC%89null%E5%A4%84%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;（2）Null处理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于强依赖，没有返回值不行（比如查询数据库）：直接抛异常；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要反馈给上层处理：&lt;/p&gt;
&lt;p&gt;（1）可能返回null的场景：使用Optional；&lt;/p&gt;
&lt;p&gt;（2）上层需要感知信息异常信息：使用vavr中的Either；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可降级：&lt;/p&gt;
&lt;p&gt;（1）返回值是默认值：集合类返回，数字返回0或-1，字符串返回空字符串，其他场景自定义&lt;/p&gt;
&lt;p&gt;集合默认值：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Collections.emptyList()  //空List
Collections.emptySet()   //空Set
Collections.emptyMap()   //空Map
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;%E6%80%BB%E7%BB%93&quot; tabindex=&quot;-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;本文总结了Java开发常用的高级规范，暂时想到这么多，对文章中观点感兴趣，欢迎留言或加微信交流。&lt;/p&gt;
&lt;p&gt;作者博客链接：&lt;a href=&quot;https://lesofn.com/archives/java-coding-standard&quot; target=&quot;_blank&quot;&gt;Java研发规范(进阶版)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者简介：李少锋，美团Java技术专家，专注分享软件研发实践、架构思考。欢迎关注公共号：&lt;strong&gt;Java研发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogpic.chekuspace.com/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B0%8F_1607785087313.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多精彩文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/errorcode-design&quot; target=&quot;_blank&quot;&gt;错误码设计思考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/threadpool-advance&quot; target=&quot;_blank&quot;&gt;Java线程池进阶&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/mvn-to-ddd-architecture&quot; target=&quot;_blank&quot;&gt;从MVC到DDD的架构演进&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/ping-tai-hua-jian-she-si-lu-qian-tan&quot; target=&quot;_blank&quot;&gt;平台化建设思路浅谈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lesofn.com/archives/gou-jian-ke-hui-gun-de-ying-yong-ji-shang-xian-checklist-shi-jian&quot; target=&quot;_blank&quot;&gt;构建可回滚的应用及上线checklist实践&lt;/a&gt;&lt;/p&gt;

    &lt;/article&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44cc1c28679b1dbdb4e00c4bef9585af</guid>
<title>抓到Netty一个Bug，顺带来透彻地聊一下Netty是如何高效接收网络连接的</title>
<link>https://toutiao.io/k/3vfg8nb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本系列Netty源码解析文章基于 &lt;strong&gt;4.1.56.Final&lt;/strong&gt;版本&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个高性能网络通讯框架来说，最最重要也是最核心的工作就是如何高效的接收客户端连接，这就好比我们开了一个饭店，那么迎接客人就是饭店最重要的工作，我们要先把客人迎接进来，不能让客人一看人多就走掉，只要客人进来了，哪怕菜做的慢一点也没关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者就来为大家介绍下netty这块最核心的内容，看看netty是如何高效的接收客户端连接的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图为笔者在一个月黑风高天空显得那么深邃遥远的夜晚，闲来无事，于是捧起Netty关于如何接收连接这部分源码细细品读的时候，意外的发现了一个影响Netty接收连接吞吐的一个Bug。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是笔者就在Github提了一个&lt;span&gt;?&lt;/span&gt;Issue#11708，阐述了下这个Bug产生的原因以及导致的结果并和Netty的作者一起讨论了下修复措施。如上图所示。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先不详细解释这个Issue，也不建议大家现在就打开这个Issue查看，笔者会在本文的介绍中随着源码深入的解读慢慢的为大家一层一层地拨开迷雾。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之所以在文章的开头把这个拎出来，笔者是想让大家带着怀疑，审视，欣赏，崇敬，敬畏的态度来一起品读世界顶级程序员编写的代码。由衷的感谢他们在这一领域做出的贡献。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，问题抛出来后，我们就带着这个疑问来开始本文的内容吧~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaYswibX4udEqDRckSCoqEWgDicedibRoE1SLdqD56zxJqxCj5LfCWPbFNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;文章概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前文回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照老规矩，再开始本文的内容之前，我们先来回顾下前边几篇文章的概要内容帮助大家梳理一个框架全貌出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者这里再次想和读者朋友们强调的是本文可以独立观看，并不依赖前边系列文章的内容，只是大家如果对相关细节部分感兴趣的话，可以在阅读完本文之后在去回看相关文章。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边的系列文章中，笔者为大家介绍了驱动Netty整个框架运转的核心引擎Reactor的创建，启动，运行的全流程。从现在开始Netty的整个核心框架就开始运转起来开始工作了，本文要介绍的主要内容就是Netty在启动之后要做的第一件事件：监听端口地址，高效接收客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;一文中，我们是从整个网络框架的基石IO模型的角度整体阐述了下Netty的IO线程模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而Netty中的Reactor正是IO线程在Netty中的模型定义。Reactor在Netty中是以Group的形式出现的，分为:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup bossGroup&lt;/code&gt;,main reactor group中的reactor主要负责监听客户端连接事件，高效的处理客户端连接。也是本文我们要介绍的重点。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从Reactor线程组也就是我们在启动代码中配置的&lt;code&gt;EventLoopGroup workerGroup&lt;/code&gt;，sub reactor group中的reactor主要负责处理客户端连接上的IO事件，以及异步任务的执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们得出Netty的整个IO模型如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们讨论的重点就是MainReactorGroup的核心工作上图中所示的步骤1，步骤2，步骤3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在从整体上介绍完Netty的IO模型之后，我们又在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中完整的介绍了Netty框架的骨架主从Reactor组的搭建过程，阐述了Reactor是如何被创建出来的，并介绍了它的核心组件如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0638516992790936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaRn9ZX4dJLJdyxSEEXojs5lEmPNiaBfstFOG95KMGibJed4vo3xMhnE6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;971&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;thread&lt;/code&gt;即为Reactor中的IO线程，主要负责监听IO事件，处理IO任务，执行异步任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;selector&lt;/code&gt;则是JDK NIO对操作系统底层IO多路复用技术实现的封装。用于监听IO就绪事件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;taskQueue&lt;/code&gt;用于保存Reactor需要执行的异步任务，这些异步任务可以由用户在业务线程中向Reactor提交，也可以是Netty框架提交的一些自身核心的任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;scheduledTaskQueue&lt;/code&gt;则是保存Reactor中执行的定时任务。代替了原有的时间轮来执行延时任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;tailQueue&lt;/code&gt;保存了在Reactor需要执行的一些尾部收尾任务，在普通任务执行完后 Reactor线程会执行尾部任务，比如对Netty 的运行状态做一些统计数据，例如任务循环的耗时、占用物理内存的大小等等&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在骨架搭建完毕之后，我们随后又在在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;》一文中介绍了&lt;strong&gt;本文的主角服务端NioServerSocketChannel的创建，初始化，绑定端口地址，向main reactor注册监听&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的完整过程&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7161290322580646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaMNnpeQav9HykpMEYenDPdshUtLBMicYHd5F9HwloOsE6FfLVtGW0XRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor启动后的结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor如何处理OP_ACCEPT事件将会是本文的主要内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此Netty框架的main reactor group已经启动完毕，开始准备监听OP_accept事件，当客户端连接上来之后，OP_ACCEPT事件活跃，main reactor开始处理OP_ACCEPT事件接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而netty中的IO事件分为：OP_ACCEPT事件，OP_READ事件，OP_WRITE事件和OP_CONNECT事件，netty对于IO事件的监听和处理统一封装在Reactor模型中，这四个IO事件的处理过程也是我们后续文章中要单独拿出来介绍的，本文我们聚焦OP_ACCEPT事件的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而为了让大家能够对IO事件的处理有一个完整性的认识，笔者写了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;这篇文章，在文章中详细介绍了Reactor线程的整体运行框架。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor线程会在一个死循环中996不停的运转，在循环中会不断的轮询监听Selector上的IO事件，当IO事件活跃后，Reactor从Selector上被唤醒转去执行IO就绪事件的处理，在这个过程中我们引出了上述四种IO事件的处理入口函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取Channel的底层操作类Unsafe&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!k.isValid()) {&lt;br/&gt;            ......如果SelectionKey已经失效则关闭对应的Channel......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//获取IO就绪事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;            &lt;span&gt;//处理Connect事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; ops = k.interestOps();&lt;br/&gt;                &lt;span&gt;//移除对Connect事件的监听，否则Selector会一直通知&lt;/span&gt;&lt;br/&gt;                ops &amp;amp;= ~SelectionKey.OP_CONNECT;&lt;br/&gt;                k.interestOps(ops);&lt;br/&gt;                &lt;span&gt;//触发channelActive事件处理Connect事件&lt;/span&gt;&lt;br/&gt;                unsafe.finishConnect();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//处理Write事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                ch.unsafe().forceFlush();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;             &lt;span&gt;//处理Read事件或者Accept事件&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者将会为大家重点介绍&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数&lt;code&gt;unsafe.read()&lt;/code&gt;的整个源码实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端连接完成三次握手之后，main reactor中的selector产生&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor随即被唤醒，来到了&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理入口函数开始接收客户端连接。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Main Reactor处理OP_ACCEPT事件&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaWfVAUiaQYd2Sebxwzf9VCWLhcbIISY1nBSug2YiaVEPewXhib8D8EUk2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;OP_ACCEPT事件活跃.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;Main Reactor&lt;/code&gt;轮询到&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;就绪时，Main Reactor线程就会从&lt;code&gt;JDK Selector&lt;/code&gt;上的阻塞轮询API&lt;code&gt;selector.select(timeoutMillis)&lt;/code&gt;调用中返回。转而去处理&lt;code&gt;NioServerSocketChannel&lt;/code&gt;上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;processSelectedKey&lt;/span&gt;&lt;span&gt;(SelectionKey k, AbstractNioChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();&lt;br/&gt;        ..............省略.................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; readyOps = k.readyOps();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;               ..............处理OP_CONNECT事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;              ..............处理OP_WRITE事件.................&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != &lt;span&gt;0&lt;/span&gt; || readyOps == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//本文重点处理OP_ACCEPT事件&lt;/span&gt;&lt;br/&gt;                unsafe.read();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException ignored) {&lt;br/&gt;            unsafe.close(unsafe.voidPromise());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理IO就绪事件的入口函数&lt;code&gt;processSelectedKey&lt;/code&gt;中的参数&lt;code&gt;AbstractNioChannel ch&lt;/code&gt;正是Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。因为此时的执行线程为main reactor线程，而main reactor上注册的正是netty服务端NioServerSocketChannel负责监听端口地址，接收客户端连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;ch.unsafe()&lt;/code&gt;获取到的NioUnsafe操作类正是NioServerSocketChannel中对底层JDK NIO ServerSocketChannel的Unsafe底层操作类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;Unsafe接口&lt;/code&gt;是Netty对Channel底层操作行为的封装，比如NioServerSocketChannel的底层Unsafe操作类干的事情就是&lt;code&gt;绑定端口地址&lt;/code&gt;，&lt;code&gt;处理OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到，Netty将&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;处理的入口函数封装在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;里的底层操作类Unsafe的&lt;code&gt;read&lt;/code&gt;方法中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaVwgSgt5AkddHoicEO9er6tOogNfpjVyMysiaZeHCCTBRolMRpG5NDs2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而NioServerSocketChannel中的Unsafe操作类实现类型为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;定义在上图继承结构中的&lt;code&gt;AbstractNioMessageChannel父类中&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法中来看下Netty对&lt;code&gt;OP_ACCPET事件&lt;/code&gt;的具体处理过程：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 接收客户端连接核心流程框架总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是按照老规矩，先从整体上把整个OP_ACCEPT事件的逻辑处理框架提取出来，让大家先总体俯视下流程全貌，然后在针对每个核心点位进行各个击破。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程是在一个&lt;code&gt;do...while{...}&lt;/code&gt;循环read loop中不断的调用JDK NIO &lt;code&gt;serverSocketChannel.accept()&lt;/code&gt;方法来接收完成三次握手的客户端连接&lt;code&gt;NioSocketChannel&lt;/code&gt;的，并将接收到的客户端连接NioSocketChannel临时保存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中，后续会服务端NioServerSocketChannel的pipeline中通过ChannelRead事件来传递，最终会在ServerBootstrapAcceptor这个ChannelHandler中被处理初始化，并将其注册到Sub Reator Group中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的read loop循环会被限定只能读取&lt;strong&gt;16次&lt;/strong&gt;，当main reactor从NioServerSocketChannel中读取客户端连接NioSocketChannel的次数达到&lt;strong&gt;16次&lt;/strong&gt;之后，无论此时是否还有客户端连接都不能在继续读取了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484087&amp;amp;idx=1&amp;amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;amp;token=997171731&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《一文聊透Netty核心引擎Reactor的运转架构》&lt;/a&gt;一文中提到，netty对reactor线程压榨的比较狠，要干的事情很多，除了要监听轮询IO就绪事件，处理IO就绪事件，还需要执行用户和netty框架本省提交的异步任务和定时任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的main reactor线程不能在read loop中无限制的执行下去，因为还需要分配时间去执行异步任务，不能因为无限制的接收客户端连接而耽误了异步任务的执行。所以这里将read loop的循环次数限定为16次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果main reactor线程在read loop中读取客户端连接NioSocketChannel的次数已经满了16次，即使此时还有客户端连接未接收，那么main reactor线程也不会再去接收了，而是转去执行异步任务，当异步任务执行完毕后，还会在回来执行剩余接收连接的任务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是Netty在接收客户端连接时的整体核心逻辑，下面笔者将这部分逻辑的核心源码实现框架提取出来，方便大家根据上述核心逻辑与源码中的处理模块对应起来，还是那句话，这里只需要总体把握核心处理流程，不需要读懂每一行代码，笔者会在文章的后边分模块来各个击破它们。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//必须在Main Reactor线程中执行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;assert&lt;/span&gt; &lt;span&gt;eventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;.&lt;span&gt;inEventLoop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//注意下面的config和pipeline都是服务端ServerSocketChannel中的&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelConfig config = config();&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = pipeline();&lt;br/&gt;            &lt;span&gt;//创建接收数据Buffer分配器（用于分配容量大小合适的byteBuffer用来容纳接收数据）&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//在接收连接的场景中，这里的allocHandle只是用于控制read loop的循环读取创建连接的次数。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;            allocHandle.reset(config);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; closed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;            Throwable exception = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;//已无新的连接可接收则退出read loop&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;span&gt;//判断是否已经读满16次&lt;/span&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//在NioServerSocketChannel对应的pipeline中传播ChannelRead事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;//清除本次accept 创建的客户端SocketChannel集合&lt;/span&gt;&lt;br/&gt;                readBuf.clear();&lt;br/&gt;                allocHandle.readComplete();&lt;br/&gt;                &lt;span&gt;//触发readComplete事件传播&lt;/span&gt;&lt;br/&gt;                pipeline.fireChannelReadComplete();&lt;br/&gt;                ....................省略............&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                ....................省略............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里首先要通过断言&lt;code&gt;assert eventLoop().inEventLoop()&lt;/code&gt;确保处理接收客户端连接的线程必须为Main Reactor 线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而main reactor中主要注册的是服务端NioServerSocketChannel，主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，所以当前main reactor线程是在NioServerSocketChannel中执行接收连接的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里我们通过&lt;code&gt;config()&lt;/code&gt;获取到的是NioServerSocketChannel的属性配置类&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;,它是在Reactor的启动阶段被创建出来的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理这里通过&lt;code&gt;pipeline()&lt;/code&gt;获取到的也是NioServerSocketChannel中的&lt;code&gt;pipeline&lt;/code&gt;。它会在NioServerSocketChannel向main reactor注册成功之后被初始化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLCnvGuX5Vnkyf8vov0T9bwuSrXAQAKQWoCQjzhgBbkfQ52iaDe6282Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;ServerChannelPipeline完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到main reactor线程会被限定只能在read loop中向NioServerSocketChannel读取16次客户端连接，所以在开始read loop之前，我们需要创建一个能够保存记录读取次数的对象，在每次read loop循环之后，可以根据这个对象来判断是否结束read loop。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个对象就是这里的 &lt;code&gt;RecvByteBufAllocator.Handle allocHandle&lt;/code&gt;专门用于统计read loop中接收客户端连接的次数，以及判断是否该结束read loop转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这一切准备就绪之后，main reactor线程就开始在&lt;code&gt;do{....}while(...)&lt;/code&gt;循环中接收客户端连接了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 read loop中通过调用&lt;code&gt;doReadMessages函数&lt;/code&gt;接收完成三次握手的客户端连接，底层会调用到JDK NIO ServerSocketChannel的accept方法，从内核全连接队列中取出客户端连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回值&lt;code&gt;localRead&lt;/code&gt;表示接收到了多少客户端连接，客户端连接通过accept方法只会一个一个的接收，所以这里的&lt;code&gt;localRead&lt;/code&gt;正常情况下都会返回&lt;code&gt;1&lt;/code&gt;，当&lt;code&gt;localRead &amp;lt;= 0&lt;/code&gt;时意味着已经没有新的客户端连接可以接收了，本次main reactor接收客户端的任务到这里就结束了，跳出read loop。开始新的一轮IO事件的监听处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将接收到的客户端连接占时存放到&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//存放连接建立后，创建的客户端SocketChannel&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;统计本次事件循环中接收到的客户端连接个数，最后在read loop末尾通过&lt;code&gt;allocHandle.continueReading&lt;/code&gt;判断是否达到了限定的16次。从而决定main reactor线程是继续接收客户端连接还是转去执行异步任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor线程退出read loop的两个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足以上两个退出条件时，main reactor线程就会退出read loop，由于在read loop中接收到的客户端连接全部暂存在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中,随后开始遍历readBuf，在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    &lt;span&gt;//NioServerSocketChannel对应的pipeline中传播read事件&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor.channelRead&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//初始化客户端SocketChannel，并将其绑定到Sub Reactor线程组中的一个Reactor上&lt;/span&gt;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终pipeline中的ChannelHandler(ServerBootstrapAcceptor)会响应ChannelRead事件，并在相应回调函数中初始化客户端NioSocketChannel，并将其注册到Sub Reactor Group中。此后客户端NioSocketChannel绑定到的sub reactor就开始监听处理客户端连接上的读写事件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netty整个接收客户端的逻辑过程如下图步骤1，2，3所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是笔者提取出来的整体流程框架，下面我们来将其中涉及到的重要核心模块拆开，一个一个详细解读下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. RecvByteBufAllocator简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor在处理对应Channel上的IO数据时，都会采用一个&lt;code&gt;ByteBuffer&lt;/code&gt;来接收Channel上的IO数据。而本小节要介绍的RecvByteBufAllocator正是用来分配ByteBuffer的一个分配器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得这个&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;在哪里被创建的吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之Reactor在Netty中的实现(创建篇)》&lt;/a&gt;一文中，在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建过程中提到，对应Channel的配置类NioServerSocketChannelConfig也会随着NioServerSocketChannel的创建而创建。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建&lt;code&gt;NioServerSocketChannelConfig&lt;/code&gt;的过程中会创建&lt;code&gt;RecvByteBufAllocator&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们看到NioServerSocketChannel中的RecvByteBufAllocator实际类型为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;，顾名思义，这个类型的RecvByteBufAllocator可以根据Channel上每次到来的IO数据大小来自适应动态调整ByteBuffer的容量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于服务端NioServerSocketChannel来说，它上边的IO数据就是客户端的连接，它的长度和类型都是固定的，所以在接收客户端连接的时候并不需要这样的一个ByteBuffer来接收，我们会将接收到的客户端连接存放在&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于客户端NioSocketChannel来说，它上边的IO数据时客户端发送来的网络数据，长度是不定的，所以才会需要这样一个可以根据每次IO数据的大小来自适应动态调整容量的ByteBuffer来接收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么看起来这个RecvByteBufAllocator和本文的主题不是很关联，因为在接收连接的过程中并不会怎么用到它，这个类笔者还会在后面的文章中详细介绍，之所以这里把它拎出来单独介绍是因为它和本文开头提到的Bug有关系，这个Bug就是由这个类引起的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 RecvByteBufAllocator.Handle的获取&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们是通过NioServerSocketChannel中的unsafe底层操作类来获取RecvByteBufAllocator.Handle的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;final&lt;/span&gt; RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractUnsafe&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Unsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;public&lt;/span&gt; RecvByteBufAllocator.&lt;span&gt;Handle &lt;span&gt;recvBufAllocHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (recvHandle == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                recvHandle = config().getRecvByteBufAllocator().newHandle();&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; recvHandle;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到最终会在NioServerSocketChannel的配置类NioServerSocketChannelConfig中获取到&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ChannelConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//用于Channel接收数据用的buffer分配器  类型为AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; RecvByteBufAllocator rcvBufAllocator;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;中会创建自适应动态调整容量的ByteBuffer分配器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AdaptiveRecvByteBufAllocator&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Handle &lt;span&gt;newHandle&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; HandleImpl(minIndex, maxIndex, initial);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HandleImpl&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                  .................省略................&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的&lt;code&gt;newHandle&lt;/code&gt;方法返回的具体类型为&lt;code&gt;MaxMessageHandle&lt;/code&gt;，这个&lt;code&gt;MaxMessageHandle&lt;/code&gt;里边保存了每次从&lt;code&gt;Channel&lt;/code&gt;中读取&lt;code&gt;IO数据&lt;/code&gt;的容量指标，方便下次读取时分配合适大小的&lt;code&gt;buffer&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次在使用&lt;code&gt;allocHandle&lt;/code&gt;前需要调用&lt;code&gt;allocHandle.reset(config);&lt;/code&gt;重置里边的统计指标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MaxMessageHandle&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ExtendedHandle&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; ChannelConfig config;&lt;br/&gt;        &lt;span&gt;//每次事件轮询时，最多读取16次&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxMessagePerRead;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的message数,这里指的是接收连接的数量&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalMessages;&lt;br/&gt;        &lt;span&gt;//本次事件轮询总共读取的字节数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; totalBytesRead;&lt;br/&gt;&lt;br/&gt;       &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;reset&lt;/span&gt;&lt;span&gt;(ChannelConfig config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.config = config;&lt;br/&gt;            &lt;span&gt;//默认每次最多读取16次&lt;/span&gt;&lt;br/&gt;            maxMessagePerRead = maxMessagesPerRead();&lt;br/&gt;            totalMessages = totalBytesRead = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;maxMessagePerRead&lt;/strong&gt;：用于控制每次read loop里最大可以循环读取的次数，默认为16次，可在启动配置类&lt;code&gt;ServerBootstrap&lt;/code&gt;中通过&lt;code&gt;ChannelOption.MAX_MESSAGES_PER_READ&lt;/code&gt;选项设置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;b.group(bossGroup, workerGroup)&lt;br/&gt;  .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;  .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;MAX_MESSAGES_PER_READ&lt;/span&gt;, 自定义次数)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalMessages&lt;/strong&gt;：用于统计read loop中总共接收的连接个数，每次read loop循环后会调用&lt;code&gt;allocHandle.incMessagesRead&lt;/code&gt;增加记录接收到的连接个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;incMessagesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; amt)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            totalMessages += amt;&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;totalBytesRead&lt;/strong&gt;：用于统计在read loop中总共接收到客户端连接上的数据大小，这个字段主要用于sub reactor在接收客户端NioSocketChannel上的网络数据用的，本文我们介绍的是main reactor接收客户端连接，所以这里并不会用到这个字段。这个字段会在sub reactor每次读取完NioSocketChannel上的网络数据时增加记录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lastBytesRead&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; bytes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            lastBytesRead = bytes;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (bytes &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                totalBytesRead += bytes;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MaxMessageHandler中还有一个非常重要的方法就是在每次read loop末尾会调用&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法来判断读取连接次数是否已满16次，来决定main reactor线程是否退出循环。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1879032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiadlS4S4GAOnWGfc4cAFuhpziasUfsEWHxBfh3nKvLNvBAFAWEAP2sJibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红框中圈出来的两个判断条件和本文主题无关，我们这里不需要关注，笔者会在后面的文章详细介绍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalMessages &amp;lt; maxMessagePerRead&lt;/code&gt;：在本文的接收客户端连接场景中，这个条件用于判断main reactor线程在read loop中的读取次数是否超过了16次。如果超过16次就会返回false，main reactor线程退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;：用于判断当客户端NioSocketChannel上的OP_READ事件活跃时，sub reactor线程在read loop中是否读取到了网络数据。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上内容就是RecvByteBufAllocator.Handle在接收客户端连接场景下的作用，大家这里仔细看下这个&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法退出循环的判断条件，再结合整个&lt;code&gt;do{....}while(...)&lt;/code&gt;接收连接循环体，感受下是否哪里有些不对劲？Bug即将出现~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9494949494949495&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia73S7DDn065yic2ibMIJ2CB70d9VuqkWqj9ydiaAk4yDaKbHZ5Z3rlfQfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 啊哈！！Bug ! !&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18333333333333332&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia1WWpXwfWKkgmhBW2wuBConIInzvqErmKhCjykxao8tPMQq4aMzRMWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netty不论是在本文中处理接收客户端连接的场景还是在处理接收客户端连接上的网络数据场景都会在一个&lt;code&gt;do{....}while(...)&lt;/code&gt;循环read loop中不断的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也都会利用在上一小节中介绍的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来记录每次read loop接收到的连接个数和从连接上读取到的网络数据大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从而在read loop的末尾都会通过&lt;code&gt;allocHandle.continueReading()&lt;/code&gt;方法判断是否应该退出read loop循环结束连接的接收流程或者是结束连接上数据的读取流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是用于接收客户端连接的main reactor也好还是用于接收客户端连接上的网络数据的sub reactor也好，它们的运行框架都是一样的，只不过是具体分工不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以netty这里想用统一的&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;来处理以上两种场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;RecvByteBufAllocator.Handle&lt;/code&gt;中的&lt;code&gt;totalBytesRead&lt;/code&gt;字段主要记录sub reactor线程在处理客户端NioSocketChannel中OP_READ事件活跃时，总共在read loop中读取到的网络数据，而这里是main reactor线程在接收客户端连接所以这个字段并不会被设置。totalBytesRead字段的值在本文中永远会是&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以无论同时有多少个客户端并发连接到服务端上，在接收连接的这个read loop中永远只会接受一个连接就会退出循环，因为&lt;code&gt;allocHandle.continueReading()方法&lt;/code&gt;中的判断条件&lt;code&gt;totalBytesRead &amp;gt; 0&lt;/code&gt;永远会返回&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                  &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (localRead &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                            closed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;                            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                        }&lt;br/&gt;                        &lt;span&gt;//统计在当前事件循环中已经读取到得Message数量（创建连接的个数）&lt;/span&gt;&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而netty的本意是在这个read loop循环中尽可能多的去接收客户端的并发连接，同时又不影响main reactor线程执行异步任务。但是由于这个Bug，main reactor在这个循环中只执行一次就结束了。这也一定程度上就影响了netty的吞吐&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们想象下这样的一个场景，当有16个客户端同时并发连接到了服务端，这时NioServerSocketChannel上的&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;活跃，main reactor从Selector上被唤醒，随后执行&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; selectCnt = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; { &lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; strategy;&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());&lt;br/&gt;                    &lt;span&gt;switch&lt;/span&gt; (strategy) {&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.CONTINUE:                  &lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.BUSY_WAIT:&lt;br/&gt;&lt;br/&gt;                          ............省略.........&lt;br/&gt;                    &lt;span&gt;case&lt;/span&gt; SelectStrategy.SELECT:&lt;br/&gt;                            ............监听轮询IO事件.........&lt;br/&gt;                    &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                    ............省略.........&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                ............处理IO就绪事件.........&lt;br/&gt;                ............执行异步任务.........&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是由于这个Bug的存在，main reactor在接收客户端连接的这个read loop中只接收了一个客户端连接就匆匆返回了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后根据下图中这个Reactor的运行结构去执行异步任务，随后绕一大圈又会回到&lt;code&gt;NioEventLoop#run&lt;/code&gt;方法中重新发起一轮OP_ACCEPT事件轮询。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6088709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiavrDh48SPMAM6BFPzvme6iceQT8aibcKY54GLfSOm2F7yCqynlkI9HkOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Reactor线程运行时结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于现在还有15个客户端并发连接没有被接收，所以此时Main Reactor线程并不会在&lt;code&gt;selector.select()&lt;/code&gt;上阻塞，最终绕一圈又会回到&lt;code&gt;NioMessageUnsafe#read&lt;/code&gt;方法的&lt;code&gt;do{.....}while()&lt;/code&gt;循环。在接收一个连接之后又退出循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来我们可以在一次read loop中把这16个并发的客户端连接全部接收完毕的，因为这个Bug，main reactor需要不断的发起OP_ACCEPT事件的轮询，绕了很大一个圈子。&lt;strong&gt;同时也增加了许多不必要的selector.select()系统调用开销&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5056451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaNC5fjKg3IMlryAfebMyBHAWFicnubdnwnXTTHq3yyg2wIr6NPq9oPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;issue讨论.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时大家在看这个&lt;span&gt;?&lt;/span&gt;Issue#11708中的讨论是不是就清晰很多了~~&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Issue#11708：https://github.com/netty/netty/issues/11708&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 Bug的修复&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者在写这篇文章的时候，Netty最新版本是4.1.68.final，这个Bug在4.1.69.final中被修复。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiamkpfIdsVEQRQibNvxZYJJiaTQFHvmuiasd23LH4hjLazv0W1sibvr46nkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于该Bug产生的原因正是因为服务端NioServerSocketChannel（用于监听端口地址和接收客户端连接）和 客户端NioSocketChannel（用于通信）中的Config配置类混用了同一个ByteBuffer分配器&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;而导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在新版本修复中专门为服务端ServerSocketChannel中的Config配置类引入了一个新的ByteBuffer分配器&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;，专门用于服务端ServerSocketChannel接收客户端连接的场景。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29596774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiav3Ks04F9n6vSaQ7UXVue9wPbIFbqyNQagBs7wgxicohYqZswtWNc8uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23548387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaC96ubib29hOP3CibOSE7tonFMkgTib9Hr0yiauIyZV5RuJic5GUQ38Fl9xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;的父类&lt;code&gt;DefaultMaxMessagesRecvByteBufAllocator&lt;/code&gt;中引入了一个新的字段&lt;code&gt;ignoreBytesRead&lt;/code&gt;，用于表示是否忽略网络字节的读取，在创建服务端Channel配置类NioServerSocketChannelConfig的时候，这个字段会被赋值为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2701612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaQJG8bYicxmmJ7mia8kjSvVTUaKeod0A0iaOczCRVgav7GibyTbDCD4AP4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当main reactor线程在read loop循环中接收客户端连接的时候。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        .........省略...........&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;     }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在read loop循环的末尾就会采用从&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;中创建的&lt;code&gt;MaxMessageHandle#continueReading&lt;/code&gt;方法来判断读取连接次数是否超过了16次。由于这里的&lt;code&gt;ignoreBytesRead == true&lt;/code&gt;这回我们就会忽略&lt;code&gt;totalBytesRead == 0&lt;/code&gt;的情况，从而使得接收连接的read loop得以继续地执行下去。在一个read loop中一次性把16个连接全部接收完毕。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1588709677419355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabJdRFibbDhoULfxwyl3njuSGPmiaw9KwAtB7hicggEYHwcUbMZe4BibEDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是对这个Bug产生的原因，以及发现的过程，最后修复的方案一个全面的介绍，因此笔者也出现在了netty 4.1.69.final版本发布公告里的thank-list中。哈哈，真是令人开心的一件事情~~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaEtpEzZGwchbkWicibbjCuOujhoHFk1GrxibqAKnfVkticFu04DQX8XyWkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上对netty接收客户端连接的全流程分析和对这个Bug来龙去脉以及修复方案的介绍，大家现在一定已经理解了整个接收连接的流程框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来笔者就把这个流程中涉及到的一些核心模块在单独拎出来从细节入手，为大家各个击破~~~&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. doReadMessages接收客户端连接&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;            logger.warn(&lt;span&gt;&quot;Failed to create a new channel from an accepted socket.&quot;&lt;/span&gt;, t);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ch.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t2) {&lt;br/&gt;                logger.warn(&lt;span&gt;&quot;Failed to close a socket.&quot;&lt;/span&gt;, t2);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;javaChannel()&lt;/code&gt;获取封装在Netty服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;中的&lt;code&gt;JDK 原生 ServerSocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; ServerSocketChannel &lt;span&gt;javaChannel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (ServerSocketChannel) &lt;span&gt;super&lt;/span&gt;.javaChannel();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;获取&lt;code&gt;JDK NIO 原生&lt;/code&gt;客户端连接&lt;code&gt;SocketChannel&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SocketChannel &lt;span&gt;accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ServerSocketChannel serverSocketChannel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; AccessController.doPrivileged(&lt;span&gt;new&lt;/span&gt; PrivilegedExceptionAction&amp;lt;SocketChannel&amp;gt;() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; SocketChannel &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; serverSocketChannel.accept();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (PrivilegedActionException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; (IOException) e.getCause();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步就是我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483737&amp;amp;idx=1&amp;amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《聊聊Netty那些事儿之从内核角度看IO模型》&lt;/a&gt;介绍到的调用&lt;code&gt;监听Socket&lt;/code&gt;的&lt;code&gt;accept方法&lt;/code&gt;，内核会基于&lt;code&gt;监听Socket&lt;/code&gt;创建出来一个新的&lt;code&gt;Socket&lt;/code&gt;专门用于与客户端之间的网络通信这个我们称之为&lt;code&gt;客户端连接Socket&lt;/code&gt;。这里的&lt;code&gt;ServerSocketChannel&lt;/code&gt;就类似于&lt;code&gt;监听Socket&lt;/code&gt;。&lt;code&gt;SocketChannel&lt;/code&gt;就类似于&lt;code&gt;客户端连接Socket&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于我们在创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候，会将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;ServerSocketChannel&lt;/code&gt;设置为&lt;code&gt;非阻塞&lt;/code&gt;，所以这里当&lt;code&gt;ServerSocketChannel&lt;/code&gt;上有客户端连接时就会直接创建&lt;code&gt;SocketChannel&lt;/code&gt;，如果此时并没有客户端连接时&lt;code&gt;accept调用&lt;/code&gt;就会立刻返回&lt;code&gt;null&lt;/code&gt;并不会阻塞。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;          ..........省略.............&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 创建客户端NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;doReadMessages&lt;/span&gt;&lt;span&gt;(List&amp;lt;Object&amp;gt; buf)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = SocketUtils.accept(javaChannel());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (ch != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                buf.add(&lt;span&gt;new&lt;/span&gt; NioSocketChannel(&lt;span&gt;this&lt;/span&gt;, ch));&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;          .........省略.......&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会根据&lt;code&gt;ServerSocketChannel&lt;/code&gt;的&lt;code&gt;accept&lt;/code&gt;方法获取到&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;（用于底层真正与客户端通信的Channel），来创建Netty中的&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;SocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioSocketChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SocketChannel socket)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, socket);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, socket.socket());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的过程其实和之前讲的创建服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;大体流程是一样的，我们这里只对客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;和服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;在创建过程中的不同之处做一个对比。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体细节部分大家可以在回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中关于&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的创建的详细细节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 对比NioSocketChannel与NioServerSocketChannel的不同&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1：Channel的层次不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们介绍Reactor的创建文章中，我们提到Netty中的&lt;code&gt;Channel&lt;/code&gt;是具有层次的。由于客户端NioSocketChannel是在main reactor接收连接时在服务端NioServerSocketChannel中被创建的，所以在创建客户端NioSocketChannel的时候会通过构造函数指定了parent属性为&lt;code&gt;NioServerSocketChanel&lt;/code&gt;。并将&lt;code&gt;JDK NIO 原生&lt;/code&gt;的&lt;code&gt;SocketChannel&lt;/code&gt;封装进Netty的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在Reactor启动过程中创建&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候&lt;code&gt;parent属性&lt;/code&gt;指定是&lt;code&gt;null&lt;/code&gt;。因为它就是顶层的&lt;code&gt;Channel&lt;/code&gt;，负责创建客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2：向Reactor注册的IO事件不同&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor注册的是&lt;code&gt;SelectionKey.OP_READ事件&lt;/code&gt;，而服务端NioServerSocketChannel向Main Reactor注册的是&lt;code&gt;SelectionKey.OP_ACCEPT事件&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioByteChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent, ch, SelectionKey.OP_READ);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt;&lt;span&gt;(ServerSocketChannel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//父类AbstractNioChannel中保存JDK NIO原生ServerSocketChannel以及要监听的事件OP_ACCEPT&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;, channel, SelectionKey.OP_ACCEPT);&lt;br/&gt;        &lt;span&gt;//DefaultChannelConfig中设置用于Channel接收数据用的buffer-&amp;gt;AdaptiveRecvByteBufAllocator&lt;/span&gt;&lt;br/&gt;        config = &lt;span&gt;new&lt;/span&gt; NioServerSocketChannelConfig(&lt;span&gt;this&lt;/span&gt;, javaChannel().socket());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3: 功能属性不同造成继承结构的不同&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6935483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaibVzdgIkicOvZJL9oNdgkTWsJTKwwKr71mN9DiaY16VzdQ1dmHtguRxOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaJhrEYzibyhX4xH6g502Qobny1kJrRNvgo7j0duvaw9HC2f5eXQPqoTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioServerSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioByteChannel&lt;/code&gt;，而服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;继承的是&lt;code&gt;AbstractNioMessageChannel&lt;/code&gt;。它们继承的这两个抽象类一个前缀是&lt;code&gt;Byte&lt;/code&gt;，一个前缀是&lt;code&gt;Message&lt;/code&gt;有什么区别吗？？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;主要处理的是服务端与客户端的通信，这里涉及到接收客户端发送来的数据，而&lt;code&gt;Sub Reactor线程&lt;/code&gt;从&lt;code&gt;NioSocketChannel&lt;/code&gt;中读取的正是网络通信数据单位为&lt;code&gt;Byte&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端&lt;code&gt;NioServerSocketChannel&lt;/code&gt;主要负责处理&lt;code&gt;OP_ACCEPT事件&lt;/code&gt;，创建用于通信的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。这时候客户端与服务端还没开始通信，所以&lt;code&gt;Main Reactor线程&lt;/code&gt;从&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的读取对象为&lt;code&gt;Message&lt;/code&gt;。这里的&lt;code&gt;Message&lt;/code&gt;指的就是底层的&lt;code&gt;SocketChannel&lt;/code&gt;客户端连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;创建过程中的不同之处，后面的过程就一样了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在AbstractNioChannel 类中封装JDK NIO 原生的&lt;code&gt;SocketChannel&lt;/code&gt;，并将其底层的IO模型设置为&lt;code&gt;非阻塞&lt;/code&gt;，保存需要监听的IO事件&lt;code&gt;OP_READ&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt;&lt;span&gt;(Channel parent, SelectableChannel ch, &lt;span&gt;int&lt;/span&gt; readInterestOp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(parent);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.ch = ch;&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.readInterestOp = readInterestOp;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//设置Channel为非阻塞 配合IO多路复用模型&lt;/span&gt;&lt;br/&gt;            ch.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为客户端NioSocketChannel创建全局唯一的&lt;code&gt;channelId&lt;/code&gt;，创建客户端NioSocketChannel的底层操作类&lt;code&gt;NioByteUnsafe&lt;/code&gt;，创建pipeline。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt;&lt;span&gt;(Channel parent)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.parent = parent;&lt;br/&gt;        &lt;span&gt;//channel全局唯一ID machineId+processId+sequence+timestamp+random&lt;/span&gt;&lt;br/&gt;        id = newId();&lt;br/&gt;        &lt;span&gt;//unsafe用于底层socket的读写操作&lt;/span&gt;&lt;br/&gt;        unsafe = newUnsafe();&lt;br/&gt;        &lt;span&gt;//为channel分配独立的pipeline用于IO事件编排&lt;/span&gt;&lt;br/&gt;        pipeline = newChannelPipeline();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在NioSocketChannelConfig的创建过程中，将NioSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;AdaptiveRecvByteBufAllocator&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DefaultChannelConfig&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;(channel, &lt;span&gt;new&lt;/span&gt; AdaptiveRecvByteBufAllocator());&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在Bug修复后的版本中服务端NioServerSocketChannel的RecvByteBufAllocator类型设置为&lt;code&gt;ServerChannelRecvByteBufAllocator&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终我们得到的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaW2k5wARibzQC47D0ricxafnVibibz8usyYO8DIiagJObUwYIu1vS6fGW08A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;NioSocketChannel.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. ChannelRead事件的响应&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5717741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaDjWPOibC4yyvicZOQROz0VprRQdxN0scINPgOrCAVGxL1bUoV6ia4YJXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;接收客户端连接.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前边介绍接收连接的整体核心流程框架的时候，我们提到main reactor线程是在一个&lt;code&gt;do{.....}while(...)&lt;/code&gt;循环read loop中不断的调用&lt;code&gt;ServerSocketChannel#accept&lt;/code&gt;方法来接收客户端的连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足退出read loop循环的条件有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在限定的16次读取中，已经没有新的客户端连接要接收了。退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从NioServerSocketChannel中读取客户端连接的次数达到了16次，无论此时是否还有客户端连接都需要退出循环。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main reactor就会退出read loop循环，此时接收到的客户端连接NioSocketChannel暂存与&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioMessageUnsafe&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioUnsafe&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;Object&amp;gt; readBuf = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Object&amp;gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        &lt;span&gt;//底层调用NioServerSocketChannel-&amp;gt;doReadMessages 创建客户端SocketChannel&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; localRead = doReadMessages(readBuf);&lt;br/&gt;                        ........省略.........&lt;br/&gt;                        allocHandle.incMessagesRead(localRead);&lt;br/&gt;                    } &lt;span&gt;while&lt;/span&gt; (allocHandle.continueReading());&lt;br/&gt;&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    exception = t;&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; size = readBuf.size();&lt;br/&gt;                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i ++) {&lt;br/&gt;                    readPending = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                    pipeline.fireChannelRead(readBuf.get(i));&lt;br/&gt;                }&lt;br/&gt;                &lt;br/&gt;                  ........省略.........&lt;br/&gt;            } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;                  ........省略.........&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后main reactor线程会遍历&lt;code&gt;List&amp;lt;Object&amp;gt; readBuf&lt;/code&gt;集合中的NioSocketChannel，并在NioServerSocketChannel的pipeline中传播ChannelRead事件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaLcRXsic4tugeyCbo2ZjSLhNtU09WGLEicbhFmqJBY7BDibKss8j2BTKibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRead事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终&lt;code&gt;ChannelRead事件&lt;/code&gt;会传播到&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;中，这里正是Netty处理客户端连接的核心逻辑所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;主要的作用就是初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;，并将客户端NioSocketChannel注册到&lt;code&gt;Sub Reactor Group&lt;/code&gt;中，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ServerBootstrapAcceptor 中会初始化客户端NioSocketChannel的这些属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：从Reactor组&lt;code&gt;EventLoopGroup childGroup&lt;/code&gt;，用于初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;用到的&lt;code&gt;ChannelHandler childHandler&lt;/code&gt;，以及&lt;code&gt;NioSocketChannel&lt;/code&gt;中的一些&lt;code&gt;childOptions&lt;/code&gt;和&lt;code&gt;childAttrs&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrapAcceptor&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; EventLoopGroup childGroup;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ChannelHandler childHandler;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] childOptions;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] childAttrs;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Channel child = (Channel) msg;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//向客户端NioSocketChannel的pipeline中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//添加在启动配置类ServerBootstrap中配置的ChannelHandler&lt;/span&gt;&lt;br/&gt;            child.pipeline().addLast(childHandler);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//利用配置的属性初始化客户端NioSocketChannel&lt;/span&gt;&lt;br/&gt;            setChannelOptions(child, childOptions, logger);&lt;br/&gt;            setAttributes(child, childAttrs);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;/**&lt;br/&gt;                 * 1：在Sub Reactor线程组中选择一个Reactor绑定&lt;br/&gt;                 * 2：将客户端SocketChannel注册到绑定的Reactor上&lt;br/&gt;                 * 3：SocketChannel注册到sub reactor中的selector上，并监听OP_READ事件&lt;br/&gt;                 * */&lt;/span&gt;&lt;br/&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                forceClose(child, t);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是在这里，netty会将我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;的启动示例程序中在ServerBootstrap中配置的客户端NioSocketChannel的所有属性（child前缀配置）初始化到NioSocketChannel中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PORT = Integer.parseInt(System.getProperty(&lt;span&gt;&quot;port&quot;&lt;/span&gt;, &lt;span&gt;&quot;8007&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Configure the server.&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//创建主从Reactor线程组&lt;/span&gt;&lt;br/&gt;        EventLoopGroup bossGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        EventLoopGroup workerGroup = &lt;span&gt;new&lt;/span&gt; NioEventLoopGroup();&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; EchoServerHandler serverHandler = &lt;span&gt;new&lt;/span&gt; EchoServerHandler();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ServerBootstrap b = &lt;span&gt;new&lt;/span&gt; ServerBootstrap();&lt;br/&gt;            b.group(bossGroup, workerGroup)&lt;span&gt;//配置主从Reactor&lt;/span&gt;&lt;br/&gt;             .channel(NioServerSocketChannel&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)//配置主&lt;span&gt;Reactor&lt;/span&gt;中的&lt;span&gt;channel&lt;/span&gt;类型&lt;br/&gt;             .&lt;span&gt;option&lt;/span&gt;(&lt;span&gt;ChannelOption&lt;/span&gt;.&lt;span&gt;SO_BACKLOG&lt;/span&gt;, 100)//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;channel&lt;/span&gt;的&lt;span&gt;option&lt;/span&gt;选项&lt;br/&gt;             .&lt;span&gt;handler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;LoggingHandler&lt;/span&gt;(&lt;span&gt;LogLevel&lt;/span&gt;.&lt;span&gt;INFO&lt;/span&gt;))//设置主&lt;span&gt;Reactor&lt;/span&gt;中&lt;span&gt;Channel&lt;/span&gt;-&amp;gt;&lt;span&gt;pipline&lt;/span&gt;-&amp;gt;&lt;span&gt;handler&lt;/span&gt;&lt;br/&gt;             .&lt;span&gt;childHandler&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;SocketChannel&lt;/span&gt;&amp;gt;() &lt;/span&gt;{&lt;span&gt;//设置从Reactor中注册channel的pipeline&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                 &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(SocketChannel ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                     ChannelPipeline p = ch.pipeline();&lt;br/&gt;                     &lt;span&gt;//p.addLast(new LoggingHandler(LogLevel.INFO));&lt;/span&gt;&lt;br/&gt;                     p.addLast(serverHandler);&lt;br/&gt;                 }&lt;br/&gt;             });&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// Start the server. 绑定端口启动服务，开始监听accept事件&lt;/span&gt;&lt;br/&gt;            ChannelFuture f = b.bind(PORT).sync();&lt;br/&gt;            &lt;span&gt;// Wait until the server socket is closed.&lt;/span&gt;&lt;br/&gt;            f.channel().closeFuture().sync();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// Shut down all event loops to terminate all threads.&lt;/span&gt;&lt;br/&gt;            bossGroup.shutdownGracefully();&lt;br/&gt;            workerGroup.shutdownGracefully();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上示例代码中通过ServerBootstrap配置的NioSocketChannel相关属性，会在Netty启动并开始初始化&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的时候将&lt;code&gt;ServerBootstrapAcceptor&lt;/code&gt;的创建初始化工作封装成&lt;code&gt;异步任务&lt;/code&gt;，然后在&lt;code&gt;NioServerSocketChannel&lt;/code&gt;注册到&lt;code&gt;Main Reactor&lt;/code&gt;中成功后执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServerBootstrap&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractBootstrap&lt;/span&gt;&amp;lt;&lt;span&gt;ServerBootstrap&lt;/span&gt;, &lt;span&gt;ServerChannel&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ................省略................&lt;br/&gt;&lt;br/&gt;        p.addLast(&lt;span&gt;new&lt;/span&gt; ChannelInitializer&amp;lt;Channel&amp;gt;() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Channel ch)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;final&lt;/span&gt; ChannelPipeline pipeline = ch.pipeline();&lt;br/&gt;                ................省略................&lt;br/&gt;                ch.eventLoop().execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        pipeline.addLast(&lt;span&gt;new&lt;/span&gt; ServerBootstrapAcceptor(&lt;br/&gt;                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在经过&lt;code&gt;ServerBootstrapAccptor#chanelRead回调&lt;/code&gt;的处理之后，此时客户端NioSocketChannel中pipeline的结构为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会将初始化好的客户端NioSocketChannel向Sub Reactor Group中注册，并监听&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图中的步骤3所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.567741935483871&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNialDtXCOD5vvVGh56FT2yKauwTch6oYbrn1icPuYKaqY8nPibicWv66sQfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;netty中的reactor.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 向SubReactorGroup中注册NioSocketChannel&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;                childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端NioSocketChannel向Sub Reactor Group注册的流程完全和服务端NioServerSocketChannel向Main Reactor Group注册流程一样。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于服务端NioServerSocketChannel的注册流程，笔者已经在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;一文中做出了详细的介绍，对相关细节感兴趣的同学可以在回看下。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里笔者在带大家简要回顾下整个注册过程并着重区别对比客户端NioSocetChannel与服务端NioServerSocketChannel注册过程中不同的地方。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 从Sub Reactor Group中选取一个Sub Reactor进行绑定&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MultithreadEventLoopGroup&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;MultithreadEventExecutorGroup&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoopGroup&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; next().register(channel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; EventExecutor &lt;span&gt;next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; chooser.next();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 向绑定的Sub Reactor上注册NioSocketChannel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;SingleThreadEventLoop&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;SingleThreadEventExecutor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;EventLoop&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(Channel channel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//注册channel到绑定的Reactor上&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; register(&lt;span&gt;new&lt;/span&gt; DefaultChannelPromise(channel, &lt;span&gt;this&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ObjectUtil.checkNotNull(promise, &lt;span&gt;&quot;promise&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//unsafe负责channel底层的各种操作&lt;/span&gt;&lt;br/&gt;        promise.channel().unsafe().register(&lt;span&gt;this&lt;/span&gt;, promise);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; promise;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当时我们在介绍&lt;code&gt;NioServerSocketChannel&lt;/code&gt;的注册过程时，这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioServerSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioMessageUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;此时这里的&lt;code&gt;promise.channel()&lt;/code&gt;为&lt;code&gt;NioSocketChannel&lt;/code&gt;。底层的unsafe操作类为&lt;code&gt;NioByteUnsafe&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(EventLoop eventLoop, &lt;span&gt;final&lt;/span&gt; ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            ..............省略....................&lt;br/&gt;            &lt;span&gt;//此时这里的eventLoop为Sub Reactor&lt;/span&gt;&lt;br/&gt;            AbstractChannel.&lt;span&gt;this&lt;/span&gt;.eventLoop = eventLoop;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;/**&lt;br/&gt;             * 执行channel注册的操作必须是Reactor线程来完成&lt;br/&gt;             *&lt;br/&gt;             * 1: 如果当前执行线程是Reactor线程，则直接执行register0进行注册&lt;br/&gt;             * 2：如果当前执行线程是外部线程，则需要将register0注册操作 封装程异步Task 由Reactor线程执行&lt;br/&gt;             * */&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (eventLoop.inEventLoop()) {&lt;br/&gt;                register0(promise);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    eventLoop.execute(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                            register0(promise);&lt;br/&gt;                        }&lt;br/&gt;                    });&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                    ..............省略....................&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意此时传递进来的EventLoop eventLoop为Sub Reactor&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但此时的执行线程为&lt;code&gt;Main Reactor线程&lt;/code&gt;，并不是Sub Reactor线程（此时还未启动）&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这里的&lt;code&gt;eventLoop.inEventLoop()&lt;/code&gt;返回的是&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2532258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiazIA5weroZkxOLyqsUBrN8Q1XP3NM5vBsFVdZXIGz1Il7FPprdZ4TNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;else分支&lt;/code&gt;中向绑定的Sub Reactor提交注册&lt;code&gt;NioSocketChannel&lt;/code&gt;的任务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当注册任务提交后，此时绑定的&lt;code&gt;Sub Reactor线程&lt;/code&gt;启动。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.3 register0&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们又来到了Channel注册的老地方&lt;code&gt;register0方法&lt;/code&gt;。在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;中我们花了大量的篇幅介绍了这个方法。这里我们只对比&lt;code&gt;NioSocketChannel&lt;/code&gt;与&lt;code&gt;NioServerSocketChannel&lt;/code&gt;不同的地方。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register0&lt;/span&gt;&lt;span&gt;(ChannelPromise promise)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ................省略..................&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; firstRegistration = neverRegistered;&lt;br/&gt;                &lt;span&gt;//执行真正的注册操作&lt;/span&gt;&lt;br/&gt;                doRegister();&lt;br/&gt;                &lt;span&gt;//修改注册状态&lt;/span&gt;&lt;br/&gt;                neverRegistered = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                registered = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;                pipeline.invokeHandlerAddedIfNeeded();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        beginRead();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;                 ................省略..................&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;doRegister()方法&lt;/code&gt;将NioSocketChannel注册到Sub Reactor中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doRegister&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; selected = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (CancelledKeyException e) {&lt;br/&gt;                ...............省略...............&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是Netty客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;与JDK NIO 原生 SocketChannel关联的地方。此时注册的&lt;code&gt;IO事件&lt;/code&gt;依然是&lt;code&gt;0&lt;/code&gt;。目的也是只是为了获取NioSocketChannel在Selector中的&lt;code&gt;SelectionKey&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时通过&lt;code&gt;SelectableChannel#register&lt;/code&gt;方法将Netty自定义的NioSocketChannel（这里的this指针）附着在SelectionKey的attechment属性上，完成Netty自定义Channel与JDK NIO Channel的关系绑定。这样在每次对Selector进行IO就绪事件轮询时，Netty 都可以从 JDK NIO Selector返回的SelectionKey中获取到自定义的Channel对象（这里指的就是NioSocketChannel）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42258064516129035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaBHZIoOsiaAmdqQxwtXvIIgHxoYrpp2AeUMs5qEla9BoHU4wkg4Sgjqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;channel与SelectionKey对应关系.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后调用&lt;code&gt;pipeline.invokeHandlerAddedIfNeeded()&lt;/code&gt;回调客户端NioSocketChannel上pipeline中的所有ChannelHandler的&lt;code&gt;handlerAdded方法&lt;/code&gt;，此时&lt;code&gt;pipeline&lt;/code&gt;的结构中只有一个&lt;code&gt;ChannelInitializer&lt;/code&gt;。最终会在&lt;code&gt;ChannelInitializer#handlerAdded&lt;/code&gt;回调方法中初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNia6cNkLIW571QH74LhkCfFpibJSm1cwDQTQBcxClKehQVGRR3ibdP9Ea5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline初始结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChannelInitializer&lt;/span&gt;&amp;lt;&lt;span&gt;C&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Channel&lt;/span&gt;&amp;gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlerAdded&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (ctx.channel().isRegistered()) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (initChannel(ctx)) {&lt;br/&gt;                &lt;span&gt;//初始化工作完成后，需要将自身从pipeline中移除&lt;/span&gt;&lt;br/&gt;                removeState(ctx);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;initChannel&lt;/span&gt;&lt;span&gt;(C ch)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于对Channel中pipeline的详细初始化过程，对细节部分感兴趣的同学可以回看下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247484005&amp;amp;idx=1&amp;amp;sn=52f51269902a58f40d33208421109bc3&amp;amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《详细图解Netty Reactor启动全流程》&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时客户端NioSocketChannel中的pipeline中的结构就变为了我们自定义的样子，在示例代码中我们自定义的&lt;code&gt;ChannelHandler&lt;/code&gt;为&lt;code&gt;EchoServerHandler&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32661290322580644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaTdUsySmibYW5g2lI0f8hN484CkfWrAjns8jib4vPJfrta5gpuxH5lyvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;客户端channel pipeline结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Sharable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EchoServerHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelRead&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Object msg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ctx.write(msg);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;channelReadComplete&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        ctx.flush();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exceptionCaught&lt;/span&gt;&lt;span&gt;(ChannelHandlerContext ctx, Throwable cause)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// Close the connection when an exception is raised.&lt;/span&gt;&lt;br/&gt;        cause.printStackTrace();&lt;br/&gt;        ctx.close();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端NioSocketChannel中的pipeline初始化完毕后，netty就开始调用&lt;code&gt;safeSetSuccess(promise)方法&lt;/code&gt;回调&lt;code&gt;regFuture&lt;/code&gt;中注册的&lt;code&gt;ChannelFutureListener&lt;/code&gt;，通知客户端NioSocketChannel已经成功注册到Sub Reactor上了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;               childGroup.register(child).addListener(&lt;span&gt;new&lt;/span&gt; ChannelFutureListener() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;operationComplete&lt;/span&gt;&lt;span&gt;(ChannelFuture future)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt; (!future.isSuccess()) {&lt;br/&gt;                            forceClose(child, future.cause());&lt;br/&gt;                        }&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在服务端NioServerSocketChannel注册的时候我们会在listener中向Main Reactor提交&lt;code&gt;bind绑定端口地址任务&lt;/code&gt;。但是在&lt;code&gt;NioSocketChannel&lt;/code&gt;注册的时候，只会在&lt;code&gt;listener&lt;/code&gt;中处理一下注册失败的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当Sub Reactor线程通知ChannelFutureListener注册成功之后，随后就会调用&lt;code&gt;pipeline.fireChannelRegistered()&lt;/code&gt;在客户端NioSocketChannel的pipeline中传播&lt;code&gt;ChannelRegistered事件&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaAGdSxbwsoLP3mhiaKahLtKrMRdE9IXvMOyxgInz5UweSSrv8H9HwNKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelRegister事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者重点要强调下&lt;/strong&gt;，在之前介绍NioServerSocketChannel注册的时候，我们提到因为此时NioServerSocketChannel并未绑定端口地址，所以这时的NioServerSocketChannel并未激活，这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;false&lt;/code&gt;。&lt;code&gt;register0方法&lt;/code&gt;直接返回。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;服务端NioServerSocketChannel判断是否激活的标准为端口是否绑定成功。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NioServerSocketChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractNioMessageChannel&lt;/span&gt;&lt;br/&gt;                             &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;io&lt;/span&gt;.&lt;span&gt;netty&lt;/span&gt;.&lt;span&gt;channel&lt;/span&gt;.&lt;span&gt;socket&lt;/span&gt;.&lt;span&gt;ServerSocketChannel&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; isOpen() &amp;amp;&amp;amp; javaChannel().socket().isBound();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;判断是否激活的标准为是否处于&lt;code&gt;Connected状态&lt;/code&gt;。那么显然这里肯定是处于&lt;code&gt;connected状态&lt;/code&gt;的。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isActive&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        SocketChannel ch = javaChannel();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ch.isOpen() &amp;amp;&amp;amp; ch.isConnected();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NioSocketChannel&lt;/code&gt;已经处于&lt;code&gt;connected状态&lt;/code&gt;，这里并不需要绑定端口，所以这里的&lt;code&gt;isActive()&lt;/code&gt;返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;           &lt;span&gt;if&lt;/span&gt; (isActive()) {&lt;br/&gt;                    &lt;span&gt;/**&lt;br/&gt;                     * 客户端SocketChannel注册成功后会走这里，在channelActive事件回调中注册OP_READ事件&lt;br/&gt;                     * */&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (firstRegistration) {&lt;br/&gt;                        &lt;span&gt;//触发channelActive事件&lt;/span&gt;&lt;br/&gt;                        pipeline.fireChannelActive();&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (config().isAutoRead()) {&lt;br/&gt;                        .......省略..........&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用&lt;code&gt;pipeline.fireChannelActive()&lt;/code&gt;在NioSocketChannel中的pipeline传播&lt;code&gt;ChannelActive事件&lt;/code&gt;，最终在&lt;code&gt;pipeline&lt;/code&gt;的头结点&lt;code&gt;HeadContext&lt;/code&gt;中响应并注册&lt;code&gt;OP_READ事件&lt;/code&gt;到&lt;code&gt;Sub Reactor&lt;/code&gt;中的&lt;code&gt;Selector&lt;/code&gt;上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiaaDWO56Rib0H2YViadZkbq3WErIBg6duwk22WMHcnt41ZWlS9WTtaYbcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;传播ChannelActive事件.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AbstractNioChannel&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;AbstractChannel&lt;/span&gt; &lt;/span&gt;{ {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doBeginRead&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        ..............省略................&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; interestOps = selectionKey.interestOps();&lt;br/&gt;        &lt;span&gt;/**&lt;br/&gt;         * 1：ServerSocketChannel 初始化时 readInterestOp设置的是OP_ACCEPT事件&lt;br/&gt;         * 2：SocketChannel 初始化时 readInterestOp设置的是OP_READ事件&lt;br/&gt;         * */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((interestOps &amp;amp; readInterestOp) == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//注册监听OP_ACCEPT或者OP_READ事件&lt;/span&gt;&lt;br/&gt;            selectionKey.interestOps(interestOps | readInterestOp);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里的&lt;code&gt;readInterestOp&lt;/code&gt;为客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;在初始化时设置的&lt;code&gt;OP_READ事件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，Netty中的&lt;code&gt;Main Reactor&lt;/code&gt;接收连接的整个流程，我们就介绍完了，此时Netty中主从Reactor组的结构就变为：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5040322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUZnjTia9x6OdAvgr1icM1ZsNiabSEUJ3uzXNIS7OGAbpeQ3ib7ZoCM6RlzjglPlzJ4Pud3L0oWSzN0iaAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;主从Reactor组完整结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们介绍了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;处理客户端连接事件的整个过程。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接收连接的整个处理框架。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;影响Netty接收连接吞吐的Bug产生的原因，以及修复的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;创建并初始化客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化&lt;code&gt;NioSocketChannel&lt;/code&gt;中的&lt;code&gt;pipeline&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;向&lt;code&gt;Sub Reactor&lt;/code&gt;注册的过程&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中我们也对比了&lt;code&gt;NioServerSocketChannel&lt;/code&gt;与&lt;code&gt;NioSocketChannel&lt;/code&gt;在创建初始化以及后面向&lt;code&gt;Reactor&lt;/code&gt;注册过程中的差异之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;接收完毕并向&lt;code&gt;Sub Reactor&lt;/code&gt;注册成功后，那么接下来&lt;code&gt;Sub Reactor&lt;/code&gt;就开始监听注册其上的所有客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;的&lt;code&gt;OP_READ事件&lt;/code&gt;，并等待客户端向服务端发送网络数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面&lt;code&gt;Reactor&lt;/code&gt;的主角就该变为&lt;code&gt;Sub Reactor&lt;/code&gt;以及注册在其上的客户端&lt;code&gt;NioSocketChannel&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下篇文章，我们将会讨论Netty是如何接收网络数据的~~~~ 我们下篇文章见~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a2cca4b4fe1742f59516c34877d33e2f</guid>
<title>顺丰快递：请签收MySQL灵魂十连</title>
<link>https://toutiao.io/k/oagb15c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、SQL语句执行流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL大体上可分为&lt;code&gt;Server层&lt;/code&gt;和&lt;code&gt;存储引擎层&lt;/code&gt;两部分。&lt;/p&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Server层：&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;连接器&lt;/code&gt;：TCP握手后服务器来验证登陆用户身份，A用户创建连接后，管理员对A用户权限修改了也不会影响到已经创建的链接权限，必须重新登陆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;查询缓存&lt;/code&gt;：查询后的结果存储位置，MySQL8.0版本以后已经取消，因为查询缓存失效太频繁，得不偿失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;分析器&lt;/code&gt;：根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;优化器&lt;/code&gt;：多种执行策略可实现目标，系统自动选择最优进行执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;执行器&lt;/code&gt;：判断是否有权限，将最终任务提交到存储引擎。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储引擎层&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负责数据的存储和提取。其架构模式是&lt;code&gt;插件式&lt;/code&gt;的，支持&lt;code&gt;InnoDB&lt;/code&gt;、&lt;code&gt;MyISAM&lt;/code&gt;、&lt;code&gt;Memory&lt;/code&gt;等多个存储引擎。现在最常用的存储引擎是&lt;code&gt;InnoDB&lt;/code&gt;，它从MySQL 5.5.5版本开始成为了默认存储引擎(经常用的也是这个)。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4267241379310345&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscHYVe250B5pbSfZrbqeiatdwHkfBFbiaXibg8HicQqZD1ibaejYZnyg0jxEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1624&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;SQL执行顺序&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29390018484288355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscvL02EdeR3b0PK0icwria3VTqC15hyics1iaicuuz2KKUlVCZm4tDbRX1JtA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、BinLog、RedoLog、UndoLog&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BinLog&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BinLog&lt;/code&gt;是记录所有数据库表结构变更（例如create、alter table）以及表数据修改(insert、update、delete)的二进制日志，主从数据库同步用到的都是BinLog文件。BinLog日志文件有三种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;STATEMENT 模式&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;内容&lt;/code&gt;：binlog 只会记录可能引起数据变更的 sql 语句&lt;/p&gt;&lt;p&gt;&lt;code&gt;优势&lt;/code&gt;：该模式下，因为没有记录实际的数据，所以日志量和 IO 都消耗很低，性能是最优的&lt;/p&gt;&lt;p&gt;&lt;code&gt;劣势&lt;/code&gt;：但有些操作并不是确定的，比如 uuid() 函数会随机产生唯一标识，当依赖 binlog 回放时，该操作生成的数据与原数据必然是不同的，此时可能造成无法预料的后果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ROW 模式&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;内容&lt;/code&gt;：在该模式下，binlog 会&lt;strong&gt;记录每次操作的源数据与修改后的目标数据&lt;/strong&gt;，StreamSets就要求该模式。&lt;/p&gt;&lt;p&gt;&lt;code&gt;优势&lt;/code&gt;：可以绝对精准的还原，从而保证了数据的安全与可靠，并且复制和数据恢复过程可以是并发进行的&lt;/p&gt;&lt;p&gt;&lt;code&gt;劣势&lt;/code&gt;：缺点在于 binlog 体积会非常大，同时，对于修改记录多、字段长度大的操作来说，记录时性能消耗会很严重。阅读的时候也需要特殊指令来进行读取数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MIXED 模式&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;内容&lt;/code&gt;：是对上述STATEMENT 跟 ROW  两种模式的混合使用。&lt;/p&gt;&lt;p&gt;&lt;code&gt;细节&lt;/code&gt;：对于绝大部分操作，都使用 STATEMENT 来进行 binlog 的记录，只有以下操作使用 ROW 来实现：表的存储引擎为 NDB，使用了uuid() 等不确定函数，使用了 insert delay 语句，使用了临时表&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41243523316062175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscM2Fp9cfschice1hHVoTicZwJAfggMichIjt1rJnhqXSpWviaAR5BeiaaKTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;965&quot;/&gt;&lt;strong&gt;主从同步流程&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、主节点必须启用二进制日志，记录任何修改了数据库数据的事件。&lt;/p&gt;&lt;p&gt;2、从节点开启一个线程（I/O Thread)把自己扮演成 mysql 的客户端，通过 mysql 协议，请求主节点的二进制日志文件中的事件 。&lt;/p&gt;&lt;p&gt;3、主节点启动一个线程（dump Thread），检查自己二进制日志中的事件，跟对方请求的位置对比，如果不带请求位置参数，则主节点就会从第一个日志文件中的第一个事件一个一个发送给从节点。&lt;/p&gt;&lt;p&gt;4、从节点接收到主节点发送过来的数据把它放置到中继日志（Relay log）文件中。并记录该次请求到主节点的具体哪一个二进制日志文件内部的哪一个位置（主节点中的二进制文件会有多个）。&lt;/p&gt;&lt;p&gt;5、从节点启动另外一个线程（sql Thread ），把 Relay log 中的事件读取出来，并在本地再执行一次。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql默认的复制方式是&lt;code&gt;异步&lt;/code&gt;的，并且复制的时候是有&lt;code&gt;并行复制能力&lt;/code&gt;的。主库把日志发送给从库后不管了，这样会产生一个问题就是假设主库挂了，从库处理失败了，这时候从库升为主库后，&lt;strong&gt;日志就丢失了&lt;/strong&gt;。由此产生两个概念。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;全同步复制&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主库写入binlog后强制同步日志到从库，&lt;strong&gt;所有的从库都执行完成后才返回给客户端&lt;/strong&gt;，但是很显然这个方式的话性能会受到严重影响。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;半同步复制&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;半同步复制的逻辑是这样，从库写入日志成功后返回&lt;code&gt;ACK&lt;/code&gt;确认给主库，主库收到至少一个从库的确认就认为写操作完成。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以延伸到由于主从配置不一样、主库大事务、从库压力过大、网络震荡等造成&lt;code&gt;主备延迟&lt;/code&gt;，如何避免这个问题？主备切换的时候用&lt;code&gt;可靠性优先原则&lt;/code&gt;还是&lt;code&gt;可用性优先原则&lt;/code&gt;？如何判断主库Crash了？互为主备情况下如何避免主备循环复制？被删库跑路了如何正确恢复？(⊙o⊙)… 感觉越来越扯到DBA的活儿上去了。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscibMIov2IbEqK78yrVZjpMS5GW2NoqXOs5CB0ibVxDT0nzQ3DVUa2QAaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;200&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RedoLog&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以先通过下面demo理解：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;饭点记账可以把账单写在&lt;code&gt;账本&lt;/code&gt;上也可以写在&lt;code&gt;粉板&lt;/code&gt;上。有人赊账或者还账的话，一般有两种做法：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、直接把账本翻出来，把这次赊的账加上去或者扣除掉。&lt;/p&gt;&lt;p&gt;2、先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生意忙时选后者，因为前者太麻烦了。得在密密麻麻的记录中找到这个人的赊账总额信息，找到之后再拿出算盘计算，最后再将结果写回到账本上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在MySQL中如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。而粉板和账本配合的整个过程就是MySQL用到的是Write-Ahead Logging 技术，它的关键点就是&lt;code&gt;先写日志，再写磁盘&lt;/code&gt;。此时账本 = BinLog，粉板 = RedoLog。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、 记录更新时，InnoDB引擎就会先把记录写到RedoLog（粉板）里面，并更新内存。同时，InnoDB引擎会在空闲时将这个操作记录更新到磁盘里面。&lt;/p&gt;&lt;p&gt;2、 如果更新太多RedoLog处理不了的时候，需先将RedoLog部分数据写到磁盘，然后擦除RedoLog部分数据。RedoLog类似转盘。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RedoLog有&lt;code&gt;write pos&lt;/code&gt; 跟&lt;code&gt;checkpoint&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;write pos&lt;/code&gt; ：是当前记录的位置，一边写一边后移，写到第3号文件末尾后就回到0号文件开头。&lt;/p&gt;&lt;p&gt;&lt;code&gt;check point&lt;/code&gt;：是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;write pos和check point之间的是粉板上还空着的部分，可以用来记录新的操作。如果write pos追上checkpoint，表示粉板满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把checkpoint推进一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为&lt;code&gt;crash-safe&lt;/code&gt;。&lt;img data-ratio=&quot;1.010204081632653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscgO7ico0mApLjNfetKfiaSRovhW0hzcciav2OEibI4vOBAHEQUwG0K1Dtmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;code&gt;redolog两阶段提交&lt;/code&gt;：为了让binlog跟redolog两份日志之间的逻辑一致。提交流程大致如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1 prepare阶段 --&amp;gt;  2 写binlog  --&amp;gt; 3 commit&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当在2之前崩溃时，重启恢复后发现没有commit，回滚。备份恢复：没有binlog 。一致&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当在3之前崩溃时，重启恢复发现虽没有commit，但满足prepare和binlog完整，所以重启后会&lt;code&gt;自动&lt;/code&gt;commit。备份：有binlog. 一致&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;binlog跟redolog区别&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redo log是物理日志，记录的是在某个数据页上做了什么修改；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如给ID=2这一行的c字段加1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redo log是循环写的，空间固定会用完；binlog是可以追加写入的。追加写是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;UndoLog&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UndoLog 一般是逻辑日志，主要分为两种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;insert undo log&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代表事务在insert新记录时产生的undo log, 只在事务回滚时需要，并且在事务提交后可以被立即丢弃&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;update undo log&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;事务在进行update或delete时产生的undo log; 不仅在事务回滚时需要，在快照读时也需要；所以不能随便删除，只有在快速读或事务回滚不涉及该日志时，对应的日志才会被purge线程统一清除&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3、MySQL中的索引&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的常见模型有&lt;code&gt;哈希表&lt;/code&gt;、&lt;code&gt;有序数组&lt;/code&gt;和&lt;code&gt;搜索树&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;哈希表&lt;/code&gt;：一种以KV存储数据的结构，只适合等值查询，不适合范围查询。&lt;/p&gt;&lt;p&gt;&lt;code&gt;有序数组&lt;/code&gt;：只适用于静态存储引擎，涉及到插入的时候比较麻烦。可以参考Java中的&lt;strong&gt;ArrayList&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;code&gt;搜索树&lt;/code&gt;：按照数据结构中的二叉树来存储数据，不过此时是N叉树(B+树)。&lt;strong&gt;广泛应用在存储引擎层中&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33382789317507416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscSfuwG8dyJpNooFwiahEInRIJtRzLZribXCd7Kd2hR4DFib5bXkrt1mX1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot;/&gt;B+树比B树&lt;code&gt;优势&lt;/code&gt;在于：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;B+ 树非叶子节点存储的只是索引，可以存储的更多。B+树比B树更加矮胖，IO次数更少。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+ 树叶子节点前后管理，更加方便范围查询。同时结果都在叶子节点，查询效率稳定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B+树中更有利于对数据扫描，可以避免B树的回溯扫描。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的优点：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、唯一索引可以保证每一行数据的唯一性 &lt;/p&gt;&lt;p&gt;2、提高查询速度 &lt;/p&gt;&lt;p&gt;3、加速表与表的连接 &lt;/p&gt;&lt;p&gt;4、显著的减少查询中分组和排序的时间&lt;/p&gt;&lt;p&gt;5、通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的缺点：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、创建跟维护都需要耗时 &lt;/p&gt;&lt;p&gt;2、创建索引时，需要对表加锁，在锁表的同时，可能会影响到其他的数据操作 &lt;/p&gt;&lt;p&gt;3、 索引需要磁盘的空间进行存储，磁盘占用也很快。&lt;/p&gt;&lt;p&gt;4、当对表中的数据进行CRUD的时，也会触发索引的维护，而维护索引需要时间，可能会降低数据操作性能&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;索引设计的原则&lt;/strong&gt;不应该：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、索引不是越多越好。索引太多，维护索引需要时间跟空间。&lt;/p&gt;&lt;p&gt;2、 频繁更新的数据，不宜建索引。&lt;/p&gt;&lt;p&gt;3、数据量小的表没必要建立索引。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应该：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、重复率小的列建议生成索引。因为重复数据少，索引树查询更有效率，等价基数越大越好。&lt;/p&gt;&lt;p&gt;2、数据具有唯一性，建议生成唯一性索引。在数据库的层面，保证数据正确性 &lt;/p&gt;&lt;p&gt;3、频繁group by、order by的列建议生成索引。可以大幅提高分组和排序效率 &lt;/p&gt;&lt;p&gt;4、经常用于查询条件的字段建议生成索引。通过索引查询，速度更快&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引失效的场景&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、&lt;code&gt;模糊搜索&lt;/code&gt;：左模糊或全模糊都会导致索引失效，比如&#x27;%a&#x27;和&#x27;%a%&#x27;。但是右模糊是可以利用索引的，比如&#x27;a%&#x27; 。&lt;/p&gt;&lt;p&gt;2、&lt;code&gt;隐式类型转换&lt;/code&gt;：比如select * from t where name = xxx , name是字符串类型，但是没有加引号，所以是由MySQL隐式转换的，所以会让索引失效
3、&lt;code&gt;当语句中带有or的时候&lt;/code&gt;：比如select * from t where name=‘sw’ or age=14&lt;/p&gt;&lt;p&gt;4、&lt;code&gt;不符合联合索引的最左前缀匹配&lt;/code&gt;：(A,B,C)的联合索引，你只where了C或B或只有B,C&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;关于索引的知识点&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;主键索引&lt;/code&gt;：主键索引的叶子节点存的是&lt;code&gt;整行&lt;/code&gt;数据信息。在InnoDB里，主键索引也被称为聚簇索引（clustered index）。主键自增是&lt;code&gt;无法保证完全自增的哦&lt;/code&gt;，遇到唯一键冲突、事务回滚等都可能导致不连续。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;唯一索引&lt;/code&gt;：以唯一列生成的索引，该列不允许有重复值，但允许有空值(NULL)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;普通索引跟唯一索引查询性能&lt;/code&gt;：InnoDB的数据是按数据页为单位来读写的，默认每页16KB，因此这两种索引查询数据性能差别微乎其微。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;change buffer&lt;/code&gt;：普通索引用在更新过程的加速，更新的字段如果在缓存中，如果是普通索引则直接更新即可。如果是唯一索引需要将所有数据读入内存来确保不违背唯一性，所以尽量用普通索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;非主键索引&lt;/code&gt;：非主键索引的叶子节点内容是&lt;code&gt;主键&lt;/code&gt;的值。在InnoDB里，非主键索引也被称为二级索引（secondary index）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;回表&lt;/code&gt;：先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;覆盖索引&lt;/code&gt;：如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;联合索引&lt;/code&gt;：相对单列索引，组合索引是用多个列组合构建的索引，一次性最多联合16个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;最左前缀原则&lt;/code&gt;：对多个字段同时建立的组合索引(有顺序，ABC，ACB是完全不同的两种联合索引) 以联合索引(a,b,c)为例，建立这样的索引相当于建立了索引a、ab、abc三个索引。另外组合索引实际还是一个索引，并非真的创建了多个索引，只是产生的效果等价于产生多个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;索引下推&lt;/code&gt;：MySQL 5.6引入了索引下推优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表字数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;索引维护&lt;/code&gt;：B+树为了维护索引有序性涉及到页分裂跟页合并。增删数据时需考虑页空间利用率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;自增主键&lt;/code&gt;：一般会建立与业务无关的自增主键，不会触发叶子节点分裂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;延迟关联&lt;/code&gt;：通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;InnoDB存储&lt;/code&gt;: &lt;code&gt;* .frm&lt;/code&gt;文件是一份定义文件，也就是定义数据库表是一张怎么样的表。&lt;code&gt;*.ibd&lt;/code&gt;文件则是该表的索引，数据存储文件，既该表的所有索引树，所有行记录数据都存储在该文件中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MyISAM存储&lt;/code&gt;：&lt;code&gt;* .frm&lt;/code&gt;文件是一份定义文件，也就是定义数据库表是一张怎么样的表。&lt;code&gt;* .MYD&lt;/code&gt;文件是MyISAM存储引擎表的所有行数据的文件。&lt;code&gt;* .MYI&lt;/code&gt;文件存放的是MyISAM存储引擎表的索引相关数据的文件。MyISAM引擎下，表数据和表索引数据是分开存储的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MyISAM查询&lt;/code&gt;：在MyISAM下，主键索引和辅助键索引都属于非聚簇索引。查询不管是走主键索引，还是非主键索引，在叶子结点得到的都是目的数据的地址，还需要通过该地址，才能在数据文件中找到目的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PS&lt;/code&gt;：&lt;code&gt;InnoDB支持聚簇索引，MyISAM不支持聚簇索引&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4、SQL事务隔离级别&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ACID的四个特性&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;原子性&lt;/code&gt;（Atomicity）：把多个操作放到一个事务中，保证这些操作要么都成功，要么都不成功&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;一致性&lt;/code&gt;（Consistency）：理解成一串对数据进行操作的程序执行下来，不会对数据产生不好的影响，比如凭空产生，或消失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;隔离性&lt;/code&gt;（Isolation，又称独立性）：隔离性的意思就是多个事务之间互相不干扰，即使是并发事务的情况下，他们只是两个并发执行没有交集，互不影响的东西；当然实现中，也不一定需要这么完整隔离性，即不一定需要这么的互不干扰，有时候还是允许有部分干扰的。所以MySQL可以支持4种事务隔离性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;持久性&lt;/code&gt;（Durability）：当某个操作操作完毕了，那么结果就是这样了，并且这个操作会持久化到日志记录中&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：ACID中C与CAP定理中C的区别&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;ACID的C着重强调单数据库事务操作时，要保证数据的完整和正确性，数据不会凭空消失跟增加。&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;amp;mid=2247485515&amp;amp;idx=1&amp;amp;sn=60763ddda77928943bfd3d57e0c9256e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;CAP&lt;/a&gt; 理论中的C指的是对一个数据多个备份的读写一致性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事务操作可能会出现的数据问题&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、&lt;code&gt;脏读&lt;/code&gt;(dirty read)：B事务更改数据还未提交，A事务已经看到并且用了。B事务如果回滚，则A事务做错了 &lt;/p&gt;&lt;p&gt;2、 &lt;code&gt;不可重复读&lt;/code&gt;(non-repeatable read)：不可重复读的重点是修改: 同样的条件, 你读取过的数据, 再次读取出来发现值不一样了，只需要锁住满足条件的记录 &lt;/p&gt;&lt;p&gt;3、 &lt;code&gt;幻读&lt;/code&gt;(phantom read)：事务A先修改了某个表的所有纪录的状态字段为已处理，未提交；事务B也在此时新增了一条未处理的记录，并提交了；事务A随后查询记录，却发现有一条记录是未处理的造成幻读现象，幻读仅&lt;code&gt;专指新插入的行&lt;/code&gt;。幻读会造成&lt;code&gt;语义上&lt;/code&gt;的问题跟&lt;code&gt;数据一致性&lt;/code&gt;问题。&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、 在可重复读RR隔离级别下，普通查询是&lt;code&gt;快照读&lt;/code&gt;，是不会看到别的事务插入的数据的。因此，幻读在&lt;code&gt;当前读&lt;/code&gt;下才会出现。要用&lt;/span&gt;&lt;span&gt;间隙锁&lt;/span&gt;&lt;span&gt;解决此问题。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说隔离级别之前，你首先要知道，&lt;code&gt;你隔离得越严实，效率就会越低&lt;/code&gt;。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL标准的事务隔离级别由低到高如下：&lt;img data-ratio=&quot;0.2463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscgibd299HzibqpMOzBzuu53emIf8YzmicWjtB5StmmOm0NQyibYvehBEkHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;上图从上到下的模式会导致系统的并行性能依次降低，安全性依次提高。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;读未提交&lt;/code&gt;：别人改数据的事务尚未提交，我在我的事务中也能读到。&lt;/p&gt;&lt;p&gt;&lt;code&gt;读已提交(Oracle默认)&lt;/code&gt;：别人改数据的事务已经提交，我在我的事务中才能读到。&lt;/p&gt;&lt;p&gt;&lt;code&gt;可重复读(MySQL默认)&lt;/code&gt;：别人改数据的事务已经提交，我在我的事务中也不去读，以此保证重复读一致性。&lt;/p&gt;&lt;p&gt;&lt;code&gt;串行&lt;/code&gt;：我的事务尚未提交，别人就别想改数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;标准跟实现&lt;/code&gt;：上面都是关于事务的标准，但是每一种数据库都有不同的实现，比如&lt;code&gt;MySQL InnDB&lt;/code&gt; 默认为&lt;code&gt;RR&lt;/code&gt;级别，但是&lt;strong&gt;不会出现幻读&lt;/strong&gt;。因为当事务A更新了所有记录的某个字段，此时事务A会获得对这个表的&lt;strong&gt;表锁&lt;/strong&gt;，因为事务A还没有提交，所以事务A获得的锁没有释放，此时事务B在该表插入新记录，会因为无法获得该表的锁，则导致插入操作被阻塞。只有事务A提交了事务后，释放了锁，事务B才能进行接下去的操作。所以可以说   &lt;strong&gt;MySQL的RR级别的隔离是已经实现解决了脏读，不可重复读和幻读的&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5、MySQL中的锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是Java的并发编程还是数据库的并发操作都会涉及到锁，研发人员引入了&lt;code&gt;悲观锁&lt;/code&gt;跟&lt;code&gt;乐观锁&lt;/code&gt;这样一种锁的&lt;strong&gt;设计思想&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;：适合在写多读少的并发环境中使用，虽然无法维持非常高的性能，但是在乐观锁无法提更好的性能前提下，可以做到数据的安全性&lt;/p&gt;&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;：加锁会增加系统开销，虽然能保证数据的安全，但数据处理吞吐量低，不适合在读书写少的场合下使用&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;优点&lt;/code&gt;：在读多写少的并发场景下，可以避免数据库加锁的开销，提高DAO层的响应性能，很多情况下ORM工具都有带有乐观锁的实现，所以这些方法不一定需要我们人为的去实现。&lt;/p&gt;&lt;p&gt;&lt;code&gt;缺点&lt;/code&gt;：在写多读少的并发场景下，即在写操作竞争激烈的情况下，会导致CAS多次重试，冲突频率过高，导致开销比悲观锁更高。&lt;/p&gt;&lt;p&gt;&lt;code&gt;实现&lt;/code&gt;：数据库层面的乐观锁其实跟&lt;code&gt;CAS&lt;/code&gt;思想类似， 通&lt;code&gt;数据版本号&lt;/code&gt;或者&lt;code&gt;时间戳&lt;/code&gt;也可以实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库并发场景主要有三种：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;读-读&lt;/code&gt;：不存在任何问题，也不需要并发控制&lt;/p&gt;&lt;p&gt;&lt;code&gt;读-写&lt;/code&gt;：有隔离性问题，可能遇到脏读，幻读，不可重复读&lt;/p&gt;&lt;p&gt;&lt;code&gt;写-写&lt;/code&gt;：可能存更新丢失问题，比如第一类更新丢失，第二类更新丢失&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两类更新丢失问题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;第一类更新丢失：事务A的事务回滚覆盖了事务B已提交的结果
第二类更新丢失：事务A的提交覆盖了事务B已提交的结果&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了合理贯彻落实锁的思想，MySQL中引入了杂七杂八的各种锁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5758547008547008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjsctpicK2QbzhGg3pLVsOag114l2sSmB649SgQD00AMWiaSf5eq76spIibOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;936&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;锁分类&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL支持三种层级的锁定，分别为&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表级锁定&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MySQL中锁定粒度&lt;code&gt;最大&lt;/code&gt;的一种锁，最常使用的MYISAM与INNODB都支持表级锁定。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;页级锁定&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了&lt;code&gt;折衷&lt;/code&gt;的页级，一次锁定相邻的一组记录。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;行级锁定&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Mysql中锁定粒度&lt;code&gt;最细&lt;/code&gt;的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大&lt;code&gt;行级锁不一定比表级锁要好&lt;/code&gt;：锁的粒度越细，代价越高，相比表级锁在表的头部直接加锁，行级锁还要扫描找到对应的行对其上锁，这样的代价其实是比较高的，所以表锁和行锁各有所长。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MyISAM中的锁&lt;span/&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;虽然MySQL支持表，页，行三级锁定，但MyISAM存储引擎&lt;strong&gt;只支持表锁&lt;/strong&gt;。所以MyISAM的加锁相对比较开销低，但数据操作的并发性能相对就不高。但如果写操作都是尾插入，那还是可以支持一定程度的读写并发&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从MyISAM所支持的锁中也可以看出，MyISAM是一个支持读读并发，但不支持通用读写并发，写写并发的数据库引擎，所以它更适合用于读多写少的应用场合，一般工程中也用的较少。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InnoDB中的锁&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该模式下支持的锁实在是太多了，具体如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;共享锁和排他锁 (Shared and Exclusive Locks)&lt;/p&gt;&lt;p&gt;意向锁（Intention Locks） &lt;/p&gt;&lt;p&gt;记录锁（Record Locks） &lt;/p&gt;&lt;p&gt;间隙锁（Gap Locks） &lt;/p&gt;&lt;p&gt;临键锁 （Next-Key Locks） &lt;/p&gt;&lt;p&gt;插入意向锁（Insert Intention Locks） &lt;/p&gt;&lt;p&gt;主键自增锁 (AUTO-INC Locks) &lt;/p&gt;&lt;p&gt;空间索引断言锁（Predicate Locks for Spatial Indexes）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子，比如行锁里的&lt;strong&gt;共享锁跟排它锁：&lt;/strong&gt;&lt;code&gt;lock in share modle&lt;/code&gt; 共享读锁：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了确保自己查到的数据没有被其他的事务正在修改，也就是说确保查到的数据是&lt;code&gt;最新的数据&lt;/code&gt;，并且不允许其他人来修改数据。但是自己不一定能够修改数据，因为有可能其他的事务也对这些数据使用了 &lt;code&gt;in share mode&lt;/code&gt; 的方式上了&lt;code&gt;S&lt;/code&gt; 锁。如果不及时的commit 或者rollback 也可能会&lt;strong&gt;造成大量的事务等待&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;for update&lt;/code&gt;排它写锁:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了让自己查到的数据确保是最新数据，并且查到后的数据只允许自己来修改的时候，需要用到&lt;code&gt;for update&lt;/code&gt;。相当于一个 update 语句。在业务繁忙的情况下，如果事务没有及时的commit或者rollback 可能会造成其他事务长时间的等待，从而影响数据库的并发使用效率。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Gap Lock&lt;/code&gt;间隙锁：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、行锁只能锁住行，如果在记录之间的间隙插入数据就无法解决了，因此MySQL引入了间隙锁(Gap Lock)。间隙锁是&lt;code&gt;左右开区间&lt;/code&gt;。间隙锁之间&lt;code&gt;不会冲突&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;2、间隙锁和行锁合称&lt;code&gt;NextKeyLock&lt;/code&gt;，每个&lt;code&gt;NextKeyLock&lt;/code&gt;是&lt;code&gt;前开后闭区间&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;间隙锁加锁原则(学完忘那种)：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、加锁的基本单位是 NextKeyLock，是前开后闭区间。&lt;/p&gt;&lt;p&gt;2、查找过程中访问到的对象才会加锁。&lt;/p&gt;&lt;p&gt;3、索引上的等值查询，给&lt;code&gt;唯一索引&lt;/code&gt;加锁的时候，NextKeyLock退化为行锁。&lt;/p&gt;&lt;p&gt;4、索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，NextKeyLock退化为间隙锁。&lt;/p&gt;&lt;p&gt;5、唯一索引上的范围查询会访问到不满足条件的第一个值为止。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6、MVCC&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、全称&lt;code&gt;Multi-Version Concurrency Control&lt;/code&gt;，即&lt;code&gt;多版本并发控制&lt;/code&gt;。MVCC是一种并发控制的&lt;code&gt;理念&lt;/code&gt;，维持一个数据的多个版本，使得读写操作没有冲突。&lt;/p&gt;&lt;p&gt;2、MVCC在MySQL InnoDB中实现目的主要是为了&lt;strong&gt;提高数据库并发性能&lt;/strong&gt;，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MySQL InnoDB下的当前读和快照读&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前读&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、像&lt;code&gt;select lock in share mode&lt;/code&gt;(共享锁)、&lt;code&gt;select for updat&lt;/code&gt;e 、&lt;code&gt;update&lt;/code&gt;、&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;delete&lt;/code&gt;(排他锁)这些操作都是一种&lt;code&gt;当前读&lt;/code&gt;，就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对&lt;code&gt;读取的记录进行加锁&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;2、当前读可以认为是&lt;code&gt;悲观锁&lt;/code&gt;的具体功能实现&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;快照读&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、不加锁的select就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即&lt;code&gt;MVCC&lt;/code&gt;，可以认为&lt;code&gt;MVCC是行锁的一个变种&lt;/code&gt;，但它在很多情况下，&lt;code&gt;避免了加锁操作&lt;/code&gt;，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本。&lt;/p&gt;&lt;p&gt;2、快照读就是MVCC思想在MySQL的具体非阻塞读功能实现，MVCC的目的就是为了实现读-写冲突不加锁，提高并发读写性能，而这个读指的就是&lt;code&gt;快照读&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;3、快照读就是MySQL为我们实现MVCC理想模型的其中一个具体非阻塞读功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为大佬不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出了MVCC，所以我们可以形成两个组合：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;MVCC + 悲观锁&lt;/code&gt;：MVCC解决读写冲突，悲观锁解决写写冲突&lt;/p&gt;&lt;p&gt;&lt;code&gt;MVCC + 乐观锁&lt;/code&gt;：MVCC解决读写冲突，乐观锁解决写写冲突&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MVCC的实现原理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MVCC实现原理主要是依赖记录中的 &lt;code&gt;四个隐式字段&lt;/code&gt;、&lt;code&gt;undo日志&lt;/code&gt; 、&lt;code&gt;Consistent Read View&lt;/code&gt;来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;四个隐式字段&lt;/strong&gt;：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DB_TRX_ID：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的&lt;code&gt;事务ID&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DB_ROLL_PTR&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;7byte，回滚指针，指向这条记录的&lt;code&gt;上一个版本&lt;/code&gt;（存储于rollback segment里）&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;DB_ROW_ID&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;6byte，隐含的自增ID（&lt;code&gt;隐藏主键&lt;/code&gt;），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;FLAG&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一个删除flag隐藏字段, 既记录被更新或删除并不代表真的删除，而是删除flag变了&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务对一条记录的修改，会导致该记录的undo log成为一条记录版本线性表(&lt;code&gt;链表&lt;/code&gt;)，undo log的链首就是最新的旧记录，链尾就是最早的旧记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;undo日志&lt;/strong&gt;：此知识点上文已经说过了，对MVCC有帮助的实质是update undo log，undo log实际上就是存在rollback segment中旧记录链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一致读视图 Consistent Read View&lt;/strong&gt;：Read View是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个&lt;code&gt;快照&lt;/code&gt;，记录并维护系统当前活跃事务的ID(InnoDB里面每个事务有一个唯一的事务ID，叫作&lt;code&gt;transaction id&lt;/code&gt;。它是在事务开始的时候向InnoDB的事务系统申请的，是按申请顺序严格递增的)。拿着这个ID跟记录中ID对比进行选择性展示，这里说下&lt;code&gt;大致的思维&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以&lt;strong&gt;简单的理解&lt;/strong&gt;为MVCC为每一行增加了两个隐藏字段，两个字段分别保存了这个行的&lt;code&gt;当前事务ID&lt;/code&gt;跟行的&lt;code&gt;删除事务ID&lt;/code&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;insert时：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB为新插入的每一行保存当前系统版本号作为版本号。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;select时：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、 InnoDB只会查找版本早于当前事务版本的数据行(也就是行的系统版本号&lt;code&gt;&amp;lt;=&lt;/code&gt;事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。&lt;/p&gt;&lt;p&gt;2、行的删除版本要么未定义，要么大于当前事务版本号，这可以确保事务读取到的行在事务开始之前未被删除。&lt;/p&gt;&lt;p&gt;3、&lt;strong&gt;只有1，2 同时满足的记录，才能返回作为查询结果&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;delete时：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识.&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;update时：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB执行update，实际上是新插入了一行记录，并保存其创建时间为当前事务的ID，同时保存当前事务ID到要update的行的删除时间。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面只是一个浅显的讲解MVCC选择标准流程，源码层面应该是根据&lt;code&gt;低水位&lt;/code&gt;跟&lt;code&gt;高水位&lt;/code&gt;来截取的。具体实现可自行百度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重点&lt;/code&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、事务中快照读的结果是&lt;code&gt;非常依赖&lt;/code&gt;该事务首次出现快照读的地方，即某个事务中首次出现快照读的地方非常关键，它有决定该事务后续快照读结果的能力。&lt;/p&gt;&lt;p&gt;2、在&lt;code&gt;RC&lt;/code&gt;隔离级别下，是每个快照读&lt;code&gt;都会生成&lt;/code&gt;并获取最新的Read View；而在&lt;code&gt;RR&lt;/code&gt;隔离级别下，则是同一个事务中的&lt;code&gt;第一个&lt;/code&gt;快照读才会创建Read View, 之后的快照读获取的都是&lt;code&gt;同一个&lt;/code&gt;Read View。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7、缓冲池（buffer pool）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8301886792452831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscwkxt1Y5ib3BSgkZNLK9bRkS9vrWMJvGibJkM2MhPuqG15fWzzDt92zibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;795&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。操作系统，会有缓冲池(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。MySQL作为一个存储系统，同样具有缓冲池(buffer pool)机制，以避免每次查询数据都进行磁盘IO，主要作用：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、存在的意义是加速查询 &lt;/p&gt;&lt;p&gt;2、缓冲池(buffer pool) 是一种常见的&lt;strong&gt;降低磁盘访问&lt;/strong&gt; 的机制；&lt;/p&gt;&lt;p&gt;3、缓冲池通常以页(page &lt;strong&gt;16K&lt;/strong&gt;)为单位缓存数据；&lt;/p&gt;&lt;p&gt;4、缓冲池的常见管理算法是&lt;strong&gt;LRU&lt;/strong&gt;，memcache，OS，InnoDB都使用了这种算法；&lt;/p&gt;&lt;p&gt;5、InnoDB对普通LRU进行了优化：将缓冲池分为&lt;code&gt;老生代&lt;/code&gt;和&lt;code&gt;新生代&lt;/code&gt;，入缓冲池的页，优先进入老生代，该页被访问，才进入新生代，以解决预读失效的问题页被访问。且在老生代&lt;strong&gt;停留时间超过配置阈值&lt;/strong&gt;的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预读失效&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38961038961038963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscH7qKU8no7yicMLJWPSXnLhlsyPDRMJpx4udB5329PPFhicsRx2gLWNng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot;/&gt;&lt;strong&gt;缓冲池污染&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，MySQL性能急剧下降，这种情况叫缓冲池污染。解决办法：加入&lt;code&gt;老生代停留时间窗口&lt;/code&gt;策略后，短时间内被大量加载的页，并不会立刻插入新生代头部，而是优先淘汰那些，短期内仅仅访问了一次的页。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8、table瘦身&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;空洞&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MySQL执行&lt;code&gt;delete&lt;/code&gt;命令其实只是把记录的位置，或者数据页标记为了&lt;code&gt;可复用&lt;/code&gt;，但磁盘文件的大小是不会变的。通过delete命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是&lt;code&gt;空洞&lt;/code&gt;。插入时候引发分裂同样会产生空洞。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重建表思路&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、新建一个跟A表结构相同的表B &lt;/p&gt;&lt;p&gt;2、按照主键ID将A数据一行行读取同步到表B &lt;/p&gt;&lt;p&gt;3、用表B替换表A实现效果上的瘦身。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重建表指令&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、alter table A engine=InnoDB，慎重用，牛逼的DBA都用下面的开源工具。&lt;/p&gt;&lt;p&gt;2、推荐Github：gh-ost&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9、SQL Joins、统计、 随机查询&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7种join具体如下：&lt;img data-ratio=&quot;0.6955056179775281&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscBH6nUzNykh2yuJfMELtlfeGgesc6GYwsmeNFkV67uXWHp7n3q7EImg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;890&quot;/&gt;&lt;strong&gt;统计&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、MyISAM模式下把一个表的总行数存在了磁盘上，直接拿来用即可 &lt;/p&gt;&lt;p&gt;2、InnoDB引擎由于 MVCC的原因，需要把数据读出来然后累计求和 &lt;/p&gt;&lt;p&gt;3、性能来说 由坏到好：count(字段) &amp;lt; count(主键id) &amp;lt; count(1) ≈ count(*)，&lt;code&gt;尽量用count(*)即可。&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;随机查询&lt;/strong&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; word &lt;span&gt;from&lt;/span&gt; words &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; &lt;span&gt;rand&lt;/span&gt;() &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接使用&lt;code&gt;order by rand()&lt;/code&gt;，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;amp;mid=2247488546&amp;amp;idx=1&amp;amp;sn=732ca84abf572196ddf76597fe096969&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;explain&lt;/a&gt; 这个语句发现需要 &lt;code&gt;Using temporary&lt;/code&gt;和 &lt;code&gt;Using filesort&lt;/code&gt;，查询的执行代价往往是比较大的。所以在设计的时要避开这种写法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(*) &lt;span&gt;into&lt;/span&gt; @C &lt;span&gt;from&lt;/span&gt; t;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; @Y1 = &lt;span&gt;floor&lt;/span&gt;(@C * &lt;span&gt;rand&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; @Y2 = &lt;span&gt;floor&lt;/span&gt;(@C * &lt;span&gt;rand&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; @Y3 = &lt;span&gt;floor&lt;/span&gt;(@C * &lt;span&gt;rand&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;limit&lt;/span&gt; @Y1,&lt;span&gt;1;&lt;/span&gt; &lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;limit&lt;/span&gt; @Y2,&lt;span&gt;1;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;limit&lt;/span&gt; @Y3,&lt;span&gt;1;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样可以避免临时表跟排序的产生，最终查询行数 = C + (Y1+1) + (Y2+1) + (Y3+1)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;exist 和 in 对比&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、in查询时首先查询子查询的表，然后将内表和外表做一个&lt;code&gt;笛卡尔积&lt;/code&gt;，然后按照条件进行筛选。&lt;/p&gt;&lt;p&gt;2、子查询使用 exists，会先进行主查询，将查询到的每行数据&lt;code&gt;循环带入&lt;/code&gt;子查询校验是否存在，过滤出整体的返回数据。&lt;/p&gt;&lt;p&gt;3、两表大小相当，in 和 exists 差别不大。&lt;code&gt;内表大，用 exists 效率较高；内表小，用 in 效率较高&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;4、查询用not in 那么内外表都进行全表扫描，没有用到索引；而not exists 的子查询依然能用到表上的索引。&lt;code&gt;not exists比not in要快&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;10、MySQL优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SQL优化主要分4个方向：&lt;code&gt;SQL语句跟索引&lt;/code&gt;、&lt;code&gt;表结构&lt;/code&gt;、&lt;code&gt;系统配置&lt;/code&gt;、&lt;code&gt;硬件&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总优化思路就是&lt;strong&gt;最大化利用索引&lt;/strong&gt;、&lt;strong&gt;尽可能避免全表扫描&lt;/strong&gt;、&lt;strong&gt;减少无效数据的查询&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、减少数据访问：设置&lt;code&gt;合理的字段类型&lt;/code&gt;，启用压缩，通过索引访问等减少磁盘 IO。&lt;/p&gt;&lt;p&gt;2、返回更少的数据：只&lt;code&gt;返回需要&lt;/code&gt;的字段和数据分页处理，减少磁盘 IO 及网络 IO。&lt;/p&gt;&lt;p&gt;3、减少交互次数：&lt;code&gt;批量&lt;/code&gt; DML 操作，函数存储等减少数据连接次数。&lt;/p&gt;&lt;p&gt;4、减少服务器 CPU 开销：&lt;strong&gt;尽量减少数据库排序操作以及全表查询&lt;/strong&gt;，减少 CPU 内存占用 &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5、分表分区：使用&lt;code&gt;表分区&lt;/code&gt;，可以增加并行操作，更大限度利用 CPU 资源。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SQL语句优化大致举例&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、合理建立覆盖索引：可以有效减少回表。&lt;/p&gt;&lt;p&gt;2、union，or，in都能命中索引，建议使用in &lt;/p&gt;&lt;p&gt;3、负向条件(!=、&amp;lt;&amp;gt;、not in、not exists、not like 等) 索引不会使用索引，建议用in。&lt;/p&gt;&lt;p&gt;4、在列上进行运算或使用函数会使索引失效，从而进行全表扫描 &lt;/p&gt;&lt;p&gt;5、小心隐式类型转换，原字符串用整型会触发&lt;code&gt;CAST&lt;/code&gt;函数导致索引失效。原int用字符串则会走索引。&lt;/p&gt;&lt;p&gt;6、不建议使用%前缀模糊查询。&lt;/p&gt;&lt;p&gt;7、多表关联查询时，小表在前，大表在后。在 MySQL 中，执行 from 后的表关联查询是从左往右执行的(Oracle 相反)，第一张表会涉及到全表扫描。&lt;/p&gt;&lt;p&gt;8、调整 Where 字句中的连接顺序，MySQL 采用从左往右，自上而下的顺序解析 where 子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SQL调优大致思路&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、先用慢查询日志定位具体需要优化的sql &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、使用 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;amp;mid=2247488546&amp;amp;idx=1&amp;amp;sn=732ca84abf572196ddf76597fe096969&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;explain&lt;/a&gt; 执行计划查看索引使用情况 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、重点关注(一般情况下根据这4列就能找到索引问题)：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、key（查看有没有使用索引） &lt;/p&gt;&lt;p&gt;2、key_len（查看索引使用是否充分）&lt;/p&gt;&lt;p&gt;3、type（查看索引类型） &lt;/p&gt;&lt;p&gt;4、Extra（查看附加信息：排序、临时表、where条件为false等）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、根据上1步找出的索引问题优化sql
5、再回到第2步&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dUQrRBUyxETV2RgzXuPqjscXslQAiaAsl3icFLPfJiaRfcCC4VXlOVv5gAhuvEbS7AbzjG6KjTUx5Fhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;表结构优化&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED 。&lt;/p&gt;&lt;p&gt;2、VARCHAR的长度只分配真正需要的空间 &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、尽量使用TIMESTAMP而非DATETIME &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;4、单表不要有太多字段，建议在20以内&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5、避免使用NULL字段，很难查询优化且占用额外索引空间。字符串默认为&#x27;&#x27;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读写分离&lt;/strong&gt;：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;只在主服务器上写，只在从服务器上读。对应到数据库集群一般都是一主一从、一主多从。业务服务器把需要写的操作都写到主数据库中，读的操作都去从库查询。主库会同步数据到从库保证数据的一致性。一般 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA5NDIzNzY1OQ==&amp;amp;mid=2735617707&amp;amp;idx=2&amp;amp;sn=6fd038b3385c1175a6efd4ef00543e35&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;读写分离&lt;/a&gt; 的实现方式有两种：&lt;code&gt;代码封装&lt;/code&gt;跟&lt;code&gt;数据库中间件&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分库分表&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&amp;amp;mid=2247484479&amp;amp;idx=1&amp;amp;sn=97358231f0f7086f0056fc5bb4e8afff&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分库分表&lt;/a&gt;分为垂直和水平两个方式，一般是&lt;code&gt;先垂直后水平&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、&lt;code&gt;垂直分库&lt;/code&gt;：将应用分为若干模块，比如订单模块、用户模块、商品模块、支付模块等等。其实就是微服务的理念。&lt;/p&gt;&lt;p&gt;2、&lt;code&gt;垂直分表&lt;/code&gt;：一般将不常用字段跟数据较大的字段做拆分。&lt;/p&gt;&lt;p&gt;3、&lt;code&gt;水平分表&lt;/code&gt;：根据场景选择什么字段作分表字段，比如淘宝日订单1000万，用userId作分表字段，数据查询支持到最近6个月的订单，超过6个月的做归档处理，那么6个月的数据量就是18亿，分1024张表，每个表存200W数据，hash(userId)%100找到对应表格。&lt;/p&gt;&lt;p&gt;4、&lt;code&gt;ID生成器&lt;/code&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI1OTI4Nw==&amp;amp;mid=2247485459&amp;amp;idx=1&amp;amp;sn=9baf434bdeebe98be60bcde7df702f22&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分布式ID&lt;/a&gt; 需要跨库全局唯一方便查询存储-检索数据，确保唯一性跟数字递增性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要流行的分库分表工具 就是&lt;code&gt;Mycat&lt;/code&gt;和&lt;code&gt;sharding-sphere&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;TiDB&lt;/strong&gt;：开源&lt;code&gt;分布式&lt;/code&gt;数据库，结合了传统的 RDBMS 和NoSQL 的最佳特性。TiDB 兼容 MySQL，&lt;code&gt;支持无限的水平扩展&lt;/code&gt;，具备强一致性和高可用性。TiDB 的目标是为 OLTP(Online Transactional Processing) 和 OLAP (Online Analytical Processing) 场景提供一站式的解决方案。TiDB 具备如下核心特点&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、支持 MySQL 协议（开发接入成本低）&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、100% 支持事务（数据一致性实现简单、可靠）&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、无限水平拓展（不必考虑分库分表），不停服务。&lt;/p&gt;&lt;p&gt;4、TiDB 支持和 MySQL 的互备。&lt;/p&gt;&lt;p&gt;5、遵循jdbc原则，学习成本低，强关系型，强一致性，不用担心主从配置，不用考虑分库分表，还可以无缝动态扩展&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适合：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、原业务的 MySQL 的业务遇到单机容量或者性能瓶颈时，可以考虑使用 TiDB 无缝替换 MySQL。&lt;/p&gt;&lt;p&gt;2、大数据量下，MySQL 复杂查询很慢。&lt;/p&gt;&lt;p&gt;3、大数据量下，数据增长很快，接近单机处理的极限，不想分库分表或者使用数据库中间件等对业务侵入性较大、对业务有约束的 Sharding 方案。&lt;/p&gt;&lt;p&gt;4、大数据量下，有高并发实时写入、实时查询、实时统计分析的需求。5、有分布式事务、多数据中心的数据 100% 强一致性、auto-failover 的高可用的需求。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不适合：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、单机 MySQL 能满足的场景也用不到 TiDB。&lt;/p&gt;&lt;p&gt;2、数据条数少于 5000w 的场景下通常用不到 TiDB，TiDB 是为大规模的数据场景设计的。&lt;/p&gt;&lt;p&gt;3、如果你的应用数据量小（所有数据千万级别行以下），且没有高可用、强一致性或者多数据中心复制等要求，那么就不适合使用 TiDB。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;End&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些简单的MySQL知识点汇总，可自取：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1、SQL基础：https://juejin.im/post/6844903790571700231&lt;/p&gt;&lt;p&gt;2、SQL面试：https://sowhat.blog.csdn.net/article/details/71158104&lt;/p&gt;&lt;p&gt;3、MySQL拷问：https://www.jianshu.com/nb/22933318&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>