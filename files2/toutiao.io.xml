<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>9a9b3cb7a7dfb532a3fec121cf6e6bd7</guid>
<title>一文搞懂前端兼容问题</title>
<link>https://toutiao.io/k/plsx3t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5274151436031331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mzricSSj51xbyHo5ULFolCf03nylYpkxc0TD1kzDgkkrn0ZTm8mNtgWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1915&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📌&lt;/span&gt;&lt;p&gt;如果你喜欢我写的文章，可以把我的公众号设为&lt;strong&gt;星标 🌟&lt;/strong&gt;，这样每次有更新就可以及时推送给你啦&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分开发者来说，版本兼容是一件存在感很低的事情，因为它在绝大部分情况下都是一行配置，在一些前端工具链（例如 Babel、CoreJS，Autoprefixer 等工具）的帮助下适配到目标浏览器，只会在一些大的 break change 事件（例如 Vue3 必须在支持 Proxy 的现代浏览器下才能运行）下才会关注这件不起眼的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但当你稍微研究一下的时候，才会发现这块儿内容知识非常杂，因为版本兼容的相关知识没有那么多内在逻辑性，很多细碎的知识点散落在在各个商业公司的博弈和版本变更中。前段时间因工作需要对部分语言/浏览器特性重点关注了一下，以此文做一下记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要记录了移动端的版本适配问题，未对桌面端做更多的研究，后面有可能补充相关内容。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.iOS &amp;amp; Safari&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;iOS 和 Android 虽然都是一年更新一个大版本，但受益于生态的封闭性，iOS 的更新率&lt;strong&gt;极高&lt;/strong&gt;，基本上最近的两个版本就能覆盖 95% 以上的人群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 &lt;span&gt;Apple 官方统计&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，截止到 2022-05-31，Apple 四年内推出的新机型中，&lt;code&gt;iOS 15&lt;/code&gt; 已经有 89% 的装机率，&lt;code&gt;iOS 14&lt;/code&gt; 也有 10% 的装机率；而在所有历史机型里，&lt;code&gt;iOS 15&lt;/code&gt; 和 &lt;code&gt;iOS 14&lt;/code&gt; 加起来也有 96% 的装机率，隔壁 Android 都羡慕哭了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.419871794871795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mCLUsFIvu4XFeYszICdCVruZwCK36aI69Za3uhJPC6BG3OONS6ITf2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么如此关注 iOS 的版本号？&lt;strong&gt;因为 iOS 版本基本上和 Safari 版本一一对应的&lt;/strong&gt;，例如 &lt;code&gt;iOS 15.6&lt;/code&gt; 上安装着 &lt;code&gt;Safari 15.6&lt;/code&gt;，&lt;code&gt;iOS 14.5&lt;/code&gt; 上安装着 &lt;code&gt;Safari 14.1&lt;/code&gt;，具体的映射关系可见 &lt;span&gt;MDN 的映射表&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，或者可以看 &lt;span&gt;core-js: SafariToIOS&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，所以我们基本上只要比对 iOS 版本号即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个问题是，有一定 C 端开发经验的开发者可能还会关注 iOS 上运行的是 UIWebView 还是 WKWebView，在 2022 年这个时间点其实已经不需要关注了，因为 Apple Store 已经发过&lt;span&gt;公告&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，2020 12 月之后已经禁止含 UIWebView 的 APP 上架了，所以 iOS 平台只有 WKWebView 这一个 WebView 了，而且它&lt;span&gt;兼容性也不错&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;，最低支持到 &lt;code&gt;iOS 8&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.Android &amp;amp; Chrome&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说完 iOS 我们再谈谈 Android。因为两个操作系统的发展策略不同，再加上国内各大厂商的魔改，Android 从一开始就深陷碎片化的深渊，有 Android 开发经历的同学一定都深有感触。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Android 系统本身碎片化，Android 系统自带的浏览器&lt;strong&gt;更碎片化&lt;/strong&gt;。在 Android 早期，Android 版本和 Chrome 浏览器版本是有绑定关系的，那这个早期是有多早？那就是 &lt;code&gt;Android 4&lt;/code&gt;，2014 年发布，绑定了 Chrome 早期几个版本，因为数据不多，我这里就直接列出来：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/mapping.mjs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ChromeToAndroid&lt;/span&gt;: [&lt;br/&gt;  [&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;&#x27;3.0&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&#x27;4.0&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;&#x27;4.4&#x27;&lt;/span&gt;],&lt;br/&gt;  [&lt;span&gt;33&lt;/span&gt;, &lt;span&gt;&#x27;4.4.3&#x27;&lt;/span&gt;],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情的转机出现在 &lt;code&gt;Android 5&lt;/code&gt;，&lt;span&gt;这个版本&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;里 WebView 被移植为一个独立的 APK，可以独立更新，不再和 Android 系统深度绑定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Google 的想法初衷是好的，借助于 Google 商店，解耦更利于浏览器的版本迭代。但是在国内多厂商魔改和一些网络问题上，极有可能发生这样的事情：对于一台 &lt;code&gt;Android 5&lt;/code&gt; 手机，理论上用户可以安装 &lt;code&gt;Chrome 36&lt;/code&gt; - &lt;code&gt;Chrome 95&lt;/code&gt; &lt;strong&gt;任意一个版本&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以和 iOS 对比起来，Android 因为他的开放性带来严重的碎片化问题：Android 版本多样，Chrome 版本多样，还有各种魔改内核，对于开发者来说适配起来真的苦不堪言。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.Web Browser&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完操作系统的版本历史，我们再看看浏览器上最关键的 JavaScript 语法兼容度。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JavaScript&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近十年内，JS 这门语言的的最大变革就是 ES6（ES2015）的发布了，带来了非常多的新特性。下面我搞了一个表格，列出几个大家常用的 JS 语法是从哪个版本开始支持的：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;语法/API&lt;/th&gt;&lt;th&gt;iOS&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Class&lt;/code&gt;&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;const&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;let&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Proxy&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;49&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;generators&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;39&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;33&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;async await&lt;/code&gt;&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;55&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;import&lt;/code&gt; &lt;code&gt;export&lt;/code&gt;&lt;/td&gt;&lt;td&gt;10.3&lt;/td&gt;&lt;td&gt;61&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，这些语法的最低支持版本集中在 &lt;code&gt;iOS 10&lt;/code&gt;、&lt;code&gt;iOS 11&lt;/code&gt;，&lt;code&gt;Chrome 49&lt;/code&gt;，&lt;code&gt;Chrome 61&lt;/code&gt; 这几个版本上，我们把它们的版本发布时间列出来：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;事件&lt;/th&gt;&lt;th&gt;发布时间&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ES5&lt;/code&gt; 标准发布时间&lt;/td&gt;&lt;td&gt;2009.12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;ES6&lt;/code&gt; 标准发布时间&lt;/td&gt;&lt;td&gt;2015.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;iOS 10&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2016.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;iOS 11&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2017.06&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Chrome 49&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2016.03&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Chrome 61&lt;/code&gt; 发布时间&lt;/td&gt;&lt;td&gt;2017.09&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间列出来后结论基本上是呼之欲出了：&lt;strong&gt;ES6 标准发布后的未来一年时间内，各大浏览器语法就支持的差不多了，两年后基本上就全部支持了&lt;/strong&gt;，&lt;strong&gt;这个时间点就是 2017 年，对应着&lt;/strong&gt; &lt;code&gt;iOS 11&lt;/code&gt; &lt;strong&gt;和&lt;/strong&gt; &lt;code&gt;Chrome 61&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;legacy vs modern&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完 ES6 的支持情况，我们再来了解两个概念，「经典浏览器」和「现代浏览器」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个词在英文里对应着「legacy browser」和「modern browser」。如果大家比较关注一些相对前沿的前端项目，比如说 Vue3，Solidjs，Vite，它们的官网里其实经常提到这两个词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，既然有两个称呼，那在工程里必然存在一个分界线去区分 legacy 和 modern，&lt;strong&gt;这个分界线就是 &lt;code&gt;iOS10.3&lt;/code&gt; 和 &lt;code&gt;Chrome 61&lt;/code&gt;，既浏览器支持 ES Modules 的版本&lt;/strong&gt;（支持 &lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; &amp;amp; &lt;code&gt;import&lt;/code&gt; &amp;amp; &lt;code&gt;export&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一看是不是就和上面的内容对上了？Babel 官网也做了相关的&lt;span&gt;解释&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;，core-js 也专门做了&lt;span&gt;区分&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;，更详细的介绍可以看 MDN 的文章：&lt;span&gt;JavaScript modules&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，我就不做多余介绍了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;modern feature&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面的探索，我们再回过来看看一些比较 modern 的 browser feature 的支持程度：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;browser fature&lt;/th&gt;&lt;th&gt;iOS&lt;/th&gt;&lt;th&gt;Chrome&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Web Worker&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SubtleCrypto&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;37&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Service Worker&lt;/td&gt;&lt;td&gt;11.3&lt;/td&gt;&lt;td&gt;45&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WebAssembly&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;57&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CSS Grid Layout&lt;/td&gt;&lt;td&gt;10.3&lt;/td&gt;&lt;td&gt;58&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WebGPU&lt;/td&gt;&lt;td&gt;not support&lt;/td&gt;&lt;td&gt;not support&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;td&gt;...&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看各个 API 的兼容度，再结合上文的内容，就可以发现很多「兼容性不好」人云亦云的说法不攻自破，&lt;strong&gt;其实大部分情况下不是兼容度不好从而不用，是项目还没有复杂到那个程度需要用这些高级功能&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Open Source Project&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中肯定不能写一行代码查一下兼容度，这些都是由社区工具做抹平的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;兼容度数据源头可以追述到 MDN 的 &lt;span&gt;browser-compat-data&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，记录了各种 API 的兼容，MDN 网站的兼容度直接是从这个 repo 里读的。我们常用的 &lt;span&gt;caniuse&lt;/span&gt;&lt;sup&gt;[11]&lt;/sup&gt; 网站，一部分数据也是依赖于它的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是工程上依赖最多的 &lt;span&gt;browserslist&lt;/span&gt;&lt;sup&gt;[12]&lt;/sup&gt;，babel、eslint、autoprefixer、postcss，webpack 等构建工具都依赖于它，browserslist 的数据又依赖于 &lt;span&gt;caniuse-lite&lt;/span&gt;&lt;sup&gt;[13]&lt;/sup&gt;，其实也是依赖于 &lt;span&gt;caniuse&lt;/span&gt;&lt;sup&gt;[14]&lt;/sup&gt;，lite 只保留了核心数据，对一些说明文案做了裁剪处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合以上分析，我们可以看出，在项目工程里依赖的 browserslist，数据准确性还是可以得到保证的，所以兼容性还是无需担心的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.Adaptation Suggestions&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，那么有什么配置建议呢？我个人认为主要有 3 点建议提供参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一个是参考国民级 APP 的最低支持度配置&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在国内，在日活上能称为国民级 APP 的就是微信抖音了，这两个 APP 因为日活巨大，基本上已经覆盖到全部中国人，所以他们的配置一定有所考量，可以反应出国内的整体手机版本水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 App Store/Android 应用商店/浏览器 UA 上看，我们可以得处以下结论（截止到 2022-8-8）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;微信&lt;/strong&gt;：最低支持到 &lt;code&gt;iOS 12&lt;/code&gt;、&lt;code&gt;Android 5&lt;/code&gt;、内置浏览器版本为 &lt;code&gt;Chrome 86&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;抖音&lt;/strong&gt;：最低支持到 &lt;code&gt;iOS 10&lt;/code&gt;、&lt;code&gt;Android 5&lt;/code&gt;、内置浏览器版本为 &lt;code&gt;Chrome 75&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然你也可以参考其他 APP，由于精力有限我就不做过多展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据项目的迭代速度来看，iOS 基本上可以做到一年一升级，比如说今年 &lt;code&gt;iOS 16&lt;/code&gt; 出来后，明年最低适配版本基本上可以升到 &lt;code&gt;iOS 11&lt;/code&gt; 了，Android 因为长尾效应和版本不绑定的问题，应该还会支持到 &lt;code&gt;Android 5&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二个建议是直接看当前业务的版本数据&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的公司不同的项目都有不同的用户场景，比如说面向三四线 C 端用户的场景，一般低端机就会多一些；面向门店的场景，说不定还得适配 IE 浏览器；面向企业内的开发者项目，直接适配到最新几个浏览器即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景如此之多就要依赖于用户版本数据统计了。一般中大厂都有比较完善的数据监控中台，直接拉一份数据就能获取大致情况，基建不完善的小公司也可以单独开个接口记录数据，收集一个月做个去重统计也能得到相关数据。拿到数据后再结合业务场景做些&lt;strong&gt;取舍&lt;/strong&gt;，基本上就可以拿到最低适配了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三个建议结合前端框架和 Chrome 版本做兼容。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合前端框架其实很好理解，比如说你用了 Vue3，底层依赖于 Proxy，那么最低依赖已经锁死到 &lt;code&gt;iOS 10&lt;/code&gt; 和 &lt;code&gt;Chrome 49&lt;/code&gt; 了，那你的最低配置只能比以上版本高，假如你无脑设置为 &lt;code&gt;iOS 9&lt;/code&gt; 或 &lt;code&gt;Android 4&lt;/code&gt;，除了在最低版本上跑不起来，还要平白无故的多了许多语法转换和 polyfill，在 &lt;strong&gt;构建速度/运行时性能/产物体积&lt;/strong&gt; 上都会产生不必要的劣化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合 Chrome 版本做兼容其实就是本文第二大节的内容。因为 &lt;code&gt;Android 5&lt;/code&gt; 之后不再和 Chrome 做深度绑定，版本兼容设置 Android 版本其实是无意义的行为，应该根据统计结果直接设置 Chrome 版本，做更细粒度的配置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Refs: Version History&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的版本历史和发布时间主要参考官方更新日志/文档 和 维基百科，相关链接如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;iOS 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/IOS_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/Android_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Chrome 版本历史：&lt;span&gt;https://en.wikipedia.org/wiki/Google_Chrome_version_history&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WKWebView API 兼容度：&lt;span&gt;https://developer.apple.com/documentation/webkit/wkwebview&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Android Verison 和 APILevel 的对应关系：&lt;span&gt;https://developer.android.com/guide/topics/manifest/uses-sdk-element#ApiLevels&lt;/span&gt;&lt;sup/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;📌&lt;/span&gt;&lt;p&gt;如果你喜欢我的文章，希望点赞👍 收藏 📁 在看 🌟 三连支持一下，谢谢你，这对我真的很重要！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎大家关注我的微信公众号：&lt;strong&gt;卤蛋实验室&lt;/strong&gt;，目前专注前端技术，对图形学也有一些微小研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以加我的微信 &lt;strong&gt;egg_labs&lt;/strong&gt;，欢迎大家来撩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9874476987447699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mINJEvt1UEUBBaR1hftktLbw5Wwzu3h0GMACiaNxcY9TWWUEkiaEcSfJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8MK8X2XQgu4C6KSk9OcJMIt6vbm4cQ0mKytNksWwTjQvricVbXuhKSt2Bwt0uBaJSTE4MgZjyQqncmzIzZbthfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;Apple 官方统计: &lt;em&gt;https://developer.apple.com/support/app-store/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;MDN 的映射表: &lt;em&gt;https://github.com/mdn/browser-compat-data/blob/main/browsers/safari_ios.json&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;core-js: SafariToIOS: &lt;em&gt;https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/mapping.mjs&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;公告: &lt;em&gt;https://developer.apple.com/cn/news/?id=edwud51q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;兼容性也不错: &lt;em&gt;https://developer.apple.com/documentation/webkit/wkwebview&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;这个版本: &lt;em&gt;https://developer.chrome.com/docs/multidevice/webview/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;解释: &lt;em&gt;https://babeljs.io/docs/en/options#targetsesmodules&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;区分: &lt;em&gt;https://github.com/zloirock/core-js/blob/master/packages/core-js-compat/src/external.mjs&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;JavaScript modules: &lt;em&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;browser-compat-data: &lt;em&gt;https://github.com/mdn/browser-compat-data&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[11]&lt;/span&gt;&lt;p&gt;caniuse: &lt;em&gt;https://caniuse.com/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;p&gt;browserslist: &lt;em&gt;https://github.com/browserslist/browserslist&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[13]&lt;/span&gt;&lt;p&gt;caniuse-lite: &lt;em&gt;https://github.com/browserslist/caniuse-lite&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[14]&lt;/span&gt;&lt;p&gt;caniuse: &lt;em&gt;https://github.com/Fyrd/caniuse&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;p&gt;&lt;em/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>908331578d291d15308c71af0d396432</guid>
<title>Golang &amp; WASM</title>
<link>https://toutiao.io/k/ms4ut8h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://unsplash.com/photos/NbgQfUvKFE0&quot;&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./cover.jpg&quot; alt=&quot;Photo by Mark Tegethoff on Unsplash&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;At the beginning of the year, I was curious about WebAssembly (WASM). &lt;a href=&quot;https://brunoluiz.net/blog/2022/jan/gif-sane-playback-control-ffmpegwasm/&quot;&gt;The result was GIFSane&lt;/a&gt;, but that was not enough: &lt;a href=&quot;https://github.com/ffmpegwasm/ffmpeg.wasm&quot;&gt;FFMpeg.wasm&lt;/a&gt; was already pre-compiled, and I only had to sort out how to use it within an extension. One thing was clear though: WASM shines when we think about complex applications (eg: media manipulation), usually performing better or opening more opportunities than JavaScript.&lt;/p&gt;&lt;p&gt;I’ve moved houses quite recently. It meant manipulating tons of documents, converting to different formats, resizing etc. Mac’s Preview app can handle it, but many might rely on browsers due to the first search results for “Convert image format1 format2”. Seriously, look at these Google results.&lt;/p&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./01-google-search.png&quot; alt=&quot;Google results for &amp;amp;lsquo;convert image&amp;amp;rsquo;&quot;/&gt;&lt;/p&gt;&lt;p&gt;When someone is converting a puppy image from JPG to PDF this might be ok. But after hearing that my family used these sites to convert documents like Passports, I got scared. Most people don’t realise that these files go to a server, and they can be stored for whatever reason and for an indefinite time. “Identity theft” sends its regards 😅&lt;/p&gt;&lt;p&gt;What if there was some website to convert images locally, without requiring a server? What if the technology for that already exists? That is when I started developing &lt;a href=&quot;https://imagewand.concordalabs.com/&quot;&gt;ImageWand&lt;/a&gt; (&lt;a href=&quot;https://github.com/brunoluiz/imagewand&quot;&gt;source&lt;/a&gt;).&lt;/p&gt;&lt;h2 id=&quot;converting-your-images-locally-and-privately-imagewand&quot;&gt;Converting your images locally and privately: ImageWand&lt;/h2&gt;&lt;p&gt;ImageWand converts images locally using WASM and Golang. In the future, it could potentially resize and compress images, but I tried to keep it simple by only using standard libraries encoders and decoders (no PDF for now).&lt;/p&gt;&lt;p&gt;It seems that Rust would have been a more solid choice for WASM, but I would have to learn it to develop this project. Rust is famous for its &lt;a href=&quot;https://users.rust-lang.org/t/making-rust-easy-to-learn-and-use/65866/3&quot;&gt;steep learning curve&lt;/a&gt; and, to keep things simple and focused, I went with Golang.&lt;/p&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./02-imagewand.png&quot; alt=&quot;ImageWand main page&quot;/&gt;&lt;/p&gt;&lt;center&gt;&lt;small&gt;Less is more, although I guess the application could benefit from more features 😅&lt;/small&gt;&lt;/center&gt;&lt;h2 id=&quot;the-building-experience&quot;&gt;The building experience&lt;/h2&gt;&lt;p&gt;Golang offers some standard libraries for image manipulation (&lt;a href=&quot;https://pkg.go.dev/image&quot;&gt;&lt;code&gt;image&lt;/code&gt; package&lt;/a&gt;). Implementing something to convert A to B wasn’t the hard part. &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/v1.0.0/imagewand.go&quot;&gt;The conversion logic was extracted and re-used&lt;/a&gt; in both CLI and WASM implementations, which is impressive in terms of portability.&lt;/p&gt;&lt;h3 id=&quot;covering-the-basics-interfacing-with-user-input&quot;&gt;Covering the basics: interfacing with user input&lt;/h3&gt;&lt;p&gt;In a CLI, the application can receive user input through flags or arguments. In WASM, things are a bit peculiar as inputs have to come from JavaScript into Golang.&lt;/p&gt;&lt;p&gt;You can instantiate and load the WASM binary for every call, similar to a CLI call, but it would be an expensive operation. The best way is to run it in the background (&lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/v1.0.0/cmd/wasm/main.go#L54&quot;&gt;observe the use of a channel to keep it running&lt;/a&gt;) while developers call it through a JavaScript interface.&lt;/p&gt;&lt;p&gt;In Golang, this is done by &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/v1.0.0/cmd/wasm/main.go#L51-L53&quot;&gt;exposing global JavaScript objects/functions within &lt;code&gt;main()&lt;/code&gt;&lt;/a&gt;. It is not great as it might conflict with other variables and it pollutes the global scope. Other WASM implementations (Rust or TinyGo+WASI) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Instance/exports&quot;&gt;expose methods by exporting them&lt;/a&gt; in the WASM instance, which is cleaner than relying on global variables.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
  &lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;Starting ImageWand 🪄&quot;&lt;/span&gt;)

  &lt;span&gt;js&lt;/span&gt;.&lt;span&gt;Global&lt;/span&gt;().&lt;span&gt;Set&lt;/span&gt;(&lt;span&gt;&quot;wand&quot;&lt;/span&gt;, &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;interface&lt;/span&gt;{}{
    &lt;span&gt;&quot;convertFromURL&quot;&lt;/span&gt;: &lt;span&gt;convertFromURL&lt;/span&gt;(),
    &lt;span&gt;&quot;convertFromBlob&quot;&lt;/span&gt;: &lt;span&gt;convertFromBlob&lt;/span&gt;(),
  })
  &lt;span&gt;&amp;lt;-&lt;/span&gt;make(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;interacting-with-javascript-land&quot;&gt;Interacting with “JavaScript-land”&lt;/h3&gt;&lt;p&gt;To declare and interact with JavaScript in Golang runtime, developers rely on &lt;a href=&quot;https://pkg.go.dev/syscall/js&quot;&gt;&lt;code&gt;syscall/js&lt;/code&gt;&lt;/a&gt;. This package allows the application to create functions, read values from JS objects (DOM and non-DOM) and interface byte arrays with JS values (specifically: &lt;code&gt;UInt8Array&lt;/code&gt;). The only caveat is the following, been present since its release on Golang 1.11.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;This package is EXPERIMENTAL. Its current scope is only to allow tests to run, but not yet to provide a comprehensive API for users. It is exempt from the Go compatibility promise.&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Although it allows all sorts of interactions with JavaScript, in my limited experience with it, I would recommend developers to only use it to interface user inputs between Golang and the JavaScript runtime.&lt;/p&gt;&lt;p&gt;If you want to manipulate DOM or create elaborate objects through Golang, you might be in a world of pain. Not only there are no typing guarantees, but the tooling for those is just not there. ImageWand only uses it to gather user input to call &lt;code&gt;imagewand&lt;/code&gt; conversion functions, essentially a glue between the UI and Golang.&lt;/p&gt;&lt;p&gt;I’ve &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/main/jasm/wasm.go&quot;&gt;created an internal package (jasm)&lt;/a&gt; with a few helper functions to interface with JavaScript values. &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/main/cmd/wasm/main.go#L20-L48&quot;&gt;It made &lt;code&gt;wasm/main.go&lt;/code&gt; way cleaner&lt;/a&gt;, but certainly the most important of all is the &lt;code&gt;Await&lt;/code&gt; method.&lt;/p&gt;&lt;h3 id=&quot;golang-and-javascript-promises&quot;&gt;Golang and JavaScript promises&lt;/h3&gt;&lt;p&gt;JavaScript applications are single-threaded and leverage an event-loop strategy. Certain tasks might cause it to block, such as disk or network operations. JavaScript can schedule these operations by spinning processes off the event-loop, without blocking the main thread. A common way of doing&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises&quot;&gt; it is through Promises&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Golang HTTP calls are &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;using JavaScript’s &lt;code&gt;fetch&lt;/code&gt;&lt;/a&gt; under the hood, for example. This results in a blocking operation (network call), which needs to be handled properly. Using &lt;code&gt;net/http&lt;/code&gt; functions incorrectly will result in a runtime deadlock error. It is a common mistake, been even pointed out on the &lt;a href=&quot;https://pkg.go.dev/syscall/js#FuncOf&quot;&gt;&lt;code&gt;syscall/js.FuncOf&lt;/code&gt; documentation&lt;/a&gt;:&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Invoking the wrapped Go function from JavaScript will pause the event loop and spawn a new goroutine. Other wrapped functions which are triggered during a call from Go to JavaScript get executed on the same goroutine.&lt;/p&gt;&lt;p&gt;As a consequence, if one wrapped function blocks, JavaScript’s event loop is blocked until that function returns. &lt;strong&gt;Hence, calling any async JavaScript API, which requires the event loop, like fetch (http.Client), will cause an immediate deadlock. Therefore a blocking function should explicitly start a new goroutine.&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Starting goroutine solves event loop blocking. Image processing would definetely be a blocking operation and definitely be spun up in a goroutine. But, JavaScript doesn’t “understand” them, and the application needs to signal JavaScript runtime to wait for its results. The easiest way is to create a &lt;code&gt;Promise&lt;/code&gt; through &lt;code&gt;syscall/js&lt;/code&gt; and call &lt;code&gt;resolve()&lt;/code&gt; through the goroutine.&lt;/p&gt;&lt;p&gt;As it is a bit of a long piece of code, abstraction is vital. In ImageWand, this is dealt with through &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/main/jasm/wasm.go#L37-L57&quot;&gt;the jasm.Await function&lt;/a&gt;.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Await&lt;/span&gt;(&lt;span&gt;cb&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() (&lt;span&gt;js&lt;/span&gt;.&lt;span&gt;Value&lt;/span&gt;, &lt;span&gt;error&lt;/span&gt;)) &lt;span&gt;js&lt;/span&gt;.&lt;span&gt;Value&lt;/span&gt; {
  &lt;span&gt;handler&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;js&lt;/span&gt;.&lt;span&gt;FuncOf&lt;/span&gt;(&lt;span&gt;func&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt; &lt;span&gt;js&lt;/span&gt;.&lt;span&gt;Value&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt; []&lt;span&gt;js&lt;/span&gt;.&lt;span&gt;Value&lt;/span&gt;) &lt;span&gt;interface&lt;/span&gt;{} {
    &lt;span&gt;resolve&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;args&lt;/span&gt;[&lt;span&gt;0&lt;/span&gt;]
    &lt;span&gt;reject&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;args&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;]

    &lt;span&gt;// This would be the function I want to deal with
&lt;/span&gt;&lt;span/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() {
      &lt;span&gt;res&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;cb&lt;/span&gt;()
      &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
      &lt;span&gt;reject&lt;/span&gt;.&lt;span&gt;Invoke&lt;/span&gt;(&lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;err&lt;/span&gt;))
        &lt;span&gt;return&lt;/span&gt;
      }

      &lt;span&gt;resolve&lt;/span&gt;.&lt;span&gt;Invoke&lt;/span&gt;(&lt;span&gt;res&lt;/span&gt;)
    }()

    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;
  })

  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;promiseJS&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;handler&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This way, any blocking operation can be created as a promise by wrapping it through this. There is a pull request open at &lt;code&gt;golang/go&lt;/code&gt; &lt;a href=&quot;https://github.com/golang/go/pull/52581&quot;&gt;that implements a better version of this snippet&lt;/a&gt;, perhaps landing in a future version of Go.&lt;/p&gt;&lt;h2 id=&quot;optimisations&quot;&gt;Optimisations&lt;/h2&gt;&lt;p&gt;Once the proof of concept was up and running, there was a problem: binary size. At this point, building without any optimisation generated a 3.2Mb binary. Not ideal for mobile usage.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;GOOS&lt;span&gt;=&lt;/span&gt;js GOARCH&lt;span&gt;=&lt;/span&gt;wasm go build -o ./app/wasm/main-go.wasm ./cmd/wasm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first optimisation one can do is to disable the injection of debugging information on build time through &lt;code&gt;ldflags&lt;/code&gt;. For ImageWand, it reduced the binary to 3.1Mb (2%). Although quite low effort, it doesn’t help much.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;GOOS&lt;span&gt;=&lt;/span&gt;js GOARCH&lt;span&gt;=&lt;/span&gt;wasm go build -o ./app/wasm/main-go-optimal.wasm -ldflags&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;-s -w&quot;&lt;/span&gt; ./cmd/wasm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Tools like &lt;a href=&quot;https://rustwasm.github.io/twiggy/&quot;&gt;&lt;code&gt;twiggy&lt;/code&gt; can help analyse the binary size&lt;/a&gt; as well. There wasn’t much to tweak in this case, but I recommend giving it a try. The one that everyone recommends though, regardless of language, is &lt;code&gt;wasm-opt&lt;/code&gt; from the &lt;a href=&quot;https://webassembly.github.io/binaryen/&quot;&gt;&lt;code&gt;binaryen&lt;/code&gt; toolchain&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;It allows many optimisations, but it requires a bit of tweaking per-project basis. After playing around with it, the previous optimised binary with &lt;code&gt;-Oz&lt;/code&gt; produced the best results: a 2.9Mb binary, a 7% reduction compared to the original binary.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;wasm-opt -Oz -o ./app/wasm/main-go-optimal-binaryen.wasm ./app/wasm/main-go-optimal.wasm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;With Golang compiler, this is as far as I could go with optimisations. Even considering Gzip, it didn’t look great. It is not rare to find websites reaching 1Mb nowadays but, for such a simple project, 2.9Mb is unacceptable.&lt;/p&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./03-benchmark-go.png&quot; alt=&quot;Go binary sizes&quot;/&gt;&lt;/p&gt;&lt;center&gt;&lt;small&gt;Binary size per optimisation: no excessive gains, but still something&lt;/small&gt;&lt;/center&gt;&lt;h2 id=&quot;tinygo-a-better-compiler-for-wasm&quot;&gt;TinyGo: a better compiler for WASM?&lt;/h2&gt;&lt;p&gt;I heard about &lt;a href=&quot;https://tinygo.org/&quot;&gt;TinyGo&lt;/a&gt; sometime ago. With the slogan “A Go Compiler For Small Places” and a focus on embedded systems, I never got on the hype train. It is a subset of the Golang language, which means &lt;a href=&quot;https://tinygo.org/docs/reference/lang-support/&quot;&gt;there are some limitations&lt;/a&gt; and not all packages will work on it, even the &lt;a href=&quot;https://tinygo.org/docs/reference/lang-support/stdlib/&quot;&gt;ones in the standard library&lt;/a&gt;. This means it is not exactly a drop-in for all scenarios.&lt;/p&gt;&lt;p&gt;But, besides embedded systems, it seems to be a quite popular WASM compiler. The binaries produced, being a subset and focused on “small places”, are quite small. Taking into consideration the supported packages and limitations, it seemed a good candidate for ImageWand.&lt;/p&gt;&lt;h3 id=&quot;almost-a-drop-in-replacement&quot;&gt;Almost a drop-in replacement&lt;/h3&gt;&lt;p&gt;The first thing I tried was to compile the program using TinyGo, without any changes. It worked incredibly well, and the binary size dropped from ~3.2Mb to ~1.5Mb. Quite an improvement, especially when the WASM target is a web browser.&lt;/p&gt;&lt;p&gt;This was until I checked the console. Using &lt;code&gt;.String()&lt;/code&gt; to get values from &lt;code&gt;syscall/js.Value&lt;/code&gt; has not been implemented. Seemingly, ImageWand hit a TinyGo limitation and a hack around would be required.&lt;/p&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./04-tinygo-error.png&quot; alt=&quot;TinyGo error&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/tinygo-org/tinygo/issues/1140&quot;&gt;There are some hacks for it&lt;/a&gt;, but they all have some memory leak issues. As the surface between the program functionality and &lt;code&gt;syscall/js&lt;/code&gt; is quite limited, &lt;a href=&quot;https://github.com/brunoluiz/imagewand/commit/4860cb4c757c0ad859912047eb145798d47ff434&quot;&gt;changing those into &lt;code&gt;int&lt;/code&gt; seemed a better solution (without any caveat)&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Besides this, anyone attempting to move from Golang to TinyGo has to replace&lt;a href=&quot;https://github.com/tinygo-org/tinygo/blob/release/targets/wasm_exec.js&quot;&gt; &lt;code&gt;wasm_exec.js&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;https://tinygo.org/docs/guides/webassembly/#how-it-works&quot;&gt;According to the documentation&lt;/a&gt;, it is based on the Go’s one, but with a couple of changes that make it incompatible. Nothing major and super easy to tackle.&lt;/p&gt;&lt;p&gt;Once tweaked, ImageWand was successfully compiled using TinyGo, without any error messages in runtime and a binary twice the original size (1.5Mb). Smells like progress!&lt;/p&gt;&lt;h3 id=&quot;tinygo-after-optimisations&quot;&gt;TinyGo after optimisations&lt;/h3&gt;&lt;p&gt;Similar to Golang, the TinyGo compiler &lt;a href=&quot;https://tinygo.org/docs/reference/usage/important-options/&quot;&gt;allows tweaks&lt;/a&gt; according to project requirements. Considering this will be distributed on the web, optimisations related to size are important. Some might prefer performance tweaks, which are available as well.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot; data-lang=&quot;shell&quot;&gt;tinygo build -o app/wasm/main-tinygo-optimal.wasm -target wasm -no-debug -gc leaking ./cmd/wasm
wasm-opt -Oz -o ./app/wasm/main-tinygo-optimal-binaryen.wasm ./app/wasm/main-tinygo-optimal.wasm
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As in Golang though, &lt;code&gt;wasm-opt&lt;/code&gt; did not result in a massive gain, but it is still something.&lt;/p&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./05-benchmark-tinygo.png&quot; alt=&quot;TinyGo binary sizes&quot;/&gt;&lt;/p&gt;&lt;center&gt;&lt;small&gt;TinyGo binary size per optimisation: drastic improvements when applying optimisations&lt;/small&gt;&lt;/center&gt;&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;./06-benchmark-all.png&quot; alt=&quot;TinyGo + Go binary sizes&quot;/&gt;&lt;/p&gt;&lt;center&gt;&lt;small&gt;Full binary size comparison from Golang to Tinygo + optimisations&lt;/small&gt;&lt;/center&gt;&lt;p&gt;If your implementation is compatible with TinyGo and you don’t fall into an edge case, go for it! It provides plenty of features, and it seems a good choice in terms of binary size, especially considering web distribution.&lt;/p&gt;&lt;h3 id=&quot;wasi-interesting-but-not-mature-enough-on-tinygo&quot;&gt;WASI: interesting but not mature enough on TinyGo&lt;/h3&gt;&lt;p&gt;At this point, ImageWand was working and it was not a large binary: I could call it a day. But, there was still one thing that I wanted to try out: &lt;a href=&quot;https://github.com/bytecodealliance/wasmtime/blob/main/docs/WASI-overview.md&quot;&gt;WASI&lt;/a&gt;.&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;WASI stands for WebAssembly System Interface. It’s an API designed by the Wasmtime project that provides access to several operating-system-like features, including files and filesystems, Berkeley sockets, clocks, and random numbers, that we’ll be proposing for standardisation.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;It’s designed to be independent of browsers, so it doesn’t depend on Web APIs or JS, and isn’t limited by the need to be compatible with JS&lt;/strong&gt;. And it has integrated capability-based security, so it extends WebAssembly’s characteristic sandboxing to include I/O.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;small&gt;ℹ️ &lt;a href=&quot;https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/&quot;&gt;There is an interesting article from MDN&lt;/a&gt; about the subject – It is something I definitely want to dive deeper into in the future&lt;/small&gt;&lt;/p&gt;&lt;p&gt;ImageWand was relying on &lt;code&gt;syscall/js&lt;/code&gt; to interface with user input, which depends on JavaScript APIs, and it wouldn’t run in any other runtime besides the browser. Binaries compiled into the WASI standard though can be run anywhere that implements its specification: browser, terminal or within other backends (serverless function with NodeJS running Golang WASI bins). Yes, “Build once, run everywhere” &lt;del&gt;Java&lt;/del&gt; vibes.&lt;/p&gt;&lt;p&gt;TinyGo supports WASI. This means &lt;code&gt;syscall/js&lt;/code&gt; is not required if you don’t want to manipulate the DOM, which would have made ImageWand code simpler, becoming just an exported Golang function… But, there are a couple of limitations when implementing WASI programs with TinyGo:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://tinygo.org/docs/concepts/compiler-internals/calling-convention/#:~:text=The%20WebAssembly%20target%20does%20not%20return%20variables%20directly%20that%20cannot%20be%20handled%20by%20JavaScript%20(see%20above%20about%20i64%2C%20also%20struct%2C%20i64%2C%20multiple%20return%20values%2C%20etc).%20Instead%2C%20they%20are%20stored%20into%20a%20pointer%20passed%20as%20the%20first%20parameter%20by%20the%20caller.&quot;&gt;Function arguments and outputs can only be numbers or pointers, which are essentially numbers with a memory address&lt;/a&gt;.&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/tinygo-org/tinygo/issues/3010#issuecomment-1191916589&quot;&gt;There is no proper support for multi-return, so no easy &lt;code&gt;(someType, error)&lt;/code&gt;&lt;/a&gt; without some hacks.&lt;/li&gt;&lt;li&gt;Lacking documentation and helper methods to operate on top of shared WASM memory (&lt;a href=&quot;https://github.com/tinygo-org/tinygo/issues/3040&quot;&gt;I’ve opened a ticket around documentation&lt;/a&gt;).&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;ImageWand was passing a slice of &lt;code&gt;byte&lt;/code&gt; with the image content, which was the simplest way to get this working (don’t io.Reader me: it is not as simple). To pass the image input and receive the output in &lt;code&gt;[]byte&lt;/code&gt;, you need to use JavaScript and WASM shared memory space, pointers and all sort of low-level magic.&lt;/p&gt;&lt;p&gt;Checking Github, it seems many people came across the issue of passing non-numeric values or returning multiple values, and every developer has a different solution to it &lt;a href=&quot;https://github.com/tinygo-org/tinygo/issues/2512#issuecomment-1011399751&quot;&gt;[1]&lt;/a&gt; &lt;a href=&quot;https://github.com/tinygo-org/tinygo/issues/1824&quot;&gt;[2]&lt;/a&gt;.&lt;a href=&quot;https://github.com/brunoluiz/imagewand/pull/4&quot;&gt; Eventually, I came up with my way of dealing with this&lt;/a&gt;, but it is quite ugly and probably not efficient at all. Most likely I should have used &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Memory&quot;&gt;&lt;code&gt;WebAssembly.memory.buffer&lt;/code&gt;&lt;/a&gt;, but I couldn’t find an easy way of doing so. Besides, WASI was an extra in this whole experiment and, at this point, I had invested a long time cracking my head to have at least something minimal working.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;&lt;span&gt;// JavaScript code
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(&lt;span&gt;buf&lt;/span&gt;).&lt;span&gt;forEach&lt;/span&gt;((&lt;span&gt;b&lt;/span&gt;) =&amp;gt; &lt;span&gt;imagewand&lt;/span&gt;.&lt;span&gt;appendToBuffer&lt;/span&gt;(&lt;span&gt;b&lt;/span&gt;));
&lt;span&gt;await&lt;/span&gt; &lt;span&gt;imagewand&lt;/span&gt;.&lt;span&gt;convertFromBlob&lt;/span&gt;(&lt;span&gt;formatToNumber&lt;/span&gt;(&lt;span&gt;format&lt;/span&gt;));

&lt;span&gt;const&lt;/span&gt; &lt;span&gt;outputSize&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;imagewand&lt;/span&gt;.&lt;span&gt;getOutputSize&lt;/span&gt;();
&lt;span&gt;const&lt;/span&gt; &lt;span&gt;arrayBuffer&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Uint8Array&lt;/span&gt;(&lt;span&gt;outputSize&lt;/span&gt;);

&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;outputSize&lt;/span&gt;; &lt;span&gt;i&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;) {
  &lt;span&gt;arrayBuffer&lt;/span&gt;[&lt;span&gt;i&lt;/span&gt;] &lt;span&gt;=&lt;/span&gt; &lt;span&gt;imagewand&lt;/span&gt;.&lt;span&gt;getOutputAtPos&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;// Golang code
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;image&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;input&lt;/span&gt; &lt;span&gt;image&lt;/span&gt;;
&lt;span&gt;var&lt;/span&gt; &lt;span&gt;output&lt;/span&gt; &lt;span&gt;image&lt;/span&gt;;

&lt;span&gt;//export appendToBuffer
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;appendToBuffer&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;) {
  &lt;span&gt;input&lt;/span&gt; = append(&lt;span&gt;input&lt;/span&gt;, &lt;span&gt;i&lt;/span&gt;)
}

&lt;span&gt;//export getOutputSize
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getOutputSize&lt;/span&gt;() &lt;span&gt;int&lt;/span&gt; {
  &lt;span&gt;return&lt;/span&gt; len(&lt;span&gt;output&lt;/span&gt;)
}

&lt;span&gt;//export getOutputAtPos
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;getOutputAtPos&lt;/span&gt;(&lt;span&gt;i&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;byte&lt;/span&gt; {
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;output&lt;/span&gt;[&lt;span&gt;i&lt;/span&gt;]
}

&lt;span&gt;// Other stuff
&lt;/span&gt;&lt;span/&gt;
&lt;span&gt;//export convertFromBlob
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;convertFromBlob&lt;/span&gt;(&lt;span&gt;format&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) {
  &lt;span&gt;img&lt;/span&gt;, &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;imagewand&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;NewBuffer&lt;/span&gt;(&lt;span&gt;input&lt;/span&gt;))
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
    panic(&lt;span&gt;err&lt;/span&gt;)
  }

  &lt;span&gt;f&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;fileFormatFromInt&lt;/span&gt;[&lt;span&gt;format&lt;/span&gt;]
  &lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; {
    panic(&lt;span&gt;&quot;format not supported&quot;&lt;/span&gt;)
  }

  &lt;span&gt;b&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;NewBuffer&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;{})
  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;img&lt;/span&gt;.&lt;span&gt;Convert&lt;/span&gt;(&lt;span&gt;b&lt;/span&gt;, &lt;span&gt;f&lt;/span&gt;); &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
    panic(&lt;span&gt;err&lt;/span&gt;)
  }

  &lt;span&gt;output&lt;/span&gt; = &lt;span&gt;b&lt;/span&gt;.&lt;span&gt;Bytes&lt;/span&gt;()
  &lt;span&gt;input&lt;/span&gt; = []&lt;span&gt;byte&lt;/span&gt;{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;These limitations and lack of documentation around WASI, workarounds and common examples for TinyGo make it quite hard to abandon &lt;code&gt;syscall/js&lt;/code&gt; for browser apps or use it for non-JS WASM applications. Although I managed to make it work, I wouldn’t recommend someone to drop &lt;code&gt;syscall/js&lt;/code&gt; in favour of WASI TinyGo for browser applications at the moment, only if the person wants to deep dive and study its details. If you decide to do so, please help the community by adding examples, tutorials and documentation to the official project page.&lt;/p&gt;&lt;h2 id=&quot;conclusions-on-using-golang-with-wasm&quot;&gt;Conclusions on using Golang with WASM&lt;/h2&gt;&lt;p&gt;Being able to re-use and compile Golang code into WASM is exciting. Besides, for those used to Golang as their daily driver, it might be a natural choice when considering complex applications.&lt;/p&gt;&lt;p&gt;In general, I always recommend Golang due its tooling. But, for WASM, my experience was quite bumpy:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The final binary size using Golang toolchain (around 3.2Mb) might be OK for the backend but not for frontend apps. This adds up when considering network outbound costs or slow mobile connections.&lt;/li&gt;&lt;li&gt;TinyGo is an amazing alternative, but you might fall into edge-cases or unsupported features. This is quite an annoyance but, if you manage to get your way around it, it is probably the perfect choice for your Golang WASM project.&lt;/li&gt;&lt;li&gt;CI pipelines will get more complex as Golang/TinyGo tooling needs to be handled, and &lt;a href=&quot;https://github.com/brunoluiz/imagewand/blob/v1.0.0/.github/workflows/deploy.yaml&quot;&gt;extra build steps are required&lt;/a&gt;. Not that JavaScript toolchain is not complex by itself already.&lt;/li&gt;&lt;li&gt;The use of &lt;code&gt;syscall/js&lt;/code&gt; is quite cumbersome and unsafe, but mostly because of the JavaScript nature.&lt;/li&gt;&lt;li&gt;Dealing with DOM elements is possible, but changing UI elements is quite a painful and complex task. Try to limit its use only as glue.&lt;/li&gt;&lt;li&gt;Golang WASM is an independent and experimental port. &lt;a href=&quot;https://github.com/golang/go/issues/53383&quot;&gt;There are discussions on how to deal with such ports&lt;/a&gt;, but it is something to bear in mind. Besides, as it is still not a stable API, it might change at any point (although it never changed since its release).&lt;/li&gt;&lt;li&gt;WASI support is Golang does not exist at the moment, and TinyGo is not the most ergonomic in terms of WASI development, with a lack of documentation and examples. This can be mostly due to the WASI specification, as it is still in progress, but things like &lt;code&gt;wasm-bindgen&lt;/code&gt; for Rust prove that it could be somehow possible.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Would I choose Golang for a WASM project? If I had to develop something quickly or the people involved are used to Golang, definitely yes (TinyGo, to be fair). But I feel it is not the best choice in terms of features, documentation, toolchain and support. C/C++ and Rust seem to lead the way.&lt;/p&gt;&lt;p&gt;I never programmed with Rust before, but considering its support to WASM and some other interesting use cases I have in mind, it is perhaps a sign that I should finally try to learn it.&lt;/p&gt;&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://withblue.ink/2020/10/03/go-webassembly-http-requests-and-promises.html&quot;&gt;Go, WebAssembly, HTTP requests and Promises&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transferable_objects&quot;&gt;MDN: Transferable objects&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://qvault.io/golang/running-go-in-the-browser-wasm-web-workers/&quot;&gt;Running Go in the Browser with WASM and Web Workers&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.sitepen.com/blog/using-webassembly-with-web-workers&quot;&gt;Using WebAssembly with Web Workers&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://www.fermyon.com/blog/optimizing-tinygo-wasm&quot;&gt;Shrink Your TinyGo WebAssembly Modules by 60%&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://elewis.dev/are-we-wasm-yet-part-1&quot;&gt;Are We Wasm Yet ? - Part 1&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://elewis.dev/are-we-wasm-yet-part-2#heading-server-implementation&quot;&gt;Are We Wasm Yet ? - Part 2&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/&quot;&gt;Standardizing WASI: A system interface to run WebAssembly outside the web&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://wasi.dev/&quot;&gt;WASI&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://wasmbyexample.dev/examples/webassembly-linear-memory/webassembly-linear-memory.go.en-us.html#&quot;&gt;WebAssembly Linear Memory example&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>68ed88cd728129197dbdd3a42651ea12</guid>
<title>[新文导读] 深度解密钉钉即时消息服务DTIM的技术设计</title>
<link>https://toutiao.io/k/6ztt44k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;本文引用自InfoQ社区“5亿用户如何高效沟通？钉钉首次对外揭秘即时消息服务DTIM”一文，作者陈万红等、策划褚杏娟，即时通讯网有修订和改动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;一、引言&lt;/h2&gt;&lt;h1&gt;&lt;strong&gt;本文是国内企业IM的事实王者钉钉首次对外深度解密其即时消息服务（&lt;span&gt;即DingTalk IM，简称DTIM&lt;/span&gt;）的技术设计实践。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;本篇文章内容将从模型设计原理到具体的技术架构、最底层的存储模型到跨地域的单元化等，全方位展现了 DTIM 在实际生产应用中所遇到的各种技术挑战及相应的解决方案，希望借本文内容的分享能为国内企业级IM的开发带来思考和启发。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28134556574923547&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLyNtiaBdfAUTDHq64ItbxThe103LyTAUYnpyb1BYrUAoJ82JBp6o38vQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;654&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_cover-opti.jpg&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;ignore_js_op&gt;&lt;br/&gt;&lt;/ignore_js_op&gt;&lt;/p&gt;&lt;h2&gt;二、技术看点&lt;/h2&gt;&lt;h1&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;一、&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;/em&gt;系列文章&lt;/p&gt;&lt;p&gt;&lt;em&gt;三、&lt;/em&gt;钉钉的技术挑战&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;四、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;模型设计&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1、DTIM系统架构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2、消息收发链路&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3、存储模型设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.4、同步模型设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;五、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;消息存储设计&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;六、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;多端同步机制设计&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.1、概述&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.2、全量消息存储逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.3、消息多端同步逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.4、大量需同步离线消息的优化逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;七、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;高可用设计&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;八、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;本文小结&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;九、&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;相关文章&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;三、钉钉的技术挑战&lt;/h2&gt;&lt;h1&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLOPeKY6WUr6NxZ3oSmBicn73DcxPDloTKG8OGWbRtMicWGVOxP1FsunPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_0.jpg&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;钉钉已经有 2100 万 + 组织、5 亿 + 注册用户在使用。DTIM 为钉钉用户提供即时消息服务，用于组织内外的沟通，这些组织包括公司、政府、学校等，规模从几人到百万人不等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;DTIM 有着丰富的功能，单聊、各种类型的群聊、消息已读、文字表情、多端同步、动态卡片、专属安全和存储等等。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;同时：&lt;/strong&gt;&lt;span&gt;钉钉内部很多业务模块，比如文档、钉闪会、Teambition、音视频、考勤、审批等，每个业务都在使用 DTIM，用于实现业务流程通知、运营消息推送、业务信令下发等。每个业务模块对于 DTIM 调用的流量峰值模型各有差别，对可用性要求也不尽相同。&lt;/span&gt;&lt;strong&gt;DTIM 需要能够面对这些复杂的场景，保持良好的可用性和体验，同时兼顾性能与成本&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;通用的即时消息系统对消息发送的成功率、时延、到达率有很高的要求，企业 IM 由于 ToB 的特性，在数据安全可靠、系统可用性、多终端体验、开放定制等多个方面有着极致的要求。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;构建稳定高效的企业 IM 服务，DTIM 主要面临的挑战是：&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;企业 IM 极致的体验要求对于系统架构设计的挑战&lt;/span&gt;：比如数据长期保存可漫游、多端数据同步、动态消息等带来的数据存储效率和成本压力，多端数据同步带来的一致性问题等；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;极限场景冲击、依赖系统错误带来的可用性问题&lt;/span&gt;：比如超大群消息，突发疫情带来的线上办公和线上教学高并发流量，系统需要能够应对流量的冲击，保障高可用；同时在中间件普遍可用性不到 99.99% 的时候，DTIM 服务需要保障核心功能的 99.995% 的可用性；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;不断扩大的业务规模，对于系统部署架构的挑战&lt;/span&gt;：比如持续增长的用户规模，突发事件如席卷全球的疫情，单地域架构已经无法满足业务发展的要求。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;DTIM 在系统设计上：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;为了实现消息收发体验、性能和成本的平衡，设计了高效的读写扩散模型和同步服务，以及定制化的 NoSQL 存储；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;通过对 DTIM 服务流量的分析，对于大群消息、单账号大量的消息热点以及消息更新热点的场景进行了合并、削峰填谷等处理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;核心链路的应用中间件的依赖做容灾处理，实现了单一中间件失败不影响核心消息收发，保障基础的用户体验。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;在消息存储过程中，一旦出现存储系统写入异常，系统会回旋缓冲重做，并且在服务恢复时，数据能主动向端上同步。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;随着用户数不断增长，单一地域已无法承载 DTIM 的容量和容灾需求，&lt;/span&gt;&lt;strong&gt;DTIM 实现了异地多单元的云原生的弹性架构&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;在分层上遵从的原则为重云轻端：&lt;/strong&gt;&lt;span&gt;业务数据计算、存储、同步等复杂操作尽量后移到云端处理，客户端只做终态数据的接收、展示，通过降低客户端业务实现的复杂度，最大化地提升客户端迭代速度，让端上开发可以专注于提升用户的交互体验，所有的功能需求和系统架构都围绕着该原则做设计和扩展。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;以下章节我们将对 DTIM 做更加详细的介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;四、模型设计&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.1、DTIM系统架构&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;低延迟、高触达、高可用一直是 DTIM 设计的第一原则，依据这个原则在架构上 DTIM 将系统拆分为三个服务做能力的承载。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;三个服务分别是：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;消息服务&lt;/span&gt;：负责 IM 核心消息模型和开放 API，IM 基础能力包括消息发送、单聊关系维护、群组元信息管理、历史消息拉取、已读状态通知、IM 数据存储以及跨地域的流量转发；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;同步服务&lt;/span&gt;：负责用户消息数据以及状态数据的端到端同步，通过客户端到服务端长连接通道做实时的数据交互，当钉钉各类设备在线时 IM 及上游各业务通过同步服务做多端的数据同步，保障各端数据和体验一致；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;通知服务&lt;/span&gt;：负责用户第三方通道维护以及通知功能，当钉钉的自建通道无法将数据同步到端上时，通过三方提供的通知和透传能力做消息推送，保障钉钉消息的及时性和有效性。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;同步服务和通知服务除了服务于消息服务，也面向其他钉钉业务比如音视频、直播、Ding、文档等多端 (&lt;/span&gt;&lt;span&gt;多设备&lt;/span&gt;&lt;span&gt;) 数据同步。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图1：&lt;/strong&gt;&lt;span&gt;DTIM架构图 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9615384615384616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicL2QruwvFSMJ5Je2q4KL7eslkhFg2ic8y8haAa01TkypgBEok6gsPLyoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_1.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;上图展示了 DTIM 系统架构，接下来详细介绍消息收发链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.2、消息收发链路&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;图2：&lt;/strong&gt;&lt;span&gt;DTIM消息处理架构 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7259978425026968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLgRvjAT2bibic15victO7g45fAj0JJ4q41KtgZolGg2nu18bbOzFqmBGWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_2.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;消息发送：&lt;/strong&gt;&lt;span&gt;消息发送接口由 Receiver 提供，钉钉统一接入层将用户从客户端发送的消息请求转发到 Receiver 模块，Receiver 校验消息的合法性（&lt;/span&gt;&lt;span&gt;文字图片等安全审核、群禁言功能是否开启或者是否触发会话消息限流规则等&lt;/span&gt;&lt;span&gt;）以及成员关系的有效性（&lt;/span&gt;&lt;span&gt;单聊校验二者聊天、群聊校验发送者在群聊成员列表中&lt;/span&gt;&lt;span&gt;），校验通过后为该消息生成一个全局唯一的 MessageId 随消息体以及接收者列表打包成消息数据包投递给异步队列，由下游 Processor 处理。消息投递成功之后，Receiver 返回消息发送成功的回执给客户端。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;消息处理 ：&lt;/strong&gt;&lt;span&gt;Processor 消费到 IM 发送事件首先做按接收者的地域分布（&lt;/span&gt;&lt;span&gt;DTIM 支持跨域部署， Geography，Geo&lt;/span&gt;&lt;span&gt;）做消息事件分流，将本域用户的消息做本地存储入库（&lt;/span&gt;&lt;span&gt;消息体、接收者维度、已读状态、个人会话列表红点更新&lt;/span&gt;&lt;span&gt;），最后将消息体以及本域接收者列表打包为 IM 同步事件通过异步队列转发给同步服务。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;消息接收 ：&lt;/strong&gt;&lt;span&gt;同步服务按接收者维度写入各自的同步队列，同时查取当前用户设备在线状态，当用户在线时捞取队列中未同步的消息，通过接入层长连接推送到各端。当用户离线时，打包消息数据以及离线用户状态列表为 IM 通知事件，转发给通知服务的 PNS 模块，PNS 查询离线设备做三方厂商通道推送，至此一条消息的推送流程结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;4.3、存储模型设计&lt;/h2&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;了解 IM 服务最快的途径就是掌握它的存储模型。&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;业界主流 IM 服务对于消息、会话、会话与消息的组织关系虽然不尽相同，但是归纳起来主要是两种形式：写扩散读聚合、读扩散写聚合。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;所谓读写扩散其实是定义消息在群组会话中的存储形式。如下图所示。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图3：&lt;/strong&gt;&lt;span&gt;读模式和写模式 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39438085327783556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLo1bib1OM58x3u4WsEPWOMKFQYjcDlLWbHzAjH1qQLDfRNpB7TffPCFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;961&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_3.png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;如上图所示：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;读扩散的场景&lt;/span&gt;：消息归属于会话，对应到存储中相当于有张 conversation_message 的表存储着该会话产生的所有消息 (cid-&amp;gt;msgid-&amp;gt;message，cid 会话 ID、msgid 消息 ID、message 消息)，这样实现的好处是消息入库效率高，只存储会话与消息的绑定关系即可；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;写扩散的场景&lt;/span&gt;：会话产生的消息投递到类似于个人邮件的收件箱，即 message_inbox 表，存储个人的所有消息（uid-&amp;gt;msgid-&amp;gt;message， uid 用户 ID、msgid 消息 ID、message 消息），基于这种实现，会话中的每条消息面向不同的接收者可以呈现出不同状态。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;DTIM 对 IM 消息的及时性、前后端存储状态一致性要求异常严格，特别对于历史消息漫游的诉求十分强烈，当前业界 IM 产品对于消息长时间存储和客户端历史消息多端漫游都做得不尽如人意，主要是存储成本过高。因此在产品体验与投入成本之间需要找到一个平衡点。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;采用读扩散：&lt;/strong&gt;&lt;span&gt;在个性化的消息扩展及实现层面有很大的约束。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;采用写扩散带来的问题也很明显：&lt;/strong&gt;&lt;span&gt;一个群成员为 N 的会话一旦产生消息就会扩散 N 条消息记录，如果在消息发送和扩散量较少的场景，这样的实现相比于读扩散落地更为简单，存储成本也不是问题。但是 DTIM 会话活跃度超高，一条消息的平均扩散比可以达到 1：30，超大群又是企业 IM 最核心的沟通场景，如果采用完全写扩散所带来存储成本问题势必制约钉钉业务发展。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;所以，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在 DTIM 的存储实现上，钉钉采取了混合的方案，将读扩散和写扩散针对不同场景做了适配，最终在用户视角系统会做统一合并&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，如下图所示。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;图4：&lt;/strong&gt;&lt;span&gt;DTIM 读写混合模式 ▼&lt;/span&gt;&lt;br/&gt;&lt;ignore_js_op&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.612942612942613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/st3UArDtcvLZxFHfmicDjISxR3CTWdhicLrczaF55bcjtLJ2MTA7TUjYgiaNbcWcddicrG6sBxuAKhiaQkuwGPhs6BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot; title=&quot;阿里IM技术分享(八)：深度解密钉钉即时消息服务DTIM的技术设计_4.png&quot;/&gt;&lt;/ignore_js_op&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;作为读扩散、写扩散方案的混合形式存在，用户维度的消息分别从 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表中获取，在应用侧按消息发送时间做排序合并，&lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 表中记录了该会话面向所有群成员接收的普通消息 N（&lt;/span&gt;&lt;span&gt;Normal&lt;/span&gt;&lt;span&gt;），而 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表在以下两种场景下被写入：&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;第一种是：&lt;/strong&gt;&lt;span&gt;定向消息 P（&lt;/span&gt;&lt;span&gt;Private，私有消息&lt;/span&gt;&lt;span&gt;），群会话中发送的消息指定了接收者范围，那么会直接写入到接收者的 message_inbox 表中，比如红包的领取状态消息只能被红包发送者可见，那么这种消息即被定义为定向消息。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;第二种是：&lt;/strong&gt;&lt;span&gt;归属于会话消息的状态转换 NP（&lt;/span&gt;&lt;span&gt;Normal to Private，普通消息转私有消息&lt;/span&gt;&lt;span&gt;），当会话消息通过某种行为使得某些消息接收者的消息状态发生转换时，该状态会写入到 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表中，比如用户在接收侧删除了消息，那么消息的删除状态会写入到 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 中，在用户拉取时会通过 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 的删除状态将 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 中的消息做覆盖，最终用户拉取不到自己已删除的消息。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;当用户在客户端发起某个会话的历史消息漫游请求时，服务端根据用户上传的消息截止时间（&lt;/span&gt;&lt;span&gt;message_create_time&lt;/span&gt;&lt;span&gt;）分别从 &lt;/span&gt;&lt;span&gt;conversation_message&lt;/span&gt;&lt;span&gt; 表和 &lt;/span&gt;&lt;span&gt;message_inbox&lt;/span&gt;&lt;span&gt; 表拉取消息列表，在应用层做状态的合并，最终返回给用户合并之后的数据，N、P、NP 三种类型消息在消息个性化处理和存储成本之间取得了很好的平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;4.4、同步模型设计&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.4.1&lt;/span&gt;推送模型&lt;/h3&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;用户在会话中发出的消息和消息状态变更等事件是如何同步到端上呢？&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;业界关于消息的同步模型的实现方案大致有三种：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;客户端拉取方案；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;服务端推送方案；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;服务端推送位点之后客户端拉取的推拉结合方案。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;三种方案各有优劣，在此简短总结：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;首先&lt;/span&gt;：客户端拉取方案的优点是该方案实施简单、研发成本低，是传统的 B/S 架构。劣势是效率低下，拉取间隔控制权在客户端，对于 IM 这种实时的场景，很难设置一个有效的拉取间隔，间隔太短对服务端压力大，间隔太长时效性差；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;其次&lt;/span&gt;：服务端主动推送方案的优点是低延迟、能做到实时，最重要的主动权在服务端。劣势相对拉取方案，如何协调服务端和客户端的处理能力存在问题；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;最后&lt;/span&gt;：推拉结合这个方案整合了拉和推的优点，但是方案更复杂，同时会比推的方案多一次 RTT，特别是在移动网络的场景下，不得不面临功耗和推送成功率的问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;DTIM 相对传统 toC 的场景，有较明显的区别：&lt;/strong&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第一是对实时性的要求：&lt;/strong&gt;&lt;span&gt;在企业服务中，比如员工聊天消息、各种系统报警，又比如音视频中的共享画板，无不要求实时事件同步，因此需要一种低延时的同步方案。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第二是弱网接入的能力：&lt;/strong&gt;&lt;span&gt;在 DTIM 服务的对象中，上千万的企业组织涉及各行各业，从大城市 5G 的高速到偏远的山区弱网，都需要 DTIM 的消息能发送、能触达。对于复杂的网络环境，需要服务端能判断接入环境，并依据不同的环境条件调整同步数据的策略。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;strong&gt;第三是功耗可控成本可控：&lt;/strong&gt;&lt;span&gt;在 DTIM 的企业场景中，消息收发频率比传统的 IM 多出一个数量级，在这么大的消息收发场景怎么保障 DTIM 的功耗可控，特别是移动端的功耗可控，是 DTIM 必须面对的问题。在这种要求下，就需要 DTIM 尽量降低 IO 次数，并基于不同的消息优先级进行合并同步，既能要保障实时性不被破坏，又要做到低功耗。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;从以上三点可知，服务端主动推送的模型更适合 DTIM 场景：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;首先可以做到极低的延时，保障推送耗时在毫秒级别；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;其次是服务端能通过用户接入信息判断用户接入环境好坏，进行对应的分包优化，保障弱网链路下的成功率；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;最后是主动推送相对于推拉结合来说，可以降低一次 IO，对 DTIM 这种每分钟过亿消息服务来说，能极大的降低设备功耗，同时配合消息优先级合并包的优化，进一步降低端的功耗。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;虽说主动推送有诸多优势，但是客户端会离线，甚至客户端处理速度无法跟上服务端的速度，必然导致消息堆积。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;DTIM 为了协调服务端和客户端处理能力不一致的问题，支持 Rebase 的能力，当服务端消息堆积的条数达到一定阈值时触发 Rebase，客户端会从 DTIM 拉取最新的消息，同时服务端跳过这部分消息从最新的位点开始推送消息。DTIM 称这个同步模型为推优先模型（&lt;/span&gt;&lt;span&gt;Preferentially-Push Model，PPM&lt;/span&gt;&lt;span&gt;）。﻿&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;在基于 PPM 的推送方案下，为了保障消息的可靠达到，DTIM 还做一系列优化。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;这些优化具体是：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持消息可重入&lt;/span&gt;：服务端可能会针对某条消息做重复推送，客户端需要根据 msgId 做去重处理，避免端上消息重复展示。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持消息排序&lt;/span&gt;：服务端推送消息特别是群比较活跃的场景，某条消息由于推送链路或者端侧网络抖动，推送失败，而新的消息正常推送到端侧，如果端上不做消息排序的话，消息列表就会发生乱序，所以服务端会为每条消息分配一个时间戳，客户端每次进入消息列表就是根据时间戳做排序再投递给 UI 层做消息展示。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;&lt;span&gt;支持缺失数据回补&lt;/span&gt;：在某个极端情况下客户端群消息事件比群创建事件更早到达端上，此时端上没有群的基本信息消息也就无法展现，所以需要客户端主动向服务端拉取群信息同步到本地，再做消息的透出。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;4.4.2&lt;/span&gt;多端数据一致性&lt;/h3&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;多端数据一致性问题一直是多端同步最核心的问题，单个用户可以同时在 PC、Pad 以及 Mobile 登录，消息、会话红点等状态需要在多端保持一致，并且用户更换设备情况下消息可以做全量的回溯。﻿&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;基于上面的业务诉求以及系统层面面临的诸多挑战，钉钉自研了同步服务来解决一致性问题。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;strong&gt;钉钉的同步服务的设计理念和原则如下：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1）&lt;/strong&gt;&lt;/em&gt;统一消息模型抽象，对于 DTIM 服务产生的新消息以及已读事件、会话增删改、多端红点清除等事件统一抽象为同步服务的事件；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2）&lt;/strong&gt;&lt;/em&gt;同步服务不感知事件的类型以及数据序列化方式。同步服务为每个用户的事件分配一个自增的 ID（注：这里非连续递增），确保消息可以根据 ID 做遍历的有序查询；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;3）&lt;/strong&gt;&lt;/em&gt;统一同步队列，同步服务为每个用户分配了一个 FIFO 的队列存储，自增 id 和事件串行写入队列；当有事件推送时，服务端根据用户当前各端在线设备状态做增量变更，将增量事件推送到各端；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;4）&lt;/strong&gt;&lt;/em&gt;根据设备和网络质量的不同可以做多种分包推送策略，确保消息可以有序、可靠、高效的发送给客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;strong&gt;上面介绍了 DTIM 的存储模型以及同步模型的设计与思考：&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;h2&gt;五、相关资料&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[1]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 企业级IM王者——钉钉在后端架构上的过人之处&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-2848-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[2]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 现代IM系统中聊天消息的同步和存储方案探讨&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-1230-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[3]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 钉钉——基于IM技术的新一代企业OA平台的技术挑战(视频+PPT)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-527-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[4]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套亿级用户的IM架构技术干货(上篇)：整体架构、服务拆分等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3393-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[5]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套亿级用户的IM架构技术干货(下篇)：可靠性、有序性、弱网优化等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3445-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[6]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 从新手到专家：如何设计一套亿级消息量的分布式IM系统&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3472-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[7]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 企业微信的IM架构设计揭秘：消息模型、万人群、已读回执、消息撤回等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3631-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[8]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 全面揭秘亿级IM消息的可靠投递机制&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-3638-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[9]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套高可用、易伸缩、高并发的IM群聊、单聊架构方案设计实践&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-2015-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[10]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套海量在线用户的移动端IM架构设计实践分享(含详细图文)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-812-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;[11]&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 一套原创分布式即时通讯(IM)系统理论架构方案&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;http://www.52im.net/thread-151-1-1.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;六、全文链接&lt;/h2&gt;&lt;p&gt;&lt;span&gt;即时通讯网(52im.net)&lt;/span&gt;&lt;span&gt;&lt;span&gt;社区链接：&lt;/span&gt;&lt;span&gt;http://www.52im.net/thread-4012-1-1.html&lt;/span&gt;&lt;span&gt;，或点击下文的“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2db63b691ae0141504e170bab0516fce</guid>
<title>如何做好分布式任务调度——Scheduler 的一些探索</title>
<link>https://toutiao.io/k/jp5tr8p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-pluginname=&quot;mpprofile&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&quot; data-nickname=&quot;字节跳动技术团队&quot; data-alias=&quot;BytedanceTechBlog&quot; data-signature=&quot;字节跳动的技术实践分享&quot; data-from=&quot;2&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;动手点关注 干货不迷路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 👆&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;作者：张宇轩，章逸，曾丹&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初识 Scheduler&lt;/p&gt;&lt;/section&gt;&lt;h2&gt;找准定位：分布式任务调度平台&lt;/h2&gt;&lt;p&gt;&lt;span&gt;无论是互联网应用或者企业级应用，都充斥着大量的任务。我们常常需要一些任务调度系统帮助我们解决问题。随着微服务化架构的逐步演进，单体架构逐渐演变为分布式、微服务架构。在此的背景下，很多原先的单点式任务调度平台已经不能满足业务系统的需求。于是出现了一些基于分布式的任务调度平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheduler 是飞书内的分布式任务调度平台。分布式任务调度能力主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分布式：平台是分布式部署的，各个节点之间可以无状态和无限的水平扩展（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;保证可扩展）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任务调度：涉&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;及到任务状态管理、任务调度请求的发送与接收、具体任务的分配、任务的具体执行；（集群中哪些机器什么时候执行什么任务，所以又需要一个可以感知整个集群运行状态的配置中心）；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;配置中心：可以感知整个集群的状态、任务信息的注册。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;摸清脉络：Scheduler的结构和核心模块&lt;/h2&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;&lt;strong&gt;名词解释：&lt;/strong&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Processor: 编程处理器, 拥有一定的编程规范, 用户自定义实现。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Executor: 一个 SDK，运行 Processor 的进行容器，与 Scheduler 通信的载体。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Job：用户创建的任务，其中包含任务的调度规则、调度模型、执行器名称等信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Instance：运行态的Job，每当Job触发后会生成一个Instance，记录本次执行的调度信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Task：最小执行单元，不同调度模型的任务产生的Task数量不同。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.7116071428571429&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4sSGiaIXXWIYibdzfKibuy2boZI1K4gXF8DogCMg32ic7zeia7bu38fwOnEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过架构图可以发现，Scheduler主要有以下三个部分：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;调度器 (Scheduler)：任务调度中心，负责管理任务的生命周期。接受任务注册，准时准确找出待触发的任务，进行任务拆分下发。找出与之关联的执行器并下发对应任务；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;执行器 (Executor)：接收调度任务，并将自身状态上报给调度器；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;控制台 (Web 前端)：负责配置执行器的信息以及调度任务的配置、任务状态、信息展示。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;因此，我们可以用一句话解释清楚 Scheduler 所做的事情，即：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;在「指定时间」「通知执行器」以「指定方式」执行任务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这句话中包含了三个关键点，也分别代表着 Scheduler 的三个核心模块：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指定时间&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：任务的触发规则，如：每天早上8点、每周二、每月15号等。&lt;strong&gt;触发器模块&lt;/strong&gt;（Launcher Cron）负责任务触发；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;指定方式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：任务的执行形式，如：单播任务-指定一个机器执行；广播任务-指定所有机器执行；分片任务-任务分阶段分批的执行。&lt;strong&gt;分派器模块&lt;/strong&gt;（Assignment Cron）负责任务的执行方式；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;通知执行器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：将任务发送到指定执行器，执行任务。&lt;strong&gt;派遣器模块&lt;/strong&gt;（Dispatcher Cron）负责任务的发送，采用流式通信，调度器以&lt;strong&gt;推送&lt;/strong&gt;的方式将任务发送给执行器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;在一个Job的调度周期中，各个模块各司其职，整个流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.209375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4A59zI8eK454p5icQjusOLRykMWwGiah7PwmDn98liaicicJx6ibYuKWhnzWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;拥有这三个核心模块后，Scheduler 已具备了成熟的任务调度功能。另外，为了增加 Scheduler 的稳定性，有额外两个模块为其保驾护航：&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;健康管理模块&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; (Service Health Cron): 负责管理 Job 的生命周期，检测未正常派发执行的 Job、Instance 和 Task，并将结果上报给运维人员。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;任务进度刷新模块&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt; (Task Cron): 异步更新 Task 状态，流量较高时进行削峰，保证依赖的 mysql 及 redis 不因为流量过高而出现问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;本篇文章不对 Scheduler 所支持的定时任务能力作赘述，而是从三个方面（&lt;strong&gt;易用性、多功能性、稳定性&lt;/strong&gt;）介绍 Scheduler 对于分布式任务调度的思考和探索：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「易用性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 决定了用户是否选择使用该框架的意愿，一个好的框架必须是易用且快速接入的；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「多功能性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 接入方需求多种多样，要站在用户角度想问题，不能闭门造车；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;「稳定性」&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;: 对于分布式任务调度平台来说，不仅仅局限于自身的稳定性，接入方的稳定性也十分重要。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1&gt;换位思考-快速接入&lt;/h1&gt;&lt;h2&gt;背景：效率至上，时间是金&lt;/h2&gt;&lt;p&gt;&lt;span&gt;以字节跳动内部为例，当前团队想要实现一个定时任务有多种方式：接入字节云的 cronjob 平台、自己实现一套定时任务框架或者接入第三方定时任务框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第一种接入 cronjob 平台，每一种定时任务都需要注册各自的 psm 和运行时环境（镜像），当任务需要访问依赖资源如 redis/db 等时，需要各自添加授权。任务代码逻辑有变化时也需要各自升级，导致开发、管理起来较为复杂。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于第二种自己实现一套定时任务框架，不仅整体开发时间较长，且需要大量时间进行测试回归来保证框架的稳定性。如果项目内使用到的定时任务较多，那么自身研发一套框架用途也较广泛；若项目中使用到的定时任务较少，则 ROI 较低，很多时候也只是为了造轮子而造轮子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，大多数项目面对增加定时任务的需求时，都会寻求直接接入第三方成熟的定时任务框架。对于他们来说，是否易于接入、与现有代码联系是否紧密、调试是否方便是很重要的选取指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于这种背景，Scheduler 在设计时就站在了接入方的角度，思考了如何让接入方能够在最短时间内以最低成本接入 Scheduler，实现自己的定时任务。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：站在用户角度想问题&lt;/h2&gt;&lt;p&gt;&lt;span&gt;站在接入方角度，对定时任务框架进行选型时最关注的几个点无非是定时任务执行准确性、最高支持 qps、定时设置多样性、接入成本这几个。对于前两个指标，Scheduler 目前接入业务方 50+，日均调度任务 20w+ 次，与公司内其他第三方定时任务框架相比也较有竞争性，同时对于后两个关注点，Scheduler 也有自己的风格。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;丰富的调度设置&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一般的定时任务框架只支持 crontab 表达式，例如 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;0 1 * * *&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; ，代表每天凌晨一点执行一次。cronTab 功能强大，但是若配置复杂的定时策略，有一定学习成本，且可读性不高。因此，鉴于这种情况，Scheduler 在 crontab 之上设计了更易读更强大的定时策略，做到所见即所得。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;startTime&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1648029600000&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;timeZone&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatLevel&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;month&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatInterval&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;repeatDays&quot;&lt;/span&gt;:[&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;23&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;start_time: 开始时间戳，在此之前定时任务不会执行，到达该时间后会执行第一次&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;timeZone: 时区设置，根据当前设置的时区准确派发&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatLevel: 重复级别，目前可以设置按「小时」、「天」、「月」、「周」、「年」以及「工作日」进行重复&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatInterval: 重复间隔，代表每隔 $repertInterval $repeatLevel 执行一次&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;repeatDays: 重复天数，重复级别是周或月时生效&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因此，该设置所代表的定时间隔为：&lt;strong&gt;每两月的3、5、23号触发一次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;table data-ace-table-col-widths=&quot;178&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;&lt;strong&gt;触发时间（北京时间）&lt;/strong&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-03-23 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-03 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-05 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;p&gt;2022-05-23 18:00:00&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;span&gt;为什么要做工作日调度&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;可能有同学注意到，Scheduler 对于重复级别的支持十分丰富，不仅可以按照普通的年、月、日等级别进行设置，还可以按照工作日进行重复调度（例如每两个工作日执行一次），这归因在 Scheduler 孵化于字节跳动内部企业服务系统，为诸如人事系统、权限系统等 ToB 服务提供定时任务能力。往往 ToB 客户的需求复杂多变，因此，需要提前具备更多能力，才能更好地服务好 ToB 客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Scheduler 在调研接入方需求时，得到了有些客户对于定时提醒这类任务的需求是尽量不要在「非工作日」打扰。于是，Scheduler 决定增加工作日调度选项来适配客户潜在需求，也侧面说明了 Scheduler 为了让接入方更快更小成本接入做出的努力。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;轻松的使用方式&lt;/h2&gt;&lt;p&gt;&lt;span&gt;相信「开箱即用」对于人们在采买诸如家电、数码产品时，是十分重要的一个考核指标。而对于对外提供的服务 or 框架，亦是如此。Scheduler 的目标就是让接入方能够在短时间熟悉 Scheduler、编写测试代码以及上线定时任务。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;专注业务&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;如果想实现一个定时任务，接入方只需要三步：引入 Scheduler sdk，绑定相应 processor，在 process 接口中实现具体业务逻辑。同时，由于定时任务的实现位于原代码中，启动配置无需更改，本地测试也较为便捷。同时，在字节跳动环境下，无需新增 psm、授权配置等，尽可能做到了「开箱即用」。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;code.byted.org/apaas/scheduler_sdk/executor&quot;&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    executorSvc, err := executor.NewExecutor(executor.NewDefaultExecutorConfig(), &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &amp;amp;HelloWorld{}) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err = executorSvc.Run(); err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; HelloWorld &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ProcessorApiName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(h *HelloWorld)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GetApiName&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; h.ProcessorApiName&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(h *HelloWorld)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SimpleProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc *executor.TaskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(err error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   tc.LogInfo(ctx, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hello world&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;快速运维&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;没有程序员想主动写出 bug，但问题总是会突然出现。如何在出现问题时快速运维、快速止损，是所有工程师都追求的目标。Scheduler 在这方面做了几种尝试：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;报警更直观&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用户可以在创建 job 时，可以选择配置报警机器人，并把 Scheduler 机器人拉入对应报警群组。当检测到对应 job 出现问题时，Scheduler 机器人会把相应报警推送到对应群组，做到实时响应。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;状态更清晰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;目前 task 的相关状态如下，当一个 task 长期没有到终态时，根据状态码即可知 task 目前处于什么状&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;态，从而推断是哪一步骤出了问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;状态码&amp;quot;&quot;&gt;状态码&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;状态&amp;quot;&quot;&gt;状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;100&quot;&gt;100&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;等待触发&amp;quot;&quot;&gt;等待触发&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;101&quot;&gt;101&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Ready 就绪态，等待推送&amp;quot;&quot;&gt;Ready 就绪态，等待推送&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;201&quot;&gt;201&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;推送到 Executor，还未实际执行（任务太多排队）&amp;quot;&quot;&gt;推送到 Executor，还未实际执行（任务太多排队）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;202&quot;&gt;202&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行中&amp;quot;&quot;&gt;执行中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;203&quot;&gt;203&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行超时，逻辑复杂导致&amp;quot;&quot;&gt;执行超时，逻辑复杂导致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;301&quot;&gt;301&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行成功&amp;quot;&quot;&gt;执行成功&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;302&quot;&gt;302&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行失败&amp;quot;&quot;&gt;执行失败&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;401&quot;&gt;401&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Ready 超时，没有 Executor 拉取&amp;quot;&quot;&gt;Ready 超时，没有 Executor 拉取&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;402&quot;&gt;402&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;推送到 Executor 后长期未执行 &amp;quot;&quot;&gt;推送到 Executor 后长期未执行&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;403&quot;&gt;403&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;执行超时，Executor 宕机导致&amp;quot;&quot;&gt;执行超时，Executor 宕机导致&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;并且一些 Scheduler 常见的报错也做了封装，帮助快速定位问题，例如&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;错误码&amp;quot;&quot;&gt;错误码&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;错误原因&amp;quot;&quot;&gt;错误原因&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_000004&amp;quot;&quot;&gt;k_sc_ec_000004&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到任务{{.jobApiName}}&amp;quot;&quot;&gt;找不到任务{{.jobApiName}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_100004&amp;quot;&quot;&gt;k_sc_ec_100004&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到任务实例{{.instanceID}}&amp;quot;&quot;&gt;找不到任务实例{{.instanceID}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_300001&amp;quot;&quot;&gt;k_sc_ec_300001&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;Processor Name 未注册{{.content}}&amp;quot;&quot;&gt;Processor Name 未注册{{.content}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_300006&amp;quot;&quot;&gt;k_sc_ec_300006&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;processor({{.content}}) 找不到对应 executor&amp;quot;&quot;&gt;processor({{.content}}) 找不到对应 executor&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_400002&amp;quot;&quot;&gt;k_sc_ec_400002&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;找不到Executor {{.content}}&amp;quot;&quot;&gt;找不到Executor {{.content}}&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-sheet-value=&quot;&amp;quot;k_sc_ec_400005&amp;quot;&quot;&gt;k_sc_ec_400005&lt;/td&gt;&lt;td data-sheet-value=&quot;&amp;quot;无权限操作&amp;quot;&quot;&gt;无权限操作&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h1&gt;并肩作战-分片任务&lt;/h1&gt;&lt;h2&gt;背景：任务越多，挑战越大&lt;/h2&gt;&lt;p&gt;&lt;span&gt;一个成熟的项目中避免不了大型批量任务，比如通过 Excel、csv 或其他数据源批量创建或更新数据，批量任务一般数据量很大，如果按照单实例串行执行，那么不能充分利用计算机资源且一次运行会消费大量时间，用户体验不友好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以 Kunlun 举例， 旧阶段的批量任务依赖于消息队列、Redis 实现，总体分为三大部分：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;解析并校验Excel，将数据解析成一条条数据，将每条消息封装成一条消息发送至消息队列；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消费消息队列，进行创建、更新等操作，并在Redis记录总体进度并推送给用户，如果任务失败，会将行数和错误原因同时记录进redis；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;待所有数据处理结束后，如果redis中没有错误数据，则提示用户成功，否则根据错误信息生成Excel返回给用户。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;271&quot; data-backw=&quot;525&quot; data-ratio=&quot;0.5167394468704513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4Q5AERM5D3txQMnMrMMiasnJJcoeQYK4tE2vdhW3X6z0TvnN6KPEzdaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;687&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;使用消息队列、redis的定时任务可以提速和优化用户体验，但有以下不足：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;维护起来不方便，例如当有新服务需要此类功能时，需要自己再实现一套差不多的框架，所以需要将分片功能托管到第三方服务，而业务方只用专注于具体业务；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;依赖于消息队列和Redis两个外部组件，对两个组件的稳定性要求极高，当其中一个出现问题，都会带来不小的麻烦。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;基于这种背景，Scheduler 丰富了原本的任务调度能力，补充了分片能力，以满足复杂繁琐的任务分片处理的需求。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：旧问题，新解法&lt;/h2&gt;&lt;p&gt;&lt;span&gt;若打算做出一套贴合业务需求的分片任务框架，需要先了解现阶段的分片任务的实现步骤。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现阶段的分片任务大致可以抽象成3个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。获取数据，可以从上传的文件解析数据、从 DB 查询出大批数据或其他数据源。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。处理数据，聚焦于具体业务，如：创建、查询、更新。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。处理结果，将此次任务运行结果处理成结果报告返回给用户，报告可以为 Excel、一条消息、一封邮件等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;Scheduler 要做的事情则是替换其中分片、消息队列、Redis 的功能，做出以下抽象：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; ShardingProcessor &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   PreProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ShardingProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   Notify(ctx context.Context, tc *TaskContext)error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   PostProcess(ctx context.Context, tc *TaskContext) error&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PreProcess(总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：数据准备阶段。可在此方法中对数据进行额外处理，如计算拓扑关系，定义数据优先级。单机运行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ShardingProcess(分)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：分片处理阶段。实际处理函数，多机运行。分片处理函数，执行批量导入、更新等处理。（&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;入参：Scheduler 对 PreProcess 返回结果的分片子参数）&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Notify(阶段式-总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：进度更新处理，每当进度变更的大小大于设定阈值，则生成一次 Notify 的Task。Executor 向 Scheduler 汇报子任务进度，Scheduler 计算出总体进度，当总进度发生变更后生成 NotifyTask 通知 Executor 进行处理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;PostProcess(总)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;：结果处理阶段。任务执行完毕后可在此函数进行后续处理，单机运行。当所有分片子任务都执行完后，Scheduler 会将子任务的执行结果发送到此函数处理。（&lt;strong&gt;入参：每一个子任务 ShardingProcess 后的结果数组）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;执行器需要实现ShardingProcessor接口以供调度器进行调度。调度过程如下：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;316&quot; data-backw=&quot;514&quot; data-ratio=&quot;0.614065180102916&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4icUAJ5LBx7RKYjgouRiby19HDMdvS7hV5EZq0SKeHKialepAmHZ64DiaoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;583&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Scheduler 支持分片任务重点在于丰富调度模型，提升调度器调度能力，完善执行器执行能力来达到支持分片任务的目的&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;调度侧能力&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;分批调度的能力&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;调度侧需要根据任务进度依次生成 PreTask、ProcessTask、NotifyTask、PostTask 来调度执行器 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ShardingProcessor&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 中的 PreProcess - Process - Notify - PostProcess 四个方法。单机调度 PreProcess，PostProcess，Notify，并行调度 PostProcess，总体调度呈现总-分-总的形式。调度过程如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4NwkHW1Fv8Uy7nvQoLtGWWyqIm1NGQzRIU7HhZoB8sicw5YXiaRThwkBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;数据拆分的能力&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;数据拆分即任务分片，指的是将单一任务按照特定的逻辑切分为多个&lt;strong&gt;独立的&lt;/strong&gt;子任务，将其分派到不同的节点执行，以提高任务的执行效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而 Scheduler 要处理的任务内部可能存在&lt;strong&gt;依赖关系&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;（比如 kunlun 业务中 metadata 批量创建的需求，由于存在 lookup 和 reference 字段等，记录创建之间存在拓扑关系）&lt;/span&gt;&lt;span&gt;，所以在执行时需要&lt;strong&gt;优先级&lt;/strong&gt;的概念，而不能被简单拆分为&lt;strong&gt;独立&lt;/strong&gt;的子任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了支持带优先级的任务分片，Scheduler 接收的分片任务的数据特点如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二维数组可以是下面这样：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;，可以是主键&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;101&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;，可以是SQL语句&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Insert into tablename xxx&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第一优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;，可以是结构体等等...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;ID&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;999&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;Name&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;zhangsan&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        // 第二优先级的任务&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;、&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;、...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;102&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__number&quot;&gt;103&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;了解了待分片任务的结构，我们来讨论如何对任务进行分片。比如，分片的数量由什么决定，单个分片上的信息是如何分配的，不同分片又是不同分派到不同的处理器上的...&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片数的确定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片数的确定基于以下参数的值：&lt;strong&gt;数据量&lt;/strong&gt;、任务创建时用户指定的&lt;strong&gt;单片最大数量、单片最小数量&lt;/strong&gt;，以及实际可用的&lt;strong&gt;执行器数量&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;算法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片特征值（sharding key）的选择要遵循的原则应该是&lt;strong&gt;基于最常用的访问方式&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于 Scheduler 分片时并不关心业务数据的结构，所以选用&lt;strong&gt;数据数组的下标&lt;/strong&gt;来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;作为分片特征值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;由于分片数量确定后，不涉及到由于分片的增加或减少对数据进行 Rehash 的情况，所以无需考虑虚拟节点、一致性哈希等方式进行分片。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这里选用哈希分片的分片算法，原因是既可以均匀分布数据，实现起来也很简单。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分片的存储和派发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;分片完成后，需要给每个分片创建一个 Task，并把分片的数据存储下来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;关于 Task 的派发，根据上面关于分片数的讨论，可以得到分片数和 Executor 数的关系：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在数据量合适的情况下（单片最大数量和单片最小数量设置合理时，是最普遍的情况），分片数和Executor 的数目是一致的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当数据量很小时，会出现分片数小于 Executor 数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当数据量很大时，会出现分片数大于 Executor 数，甚至可能是后者的几倍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;为了让各个 Task / 各个分片 能够均匀派发给各个 Executor，也为了避免某个executor挂掉时，其他Executor 不能均匀分摊挂掉的节点原先承担的分片，需要采用合理的分片策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分片时，我们保证了各分片的数据是尽量均匀分布的，所以从分片到 Executor 的分派方式可以尽可能地简单，采用平均分配的策略即可。对于挂掉的节点所承担的分片，也采用同样的策略派发到存活的 Executors 上即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如:&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;有3个 Executor，分成9片，则每个 Executor 分到的分片是: &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1=[0,1,2], 2=[3,4,5], 3=[6,7,8]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果Executor 1挂掉，则将1的分片&lt;em&gt;平均分配*&lt;/em&gt; 到Executor 2、3: &lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2=[0,1,3,4,5], 3=[2,6,7,8]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;&lt;strong&gt;平均分配*&lt;/strong&gt;：对于不能均分的情况，为了避免靠前的 Executor 总是承担更多的压力，可以根据待分配分片数量的奇偶来决定是升序分派还是降序分派。&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;&lt;span&gt;进度通知的能力&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Scheduler 支持通知 Executor 任务执行的整体进度&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Executor 上报子任务进度至 Scheduler；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Scheduler 计算总任务进度；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;总任务进度发生变化，则生成 NotifyTask 发送至 Executor。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3936651583710407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4n9hTBcxHUJMR06QpDiaiaQQIbAeyB2zKuJ8Zk6m0Qd8K1iavp4Fibf27rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot;/&gt;&lt;/section&gt;&lt;h2&gt;执行侧分批执行的能力&lt;/h2&gt;&lt;p&gt;&lt;span&gt;执行侧需要实现并注册 SDK 提供的ShardingProcessor接口，来处理由调度侧发来的多种类型的Task。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PreProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;预处理方法，可以进行但不限于以下的操作：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;启动参数不符合 Scheduler 规定格式，可以通过 PreProcess 方法进行一次转换；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据存在导入优先级，可以在 PreProcess 中编写计算拓扑关系的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-type=&quot;quote_container&quot;&gt;&lt;p&gt;如果不需要预处理，可直接在方法内 return，分片时数据使用启动时的 Data&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;func&lt;/span&gt; (&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;s&lt;/span&gt; *&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ShardingProcessor&lt;/span&gt;) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PreProcess&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ctx&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.Context&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tc&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;taskContext&lt;/span&gt;) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;error&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attribute&quot;&gt;oldData &lt;/span&gt;:= tc.&lt;span class=&quot;code-snippet__built_in&quot;&gt;GetData&lt;/span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 用户业务, 数据处理&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    newData := &lt;span class=&quot;code-snippet__built_in&quot;&gt;Transform&lt;/span&gt;(oldData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // 返回带拓扑排序的数据&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tc.&lt;span class=&quot;code-snippet__built_in&quot;&gt;SetResult&lt;/span&gt;(newData)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return nil&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ShardingProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分片处理函数，主要是进行数据更新、创建操作。ShardingProcess 的入参是切分后的数组（&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;[]interface{}&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;）。Executor 需要对参数进行两部分额外处理：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;将 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;[]interface{} &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;中的 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;interface{} &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;断言成具体 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;struct{}&lt;/strong&gt;&lt;span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;处理后。计算当前子任务执行进度，进行上报；如果省略上报，服务端以分片粒度生成 NotifyTask通知执行器。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *ShardingProcessor)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ShardingProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc taskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   taskData := tc.GetData()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, data := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; taskData{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   tc.SetResult(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;PostProcess&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接受所有分片处理结果，进行后续处理，如生成错误文件。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;false&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(s *ShardingProcessor)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;PostProcess&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(ctx context.Context, tc taskContext)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    taskData := tc.GetData()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, result := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; taskData{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tc.SetResult(...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Notify&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提供给子任务上报的能力，Scheduler 会根据所有子任务上报结果计算进度，通知 Executor，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;通知粒度为数据条数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。如果接入方不主动上报子任务进度，Scheduler 会根据子任务完成度进行通知，&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;通知粒度为分片粒度&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分片任务流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.2342342342342343&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4crI1FmJdqIhxe9Dod49EtUH6R3mJibzaJ9vaGYmZ5b8T2Tl7Ycz6oKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;444&quot;/&gt;&lt;/p&gt;&lt;h1&gt;削峰填谷-流量控制&lt;/h1&gt;&lt;h2&gt;背景：提供能力，而非施加压力&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在 Scheduler 设计初期时，更多的是把注意力放在了如何能够快速、准确、低延迟的触发任务，为此还多次优化了触发器、分派器、派遣器三大模块的轮询逻辑，但是忽略了任务量过大时下游能否抗住流量的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 Scheduler 在调度时无法准确感知下游压力，那么很容易将下游打挂，如：在定时任务首次上线时，因为 kunlun 的装包机制导致数千个应用下配置了同样的定时任务，虽然一个包内的数十个定时任务触发时间分散，但是应用包之间的同一个任务触发时间相同，导致下游需要在同一时刻处理数千个任务，再加上任务的处理流程还会通过消息中间件进行扩散，导致数据库在任务执行阶段一直处理低IDLE 阶段。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;分析：流量追踪，剥茧抽丝&lt;/h2&gt;&lt;section&gt;&lt;span&gt;目前大部分后端服务，通过分析任务的流量走向，可以大致确认每一条任务在执行过程中不论扩散还是非扩散流量都会走向DB，流量图大致如图。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24676850763807284&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv44TBZibG6RLeqgp1jF1u85r9gq99LEKlibxVxticyD0xX7MQtPJABx4NvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;851&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任务的流量最终打到了 DB，所以流量控制的目标就更加清晰：对 DB 的流量控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要对 DB 进行流量控制，那么就要设定合理的指标，理论上，只要指标采纳的足够合理，就能严格、准确的控制流量，指标则需要具备以下条件：&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;实时性。能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;准时&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;反应数据库健康状况；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;权威性。能够&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;准确&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;反应数据库健康状况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;优先级：实时性 &amp;gt; 权威性。当一个指标的实时性不够高，那么它的权威性就不再有价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只需要实时监听着 DB 的指标，来判断任务是立刻执行，还是延迟执行就能有效的保护 DB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指标选择&lt;/span&gt;&lt;/p&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;消费 metrics 的监控点，关于数据库的打点信息非常全面，能够非常轻易的获取到数据库宿主机的CPU、内存或数据库本身的连接数、查询数等指标，这些指标的权威性毋庸置疑，但是 metrics 通过将指标收集到本地代理，代理每 30s 做一次聚合发送至服务端，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;其时效性太差&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;数据库不可用因素为：大量任务触发 -&amp;gt; DB 访问流量增高 -&amp;gt; CPU idle 降低 -&amp;gt; 数据库不可用。造成 CPU idle 降低的因素为 DB 流量增高，可以将 DB 的流量作为指标进行流量控制，缺点是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;需要自己采集指标&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;指标收集&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;指标范围&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;反映 DB 压力较为直接的指标是 cpu idle，但考虑到服务部署往往多实例以及 cpu idle 采集难度大的情况，以近似指标来代替。另一方面，通过历史数据分析，DB 流量与 cpu idle 有一定的关联，因此以 DB 流量作为 DB 压力指标。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;1286&quot; data-ratio=&quot;0.7485448195576252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4icDib3SOiaLpgJanDcpEFWuGosmEoCcQI0ib4IqibeL09iaq0spcnIY4l1ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1718&quot; data-width=&quot;1718&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据存储&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;参考限流的实现方案，采用单独的 Redis 存储流量数据，以 1s 为时间窗口作为 Redis key，每个时间窗口的流量作为 Redis value，每次发生 DB 操作时更新流量数据。系统中存在多个 DB，每个 DB 单独统计，在 Redis key 中加入db信息。Redis key 设置10s过期时间，查询时根据过去3个窗口的加权平均（80%/15%/5%）作为当前流量，以处理窗口交界处的突发流量。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;收集方式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;目前 DB 流量已有 metrics 监控数据，但由于 metrics 会在本地聚合 30s 数据后上报，至少会有 30s的延迟。而造成 DB 压力大的定时任务多为短期集中触发，使用 metrics 数据会有感知不及时的问题，因此需要额外收集数据。参考 DB metrics 数据采集的方式，通过 Gorm 的 callback 机制插入具体的采集逻辑，减少对业务代码的侵入。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;SetMonitorCallBack&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(db *gorm.DB)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   db.Callback().Create().Before(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gorm:before_create&quot;&lt;/span&gt;).Register(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric:before_create&quot;&lt;/span&gt;, beforeCreateCallback)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   db.Callback().Delete().Before(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gorm:before_delete&quot;&lt;/span&gt;).Register(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;metric:before_delete&quot;&lt;/span&gt;, beforeDeleteCallback)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCreateCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    beforeCallback(scope, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;create&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope, method &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;在采集逻辑上，需要考虑以下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code data-wrap=&quot;true&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; MetricType &lt;span class=&quot;code-snippet__keyword&quot;&gt;int8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  QueryCount MetricType = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; DBMetric &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DBName   &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DBMethod &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Type MetricType&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timestamp &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value     &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;beforeCallback&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(scope *gorm.Scope, method &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dbName := getStringValueFromCtx(scope.DB().Ctx, CtxVariableDBName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    curMs := time.Now().UnixNano()/&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(time.Millisecond)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    metric := DBMetric{dbName, method, QueryCount, curMs, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; ch &amp;lt;- metric:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;metricAgent&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    windowSize := &lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    aggrMetrics := &lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;]&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]DBMetric&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer := time.NewTicker(windowSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       timer.Stop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; msg := &amp;lt;-ch:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           curWindow := curMs/windowSize&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           更新aggrMetrics中curWindow对应的metric（对queryCount来说是加&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-timer.C:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           将aggrMetrics中key+windowSize&amp;lt;=curTime的数据上报并清除&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运维成本：采集逻辑会运行在各个服务上，考虑到后续会收集更多的指标，直接上报 Redis 需要给各个服务开通读写权限，运维管理成本较高。基于此，使用额外的服务来管理指标数据，接收上报的指标数据存入 Redis，并通过接口的方式提供查询服务。指标存放在更加聚焦在DB资源的resource 服务中，在 resource 服务中通过增加接口的方式实现指标数据的管理功能，同时，为了不影响 resource 原有业务的稳定性，使用单独的集群提供服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8130563798219584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4kOfmWjv1vpJJGG03BYUjTNV1U1zU6feGtalm5Wp1mNa3oEQs2fvkvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-meta-block-props=&quot;{&amp;quot;blockType&amp;quot;:&amp;quot;DIAGRAM_BLOCK&amp;quot;,&amp;quot;initData&amp;quot;:&amp;quot;%7B%22data%22%3A%7B%22mxCellList%22%3A%5B%22Xfazc13W%22%2C%22Pect1uf9%22%2C%22IzcPPDCM%22%2C%22dKVFLhD7%22%2C%22y9MiJU2P%22%2C%221UWkGJ8U%22%2C%22cZiSN9SC%22%2C%221xAmiJGI%22%2C%22BqbtgSQN%22%2C%22saeOpCAs%22%2C%22AqV2vvLC%22%2C%22IwQZXnox%22%2C%22G11qs1VY%22%2C%22euPp4iCQ%22%2C%22Wq3ezNTp%22%2C%22oKbWjFpV%22%2C%22tkfJr3ne%22%2C%22h9QvUkVa%22%2C%22Oi2BPCn8%22%2C%22o31bDaCF%22%2C%225Ipy4vFs%22%2C%226tMpMM21%22%2C%22ISZYlo1D%22%2C%22rVZr7hBi%22%2C%224ZD4SYXv%22%2C%22cqRlqkVT%22%2C%22oiLT6GWI%22%2C%22oMOyPYSk%22%2C%22rCj21opl%22%2C%2287jAkrS5%22%2C%22FpSoaVYM%22%2C%22ROD88lM4%22%2C%22Oj3VFKah%22%2C%22eBKTH4D0%22%2C%22TaG2Gi4M%22%2C%221VuHPxBA%22%2C%22yF8bVHdP%22%2C%22Mo4BlpfR%22%5D%2C%22mxGraphModel%22%3A%7B%22arrows%22%3A%221%22%2C%22connect%22%3A%221%22%2C%22dx%22%3A%22946%22%2C%22dy%22%3A%22549%22%2C%22fold%22%3A%221%22%2C%22grid%22%3A%221%22%2C%22gridSize%22%3A%2210%22%2C%22guides%22%3A%221%22%2C%22page%22%3A%221%22%2C%22pageHeight%22%3A%221169%22%2C%22pageScale%22%3A%221%22%2C%22pageWidth%22%3A%22827%22%2C%22tooltips%22%3A%221%22%7D%2C%22mxCellMap%22%3A%7B%221UWkGJ8U%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22224%22%2C%22y%22%3A%22365%22%7D%2C%22id%22%3A%221UWkGJ8U%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u91C7%u96C6%22%2C%22vertex%22%3A%221%22%7D%2C%221VuHPxBA%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2277%22%2C%22x%22%3A%22531%22%2C%22y%22%3A%22245%22%7D%2C%22id%22%3A%221VuHPxBA%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3Brotation%3D30%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%221xAmiJGI%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22194%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%221xAmiJGI%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%224ZD4SYXv%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22150%22%2C%22width%22%3A%22250%22%2C%22x%22%3A%22373%22%2C%22y%22%3A%2270%22%7D%2C%22id%22%3A%224ZD4SYXv%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%225Ipy4vFs%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22534%22%2C%22y%22%3A%22349%22%7D%2C%22id%22%3A%225Ipy4vFs%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%226tMpMM21%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22634%22%2C%22y%22%3A%22349%22%7D%2C%22id%22%3A%226tMpMM21%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u7BA1%u7406%22%2C%22vertex%22%3A%221%22%7D%2C%2287jAkrS5%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22483%22%2C%22y%22%3A%2279%22%7D%2C%22id%22%3A%2287jAkrS5%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22Scheduler%22%2C%22vertex%22%3A%221%22%7D%2C%22AqV2vvLC%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22204%22%2C%22y%22%3A%22294%22%7D%2C%22id%22%3A%22AqV2vvLC%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22Metadata%22%2C%22vertex%22%3A%221%22%7D%2C%22BqbtgSQN%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22263%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%22BqbtgSQN%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22FpSoaVYM%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22568.75%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22568.25%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22FpSoaVYM%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22G11qs1VY%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22214.5%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22214%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22G11qs1VY%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22ISZYlo1D%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22599%22%2C%22y%22%3A%22314%22%7D%2C%22id%22%3A%22ISZYlo1D%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource%22%2C%22vertex%22%3A%221%22%7D%2C%22IwQZXnox%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22154%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22153.5%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22IwQZXnox%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22IzcPPDCM%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22150%22%2C%22width%22%3A%22250%22%2C%22x%22%3A%2294%22%2C%22y%22%3A%22285%22%7D%2C%22id%22%3A%22IzcPPDCM%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22Mo4BlpfR%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2277%22%2C%22x%22%3A%22416%22%2C%22y%22%3A%22367.5%22%7D%2C%22id%22%3A%22Mo4BlpfR%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u4E0A%u62A5%22%2C%22vertex%22%3A%221%22%7D%2C%22Oi2BPCn8%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22623%22%2C%22y%22%3A%22499%22%7D%2C%22id%22%3A%22Oi2BPCn8%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22redis%22%2C%22vertex%22%3A%221%22%7D%2C%22Oj3VFKah%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22689.25%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22688.75%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22Oj3VFKah%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22Pect1uf9%22%3A%7B%22id%22%3A%22Pect1uf9%22%2C%22parent%22%3A%22Xfazc13W%22%7D%2C%22ROD88lM4%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22629.25%22%2C%22y%22%3A%22420%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22628.75%22%2C%22y%22%3A%22490%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22ROD88lM4%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22TaG2Gi4M%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2257%22%2C%22x%22%3A%22510%22%2C%22y%22%3A%22260%22%7D%2C%22id%22%3A%22TaG2Gi4M%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3Brotation%3D30%3B%22%2C%22value%22%3A%22%u8DEF%u7531%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%22Wq3ezNTp%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22549%22%7D%2C%22id%22%3A%22Wq3ezNTp%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22Xfazc13W%22%3A%7B%22id%22%3A%22Xfazc13W%22%7D%2C%22cZiSN9SC%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2260%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22525%22%7D%2C%22id%22%3A%22cZiSN9SC%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dmxgraph.flowchart.database%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23ffffff%3BstrokeColor%3D%23000000%3BstrokeWidth%3D2%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22cqRlqkVT%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22393%22%2C%22y%22%3A%22110%22%7D%2C%22id%22%3A%22cqRlqkVT%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22dKVFLhD7%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22114%22%2C%22y%22%3A%22325%22%7D%2C%22id%22%3A%22dKVFLhD7%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22eBKTH4D0%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22170%22%2C%22y%22%3A%22240%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22220%22%2C%22y%22%3A%22190%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22eBKTH4D0%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22source%22%3A%22IzcPPDCM%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3BexitX%3D1%3BexitY%3D0.5%3BexitDx%3D0%3BexitDy%3D0%3BentryX%3D0%3BentryY%3D0.5%3BentryDx%3D0%3BentryDy%3D0%3B%22%2C%22target%22%3A%22o31bDaCF%22%2C%22value%22%3A%22%22%7D%2C%22euPp4iCQ%22%3A%7B%22-0-mxGeometry%22%3A%7B%22-0-mxPoint%22%3A%7B%22as%22%3A%22sourcePoint%22%2C%22x%22%3A%22274.5%22%2C%22y%22%3A%22445%22%7D%2C%22-1-mxPoint%22%3A%7B%22as%22%3A%22targetPoint%22%2C%22x%22%3A%22274%22%2C%22y%22%3A%22515%22%7D%2C%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22relative%22%3A%221%22%2C%22width%22%3A%2250%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22euPp4iCQ%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22endArrow%3Dclassic%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%7D%2C%22h9QvUkVa%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%22102%22%2C%22x%22%3A%22592%22%2C%22y%22%3A%22494%22%7D%2C%22id%22%3A%22h9QvUkVa%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22shape%3Dcube%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BboundedLbl%3D1%3BbackgroundOutline%3D1%3BdarkOpacity%3D0.05%3BdarkOpacity2%3D0.1%3BfillColor%3D%23E6E6E6%3Bsize%3D32%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22o31bDaCF%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%22100%22%2C%22width%22%3A%22210%22%2C%22x%22%3A%22524%22%2C%22y%22%3A%22309%22%7D%2C%22id%22%3A%22o31bDaCF%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%22%2C%22vertex%22%3A%221%22%7D%2C%22oKbWjFpV%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22194%22%2C%22y%22%3A%22549%22%7D%2C%22id%22%3A%22oKbWjFpV%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22oMOyPYSk%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22503%22%2C%22y%22%3A%22150%22%7D%2C%22id%22%3A%22oMOyPYSk%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3BfillColor%3D%23FFE6CC%3B%22%2C%22value%22%3A%22%u6027%u80FD%u6570%u636E%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%2C%22oiLT6GWI%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22403%22%2C%22y%22%3A%22150%22%7D%2C%22id%22%3A%22oiLT6GWI%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%22rCj21opl%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22403%22%2C%22y%22%3A%22120%22%7D%2C%22id%22%3A%22rCj21opl%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource_sdk%22%2C%22vertex%22%3A%221%22%7D%2C%22rVZr7hBi%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22relative%22%3A%221%22%7D%2C%22edge%22%3A%221%22%2C%22id%22%3A%22rVZr7hBi%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22source%22%3A%224ZD4SYXv%22%2C%22style%22%3A%22rounded%3D0%3BorthogonalLoop%3D1%3BjettySize%3Dauto%3Bhtml%3D1%3BexitX%3D0.5%3BexitY%3D1%3BexitDx%3D0%3BexitDy%3D0%3BentryX%3D0.5%3BentryY%3D0%3BentryDx%3D0%3BentryDy%3D0%3B%22%2C%22target%22%3A%22o31bDaCF%22%7D%2C%22saeOpCAs%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2260%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22335%22%7D%2C%22id%22%3A%22saeOpCAs%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22resource_sdk%22%2C%22vertex%22%3A%221%22%7D%2C%22tkfJr3ne%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2220%22%2C%22width%22%3A%2240%22%2C%22x%22%3A%22263%22%2C%22y%22%3A%22550%22%7D%2C%22id%22%3A%22tkfJr3ne%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22DB%22%2C%22vertex%22%3A%221%22%7D%2C%22y9MiJU2P%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2250%22%2C%22width%22%3A%2290%22%2C%22x%22%3A%22124%22%2C%22y%22%3A%22365%22%7D%2C%22id%22%3A%22y9MiJU2P%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22rounded%3D0%3BwhiteSpace%3Dwrap%3Bhtml%3D1%3B%22%2C%22value%22%3A%22%u8D44%u6E90%u8DEF%u7531%22%2C%22vertex%22%3A%221%22%7D%2C%22yF8bVHdP%22%3A%7B%22-0-mxGeometry%22%3A%7B%22as%22%3A%22geometry%22%2C%22height%22%3A%2215%22%2C%22width%22%3A%2257%22%2C%22x%22%3A%22423%22%2C%22y%22%3A%22341%22%7D%2C%22id%22%3A%22yF8bVHdP%22%2C%22parent%22%3A%22Pect1uf9%22%2C%22style%22%3A%22text%3Bhtml%3D1%3BstrokeColor%3Dnone%3BfillColor%3Dnone%3Balign%3Dcenter%3BverticalAlign%3Dmiddle%3BwhiteSpace%3Dwrap%3Brounded%3D0%3B%22%2C%22value%22%3A%22%u8DEF%u7531%u67E5%u8BE2%22%2C%22vertex%22%3A%221%22%7D%7D%7D%2C%22diagramType%22%3A%22flowchart%22%2C%22lastEditTime%22%3A0%7D&amp;quot;,&amp;quot;props&amp;quot;:{&amp;quot;diagramType&amp;quot;:&amp;quot;flowchart&amp;quot;,&amp;quot;viewType&amp;quot;:&amp;quot;card&amp;quot;},&amp;quot;blockId&amp;quot;:&amp;quot;d70932ee-7e6d-403a-bfcb-1563dab93403&amp;quot;}&quot;/&gt;&lt;/p&gt;&lt;h2&gt;Scheduler 调度反馈&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;流量阈值限制&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Scheduler 调度速率与 DB 负载之间的关系较为复杂，本期采用简单的阈值反馈机制，设置 DB 流量阈值，当流量超出阈值时，停止 Scheduler 当前周期调度。根据历史数据，设置阈值为5K。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当流量未超出阈值时，不能预估任务对 DB 流量的影响，采用简单策略对任务数进行限制：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;任务数 = max(（DB流量阈值 - DB当前流量）* 100 / DB 流量阈值, 0)&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;DB路由&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;目前 Kunlun 的 DB 资源根据租户进行分配，不同租户的数据和流量会落在不同的 DB 上。Scheduler会记录 Job 所处租户，所以在调度时，需要根据租户查找真实的 DB 资源，通过 DB 指标的健康状况来决定是否派遣任务：&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;调度控制流程&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.620253164556962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhTYhABQhe0A6BKcF0zBhv4urevd2cYIubSziaicP3CGWqJEzmwEGRQhKwRvZZia43mcr5xWwBLhBJEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable js_wx_tap_highlight&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI1MzYzMjE0MQ==&quot; data-alias=&quot;BytedanceTechBlog&quot; data-from=&quot;2&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOhkoWTP1gVm0Lqs480XOARyoSYjPEsRVCSF35cbWIp6cliaYic8KUfNfiaSjVnruzTQUTCA0lmv9vUmw/0?wx_fmt=png&amp;amp;wx_head=1&quot; data-nickname=&quot;字节跳动技术团队&quot; data-signature=&quot;字节跳动的技术实践分享&quot; has-insert-preloading=&quot;1&quot; data-index=&quot;1&quot; data-origin_num=&quot;223&quot; data-is_biz_ban=&quot;0&quot; data-isban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fdaf6320528aca107cfc3dc5c27b958e</guid>
<title>阿里云万亿级数据集成架构实践</title>
<link>https://toutiao.io/k/c7nntg6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;&lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI0hWjpMznaHVbVNYcibSA5sKgBXldLywt7tpNy1A253nJLIsFhZYicobQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;分享嘉宾：罗海伟 阿里巴巴&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;编辑整理：公茂涛 中国科学院大学&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span&gt;出品平台：DataFunTalk&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-alias=&quot;zhiming_data&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;阿&lt;/span&gt;&lt;span&gt;里云DataWorks数据集成是DataX团队在阿里云上的商业化产品，致力于提供复杂网络环境下、丰富的异构数据源之间高速稳定的数据移动能力，以及繁杂业务背景下的数据同步解决方案。&lt;/span&gt;&lt;span&gt;目前已经支持云上近3000家客户，单日同步数据超过3万亿条。&lt;/span&gt;&lt;span&gt;DataWorks数据集成目前支持离线50+种数据源，可以进行整库迁移、批量上云、增量同步、分库分表等各类同步解决方案。&lt;/span&gt;&lt;span&gt;2020年上线实时同步能力，支持10+种数据源的读写任意组合，提供MySQL，Oracle等多种数据源到阿里云MaxCompute，Hologres等大数据引擎的一键全增量同步解决方案。&lt;/span&gt;&lt;span&gt;今天跟大家交流的内容是数据集成DataX的架构，以及在使用数据集成这款产品过程中遇到的一些问题和实践经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天的介绍会围绕下面几点展开：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么需要数据集成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成大事记&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成产品定位和业务支撑情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成DataX设计核心思路&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成DataX架构&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成数据同步-核心亮点&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成解决方案系统&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;阿里云 DataWorks &amp;amp; 数据集成关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;智能实时数仓解决方案示例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;为什么需要数据集成&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 数据集成的应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIVl0RmAIX1U72IyQ9TdXSibzKVBX5oGJSmnK1LvuFAsiaicSr2h6kRw5vw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先为什么需要数据集成，在大数据场景下，数据集成主要是解决哪些核心问题，我将其分为以下四个场景：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个场景&lt;/span&gt;&lt;span&gt;就是搬站上云&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。搬站上云主要用来对接业务数据库，完成数仓初始化，比如用户需要把自己的云下数据库快速安全地迁移到云上存储并做进一步的业务分析，如线下MySQL、Oracle到云上MaxCompute或者是Hadoop中Hive上，这既包含了一次性全量数据迁移，还包含持续增量数据迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个场景&lt;/span&gt;&lt;span&gt;是构建实时数仓&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，做流式的数据汇聚。主要包含应用产生的日志数据，应用产生的消息数据，和应用对接数据库产生的日志数据（数据库的Binlog或者归档日志）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三个场景是平台融和&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，完成云上各个产品之间的数据同步和交换。既包含跨云平台之间的数据同步，比如从AWS、GCP到阿里云；还包含云平台内部之间的数据交换，比如阿里云内部RDS、MaxCompute、OSS、PolarDB、AnalyticDB、Datahub等之间的数据同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四个场景是容灾备份&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。当数据分为冷热数据时，需要把冷数据放到归档数据中，极大节约成本。在数仓场景中，也可以把云上计算好的一些结果数据回流到数据库中，服务于在线数据应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是数据集成主要支撑的四个典型的数据场景。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. 数据集成的角色和地位&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIibxSgSPicjT62BiarVibH2zh0zH59u3nYFsqibiaBrQzujRl2qly4LSSm3TQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据集成在整个数仓建设中的角色和地位是什么呢？这里我们将数仓开发简单概括为6个模块或步骤，第一个是数据源，里面包含了各种关系型数据库、文件存储、大数据存储、消息队列等。这些异构的数据源可以通过统一的数据集成平台来将异构网络的数据统一抽取到数据仓库平台，在数据仓库平台中完成数据汇聚，进行进一步的数据分析。分析后的结果数据仍可以通过数据集成回流到在线数据库，为在线业务、在线应用提供数据查询。除此之外，还可以利用一个承上启下的产品-数据服务，对接数据应用，制作相关报表、大屏、和应用等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，我们知道数据集成在整个数据仓库开发建设过程中起到了非常关键的作用，只有通过数据集成将异构数据源统一汇总到数据仓库中，才有后序的数据分析、数据服务、数据应用等。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成大事记&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI85CnNcOu6mYkZ1jLbGWECRR9FW7OKQoeF8Ik202sibK45TNopXjWaibA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阿里云数据集成正是为了解决数据仓库中这些经典问题而出现的，它是一款有历史渊源的产品。2011年伴随着阿里巴巴数据平台事业部成立，当时推出了DataX的1.0和2.0版本，当时大家可能对于这款产品还没有太多了解。在2014年，伴随着DataX 3.0版本的发布，我们将服务于内部的数据集成产品推向了阿里云（公有云、专有云），开始正式的对外提供服务。并且于2016年，将数据同步引擎DataX开源到社区，助力大数据ETL生态建设。在2018年DataX有了一个比较大的架构升级，将公有云、专有云、阿里内部功能统一建立全新的Data Integration服务，进一步优化了开发效率，节约了运维成本。在2019年，将数据集成能力进行了商业化。在2020年，发布了数据集成的实时同步能力，可以支持数据实时传输，并且提供了一些实时同步场景解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之，阿里云数据集成是大数据平台上下云的核心枢纽，可以将不同业务系统中数据相互打通，实现数据自由离线或实时的流动。其致力于提供复杂网络环境下，丰富的异构数据源之间高速稳定的数据移动能力，以及在繁杂业务背景下，提供数据同步解决方案。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成产品定位和业务支撑情况&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 阿里云数据集成产品定位&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI7fe9t4H4LmVkicdSic7nBW7vJ5e79joSVCqPaR02REt5GrVib0suBDp1Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中是阿里云数据集成产品的核心功能特性列表，大家在自己设计或选型ETL产品的时候，可以着重了解这些点，做选型参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，离线和实时全覆盖，这款产品既支持传统的离线同步，也支持及时高效的实时同步；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二点，针对各种复杂网络均做了相应的解决方案和产品化能力，无论数据源在公网、IDC还是VPC等，数据集成都有对应的解决方案；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三点，因为DataX是一个云上产品，同时需要具备一些安全的管控策略，我们将开发和生产环境隔离，进行数据源权限安全控制；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第四点，得益于这种可扩展性架构，DataX可以支持繁多的异构数据源，离线支持50+种数据源，实时支持10+种数据源读写任意组合，其中涵盖了关系型数据库、MPP、NoSQL、文件储存、消息流等各大种类；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第五点，在大数据场景中往往存在特定场景的通用需求，比如整库迁移、批量上云、增量同步、分库分表、一键实时全增量，我们将这些通用需求抽象为数据集成的解决方案，进一步降低用户使用数据集成门槛；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们拥有一个非常完备的运维监控体系，能够进行流量控制、脏数据控制，能够对任务执行资源组进行监控，另外还可以设置任务告警，支持电话、短信、邮件、钉钉等。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;2. 阿里云数据集成业务支撑情况&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI4wyrka60MQNs0kpSlyOCB2jKHvkyU5XnM1JtzdmbLtq0DlngtcGqzg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先该产品现在拥有数千用户、数万名开发者，每天同步的数据量在PB级别，这些数据是由数千万个任务调度完成，而且该产品已经做到了全球地域部署覆盖，目前已经涵盖了政府、金融、保险、能源、电力、制造、互联网、零售等多个行业，几乎每一个行业都有典型的客户和场景。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成DataX设计核心思路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 核心设计思路&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIpUu4NsAkDyzA1TNrBiacBu0CQxFdTbrGrURT9sUeictV8XtqmHic8RqQQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;左侧图是传统的数据ETL工具制作的方法，是一种网状模型，每种储存之间如果交换数据，需分别设计一套数据传输软件。比如在MySQL和FTP之间交换数据，需要实现一个MySQL到FTP的数据同步工具，在MySQL和HDFS之间交换数据，还要实现另一个同步工具，这种方法扩展性非常差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这种场景，DataX做了一个非常核心的抽象，就是右侧图中蓝色的线性模型，每一种数据源统一通过DataX框架做数据交换，当增加一种新的数据源类型同步插件，便天然的具备和DataX已有的其他数据源通道进行数据交换的能力。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;下面着重介绍一下具体的实现思路，首先每一种数据存储，比如MySQL，会有一个MySQL的Reader插件和一个Writer插件，Reader插件主要是用来读取MySQL中的数据，读取的模式可以是离线的同步，也可以是实时的Binlog同步，Writer插件主要是用来写入数据。DataX做了两个核心抽象，第一个是接口抽象，不论Reader还是Writer插件均有一套接口规范，只要符合接口规范，就可以纳入平台调度体系，被平台调度和使用。另外一个抽象是数据类型规范，每增加一种新的数据源，只要符合数据交换规范，就可以和平台中已经支持的其他数据源进行交换，以上就是DataX极具扩展性的原因。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们在2016年将数据同步核心同步引擎的一部分DataX开源到了社区，地址为：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;https://github.com/alibaba/DataX &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;D&lt;/span&gt;&lt;/span&gt;&lt;span&gt;ataX是数据集成的一个核心同步引擎，是我们同步能力的一部分，今天除了要介绍一些开源的架构之外，还会介绍一些商业版，还没有完全开源的部分功能的核心架构。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 离线数据同步原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIGYEHuudmut5ibvNINPqH0w2TSscURXBm84micJs66NCvTQ3DLcF2morw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是离线数据的同步原理，每一个数据同步作业都是一个DataX程序进程，DataX可以连接数据源头读取数据，读取到数据以后写入到目标端。数据源头的数据读取可以基于数据库的JDBC协议，这些在一些关系型数据库或者一些MPP数据库中已经非常常见了；如果源数据系统是Kafka，MQ消息队列等储存形式的话，可以使用数据源对应的SDK进行读写。一个任务在读取的过程中，会发生切片、分发、执行，Reader和Writer之间是一个生产者消费者模型，Reader在读取数据以后会将数据发送到中间的缓存队列，Writer从中间缓存队列捕获数据，并最终由Writer写入到目标储存里面。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 实时数据同步原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIgU0vszHqSThichZBnzLibqP6NFm3JnvT6viawA0j2t1PHuTM6Hq4vNnHA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，介绍一下DataX实时数据同步原理。数据来源主要分为两类，关系型数据库和实时消息流。关系型数据库可以有对应日志，比如MySQL对应的Binlog日志，Oracle的归档日志，或者数据变更捕获cdc。这些日志会被日志抽取捕获到，捕获方式有API和SDK两种方式，然后框架会将捕获到的内容做消息分解处理，分解为insert、update、delete、alter等事件，然后并行地将其存放。我们支持关系型数据库、大数据、实时消息流等多种目标存储方式，如果数据源就是实时消息流的话，我们可以使用消息订阅模式订阅消息，并且将消息同样做分解，最终重放到目标端。其中第一类关系型数据库复杂度还是比较高的，因为包含了数据的增删改和DDL操作，实时消息流则主要是一些追加数据。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成DataX架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. DataX架构模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;①&lt;/span&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Standalone模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIibAbRydy657mhW701nnENSVicxAW0t2Nu3Niau1wSiclGtJxg1Aol6C8MA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解基础原理之后，向大家介绍一下阿里云数据集成DataX的架构设计，其中最经典的是大家比较熟悉的Standalone模式，Github上开源的即为这种模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Standalone模式将整个过程抽象为3个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一部分是framework框架，框架主要用来提供一些核心的、共性的功能，比如数据的速度控制、脏数据、任务执行指标的收集、汇总和上报，除此之外，框架还具有一定的调度能力；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二部分是Reader插件部分，Reader插件主要是用来对接数据源头，将源头数据读入其中；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三部分是Writer写插件部分，每一个目标存储类型都对应一个Writer插件，可以将源头投递过来的数据，写入到不同的目标储存里面。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;上面就是一个非常简单的模型，我们将一个数据同步作业称之为一个job，为了最大化的提高任务执行速度和效率，我们会将一个job拆分成多个task任务，每一个task都是一个完整数据同步作业的一个工作子任务，用来完成对应工作期间数据传输和投递，task任务可以被我们调度框架进行调度执行。task是分组的，即TaskGroup。一个TaskGroup可以有多个task子任务，TaskGroup会在worker节点中执行和处理，worker也是单机版本的，这也是Github中开源的经典模式。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;②&lt;/span&gt; Distribute模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI7k2XcdJzZ7jbRqpVEMkcRCOagN0RoTOiadoicmeJ82rcYwhWz3dM994g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了Standalone模式以外，我们在商业版本里面还有一些更强大的能力，首先是分布式模式，刚刚我们看到一个数据传输作业可以被分为多个task子任务，task又可以分组成TaskGroup，这些task会被并发执行。我们将前面讲的调度部分换成分布式调度模型，我们可以将不同的TaskGroup分发到不同的worker节点上面，就可以突破系统的单机瓶颈，在面对海量数据同步的时候，极大地提升数据传输效率。分布式执行集群也可以做到线性扩展，只要数据系统吞吐可以保障，数据同步作业可以随着worker节点的增加而线性增加，并且我们还做了一些异常节点的隔离等对应的一些分布式机制。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;③&lt;/span&gt; On Hadoop模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIwkGZUPkRdncE5jGiaHU8WVfcPD1chicU8KOfKhtPDibZk146dyb9ZO5Eg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三个模式是On Hadoop模式，也是商业化版本的一个能力。当用户已经拥有一个Hadoop执行集群，我们可以将DataX数据传输作业部署在已有的Hadoop集群里面，Hadoop中常见的编程模型是MapReduce，我们可以将DataX拆分的task寄宿在mapper节点和reducer节点中，通过Yarn进行统一调度和管理，通过这种方式我们可以复用已有的Hadoop计算和执行能力。这种模式和开源的Sqoop框架是有一点类似的。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时同步CheckPoint机制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIiauBmmhmRFnLflGLaTRTNfP5ibF9iaqJxLFLtsV2Xq9ibqPJPwgQUsOEgg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍阿里云数据集成DataX关于实时同步的checkpoint机制。checkpoint机制可以保证实时数据传输的稳定和断点续传的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你对Flink特别了解的话，这张图会非常熟悉。Flink是阿里团队开源出去的另外一个非常重要的实时计算引擎，DataX框架也借助了Flink的checkpoint机制，比如Flink会定期发送一些barrier事件和消息。我们的Reader Task其实是source，收到barrier以后，会产生snapShotState，并且barrier会传递到Transformer Task，Transformer Task可以用来做数据的转换，Transformer Task收到barrier以后，barrier进一步传递到Writer Task，这个时候的Writer Task其实就是sink，收到barrier之后，会再做一次snapShotState，Writer Task会将我们的数据flush到目标储存。我们会跟踪barrier进度情况，并且根据barrier进度情况，把数据流消费的点位cache缓存下来，并且可以进行持久化存储。当任务出现异常或者进程退出的时候，我们可以继续从上一个cache点继续消费数据，可以保证数据不会被丢弃，不过数据可能会有部分的重复，一般后序的计算引擎可以处理这种情况（幂等写出，最终一致）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成数据同步-核心亮点&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 阿里云数据集成离线同步-核心亮点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIUZyoyt4C4fkuyuNibJ5MOmib2KyibAqz9ldZH8c7DjOsR3RAxzwmvzGOw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;概况一下阿里云数据集成离线同步的核心亮点。主要分为以下四个部分：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一部分&lt;/span&gt;&lt;span&gt;是支持多种类的数据源&lt;/span&gt;&lt;span&gt;，DataX支持50+常见数据源，涵盖各种关系型数据库、文件系统、大数据系统、消息系统；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二部分&lt;/span&gt;&lt;span&gt;是解决方案系统&lt;/span&gt;&lt;span&gt;，我们为一些数据传输经典问题准备了对应的解决方案，比如支持全量和增量的数据同步，支持整库、批量数据同步、支持分库分表，我们将这些琐碎的功能整合成了产品化的解决方案，直接通过界面操作即可完整复杂的数据传输过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三部分&lt;/span&gt;&lt;span&gt;是精细化权限管控能力&lt;/span&gt;&lt;span&gt;，可以对数据源权限进行安全控制，并且隔离开发和生产环境；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第四部分&lt;/span&gt;&lt;span&gt;DataX支持复杂调度&lt;/span&gt;&lt;span&gt;，数据集成与DataWorks深度融合，利用DataWorks强大的调度能力调度我们的数据传输任务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 阿里云数据集成实时同步-核心亮点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIibX0Bu5b7rCtuSqgcicJs35X8LiaE3tpibS4efVhfKzBusiaUTHJ8HEPWaw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再概况下阿里云数据集成实时同步的核心亮点。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX是借助插件化机制，对新的数据源支持扩展能力强。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX支持丰富多样的数据源，支持星型链路组合，任何一种输入源都可以和任何一种输出源搭配组成同步链路。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX支持断点续传，可以实时读取MySQL、Oracle、SQLSever、OceanBase、Kafka、LogHub、DataHub、PolarDB等的数据，可以将数据实时写入到MaxCompute、Hologres、Datahub、Kafka、ElasticSearch等储存系统。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX天然具有云原生基因，和阿里云产品融合度非常高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX可以轻松监控运维告警，提供运维大盘、监控报警、FailOver等运维能力，可以监控业务延迟、Failover、脏数据、心跳检查、失败信息，并且支持邮件、电话、钉钉告警通知。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DataX支持一站式解决方案，支持常见数据源整库全增量到MaxCompute、Hologres、ElasticSearch、DataHub等，同时能够满足分库分表，单表、整库多表、DDL消息等复杂场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云数据集成解决方案系统&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 离线数仓-整库迁移方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI5WhIRZeJfXbcHjCtMkfxokdqm0f7rjZbQ7WbmQVE6gaKdgkygrhwkA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面将详细介绍一下阿里云数据集成解决方案系统，首先是离线数仓的整库迁移解决方案，我们将数据集成中的一些典型场景，抽象为数据产品解决方案，可以帮助提升用户效率，降低用户使用成本。上图展示出源头数据库中所有的表列表，直接选中需要的表，选择对应的同步方式，比如每日增量或者每日全量，选择分批上传或者整批上传的同步并发配置，就可以上传到MaxCompute中，这种可视化操作可以满足大多离线数据迁移场景。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓-全增量解决方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaI5mfv5HxNduUMyr5kRHNW6jRgX8jwDPTwFu0GbAyqn79TJFafjgxEAA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时数仓的全增量解决方案，可以非常方便的将现有数据库通过简单的配置后，完成存量的全量迁移，以及后续增量的实时同步。支持在目标库中建表、自动建立离线同步任务、自动建立实时任务、自动启动离线任务、自动启动实时任务、自动建立和启动增量和全量的融合任务、全流程的监控和展示，支持子步骤异常重试。通过这种方案，可以让用户不用关注每个全量任务和实时任务的琐碎配置细节。通过这一套解决方案，可以完成整个数据的全量、增量实时数据的同步。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;08&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;阿里云DataWorks和数据集成的关系&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIDxxCib3JQ0Wr2T3jSBQjaAvIgzM2hoq1DJX9xE849cdiboRu0KMMA9Bg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面介绍了阿里云数据集成开源和商业架构和能力，接下来介绍一下阿里云DataWorks和数据集成的关系。DataWorks是阿里云提供的一站式开发、数据治理的平台，融合了阿里云、阿里集团12年之久的数据中台、数据治理的实践经验。数据集成是阿里云DataWorks核心的一部分，DataWorks向下支持各种不同的计算和存储引擎，比如阿里大数据计算服务MaxCompute、开源大数据计算平台E-MapReduce、实时计算Realtime Compute、图计算引擎GraphCompute、交互式分析引擎MC-Hologres等，以及支持OSS、HDFS、DB等各种存储引擎。这些不同的计算存储引擎可以被阿里云DataWorks统一管理使用，后面可以基于这些引擎去做整个数据仓库。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DataWorks内部划分为7个模块，最下面是数据集成，可以完成各种模式的数据同步。数据集成之上，是元数据中心，提供统一的元数据服务。任务调度中心可以执行任务调度服务，数据开发方面，不同的存储引擎，比如实时计算和离线计算，其有着不同的开发模式，DataWorks支持离线开发和实时开发。同时DataWorks拥有一套综合数据治理的解决方案，会有一个数据服务模块，统一向上提供数据服务，对接各种数据应用。最后将DataWorks各种能力统一通过OpenAPI对外提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据集成模块是可以单独对用户提供服务，单独使用的，并不需要了解和掌握所有DataWorks模块就可以将数据同步作业配置和运行起来。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;09&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;智能实时数仓解决方案示例&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIWKwl5Oj8cK5m7wY0PPRYjO4YNAdnoz4r9AARkQ98AQsPCsc7iazZmHg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一个智能实时数仓解决方案实例，可以应用在电商、游戏、社交等大数据实时场景中。数据源有结构化数据和非结构化数据，非结构化数据可以通过DataHub数据总线做实时数据采集，之后借助数据集成来实时写到Hologres中做交互式分析，也可以将数据实时写入到MaxCompute中，进行归档和离线数据计算，另外Flink也可以消费订阅数据，做实时数据计算。Flink计算结果同时又可以写入Hologres中，也可以将实时计算结果做实时大屏和实时预警。结构化数据也可以通过实时数据抽取或者批量数据采集方式，统一采集到DataWorks，实时数据可以写入到Hologres或者定期归档到MaxCompute，离线数据可以通过批量数据加工到MaxCompute中来，另外MaxCompute和Hologres可以结合使用，进行实时联邦查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这套解决方案可以将阿里云实时数仓全套链路与离线数据无缝衔接，满足一套存储、两种计算（实时计算和离线计算）的高性价比组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个3连击呗~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分享嘉宾：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;289&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lAStFsJ0Pm1KX3Gm29Bw5WibzTLIiarQiaIdiaO7ib89YNS9uWmdSxTHzdPbsYthMzc32oo8ibzgK5tun8Y7dzFTdY7Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;电子书下载&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;389&quot; data-backw=&quot;578&quot; data-fileid=&quot;100072355&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6733909702209414&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPjicBGnN2Sv2xfMf0eh07fxem4LZeMGOo8FKqdlPdbTWZtXDDHYfNS78E3QkgUh68DMRia11ayJcyOQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;《大数据典藏版合集》&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;电子书目录如上，感兴趣的小伙伴，后台&lt;/span&gt;&lt;span&gt;回复&lt;/span&gt;&lt;strong&gt;&lt;span&gt;『大数据典藏版合集』&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，即可下载。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;&quot;&gt;&lt;mp-common-profile class=&quot;custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mp-common-profile&quot; data-from=&quot;0&quot; data-id=&quot;MzA3NTM0MTYyMQ==&quot; data-alias=&quot;zhiming_data&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/7iaMpruNx3Afic1pUJiat0zez4aPTUCyHDAs7PzvDuIO6GRh5jhGImRAicoUsg240UM4w7zooIKAiaqwnAiaU2BMNl0Q/0?wx_fmt=png&quot; data-nickname=&quot;志明与数据&quot; data-signature=&quot;专注于数据管理、数据治理、项目管理、大数据等相关领域的知识内容、实践经验、心得感悟分享。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>