<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>00046e6406013972e205f83ffd166683</guid>
<title>有哪些公司大规模使用了prometheus？有没有经典案例分享下？</title>
<link>https://toutiao.io/k/p5qn7s3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;fmt&quot;&gt;
          &lt;h1 id=&quot;cloudflare--prometheus&quot;&gt;Cloudflare 如何大规模运行 Prometheus&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuDvqbQdq.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们使用Prometheus来深入了解构成我们全球网络的所有不同硬件和软件。Prometheus 允许我们随着时间的推移衡量健康状况和绩效，如果任何服务有任何问题，请在它成为问题之前通知我们的团队。&lt;/p&gt;
&lt;p&gt;在撰写本文时，我们运行了 916 个 Prometheus 实例，总共有大约 49 亿个时间序列。这是显示确切数字的屏幕截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuFhft1VE.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这平均每个实例大约有 500 万个时间序列，但实际上我们混合了非常小和非常大的实例，最大的实例每个存储大约 3000 万个时间序列。&lt;/p&gt;
&lt;p&gt;运行如此庞大的 Prometheus 部署并非没有挑战。在这篇博文中，我们将介绍在尝试为每个 Prometheus 实例收集数百万个时间序列时可能遇到的一些问题。&lt;/p&gt;
&lt;h2 id=&quot;heading&quot;&gt;指标基数&lt;/h2&gt;
&lt;p&gt;当您开始运行自己的 Prometheus 实例时，您可能会听到的第一个问题是基数，这个问题最引人注目的案例被称为“基数爆炸”。&lt;/p&gt;
&lt;p&gt;因此，让我们首先从 Prometheus 的角度来看一下基数意味着什么，什么时候它可能成为问题，以及一些处理它的方法。&lt;/p&gt;
&lt;p&gt;假设我们有一个我们想要检测的应用程序，这意味着以 Prometheus 可以从我们的应用程序读取的指标形式添加一些可观察的属性。指标可以是您可以用数字表示的任何内容，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;车辆行驶的速度。&lt;/li&gt;
&lt;li&gt;当前温度。&lt;/li&gt;
&lt;li&gt;某些特定事件发生的次数。&lt;br/&gt;
要在我们的应用程序中创建指标，我们可以使用许多 Prometheus 客户端库之一。为简单起见，我们选择client_python，但无论您使用何种语言，相同的概念都将适用。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

# Declare our first metric.
# First argument is the name of the metric.
# Second argument is the description of it.
c = Counter(mugs_of_beverage_total, &#x27;The total number of mugs drank.&#x27;)

# Call inc() to increment our metric every time a mug was drank.
c.inc()
c.inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用这个简单的代码，Prometheus 客户端库将创建一个单一的指标。为了让 Prometheus 收集此指标，我们需要我们的应用程序运行 HTTP 服务器并在那里公开我们的指标。最简单的方法是使用 client_python 本身提供的功能 - 请参阅此处的文档。&lt;/p&gt;
&lt;p&gt;当 Prometheus 向我们的应用程序发送 HTTP 请求时，它将收到以下响应：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP mugs_of_beverage_total The total number of mugs drank.
# TYPE mugs_of_beverage_total counter
mugs_of_beverage_total 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Prometheus 自己的文档中广泛介绍了这种格式和底层数据模型。&lt;/p&gt;
&lt;p&gt;有关详细信息，请参阅数据模型和说明格式页面。&lt;/p&gt;
&lt;p&gt;如果愿意，我们可以添加更多指标，它们都将出现在对指标端点的 HTTP 响应中。&lt;/p&gt;
&lt;p&gt;Prometheus 指标可以具有标签形式的额外维度。我们可以使用这些向我们的指标添加更多信息，以便我们可以更好地了解正在发生的事情。&lt;/p&gt;
&lt;p&gt;通过我们的示例指标，我们知道消耗了多少杯，但如果我们还想知道它是哪种饮料怎么办？或者我们想知道这是冷饮还是热饮？添加标签非常容易，我们需要做的就是指定它们的名称。一旦我们这样做了，我们需要在递增我们的计数器以传递这些额外信息时传递标签值（与指定标签名称的顺序相同）。&lt;/p&gt;
&lt;p&gt;让我们调整示例代码来执行此操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(mugs_of_beverage_total, &#x27;The total number of mugs drank.&#x27;, [&#x27;content&#x27;, &#x27;temperature&#x27;])

c.labels(&#x27;coffee&#x27;, &#x27;hot&#x27;).inc()
c.labels(&#x27;coffee&#x27;, &#x27;hot&#x27;).inc()
c.labels(&#x27;coffee&#x27;, &#x27;cold&#x27;).inc()
c.labels(&#x27;tea&#x27;, &#x27;hot&#x27;).inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的 HTTP 响应现在将显示更多条目：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP mugs_of_beverage_total The total number of mugs drank.
# TYPE mugs_of_beverage_total counter
mugs_of_beverage_total{content=&quot;coffee&quot;, temperature=&quot;hot&quot;} 2
mugs_of_beverage_total{content=&quot;coffee&quot;, temperature=&quot;cold&quot;} 1
mugs_of_beverage_total{content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如我们所看到的，我们为每个唯一的标签组合都有一个条目。&lt;/p&gt;
&lt;p&gt;这将我们带到了指标上下文中基数的定义。基数是所有标签的唯一组合的数量。您拥有的标签越多，每个标签可以取的值越多，您可以创建的独特组合就越多，基数就越高。&lt;/p&gt;
&lt;h2 id=&quot;-vs--vs-&quot;&gt;指标 vs 样本 vs 时间序列&lt;/h2&gt;
&lt;p&gt;现在我们应该停下来对指标和时间序列进行重要区分。&lt;/p&gt;
&lt;p&gt;指标是具有某些已定义维度（标签）的可观察属性。在我们的示例中，它是一个 Counter 类对象。&lt;/p&gt;
&lt;p&gt;时间序列是该指标的一个实例，具有所有维度（标签）的独特组合，加上一系列时间戳和值对——因此得名“时间序列”。名称和标签告诉我们正在观察什么，而时间戳和值对告诉我们可观察的属性如何随时间变化，允许我们使用这些数据绘制图表。&lt;/p&gt;
&lt;p&gt;这意味着单个指标将创建一个或多个时间序列。时间序列的数量完全取决于标签的数量以及这些标签可以取的所有可能值的数量。&lt;/p&gt;
&lt;p&gt;每次我们为我们的指标添加一个新标签时，我们都冒着增加将作为结果导出到 Prometheus 的时间序列数量的风险。&lt;/p&gt;
&lt;p&gt;在我们的示例中，我们有两个标签，“内容”和“温度”，它们都可以有两个不同的值。所以我们最终可以创建的时间序列的最大数量是四个 (2&lt;em&gt;2)。如果我们添加另一个也可以有两个值的标签，那么我们现在最多可以导出八个时间序列 (2&lt;/em&gt;2*2)。我们拥有的标签越多或它们可以拥有的时间序列越多。&lt;/p&gt;
&lt;p&gt;如果所有标签值都由您的应用程序控制，您将能够计算出所有可能的标签组合的数量。但真正的风险是当您使用来自外部世界的标签值创建指标时。&lt;/p&gt;
&lt;p&gt;如果我们跟踪对 Web 服务器的 HTTP 请求数量而不是饮料，并且我们使用请求路径作为标签值之一，那么任何发出大量随机请求的人都可能迫使我们的应用程序创建大量时间序列. 为避免这种情况，通常最好永远不要接受来自不受信任来源的标签值。&lt;/p&gt;
&lt;p&gt;使事情变得更复杂的是，您在阅读 Prometheus 文档时可能还会听到“示例”。样本介于指标和时间序列之间——它是特定时间戳的时间序列值。这里的时间戳可以是显式的也可以是隐式的。如果样本缺少任何明确的时间戳，则意味着该样本代表最新值——它是给定时间序列的当前值，而时间戳只是您进行观察的时间。&lt;/p&gt;
&lt;p&gt;如果您查看我们示例指标的 HTTP 响应，您会发现返回的条目都没有时间戳。实际上任何地方都没有时间戳。这是因为 Prometheus 服务器本身负责时间戳。当 Prometheus 收集指标时，它会记录开始每次收集的时间，然后它将使用它为每个时间序列编写时间戳和值对。&lt;/p&gt;
&lt;p&gt;这就是为什么我们的应用程序导出的不是真正的指标或时间序列——它是样本。&lt;/p&gt;
&lt;p&gt;令人困惑？让我们回顾一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们从一个指标开始——它只是对我们可以观察到的事物的定义，比如喝醉的杯子数。&lt;/li&gt;
&lt;li&gt;我们的指标作为 HTTP 响应公开。该响应将包含一个样本列表——这些是我们指标的各个实例（由名称和标签表示），加上当前值。&lt;/li&gt;
&lt;li&gt;当 Prometheus 从我们的 HTTP 响应中收集所有样本时，它会添加该收集的时间戳，并将所有这些信息结合在一起，我们就有了一个时间序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZuZFwhuG1.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;heading-1&quot;&gt;基数相关问题&lt;/h2&gt;
&lt;p&gt;每个时间序列都会消耗我们的资源，因为它需要保存在内存中，所以我们拥有的时间序列越多，消耗的资源指标就越多。对于客户端库和 Prometheus 服务器来说都是如此，但对于 Prometheus 本身来说更像是一个问题，因为单个 Prometheus 服务器通常会从许多应用程序收集指标，而应用程序只保留自己的指标。&lt;/p&gt;
&lt;p&gt;因为我们知道我们拥有的标签越多，我们最终得到的时间序列就越多，你可以看到这什么时候会成为一个问题。简单地向我们所有的指标添加一个具有两个不同值的标签可能会使我们必须处理的时间序列数量增加一倍。这反过来将使我们的 Prometheus 服务器的内存使用量增加一倍。如果我们让 Prometheus 消耗的内存超过它实际使用的内存，那么它就会崩溃。&lt;/p&gt;
&lt;p&gt;这种情况通常被描述为“基数爆炸”——一些指标突然添加了大量不同的标签值，创建了大量的时间序列，导致普罗米修斯耗尽内存，结果你失去了所有的可观察性。&lt;/p&gt;
&lt;h2 id=&quot;prometheus-&quot;&gt;Prometheus 是如何使用内存的？&lt;/h2&gt;
&lt;p&gt;为了更好地处理基数问题，最好先更好地了解 Prometheus 的工作原理以及时间序列如何消耗内存。&lt;/p&gt;
&lt;p&gt;为此，让我们遵循普罗米修斯内部时间序列生命周期中的所有步骤。&lt;/p&gt;
&lt;h2 id=&quot;---http-&quot;&gt;第一步 - HTTP 抓取&lt;/h2&gt;
&lt;p&gt;从 Prometheus 向我们的应用程序发送 HTTP 请求的过程称为“抓取”。在 Prometheus 配置文件中，我们定义了一个“抓取配置”，告诉 Prometheus 发送 HTTP 请求的位置、发送频率，以及可选地对请求和响应应用额外处理。&lt;/p&gt;
&lt;p&gt;它将记录它发送 HTTP 请求的时间，并稍后将其用作所有收集的时间序列的时间戳。&lt;/p&gt;
&lt;p&gt;发送请求后，它将解析响应以查找那里公开的所有样本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZv5TDe91G.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;heading-2&quot;&gt;第二步——新的时间序列还是更新？&lt;/h2&gt;
&lt;p&gt;一旦 Prometheus 有了从我们的应用程序收集的样本列表，它将把它保存到TSDB - 时间序列数据库 - Prometheus 保存所有时间序列的数据库。&lt;/p&gt;
&lt;p&gt;但在此之前，它需要首先检查哪些样本属于 TSDB 中已经存在的时间序列，哪些属于全新的时间序列。&lt;/p&gt;
&lt;p&gt;正如我们之前提到的，时间序列是从指标生成的。每个唯一的指标标签组合都有一个时间序列。&lt;/p&gt;
&lt;p&gt;这意味着 Prometheus 必须检查是否已经存在具有相同名称和完全相同标签集的时间序列。在内部，时间序列名称只是另一个名为 &lt;strong&gt;name&lt;/strong&gt; 的标签，因此名称和标签之间没有实际区别。下面的两种表示都是导出相同时间序列的不同方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mugs_of_beverage_total{content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
{__name__=&quot;mugs_of_beverage_total&quot;, content=&quot;tea&quot;, temperature=&quot;hot&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于一切都是标签，Prometheus 可以简单地使用 sha256 或任何其他算法对所有标签进行哈希处理，以得出每个时间序列唯一的单个 ID。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZv9KGR6vS.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知道它可以快速检查是否有任何时间序列已经存储在 TSDB 中具有相同的哈希值。基本上我们的标签哈希被用作 TSDB 中的主键。&lt;/p&gt;
&lt;h2 id=&quot;----tsdb&quot;&gt;第三步 - 附加到 TSDB&lt;/h2&gt;
&lt;p&gt;一旦 TSDB 知道它是否必须插入新的时间序列或更新现有的时间序列，它就可以开始真正的工作。&lt;/p&gt;
&lt;p&gt;在内部，所有时间序列都存储在名为Head的结构上的地图中。该映射使用标签哈希作为键，使用名为memSeries 的结构作为值。这些 memSeries 对象存储所有时间序列信息。memSeries 的结构定义相当大，但我们真正需要知道的是它具有所有时间序列标签和包含所有样本（时间戳和值对）的块的副本。&lt;/p&gt;
&lt;p&gt;每个 memSeries 实例都存储一次标签。&lt;/p&gt;
&lt;p&gt;样本使用“varbit”编码存储在块内，这是一种针对时间序列数据优化的无损压缩方案。每个块代表特定时间范围内的一系列样本。这有助于 Prometheus 更快地查询数据，因为它需要做的就是首先找到标签与我们的查询匹配的 memSeries 实例，然后找到负责查​​询时间范围的块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvcYLtYAU.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下， Prometheus 将每两小时wall clock创建一个块。所以会有一个块用于：00:00 - 01:59、02:00 - 03:59、04:00 - 05:59、...、22:00 - 23:59。&lt;/p&gt;
&lt;p&gt;我们只能附加一个块，它被称为“头块”。这是负责最近时间范围的块，包括我们抓取的时间。任何其他块都包含历史样本，因此是只读的。&lt;/p&gt;
&lt;p&gt;每个块最多可以容纳120 个样本。这是因为一旦我们在一个块上有超过 120 个样本，“varbit”编码的效率就会下降。TSDB将尝试估计给定块何时达到 120 个样本，并相应地设置当前 Head Chunk 的最大允许时间。&lt;/p&gt;
&lt;p&gt;如果我们尝试附加一个时间戳高于当前 Head Chunk 的最大允许时间的样本，则 TSDB 将创建一个新的 Head Chunk 并根据附加速率为其计算新的最大时间。&lt;/p&gt;
&lt;p&gt;所有块都必须与挂钟时间的那两个小时时段对齐，因此如果 TSDB 正在为 10:00-11:59 构建一个块并且它在 11:30 已经“满”，那么它将为11:30-11:59时间范围。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZveSuiPL5.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于默认的 Prometheus 抓取间隔是一分钟，因此需要两个小时才能达到 120 个样本。&lt;/p&gt;
&lt;p&gt;这意味着使用 Prometheus 默认值，每个 memSeries 应该有一个块，每两个小时的数据有 120 个样本。&lt;/p&gt;
&lt;p&gt;回到我们的时间序列——此时 Prometheus 要么创建一个新的 memSeries 实例，要么使用已经存在的 memSeries。一旦有了要使用的 memSeries 实例，它就会将我们的样本附加到 Head Chunk。如果需要，这可能需要 Prometheus 创建一个新块。&lt;/p&gt;
&lt;h2 id=&quot;heading-3&quot;&gt;第四步——内存映射旧块&lt;/h2&gt;
&lt;p&gt;经过几个小时的 Prometheus 运行和抓取指标后，我们的时间序列上可能会有不止一个块：&lt;/p&gt;
&lt;p&gt;一个“Head Chunk”——包含最后两个小时的挂钟插槽中的最多两个小时。&lt;br/&gt;
一个或多个用于历史范围 - 这些块仅供阅读，Prometheus 不会尝试在此处附加任何内容。&lt;br/&gt;
由于所有这些块都存储在内存中，Prometheus 将尝试通过将它们写入磁盘和内存映射来减少内存使用。这样做的好处是内存映射块不使用内存，除非 TSDB 需要读取它们。&lt;/p&gt;
&lt;p&gt;Head Chunk 从不进行内存映射，它始终存储在内存中。&lt;/p&gt;
&lt;h2 id=&quot;---&quot;&gt;第五步 - 将块写入磁盘&lt;/h2&gt;
&lt;p&gt;到目前为止，所有时间序列都完全存储在内存中，您拥有的时间序列越多，Prometheus 的内存使用率就越高。唯一的例外是内存映射块，它们被卸载到磁盘，但如果查询需要，将被读入内存。&lt;/p&gt;
&lt;p&gt;这允许 Prometheus 每秒抓取和存储数千个样本，我们最大的实例每秒附加 550k 个样本，同时还允许我们同时查询所有指标。&lt;/p&gt;
&lt;p&gt;但是您不能将所有内容永远保存在内存中，即使数据的内存映射部分也是如此。&lt;/p&gt;
&lt;p&gt;每两个小时 Prometheus 就会将内存中的块持久化到磁盘上。这个过程也与挂钟对齐，但偏移了一个小时。&lt;/p&gt;
&lt;p&gt;当使用普罗米修斯默认值并假设我们每两个小时的挂钟有一个块时，我们会看到：&lt;/p&gt;
&lt;p&gt;02:00 - 为 02:00 - 03:59 时间范围创建一个新块&lt;br/&gt;
03:00 - 为 00:00 - 01:59 写一个块&lt;br/&gt;
04:00 - 为 04:00 - 05:59 时间范围创建一个新块&lt;br/&gt;
05:00 - 为 02:00 - 03:59 写一个块&lt;br/&gt;
……&lt;br/&gt;
22:00 - 为 22:00 - 23:59 时间范围创建一个新块&lt;br/&gt;
23:00 - 为 20:00 - 21:59 写一个块&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvjBXjSYG.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦一个块被写入一个块，它就会从 memSeries 中移除，从而从内存中移除。Prometheus 将在配置的保留期内将每个块保留在磁盘上。&lt;/p&gt;
&lt;p&gt;块最终将被“压缩”，这意味着 Prometheus 将采用多个块并将它们合并在一起以形成一个覆盖更大时间范围的块。这个过程有助于减少磁盘使用，因为每个块都有一个占用大量磁盘空间的索引。通过将多个块合并在一起，可以重复使用该索引的大部分，从而允许 Prometheus 使用相同数量的存储空间存储更多数据。&lt;/p&gt;
&lt;h2 id=&quot;heading-4&quot;&gt;第六步——垃圾收集&lt;/h2&gt;
&lt;p&gt;在将块写入块并从 memSeries 中删除后，我们可能会得到一个没有块的 memSeries 实例。如果任何时间序列不再被任何应用程序公开，那么就会发生这种情况，因此没有试图向其附加更多样本的刮擦。&lt;/p&gt;
&lt;p&gt;一种常见的模式是将软件版本导出为 build_info 指标，Prometheus 本身也这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.42.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 Prometheus 2.43.0 发布时，该指标将导出为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.43.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这意味着带有 version=”2.42.0” 标签的时间序列将不再接收任何新样本。&lt;/p&gt;
&lt;p&gt;一旦这个时间序列的最后一个块被写入一个块并从 memSeries 实例中删除，我们就没有剩下的块了。这意味着我们的 memSeries 仍然消耗一些内存（主要是标签），但实际上没有做任何事情。&lt;/p&gt;
&lt;p&gt;为了摆脱这样的时间序列，Prometheus 将在写入一个块后立即运行“head 垃圾回收”（记住 Head 是包含所有 memSeries 的结构）。这个垃圾收集，除其他外，将寻找任何没有单个块的时间序列，并将其从内存中删除。&lt;/p&gt;
&lt;p&gt;由于这发生在写入一个块之后，并且写入一个块发生在块窗口的中间（与挂钟对齐的两个小时片），唯一会找到的 memSeries 是那些“孤立的”——它们之前收到过样本，但现在不是了。&lt;/p&gt;
&lt;h2 id=&quot;heading-5&quot;&gt;这是什么意思呢？&lt;/h2&gt;
&lt;p&gt;Prometheus 中使用的 TSDB 是一种特殊的数据库，针对非常特定的工作负载进行了高度优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从应用程序中抓取的时间序列保存在内存中。&lt;/li&gt;
&lt;li&gt;如果有连续更新，样本将使用最有效的编码进行压缩。&lt;/li&gt;
&lt;li&gt;几个小时前的块被写入磁盘并从内存中删除。&lt;/li&gt;
&lt;li&gt;当时间序列从应用程序中消失并且不再被抓取时，它们仍然保留在内存中，直到所有块都写入磁盘并且垃圾收集将它们删除。&lt;br/&gt;
这意味着 Prometheus 在一遍又一遍地连续抓取相同的时间序列时效率最高。当它只抓取时间序列一次而不再抓取时，效率最低——与使用该内存存储的信息量相比，这样做会带来显着的内存使用开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们试着想象一下普罗米修斯是如何设计完美的数据类型的，我们最终会得到这样的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvtcxhQhh.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一些连续的线条描述了一些观察到的特性。&lt;/p&gt;
&lt;p&gt;另一方面，如果我们想可视化 Prometheus 在处理时效率最低的数据类型，我们将以这样的方式结束：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvuNXZzhC.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们有单个数据点，每个数据点代表我们测量的不同属性。&lt;/p&gt;
&lt;p&gt;尽管您可以调整 Prometheus 的一些行为，并通过传递其中一个隐藏的标志来调整它以用于短暂的时间序列，但通常不鼓励这样做。这些标志仅用于测试，可能会对 Prometheus 服务器的其他部分产生负面影响。&lt;/p&gt;
&lt;p&gt;为了更好地理解短暂时间序列对内存使用的影响，让我们看另一个例子。&lt;/p&gt;
&lt;p&gt;让我们看看如果我们在 00:25 启动我们的应用程序会发生什么，允许 Prometheus 在它导出时抓取它一次：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.42.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在第一次抓取之后立即将我们的应用程序升级到新版本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prometheus_build_info{version=&quot;2.43.0&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 00:25 Prometheus 将创建我们的 memSeries，但我们必须等到 Prometheus 写入一个包含 00:00-01:59 数据的块并运行垃圾收集，然后 memSeries 从内存中删除，这将在 03 发生： 00。&lt;/p&gt;
&lt;p&gt;这个单个样本（数据点）将创建一个时间序列实例，该实例将使用资源在内存中保留超过两个半小时，这样我们就有了一个时间戳和值对。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvzPWb7Vo.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们要连续抓取大量仅存在很短时间的时间序列，那么我们将在内存中慢慢积累大量 memSeries，直到下一次垃圾回收。&lt;/p&gt;
&lt;p&gt;查看此类 Prometheus 服务器的内存使用情况，我们会看到这种模式随时间重复出现：&lt;br/&gt;
&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvBuZp6WG.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的重要信息是短暂的时间序列很昂贵。只被抓取一次的时间序列保证在 Prometheus 中存活一到三个小时，具体取决于抓取的确切时间。&lt;/p&gt;
&lt;h2 id=&quot;heading-6&quot;&gt;基数的代价&lt;/h2&gt;
&lt;p&gt;至此我们应该知道一些关于 Prometheus 的事情：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我们知道什么是指标、样本和时间序列。&lt;/li&gt;
&lt;li&gt;我们知道，指标上的标签越多，它可以创建的时间序列就越多。&lt;/li&gt;
&lt;li&gt;我们知道每个时间序列都会保存在内存中。&lt;/li&gt;
&lt;li&gt;我们知道时间序列会在内存中保留一段时间，即使它们只被刮掉一次。&lt;br/&gt;
考虑到所有这些，我们现在可以看到问题 - 一个具有高基数的指标，尤其是具有来自外部世界的标签值的指标，很容易在很短的时间内创建大量时间序列，导致基数爆炸。这会增加 Prometheus 的内存使用量，如果它使用了所有可用的物理内存，这可能会导致 Prometheus 服务器崩溃。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更好地了解这个问题，让我们调整示例指标以跟踪 HTTP 请求。&lt;/p&gt;
&lt;p&gt;我们的指标将有一个存储请求路径的标签。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(http_requests_total, &#x27;The total number of HTTP requests.&#x27;, [&#x27;path&#x27;])

# HTTP request handler our web server will call
def handle_request(path):
  c.labels(path).inc()
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们使用 curl 命令发出单个请求：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl https://app.example.com/index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们应该在我们的应用程序中看到这些时间序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{path=&quot;/index.html&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果一个邪恶的黑客决定向我们的应用程序发送一堆随机请求会发生什么？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; curl https://app.example.com/jdfhd5343
&amp;gt; curl https://app.example.com/3434jf833
&amp;gt; curl https://app.example.com/1333ds5
&amp;gt; curl https://app.example.com/aaaa43321
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将创建额外的时间序列：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# HELP http_requests_total The total number of HTTP requests.
# TYPE http_requests_total counter
http_requests_total{path=&quot;/index.html&quot;} 1
http_requests_total{path=&quot;/jdfhd5343&quot;} 1
http_requests_total{path=&quot;/3434jf833&quot;} 1
http_requests_total{path=&quot;/1333ds5&quot;} 1
http_requests_total{path=&quot;/aaaa43321&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果有 1,000 个随机请求，我们最终会在 Prometheus 中得到 1,000 个时间序列。如果我们的指标有更多标签，并且所有标签都是根据请求负载（HTTP 方法名称、IP、标头等）设置的，我们很容易得到数百万个时间序列。&lt;/p&gt;
&lt;p&gt;通常它不需要任何恶意行为者来引起与基数相关的问题。一类常见的错误是在指标上贴上错误标签并将原始错误对象作为值传递。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from prometheus_client import Counter

c = Counter(errors_total, &#x27;The total number of errors.&#x27;, [error])

def my_func:
  try:
    ...
  except Exception as err:
    c.labels(err).inc()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果需要处理的错误是一般性的，例如“权限被拒绝”，这很有效：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;errors_total{error=&quot;Permission Denied&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果错误字符串包含一些特定于任务的信息，例如我们的应用程序无法访问的文件的名称，或者 TCP 连接错误，那么我们可能很容易以这种方式得到高基数指标：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;errors_total{error=&quot;file not found: /myfile.txt&quot;} 1
errors_total{error=&quot;file not found: /other/file.txt&quot;} 1
errors_total{error=&quot;read udp 127.0.0.1:12421-&amp;gt;127.0.0.2:443: i/o timeout&quot;} 1
errors_total{error=&quot;read udp 127.0.0.1:14743-&amp;gt;127.0.0.2:443: i/o timeout&quot;} 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一旦被抓取，所有这些时间序列将在内存中保留至少一小时。在 Prometheus 中持续累积时间序列非常容易，直到内存不足。即使是 Prometheus 自己的客户端库也有可能使您面临此类问题的错误。&lt;/p&gt;
&lt;h2 id=&quot;heading-7&quot;&gt;时间序列需要多少内存？&lt;/h2&gt;
&lt;p&gt;Prometheus 中存储的每个时间序列（作为 memSeries 实例）包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有标签的副本。&lt;/li&gt;
&lt;li&gt;包含样本的块。&lt;/li&gt;
&lt;li&gt;Prometheus 内部所需的额外字段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;标签所需的内存量将取决于这些标签的数量和长度。您拥有的标签越多，或者名称和值越长，使用的内存就越多。&lt;/p&gt;
&lt;p&gt;Prometheus 内部存储标签的方式也很重要，但这是用户无法控制的。有一个开放的拉取请求，它通过将所有标签存储为单个字符串来改进标签的内存使用。&lt;/p&gt;
&lt;p&gt;块将消耗更多内存，因为它们在每次抓取之后慢慢填充更多样本，因此这里的内存使用将遵循一个循环 - 我们从附加第一个样本时的低内存使用开始，然后内存使用缓慢上升直到新的块被创建，我们重新开始。&lt;/p&gt;
&lt;p&gt;您可以通过在 Prometheus 服务器上运行此查询来计算您的时间序列需要多少内存：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;go_memstats_alloc_bytes / prometheus_tsdb_head_series&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;请注意，您的 Prometheus 服务器必须配置为自行抓取才能正常工作。&lt;/p&gt;
&lt;p&gt;其次这个计算是基于 Prometheus 使用的所有内存，而不仅仅是时间序列数据，所以它只是一个近似值。使用它来粗略了解每个时间序列使用了多少内存，不要假设它是那个确切的数字。&lt;/p&gt;
&lt;p&gt;第三，Prometheus 是用Golang编写的，这是一种具有垃圾收集功能的语言。因此，Prometheus 所需的实际物理内存量通常会更高，因为它将包括需要由 Go 运行时释放的未使用（垃圾）内存。&lt;/p&gt;
&lt;h2 id=&quot;prometheus&quot;&gt;保护普罗米修斯免受基数爆炸Prometheus&lt;/h2&gt;
&lt;p&gt;确实提供了一些选项来处理高基数问题。您可以在抓取配置块中设置许多选项。以下是 Prometheus 文档中相关选项的摘录：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# An uncompressed response body larger than this many bytes will cause the
# scrape to fail. 0 means no limit. Example: 100MB.
# This is an experimental feature, this behaviour could
# change or be removed in the future.
[ body_size_limit: &amp;lt;size&amp;gt; | default = 0 ]
# Per-scrape limit on number of scraped samples that will be accepted.
# If more than this number of samples are present after metric relabeling
# the entire scrape will be treated as failed. 0 means no limit.
[ sample_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on number of labels that will be accepted for a sample. If
# more than this number of labels are present post metric-relabeling, the
# entire scrape will be treated as failed. 0 means no limit.
[ label_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on length of labels name that will be accepted for a sample.
# If a label name is longer than this number post metric-relabeling, the entire
# scrape will be treated as failed. 0 means no limit.
[ label_name_length_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape limit on length of labels value that will be accepted for a sample.
# If a label value is longer than this number post metric-relabeling, the
# entire scrape will be treated as failed. 0 means no limit.
[ label_value_length_limit: &amp;lt;int&amp;gt; | default = 0 ]

# Per-scrape config limit on number of unique targets that will be
# accepted. If more than this number of targets are present after target
# relabeling, Prometheus will mark the targets as failed without scraping them.
# 0 means no limit. This is an experimental feature, this behaviour could
# change in the future.
[ target_limit: &amp;lt;int&amp;gt; | default = 0 ]

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置所有与标签长度相关的限制可以避免极长的标签名称或值最终占用过多内存的情况。&lt;/p&gt;
&lt;p&gt;回到我们带有错误标签的指标，我们可以想象这样一种场景，其中某些操作返回一条巨大的错误消息，甚至是包含数百行的堆栈跟踪。如果这样的堆栈跟踪最终作为标签值，它将比其他时间序列占用更多的内存，甚至可能是兆字节。由于标签在 Prometheus 处理查询时被复制，这可能会导致内存使用量显着增加。&lt;/p&gt;
&lt;p&gt;设置 label_limit 提供了一些基数保护，但即使只有一个标签名称和大量值，我们也可以看到高基数。通过 sample_limit 是避免高基数的最终保护。它使我们能够对可以从每个应用程序实例中抓取的时间序列数量实施硬性限制。所有这些限制的不利之处在于，违反其中任何一个都会导致整个抓取错误。&lt;/p&gt;
&lt;p&gt;如果我们将 sample_limit 配置为 100 并且我们的指标响应包含 101 个样本，那么 Prometheus根本不会抓取任何内容。这是 Prometheus 开发人员经过深思熟虑做出的设计决定。&lt;/p&gt;
&lt;p&gt;主要动机似乎是处理部分抓取的指标很困难，最好将失败的抓取视为事件。&lt;/p&gt;
&lt;h2 id=&quot;cloudflare-&quot;&gt;Cloudflare 如何处理高基数？&lt;/h2&gt;
&lt;p&gt;我们在世界各地拥有数百个数据中心，每个数据中心都有专门的 Prometheus 服务器负责抓取所有指标。每个 Prometheus 都在抓取数百个不同的应用程序，每个应用程序都运行在数百台服务器上。结合起来有很多不同的指标。意外导致基数问题并不难，过去我们已经处理过很多与之相关的问题。&lt;/p&gt;
&lt;h2 id=&quot;heading-8&quot;&gt;基本限制&lt;/h2&gt;
&lt;p&gt;我们部署的最基本的保护层是抓取限制，我们对所有配置的抓取实施。这些是 99% 的应用程序导出指标永远不会超过的合理默认值。&lt;/p&gt;
&lt;p&gt;默认情况下，每个时间序列最多允许 64 个标签，这比大多数指标使用的要多得多。我们还将标签名称和值的长度限制为 128 和 512 个字符，这对于绝大多数刮擦来说也绰绰有余。&lt;/p&gt;
&lt;p&gt;最后，我们默认将 sample_limit 设置为 200 - 因此每个应用程序最多可以导出 200 个时间序列而无需任何操作。&lt;/p&gt;
&lt;p&gt;当有人想要导出更多时间序列或使用更长的标签时会发生什么？他们所要做的就是在他们的抓取配置中明确设置它。&lt;/p&gt;
&lt;p&gt;这些限制是为了防止意外发生，并确保如果任何应用程序正在导出大量时间序列（超过 200 个），负责它的团队就会知道这一点。这有助于我们避免应用程序导出实际上不需要的数千个时间序列的情况。一旦超过 200 个时间序列标记，您应该开始更多地考虑您的指标。&lt;/p&gt;
&lt;h2 id=&quot;ci-&quot;&gt;CI 验证&lt;/h2&gt;
&lt;p&gt;下一层保护是在有人发出拉取请求以为其应用程序添加新的或修改现有的抓取配置时在 CI（持续集成）中运行的检查。&lt;/p&gt;
&lt;p&gt;这些检查旨在确保我们在所有 Prometheus 服务器上都有足够的容量来容纳额外的时间序列，如果该更改会导致收集额外的时间序列。&lt;/p&gt;
&lt;p&gt;例如，如果有人想修改 sample_limit，假设通过将现有限制 500 更改为 2,000，对于具有 10 个目标的抓取，每个目标增加 1,500，有 10 个目标即 10*1,500=15,000 个额外的时间序列可能被刮掉。在允许合并拉取请求之前，我们的 CI 将检查所有 Prometheus 服务器是否有至少 15,000 个时间序列的备用容量。&lt;/p&gt;
&lt;p&gt;这让我们有信心在应用更改后不会使任何 Prometheus 服务器过载。&lt;/p&gt;
&lt;h2 id=&quot;heading-9&quot;&gt;我们的自定义补丁&lt;/h2&gt;
&lt;p&gt;最重要的保护层之一是我们在 Prometheus 之上维护的一组补丁。Prometheus 存储库上有一个开放的拉取请求。该补丁集由两个主要元素组成。首先是允许我们对 TSDB 随时可以存储的时间序列总数实施限制的补丁。在普罗米修斯的标准构建中没有等效的功能，如果任何刮擦产生一些样本，它们将被附加到 TSDB 内的时间序列，如果需要创建新的时间序列。这是带有未设置任何 sample_limit 的抓取的标准流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-10.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过我们的补丁，我们告诉 TSDB 允许在任何时间存储来自所有擦除的总共 N 个时间序列。因此，当 TSDB 被要求追加新样本时，它会首先检查已经存在多少时间序列。&lt;/p&gt;
&lt;p&gt;如果存储的时间序列总数低于配置的限制，那么我们将像往常一样附加样本。与标准 Prometheus 的不同之处在于，当要附加新样本时，TSDB 已经存储了它允许拥有的最大时间序列数。&lt;/p&gt;
&lt;p&gt;然后，我们的修补逻辑将检查我们要追加的样本是否属于已经存储在 TSDB 中的时间序列，或者它是否是需要创建的新时间序列。如果时间序列已经存在于 TSDB 中，那么我们允许继续追加。如果时间序列尚不存在，而我们的追加将创建它（将创建一个新的 memSeries 实例），那么我们将跳过此示例。我们还将向抓取逻辑发信号通知一些样本已被跳过。这是我们的补丁修改后的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.super-ops.com/uploads/post/4MZvVhYyFb1.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过运行“go_memstats_alloc_bytes / prometheus_tsdb_head_series”查询，我们知道每个时间序列需要多少内存（平均），我们也知道每个服务器上有多少物理内存可供 Prometheus 使用，这意味着我们可以轻松计算粗略数量我们可以将时间序列存储在 Prometheus 中，考虑到由于 Prometheus 是用 Go 编写的，因此存在垃圾收集开销：&lt;/p&gt;
&lt;p&gt;Prometheus 可用的内存/每个时间序列的字节数 = 我们的容量&lt;/p&gt;
&lt;p&gt;这并没有捕捉到普罗米修斯的所有复杂性，但给了我们一个粗略的估计，即我们可以期望有多少时间序列的容量。&lt;/p&gt;
&lt;p&gt;通过在我们所有的普罗米修斯服务器上设置这个限制，我们知道它永远不会抓取比我们的内存更多的时间序列。这是我们避免 Prometheus 服务器因内存不足而崩溃的风险的最后一道防线。&lt;/p&gt;
&lt;p&gt;第二个补丁修改了 Prometheus 处理 sample_limit 的方式 - 使用我们的补丁而不是让整个抓取失败，它只是忽略多余的时间序列。如果我们有一个 sample_limit 设置为 200 的抓取，并且应用程序公开了 201 个时间序列，那么除了最后一个时间序列之外的所有时间序列都将被接受。这是具有 sample_limit 选项集的抓取的标准 Prometheus 流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-9.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个抓取要么成功要么失败。Prometheus 简单地计算一次抓取中有多少样本，如果超过 sample_limit 允许的数量，则抓取失败。&lt;/p&gt;
&lt;p&gt;使用我们的自定义补丁，我们不关心刮擦中有多少样本。&lt;/p&gt;
&lt;p&gt;相反，我们在将时间序列附加到 TSDB 时计算时间序列。一旦我们附加了 sample_limit 个样本，我们就开始有选择性了。仅当它们属于已存储在 TSDB 中的时间序列时，才会附加任何多余的样本（达到 sample_limit 之后）。即使在我们超过 sample_limit 之后我们仍然允许追加一些样本的原因是将样本追加到现有时间序列很便宜，它只是添加一个额外的时间戳和值对。&lt;/p&gt;
&lt;p&gt;另一方面，创建新的时间序列要昂贵得多——我们需要分配新的 memSeries 实例和所有标签的副本，并将其保存在内存中至少一个小时。&lt;/p&gt;
&lt;p&gt;这是我们修改后的流程的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog.cloudflare.com/content/images/2023/03/blog-12.png&quot; alt=&quot;图片&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这两个补丁都为我们提供了两个级别的保护。&lt;/p&gt;
&lt;p&gt;TSDB 限制补丁保护整个 Prometheus 不被太多的时间序列过载。这是因为阻止时间序列吃内存的唯一方法是防止它们被附加到 TSDB。一旦他们进入 TSDB 就已经太晚了。&lt;/p&gt;
&lt;p&gt;虽然 sample_limit 补丁阻止了单个抓取使用过多的 Prometheus 容量，这可能导致创建太多的时间序列并耗尽 Prometheus 的总容量（由第一个补丁强制执行），这反过来会影响所有其他抓取，因为某个新的时间系列将不得不被忽略。&lt;/p&gt;
&lt;p&gt;同时，我们的补丁通过将每次抓取的时间序列限制在某个级别，而不是硬性失败并从受影响的抓取中删除所有时间序列，这将意味着失去受影响应用程序的所有可观察性，从而为我们提供优雅的降级。&lt;/p&gt;
&lt;p&gt;还值得一提的是，如果没有我们的 TSDB 总限制补丁，我们可以继续向 Prometheus 添加新的抓取，仅此一项就可能导致耗尽所有可用容量，即使每个抓取都设置了 sample_limit 并且抓取的时间序列少于此限制允许的数量。&lt;/p&gt;
&lt;p&gt;Prometheus 本身导出的额外指标会告诉我们是否有任何抓取超出限制，如果发生这种情况，我们会提醒负责它的团队。&lt;/p&gt;
&lt;p&gt;这也有利于我们进行自助容量管理——不需要团队签署您的分配，如果 CI 检查通过，那么我们就有您的应用程序所需的容量。我们更喜欢优雅降级的主要原因是我们希望我们的工程师能够自信地部署应用程序及其指标，而无需成为 Prometheus 的主题专家。&lt;/p&gt;
&lt;p&gt;这样，即使是最没有经验的工程师也可以开始导出指标，而不必不断地想“这会导致事故吗？” &lt;/p&gt;
&lt;p&gt;另一个原因是试图掌握您的使用情况可能是一项具有挑战性的任务。&lt;br/&gt;
表面上看起来很简单，毕竟您只需要阻止自己创建太多指标、添加太多标签或设置来自不受信任来源的标签值即可。&lt;/p&gt;
&lt;p&gt;实际上，这就像尝试确保您的应用程序不使用太多资源（如 CPU 或内存）一样简单 - 您可以通过简单地分配更少的内存和进行更少的计算来实现这一点。没有比这更容易的了，直到你真正尝试去做。&lt;/p&gt;
&lt;p&gt;任何应用程序为您做的越多，它就越有用，它可能需要的资源就越多。您的需求或客户的需求会随着时间的推移而变化，因此您不能只对它可以消耗多少字节或 CPU 周期划一条线。如果你这样做，这条线最终会被重新绘制，多次。通常，在指标上添加更多标签可以让您获得更多洞察力，因此您尝试监控的应用程序越复杂，就越需要额外的标签。&lt;/p&gt;
&lt;p&gt;除此之外，在大多数情况下我们不会同时看到所有可能的标签值，它通常是所有可能组合的一小部分。&lt;/p&gt;
&lt;p&gt;例如，我们之前在示例中使用的 errors_total 指标可能根本不存在，直到我们开始看到一些错误，即使这样，也可能只会记录一两个错误。&lt;/p&gt;
&lt;p&gt;这适用于我们看到工程师正在使用的许多标签。这意味着查看一个应用程序可能导出多少个时间序列，以及它实际导出多少个，会给我们两个完全不同的数字，这使得容量规划变得更加困难。&lt;/p&gt;
&lt;p&gt;尤其是在处理部分由多个不同团队维护的大型应用程序时，每个团队都从他们的堆栈部分导出一些指标。出于这个原因，我们确实容忍了一定比例的短暂时间序列，即使它们不是普罗米修斯的完美选择并且会消耗我们更多的内存。&lt;/p&gt;
&lt;p&gt;文档最后，我们维护了一组内部文档页面，这些页面试图指导工程师完成抓取和使用指标的过程，其中包含大量特定于我们环境的信息。Prometheus 和 PromQL（普罗米修斯查询语言）在概念上非常简单，但这意味着所有复杂性都隐藏在整个指标管道的不同元素之间的交互中。&lt;/p&gt;
&lt;p&gt;从工程角度管理指标的整个生命周期是一个复杂的过程。您必须在您的应用程序中定义您的指标，使用名称和标签，以便您轻松处理生成的时间序列。&lt;/p&gt;
&lt;p&gt;然后，您必须以正确的方式配置 Prometheus 抓取并将其部署到正确的 Prometheus 服务器。接下来，您可能需要创建记录和/或警报规则以利用您的时间序列。&lt;/p&gt;
&lt;p&gt;最后，您需要创建一个仪表板来可视化所有指标并能够发现趋势。在这个过程的各个阶段都会有陷阱和犯错的余地。我们在之前关于 Prometheus 的博文中介绍了一些最基本的陷阱 -监控我们的监控。在同一篇博客文章中，我们还提到了我们用来帮助​​我们的工程师编写有效的 Prometheus 警报规则的工具之一。&lt;/p&gt;
&lt;p&gt;拥有涵盖所有特定于我们环境和最常见任务的基础知识的良好内部文档非常重要。能够回答“如何做 IX？” 无需等待主题专家，让每个人都更有效率，行动更快，同时也避免普罗米修斯专家一遍又一遍地回答相同的问题。&lt;/p&gt;
&lt;h2 id=&quot;heading-10&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;Prometheus 是一个出色且可靠的工具，但处理高基数问题可能具有挑战性，尤其是在许多不同的应用程序被同一个 Prometheus 服务器抓取的环境中。过去，我们在 Prometheus 实例过载方面遇到过很多问题，并开发了许多工具来帮助我们处理这些问题，包括自定义补丁。但解决高基数问题的关键是更好地理解 Prometheus 的工作原理以及哪种使用模式会出现问题。更好地了解 Prometheus 内部结构使我们能够维护一个快速可靠的可观察性平台，而无需过多的繁文缛节，而我们围绕它开发的工具（其中一些是开源的）可帮助我们的工程师避免最常见的陷阱并自信地进行部署.&lt;/p&gt;

        &lt;/article&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>072c53f8a083042f8f5a4368c1109b29</guid>
<title>2 万多行MyBatis源码，你知道里面用了多少种设计模式吗？</title>
<link>https://toutiao.io/k/k0nr4fi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;outer&quot; label=&quot;edit by 135editor&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span&gt;在MyBatis的两万多行的框架源码中，使用了大量的设计模式对工程架构中的复杂场景进行解耦，这些设计模式的巧妙使用是整个框架的精华。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过整理，大概有以下设计模式，如图1所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30866425992779783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPiaEqmgIIcViaM4eYMkOt9WnRzRXs01d1kmrUofo9QWC3WNhzx3Y4Qwicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：创建型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;工厂模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SqlSessionFactory 的结构如图2所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6263537906137184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtiaJWAlfP62qh4yxDuicXwMG2EVEk7j1ibICSwFicOJ893or1ZbKlu2U7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工厂模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;简单工厂是一种创建型模式，在父类中提供一个创建对象的方法，允许子类决定实例对象的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory 是获取会话的工厂，每次使用MyBatis 操作数据库时， 都会开启一个新的会话。在会话工厂的实现中，SqlSessionFactory 负责获取数据源环境配置信息、构建事务工厂和创建操作SQL 的执行器，最终返回会话实现类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类设计：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactory、ObjectFactory、MapperProxyFactory 和DataSourceFactory。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;单例模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Configuration 单例配置类的结构如图3所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6967509025270758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPDiaQUbbXnHeQgH1Iia8sR2nhwlWgpRIBHVp8hpkTkPwnmAMr9dV606dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;单例模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种创建型模式，能够保证一个类只有一个实例，并且提供一个访问该实例的全局节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Configuration 是一个大单例，贯穿整个会话周期，所有的配置对象（如映射、缓存、入参、出参、拦截器、注册机和对象工厂等）都在Configuration 配置项中初始化， 并且随着SqlSessionFactoryBuilder 构建阶段完成实例化操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;ErrorContext、LogFactory 和Configuration。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;建造者模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ResultMap 建造者模式的结构如图4所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.41155234657039713&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPKDXYD8OEicS83k3dPIkxUI9fKrcZDwQSd81u8QyGRaDRIpYYqLO3ZUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;建造者模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;使用多个简单的对象一步一步地构建成一个复杂的对象，提供了一种创建对象的最佳方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;建造者模式在MyBatis 中使用了大量的XxxxBuilder，将XML 文件解析到各类对象的封装中，使用建造者及建造者助手完成对象的封装。它的核心目的是不希望把过多的关于对象的属性设置写到其他业务流程中，而是用建造者方式提供最佳的边界隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XML StatementBuilder 和CacheBuilder。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：结构型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;适配器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;日志实现类的结构如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7942238267148014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROP5r6icibZlCbnVlnVlHrFicypRCF1icicW8CrQQHOKNxxmNVECfzUiavHJnqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;适配器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能使接口不兼容的对象也可以相互合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;正是因为有太多的日志框架，包括Log4j、Log4j2 和Slf4J 等，而这些日志框架的使用接口又各有差异，为了统一这些日志框架的接口，MyBatis 定义了一套统一的接口，为所有的其他日志框架的接口做相应的适配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要集中在对Log 日志的适配上。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;代理模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;代理模式的实现结构如图6所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4747292418772563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPknMgl3bia1npjZwlyeiaFGnPDLcOhR8jicZYvU5e1YiaAOpiaRMD8U9jOTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;代理模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，能够提供对象的替代品或占位符。代理控制元对象的访问，并且允许在将请求提交给对象前进行一些处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;没有代理模式就不存在各类框架。就像MyBatis 中的MapperProxy 实现类， 代理工厂实现的功能就是完成DAO 接口的具体实现类的方法，配置的任何一个DAO 接口调用的CRUD 方法，都会被MapperProxy 接管，调用到方法执行器等，并返回最终的数据库执行结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;DriverProxy、Plugin、Invoker 和MapperProxy。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;组合模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;解析节点类的结构如图7所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8971119133574007&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPqPgVVfn9s5K9fVN8zR9WKLyoYrZSibrkZMaSGd6p3uW40QYIPcs2KBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;组合模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型模式，可以将对象组合成树形结构以表示“部分—整体” 的层次结构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis XML 动态的SQL 配置中，共提供了9 种标签（trim、where、set、foreach、if、choose、when、otherwise 和bind），使用者可以组合出各类场景的SQL 语句。而SqlNode 接口的实现就是每个组合结构中的规则节点，通过规则节点的组装，完成规则树组合模式的使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;主要体现在对各类SQL 标签的解析上，以实现SqlNode 接口的各个子类为主。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;装饰器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;二级缓存装饰器的实现结构如图8所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5451263537906137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPtAiafB9fJsu1icgOrb2mUgkh6JTG9ibUXvjOzGNL9OLN3rSUqZLQmmUibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;装饰器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种结构型设计模式，允许将对象放入包含行为的特殊封装对象中， 为元对象绑定新的行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;MyBatis 的所有SQL 操作都是经过SqlSession 调用SimpleExecutor 完成的， 而一级缓存的操作也是在简单执行器中处理的。这里的二级缓存因为是基于一级缓存刷新的，所以在实现上，通过创建一个缓存执行器，包装简单执行器的处理逻辑，实现二级缓&lt;/span&gt;&lt;span&gt;存操作。这里用到的就是装饰器模式，也叫俄罗斯套娃模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：行为型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;模板模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;SQL 执行模板模式如图9所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7003610108303249&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPFQ2KK6dSZ7pdrzxuG5picTMrwJB8ZFlICSibwQpSfs3HtAcEpnNoibpCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;模板模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，在超类中定义了一个算法的框架，允许子类在不修改结构的情况下重写算法的特定步骤。场景介绍：存在一系列可被标准定义的流程，并且流程的步骤大部分采用通用逻辑，只有一小部分是需要子类实现的，通常采用模板模式来定义这个标准的流程。就像MyBatis 的BaseExecutor 就是一个用于定义模板模式的抽象类，在这个类中把查询、修改的操作都定义为一套标准的流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;BaseExecutor、SimpleExecutor 和BaseTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;策略模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;多类型处理器策略模式的结构如图10所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.023465703971119&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPdWHmfGsN5DOnkMY7K89WKp0E0Otoqf3rSR2eZRnG5pGcXKicaUlegUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;策略模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能定义一系列算法，并将每种算法分别放入独立的类中，从而使算法的对象能够互相替换。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在MyBatis 处理JDBC 执行后返回的结果时，需要按照不同的类型获取对应的值，这样就可以避免大量的if 判断。所以，这里基于TypeHandler 接口对每个参数类型分别做了自己的策略实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PooledDataSource、UnpooledDataSource、BatchExecutor、ResuseExecutor、SimpleExector、CachingExecutor、LongTypeHandler、StringTypeHandler 和DateTypeHandler。&lt;/span&gt;&lt;/p&gt;&lt;section yne-bulb-block=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;▊ &lt;strong&gt;&lt;span&gt;迭代器模式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;拆解字段解析实现的结构如图11所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8194945848375451&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/moaR7nLaQrFbZ79iaJB6uqGWs9nkpHROPicHzHb7tXEM5PnZcyJXOYNiaM6CzDLqkOraWNzL5srByZ91Sibr0tCVlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/p&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;迭代器模式：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是一种行为型模式，能在不暴露集合底层表现形式的情况下遍历集合中的所有元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;场景介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer 用于MyBatis 的MetaObject 反射工具包下，用来解析对象关系的迭代操作。这个类在MyBatis 中使用得非常频繁，包括解析数据源配置信息并填充到数据源类上，同时参数的解析、对象的设置都会使用这个类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同类场景：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;PropertyTokenizer。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;117920&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;strong data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过梳理，MyBatis大约运用了10种左右设计模式。可以说，复杂且优秀的ORM 框架源码在设计和实现的过程中都会使用大量的设计模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在解决复杂场景的问题时，需要采用分治、抽象的方法，运用设计模式和设计原则等相关知识，把问题合理切割为若干子问题，以便加以理解和解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;学习源码远不是只是为了应付面试，更重要的是学习优秀框架在复杂场景下的解决方案。通过学习这些优秀的方案技术，可以提高对技术设计和实现的理解，扩展编码思维，积累落地经验。只有经过这样长期的积累，我们才更有可能成为优秀的高级工程师和架构师。&lt;/span&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;7&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p data-autoskip=&quot;1&quot;&gt;本文节选自《手写MyBatis：渐进式源码实践》一书，欢迎阅读本书了解更多相关内容！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;4.75503355704698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0nk2GSKyCib2Rk8UcW0bPHQLgcy4eEYr5Dg6G9zwumjfHFZTow1HudAXRubX7MJelvOwFP11zGEMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0413793103448277&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SfAHMuUxqJ0nk2GSKyCib2Rk8UcW0bPHQeSWslibqiatCG7JGq2qTuyoIiaNKyhQNGmRZGQ9eLCYQJxQOiaxTMO2ZdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;290&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;限时五折优惠，快快扫码抢购吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;本次继续送书3本。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;评论区留言，点赞最高者分别赠送一本，为了给其他同学更多机会，上一次留言中奖者本次不做统计。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fgnkxfGnnkTMNtGy7KWfCrdJibAYY6HtIGhhtVOFQXzkE5GcmZIhTLgxggMlCe3oMwqKNesBDoU7kfgzFHuxyeA/640?wx_fmt=gif&quot; data-w=&quot;160&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文，查看本书详情！&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>711b63cc398fb47516ebdcdcd7d21411</guid>
<title>美团自动量化工具 MTPQ 首次发布，最高加速 94%</title>
<link>https://toutiao.io/k/lroh3ln</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;nextStep-modal-body&quot;&gt;
&lt;p&gt;验证码将拨打您的电话告知，您可能会接到&lt;/p&gt;
&lt;p&gt;010、024、029、0551等开头的来电，请放&lt;/p&gt;
&lt;p&gt;心接听&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b61eaba73f1f28545189c1cfd6d8d6cb</guid>
<title>实战，一个高扩展、可视化低代码前端，详实、完整</title>
<link>https://toutiao.io/k/acf822h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RxEditor是一款开源企业级可视化低代码前端，目标是可以编辑所有 HTML 基础的组件。比如支持 React、VUE、小程序等，目前仅实现了 React 版。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RxEditor运行快照： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5002613695765813&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicI1xQ2HojgFfmH260ovc2KT9FvdFRQ81C5DJiaibckwx77N6UwXjyPehw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1913&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：&lt;span&gt;github.com/rxdrag/rxed…&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示地址（ Vercel 部署，需要科学的方法才能访问）：&lt;span&gt;rxeditor.vercel.app/&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍RxEditor 设计实现方法，尽可能包括技术选型、软件架构、具体实现中碰到的各种小坑、预览渲染、物料热加载、前端逻辑编排等内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;注：为了方便理解，文中引用的代码滤除了细节，是实际实现代码的简化版&lt;/em&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计原则&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;尽量减少对组件的入侵，最大程度使用已有组件资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置优先，脚本辅助。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础功能原子化，组合式设计。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物料插件化、逻辑组件化，尽可能动态插入系统。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础原理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目的设计目标，是能够通过拖拽的方式操作基于 HTML 制作的组件，如：调整这些组件的包含关系，并设置组件属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是 React、Vue、Angluar、小程序，还是别的类似前端框架，最终都是要把 JS 组件，以DOM节点的形式渲染出来。 &lt;img data-ratio=&quot;0.6015625&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicSP3PqBdrBx5sB31CUtx3l7b8Mro5g6onOjlM7oPOMNqt22Frd5QQeQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;384&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器（RxEditor）要维护一个树形模型，这个模型描述的是组件的隶属关系，以及 props。同时还能跟 dom 树交互，通过各种 dom 事件，操作组件模型树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里关键的一个点是，编辑器需要知道 dom 节点跟组件节点之间的对应关系。在不侵入组件的前提下，并且还要忽略前端库的差异，比较理想的方法是给 dom 节点赋一个特殊属性，并跟模型中组件的 id 对应，在 RxEditor 中，这个属性是rx-id，比如在dom节点中这样表示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;div rx-id=&quot;one-uuid&quot;&amp;gt;  &lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器监听 dom 事件，通过事件的 target 的 rx-id 属性，就可以识别其在模型中对应组件节点。也可以通过 &lt;code&gt;document.querySelector([rx-id=&quot;${id}&quot;])&lt;/code&gt;方法，查找组件对应的 dom 节点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还加了 rx-node-type 跟 rx-status 这两个辅助属性。rx-node-type 属性主要用来识别是工具箱的Resource、画布内的普通节点还是编辑器辅助组件，rx-status 计划是多模块编辑使用，不过目前该功能尚未实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rx-id 算是设计器的基础性原理，它给设计器内核抹平了前端框架的差异，几乎贯穿设计器的所有部分。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Schema 定义&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑器操作的是JSON格式的组件树，设计时，设计引擎根据这个组件树渲染画布；预览时，执行引擎根据这个组件树渲染实际页面；代码生成时，可以把这个组件树生成代码；保存时，直接把它序列化存储到数据库或者文件。这个组件树是设计器的数据模型，通常会被叫做 Schema。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像阿里的 formily，它的Schema 依据的是JSON Schema 规范，并在上面做了一些扩展，他在描述父子关系的时候，用的是properties键值对：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{ &amp;lt;---- RecursionField(条件：&lt;span&gt;object&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;object&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;properties&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;username&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;phone&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-validator&quot;&lt;/span&gt;:&lt;span&gt;&quot;phone&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;email&quot;&lt;/span&gt;:{ &amp;lt;---- RecursionField(条件：&lt;span&gt;string&lt;/span&gt;；渲染权：RecursionField)&lt;br/&gt;      &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-component&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-validator&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    ......&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用键值对的方式存子组件（children）有几个明显的问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用这样的方式渲染预览界面时，一个字段只能绑定一个控件，无法绑定多个，因为key值唯一。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;键值对不携带顺序信息，存储到数据库JSON类型的字段时，具体的后端实现语言要进行序列化与反序列化的操作，不能保证顺序，为了避免出问题，不得不加一个类似index的字段来记录顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计器引擎内部操作时，用的是数组的方式记录数据，传输到后端存储时，不得不进行转换。 鉴于上述问题，RxEditor采用了数组的形式来记录Children，与React跟Vue控件比较接近的方式：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeMeta&amp;lt;IField = any, IReactions = any&amp;gt; {&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  props?: {&lt;br/&gt;    [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;?: IField,&lt;br/&gt;  &lt;span&gt;&quot;x-reactions&quot;&lt;/span&gt;?: IReactions,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeSchema&amp;lt;IField = any, IReactions = any&amp;gt; &lt;br/&gt;  &lt;span&gt;extends&lt;/span&gt; INodeMeta&amp;lt;IField, IReactions&amp;gt; {&lt;br/&gt;  children?: INodeSchema[]&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: INodeSchema | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面formily的例子，相应转换成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{ &lt;br/&gt;  &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Profile&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;    &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;object&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;user&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;chilren&quot;&lt;/span&gt;:[&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;username&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;phone&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;componentName&quot;&lt;/span&gt;:&lt;span&gt;&quot;Input&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;:{&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt;:&lt;span&gt;&quot;string&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;rule&quot;&lt;/span&gt;:&lt;span&gt;&quot;email&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 x-field 是表单数据的定义，x-reactions 是组件控制逻辑，通过前端编排来实现，这两个后面会详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是卡槽（slots），这个是 RxEditor 的原创设计，原生 Schema 直接支持卡槽，可以很大程度上支持现有组件，比如很多 React antd 组件，不需要封装就可以直接拉到设计器里来用，关于卡槽后面还会有更详细的介绍。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组件形态&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目中的前端组件，要在两个地方渲染，一是设计引擎的画布，另一处是预览页面。这两处使用的是不同渲染引擎，对组件的要求也不一样，所以把组件分定义为两个形态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计形态，在设计器画布内渲染，需要提供ref或者转发rx-id，有能力跟设计引擎交互。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;预览形态，预览引擎使用，渲染机制跟运行时渲染一样。相当于普通的前端组件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计形态的组件跟预览形态的组件，对应的是同一份schema，只是在渲染时，使用不同的组件实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，以React为例，详细介绍组件设计形态与预览形态之间的区别与联系，同时也介绍了如何制作设计形态的组件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有 React ref 的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分组件是最简单的，直接拿过来使用就好，这些组件的设计形态跟预览形态是一样的，在设计引擎这样渲染：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentDesignerView = memo(&lt;span&gt;(&lt;span&gt;props: { nodeId: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { nodeId } = props;&lt;br/&gt;  &lt;span&gt;//获取数据模型树中对应的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; node = useTreeNode(nodeId);&lt;br/&gt;  &lt;span&gt;//通过ref，给 dom 赋值rx-id&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; handleRef = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;undefined&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    element?.setAttribute(&lt;span&gt;&quot;rx-id&quot;&lt;/span&gt;, node.id)&lt;br/&gt;  }, [node.id])&lt;br/&gt;  &lt;span&gt;//拿到设计形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = useDesignComponent(node?.meta?.componentName);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&amp;lt;Component ref={handleRef} {...realProps} &amp;gt;&lt;br/&gt;  &amp;lt;&lt;span&gt;/Component&amp;gt;)&lt;br/&gt;}))&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要 rx-id 被添加到 dom 节点上，就建立了 dom 与设计器内部数据模型的联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预览引擎的渲染相对更简单直接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ComponentViewProps = {&lt;br/&gt;  node: IComponentRenderSchema,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentView = memo((&lt;br/&gt;  props: ComponentViewProps&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { node, ...other } = props&lt;br/&gt;  &lt;span&gt;//拿到预览形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = usePreviewComponent(node.componentName)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Component {...node.props} {...other}&amp;gt;&lt;br/&gt;      {&lt;br/&gt;        node.children?.map(&lt;span&gt;&lt;span&gt;child&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (&amp;lt;ComponentView key={child.id} node={child} /&amp;gt;)&lt;br/&gt;         })&lt;br/&gt;      }&lt;br/&gt;    &amp;lt;&lt;span&gt;/Component&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;无ref，但可以把未知属性转发到合适的dom节点上&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个React组件，实现方式是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentA = &lt;span&gt;(&lt;span&gt;props&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {propA, propB, ...rest} = props&lt;br/&gt;    ...&lt;br/&gt;    return(&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; {&lt;span&gt;...rest&lt;/span&gt;}&amp;gt;&lt;/span&gt;&lt;br/&gt;            ...&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;    &lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 propA 跟 propB，其它的属性被原封不动的转发到了根div上，这样的组件在设计引擎里面可这样渲染：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentDesignerView = memo(&lt;span&gt;(&lt;span&gt;props: { nodeId: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { nodeId } = props;&lt;br/&gt;  &lt;span&gt;//获取数据模型树中对应的节点&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; node = useTreeNode(nodeId);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//拿到设计形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = useDesignComponent(node?.meta?.componentName);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&amp;lt;Component rx-id={node.id} {...node?.meta?.props} &amp;gt;&lt;br/&gt;  &amp;lt;&lt;span&gt;/Component&amp;gt;)&lt;br/&gt;}))&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样的方式，rx-id 被同样添加到 dom 节点上，从而建立了数据模型与 dom之间的关联。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过组件 id 拿到 ref&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的组件，既不能提供合适的ref，也不能转发rx-id，但是这个组件有id属性，可以通过唯一的id，来获得对应 dom 的 ref：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export const WrappedComponentA = forwardRef((props, ref)=&amp;gt;{&lt;br/&gt;    const node = useNode()&lt;br/&gt;    useLayoutEffect(() =&amp;gt; {&lt;br/&gt;      const element = node?.id ? document.getElementById(node?.id) : null&lt;br/&gt;      if (isFunction(ref)) {&lt;br/&gt;        ref(element)&lt;br/&gt;      }&lt;br/&gt;    }, [node?.id, ref])&lt;br/&gt;    return(&lt;br/&gt;       &amp;lt;ComponentA id={node?.id} {...props}/&amp;gt;&lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取成高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;forwardRefById&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLInputElement&amp;gt;&lt;span&gt;(&lt;span&gt;(props: any, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; node = useNode()&lt;br/&gt;    useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; element = node?.id ? &lt;span&gt;document&lt;/span&gt;.getElementById(node?.id) : &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isFunction(ref)) {&lt;br/&gt;        ref(element)&lt;br/&gt;      }&lt;br/&gt;    }, [node?.id, ref])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;WrappedComponent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{node?.id}&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;} /&amp;gt;&lt;/span&gt;&lt;br/&gt;  }))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRefById(ComponentA)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这种方式时，要确保组件的id没有其它用途。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;嵌入隐藏元素&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个组件，通过上述方式安插 rx-id 都不合适，这个组件恰好有 children 的话，可以在 children 里面插入一个隐藏元素，通过隐藏元素 dom 的parentElement 获取 ref，直接上高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; HiddenElement = styled.div&lt;span&gt;`&lt;br/&gt;  display: none;&lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;forwardRefByChildren&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMElement&amp;gt;&lt;span&gt;(&lt;span&gt;(props: any, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { children, ...rest } = props&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handleRefChange = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (isFunction(ref)) {&lt;br/&gt;        ref(element?.parentElement)&lt;br/&gt;      }&lt;br/&gt;    }, [ref])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;WrappedComponent&lt;/span&gt; {&lt;span&gt;...rest&lt;/span&gt;}&amp;gt;&lt;/span&gt;&lt;br/&gt;      {children}&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;HiddenElement&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{handleRefChange}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;WrappedComponent&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  }))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRefByChildren(ComponentA)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;调整 ref 位置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的组件，提供了 ref，但是 ref 位置并不合适，基于 ref 指示的 dom 节点画编辑时的轮廓线的话，会显的别扭，有个这样实现的组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentA = forwardRef&amp;lt;HTMElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&amp;lt;div style={padding:16}&amp;gt;&lt;br/&gt;        &amp;lt;div ref={ref}&amp;gt;&lt;br/&gt;            ...&lt;br/&gt;        &amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;)&lt;br/&gt;}&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编辑时这个组件的轮廓线，会显示在内层 div，距离外层 div 差了16个像素。为了把rx-id插入到外层 div， 加入一个转换 ref 的高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 传出真实ref用的回调&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; Callback = &lt;span&gt;(&lt;span&gt;element?: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; HTMLElement | &lt;span&gt;undefined&lt;/span&gt; | &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; defaultCallback = &lt;span&gt;(&lt;span&gt;element?: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; element;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;switchRef&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent, callback: Callback = defaultCallback&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLInputElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handleRefChange = useCallback(&lt;span&gt;(&lt;span&gt;element: HTMLElement | &lt;span&gt;null&lt;/span&gt;&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isFunction(&lt;span&gt;ref&lt;/span&gt;)&lt;/span&gt;) {&lt;br/&gt;        ref(&lt;span&gt;callback(&lt;span&gt;element&lt;/span&gt;)&lt;/span&gt;)&lt;br/&gt;      }&lt;br/&gt;    }, [ref]&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;lt;WrappedComponent ref={handleRefChange} {...props} /&amp;gt;&lt;br/&gt;  }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;WrappedComponentA&lt;/span&gt; = &lt;span&gt;forwardRefByChildren&lt;/span&gt;(&lt;span&gt;ComponentA, element=&amp;gt;element?.parentElement&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;组件外层包一个 div&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个组件，既不能提供合适的ref，不能转发rx-id，没有id属性，也没有children， 可以在组件外层直接包一个 div，使用div 的 ref ：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; WrappedComponentA = forwardRef(&lt;span&gt;(&lt;span&gt;props, ref&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{ref}&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;ComponentA&lt;/span&gt; {&lt;span&gt;...props&lt;/span&gt;}/&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;           &lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提取成高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ReactComponent = React.FC&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | React.ComponentClass&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;wrapWithRef&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent&lt;/span&gt;):&lt;span&gt;ReactComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLDivElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &amp;lt;div ref = {ref}&amp;gt;&lt;br/&gt;         &amp;lt;WrappedComponent {...props} /&amp;gt;&lt;br/&gt;        &amp;lt;/div&lt;br/&gt;    }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;WrappedComponentA&lt;/span&gt; = &lt;span&gt;wrapWithRef&lt;/span&gt;(&lt;span&gt;ComponentA&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个实现方式有个明显的问题，凭空添加了一个div，隔离了 css 上下文，为了保证设计器的显示效果跟预览时一样，所见即所得，需要在组件的预览形态上也加一个div，就是说直接修改原生组件，设计形态跟预览形态都使用转换后的组件。即便是这样，也像做不可描述的事情时带T一样，有些许不爽。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;带卡槽（slots）的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 中有卡槽，分为具名卡槽跟不具名卡槽，不具名卡槽就是 children。React 中没有明确的卡槽概念，但是React.ReactNode 类型的 props 就相当于具名卡槽了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在可视化设计器中，是需要卡槽的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;卡槽可以非常清晰的区分组建的各个区域，并且能很好地复用逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可视化编辑器中的拖拽，是把组件拖入（拖出）children（非具名卡槽），对于具名卡槽，这种普通拖放是无能无力的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果schema不支持卡槽，通常会特殊处理一下组件，就是在组件外封装一层，并且还用不了高阶组件。比如 antd 的 List 组件，它有 header 跟 footer 两个 React.ReactNode 类型的属性，这就是两个卡槽。要想在设计器中使用这两个卡槽，设计形态的组件一般会这么写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { List &lt;span&gt;as&lt;/span&gt; AntdList, ListProps } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;antd&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ListAddonProps = {&lt;br/&gt;    hasHeader?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;    hasFooter?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; List = memo(forwardRef&amp;lt;HTMLDivElement&amp;gt;((&lt;br/&gt;    props: ListProps&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; &amp;amp; ListAddonProps, ref) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {hasHeader, hasFooter, children, ...rest} = props&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; footer = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//这里根据Schema树和children构造footer卡槽&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;    }, [children, hasFooter])&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; header = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//这里根据Schema树和children构造header卡槽&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;    }, [children, hasHeader])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&amp;lt;AntdList header = {header} header={footer} {...rest}}/&amp;gt;)&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件的设计形态也需要类似的封装，这里就不详细展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方式，相当于把所有的具名卡槽转换成非具名卡槽，然后在渲染的时候，再根据配置把非具名卡槽解析成具名卡槽。hasHeader这类属性不设置，也能解析，只是换了种实现方式，并无本质区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥有具名卡槽的前端库太多了，每一种组件都这样处理，复杂而繁琐，并且违背了设计原则：“尽量减少对组件的入侵，最大程度使用已有组件资源”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个因素，把卡槽（slots）放入了 schema，只需要在渲染的时候跟非具名卡槽稍微做一下区别，就可以插入插槽：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ComponentViewProps = {&lt;br/&gt;  node: IComponentRenderSchema,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentView = memo((&lt;br/&gt;  props: ComponentViewProps&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { node, ...other } = props&lt;br/&gt;  &lt;span&gt;//拿到预览形态的组件&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; Component = usePreviewComponent(node.componentName)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;//渲染卡槽&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; slots = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; slts: { [key: &lt;span&gt;string&lt;/span&gt;]: React.ReactElement } = {}&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; name of &lt;span&gt;Object&lt;/span&gt;.keys(node?.slots || {})) {&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; slot = node?.slots?.[name]&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (slot) {&lt;br/&gt;              slts[name] = &amp;lt;ComponentView node={slot} /&amp;gt;&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; slts&lt;br/&gt;  }, [node?.slots])&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Component {...node.props} {...slots} {...other}&amp;gt;&lt;br/&gt;      {&lt;br/&gt;        node.children?.map(&lt;span&gt;&lt;span&gt;child&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; (&amp;lt;ComponentView key={child.id} node={child} /&amp;gt;)&lt;br/&gt;         })&lt;br/&gt;      }&lt;br/&gt;    &amp;lt;&lt;span&gt;/Component&amp;gt;&lt;br/&gt;  )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是预览形态的渲染代码，设计形态类似，此处不详细展开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用这样的方式处理卡槽，卡槽是不能被拖入的，只能通过属性面板的配置打开或者关闭卡槽： &lt;img data-ratio=&quot;0.7617328519855595&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicBhIuWJD1Qiblf0icIib7VrMHAUur7fXT9Q6moRzSHnXcicMhu9pAM8CpZA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;277&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，卡槽只能是一个独立节点，不能是节点数组，相当于把React.ReactNode转换成了React.ReactElement，不过这个转换对用户体验的影响并不大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要独立制作设计形态的组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述各种高阶组件、schema原生支持的slots，已有的组件，基本上不需要修改就可以纳入可视化设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，也有例外。有些组件，还是需要独立制作设计形态。需要独立制作设计形态的组件，一般基于两个方面的考虑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;用户体验；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务逻辑复杂。 在用户体验方面，看一个例子，antd 的 Button 组件。Button的使用代码：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&quot;&lt;span&gt;primary&lt;/span&gt;&quot;&amp;gt;&lt;br/&gt;    &lt;span&gt;Primary&lt;/span&gt; &lt;span&gt;Button&lt;/span&gt;&lt;br/&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组件的children可以是 text 文本，text 文本不是一个组件，在编辑器中式很难被拖入的，要想拖入的话，可以加一个文本类型的组件 Text：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Button&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;&quot;primary&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;Primary Button&lt;span&gt;&amp;lt;/&lt;span&gt;Text&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;Button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就解决了拖放问题，并且Text组件可以在很多地方被使用，也不算增加实体。但是这样每个Button 嵌套一个 Text方式，会大量增加设计器画布中控件的数量，用户体验并不好。这种情况，最好重写Buton组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; {Button &lt;span&gt;as&lt;/span&gt; AntdButton, ButtonProps} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;antd&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; Button = memo(forwardRef&amp;lt;HTMLElement&amp;gt;(&lt;br/&gt;    &lt;span&gt;(&lt;span&gt;props: ButtonProps&amp;amp;{title?:&lt;span&gt;string&lt;/span&gt;}}, ref&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; {title, ...rest} = props&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;  (&amp;lt;AntdButton {...rest}&amp;gt;&lt;br/&gt;        {title}&lt;br/&gt;    &amp;lt;&lt;span&gt;/AntdButton&amp;gt;)&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步提取为高阶组件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;mapComponent&lt;/span&gt;(&lt;span&gt;WrappedComponent: ReactComponent, maps: { [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;string&lt;/span&gt; }&lt;/span&gt;): &lt;span&gt;ReactComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; memo(forwardRef&amp;lt;HTMLElement&amp;gt;&lt;span&gt;(&lt;span&gt;(&lt;span&gt;props: &lt;span&gt;any&lt;/span&gt;, ref&lt;/span&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; mapedProps = useMemo(&lt;span&gt;() =&amp;gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; newProps = {} &lt;span&gt;as&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;&lt;span&gt;const&lt;/span&gt; key of &lt;span&gt;Object&lt;/span&gt;.keys(&lt;span&gt;props || {}&lt;/span&gt;)&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;maps[key]&lt;/span&gt;) {&lt;br/&gt;          newProps[maps[key]] = props?.[key]&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          newProps[key] = props?.[key]&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; newProps&lt;br/&gt;    }, [props]&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;&lt;br/&gt;      &amp;lt;WrappedComponent ref={ref} {...mapedProps} /&amp;gt;&lt;br/&gt;    &lt;/span&gt;)&lt;br/&gt;  }&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;Button&lt;/span&gt; = &lt;span&gt;mapComponent&lt;/span&gt;(&lt;span&gt;AntdButton, { title: &#x27;children&#x27; }&lt;/span&gt;)&lt;br/&gt;复制代码&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务逻辑复杂的例子，典型的是table，设计形态跟预览形态的区别：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计形态&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3277693474962064&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicmYRmJ3XicWDCu3cIvib2Gjts1VLpphaibMgFexXJGGnesxaX9McExltOg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;659&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预览形态&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4746268656716418&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpic2icdQp0DrWBIStc4w1dT6rbpG1ib57fmkjH6zaaPdia9Rxcj1HfkMjgJA/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种组件，是需要特殊制作的，没有什么简单的办法，具体实现请参考源码。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Material，物料的定义&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Schema，只是用来描述一个组件，这个组件相关的配置，比如多语言信息、在工具箱中的图标、编辑规则（比如：它可以被放置在哪些组件下，不能被放在什么组件下）等等这些信息，需要一个配置来描述，这个就是物料的定义。具体定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IBehaviorRule {&lt;br/&gt;  disabled?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//默认false&lt;/span&gt;&lt;br/&gt;  selectable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可选中，默认为true&lt;/span&gt;&lt;br/&gt;  droppable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction&lt;span&gt;//是否可作为拖拽容器，默认为false&lt;/span&gt;&lt;br/&gt;  draggable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可拖拽，默认为true&lt;/span&gt;&lt;br/&gt;  deletable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可删除，默认为true&lt;/span&gt;&lt;br/&gt;  cloneable?: &lt;span&gt;boolean&lt;/span&gt; | AbleCheckFunction &lt;span&gt;//是否可拷贝，默认为true&lt;/span&gt;&lt;br/&gt;  resizable?: IResizable | &lt;span&gt;(&lt;span&gt;(&lt;span&gt;engine?: IDesignerEngine&lt;/span&gt;) =&amp;gt; IResizable&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;moveable&lt;/span&gt;?: &lt;span&gt;IMoveable&lt;/span&gt; | (&lt;span&gt;(&lt;span&gt;engine?: IDesignerEngine&lt;/span&gt;) =&amp;gt; IMoveable&lt;/span&gt;)  // 可用于自由布局&lt;br/&gt;  &lt;span&gt;allowChild&lt;/span&gt;?: (&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  allowAppendTo?: &lt;span&gt;(&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  allowSiblingsTo?: &lt;span&gt;(&lt;span&gt;target: ITreeNode, engine?: IDesignerEngine,&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;br/&gt;  noPlaceholder?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  noRef?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  lockable?: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IComponentConfig&amp;lt;ComponentType = any&amp;gt; {&lt;br/&gt;  &lt;span&gt;//npm包名 生成代码用&lt;/span&gt;&lt;br/&gt;  packageName?: &lt;span&gt;string&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;//组件名称，要唯一，可以加点号：.&lt;/span&gt;&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//组件的预览形态&lt;/span&gt;&lt;br/&gt;  component: ComponentType,&lt;br/&gt;  &lt;span&gt;//组件的设计形态&lt;/span&gt;&lt;br/&gt;  designer: ComponentType,&lt;br/&gt;  &lt;span&gt;//组件编辑规则，比如是否能作为另外组件的children&lt;/span&gt;&lt;br/&gt;  behaviorRule?: IBehaviorRule&lt;br/&gt;  &lt;span&gt;//右侧属性面板的配置Schema&lt;/span&gt;&lt;br/&gt;  designerSchema?: INodeSchema&lt;br/&gt;  &lt;span&gt;//组件的多语言资源&lt;/span&gt;&lt;br/&gt;  designerLocales?: ILocales&lt;br/&gt;  &lt;span&gt;//组件设计时的特殊props配置，比如Input组件的readOnly属性&lt;/span&gt;&lt;br/&gt;  designerProps?: IDesignerProps&lt;br/&gt;  &lt;span&gt;//组件在工具箱中的配置&lt;/span&gt;&lt;br/&gt;  resource?: IResource&lt;br/&gt;  &lt;span&gt;//卡槽slots用到的组件，值为true时，用缺省组件DefaultSlot, &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// string时，存的是已经注册过的component resource名字&lt;/span&gt;&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: IComponentConfig | &lt;span&gt;true&lt;/span&gt; | &lt;span&gt;string&lt;/span&gt; | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;//右侧属性面板用的多语言资源&lt;/span&gt;&lt;br/&gt;  toolsLocales?: ILocales，&lt;br/&gt;  &lt;span&gt;//右侧属性面板用到的扩展组件。是的，组合式设计，都可以配置&lt;/span&gt;&lt;br/&gt;  tools?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: ComponentType | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IBehaviorRule接口定义组建的编辑规则，随着项目的逐步完善，这个接口大概率会变化，这里也没必要在意这么细节的东西，要重点关注的是IComponentConfig接口，这就是一个物料的定义，泛型使用的ComponetType是为了区别前端差异，比如React的物料定义是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; ReactComponent = React.FC&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; &lt;br/&gt;    | React.ComponentClass&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt; | &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IComponentMaterial &lt;br/&gt;    &lt;span&gt;extends&lt;/span&gt; IComponentConfig&amp;lt;ReactComponent&amp;gt; {&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物料如何使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物料定义，包含了一个组件的所有内容，直接注册进设计器，就可以使用。后面会有相关讲述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物料的热加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个不想热加载的低代码平台，不是一个有出息的平台。但是，这个版本并没有来得及做热加载，后续版本会补上。这里简单分享前几个版本的热加载经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个物料的定义是一个js对象，只要能拿到这个队形，就可以直接使用。热加载要解决的问题式拿到，具体拿到的方式可能有这么几种：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;import&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;js 原生import可以引入远程定义的物料，但是这个方式有个明显的缺点，就是不能跨域。如果没有跨域需求，可以用这种方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;webpack组件联邦&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看网上介绍，这种方式似乎可行，但并没有尝试过，有类似尝试的朋友，欢迎留言。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;src引入&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式可行的，并且以前的版本中已经成功实现，具体做法是在编译的物料库里，把物料的定义挂载到全局window对象上，在编辑器里动态创建一个 script 元素，在load事件中，从全局window对象上拿到定义，具体实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadJS&lt;/span&gt;(&lt;span&gt;src: string, clearCache = false&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;HTMLScriptElement&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;HTMLScriptElement&amp;gt;&lt;span&gt;(&lt;span&gt;(resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; script = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&quot;script&quot;&lt;/span&gt;, {});&lt;br/&gt;    script.type = &lt;span&gt;&quot;text/JavaScript&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (clearCache) {&lt;br/&gt;      script.src = src + &lt;span&gt;&quot;?t=&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;().getTime();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      script.src = src;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (script.addEventListener) {&lt;br/&gt;      script.addEventListener(&lt;span&gt;&quot;load&quot;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        resolve(script)&lt;br/&gt;      });&lt;br/&gt;      script.addEventListener(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Script错误&quot;&lt;/span&gt;, e)&lt;br/&gt;        reject(e)&lt;br/&gt;      });&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.head.appendChild(script);&lt;br/&gt;&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;loadPlugin&lt;/span&gt;(&lt;span&gt;url: string&lt;/span&gt;): &lt;span&gt;Promise&lt;/span&gt;&amp;lt;&lt;span&gt;IPlugin&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; path = trimUrl(url);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; indexJs = path + &lt;span&gt;&quot;index.js&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;&amp;lt;IPlugin&amp;gt;&lt;span&gt;(&lt;span&gt;(resolve, reject&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    loadJS(indexJs, &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;      .then(&lt;span&gt;(&lt;span&gt;script&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;//从全局window上拿到物料的定义&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; rxPlugin = &lt;span&gt;window&lt;/span&gt;.rxPlugin&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;加载结果&quot;&lt;/span&gt;, &lt;span&gt;window&lt;/span&gt;.rxPlugin)&lt;br/&gt;        &lt;span&gt;window&lt;/span&gt;.rxPlugin = &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;        rxPlugin &amp;amp;&amp;amp; resolve(rxPlugin);&lt;br/&gt;        script?.remove();&lt;br/&gt;      })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        reject(err);&lt;br/&gt;      })&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; p;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物料的单独打包使用webpack，这个工具不是很熟练，勉强能用。有熟悉的大佬欢迎留言指导一下，不胜感激。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器的画布目前使用的iframe，选择iframe的原因，后面会有详细介绍。使用iframe时，相当于一个应用启动了两套React，如果从设计器通过window对象，把物料传给iframe画布，react会报错。所以需要在iframe内部单独热加载物料，切记！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;状态管理&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不考虑其它前端库，只考虑React的话，状态管理肯定会选择recoil。如果要考虑vue、angular等其它前端，就只能放弃recoil，从知道的其它库里选：redux、mobx、rxjs。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rxjs虽然看起来不错，但是没有使用经验，暂时放弃了。mobx，个人不喜欢，与上面的设计原则“尽量减少对组件的入侵，最大程度使用已有组件资源”相悖，也只能放弃。最后，选择了Redux。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Redux的代码看起来会繁琐一些，好在这种可视化项目本身的状态并不多，这种繁琐度是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用过程中发现，Redux做低代码状态管理，有很多不错的优势。足够轻量，数据的流向清晰明了，可以精确控制订阅。并且，Redux对配置是友好的，在可视化业务编排里，配置订阅其状态数据非常方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;年少无知的的时候，曾经诋毁过Reudx。不管以前说过多少Redux坏话，它还是优雅地在那里，任你随时取用，不介曾经意被你误解过，不在意是否被你咒骂过。或许，这就是开源世界的包容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前项目里，有三个地方用到了Redux，这三处位置以后会独立成三个npm包，所以各自维护自己的状态树的Root 节点，也就是分别维护自己的状态树。这三个状态树分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计器状态树&lt;/strong&gt; 设计器引擎逻辑上维护一棵节点树，节点树跟带 rx-id 的 dom 节点一一对应。前面定义的schema，是协议性质，用于传输、存储。设设计引擎会把schema转换成节点树，然后展平存储在Redux里面。节点树的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//这个INodeMeta跟上面Schema定义部分提到的，是一个&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; INodeMeta&amp;lt;IField = any, IReactions = any&amp;gt; {&lt;br/&gt;  componentName: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  props?: {&lt;br/&gt;    [key: &lt;span&gt;string&lt;/span&gt;]: &lt;span&gt;any&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;x-field&quot;&lt;/span&gt;?: IField,&lt;br/&gt;  &lt;span&gt;&quot;x-reactions&quot;&lt;/span&gt;?: IReactions,&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//节点经由Schema转换而成&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; ITreeNode {&lt;br/&gt;  &lt;span&gt;//节点唯一ID，对应dom节点上的rx-id&lt;/span&gt;&lt;br/&gt;  id: ID&lt;br/&gt;  &lt;span&gt;//组件标题&lt;/span&gt;&lt;br/&gt;  title?: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//组件描述&lt;/span&gt;&lt;br/&gt;  description?: &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//组件Schema&lt;/span&gt;&lt;br/&gt;  meta: INodeMeta&lt;br/&gt;  &lt;span&gt;//父节点Id&lt;/span&gt;&lt;br/&gt;  parentId?: ID&lt;br/&gt;  &lt;span&gt;//子节点Id&lt;/span&gt;&lt;br/&gt;  children: ID[]&lt;br/&gt;  是否是卡槽节点&lt;br/&gt;  isSlot: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//卡槽节点id键值对&lt;/span&gt;&lt;br/&gt;  slots?: {&lt;br/&gt;    [name: &lt;span&gt;string&lt;/span&gt;]: ID&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//文档id，设计器底层模型支持多文档&lt;/span&gt;&lt;br/&gt;  documentId: ID&lt;br/&gt;  &lt;span&gt;//标识专用属性，不通过外部传入，系统自动构建&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//包含rx-id，rx-node-type，rx-status三个属性&lt;/span&gt;&lt;br/&gt;  rxProps?: RxProps&lt;br/&gt;  &lt;span&gt;//设计时的属性，比如readOnly， open等&lt;/span&gt;&lt;br/&gt;  designerProps?: IDesignerProps&lt;br/&gt;  &lt;span&gt;//用来编辑属性的schema&lt;/span&gt;&lt;br/&gt;  designerSchema?: INodeSchema&lt;br/&gt;  &lt;span&gt;//设计器专用属性，比如是否锁定&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//designerParams?: IDesignerParams&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;展平到Redux里面：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//多文档模型，一个文档的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; DocumentState = {&lt;br/&gt;  &lt;span&gt;//知否被修改过&lt;/span&gt;&lt;br/&gt;  changed: &lt;span&gt;boolean&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;//被选中的节点&lt;/span&gt;&lt;br/&gt;  selectedIds: ID[] | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//操作快照&lt;/span&gt;&lt;br/&gt;  history: ISnapshot[]&lt;br/&gt;  &lt;span&gt;//根节点Id&lt;/span&gt;&lt;br/&gt;  rootId?: ID&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; DocumentByIdState = {&lt;br/&gt;  [key: &lt;span&gt;string&lt;/span&gt;]: DocumentState | &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; NodesById = {&lt;br/&gt;  [id: ID]: ITreeNode&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; State = {&lt;br/&gt;  &lt;span&gt;//状态id&lt;/span&gt;&lt;br/&gt;  stateId: StateIdState&lt;br/&gt;  &lt;span&gt;//所有的文档模型&lt;/span&gt;&lt;br/&gt;  documentsById: DocumentByIdState&lt;br/&gt;  &lt;span&gt;//当前激活文档的id&lt;/span&gt;&lt;br/&gt;  activedDocumentId: ID | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//所有文档的节点，为了以后支持跨文档拖放，全部节点放在根下&lt;/span&gt;&lt;br/&gt;  nodesById: NodesById&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据模型状态树&lt;/strong&gt; fieldy模块的数据模型主要用来管理页面的数据模型，树状结构，Immutble的。数据模型中的数据，通过 schema 的 x-field 属性绑定到具体组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预览页面、右侧属性面板都是用这个模型（右侧属性面板就是一个运行时模块，根页面预览使用相同的渲染引擎，就是说右侧属性面板是基于低代码配置来实现的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//字段状态&lt;br/&gt;export type FieldState = {&lt;br/&gt;  //自动生成id，用于组件key值&lt;br/&gt;  id: string;&lt;br/&gt;  //字段名&lt;br/&gt;  name?: string;&lt;br/&gt;  //基础路径&lt;br/&gt;  basePath?: string;&lt;br/&gt;  //路径，path=basePath + &quot;.&quot; + name&lt;br/&gt;  path: string;&lt;br/&gt;  //字段是否已被初始化&lt;br/&gt;  initialized?: boolean;&lt;br/&gt;  //字段是否已挂载&lt;br/&gt;  mounted?: boolean; &lt;br/&gt;  //字段是否已卸载&lt;br/&gt;  unmounted?: boolean; &lt;br/&gt;  //触发 onFocus 为 true，触发 onBlur 为 false&lt;br/&gt;  active?: boolean; &lt;br/&gt;  //触发过 onFocus 则永远为 true&lt;br/&gt;  visited?: boolean; &lt;br/&gt;  display?: FieldDisplayTypes;&lt;br/&gt;  pattern?: FieldPatternTypes;&lt;br/&gt;  loading?: boolean;&lt;br/&gt;  validating?: boolean;&lt;br/&gt;  modified?: boolean;&lt;br/&gt;  required?: boolean;&lt;br/&gt;  value?: any;&lt;br/&gt;  defaultValue?: any;&lt;br/&gt;  initialValue?: any;&lt;br/&gt;  errors?: IFieldFeedback[];&lt;br/&gt;  validateStatus?: FieldValidateStatus;&lt;br/&gt;  meta: IFieldMeta&lt;br/&gt;}&lt;br/&gt;export type FieldsState = {&lt;br/&gt;  [path: string]: FieldState | undefined&lt;br/&gt;}&lt;br/&gt;export type FormState = {&lt;br/&gt;  //字段是否已挂载&lt;br/&gt;  mounted?: boolean; &lt;br/&gt;  //字段是否已卸载&lt;br/&gt;  unmounted?: boolean; &lt;br/&gt;  initialized?: boolean;&lt;br/&gt;  pattern?: FieldPatternTypes;&lt;br/&gt;  loading?: boolean;&lt;br/&gt;  validating?: boolean;&lt;br/&gt;  modified?: boolean;&lt;br/&gt;  fields: FieldsState;&lt;br/&gt;  fieldSchemas: IFieldSchema[];&lt;br/&gt;  initialValue?: any;&lt;br/&gt;  value?: any;&lt;br/&gt;}&lt;br/&gt;export type FormsState = {&lt;br/&gt;  [name: string]: FormState | undefined&lt;br/&gt;}&lt;br/&gt;export type State = {&lt;br/&gt;  forms: FormsState&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉formily的朋友，会发现这个结构定义跟fomily很像。没错，就是这个接口的定义就是借鉴（抄）了formily。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑编排设计器状态树&lt;/strong&gt; 这个有机会再单独成文介绍吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;软件架构&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软件被划分为两个比较独立的部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;设计器，用于设计页面，消费的是设计形态的组件。生成页面Schema。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行时，把设计器生成的页面Schema，渲染为正常运行的页面，消费的是预览形态的组件。 采用分层设计架构，上层依赖下层。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;设计器架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器的最底层是core包，在它之上是react-core、vue-core，再往上就是shell层，比如Antd shell、Mui shell等。下图是架构图，图中虚线表示只是规划尚未实现的部分，实线是已经实现的部分。后面的介绍，也是以已经实现的 React 为主。 &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6037735849056604&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicibN3nXNWDIiaHY5icgialQibMIpKZyKNHSkVCmQk6dTZ6icblqA2KM3QkC4A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;core包是整个设计器的基础，包含了 Redux 状态树、页面互动逻辑，编辑器的各种状态等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-core 包定义了 react 相关的基础组件，把 core 包功能封装为hooks。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-shells 包，针对不同组件库的具体实现，比如 antd 或者 mui 等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时包含三个包：ComponentRender、fieldy跟minions，前者依赖后两者。 &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6111111111111112&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpichQiaibCxc5C1sSQZrAH5qls5vENBicPQaMib31yup36AicIlfukagW4PcqQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fieldy 是数据模型，用于组织页面数据，比如表单、字段等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;minions（小黄人）是控制器部分，用于控制页面的业务逻辑以及组件间的联动关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ComponertRender 负责把Schema 渲染为正常运行的页面。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;core包的设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Core包是基于接口的设计，这样的设计方式有个明显的优点，就是清晰模块间的依赖关系，封装了具体的实现细节，能方便的单独替换某个模块。Core 包含的模块： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6485943775100401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicBsib5zKWeKG6ibq1As2gGibiajy8jnC8QR1IVAcicRUsIeX41CFuibIhErVw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;498&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计器引擎是 IDesignerEngine 接口的具体实现，也是 Core 包入口，通过 IDesignerEngine 可以访问包内的其它模块。接口定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDesignerEngine&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//获取设计器当前语言代码，比如：zh-CN, en-US...&lt;/span&gt;&lt;br/&gt;    getLanguage(): string&lt;br/&gt;    &lt;span&gt;//设置设计设计语言代码&lt;/span&gt;&lt;br/&gt;    setLanguage(lang: string): void&lt;br/&gt;    &lt;span&gt;//中创建一个文档模型，注：设计器是多文档模型，core支持同时编辑多个文档&lt;/span&gt;&lt;br/&gt;    createDocument(schema: INodeSchema): IDocument&lt;br/&gt;    &lt;span&gt;//通过 id 获取文档模型&lt;/span&gt;&lt;br/&gt;    getDocument(id: ID): IDocument | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//通过节点 id 获取节点所属文档模型&lt;/span&gt;&lt;br/&gt;    getNodeDocument(nodeId: ID): IDocument | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取所有文档模型&lt;/span&gt;&lt;br/&gt;    getAllDocuments(): IDocument[] | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取监视器 monitor，监视器用于传递Redux store的状态数据&lt;/span&gt;&lt;br/&gt;    getMonitor(): IMonitor&lt;br/&gt;    &lt;span&gt;//获取Shell模块，shell用与获取设计器的事件，比如鼠标移动等&lt;/span&gt;&lt;br/&gt;    getShell(): IDesignerShell&lt;br/&gt;    &lt;span&gt;//获取组件管理器，组件管理器管理组件物料&lt;/span&gt;&lt;br/&gt;    getComponentManager(): IComponentManager&lt;br/&gt;    &lt;span&gt;//获取资源管理器，资源是指左侧工具箱上的资源，一个资源对应一个组件或者一段组件模板&lt;/span&gt;&lt;br/&gt;    getResourceManager(): IResourceManager&lt;br/&gt;    &lt;span&gt;//获取国语言资源管理器&lt;/span&gt;&lt;br/&gt;    getLoacalesManager(): ILocalesManager&lt;br/&gt;    &lt;span&gt;//获取装饰器管理器，装饰器是设计器的辅助工具，主要用于给画布内的节点添加附加dom属性，比如outline，辅助边距，数据绑定提示等&lt;/span&gt;&lt;br/&gt;    getDecoratorManager(): IDecoratorManager&lt;br/&gt;    &lt;span&gt;//获取设计动作，动作的实现方法，大部分会转换成redux的action&lt;/span&gt;&lt;br/&gt;    getActions(): IActions&lt;br/&gt;    &lt;span&gt;//注册插件，rxeditor是组合式设计，插件没有功能性接口，只是为了统一销毁被组合的对象，提供了简单的销毁接口&lt;/span&gt;&lt;br/&gt;    registerPlugin(pluginFactory: IPluginFactory): void&lt;br/&gt;    &lt;span&gt;//获取插件&lt;/span&gt;&lt;br/&gt;    getPlugin(name: string): IPlugin | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//发送 redux action&lt;/span&gt;&lt;br/&gt;    dispatch(action: IAction&amp;lt;any&amp;gt;): void&lt;br/&gt;    &lt;span&gt;//销毁设计器&lt;/span&gt;&lt;br/&gt;    destory(): void&lt;br/&gt;    &lt;span&gt;//获取一个节点的行为规则，比如是否可拖放等&lt;/span&gt;&lt;br/&gt;    getNodeBehavior(nodeId: ID): NodeBehavior&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redux store 是设计其引擎的状态管理模块，通过Monitor模块跟文档模型，把最新的状态传递出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;监视器（IMonitor）模块&lt;/strong&gt;，提供订阅接口，发布设计器状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;动作管理（IActions）模块&lt;/strong&gt;，把部分常用的Redux actions 封装成通用接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文档模型（IDocument）&lt;/strong&gt;，Redux store存储了文档的状态数据，文档模型直接使用Redux store，并将其分装为更直观的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDocument&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//唯一标识&lt;/span&gt;&lt;br/&gt;    id: ID&lt;br/&gt;    &lt;span&gt;//销毁文档&lt;/span&gt;&lt;br/&gt;    destory(): void&lt;br/&gt;    &lt;span&gt;//初始化&lt;/span&gt;&lt;br/&gt;    initialize(rootSchema: INodeSchema, documentId: ID): void&lt;br/&gt;    &lt;span&gt;//把一个节点移动到树形结构的指定位置&lt;/span&gt;&lt;br/&gt;    moveTo(sourceId: ID, targetId: ID, pos: NodeRelativePosition): void&lt;br/&gt;    &lt;span&gt;//把多个节点移动到树形结构的指定位置&lt;/span&gt;&lt;br/&gt;    multiMoveTo(sourceIds: ID[], targetId: ID, pos: NodeRelativePosition): void&lt;br/&gt;    &lt;span&gt;//添加新节点，把组件从工具箱拖入画布，会调用这个方法&lt;/span&gt;&lt;br/&gt;    addNewNodes(elements: INodeSchema | INodeSchema[], targetId: ID, pos: NodeRelativePosition): NodeChunk&lt;br/&gt;    &lt;span&gt;//删除一个节点&lt;/span&gt;&lt;br/&gt;    remove(sourceId: ID): void&lt;br/&gt;    &lt;span&gt;//克隆一个节点&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;clone&lt;/span&gt;(sourceId: ID): void&lt;br/&gt;    &lt;span&gt;//修改节点meta数据，右侧属性面板调用这个方法修改数据&lt;/span&gt;&lt;br/&gt;    changeNodeMeta(id: ID, newMeta: INodeMeta): void&lt;br/&gt;    &lt;span&gt;//删除组件卡槽位的组件&lt;/span&gt;&lt;br/&gt;    removeSlot(id: ID, name: string): void&lt;br/&gt;    &lt;span&gt;//给一个组件卡槽插入默认组件&lt;/span&gt;&lt;br/&gt;    addSlot(id: ID, name: string): void&lt;br/&gt;    &lt;span&gt;//发送一个redux action&lt;/span&gt;&lt;br/&gt;    dispatch(action: IDocumentAction&amp;lt;any&amp;gt;): void&lt;br/&gt;    &lt;span&gt;//把当前文档状态备份为一个快照&lt;/span&gt;&lt;br/&gt;    backup(actionType: HistoryableActionType): void&lt;br/&gt;    &lt;span&gt;//撤销时调用&lt;/span&gt;&lt;br/&gt;    undo(): void&lt;br/&gt;    &lt;span&gt;//重做是调用&lt;/span&gt;&lt;br/&gt;    redo(): void&lt;br/&gt;    &lt;span&gt;//定位到某个操作快照，撤销、重做的补充&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;goto&lt;/span&gt;(index: number): void&lt;br/&gt;    &lt;span&gt;//获取文档根节点&lt;/span&gt;&lt;br/&gt;    getRootNode(): ITreeNode | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//通过id获取文档节点&lt;/span&gt;&lt;br/&gt;    getNode(id: ID): ITreeNode | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;//获取节点schema，相当于把ItreeNode树转换成 schema 树&lt;/span&gt;&lt;br/&gt;    getSchemaTree(): INodeSchema | &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;组件管理器（IComponentManager）&lt;/strong&gt;，管理组件信息（组件注册、获取等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;资源管理器（IResourceManager）&lt;/strong&gt;，管理工具箱的组件、模板资源（资源注册、资源获取等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;多语言管理器（ILocalesManager）&lt;/strong&gt;，管理多语言资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Shell管理（IDesignerShell）&lt;/strong&gt;，与界面交互的通用逻辑，基于事件模型实现，类图： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6869436201780416&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicO4Sh21PJqiaJK57sbMsU4UCrysSb3QQhtq4NLFnRGriaKFsicZQWNXkrQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;674&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DesignerShell类聚合了多个驱动（IDriver），驱动通过IDispatchable接口（DesignerShell就实现了这个接口，代码中使用的就是DesignerShell）把事件发送给 DesignerShell，再由 DesignerShell 把事件分发给其它订阅者。驱动的种类有很多，比如键盘事件驱动、鼠标事件驱动、dom事件驱动等。不同的shell实现，需要的驱动也不一样，比如画布用div实现跟iframe实现，需要的驱动会略有差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着后续的进展，可以有更多的驱动被组合进项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件（IPlugin），RxEditor组合式的编辑器，只要拿到 IDesignerEngine 实例，就可以扩展编辑器的功能。只是有的时候需要在编辑器退出的时候，需要统一销毁某些资源，故而加入了一个简单的IPlugin接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; IPlugin {&lt;br/&gt;  &lt;span&gt;//唯一名称，可用于覆盖默认值&lt;/span&gt;&lt;br/&gt;  name: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  destory(): &lt;span&gt;void&lt;/span&gt;,&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中的 core/auxwidgets 跟 core/controllers 都是 IPlugin 的实现，查看这些代码，就可以明白具体功能是怎么被组合进设计器的。实际代码中，为了更好的组合，还定义了一个工厂接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;type&lt;/span&gt; IPluginFactory = (&lt;br/&gt;  engine: IDesignerEngine,&lt;br/&gt;) =&amp;gt; IPlugin&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 IDesignerEngine 的时候直接传入不同的 Plugin 工厂就可以：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;createEngine&lt;/span&gt;&lt;span&gt;(&lt;br/&gt;  plugins: IPluginFactory[],&lt;br/&gt;  options: {&lt;br/&gt;    languange?: string,&lt;br/&gt;    debugMode: boolean,&lt;br/&gt;  }&lt;br/&gt;)&lt;/span&gt;: &lt;span&gt;IDesignerEngine&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//构建IDesignerEngine&lt;/span&gt;&lt;br/&gt;    ....&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt;&lt;span&gt;const&lt;/span&gt; eng = createEngine(&lt;br/&gt;      [&lt;br/&gt;        StartDragController,&lt;br/&gt;        SelectionController,&lt;br/&gt;        DragStopController,&lt;br/&gt;        DragOverController,&lt;br/&gt;        ActiveController,&lt;br/&gt;        ActivedOutline,&lt;br/&gt;        SelectedOutline,&lt;br/&gt;        GhostWidget,&lt;br/&gt;        DraggedAttenuator,&lt;br/&gt;        InsertionCursor,&lt;br/&gt;        Toolbar,&lt;br/&gt;      ],&lt;br/&gt;      {&lt;br/&gt;        debugMode: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    )&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器管理（IDecoratorManager），装饰器用于给画布内的节点，插入html标签或者属性。这些插入的元素不依赖于节点的编辑状态（依赖于编辑状态的，通过插件插入，比如轮廓线），比如给所有的节点加入辅助的outline，或者标识出已经绑定了后端数据的节点。可以自定义多种类型的装饰器，动态插入编辑器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器的接口定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//唯一名称&lt;/span&gt;&lt;br/&gt;  name: string&lt;br/&gt;  &lt;span&gt;//附加装饰器到dom节点&lt;/span&gt;&lt;br/&gt;  decorate(el: HTMLElement, node: ITreeNode): void;&lt;br/&gt;  &lt;span&gt;//从dom节点，卸载装饰器&lt;/span&gt;&lt;br/&gt;  unDecorate(el: HTMLElement): void;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IDecoratorManager&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  addDecorator(decorator: IDecorator, documentId: string): void&lt;br/&gt;  removeDecorator(name: string, documentId: string): void&lt;br/&gt;  getDecorator(name: string, documentId: string): IDecorator | undefined&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个辅助轮廓线的示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;export &lt;span&gt;const&lt;/span&gt; LINE_DECORTOR_NAME = &lt;span&gt;&quot;lineDecorator&quot;&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LineDecorator&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IDecorator&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  name: string = LINE_DECORTOR_NAME;&lt;br/&gt;&lt;br/&gt;  decorate(el: HTMLElement, node: ITreeNode): void {&lt;br/&gt;    el.classList.add(&lt;span&gt;&quot;rx-node-outlined&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  unDecorate(el: HTMLElement): void {&lt;br/&gt;    el.classList.remove(&lt;span&gt;&quot;rx-node-outlined&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//css&lt;/span&gt;&lt;br/&gt;.rx-node-outlined{&lt;br/&gt;  outline: dashed grey &lt;span&gt;1&lt;/span&gt;px;&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;react-core 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个包是使用 React 对 core 进行的封装，并且提供一些通用 React 组件，不依赖具体的组件库（类似antd，mui等）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上下文（Contexts）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DesignerEngineContext&lt;/strong&gt; 设计引擎上下文，用于下发 IDesignerEngine 实例，包裹在设计器最顶层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DesignComponentsContext&lt;/strong&gt; 设计形态组件上下文，注册进设计器的组件，它们的设计形态通过这个上下文下发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PreviewComponentsContext&lt;/strong&gt; 预览形态组件上下文，注册进设计器的组件，他们的预览形态通过这个上下文下发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DocumentContext&lt;/strong&gt; 文档上下文，下发一个文档模型（IDocument），包裹在文档视图的顶层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NodeContext&lt;/strong&gt; 节点上下文，下发 ITreeNode，每个节点包裹一个这样的上下文。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通用组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Designer&lt;/strong&gt; 设计器根组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DocumentRoot&lt;/strong&gt; 文档视图根组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ComponentTreeWidget&lt;/strong&gt; 在画布上渲染节点树，调用 ComponentDesignerView 递归实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;画布（Canvas）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现不依赖具体画布。使用 ComponentTreeWidget 组件实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;core 包定义了画布接口 IShellPane，和不同的画布实现逻辑（headless的）：IFrameCanvasImpl（把画布包放入iframe的实现逻辑），ShadowCanvasImpl（把画布放入Web component的实现逻辑）。如果需要，可以做一个div的画布实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在react-core包，把画布的实现逻辑跟具体界面组件挂接到一起，具体可以阅读相关代码，有问题欢迎留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;画布的实现方式大概有三种方式，都有各自的优缺点，下面分别说说。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;div实现方式&lt;/strong&gt;，把设计器组件树渲染在一个div内，跟设计器没有隔离，这中实现方式比较简单，性能也好。缺点就是js上下文跟css样式没有隔离机制，被设计页面的样式不够独立。类似 position:fixed 的样式需要在画布最外层加一个隔离，比如：transform:scale(1) 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应式布局，是指随着浏览器的大小改变，会呈现不同的样式，css中使用的是 @media 查询，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@media (min-width: 1200){ //&amp;gt;=1200的设备 }&lt;br/&gt;@media (min-width: 992px){ //&amp;gt;=992的设备 }&lt;br/&gt;@media (min-width: 768px){ //&amp;gt;=768的设备 }&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个设计器中，如果能通过调整画布的大小来触发@media的选择，就可以直观的看到被设计的内容在不同设备上的外观。div作为画布，是模拟不了浏览器大小的，无法触发@media 查询，对响应式页面的设计并不十分友好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;web component沙箱方式&lt;/strong&gt;，用 shadow dom 作为画布，把设计器组件树渲染在 shadow dom 内。这样的实现方式，性能跟div方式差不多，还可以有效隔离js上下文跟css样式，比div的实现方式稍微好一些，类似 position:fixed 的样式还是需要在画布最外层加一个隔离，比如：transform:scale(1) 。并且 shadow dom 不能模拟浏览器大小，它的大小改变也不能触发无法触发@media 查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;iframe实现方式&lt;/strong&gt;，把设计器组件树渲染在 iframe 内，iframe会隔离js跟css，并且iframe尺寸的变化也会触发 @media 查询，是非常理想的实现方式，RxEditor 最终也锁定在了这种实现方式上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往iframe内部渲染组件，也有不同的渲染方式。在 RxEditor 项目中，尝试过两种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReactDOM.Root.render渲染，这种方式需要拿到iframe里面第一个div的dom，然后传入ReactDOM.createRoot。相当于在主程序渲染画布组件，这种实现方式性能还是不错的，画面没有闪烁感。但是，组件用的css样式跟js链接，需要从外部传入iframe内部。很多组件库的不兼容这样实现方式，比如 antd 的 popup 系列组件，在这种方式下很难正常工作，要实现类似功能，不得不重写组件，与设计原则 “尽量减少对组件的入侵，最大程度使用已有组件资源” 相悖。 iframe.src方式渲染，定义一个画布渲染组件，并配置路由，把路由地址传入iframe.src：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&amp;lt;Routes&amp;gt;&lt;br/&gt;    ...&lt;br/&gt;    &amp;lt;Route &lt;br/&gt;        path={&#x27;/canvas-render&#x27;} &lt;br/&gt;        element={&amp;lt;IFrameCanvasRender designers={designers} /&amp;gt;}&lt;br/&gt;    &amp;gt;&lt;br/&gt;    &amp;lt;/Route&amp;gt;&lt;br/&gt;    ...&lt;br/&gt;&amp;lt;/Routes&amp;gt;&lt;br/&gt;&lt;br/&gt;//iframe渲染&lt;br/&gt;&amp;lt;iframe&lt;br/&gt;    ref={ref}&lt;br/&gt;    src={&#x27;/canvas-render&#x27;}&lt;br/&gt;    onLoad={handleLoaded}&lt;br/&gt;&amp;gt;&lt;br/&gt;&amp;lt;/iframe&amp;gt;&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的渲染方式，完美解决了上述各种问题，就是渲染画布的时候，需要一段时间初始化React，性能上比上述方式略差。另外，热加载进来的组件不能通过window全局对象的形式传入iframe，热加载需要在iframe内部完成，否则React会报冲突警告。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;react-shells 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;依赖于组件库部分的实现，目前只是先了 antd 版本。代码就是普通react组件跟钩子，直接翻阅一下源码就好，有问题欢迎留言。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;runner 包&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个包是运行时，以正常运行的方式渲染设计器生产的页面，消费的是预览形态的组件。设计器右侧的属性面板也是基于低代码实现，使用的是这个包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runner 包能渲染一个完整的前端应用，包含表单数据绑定，组件的联动。采用模型数据、行为、UI界面三者分离的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据模型在 fieldy 模块定义，基于Redux实现，前面已经介绍过其接口。这个模块，在逻辑上管理一棵数据树，组件可以绑定树的具体节点，一个节点可以绑定多个组件。绑定方式，在 schema 的 x-field 字段定义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文的开始的设计原则中说过，尽量减少对组件的入侵，最大程度使用已有组件资源。这就意味着，控制组件的时候，不要重写组件或者侵入其内部，而是通过组件对外的接口props来控制。在组件外层，包装一个控制器，来实现对组件的控制。比如一个组件ComponentA，控制器代码可以这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ControllerA{&lt;br/&gt;    setProp(name: &lt;span&gt;string&lt;/span&gt;, value: &lt;span&gt;any&lt;/span&gt;): &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;    subscribeToPropsChange(listener: PropsListener): UnListener&lt;br/&gt;    destory(): &lt;span&gt;void&lt;/span&gt;,&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; ComponentAController = memo(&lt;span&gt;(&lt;span&gt;props&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; [changedProps, setChangeProps] = useState&amp;lt;&lt;span&gt;any&lt;/span&gt;&amp;gt;()&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; handlePropsChange = useCallback(&lt;span&gt;(&lt;span&gt;name: &lt;span&gt;string&lt;/span&gt;, value: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      setChangeProps(&lt;span&gt;(&lt;span&gt;changedProps: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ({ ...changedProps, [name]: value })&lt;br/&gt;      })&lt;br/&gt;    }, [])&lt;br/&gt;    &lt;br/&gt;    useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; ctrl = &lt;span&gt;new&lt;/span&gt; ControllerA()&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; unlistener = ctrl?.subscribeToPropsChange(handlePropsChange)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          ctrl.destory()&lt;br/&gt;          unlistener?.()&lt;br/&gt;        }&lt;br/&gt;    }, [])&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newProps = useMemo(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; { ...props, ...controller?.events, ...changedProps }&lt;br/&gt;    }, [changedProps, controller?.events, props])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;(&lt;br/&gt;        &amp;lt;Component {...newProps}&amp;gt;    &lt;br/&gt;    )&lt;br/&gt;})&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码，相当于把组件的控制逻辑抽象到ControllerA内部，通过 props 更改 ComponentA 的状态。ControllerA 的实例可以注册到全局或者通过Context下发到子组件（上面算是伪代码，未展示这部分），其它组件可以通过ControllerA 的实例，传递联动控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RxEditor中，控制器实例是通过Context逐级下发的，子组件可以调用所有父组件的控制器，因为控制器本身是个类，所以可以通过属性变量传递数据，实际的控制器定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//变量控制器，用于组件间共享数据&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IVariableController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  setVariable(name: string, value: any): void,&lt;br/&gt;  getVariable(name: string): any,&lt;br/&gt;  subscribeToVariableChange(name: string, listener: VariableListener): void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//属性控制器，用于设置组件属性&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPropController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  setProp(name: string, value: any): void&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//组件控制器接口&lt;/span&gt;&lt;br/&gt;export &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IComponentController&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;IVariableController&lt;/span&gt;, &lt;span&gt;IPropController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;//唯一Id&lt;/span&gt;&lt;br/&gt;  id: string,&lt;br/&gt;  &lt;span&gt;//并称，编排时作为标识&lt;/span&gt;&lt;br/&gt;  name?: string,&lt;br/&gt;  &lt;span&gt;//逻辑编排的meta数据&lt;/span&gt;&lt;br/&gt;  meta: IControllerMeta,&lt;br/&gt;  subscribeToPropsChange(listener: PropsListener): UnListener&lt;br/&gt;  destory(): void,&lt;br/&gt;  &lt;span&gt;//其它&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;复制代码&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runner 渲染跟设计器一样，是通过 ComponentView 组件递归完成的。所以 ComponentAController 可以提取为一个高阶组件 withController（具体实现请阅读代码），ComponentView 渲染组件时，根据schema配置，如果配置了 x-reactions，就给组件包裹高阶组件withController，实现组件控制器的绑定。如果配置了x-field，就给组件包裹一个数据绑定的高阶组件 withBind。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ComponentRender 调用 ComponentView， 通过递归机制把schema树渲染为真实页面。渲染时，会根据x-field的配置渲染fieldy模块的一些组件，完成数据模型的建立。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，IComponentController 的具体实现，依赖逻辑编排，逻辑编排的实现原理在下一节介绍。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;逻辑编排&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一直对逻辑编排不是很感兴趣，觉得用图形化的形式实现代码逻辑，不会有什么优势。直到看到 mybricks 的逻辑编排，才发现换个思路，可以把业务逻辑组件化，逻辑编排其实大有可为。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，以打地鼠逻辑为例，说一下逻辑编排的实现思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;打地鼠的界面：&lt;/strong&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23577235772357724&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpiczze4dD415smbXvfOMpa5W3M1fFY1iaRIM7XBMIKe1j9gwwqmAciaat4g/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左侧9个按钮是地鼠，每隔1秒会随机活动一只（变为蓝色），鼠标点击活动地鼠为击中（变为红色，并且积分器上记1分），右侧上方的输入框为计分器，下面是两个按钮用来开始或者结束游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面讲过，RxEditor 组件控制器是通过Context下发到子组件的，就是是说只有子组件能访问父组件的控制器，父组件访问不了子组件的控制器，兄弟组件之间也不能相互访问控制器。如果通过全局注册控制器的方式，组件之间就可以随意访问控制器，实现这种地鼠逻辑会简单些。但是，如果全局的方式注册控制器，会带来一个新的问题，就是动态表格的控制器不好注册，表格内的控件是动态生成的，他的控制器不好在设计时绑定，所以目前只考虑Context的实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;游戏主控制器&lt;/strong&gt; 在最顶层的组件 antd Row 上加一个一个游戏控制，控制器取名“游戏容器”： &lt;img data-ratio=&quot;0.24483406386975579&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicCPF9fEPic9BzTLjGUNmUAcuXrUL2GRskqpPFlUNdicM6RTpeFSD61Xjg/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1597&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个控制器的可视化配置： &lt;img data-ratio=&quot;0.40935297885970534&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicJU8ErT8Q8km7NmxJbUJsV3Lp2RJf6qTslrib6rNcdGhLPjHsAESqw9A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1561&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个可视化配置的实现原理，改天再写吧，这里只介绍如何用它实现逻辑编排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个基于数据流的逻辑编排引擎，数据从节点的输入端口（左侧端口）流入，经过处理以后，再从输出端口（右侧端口）流出。流入与流出是基于回调的方式实现（类似Promise），并且每个节点可以有自己的状态，所以上图跟流程图有个本质的不同，流程图是单线脚本，而上图每一个节点是一个对象，有点像电影《超级奶爸》里面的小黄人，所以我给这个逻辑编排功能起名叫minions（小黄人），不同的是，这里的小黄人可以组合成另外一个小黄人，可以任意嵌套、任意组合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的实现机制相当于把业务逻辑组件化了，然后再把业务逻辑组件可视化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制器的事件组件内置的，antd 的 Row 内置了三个事件：初始化、销毁、点击。可以在这些事件里实现具体的业务逻辑。本例中的初始化事件中，实现了打地鼠的主逻辑： &lt;img data-ratio=&quot;0.24338085539714868&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicfwVI8GJ8cEAZpa8FzKOkx0T1xMYabkDzROiargRdFGTmrD81QsHIyew/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;982&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;监听“运行”变量，如果为true，启动一个信号发生器，信号发生器每1000毫秒产生一个信号，游戏开始；如果为false，则停止信号发生器，游戏结束。信号发生器产生信号以后，传递给一个随机数生成器，用于生成一个代表地鼠编号的随机数，这个随机数赋值给变量”活跃地鼠“，地鼠组件会订阅变量”活跃地鼠“，如果变量值跟自己的编号一致，就把自己变为激活状态&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交互相当于类的方法（实际上用一个类来实现），是自定义的。这里定义了三个交互：开始、结束、计分，一个交互就是一个类，可以通过Context下发到子组件，子组件可以实例化并用它们来组合自己的逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始，就是把变量”运行“赋值为true，用于启动游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结束，就是把变量”运行“赋值为false，用于结束游戏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计分，就是把成绩+1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量相当于组件控制器类的属性，外部可以通过 subscribeToVariableChange 方法订阅变量的变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;地鼠控制器&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在初始化事件中，地鼠订阅父组件”游戏容器“的活跃地鼠变量，通过条件判断节点判断是否跟自己编号一致，如果一致，把按钮的disabled属性设置为常量false，并启动延时器，延时2000毫秒以后，设置disabled为常量true，并重置按钮颜色（danger属性设置为false）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击事件的编排逻辑： &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3339449541284404&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHriapibblB0rX6SvOuDNZtVpicRnX4E36cfjTHDC7EV90Ol8xnQJeibFDuAuleZIoQTsw6SQqAshP78rw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给danger属性赋值常量true（按钮变红），调用游戏容器的计分方法，增加积分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它组件也是类似的实现方式，这里就不展开了。具体的实现例子，请参考在线演示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里只是初步介绍了逻辑编排的大概原理，详细实现有机会再起一篇专门文章来写吧。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了一个可视化前端的实现原理，包括可视化编辑、运行时渲染等方面内容，所涵盖内容，可以构建一个完整低代码前端，只是限于精力有限、篇幅有限，很多东西没有展开，详细的可以翻阅一下实现代码。有问题，欢迎留言&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f16ac4f674029fff38ae1801fcf22a5e</guid>
<title>理解并统一14种归因算法，让神经网络具有可解释性</title>
<link>https://toutiao.io/k/pttg4se</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content js_underline_content               defaultNoSetting&amp;#10;            &quot; id=&quot;js_content&quot;&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;p&gt;&lt;span&gt;机器之心专栏&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;机器之心编辑部&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;100&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;本文提出了统一解释 14 种输入单元重要性归因算法的内在机理，并提出评价归因算法可靠性&lt;/span&gt;&lt;span&gt;的三大准则。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管 DNN 在各种实际应用中取得了广泛的成功，但其过程通常被视为黑盒子，因为我们很难解释 DNN 如何做出决定。缺乏可解释性损害了 DNN 的可靠性，从而阻碍了它们在高风险任务中的广泛应用，例如自动驾驶和 AI 医疗。因此，可解释 DNN 引起了越来越多的关注。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为解释 DNN 的典型视角，归因方法旨在计算每个输入变量对网络输出的归因 / 重要性 / 贡献分数。例如，给定一个用于图像分类的预训练 DNN 和一个输入图像，每个输入变量的属性得分是指每个像素对分类置信度得分的数值影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管近年来研究者提出了许多归因方法，但其中大多数都建立在不同的启发式方法之上。目前还缺乏统一的理论视角来检验这些归因方法的正确性，或者至少在数学上阐明其核心机制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究人员曾试图统一不同的归因方法，但这些研究只涵盖了几种方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文中，我们提出了「统一解释 14 种输入单元重要性归因算法的内在机理」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj8z9RmtKZI8c7EDbicYciaxd2edDSwkRibZoX1hH1bj6ObGZtia4vSBfkKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;论文地址：https://arxiv.org/pdf/2303.01506.pdf&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实无论是「12 种提升对抗迁移性的算法」，还是「14 种输入单元重要性归因算法」，都是工程性算法的重灾区。在这两大领域内，大部分算法都是经验性的，人们根据实验经验或直觉认识，设计出一些似是而非的工程性算法。大部分研究没有对 “究竟什么是输入单元重要性” 做出严谨定义和理论论证，少数研究有一定的论证，但往往也很不完善。当然，“缺少严谨的定义和论证” 的问题充满了整个人工智能领域，只是在这两个方向上格外突出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一，在众多经验性归因算法充斥可解释机器学习领域的环境下，我们希望证明 “所有 14 种归因算法（解释神经网络输入单元重要性的算法）的内在机理，都可以表示为对神经网络所建模的交互效用的一种分配，不同归因算法对应不同的交互效用分配比例”。这样，虽然不同算法有着完全不同的设计着眼点（比如有些算法有提纲挈领的目标函数，有些算法则是纯粹的 pipeline），但是我们发现在数学上，这些算法都可以被我们纳入到 “对交互效用的分配” 的叙事逻辑中来。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于上面的交互效用分配框架，我们可以进一步为神经网络输入单元重要性归因算法提出三条评估准则，来衡量归因算法所预测的输入单元重要性值是否合理。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，我们的理论分析不只适用于 14 种归因算法，理论上可以统一更多的类似研究。因为人力有限，这篇论文里我们仅仅讨论 14 种算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;研究的真正难点在于，不同的经验性归因算法往往都是搭建在不同的直觉之上的，每篇论文都仅仅努力从各自的角度「自圆其说」，分别基于不同的直觉或角度来设计归因算法，而缺少一套规范的数学语言来统一描述各种算法的本质。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;算法回顾&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在讲数学以前，本文先从直觉层面简单回顾之前的算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;1. 基于梯度的归因算法。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这一类算法普遍认为，神经网络的输出对每个输入单元的梯度可以反映输入单元的重要性。例如，Gradient*Input 算法将输入单元的重要性建模为梯度与输入单元值的逐元素乘积。考虑到梯度仅能反映输入单元的局部重要性，Smooth Gradients 和 Integrated Gradients 算法将重要性建模为平均梯度与输入单元值的逐元素乘积，其中这两种方法中的平均梯度分别指输入样本邻域内梯度的平均值或输入样本到基准点（baseline point）间线性插值点的梯度平均值。类似地，Grad-CAM 算法采用网络输出对每个 channel 中所有特征梯度的平均值，来计算重要性分数。进一步，Expected Gradients 算法认为，选择单个基准点往往会导致有偏的归因结果，从而提出将重要性建模为不同基准点下 Integrated Gradients 归因结果的期望。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2. 基于逐层反向传播的归因算法。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;深度神经网络往往极为复杂，而每一层神经网络的结构相对简单（比如深层特征通常是浅层特征的线性加和 + 非线性激活函数），便于分析浅层特征对深层特征的重要性。因此，这类算法通过估计中层特征的重要性，并将这些重要性逐层传播直至输入层，得到输入单元的重要性。这一类算法包括 LRP-\epsilon, LRP-\alpha\beta, Deep Taylor, DeepLIFT Rescale, DeepLIFT RevealCancel, DeepShap 等。不同反向传播算法间的根本区别在于，他们采用了不同的重要性逐层传播规则。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3. 基于遮挡的归因算法。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这类算法根据遮挡某一输入单元对模型输出的影响，来推断该输入单元的重要性。例如，Occlusion-1（Occlusion-patch）算法将第 i 个像素（像素块）的重要性建模为其它像素未被遮挡时，像素 i 未遮挡和遮挡两种情况下的输出改变量。Shapley value 算法则综合考虑了其它像素的所有可能遮挡情况，并将重要性建模为不同遮挡情况下像素 i 对应输出改变量的平均值。研究已证明，Shapley value 是唯一满足 linearity, dummy, symmetry, efficiency 公理的归因算法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;统一 14 种经验性归因算法的内在机理&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在深入研究多种经验性归因算法后，我们不禁思考一个问题：在数学层面上，神经网络的归因究竟在解决什么问题？在众多经验性归因算法的背后，是否蕴含着某种统一的数学建模与范式？为此，我们尝试从归因的定义出发，着眼考虑上述问题。归因，是指每一个输入单元对神经网络输出的重要性分数 / 贡献。那么，解决上述问题的关键在于，（1）在数学层面上建模「输入单元对网络输出的影响机制」，（2）解释众多经验性归因算法是如何利用该影响机制，来设计重要性归因公式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对第一个关键点，我们研究发现：每一个输入单元往往通过两种方式影响神经网络的输出。一方面，某一个输入单元无需依赖其他输入单元，可独立作用并影响网络输出，这类影响称为 “独立效应”。另一方面，一个输入单元需要通过与其他输入单元共同协作，形成某种模式，进而对网络输出产生影响，这类影响称为 “交互效应”。我们理论证明了，神经网络的输出可以严谨解构为不同输入变量的独立效应，以及不同集合内输入变量间的交互效应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16632016632016633&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjgmK8VuVs06XW44MY0hhkEhBAJhP2jtr3SDavn5AbpEiba4MvSTBLOSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6119402985074627&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjqJ5McbA90TTNHr9ecVy3atiaYH70ePVn10kRHYkFFIZwTZIbsqoKdmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;67&quot;/&gt; &lt;span&gt;表示第 i 个输入单元的独立效应，&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6166666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj5WY45AeBG6hWPoc25wSl90CiaNw7WZdz2aH6sFfpjXrxkgWPMBeLicqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;60&quot;/&gt;&lt;span&gt; 表示集合 S 内多个输入单元间的交互效应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对第二个关键点，我们探究发现，所有 14 种现有经验性归因算法的内在机理，都可以表示对上述独立效用和交互效用的一种分配，而不同归因算法按不同的比例来分配神经网络输入单元的独立效用和交互效用。具体地，令&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.121212121212121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjaONmeZJQ8gyFqFWMODvnWLe3cDCpyKqrHoh19vbQyeIUeT1XVzniaJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;33&quot;/&gt;&lt;span&gt;表示第 i 个输入单元的归因分数。&lt;/span&gt;&lt;span&gt;我们严格证明了，所有 14 种经验性归因算法得到的&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2333333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj0VAlzaM06WdtK1kbUj8AVOhD2BGf55zVD7pyafbGw1XdNotLBPvOXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;30&quot;/&gt;&lt;span&gt;，都可以统一表示为下列数学范式（即独立效用和交互效用的加权和）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.17209302325581396&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj8QoAMOBc7ZtulibJWLtDkleQvdY14via71xxxhibKk9JvSvXusx4Sok4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8163265306122449&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjwAmseXNiaZhdia3RV7SV9NkAR87C9ztrR9zONgk2XjUS4qarMbicxuSBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;49&quot;/&gt;&lt;span&gt;反映了将第 j 个输入单元的独立效应分配给第 i 个输入单元的比例，&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7321428571428571&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj86dt3s1kQ0728ich3LsWN3kUUiclsoqfx5XDOVd7Ppeo1B1AOduVOIwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;56&quot;/&gt;&lt;span&gt;表示将集合 S 内多个输入单元间的交互效应分配给第 i 个输入单元的比例。&lt;/span&gt;&lt;span&gt;众多归因算法的 “根本区别” 在于，不同归因算法对应着不同的分配比例 &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32142857142857145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjXRekM83T2XiaDtd1RC49yson5vib6ib63wBxvIiauANI6hHnzsksDJCbZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;140&quot;/&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表 1 展示了十四种不同的归因算法分别是如何对独立效应与交互效应进行分配。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7101568951279934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjxDMuwmNd8GV1jyAdDBQ5oJUicl7UB2pib7Mso9QSKL8Llu3gmzve4JOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1211&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图表 1. 十四种归因算法均可以写成独立效应与交互效应加权和的数学范式。其中&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2582781456953642&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj62kv5Dx73sgusnOibwjCMkpOUnsAdwxEPKRTRonib4Br6Oygtknmfovg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;151&quot;/&gt;&lt;em&gt;&lt;span&gt;分别表示泰勒独立效应和泰勒交互效应，满足&lt;/span&gt;&lt;/em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.09504132231404959&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjRpzQpQibJU1vAtsV9pI5nQDqMXoic8WVwwpwmsSys4HAaGfXfD3GICOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;em&gt;&lt;span&gt;，是对独立效应&lt;/span&gt;&lt;/em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5714285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjp7hKucmnFNU0ITmFNeyJgLZF55l85bOGfOJOGQjrvnWMqFe4Zgo7AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;63&quot;/&gt;&lt;em&gt;&lt;span&gt;和交互效&lt;/span&gt;&lt;/em&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjVSm8NficibxyHhgJyQcFK7go17ySM5n3uOoQOtQMSBrMgWrJTmIw3ia5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;57&quot;/&gt;&lt;em&gt;&lt;span&gt;的细化。&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3832528180354267&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjUhV446DVGFXT7VGbLC9qsp3OIpTrRBaJJXNlbTxuwibiaVCO1n6OMqhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2840909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjABbcG00WBPOZQacHgZIWpicpFH2Wk8xK90xdJfZpqkfE1mYTuO2TiaAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2887096774193548&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjvmSoH9EZUuQfFl060yfktXnlWYlyIP7CSdvpa1t02QwzJiaX5GX9ib0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2684458398744113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjJXfINic3UImgnOUfhw0x53Pkk9ncTv66tcxn8khdGkIvKHjPcIosvFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4968051118210863&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjFU3lpdhpwUsjgPrHaPoah3n2xeibEOIbryLGzgCyvgxrOunIucMuXUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2750809061488673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjicfQOHkJUehqqKa1sbQRQ2uL7yiakzGD0WIRW2zSUlwbumJPV9w0mia5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28032786885245903&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjibbibiaQ3tHoD7GicNj3GgicYvD6botrBFbvDa7d6pFYusBibgibb1wwhmBlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;610&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2896440129449838&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjm7V1s5s72DiaKx4GcEcvH6pjUlazx3qNsz5IsLic1vQe9icZ8eAdE8N3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3778135048231511&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj1xnRIeZ3iaAceU6FkoWicmOWOmfwZ3ic51XQKEnrE5L4eGbu6cYjfcYiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8894154818325435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj8L0nK16jgI7TyYYFpgWKqy5XfeFQibibFfwbA1RGyPYx4o0j3hZtfAjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6242038216560509&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjgXGWrSwL37AOXVTmdCcqQ8lwlNM87TcEVtfiaSPGCMqFnoTONhNgnBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47385103011093505&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjn9DeEcQkUQJRwaRaTqCwEekUe1gfgJ12Y5f8n4qRFNEVQMI3E1LRHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;631&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4416&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjLng3PTS8z1QKounDI4Nwsz5eXvcg0QfJcSmzhHg4Kibg1OAo8Ue99EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5875796178343949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjpUfuFiaXJ6zl62ICjBgUmiaN9QeuUk8ibDDG2YaumJez7iaVviaS896ryOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;628&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4391025641025641&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjcId0eZPCgawx9Ko1RQSiaqaQyg49iaztD76Fea6h7mMoItekPsNoQnzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;624&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;评价归因算法可靠性的三大准则&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在归因解释研究中，由于无从获得 / 标注神经网络归因解释的真实值，人们无法从实证角度评价某一个归因解释算法的可靠性。“缺乏对归因解释算法可靠性的客观评价标准” 这一根本缺陷，引发了学界对归因解释研究领域的广泛批评与质疑。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而本研究中对归因算法公共机理的揭示，使我们能在同一理论框架下，公平地评价和比较不同归因算法的可靠性。具体地，我们提出了以下三条评估准则，以评价某一个归因算法是否公平合理地分配独立效应和交互效应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）&lt;strong&gt;准则一：分配过程中涵盖所有独立效应和交互效应&lt;/strong&gt;。当我们将神经网络输出解构为独立效应与交互效应后，可靠的归因算法在分配过程中应尽可能涵盖所有的独立效应和交互效应。例如，对 I’m not happy 句子的归因中，应涵盖三个单词 I’m, not, happy 的所有独立效应，同时涵盖 J (I’m, not), J (I’m, happy), J (not, happy), J (I’m, not, happy) 等所有可能的交互效应。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）&lt;strong&gt;准则二：避免将独立效应和交互分配给无关的输入单元&lt;/strong&gt;。第 i 个输入单元的独立效应，只应分配给第 i 个输入单元，而不应分配给其它输入单元。类似地，集合 S 内输入单元间的交互效应，只应分配给集合 S 内的输入单元，而不应分配给集合 S 以外的输入单元（未参与交互）。例如，not 和 happy 之间的交互效应，不应分配给单词 I’m。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（3）&lt;strong&gt;准则三：完全分配&lt;/strong&gt;。每个独立效应（交互效应）应当完全分配给对应的输入单元。换句话说，某一个独立效应（交互效应）分配给所有对应输入单元的归因值，加起来应当恰好等于该独立效应（交互效应）的值。例如，交互效应 J (not, happy) 会分配一部分效应&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6923076923076923&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjv13NXrGNBOMAm9I50QXbeHUupLug1mdSmORwAib147Jia9oWX5TSYsAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;52&quot;/&gt;&lt;span&gt;(not, happy) 给单词 not，同时分配一部分效应 &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6101694915254238&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjuTXy5m4bWg5eeNrFlAmhaL3BRJulc937s1CRek9AOVA5VjyicWkiaTpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;59&quot;/&gt;&lt;span&gt; (not, happy) 给单词 happy。那么，分配比例应满足 &lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.18285714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gj2pvZz8dNQ55Wiaiah7ibtpATdAFfK9EsUp33p8GJAyol9QFFibWZJYpJOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;175&quot;/&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接着，我们采用这三条评估准则，评估了上述 14 种不同归因算法（如表 2 所示）。我们发现，Integrated Gradients, Expected Gradients, Shapley value, Deep Shap, DeepLIFT Rescale, DeepLIFT RevealCancel 这些算法满足所有的可靠性准则。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2341101694915254&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9gVWKicQWyBF1eoBaKRK1gjkwnmw00r8QEEM70PiaYdasF6kFCncxU9fFuYegAMc8XBWHxLm3e49Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;em&gt;&lt;span&gt;表 2. 总结 14 种不同归因算法是否满足三条可靠性评估准则。&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;作者介绍&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文作者邓辉琦，是中山大学应用数学专业的博士，博士期间曾在香港浸会大学和德州农工大学计算机系访问学习，现于张拳石老师团队进行博士后研究。研究方向主要为可信 / 可解释机器学习，包括解释深度神经网络的归因重要性、解释神经网络的表达能力等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;邓辉琦前期做了很多工作。张老师只是在初期工作结束以后，帮她重新梳理了一遍理论，让证明方式和体系更顺畅一些。邓辉琦毕业前论文不是很多，21 年末来张老师这边以后，在博弈交互的体系下，一年多做了三个工作，包括（1）发现并理论解释了神经网络普遍存在的表征瓶颈，即证明神经网络更不善于建模中等复杂度的交互表征。这一工作有幸被选为 ICLR 2022 oral 论文，审稿得分排名前五（得分 8 8 8 10）。（2）理论证明了贝叶斯网络的概念表征趋势，为解释贝叶斯网络的分类性能、泛化能力和对抗鲁棒性提供了新的视角。（3）从理论层面上解释了神经网络在训练过程中对不同复杂度交互概念的学习能力。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;扩展阅读，「统一 12 种提升对抗迁移性的算法」：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/546433296&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;90835&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-autoskip=&quot;1&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;探寻隐私计算最新行业技术，「首届隐语开源社区开放日」报名启程&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;春暖花开之际，诚邀广大技术开发者&amp;amp;产业用户相聚活动现场，体验数智时代的隐私计算生态建设之旅：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;高效交流——与众多技术专家&amp;amp;社区KOL面对面深入交流，探讨隐私计算技术现状及未来趋势，一站构建隐私计算产业体系知识；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最新资讯——隐语开源指导委员会共享未来展望，与开发者们共话行业新发展，共建社区生态；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;精彩发布——隐语版本更新发布及开源 Roadmap，了解更多技术未来趋势及路径。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3月29日，北京·798机遇空间，隐语开源社区开放日，期待线下面基。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;阅读原文&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，立即报名。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;288&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gW83Ig9Zr9cKwWxFs9fhpVlMCgtVRMzwHAicWdH3ia1ucOyric1tc2gy0FKiaB9dIv5FLYeQzQDLp7btrg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;© THE END &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mp-style-type data-value=&quot;10000&quot;/&gt;&lt;/p&gt;&lt;/div&gt;

          
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>