<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b128a369165d86c178ac26d6b194174a</guid>
<title>阿里云官方 Redis 开发规范！</title>
<link>https://toutiao.io/k/2fqcbfi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6573208722741433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwDLiaiaWVWJILbpcFk8iaYKHEpKlmD7krfWCzRvtA8hP2HovZAxh4om2Ssz8UqFz9JS0bISLrNSD1YA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;3210&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;JavaGuide在线网站：javaguide.cn&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;来源：https://developer.aliyun.com/article/531067&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;昨晚在阿里云社区看到一份阿里云官方 Redis 开发规范，是一位阿里云数据库技术专家(Redis方向)写的，感觉有很多地方值得参考。我对原文排版和内容进行了简单完善，这里分享一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;一、键值设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. key 名设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1)【建议】: 可读性和可管理性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以业务名(或数据库名)为前缀(防止 key 冲突)，用冒号分隔，比如业务名:表名:id&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ugc:video:1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2)【建议】：简洁性&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保证语义的前提下，控制 key 的长度，当 key 较多时，内存占用也不容忽视，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;user:{uid}:friends:messages:{mid}简化为u:{uid}:fr:m:{mid}。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(3)【强制】：不要包含特殊字符&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：包含空格、换行、单双引号以及其他转义字符&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细解析：&lt;a href=&quot;https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.7.753b1feeTX187Q&amp;amp;__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483663&amp;amp;idx=1&amp;amp;sn=7c4ad441eaec6f0ff38d1c6a097b1fa4&amp;amp;chksm=ce5f9e8cf928179a2c74227da95bec575bdebc682e8630b5b1bb2071c0a1b4be6f98d67c37ca&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 开发规范解析(一)--键名设计&lt;/a&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. value 设计&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1)【强制】：拒绝 bigkey(防止网卡流量、慢查询)&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;string 类型控制在 10KB 以内，hash、list、set、zset 元素个数不要超过 5000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：一个包含 200 万个元素的 list。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非字符串的 bigkey，不要使用 del 删除，使用 hscan、sscan、zscan 方式渐进式删除，同时要注意防止 bigkey 过期时间自动删除问题(例如一个 200 万的 zset 设置 1 小时过期，会触发 del 操作，造成阻塞，而且该操作不会不出现在慢查询中(latency 可查))，&lt;span&gt;查找方法&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;和&lt;span&gt;删除方法&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细解析：&lt;a href=&quot;https://mp.weixin.qq.com/s?spm=a2c6h.12873639.article-detail.10.753b1feeTX187Q&amp;amp;__biz=Mzg2NTEyNzE0OA==&amp;amp;mid=2247483677&amp;amp;idx=1&amp;amp;sn=5c320b46f0e06ce9369a29909d62b401&amp;amp;chksm=ce5f9e9ef928178834021b6f9b939550ac400abae5c31e1933bafca2f16b23d028cc51813aec&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 开发规范解析(二)--老生常谈 bigkey&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2)【推荐】：选择适合的数据类型。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如 ziplist，但也要注意节省内存和性能之间的平衡)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; user:1:name tom&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; user:1:age 19&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; user:1:favor football&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hmset user:1 name tom age 19 favor football&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】：控制 key 的生命周期，redis 不是垃圾桶。&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议使用 expire 设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注 idletime。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247525881&amp;amp;idx=1&amp;amp;sn=33d4565668cff95f5ee239c6e1d660fe&amp;amp;chksm=cea12a32f9d6a324432c964bf536181f2d55ee50afba9a53d9b09fa0e1a7126a03bb1dde4c60&amp;amp;token=698289097&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java 面试指北》&lt;/a&gt;来啦！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;二、命令使用&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】 O(N)命令关注 N 的数量&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 hgetall、lrange、smembers、zrange、sinter 等并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 hscan、sscan、zscan 代替。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】：禁用命令&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;禁止线上使用 keys、flushall、flushdb 等，通过 redis 的 rename 机制禁掉命令，或者使用 scan 的方式渐进式处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】合理使用 select&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.【推荐】使用批量操作提高效率&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原生命令：例如 mget、mset。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非原生命令：可以使用 pipeline 提高效率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但要注意控制一次批量操作的 &lt;strong&gt;元素个数&lt;/strong&gt;(例如 500 以内，实际也和元素字节数有关)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意两者不同：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;原生是原子操作，pipeline 是非原子操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pipeline 可以打包不同的命令，原生做不到&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;pipeline 需要客户端和服务端同时支持。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.【建议】Redis 事务功能较弱，不建议过多使用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的 key 必须在一个 slot 上(可以使用 hashtag 功能解决)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.【建议】Redis 集群版本在使用 Lua 上有特殊要求：&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;所有 key 都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的 redis 命令，key 的位置，必须是 KEYS array, 否则直接返回 error，&quot;-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;所有 key，必须在 1 个 slot 上，否则直接返回 error, &quot;-ERR eval/evalsha command keys must in same slot&quot;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.【建议】必要情况下使用 monitor 命令时，要注意不要长时间使用。&lt;span/&gt;&lt;/h3&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三、客户端使用&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】避免多个应用使用一个 Redis 实例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正例：不相干的业务拆分，公共数据做服务化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】使用带有连接池的数据库&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;执行命令如下：&lt;br/&gt;Jedis jedis = null;&lt;br/&gt;try {&lt;br/&gt;    jedis = jedisPool.getResource();&lt;br/&gt;    //具体的命令&lt;br/&gt;    jedis.executeCommand()&lt;br/&gt;} catch (Exception e) {&lt;br/&gt;    logger.error(&lt;span&gt;&quot;op key {} error: &quot;&lt;/span&gt; + e.getMessage(), key, e);&lt;br/&gt;} finally {&lt;br/&gt;    //注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (jedis != null)&lt;br/&gt;        jedis.close();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 JedisPool 优化方法的文章:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Jedis 常见异常汇总&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JedisPool 资源池优化&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【建议】高并发下建议客户端添加熔断功能(例如 netflix hystrix)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在通过 Redis 客户端操作 Redis 中的数据时，我们会在其中加入熔断器的逻辑。比如，当节点处于熔断状态时，直接返回空值以及熔断器三种状态之间的转换，具体的示例代码像下面这样：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，当某一个 Redis 节点出现问题，Redis 客户端中的熔断器就会实时监测到，并且不再请求有问题的 Redis 节点，避免单个节点的故障导致整体系统的雪崩。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.【推荐】确保登录安全&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置合理的密码，如有必要可以使用 SSL 加密访问（阿里云 Redis 支持）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.【建议】选择合适的内存淘汰策略&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据自身业务类型，选好 maxmemory-policy(最大内存淘汰策略)，设置好过期时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认策略是 volatile-lru，即超过最大内存后，在过期键中使用 lru 算法进行 key 的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其他策略如下&lt;/strong&gt; ：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;allkeys-random：随机删除所有键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-random:随机删除过期键，直到腾出足够空间为止。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息&quot;(error) OOM command not allowed when used memory&quot;，此时 Redis 只响应读操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247525881&amp;amp;idx=1&amp;amp;sn=33d4565668cff95f5ee239c6e1d660fe&amp;amp;chksm=cea12a32f9d6a324432c964bf536181f2d55ee50afba9a53d9b09fa0e1a7126a03bb1dde4c60&amp;amp;token=698289097&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java 面试指北》&lt;/a&gt;来啦！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;四、相关工具&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.【推荐】：数据同步&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 间数据同步可以使用：redis-port&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.【推荐】：big key 搜索&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;amp;mid=2247499195&amp;amp;idx=2&amp;amp;sn=13fe477aac7cbb8cd03d91511ea98ba0&amp;amp;chksm=cea1b270f9d63b667b72c142321dfccdb64deb11f4fd082e1cfedf7d45768e125a9db7fa6918&amp;amp;token=973133388&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis 为什么变慢了？一文讲透如何排查 Redis 性能问题 | 万字长文&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.【推荐】：热点 key 寻找&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;京东开源的 &lt;span&gt;hotkey&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 支持毫秒级探测热点数据，毫秒级推送至服务器集群内存，大幅降低热 key 对数据层查询压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;五 附录：删除 bigkey&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面操作可以使用 pipeline 加速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis 4.0 已经支持 key 的异步删除，欢迎使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. Hash 删除: hscan + hdel&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigHash&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigHashKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = &lt;span&gt;new&lt;/span&gt; ScanParams().count(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; scanResult = jedis.hscan(bigHashKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;Entry&amp;lt;String, String&amp;gt;&amp;gt; entryList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (entryList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !entryList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;String, String&amp;gt; entry : entryList) {&lt;br/&gt;                jedis.hdel(bigHashKey, entry.getKey());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//删除bigkey&lt;/span&gt;&lt;br/&gt;    jedis.del(bigHashKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. List 删除: ltrim&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigList&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigListKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; llen = jedis.llen(bigListKey);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; counter = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; left = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (counter &amp;lt; llen) {&lt;br/&gt;        &lt;span&gt;//每次从左侧截掉100个&lt;/span&gt;&lt;br/&gt;        jedis.ltrim(bigListKey, left, llen);&lt;br/&gt;        counter += left;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//最终删除key&lt;/span&gt;&lt;br/&gt;    jedis.del(bigListKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. Set 删除: sscan + srem&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void delBigSet(String host, int port, String password, String bigSetKey) {&lt;br/&gt;    Jedis jedis = new Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != null &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = new ScanParams().count(100);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;String&amp;gt; scanResult = jedis.sscan(bigSetKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;String&amp;gt; memberList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (memberList != null &amp;amp;&amp;amp; !memberList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (String member : memberList) {&lt;br/&gt;                jedis.srem(bigSetKey, member);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    //删除bigkey&lt;br/&gt;    jedis.del(bigSetKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. SortedSet 删除: zscan + zrem&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;delBigZset&lt;/span&gt;&lt;span&gt;(String host, &lt;span&gt;int&lt;/span&gt; port, String password, String bigZsetKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Jedis jedis = &lt;span&gt;new&lt;/span&gt; Jedis(host, port);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (password != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(password)) {&lt;br/&gt;        jedis.auth(password);&lt;br/&gt;    }&lt;br/&gt;    ScanParams scanParams = &lt;span&gt;new&lt;/span&gt; ScanParams().count(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    String cursor = &lt;span&gt;&quot;0&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;        ScanResult&amp;lt;Tuple&amp;gt; scanResult = jedis.zscan(bigZsetKey, cursor, scanParams);&lt;br/&gt;        List&amp;lt;Tuple&amp;gt; tupleList = scanResult.getResult();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (tupleList != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !tupleList.isEmpty()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Tuple tuple : tupleList) {&lt;br/&gt;                jedis.zrem(bigZsetKey, tuple.getElement());&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        cursor = scanResult.getStringCursor();&lt;br/&gt;    } &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;&quot;0&quot;&lt;/span&gt;.equals(cursor));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//删除bigkey&lt;/span&gt;&lt;br/&gt;    jedis.del(bigZsetKey);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;查找方法: &lt;em&gt;https://developer.aliyun.com/article/531067#cc1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;删除方法: &lt;em&gt;https://developer.aliyun.com/article/531067#cc2&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Jedis 常见异常汇总: &lt;em&gt;https://yq.aliyun.com/articles/236384?spm=a2c6h.12873639.article-detail.11.753b1feeTX187Q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;JedisPool 资源池优化: &lt;em&gt;https://yq.aliyun.com/articles/236383?spm=a2c6h.12873639.article-detail.12.753b1feeTX187Q&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;hotkey: &lt;em&gt;https://gitee.com/jd-platform-opensource/hotkey&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>961fb0f6736a16e6175368bd320e40d4</guid>
<title>为什么游戏行业喜欢用PolarDB</title>
<link>https://toutiao.io/k/ligtpt2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;h3&gt;&lt;strong&gt;游戏行业痛点&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在笔者看来, 不同行业对数据库使用有巨大的差别. 比如游戏行业没有复杂的事务交易场景, 他有一个非常大的blob 字段用于存储角色的装备信息, 那么大Blob 字段的更新就会成为数据库的瓶颈, 比如在线教育行业需要有抢课的需求, 因此会有热点行更新的场景, 对热点行如何处理会成为数据库的瓶颈, 比如SaaS 行业, 每一个客户有一个Database, 因此会有非常多的Table, 那么数据库就需要对多表有很好的支持能力.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;游戏行业和其他行业对数据库的使用要求是不一样的.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以在支撑了大量游戏业务之后, 我理解游戏行业在使用自建MySQL 的时候有3个比较大的痛点&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;1.对备份恢复的需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2.对写入性能的要求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3.对跨region 容灾的需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;接下来会分别讲述这三个痛点PolarDB 是如何解决的.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;备份恢复&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;笔者和大量游戏开发者沟通中, 游戏行业对备份恢复的需求是极其强烈的. 比如在电商行业, 是不可能存在将整个数据库实例进行回滚到一天之前的数据, 这样所有的用户的购买交易信息都丢失了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是, 在游戏行业中, 这种场景确实存在的, 比如在发版的时候, 游戏行业是有可能发版失败, 这个在其他行业出现概率非常低, 如果发版失败, 那么整个实例就需要回滚到版本之前. 因此每次发版的时候都需要对数据库实例进行备份. 因此当我们玩游戏的时候, 看到大版本需要停服更新, 那么就有可能是因为后台需要备份数据等等一系列操作了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还有一种场景, 当发生因为外挂, 漏洞, 参数配置错误等等场景下, 这种紧急情况游戏就需要回滚到出问题前的版本, 这样就需要对整个实例进行回滚.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.103030303030303&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15YvdyeOshdBrFwDBDdNDAlSWs4MsJ94utu9oIoP4YB0tIb2FA4k9mMfrjg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;官方MySQL 由于是单机架构, 那么常见的备份方法是通过Xtrabackup 工具, 将数据备份到本地以后, 如果本地空间不够, 就需要上传到OSS 等远端存储中. 通常通过Xtrabackup 备份工具都需要1h 左右, 如果需要将数据上传到远端那么时间就更长了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 是天然的计存分离的架构, 那么备份的时候通过底下分布式存储的快照能力, 备份可以不超过30s, 将备份时间大大缩短了.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心思路是采用Redirect-on-Write 机制, 每次创建快照并没有真正Copy数据, 只有建立快照索引, 当数据块后期有修改(Write)时才把历史版本保留给Snapshot, 然后生成新的数据块, 被原数据引用(Redirect).&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一种场景是, 在游戏行业中, 有可能某一个玩家的装备被盗号了, 那么玩家就会找游戏的运营人员投诉, 运营人员会找到游戏运维人员, 帮忙查询玩家的历史数据.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者之前就遇到某著名游戏多个玩家被盗号, 然后运维人员经常需要通过PolarDB 按时间的还原的能力恢复出某多个不同时间点的实例, 用来查询这个玩家的具体装备信息, 同时由于玩家对盗号的时间也不准确, 经常有时候需要还原出多个实例才可以.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对这样的场景, PolarDB 推出了Flashback Query, 就可以在当前实例查询出任意时间点的历史数据. 具体原理见文章 Flashback Query&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3859964093357271&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15Yvdru5WTGZPF1Cco4LFks5Ag4N86ZBP1ibicnxYl2E1Xgf4g4G7TGbX3jow/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1114&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;整体而言, PolarDB 建立了一套非常完善的备份恢复能力, 从库=&amp;gt;表=&amp;gt;行三个维度满足的游戏行业对备份恢复的需求.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5993485342019544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y7l9KJ42n2yyhy0EzXVHEGPK6GK15YvdmM5r2ibK5ibTplyhgrYodcpjJ6icsZiaMqoEp8xMOSaOQM337tImg2gUHg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;写入性能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;游戏行业使用数据库的方式也与其他行业有较大区别, 是一种非常弱Schema 的使用方式, 其他行业通常对业务经常抽象, 建立表结构, 每个字段尽可能小, 不建议有大字段, 有大字段尽可能进行拆封等等.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是在游戏行业中, 由于需要满足游戏快速迭代发展的需求, 玩家的装备信息结构非常复杂, 因此常见的做法是将玩家装备等级信息保存在一个大的blob字段中, 这个blob字段通过proto_buf 或者 json 进行编解码, 每次在获得装备或者升级以后, 就进行整个字段更新,  在游戏开服初期玩家数据长度较短, 而随着游戏版本更新版本, 游戏剧情, 运营活动的增多, 相对于游戏开服初期的数KB, blob字段的长度可能会膨胀到数百KB, 甚至达到MB级别, 因此可能只是获得一个装备, 就需要向数据库写入数百KB 大小的数据, 这样的写放大其实非常不合理.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;目前也有像MongoDB 这样的文档数据库, 让用户写入的时候仅仅更新某个字段, 从而减少写放大. 但是这样影响了用户的使用习惯, 需要用户在业务逻辑上进行修改, 这是快速发展的游戏行业所不能接受的, 所以笔者看到尽管有客户因为写入问题转向了MongoDB, 但是其实不多.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 针对这样的情况尽可能满足用户的使用习惯, 在数据库内核层面优化数据库的写入能力. 通过 partition redo log, redo log cache, undo log readahead,  early lock release, no blob latch 等等能力将写入能力充分优化. 具体原理可以参考我们内核月报 和之前的文章PolarDB-cloudjump 针对游戏场景, 我们修改了 sysbench 工具, 模拟游戏行业中大Blob 更新的workload, 放在 game-sysbench 工具中, 后续我们还会将更多行业比如Saas, 电商等等行业的workload 放在这个工具中.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在game_blob_update workload 中, 如果玩家的平均装备信息是 300kb, 我们对比了PolarDB VS aurora VS 自建MySQL 的数据&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;PolarDB 8.0 相对有最高的QPS 1877.44, 峰值QPS最高可以到2000, CPU bound场景PolarDB的性能大概是Aurora的5.7倍, 是自建 MySQL 本地盘的3倍. IO bound场景PolarDB的性能是Aurora的15倍.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CPU bound场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;DB&lt;/th&gt;&lt;th&gt;并发数据&lt;/th&gt;&lt;th&gt;QPS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PolarDB 8.0&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;1877.44&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MySQL 8.0 本地盘&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;600.22&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Aurora 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;328.47&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IO bound场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;DB&lt;/th&gt;&lt;th&gt;并发数据&lt;/th&gt;&lt;th&gt;QPS&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;PolarDB 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;1035.30&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MySQL 8.0 本地盘&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;610&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Aurora 8.0&lt;/td&gt;&lt;td&gt;200&lt;/td&gt;&lt;td&gt;69.15&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;跨region 容灾&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;目前游戏行业纷纷出海, 包含了游戏服和平台服. 用户在自建MySQL/RDS 的场景中,  用户可能需要在另外一个region 建立一个新的实例, 然后通过同步工具或者DTS 进行跨region 备份. 用户需要处理region 错误场景如何进行切换等等.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;笔者认为对数据库而言, 稳定性 &amp;gt; 易用性 &amp;gt; 性能.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在这个场景中, 用户如果使用云厂商的话, 使用的是云厂商提供的原子能力, 自己通过组装这些原子能力实现容灾的需求, 而PolarDB 针对这样场景提出来PolarDB GlobalDataba 的解决方案, 将跨region 的容灾放在解决方案中, 提供了一个更加易容的解决方案, 从而用户可以关注自身的业务逻辑, 而不需要处理这些容灾的场景.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在具体跨region 的同步场景方案中, PolarDB 是通过多通道物理复制能力, 从而保证跨region 的容灾在1s 以内.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Links:&lt;/p&gt;&lt;p&gt;game-sysbench: https://github.com/baotiao/game-sysbench&lt;/p&gt;&lt;p&gt;PolarDB-cloudjump: https://zhuanlan.zhihu.com/p/535426034&lt;/p&gt;&lt;p&gt;Flashback-Query: https://zhuanlan.zhihu.com/p/434466612&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;参考阅读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文由高可用架构转载。技术原创及架构实践文章，欢迎通过公众号菜单「联系我们」进行投稿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDU1MTE1OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8XkvNnTiapONl06YmHad4csRU93kcbJ76JIWzEAmOSVooibFHHkzfWzzkc7dpU4H06Wp9F6Z687vIghdawxvl47A/0?wx_fmt=png&quot; data-nickname=&quot;高可用架构&quot; data-alias=&quot;ArchNotes&quot; data-signature=&quot;高可用架构公众号。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;‍&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e41226234125f97244c368afa2f04c56</guid>
<title>关于HTTP协议那些事</title>
<link>https://toutiao.io/k/xvdtkbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;作者简介&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;张倩：爱生活，爱美食，立志成为一枚安静优雅小吃货&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到http协议，相信大家也都不陌生。毕竟是跟工作息息相关的，想着好好深入一下，正好看到了罗老师的《透视HTTP协议》，也算是说透了揉碎了，讲的明明白白。下面就里面的内容做了这篇学习总结&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2195121951219512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA0xs3aNMDscdicB7ayZGCNcZjFE5oeoIxoCwtSIeqM7PnayCZxhynI8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始之前先抛出几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;是什么在促进HTTP的发展？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;post请求是什么样的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存在浏览器network中的体现？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP的大文件传输？一切都在发展，想想更好的方案&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP协议跟TCP/IP协议栈的关系&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就开始唠了～～～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 发展史&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5078468298807282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAQewOXxcPLPoUxYMmzPxZveVUrFhGSfBcJicBzQsqrZ0BSsRw0AnlMZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1593&quot;/&gt;&lt;figcaption&gt;http发展史&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HTTP 的发展历程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/0.9（90年代初）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受限于当时的大环境，只支持get的纯文本传输，后定义为HTTP/0.9 --- 是小范围的试炼&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/1.0(93年)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得益于jpeg及mp3等数据格式的问世，用户期待图文并茂的网页 --- 小有成就&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加了 HEAD、POST 等新方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加了响应状态码，标记可能的错误原因；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了协议版本号概念；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传输的数据不再仅限于文本。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HTTP/1.1（99年）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经历了第一次浏览器大战的HTTP/1.0扛住压力，推动了http的进一步完善。--- 破茧成蝶，正式成为标准（RFC 2616）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;增加了 PUT、DELETE 等新的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增加了缓存管理和控制；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;明确了连接管理，允许持久连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许响应数据分块（chunked），利于传输大文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强制要求 Host 头，让互联网主机托管成为可能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过由于 HTTP/1.1 太过庞大和复杂，所以在 2014 年又做了一次修订，原来的一个大文档被拆分成了六份较小的文档，编号为 7230-7235，优化了一些细节，但此外没有任何实质性的改动。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;更上一层楼，HTTP/2（2015年）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“挟用户以号令天下”，Google 借此顺势把 SPDY 推上了标准的宝座，互联网标准化组织以 SPDY 为基础开始制定新版本的 HTTP 协议，最终在 2015 年发布了 HTTP/2，RFC 编号 7540。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;二进制协议，不再是纯文本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可发起多个请求，废弃了 1.1 里的管道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用专用算法压缩头部，减少数据传输量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;允许服务器主动向客户端推送数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增强了安全性，“事实上”要求加密通信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;追求极致，HTTP/3&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次还是Google，而且它要“革自己的命”。2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结合发展史的总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;从无到有&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从简单到复杂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从实现到不断的优化扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从无人知晓到无人不晓&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;追求安全、高速、便捷的传输&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家可以思考下第一个问题了，你觉得呢?
有兴趣的可以去看参考资料里的协议详解。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的报文&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3997050147492625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAQWlwiaefJOsae4oqSWHGicIOnZE43y9SGaMdyUiaSdHzUvpHL37ibG0lbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;figcaption&gt;请求行 GET / HTTP/1.1&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42668621700879766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA8LBUNCibDXicb4cMQXlo5u2RPxqnNp00MaQXELVblUuZk2w2shZXe9dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1364&quot;/&gt;&lt;figcaption&gt;状态行 HTTP/1.1 200 OK&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于头字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通用字段：在请求头和响应头里都可以出现；Date Cache-Control， Connection，Date，Pragma，Transfer-Encoding，Upgrade&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；Host，User-Agent,Referer Accept Accept-Charset Accept-Encoding Accept-Language, Authorization,Expect,From,If-Match,If-Modified-Since,If-None-Match,If-Range,If-Unmodified-Since,Max-Forwards, Range等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应字段：仅能出现在响应头里，补充说明响应报文的信息；Accept-Ranges,Age，ETag，Location，Proxy-Authenticate，Retry-After，Server，Vary等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。Content-Length，Allow，Content-Encoding，Content-Language， Content-Length，Content-Location，Content-MD5，Content-Range，Content-Type，Expires，Last-Modified&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：1，请求头的限制：各个web服务器都不允许过大的请求头，因为头部太大可能会占用大量的服务器资源，影响运行效率。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;apache2来说，它默认值是8k；Apache里，可按下面方式调整：LimitRequestLine 请求行的字节数
LimitRequestFields  请求头域的个数 默认值100
LimitRequestFieldSize 配置允许的请求头字节大小 默认值是8190
nginx默认的header长度上限是4k，也可根据情况配置，如下两种方式：client_header_buffer_size 16k;
large_client_header_buffers 4 16k;&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;2，如果header头信息请求超过了，nginx会直接返回400错误
3，关于头字段大小写，尽量首字母大写
4，字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”  。否则响应 （400 Bad Request）&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家可以思考下第二个问题了，post请求是需要向服务端提交数据的，可要结合实体字段～
有兴趣的在跟后端联调时抓包看看吧&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的缓存机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/1.0提供了Pragma及Expires的缓存字段，到HTTP/1.1扩展了更多头字段Cache-Control、Last-Modified / If-Modified-Since， Etag / If-None-Match等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么用缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在传输中间有其他备份，不用每次都去服务器请求，链路更短响应更迅速。也就是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;减少了冗余的数据传输，节省了网费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓解了服务器的压力， 大大提高了网站的性能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快了客户端加载网页的速度&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;怎么缓存的&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从网上抓了张图，如下：&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1015873015873017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAb3ZuKqjCf1V87Eico0wyWRlw8nQQaKX9KtZEefm9aCia9d9pXI0WKBaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1260&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一张图，不信你还不懂&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6037514654161782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/l7qvliaicFcd6SypgIYmFXotucODES1wmACd7iajRPJUkeH2PuQyyFuboWj6ICCNsy6Gs8tSzsrjLb0XyPDw3RlBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1706&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强缓存与协商缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.432520325203252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAibiaEc6cxJ3PBkUxKicJ7u1jWg58D8MTTEQlholleRHsYlUOr6yFjV3aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;chrome浏览器：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;200 from memory cache 不访问服务器，直接读缓存，从内存中读取缓存。此时的数据是缓存到内存中的，当kill进程后，数据将不存在
200 from disk cache 不访问服务器，直接读缓存，从磁盘中读取缓存，当kill进程时，数据还是存在。304 Not Modified 访问服务器，发现数据没有更新，服务器返回此状态码。然后从缓存中读取数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命中强制缓存时，资源会显示from memory cache or from disk cache&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存相关的头字段&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Pragma&lt;/td&gt;&lt;td&gt;&quot;no-cache&quot;表示禁用缓存 (HTTP/1.0)已废弃&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Cache-Control&lt;/td&gt;&lt;td&gt;no-store no-cache max-age等，请求响应的值页有区别&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;请求首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;&lt;td&gt;比较资源最后的更新时间是否一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Unmodified-Since&lt;/td&gt;&lt;td&gt;比较资源最后的更新时间是否不一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Match&lt;/td&gt;&lt;td&gt;比较 ETag 是否一致&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-None-Match&lt;/td&gt;&lt;td&gt;比较 ETag 是否一致&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;响应首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ETag&lt;/td&gt;&lt;td&gt;资源的匹配信息（通过强比较算法生成值）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实体首部字段&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名称&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Expires&lt;/td&gt;&lt;td&gt;资源的过期时间(HTTP/1.0)，有弊端&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Last-Modified&lt;/td&gt;&lt;td&gt;资源的最后一次修改时间&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于Cache-Control&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上找了张图，方便大家理解～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9100294985250738&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/l7qvliaicFcd6SypgIYmFXotucODES1wmAtsOx6TfzV2UU24t5ZuLBsJ21O1ANRiaOjhqQWgQb8dtzmTvLIl9nn8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1356&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;综上，大家工作的过程中也留意下chrome的network，结合思考下～&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;5&lt;/span&gt;&lt;/span&gt;&lt;span&gt;HTTP 的大文件传输&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何在有限的带宽下快捷的传输大文件呢？更有效的节省内存、带宽等资源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据压缩（把大文件整体变小）&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端请求时带上Accept-Encoding（支持的压缩方式），响应时指定Content-Encoding（此响应的压缩方式），按此压缩后发给客户端。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;gzip 等压缩算法通常只对文本文件有较好的压缩率，而图片、音频视频等多媒体数据本身就已经是高度压缩的，效果不好。在 Nginx 里就会使用“gzip on”指令，启用对“text/html”的压缩。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分块传输&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果大文件整体不能变小，那就把它“拆开”，分解成多个小块。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP协议1.1版本提供了分开传输机制（Chunked transfer encoding）。也就是服务端的”化整为零“，即把大文件拆开，分成多个小块来传输。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：HTTP/2 中已经不支持 chunked 这一格式了，因为其本身提供了更加高级的流机制来实现类似功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Transfer-Encoding&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个响应头有下面几个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;chunked：数据分块发送。此时应缺省 Content-Length 响应头。意思是报文里的 body 部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compress：使用 Lempel-Ziv-Welch 算法进行传输的格式，目前没有浏览器在支持。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;deflate：使用 deflate 压缩算法 zlib 结构。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gzip：使用 Lempel-Ziv coding 编码的压缩格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;identity：标识身份函数（e.g. no compression, nor modification）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;也可以同时指定多个值，用逗号分隔，像这样：Transfer-Encoding: gzip, chunked。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAZNLZhAbFsgpdRH6ibNtWaryxCTa3UNQyicZ6wJwhib0Ric7loicvIymMFQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAhNGNcpAZiaW33uVpQWFsYVpjjYZmZuq8B5JnYysiaQqM1yic86tX7SlWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmACeL7dlGqcudNE3HVq868KmDWBrAsjSrgsPEsxz5SX8E89QNGBSsNZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“Transfer-Encoding: chunked”和“Content-Length”这两个字段是互斥的，也就是说响应报文里这两个字段不能同时出现。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;范围请求&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP协议还提出了范围请求（range requests）的概念。允许客户端在请求头里使用专用字段来表示只获取文件的一部分，相当于是客户端的“化整为零”。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;试想你正在追剧，想拖着看，这实际上是想获取一个大文件其中的片段数据，而这时就用到范围请求了。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;相关头字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求头Range是 HTTP 范围请求的专用字段，格式是“bytes=x-y”，其中的 x 和 y 是以字节为单位的数据范围；响应头里有“Accept-Ranges: bytes”标识服务端支持范围请求的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bytes=x-y&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;表示第二个500字节：bytes=500-999&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示最后500个字节：bytes=-500&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示500字节以后的范围：bytes=500-&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个和最后一个字节：bytes=0-0,-1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时指定几个范围：bytes=500-600,601-999&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /test HTTP/1.1&lt;br/&gt;&lt;br/&gt;Host: www.test.com&lt;br/&gt;&lt;br/&gt;Range: bytes=0-31&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;响应报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HTTP/1.1 206 Partial Content&lt;br/&gt;&lt;br/&gt;Content-Length: 32&lt;br/&gt;&lt;br/&gt;Accept-Ranges: bytes&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 0-31/96&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小；开 N 个线程，每个线程使用 Range 字段划分出各自负责下载的片段，发请求传输数据；下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分就可以了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;范围请求-多段数据&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;刚才说的范围请求一次只获取一个片段，其实它还支持在 Range 头里使用多个“x-y”，一次性获取多个片段数据。请求头Range同时指定几个范围：bytes=500-600,601-999&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;特殊的 MIME 类型：“multipart/byteranges”，表示报文的 body 是由多段字节序列组成的，并且还要用一个参数“boundary=xxx”来分隔段。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;多段数据的格式与分块传输也比较类似，但它需要用分隔标记 boundary 来区分不同的片段，可以通过图来对比一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAqlrrZaN8CY0069Jdml8NjTLD7Wqgw0lH8YNI37bQiaic4zN0aW6I6Lkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每一个分段必须以“- -boundary”开始（前面加两个“-”），之后要用“Content-Type”和“Content-Range”标记这段数据的类型和所在范围，然后就像普通的响应头一样以回车换行结束，再加上分段数据，最后用一个“- -boundary- -”（前后各有两个“-”）表示所有的分段结束。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，Telnet 发出有两个范围的请求：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;请求报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /test2 HTTP/1.1&lt;br/&gt;&lt;br/&gt;Host: www.test.com&lt;br/&gt;&lt;br/&gt;Range: bytes=0-9, 20-29&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;响应报文&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HTTP/1.1 206 Partial Content&lt;br/&gt;&lt;br/&gt;Content-Type: multipart/byteranges; boundary=00000000001&lt;br/&gt;&lt;br/&gt;Content-Length: 189&lt;br/&gt;&lt;br/&gt;Connection: keep-alive&lt;br/&gt;&lt;br/&gt;Accept-Ranges: bytes&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;--00000000001&lt;br/&gt;&lt;br/&gt;Content-Type: text/plain&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 0-9/96&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// this is&lt;br/&gt;&lt;br/&gt;--00000000001&lt;br/&gt;&lt;br/&gt;Content-Type: text/plain&lt;br/&gt;&lt;br/&gt;Content-Range: bytes 20-29/96&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;ext json d&lt;br/&gt;&lt;br/&gt;--00000000001--&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;大文件传输的总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;压缩 HTML 等文本文件是传输大文件最基本的方法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段 “Content-Range”，响应状态码必须是 206；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。要注意这四种方法不是互斥的，而是可以混合起来使用，例如压缩后再分块传输，或者分段后再分块，实验环境的 URI“/16-3”就模拟了后一种的情形，你可以自己用 Telnet 试一下。》综上，大家也思考下新时代里大文件传输的方式。五、相关的协议&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;&lt;span&gt;相关的协议&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47868453105968334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmA7fQNBNYzxrRSyA3H1PqSY85dicfzvYeaxh8xxm0I7pp7vrHibiafIAr7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1642&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。它是在网络的使用中的最基本的通信协议。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用层的主要协议有HTTP、Telnet、FTP、SMTP等，是用来接收来自传输层的数据或者按不同应用要求与方式将数据传输至传输层；传输层的主要协议有UDP、TCP，是使用者使用平台和计算机信息网内部数据结合的通道，可以实现数据传输与数据共享；网络层的主要协议有ICMP、IP、IGMP，主要负责网络中数据包的传送等；而网络访问层，也叫网路接口层或数据链路层，主要协议有ARP、RARP，主要功能是提供链路管理错误检测、对不同通信媒介有关信息细节问题进行有效处理等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是wireshake的抓包，访问&lt;code&gt;http://127.0.0.1/&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.660958904109589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAUparRQtcYiaribkm9LvB0IdLykdibaCoa8EIk9c5mj85DHytGHehfjFJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;图片来源：罗老师的透析http协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wireshark 里就会有捕获的数据包（域名访问的话还会有dns解析）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8037974683544304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAjQLH96YCDffI9sHP1ia10nfplOZ60D88u6T3ewrTSfnLgCI1vxPt4Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;316&quot;/&gt;&lt;figcaption&gt;图片来源：罗老师的透析http协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；浏览器用 TCP 的三次握手与服务器建立连接；浏览器向服务器发送拼好的报文；服务器收到报文后处理请求，同样拼好报文再发给浏览器；浏览器解析报文，渲染输出页面。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面是极简情况下，现在的大多数场景更复杂，如下图：NSFileHandle_3.png&lt;img data-ratio=&quot;0.44175824175824174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l7qvliaicFcd6SypgIYmFXotucODES1wmAsw5w0fCe9VkLVibg15sFibzFquBvjLl9vwXGUgalQ8M4Y0mrx3vuRvWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上 ，最后一个问题的答案也揭晓了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;【参考资料】&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;[1] 罗剑锋（Chrono）《透视HTTP协议》(深入理解HTTP协议本质与应用)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[2] IETF RFC Hypertext Transfer Protocol 协议相关RFC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[3] IETF RFC2616 (终于成为了标准)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>196b488fbc3721e379b959e0712fbf6f</guid>
<title>分布式限流 redission RRateLimiter 的使用及原理</title>
<link>https://toutiao.io/k/8i1fczy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前提&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近公司在做有需求在做分布式限流，调研的限流框架大概有&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、spring cloud gateway集成redis限流,但属于网关层限流&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、阿里Sentinel,功能强大、带监控平台&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、srping cloud hystrix，属于接口层限流，提供线程池与信号量两种方式&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、其他：redission、手撸代码&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际需求情况属于业务端限流，redission更加方便，使用更加灵活，下面介绍下redission分布式限流如何使用及原理：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用很简单、如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 1、 声明一个限流器&lt;/span&gt;&lt;br/&gt;RRateLimiter rateLimiter = redissonClient.getRateLimiter(key);&lt;br/&gt; &lt;br/&gt;&lt;span&gt;// 2、 设置速率，5秒中产生3个令牌&lt;/span&gt;&lt;br/&gt;rateLimiter.trySetRate(RateType.OVERALL, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, RateIntervalUnit.SECONDS);&lt;br/&gt; &lt;br/&gt;&lt;span&gt;// 3、试图获取一个令牌，获取到返回true&lt;/span&gt;&lt;br/&gt;rateLimiter.tryAcquire(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、原理&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1、getRateLimiter&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 声明一个限流器 名称 叫key&lt;/span&gt;&lt;br/&gt;redissonClient.getRateLimiter(key)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2、trySetRate&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;trySetRate方法跟进去底层实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RFuture&amp;lt;Boolean&amp;gt; &lt;span&gt;trySetRateAsync&lt;/span&gt;&lt;span&gt;(RateType type, &lt;span&gt;long&lt;/span&gt; rate, &lt;span&gt;long&lt;/span&gt; rateInterval, RateIntervalUnit unit)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,&lt;br/&gt;            &lt;span&gt;&quot;redis.call(&#x27;hsetnx&#x27;, KEYS[1], &#x27;rate&#x27;, ARGV[1]);&quot;&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;redis.call(&#x27;hsetnx&#x27;, KEYS[1], &#x27;interval&#x27;, ARGV[2]);&quot;&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;return redis.call(&#x27;hsetnx&#x27;, KEYS[1], &#x27;type&#x27;, ARGV[3]);&quot;&lt;/span&gt;,&lt;br/&gt;            Collections.&amp;lt;Object&amp;gt;singletonList(getName()), rate, unit.toMillis(rateInterval), type.ordinal());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，更容易理解：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面这段代码，5秒中产生3个令牌，并且所有实例共享（&lt;code&gt;RateType.OVERALL&lt;/code&gt;所有实例共享、&lt;code&gt;RateType.CLIENT&lt;/code&gt;单实例端共享）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;trySetRate(RateType.OVERALL, 3, 5, RateIntervalUnit.SECONDS);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么redis中就会设置3个参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hsetnx,key,rate,3&lt;br/&gt;&lt;br/&gt;hsetnx,key,interval,5&lt;br/&gt;&lt;br/&gt;hsetnx,key,&lt;span&gt;type&lt;/span&gt;,0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看&lt;code&gt;tryAcquire(1)&lt;/code&gt;方法：底层源码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;RFuture&amp;lt;T&amp;gt; &lt;span&gt;tryAcquireAsync&lt;/span&gt;&lt;span&gt;(RedisCommand&amp;lt;T&amp;gt; command, Long value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,&lt;br/&gt;            &lt;span&gt;&quot;local rate = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;rate&#x27;);&quot;&lt;/span&gt;  &lt;span&gt;//1&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;local interval = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;interval&#x27;);&quot;&lt;/span&gt;  &lt;span&gt;//2&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;local type = redis.call(&#x27;hget&#x27;, KEYS[1], &#x27;type&#x27;);&quot;&lt;/span&gt; &lt;span&gt;//3&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;assert(rate ~= false and interval ~= false and type ~= false, &#x27;RateLimiter is not initialized&#x27;)&quot;&lt;/span&gt; &lt;span&gt;//4&lt;/span&gt;&lt;br/&gt;          &lt;br/&gt;          + &lt;span&gt;&quot;local valueName = KEYS[2];&quot;&lt;/span&gt; &lt;span&gt;//5&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;if type == 1 then &quot;&lt;/span&gt;&lt;br/&gt;              + &lt;span&gt;&quot;valueName = KEYS[3];&quot;&lt;/span&gt; &lt;span&gt;//6&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;end;&quot;&lt;/span&gt;&lt;br/&gt;          &lt;br/&gt;          + &lt;span&gt;&quot;local currentValue = redis.call(&#x27;get&#x27;, valueName); &quot;&lt;/span&gt; &lt;span&gt;//7&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;if currentValue ~= false then &quot;&lt;/span&gt; &lt;br/&gt;                 + &lt;span&gt;&quot;if tonumber(currentValue) &amp;lt; tonumber(ARGV[1]) then &quot;&lt;/span&gt; &lt;span&gt;//8&lt;/span&gt;&lt;br/&gt;                     + &lt;span&gt;&quot;return redis.call(&#x27;pttl&#x27;, valueName); &quot;&lt;/span&gt;&lt;br/&gt;                 + &lt;span&gt;&quot;else &quot;&lt;/span&gt;&lt;br/&gt;                     + &lt;span&gt;&quot;redis.call(&#x27;decrby&#x27;, valueName, ARGV[1]); &quot;&lt;/span&gt; &lt;span&gt;//9&lt;/span&gt;&lt;br/&gt;                     + &lt;span&gt;&quot;return nil; &quot;&lt;/span&gt;&lt;br/&gt;                 + &lt;span&gt;&quot;end; &quot;&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;else &quot;&lt;/span&gt; &lt;span&gt;//10&lt;/span&gt;&lt;br/&gt;                 + &lt;span&gt;&quot;redis.call(&#x27;set&#x27;, valueName, rate, &#x27;px&#x27;, interval); &quot;&lt;/span&gt; &lt;br/&gt;                 + &lt;span&gt;&quot;redis.call(&#x27;decrby&#x27;, valueName, ARGV[1]); &quot;&lt;/span&gt;&lt;br/&gt;                 + &lt;span&gt;&quot;return nil; &quot;&lt;/span&gt;&lt;br/&gt;          + &lt;span&gt;&quot;end;&quot;&lt;/span&gt;,&lt;br/&gt;            Arrays.&amp;lt;Object&amp;gt;asList(getName(), getValueName(), getClientValueName()), &lt;br/&gt;            value, commandExecutor.getConnectionManager().getId().toString());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第1、2、3备注行是获取上一步set的3个值：&lt;code&gt;rate、interval、type&lt;/code&gt;，如果这3个值没有设置，直接返回rateLimiter没有被初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第5备注行声明一个变量叫&lt;code&gt;valueName &lt;/code&gt;值为&lt;code&gt;KEYS[2],KEYS[2]&lt;/code&gt;对应的值是&lt;code&gt;getValueName()&lt;/code&gt;方法，&lt;code&gt;getValueName()&lt;/code&gt;返回的就是上面第一步&lt;code&gt;getRateLimiter&lt;/code&gt;我们设置的key；如果type=1，表示全局共享，那么&lt;code&gt;valueName&lt;/code&gt; 的值改为取&lt;code&gt;KEYS[3]&lt;/code&gt;，&lt;code&gt;KEYS[3]&lt;/code&gt;对应的值为&lt;code&gt;getClientValueName()&lt;/code&gt;，查看&lt;code&gt;getClientValueName()&lt;/code&gt;源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;String &lt;span&gt;getClientValueName&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; suffixName(getValueName(), commandExecutor.getConnectionManager().getId().toString());&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConnectionManager().getId()&lt;/code&gt;如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ConnectionManager&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;UUID &lt;span&gt;getId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;    省略...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个getId()是每个客户端初始化的时候生成的UUID，即每个客户端的getId是唯一的，这也就验证了&lt;code&gt;trySetRate&lt;/code&gt;方法中&lt;code&gt;RateType.ALL&lt;/code&gt;与&lt;code&gt;RateType.PER_CLIENT&lt;/code&gt;的作用。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;接着看第7标准行，获取&lt;code&gt;valueName&lt;/code&gt;对应的值&lt;code&gt;currentValue&lt;/code&gt;；首次获取肯定为空，那么看第10标准行else的逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;set valueName 3 px 5&lt;/code&gt;，设置key=valueName value=3 过期时间为5秒&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;decrby valueName 1&lt;/code&gt;，将上面valueName的值减1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;那么如果第二次访问，第7标注行返回的值存在，将会走第8标注行，紧接着走如下判断&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前valueName的值也就是3，小于要获得的令牌数量(&lt;code&gt;tryAcquire&lt;/code&gt;方法中的入参)，那么说明当前时间内（key的有效期5秒内），令牌的数量已经被用完，返回pttl(key的剩余过期时间)；反之说明桶中有足够的令牌，获取之后将会把桶中的令牌数量减1，至此结束。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redission&lt;/code&gt;分布式限流采用令牌桶思想和固定时间窗口，&lt;code&gt;trySetRate&lt;/code&gt;方法设置桶的大小，利用&lt;code&gt;redis key&lt;/code&gt;过期机制达到时间窗口目的，控制固定时间窗口内允许通过的请求量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;来源：blog.csdn.net/promisessh/article&lt;/em&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;/details/112767743&lt;/em&gt;&lt;/h3&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&amp;amp;mid=2247494250&amp;amp;idx=2&amp;amp;sn=957a5eb085292fb716d5b7db6f8a8628&amp;amp;chksm=e80e5c1cdf79d50adce9e6266562ad1e283a5997b7f3b21f3c394d20819080c2f34aea7b8eaa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最全的java面试题库&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;最全的java面试题库&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100026048&quot; data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhpqXIKV3icLwTcOzYBrWMq2XfdMVmt1XU6cIicfFIjtvVYWPuwu6TaBrdeomQfNPfgWSibLZiarZrMyvA/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;PS：因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“在看”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“星标”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持我们吧！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5af31c40f510eb5e1f0fe10ad1e6f70f</guid>
<title>Thrift 序列化协议浅析</title>
<link>https://toutiao.io/k/v6esqht</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码简图&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6463414634146342&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIw3ib5IfGdZFxBgxyfahXhvZRx3UubRW7Ls9vWCibQYqicHUCUjiaMicSzeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码具体内容&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;抓包拿到编码后的字节流（转成了十进制，方便大家看）&lt;br/&gt;&lt;br/&gt;/* 接口名长度 */         0   0   0    25&lt;br/&gt;/* 接口名 */            83  101  97  114  99  104  68  101  112  97  114  116&lt;br/&gt;                       109  101  110  116  66  121  75  101  121  119  111&lt;br/&gt;                       114  100&lt;br/&gt;/* 消息类型 */           1&lt;br/&gt;/* 消息序号 */           0   0   0   1&lt;br/&gt;/* keyword 字段类型 */   11&lt;br/&gt;/* keyword 字段ID*/     0   1&lt;br/&gt;/* keyword len */      0   0   0   4&lt;br/&gt;/* keyword value */    108   97   114   107&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; 字段类型 */     8&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; 字段ID*/       0   2&lt;br/&gt;/* &lt;span&gt;limit&lt;/span&gt; value */      0   0   0   50&lt;br/&gt;/* 字段终止符 */         0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;编码含义&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息头&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg_type：消息类型，包含四种类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Call：客户端消息。调用远程方法，并且期待对方发送响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;OneWay：客户端消息。调用远程方法，不期待响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Reply：服务端消息。正常响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Exception：服务端消息。异常响应。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;msg_seq_id：消息序号。客户端使用消息序号来处理响应的失序到达，实现请求和响应的匹配。服务端不需要检查该序列号，也不能对序列号有任何的逻辑依赖，只需要响应的时候将其原样返回即可。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;消息体&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息体分为两种编码模式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定长类型 -&amp;gt; T-V 模式，即：字段类型 + 序号 + 字段值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;变长类型 -&amp;gt; T-L-V 模式，即：字段类型 + 序号 + 字段长度 + 字段值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;field_type：字段类型，包括 String、I64、Struct、Stop 等。字段类型有两个作用：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Stop 类型用于停止嵌套解析&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非 Stop 类型用于 Skip（Skip 操作是跳过当前字段，会在「常见问题 - 兼容性」进行讲解）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fied_id：字段序号，解码时通过序号确定字段&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;len：字段长度，用于变长类型，如 String&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;value：字段值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;数据格式&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 定长数据类型&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;类型标识(8 位)&lt;/th&gt;&lt;th&gt;类型尺寸（单位：字节）&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;bool&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i16&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i32&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;i64&lt;/td&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 变长数据类型&lt;span/&gt;&lt;/h4&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;&lt;th&gt;类型标识（8 位）&lt;/th&gt;&lt;th&gt;类型尺寸（长度 + 值）&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;4 + N&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;struct&lt;/td&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;嵌套数据 + 一个字节停止符（0）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;map&lt;/td&gt;&lt;td&gt;13&lt;/td&gt;&lt;td&gt;1 + 1 + 4 + N*(X+Y) 【key 类型 + val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;set&lt;/td&gt;&lt;td&gt;14&lt;/td&gt;&lt;td&gt;1 + 4 + N 【val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;list&lt;/td&gt;&lt;td&gt;15&lt;/td&gt;&lt;td&gt;1 + 4 + N 【val 类型 + 长度 + 值】&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他协议&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Compact 协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Compact 协议是二进制压缩协议，在大部分字段的编码方式上与 Binary 协议保持一致。区别在于整数类型（包括变长类型的长度）采用了【先 zigzag 编码 ，再 varint 压缩编码】实现，最大化节省空间开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，varint 和 zigzag 是什么？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;varint 编码&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决的问题：定长存储的整数类型绝对值较小时空间浪费大&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据统计，RPC 通信时大部分时候传递的整数值都很小，如果使用定长存储会很浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个 🌰，对 i32 类型的 7 进行编码，可以说前面 3 个字节都浪费了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;00000000 00000000 00000000 00000111&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决思路：将整数类型由定长存储转为变长存储（能用 1 个字节存下就坚决不用 2 个字节）&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理并不复杂，就是将整数按 7bit 分段，每个字节的最高位作为标识位，标识后一个字节是否属于该数据。1 代表后面的字节还是属于当前数据，0 代表这是当前数据的最后一个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 i32 类型，数值 955 为例，可以看出，由原来的 4 字节压缩到了 2 字节：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;binary编码：       00000000  00000000  00000011  10111011&lt;br/&gt;切分：        0000  0000000   0000000   0000111   0111011&lt;br/&gt;compact编码：                          00000111  10111011&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，varint 编码同样存在缺陷，那就是存储大数的时候，反而会比 binary 的空间开销更大：本来 4 个字节存下的数可能需要 5 个字节，8 个字节存下的数可能需要 10 个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;zigzag 编码&lt;span/&gt;&lt;/h4&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决的问题：绝对值较小的负数经过 varint 编码后空间开销较大
举个 🌰，i32 类型的负数（-11）&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;原码：         10000000  00000000  00000000  00001011&lt;br/&gt;反码：         11111111  11111111  11111111  11110100&lt;br/&gt;补码：         11111111  11111111  11111111  11110101&lt;br/&gt;varint编码：   00001111  11111111  11111111  11111111  11110101&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，对于绝对值较小的负数，用 varint 编码以后前导 1 过多，难以压缩，空间开销比 binary 编码还大。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;解决思路：负数转正数，从而把前导 1 转成前导 0，便于 varint 压缩&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法公式 &amp;amp; 步骤 &amp;amp; 示范：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 算法公式&lt;br/&gt;32位： (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 31)&lt;br/&gt;64位： (n &amp;lt;&amp;lt; 1) ^ (n &amp;gt;&amp;gt; 63)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/*&lt;br/&gt; * 算法步骤：&lt;br/&gt; * 1. 不分正负：符号位后置，数值位前移&lt;br/&gt; * 2. 对于负数：符号位不变，数值位取反&lt;br/&gt; */&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;// 示例&lt;br/&gt;负数(-11）&lt;br/&gt;  补码：                     11111111  11111111  11111111  11110101&lt;br/&gt;  符号位后置，数值位前移：      11111111  11111111  11111111  11101011&lt;br/&gt;  符号位不变，数值位取反(21)：  00000000  00000000  00000000  00010101&lt;br/&gt;&lt;br/&gt;正数(11）&lt;br/&gt;  补码：                     00000000  00000000  00000000  00010101&lt;br/&gt;  符号位后置，数值位前移(22)：  00000000  00000000  00000000  00101010&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【奇怪的知识】为什么取名叫 zigzag？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这个算法将负数编码成正奇数，正数编码成偶数。最后效果是正负数穿插向前，就像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;编码前       编码后&lt;br/&gt;  0           0&lt;br/&gt;  -1          1&lt;br/&gt;  1           2&lt;br/&gt;  -2          3&lt;br/&gt;  2           4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Json 协议&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thrift 不仅支持二进制序列化协议，也支持 Json 这种文本协议&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据格式&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/* bool、i8、i16、i32、i64、double、string */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;类型&quot;&lt;/span&gt;: &lt;span&gt;&quot;值&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;str&quot;&lt;/span&gt;: &lt;span&gt;&quot;keyword&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* struct */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;rec&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;成员编号&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;成员类型&quot;&lt;/span&gt;: &lt;span&gt;&quot;成员值&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    ...&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;rec&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;1&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;i32&quot;&lt;/span&gt;: 50&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* map */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;map&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;键类型&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;值类型&quot;&lt;/span&gt;,&lt;br/&gt;    元素个数,&lt;br/&gt;      &lt;span&gt;&quot;键1&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;值1&quot;&lt;/span&gt;,&lt;br/&gt;      ...&lt;br/&gt;      &lt;span&gt;&quot;键n&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;值n&quot;&lt;/span&gt;&lt;br/&gt;   ]&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;6&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;map&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;i64&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;str&quot;&lt;/span&gt;,&lt;br/&gt;    1,&lt;br/&gt;    666,&lt;br/&gt;    &lt;span&gt;&quot;mapValue&quot;&lt;/span&gt;&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;/* List */&lt;br/&gt;&lt;span&gt;&quot;编号&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;set/lst&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;值类型&quot;&lt;/span&gt;,&lt;br/&gt;    元素个数,&lt;br/&gt;    &lt;span&gt;&quot;ele1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;ele2&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;elen&quot;&lt;/span&gt;&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;// 示例&lt;br/&gt;&lt;span&gt;&quot;2&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;lst&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;str&quot;&lt;/span&gt;,&lt;br/&gt;    2,&lt;br/&gt;    &lt;span&gt;&quot;lark&quot;&lt;/span&gt;,&lt;span&gt;&quot;keyword&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;case 分析&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修改字段类型导致 RPC 超时&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现象：A 服务访问 B 服务，业务逻辑短时间处理完，但整个请求 15s 超时，必现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接原因：IDL 类型被修改；并且只升级了服务端（B 服务），没升级客户端（A 服务）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31368993653671806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIiac3ia5DgujnicJnlx4uoS1aPHE7Z9rgFAq0icRmxmfSY3PkDqrClwp8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2206&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质原因：string 是变长编码，i64 是定长编码。由于客户端没有升级，所以反序列化的时候，会把 signTime 当做 string 类型来解析。而变长编码是 T-L-V 模式，所以解析的时候会把 signTime 的低位 4 字节翻译成 string 的 length。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;signTime 是时间戳，大整数，比如：1624206147902，转成二进制为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;00000000 00000000 00000001 01111010 00101010 00111011 00000001 00111110&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;低位 4 字节转成十进制为：378&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是要再读 378 个字节作为 SignTime 的值，这已经超过了整个 payload 的大小，最终导致 Socket 读超时。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;【注】修改类型不一定就会导致超时，如果 value 的值比较小，解析到的 length 也比较小，能够保证读完。但是错误的解析可能会导致各种预期之外的情况，包括：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;乱码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;空值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;报错：unknown data type xxx （skip 异常）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常见问题&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;兼容性&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;增加字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 skip 来跳过增加的字段，从而保证兼容性&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.550185873605948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIqduvE5zmCdobaa7Xhj86ZrNucsEhWDfJ65gQ78VJ95paGfpUkwy21g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2152&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;删除字段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译生成的解析代码是基于 field_id 的 switch-case 结构，语法结构上直接具备兼容性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49913344887348354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIY25mOuC4YEsviba15EvnNcLcWFNVYCib3ibl0Gyn12dVpaibGzcdXvPW8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2308&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修改字段名&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不破坏兼容性，因为 binary 协议不会对 name 进行编码&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Exception&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thrift 有两种 Exception，一种是框架内置的异常，一种是 IDL 自定义的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;框架内置的异常包括：「方法名错误」、「消息序列号错误」、「协议错误」，这些异常由框架捕获并封装成 Exception 消息，反序列化时会转成 error 并抛给上层，逻辑如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5452586206896551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPI5fdYBoZPz4artJQYfhKrIeiabySQscvsq12F9ZoeLZTDVPSTBqN1oYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一种异常是由用户在 IDL 中自定义的，关键字是 exception，用法上跟 struct 没有太大区别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28315946348733234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaQFeS3PEy4Qvdh15OU7JPIdov82JAyeXYUJRfBibgDPpbyvoIo4eAUDcmNqx1hHFFq7sBmAFXLdLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1342&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;optional、require 实现原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;optional 表示字段可填，require 表示必填&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;字段被标识为 optional 之后：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型会被编译为指针类型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;序列化代码会做空值判断，如果字段为空，则不会被编码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;字段被标识为 require 之后：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型会被编译为非指针类型（复合类型 optional 和 require 没区别）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;序列化不会做空值判断，字段一定会被编码。如果没有显式赋值，就编码默认值（默认空值，或者 IDL 显式指定的默认值）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>