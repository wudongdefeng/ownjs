<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e8d70511e6dee769862d6f21c77676fb</guid>
<title>Go 1.15 中值得关注的几个变化</title>
<link>https://toutiao.io/k/lipeqlg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://tonybai.com/wp-content/uploads/go-1.15-1.png&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tip.golang.org/doc/go1.15&quot;&gt;Go 1.15版本&lt;/a&gt;在8月12日就正式发布了，给我的感觉就是发布的挺痛快^_^。这种感觉来自与之前版本发布时间的对比：&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;发布于当年的9月4日，更早的&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;发布于当年的8月25日。&lt;/p&gt;
&lt;p&gt;不过这个时间恰与我家&lt;a href=&quot;https://tonybai.com/2020/07/29/my-second-daughter-was-born/&quot;&gt;二宝出生&lt;/a&gt;和老婆月子时期有重叠，每天照顾孩子团团转的我实在抽不出时间研究Go 1.15的变化:(。如今，我逐渐从照顾二宝的工作中脱离出来^_^，于是“Go x.xx版本值得关注的几个变化”系列将继续下去。关注Go语言的演变对掌握和精通Go语言大有裨益，凡是致力于成为一名高级Gopher的读者都应该密切关注Go的演进。&lt;br/&gt;
截至写稿时，Go 1.15最新版是Go 1.15.2。Go 1.15一如既往的遵循&lt;a href=&quot;https://tip.golang.org/doc/go1compat.html&quot;&gt;Go1兼容性承诺&lt;/a&gt;。&lt;a href=&quot;https://tip.golang.org/ref/spec&quot;&gt;语言规范&lt;/a&gt;方面没有任何变化。可以说这是一个“面子”上变化较小的一个版本，但“里子”的变化还是不少的，在本文中我就和各位读者一起就重要变化逐一了解一下。&lt;/p&gt;
&lt;h3&gt;一. 平台移植性&lt;/h3&gt;
&lt;p&gt;Go 1.15版本不再对darwin/386和darwin/arm两个32位平台提供支持了。Go 1.15及以后版本仅对darwin/amd64和darwin/arm64版本提供支持。并且不再对macOS 10.12版本之前的版本提供支持。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;中，Go编译器在被传入-race和-msan的情况下，默认会执行&lt;strong&gt;-d=checkptr&lt;/strong&gt;，即对unsafe.Pointer的使用进行&lt;a href=&quot;https://github.com/golang/go/issues/34964&quot;&gt;合法性检查&lt;/a&gt;。&lt;strong&gt;-d=checkptr&lt;/strong&gt;主要检查两项内容：&lt;/p&gt;

&lt;p&gt;但在Go 1.14中，这个检查并不适用于Windows操作系统。Go 1.15中增加了对windows系统的支持。&lt;/p&gt;
&lt;p&gt;对于&lt;a href=&quot;https://riscv.org&quot;&gt;RISC-V&lt;/a&gt;架构，Go社区展现出十分积极的姿态，早在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;，Go就为RISC-V cpu架构预留了GOARCH值：riscv和riscv64。&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot;&gt;Go 1.14版本&lt;/a&gt;则为64bit RISC-V提供了在linux上的实验性支持(GOOS=linux, GOARCH=riscv64)。在Go 1.15版本中，Go在GOOS=linux, GOARCH=riscv64的环境下的稳定性和性能得到持续提升，并且已经可以支持goroutine异步抢占式调度了。&lt;/p&gt;
&lt;h3&gt;二. 工具链&lt;/h3&gt;
&lt;h4&gt;1. GOPROXY新增以管道符为分隔符的代理列表值&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;https://tonybai.com/2019/10/27/some-changes-in-go-1-13/&quot;&gt;Go 1.13版本&lt;/a&gt;中，&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot;&gt;GOPROXY&lt;/a&gt;支持设置为多个proxy的列表，多个proxy之间采用逗号分隔。Go工具链会按顺序尝试列表中的proxy以获取依赖包数据，但是当有proxy server服务不可达或者是返回的http状态码不是404也不是410时，go会终止数据获取。但是当列表中的proxy server返回其他错误时，Go命令不会向GOPROXY列表中的下一个值所代表的的proxy server发起请求，这种行为模式没能让所有gopher满意，&lt;strong&gt;很多Gopher认为Go工具链应该向后面的proxy server请求，直到所有proxy server都返回失败&lt;/strong&gt;。Go 1.15版本满足了Go社区的需求，新增以管道符“|”为分隔符的代理列表值。如果GOPROXY配置的proxy server列表值以管道符分隔，则无论某个proxy server返回什么错误码，Go命令都会向列表中的下一个proxy server发起新的尝试请求。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：Go 1.15版本中GOPROXY环境变量的默认值依旧为&lt;strong&gt;https://proxy.golang.org,direct&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;2. module cache的存储路径可设置&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://tonybai.com/2019/06/03/the-practice-of-upgrading-major-version-under-go-module/&quot;&gt;Go module机制&lt;/a&gt;自打在&lt;a href=&quot;https://tonybai.com/2018/11/19/some-changes-in-go-1-11/&quot;&gt;Go 1.11版本&lt;/a&gt;中以试验特性的方式引入时就将module的本地缓存默认放在了&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;下（如果没有显式设置GOPATH，那么默认值将是&lt;strong&gt;~/go&lt;/strong&gt;；如果GOPATH下面配置了多个路径，那么选择第一个路径），一直到Go 1.14版本，这个位置都是无法配置的。&lt;/p&gt;
&lt;p&gt;Go module的引入为去除GOPATH提供了前提，于是module cache的位置也要尽量与GOPATH“脱钩”：Go 1.15提供了GOMODCACHE环境变量用于自定义module cache的存放位置。如果没有显式设置GOMODCACHE，那么module cache的默认存储路径依然是&lt;strong&gt;\$GOPATH/pkg/mod&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;三. 运行时、编译器和链接器&lt;/h3&gt;
&lt;h4&gt;1. panic展现形式变化&lt;/h4&gt;
&lt;p&gt;在Go 1.15之前，如果传给panic的值是bool, complex64, complex128, float32, float64, int, int8, int16, int32, int64, string, uint, uint8, uint16, uint32, uint64, uintptr等原生类型的值，那么panic在触发时会输出具体的值，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

func foo() {
    var i uint32 = 17
    panic(i)
}

func main() {
    foo()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码，得到如下结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: 17

goroutine 1 [running]:
main.foo(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:5
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:9 +0x39
exit status 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15版本亦是如此。但是对于派生于上述原生类型的自定义类型而言，Go 1.14只是输出变量地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/panic.go

package main

type myint uint32

func bar() {
    var i myint = 27
    panic(i)
}

func main() {
    bar()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用Go 1.14运行上述代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: (main.myint) (0x105fca0,0xc00008e000)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go 1.15针对此情况作了展示优化，即便是派生于这些原生类型的自定义类型变量，panic也可以输出其值。使用Go 1.15运行上述代码的结果如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run panic.go
panic: main.myint(27)

goroutine 1 [running]:
main.bar(...)
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:12
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.15-examples/runtime/panic.go:17 +0x39
exit status 2

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 将小整数([0,255])转换为interface类型值时将不会额外分配内存&lt;/h4&gt;
&lt;p&gt;Go 1.15在runtime/iface.go中做了一些优化改动：增加一个名为staticuint64s的数组，预先为[0,255]这256个数分配了内存。然后在convT16、convT32等运行时转换函数中判断要转换的整型值是否小于256(len(staticuint64s))，如果小于，则返回staticuint64s数组中对应的值的地址；否则调用mallocgc分配新内存。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$GOROOT/src/runtime/iface.go

// staticuint64s is used to avoid allocating in convTx for small integer values.
var staticuint64s = [...]uint64{
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
        0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
        0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
        0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
        0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
        0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,

        ... ...

        0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7,
        0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,

}

func convT16(val uint16) (x unsafe.Pointer) {
        if val &amp;lt; uint16(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 6)
                }
        } else {
                x = mallocgc(2, uint16Type, false)
                *(*uint16)(x) = val
        }
        return
}

func convT32(val uint32) (x unsafe.Pointer) {
        if val &amp;lt; uint32(len(staticuint64s)) {
                x = unsafe.Pointer(&amp;amp;staticuint64s[val])
                if sys.BigEndian {
                        x = add(x, 4)
                }
        } else {
                x = mallocgc(4, uint32Type, false)
                *(*uint32)(x) = val
        }
        return
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们可以用下面例子来验证一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/runtime/tinyint2interface.go

package main

import (
    &quot;math/rand&quot;
)

func convertSmallInteger() interface{} {
    i := rand.Intn(256)
    var j interface{} = i
    return j
}

func main() {
    for i := 0; i &amp;lt; 100000000; i++ {
        convertSmallInteger()
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们分别用go 1.14和go 1.15.2编译这个源文件（注意关闭内联等优化，否则很可能看不出效果）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go14 tinyint2interface.go

// go 1.15.2

go build  -gcflags=&quot;-N -l&quot; -o tinyint2interface-go15 tinyint2interface.go

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用下面命令输出程序执行时每次GC的信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$env GODEBUG=gctrace=1 ./tinyint2interface-go14
gc 1 @0.025s 0%: 0.009+0.18+0.021 ms clock, 0.079+0.079/0/0.20+0.17 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 2 @0.047s 0%: 0.003+0.14+0.013 ms clock, 0.031+0.099/0.064/0.037+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 3 @0.064s 0%: 0.008+0.20+0.016 ms clock, 0.071+0.071/0.018/0.081+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 4 @0.081s 0%: 0.005+0.14+0.013 ms clock, 0.047+0.059/0.023/0.032+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 5 @0.098s 0%: 0.005+0.10+0.017 ms clock, 0.042+0.073/0.027/0.080+0.13 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

... ...

gc 192 @3.264s 0%: 0.003+0.11+0.013 ms clock, 0.024+0.060/0.005/0.035+0.11 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 193 @3.281s 0%: 0.005+0.13+0.032 ms clock, 0.042+0.075/0.041/0.050+0.25 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 194 @3.298s 0%: 0.004+0.12+0.013 ms clock, 0.033+0.072/0.030/0.033+0.10 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P
gc 195 @3.315s 0%: 0.003+0.17+0.023 ms clock, 0.029+0.062/0.055/0.024+0.18 ms cpu, 4-&amp;gt;4-&amp;gt;0 MB, 5 MB goal, 8 P

$env GODEBUG=gctrace=1 ./tinyint2interface-go15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到和go 1.14编译的程序不断分配内存，不断导致GC相比，go1.15.2没有输出GC信息，间接证实了小整数转interface变量值时不会触发内存分配。&lt;/p&gt;
&lt;h4&gt;3. 加入更现代化的链接器(linker)&lt;/h4&gt;
&lt;p&gt;一个新版的&lt;a href=&quot;https://golang.org/s/better-linker&quot;&gt;现代化linker&lt;/a&gt;正在逐渐加入到Go中，Go 1.15是新版linker的起点。后续若干版本，linker优化会逐步加入进来。在Go 1.15中，对于大型项目，新链接器的性能要提高20%，内存占用减少30%。&lt;/p&gt;
&lt;h4&gt;4. objdump支持输出GNU汇编语法&lt;/h4&gt;
&lt;p&gt;go 1.15为objdump工具增加了-gnu选项，&lt;strong&gt;以在Go汇编的后面，辅助输出GNU汇编，便于对照&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go 1.14：

$go tool objdump -S tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)
  0x1001002             476f                    OUTSD DS:0(SI), DX
  0x1001004             206275                  ANDB AH, 0x75(DX)
  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP
... ...

//go 1.15.2：

$go tool objdump  -S -gnu tinyint2interface-go15|more
TEXT go.buildid(SB)

  0x1001000             ff20                    JMP 0(AX)                            // jmpq *(%rax)           

  0x1001002             476f                    OUTSD DS:0(SI), DX                   // rex.RXB outsl %ds:(%rsi),(%dx)
  0x1001004             206275                  ANDB AH, 0x75(DX)                    // and %ah,0x75(%rdx)     

  0x1001007             696c642049443a20        IMULL $0x203a4449, 0x20(SP), BP      // imul $0x203a4449,0x20(%rsp,%riz,2),%ebp

... ...

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;四. 标准库&lt;/h3&gt;
&lt;p&gt;和以往发布的版本一样，标准库有大量小改动，这里挑出几个笔者感兴趣的和大家一起看一下。&lt;/p&gt;
&lt;h4&gt;1. 增加tzdata包&lt;/h4&gt;
&lt;p&gt;Go time包中很多方法依赖时区数据，但不是所有平台上都自带时区数据。Go time包会以下面顺序搜寻时区数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- ZONEINFO环境变量指示的路径中

- 在类Unix系统中一些常见的存放时区数据的路径（zoneinfo_unix.go中的zoneSources数组变量中存放这些常见路径）：

    &quot;/usr/share/zoneinfo/&quot;,
    &quot;/usr/share/lib/zoneinfo/&quot;,
    &quot;/usr/lib/locale/TZ/&quot;

- 如果平台没有，则尝试使用$GOROOT/lib/time/zoneinfo.zip这个随着go发布包一起发布的时区数据。但在应用部署的环境中，很大可能不会进行go安装。

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果go应用找不到时区数据，那么go应用运行将会受到影响，就如下面这个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们移除系统的时区数据(比如将/usr/share/zoneinfo改名)和Go安装包自带的zoneinfo.zip(改个名)后，在Go 1.15.2下运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run tzdata.go
LoadLocation error: unknown time zone America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为此，Go 1.15提供了一个将时区数据嵌入到Go应用二进制文件中的方法：&lt;strong&gt;导入time/tzdata包&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/tzdata.go

package main

import (
    &quot;fmt&quot;
    &quot;time&quot;
    _ &quot;time/tzdata&quot;
)

func main() {
    loc, err := time.LoadLocation(&quot;America/New_York&quot;)
    if err != nil {
        fmt.Println(&quot;LoadLocation error:&quot;, err)
        return
    }
    fmt.Println(&quot;LoadLocation is:&quot;, loc)
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们再用go 1.15.2运行一下上述导入tzdata包的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run testtimezone.go
LoadLocation is: America/New_York

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过由于附带tzdata数据，应用二进制文件的size会增大大约800k，下面是在ubuntu下的实测值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x 1 root root 2.0M Oct 11 02:42 tzdata-withouttzdata*
-rwxr-xr-x 1 root root 2.8M Oct 11 02:42 tzdata-withtzdata*

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;2. 增加json解码限制&lt;/h4&gt;
&lt;p&gt;json包是日常使用最多的go标准库包之一，在Go 1.15中，go按照json规范的要求，为json的解码增加了一层限制：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// json规范要求

//https://tools.ietf.org/html/rfc7159#section-9

A JSON parser transforms a JSON text into another representation.  A
   JSON parser MUST accept all texts that conform to the JSON grammar.
   A JSON parser MAY accept non-JSON forms or extensions.

   An implementation may set limits on the size of texts that it
   accepts.  An implementation may set limits on the maximum depth of
   nesting.  An implementation may set limits on the range and precision
   of numbers.  An implementation may set limits on the length and
   character contents of strings.

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个限制就是增加了一个对json文本最大缩进深度值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// $GOROOT/src/encoding/json/scanner.go

// This limits the max nesting depth to prevent stack overflow.
// This is permitted by https://tools.ietf.org/html/rfc7159#section-9
const maxNestingDepth = 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果一旦传入的json文本数据缩进深度超过maxNestingDepth，那json包就会panic。当然，绝大多数情况下，我们是碰不到缩进10000层的超大json文本的。因此，该limit对于99.9999%的gopher都没啥影响。&lt;/p&gt;
&lt;h4&gt;3. reflect包&lt;/h4&gt;
&lt;p&gt;Go 1.15版本之前reflect包&lt;a href=&quot;https://github.com/golang/go/issues/38521&quot;&gt;存在一处行为不一致的问题&lt;/a&gt;，我们看下面例子(例子来源于https://play.golang.org/p/Jnga2_6Rmdf)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// go1.15-examples/stdlib/reflect.go

package main

import &quot;reflect&quot;

type u struct{}

func (u) M() { println(&quot;M&quot;) }

type t struct {
    u
    u2 u
}

func call(v reflect.Value) {
    defer func() {
        if err := recover(); err != nil {
            println(err.(string))
        }
    }()
    v.Method(0).Call(nil)
}

func main() {
    v := reflect.ValueOf(t{}) // v := t{}
    call(v)                   // v.M()
    call(v.Field(0))          // v.u.M()
    call(v.Field(1))          // v.u2.M()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用Go 1.14版本运行该示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
M
reflect: reflect.flag.mustBeExported using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到同为类型t中的非导出字段(field)的u和u2(u是以嵌入类型方式称为类型t的字段的)，通过reflect包可以调用字段u的导出方法(如输出中的第二行的M)，却无法调用非导出字段u2的导出方法（如输出中的第三行的panic信息）。&lt;/p&gt;
&lt;p&gt;这种不一致在Go 1.15版本中被修复，我们使用Go 1.15.2运行上述示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$go run reflect.go
M
reflect: reflect.Value.Call using value obtained using unexported field
reflect: reflect.Value.Call using value obtained using unexported field

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们看到reflect无法调用非导出字段u和u2的导出方法了。但是reflect依然可以通过提升到类型t的方法来间接使用u的导出方法，正如运行结果中的第一行输出。&lt;br/&gt;
&lt;strong&gt;这一改动可能会影响到遗留代码中使用reflect调用以类型嵌入形式存在的非导出字段方法的代码&lt;/strong&gt;，如果你的代码中存在这样的问题，可以直接通过提升(promote)到包裹类型(如例子中的t)中的方法（如例子中的call(v)）来替代之前的方式。&lt;/p&gt;
&lt;h3&gt;五. 小结&lt;/h3&gt;
&lt;p&gt;由于Go 1.15删除了一些GC元数据和一些无用的类型元数据，Go 1.15编译出的二进制文件size会减少5%左右。我用一个中等规模的go项目实测了一下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-rwxr-xr-x   1 tonybai  staff    23M 10 10 16:54 yunxind*
-rwxr-xr-x   1 tonybai  staff    24M  9 30 11:20 yunxind-go14*

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二进制文件size的确有变小，大约4%-5%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你还没有升级到Go 1.15，那么现在正是时候&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本文中涉及的代码可以在&lt;a href=&quot;https://github.com/bigwhite/experiments/tree/master/go1.15-examples&quot;&gt;这里&lt;/a&gt;下载。https://github.com/bigwhite/experiments/tree/master/go1.15-examples&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;我的Go技术专栏：“&lt;a href=&quot;https://www.imooc.com/read/87&quot;&gt;改善Go语⾔编程质量的50个有效实践&lt;/a&gt;”上线了，欢迎大家订阅学习！&lt;/p&gt;
&lt;p&gt;我的网课“&lt;a href=&quot;https://coding.imooc.com/class/284.html&quot;&gt;Kubernetes实战：高可用集群搭建、配置、运维与应用&lt;/a&gt;”在慕课网上线了，感谢小伙伴们学习支持！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://51smspush.com/&quot;&gt;我爱发短信&lt;/a&gt;：企业级短信平台定制开发专家 https://51smspush.com/&lt;br/&gt;
smspush : 可部署在企业内部的定制化短信平台，三网覆盖，不惧大并发接入，可定制扩展； 短信内容你来定，不再受约束, 接口丰富，支持长短信，签名可选。&lt;/p&gt;
&lt;p&gt;2020年4月8日，中国三大电信运营商联合发布《5G消息白皮书》，51短信平台也会全新升级到“51商用消息平台”，全面支持5G RCS消息。&lt;/p&gt;
&lt;p&gt;著名云主机服务厂商DigitalOcean发布最新的主机计划，入门级Droplet配置升级为：1 core CPU、1G内存、25G高速SSD，价格5$/月。有使用DigitalOcean需求的朋友，可以打开这个&lt;a href=&quot;https://m.do.co/c/bff6eed92687&quot;&gt;链接地址&lt;/a&gt;：https://m.do.co/c/bff6eed92687 开启你的DO主机之路。&lt;/p&gt;
&lt;p&gt;Gopher Daily(Gopher每日新闻)归档仓库 – https://github.com/bigwhite/gopherdaily&lt;/p&gt;
&lt;p&gt;我的联系方式：&lt;/p&gt;
&lt;p&gt;微博：https://weibo.com/bigwhite20xx&lt;br/&gt;
微信公众号：iamtonybai&lt;br/&gt;
博客：tonybai.com&lt;br/&gt;
github: https://github.com/bigwhite&lt;/p&gt;
&lt;p&gt;微信赞赏：&lt;br/&gt;
&lt;img src=&quot;https://tonybai.com/wp-content/uploads/wechat-zanshang-code-512x512.jpg&quot; alt=&quot;img{512x368}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;商务合作方式：撰稿、出书、培训、在线课程、合伙创业、咨询、广告合作。&lt;/p&gt;
&lt;p&gt;© 2020, &lt;a href=&quot;https://tonybai.com&quot;&gt;bigwhite&lt;/a&gt;. 版权所有. &lt;/p&gt;
&lt;p&gt;Related posts:&lt;/p&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2020/03/08/some-changes-in-go-1-14/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.14中值得关注的几个变化&quot;&gt;Go 1.14中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2016/02/21/some-changes-in-go-1-6/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.6中值得关注的几个变化&quot;&gt;Go 1.6中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/03/09/understanding-import-packages/&quot; rel=&quot;bookmark&quot; title=&quot;理解Golang包导入&quot;&gt;理解Golang包导入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2018/11/26/hello-go-module-proxy/&quot; rel=&quot;bookmark&quot; title=&quot;Hello，Go module proxy&quot;&gt;Hello，Go module proxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tonybai.com/2015/07/10/some-changes-in-go-1-5/&quot; rel=&quot;bookmark&quot; title=&quot;Go 1.5中值得关注的几个变化&quot;&gt;Go 1.5中值得关注的几个变化&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f79f835ec773c98b474e90f700fed766</guid>
<title>美团外卖实时数仓建设实践</title>
<link>https://toutiao.io/k/44pxclt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: 5px; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); text-align: center; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;107&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;107&quot; data-ratio=&quot;0.18532818532818532&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPgSqUNo1QscekFiaN8hrcem7WTpurZjSTib8whMJ9aeDSeOgY5jKNOLAx3ncZDibX6Iupcl9fzJeB6Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2072&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;324&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;324&quot; data-ratio=&quot;0.5612094395280236&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47goL4MxaoiaicUdpFy2JdcU0waQLKeuUu8QFft6Ba0UhplmfnfcTJ3ibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1356&quot;/&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;font-variant-numeric: normal; font-variant-east-asian: normal; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; line-height: 27.2px; widows: 1; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-bottom: -10px; margin-left: -8px; max-width: 100%; width: 18px; height: 18px; border-top: 8px solid rgb(54, 65, 173); border-left: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;section data-bgopacity=&quot;50%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-style=&quot;max-width: 100%; width: 543.333px; background: rgb(247, 247, 247); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;文章作者：朱良 美团外卖 技术专家&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;编辑整理：&lt;/span&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;Comn&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(33, 33, 33)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(247, 247, 247)&quot; data-darkmode-color-16008590572276=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(0, 128, 255)&quot;&gt;出品平台：DataFunTalk&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot; data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;max-width: 100%; width: 18px; height: 18px; border-bottom: 8px solid rgb(54, 65, 173); border-right: 8px solid rgb(54, 65, 173); box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;br data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 25px; margin-bottom: 25px; white-space: normal; max-width: 100%; font-family: -apple-system-font, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; min-height: 1em; background-color: rgb(255, 255, 255); line-height: 2em; box-sizing: border-box !important; overflow-wrap: break-word !important; visibility: visible;&quot;&gt;&lt;strong data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot;&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;本文&lt;/span&gt;&lt;span&gt;主要介绍一种通用的实时数&lt;/span&gt;&lt;span&gt;仓&lt;/span&gt;&lt;span&gt;构建的方法与实践。&lt;/span&gt;&lt;span&gt;实时数仓以端&lt;/span&gt;&lt;span&gt;到端低延迟、&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;标准化、快速响应变化、数据统一&lt;/span&gt;&lt;span&gt;为目标&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;在实践中，我们总结的最佳实践是&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;一个通用&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;实时&lt;/span&gt;&lt;span&gt;生产平台&lt;/span&gt;&lt;span&gt; + 一个通用交互式&lt;/span&gt;&lt;span&gt;实时&lt;/span&gt;&lt;span&gt;分析引擎&lt;/span&gt;&lt;span&gt;相互配合同时满足实时和准实时业务场景&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;两者合理分工，互相补充，形成易于开发、易于维护、效率最高的流水线&lt;/span&gt;&lt;span&gt;，兼顾开发效率与生产成本，以较好的投入产出比满足业务多样需求。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-backh=&quot;311&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5615819209039548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47LdsFD9fB1A4ZicE6r6zib22VSkFN5jycEiaRiauCwyiaDzS1Rmxra9MokGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时数据在美团外卖的场景是非常多的，主要有以下几点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营层面：比如实时业务变化，实时营销效果，当日营业情况以及当日实时业务趋势分析等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生产层面：比如实时系统是否可靠，系统是否稳定，实时监控系统的健康状况等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;C端用户：比如搜索推荐排序，需要实时了解用户的想法，行为、特点，给用户推荐更加关注的内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;风控侧：在外卖以及金融科技用的是非常多的，实时风险识别，反欺诈，异常交易等，都是大量应用实时数据的场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时技术及架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时计算技术选型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;238&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.43099273607748184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47wfso10tclGUNGS4vvbZH5shPEzCWXPHfJpjyHr7ibQoTeu8FBeiayyog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1239&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前开源的实时技术比较多，比较通用的是Storm、Spark Streaming以及Flink，具体要根据不同公司的业务情况进行选型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团外卖是依托美团整体的基础数据体系建设，从技术成熟度来讲，前几年用的是Storm，Storm当时在性能稳定性、可靠性以及扩展性上是无可替代的，随着Flink越来越成熟，从技术性能上以及框架设计优势上已经超越Storm，从趋势来讲就像Spark替代MR一样，Storm也会慢慢被Flink替代，当然从Storm迁移到Flink会有一个过程，我们目前有一些老的任务仍然在Storm上，也在不断推进任务迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体Storm和Flink的对比可以参考上图表格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;① Lambda架构&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;286&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5167620605069502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47lyibAfzSI31vGZcrf1xyyruL5nVeXDkkS2pH3uSeN7d20aCQ7ZFkbtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1223&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Lambda架构是比较经典的架构，以前实时的场景不是很多，以离线为主，当附加了实时场景后，由于离线和实时的时效性不同，导致技术生态是不一样的。Lambda架构相当于附加了一条实时生产链路，在应用层面进行一个整合，双路生产，各自独立。这在业务应用中也是顺理成章采用的一种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;双路生产会存在一些问题，比如加工逻辑double，开发运维也会double，资源同样会变成两个资源链路。因为存在以上问题，所以又演进了一个Kappa架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;② Kappa架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;276&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.47641886490807356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47iae7rSgYhlME0XjZK1lTc285EMJZ1TibBiahjFzJTyiajk1tkfATnOb16w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1251&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Kappa架构从架构设计来讲比较简单，生产统一，一套逻辑同时生产离线和实时。但是在实际应用场景有比较大的局限性，在业内直接用Kappa架构生产落地的案例不多见，且场景比较单一。这些问题在我们这边同样会遇到，我们也会有自己的一些思考，在后面会讲到。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;业务痛点&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;215&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.38794435857805254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47QulbL8dhO4QkNXb7rdwXFl08Qic3zqiciaMQZuZHSbDzAFhYwcRiaTMTyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在外卖业务上，我们也遇到了一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业务早期，为了满足业务需要，一般是拿到需求后case by case的先把需求完成，业务对于实时性要求是很高的，从时效性来说，没有进行中间层沉淀的机会，在这种场景下，一般是拿到业务逻辑直接嵌入，这是能想到的简单有效的方法，在业务发展初期这种开发模式比较常见。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，拿到数据源后，会经过数据清洗，扩维，通过Storm或Flink进行业务逻辑处理，最后直接进行业务输出。把这个环节拆开来看，数据源端会重复引用相同的数据源，后面进行清洗、过滤、扩维等操作，都要重复做一遍，唯一不同的是业务的代码逻辑是不一样的，如果业务较少，这种模式还可以接受，但当后续业务量上去后，会出现谁开发谁运维的情况，维护工作量会越来越大，作业无法形成统一管理。而且所有人都在申请资源，导致资源成本急速膨胀，资源不能集约有效利用，因此要思考如何从整体来进行实时数据的建设。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;数据特点与应用场景&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;236&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.4262948207171315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47yIWDicCmbsz6hSvSSiaVhr3qyqW0DXj4RLkXvXRPCXvWCYibPRB6T1LHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1255&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么如何来构建实时数仓呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先要进行拆解，有哪些数据，有哪些场景，这些场景有哪些共同特点，对于外卖场景来说一共有两大类，日志类和业务类。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;日志类：数据量特别大，半结构化，嵌套比较深。日志类的数据有个很大的特点，日志流一旦形成是不会变的，通过埋点的方式收集平台所有的日志，统一进行采集分发，就像一颗树，树根非常大，推到前端应用的时候，相当于从树根到树枝分叉的过程（从1到n的分解过程），如果所有的业务都从根上找数据，看起来路径最短，但包袱太重，数据检索效率低。日志类数据一般用于生产监控和用户行为分析，时效性要求比较高，时间窗口一般是5min或10min或截止到当前的一个状态，主要的应用是实时大屏和实时特征，例如用户每一次点击行为都能够立刻感知到等需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务类：主要是业务交易数据，业务系统一般是自成体系的，以Binlog日志的形式往下分发，业务系统都是事务型的，主要采用范式建模方式，特点是结构化的，主体非常清晰，但数据表较多，需要多表关联才能表达完整业务，因此是一个n到1的集成加工过程。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;业务类实时处理面临的几个难点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务的多状态性：业务过程从开始到结束是不断变化的，比如从下单-&amp;gt;支付-&amp;gt;配送，业务库是在原始基础上进行变更的，binlog会产生很多变化的日志。而业务分析更加关注最终状态，由此产生数据回撤计算的问题，例如10点下单，13点取消，但希望在10点减掉取消单。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务集成：业务分析数据一般无法通过单一主体表达，往往是很多表进行关联，才能得到想要的信息，在实时流中进行数据的合流对齐，往往需要较大的缓存处理且复杂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析是批量的，处理过程是流式的：对单一数据，无法形成分析，因此分析对象一定是批量的，而数据加工是逐条的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;日志类和业务类的场景一般是同时存在的，交织在一起，无论是Lambda架构还是Kappa架构，单一的应用都会有一些问题。因此针对场景来选择架构与实践才更有意义。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;05&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时数仓架构设计&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时架构：流批结合的探索&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;201&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47sczNJMdQ7XkMOyhE4UPIEoOGAYx0ia6eZ90sqC6pdib8icQc93lkxCs8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上问题，我们有自己的思考。通过流批结合的方式来应对不同的业务场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如上图所示，数据从日志统一采集到消息队列，再到数据流的ETL过程，作为基础数据流的建设是统一的。之后对于日志类实时特征，实时大屏类应用走实时流计算。对于Binlog类业务分析走实时OLAP批处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流式处理分析业务的痛点？对于范式业务，Storm和Flink都需要很大的外存，来实现数据流之间的业务对齐，需要大量的计算资源。且由于外存的限制，必须进行窗口的限定策略，最终可能放弃一些数据。计算之后，一般是存到Redis里做查询支撑，且KV存储在应对分析类查询场景中也有较多局限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时OLAP怎么实现？有没有一种自带存储的实时计算引擎，当实时数据来了之后，可以灵活的在一定范围内自由计算，并且有一定的数据承载能力，同时支持分析查询响应呢？随着技术的发展，目前MPP引擎发展非常迅速，性能也在飞快提升，所以在这种场景下就有了一种新的可能。这里我们使用的是Doris引擎。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种想法在业内也已经有实践，且成为一个重要探索方向。阿里基于ADB的实时OLAP方案等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时数仓架构设计&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;257&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.4654487688641779&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47KibeyDudX692U6G9tPnYkuBYjTB5edzka04wttibRicDjBu8ic6lX1GOiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1259&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从整个实时数仓架构来看，首先考虑的是如何管理所有的实时数据，资源如何有效整合，数据如何进行建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从方法论来讲，实时和离线是非常相似的，离线数仓早期的时候也是case by case，当数据规模涨到一定量的时候才会考虑如何治理。分层是一种非常有效的数据治理方式，所以在实时数仓如何进行管理的问题上，首先考虑的也是分层的处理逻辑，具体如下：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据源：在数据源的层面，离线和实时在数据源是一致的，主要分为日志类和业务类，日志类又包括用户日志，DB日志以及服务器日志等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;实时明细层：在明细层，为了解决重复建设的问题，要进行统一构建，利用离线数仓的模式，建设统一的基础明细数据层，按照主题进行管理，明细层的目的是给下游提供直接可用的数据，因此要对基础层进行统一的加工，比如清洗、过滤、扩维等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;汇总层：汇总层通过Flink或Storm的简洁算子直接可以算出结果，并且形成汇总指标池，所有的指标都统一在汇总层加工，所有人按照统一的规范管理建设，形成可复用的汇总结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总结起来，从整个实时数仓的建设角度来讲，首先数据建设的层次化要先建出来，先搭框架，然后定规范，每一层加工到什么程度，每一层用什么样的方式，当规范定义出来后，便于在生产上进行标准化的加工。由于要保证时效性，设计的时候，层次不能太多，对于实时性要求比较高的场景，基本可以走上图左侧的数据流，对于批量处理的需求，可以从实时明细层导入到实时olap引擎里，基于olap引擎自身的计算和查询能力进行快速的回撤计算，如上图右侧的数据流。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;06&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时平台化建设&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;257&quot; data-backw=&quot;554&quot; data-ratio=&quot;0.46359223300970875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47jXt5vT8Fa7KRhsILMX0wZSibicBH6Tibib1VEdYIcvIy7CCH8TZUrFWUhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;架构确定之后，后面考虑的是如何进行平台化的建设，实时平台化建设完全附加于实时数仓管理之上进行的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先进行功能的抽象，把功能抽象成组件，这样就可以达到标准化的生产，系统化的保障就可以更深入的建设，对于基础加工层的清洗、过滤、合流、扩维、转换、加密、筛选等功能都可以抽象出来，基础层通过这种组件化的方式构建直接可用的数据结果流。这其中会有一个问题，用户的需求多样，满足了这个用户，如何兼容其他的用户，因此可能会出现冗余加工的情况，从存储来讲，实时数据不存历史，不会消耗过多的存储，这种冗余是可以接受的，通过冗余的方式可以提高生产效率，是一种空间换时间的思想应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过基础层的加工，数据全部沉淀到IDL层，同时写到olap引擎的基础层，再往上是实时汇总层计算，基于storm、flink或doris，生产多维度的汇总指标，形成统一的汇总层，进行统一的存储分发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这些功能都有了以后，元数据管理，指标管理，数据安全性、SLA、数据质量等系统能力也会逐渐构建起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 实时基础层功能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;247&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.44692737430167595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY477SNC7QoQ7MBibmDxorSJ6d7DhLoeaiciaO4icvUVvg6mXZaVHqxyfnGtKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1253&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实时基础层的建设要解决一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是一条流重复读的问题，一条Binlog打过来，是以DB包的形式存在的，用户可能只用其中一张表，如果大家都要用，可能存在所有人都要接这个流的问题。解决方案是可以按照不同的业务解构出来，还原到基础数据流层，根据业务的需要做成范式结构，按照数仓的建模方式进行集成化的主题建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次要进行组件的封装，比如基础层的清洗、过滤、扩维等功能，通过一个很简单的表达入口，让用户将逻辑写出来。trans环节是比较灵活的，比如从一个值转换成另外一个值，对于这种自定义逻辑表达，我们也开放了自定义组件，可以通过java或python开发自定义脚本，进行数据加工。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 实时特征生产功能&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;241&quot; data-backw=&quot;554&quot; data-ratio=&quot;0.43527508090614886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY4730qXZl3NaPzKbfvhza1UuQYZRibDqYM3p6Hqib1TL6Wmia6GhVzHnu1eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1236&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征生产可以通过sql语法进行逻辑表达，底层进行逻辑的适配，透传到计算引擎，屏蔽用户对计算引擎的依赖。就像对于离线场景，目前大公司很少通过代码的方式开发，除非一些特别的case，所以基本上可以通过sql化的方式表达。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在功能层面，把指标管理的思想融合进去，原子指标、派生指标，标准计算口径，维度选择，窗口设置等操作都可以通过配置化的方式，这样可以统一解析生产逻辑，进行统一封装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一个问题，同一个源，写了很多sql，每一次提交都会起一个数据流，比较浪费资源，我们的解决方案是，通过同一条流实现动态指标的生产，在不停服务的情况下可以动态添加指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在实时平台建设过程中，更多考虑的是如何更有效的利用资源，在哪些环节更能节约化的使用资源，这是在工程方面更多考虑的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3. SLA建设&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;271&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;280&quot; data-ratio=&quot;0.4694178334561533&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47Hf4D4s4nGoLC4MmvUuY7icqz6hPWsVh1ZoUqejia4Tka3K9LVyYDzUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1357&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SLA主要解决两个问题，一个是端到端的SLA，一个是作业生产效率的SLA，我们采用埋点+上报的方式，由于实时流比较大，埋点要尽量简单，不能埋太多的东西，能表达业务即可，每个作业的输出统一上报到SLA监控平台，通过统一接口的形式，在每一个作业点上报所需要的信息，最后能够统计到端到端的SLA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实时生产中，由于链路非常长，无法控制所有链路，但是可以控制自己作业的效率，所以作业SLA也是必不可少的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4. 实时OLAP方案&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;269&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;290&quot; data-ratio=&quot;0.46534653465346537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47Je1v0UKMBnZ6uKGehEl8HLdPiaSvmoqc2nHkQyUrawBROSQgWbBa0YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1212&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过带计算能力的olap引擎来解决，不需要把一个流进行逻辑化映射，只需要解决数据实时稳定的入库问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这边采用的是doris作为高性能的olap引擎，由于业务数据产生的结果和结果之间还需要进行衍生计算，doris可以利用unique模型或聚合模型快速还原业务，还原业务的同时还可以进行汇总层的聚合，也是为了复用而设计。应用层可以是物理的，也可以是逻辑化视图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种模式重在解决业务回撤计算，比如业务状态改变，需要在历史的某个点将值变更，这种场景用流计算的成本非常大，olap模式可以很好的解决这个问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;07&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实时应用案例&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-backh=&quot;282&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.5098712446351932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY4730U1kTgqyglDkxKibr1TicWNpj6CLf092SdkBnusibiaBR9kttaGQSJlWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1165&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后通过一个案例说明，比如商家要根据用户历史下单数给用户优惠，商家需要看到历史下了多少单，历史T+1的数据要有，今天实时的数据也要有，这种场景是典型的Lambda架构，可以在doris里设计一个分区表，一个是历史分区，一个是今日分区，历史分区可以通过离线的方式生产，今日指标可以通过实时的方式计算，写到今日分区里，查询的时候进行一个简单的汇总。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景看起来比较简单，难点在于商家的量上来之后，很多简单的问题都会变的复杂，因此后面我们也会通过更多的业务输入，沉淀出更多的业务场景，抽象出来形成统一的生产方案和功能，以最小化的实时计算资源支撑多样化的业务需求，这也是未来需要达到的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-darkmode-bgcolor-16008590572276=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16008590572276=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16008590572276=&quot;rgb(136, 151, 171)&quot; data-darkmode-original-color-16008590572276=&quot;rgb(63, 74, 89)&quot; data-style=&quot;color: rgb(63, 74, 89); font-family: 微软雅黑; font-size: 11pt; letter-spacing: 0.4pt; text-align: left; text-indent: 0pt; visibility: visible;&quot;&gt;今天的分享就到这里，谢谢大家。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;在文末分享、点赞、在看，给个三连击呗~~&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;嘉宾介绍：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;274&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;274&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zHbzQPKIBPiaAVSkpJ2oms9sfuF93wY47j9w7euykic0EPa6l2ySODdthAIjgwgI56B2vMwCCq8nyeybbKGrMznA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;朱良&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;美团外卖 | 技术专家&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;朱良，5年以上传统行业数仓建设经验，6年互联网数仓经验，技术方向涉及离线，实时数仓治理，系统化能力建设，OLAP系统及引擎，大数据相关技术，重点跟进OLAP，实时技术前沿发展趋势。业务方向涉及即席查询，运营分析，策略报告产品，用户画像，人群推荐，实验评估等。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;会员推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DataFun会员计划重磅发布！多重权益加持，为你筑就数据科学家之路！扫码了解更多：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;1606&quot; data-backw=&quot;578&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;246&quot; data-ratio=&quot;2.778498609823911&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjDxn4WzaBoRRHRHicz6Iz6BrVcCia7mbUMM8Uw9JMLYM3hEia0amw4iadLt5GIiaY4Ec5FgA0MzKlFVMw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;文章推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NTMyOTI4Mw==&amp;amp;mid=2247508384&amp;amp;idx=1&amp;amp;sn=f4b9b2a8113daf5b73216258e66542e1&amp;amp;chksm=fbd713cccca09adafa33b72eb156fd7cd49a603b6ae266343e8310bb5f4eedcb25b679a7f879&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;美团外卖离线数仓建设实践&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于我们：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;DataFunTalk &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;专注于大数据、人工智能技术应用的分享与交流。发起于2017年，在北京、上海、深圳、杭州等城市举办超过100场线下沙龙、论坛及峰会，已邀请近600位专家和学者参与分享。其公众号 DataFunTalk 累计生产原创文章300+，百万+阅读，8万+精准粉丝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;160&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.27734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zHbzQPKIBPjDjicR2yOx02wNZLtRyVjaalkxbGB7NU2Paq7KM3MPhXtxKJy9M6Bs8EicpUtqCUe6fgfV4HSiaHs7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;三连击&lt;/strong&gt;呗！&lt;strong&gt;👇 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01adcab2dbf677f6b5b20faa75e94fb4</guid>
<title>怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34e6e60802faa7ddfeb293dfba09af6c</guid>
<title>Go-Zero 如何应对海量定时/延迟任务</title>
<link>https://toutiao.io/k/g1xuphe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;一个系统中存在着大量的调度任务，同时调度任务存在时间的滞后性，而大量的调度任务如果每一个都使用自己的调度器来管理任务的生命周期的话，浪费 cpu 的资源而且很低效。&lt;/p&gt;&lt;p&gt;本文来介绍 &lt;code&gt;go-zero&lt;/code&gt; 中 &lt;span&gt;延迟操作&lt;/span&gt;，它可能让开发者调度多个任务时，&lt;span&gt;只需关注具体的业务执行函数和执行时间「立即或者延迟」&lt;/span&gt;。而 &lt;span&gt;延迟操作&lt;/span&gt;，通常可以采用两个方案：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Timer&lt;/code&gt;：定时器维护一个优先队列，到时间点执行，然后把需要执行的 task 存储在 map 中&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;collection&lt;/code&gt; 中的 &lt;code&gt;timingWheel&lt;/code&gt; ，维护一个存放任务组的数组，每一个槽都维护一个存储 task 的双向链表。开始执行时，计时器每隔指定时间执行一个槽里面的 tasks。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;方案 2 把维护 task 从 &lt;code&gt;优先队列 O(nlog(n))&lt;/code&gt; 降到 &lt;code&gt;双向链表 O(1)&lt;/code&gt;，而执行 task 也只要轮询一个时间点的 tasks &lt;code&gt;O(N)&lt;/code&gt;，不需要像优先队列，放入和删除元素 &lt;code&gt;O(nlog(n))&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们先看看 &lt;code&gt;go-zero&lt;/code&gt; 中自己对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用 ：&lt;/p&gt;&lt;h2&gt;cache 中的 timingWheel&lt;/h2&gt;&lt;p&gt;首先我们先来在 &lt;code&gt;collection&lt;/code&gt; 的 &lt;code&gt;cache&lt;/code&gt; 中关于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;NewTimingWheel&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Second&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;v&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;k&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;})&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;err&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;err&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;cache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;timingWheel&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是 &lt;code&gt;cache&lt;/code&gt; 初始化中也同时初始化 &lt;code&gt;timingWheel&lt;/code&gt; 做 key 的过期处理，参数依次代表：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;interval&lt;/code&gt;：时间划分刻度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;numSlots&lt;/code&gt;：时间槽&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;execute&lt;/code&gt;：时间点执行函数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 &lt;code&gt;cache&lt;/code&gt; 中执行函数则是 &lt;span&gt;删除过期 key&lt;/span&gt;，而这个过期则由 &lt;code&gt;timingWheel&lt;/code&gt; 来控制推进时间。&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，就通过 &lt;code&gt;cache&lt;/code&gt; 对 &lt;code&gt;timingWheel&lt;/code&gt; 的使用来认识。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;初始化&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 真正做初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newTimingWheelWithClock&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ticker&lt;/span&gt; &lt;span&gt;timex&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Ticker&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;interval&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 单个时间格时间间隔&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                       &lt;span&gt;// 定时器，做时间推动，以interval为单位推进&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;slots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;         &lt;span&gt;make&lt;/span&gt;&lt;span&gt;([]&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;),&lt;/span&gt; &lt;span&gt;// 时间轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timers&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;        &lt;span&gt;NewSafeMap&lt;/span&gt;&lt;span&gt;(),&lt;/span&gt;                 &lt;span&gt;// 存储task{key, value}的map [执行execute所需要的参数]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                 &lt;span&gt;// at previous virtual circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;       &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                      &lt;span&gt;// 执行函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;      &lt;span&gt;numSlots&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;                     &lt;span&gt;// 初始化 slots num&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;    &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;       &lt;span&gt;// 以下几个channel是做task传递的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;moveChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;removeChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{}),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;drainChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;  &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})),&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;stopChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;lang&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PlaceholderType&lt;/span&gt;&lt;span&gt;),&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 把 slot 中存储的 list 全部准备好&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;initSlots&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 开启异步协程，使用 channel 来做task通信和传递&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44309647602541885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ2W2kCZ7nRZHMbt30icn6zTNbW0fHUXXCElAPH2uAMZTXCysUMru7SCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1731&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以上比较直观展示 &lt;code&gt;timingWheel&lt;/code&gt; 的 &lt;span&gt;“时间轮”&lt;/span&gt;，后面会围绕这张图解释其中推进的细节。&lt;/p&gt;&lt;p&gt;&lt;code&gt;go tw.run()&lt;/code&gt; 开一个协程做时间推动：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;select&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// 定时器做时间推动 -&amp;gt; scanAndRunTasks()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;ticker&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Chan&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// add task 会往 setChannel 输入task&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;lt;-&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setChannel&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看出，在初始化的时候就开始了 &lt;code&gt;timer&lt;/code&gt; 执行，并以&lt;code&gt;internal&lt;/code&gt;时间段转动，然后底层不停的获取来自 &lt;code&gt;slot&lt;/code&gt; 中的 &lt;code&gt;list&lt;/code&gt; 的 task，交给 &lt;code&gt;execute&lt;/code&gt; 执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5576619273301737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7KHxknp0ykgrXOwEz7FLxrxIgAL0bxQw1JFULaLOickPl2MKdd39wcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;Task Operation&lt;/h3&gt;&lt;p&gt;紧接着就是设置 &lt;code&gt;cache key&lt;/code&gt; ：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt;{})&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;_&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lruCache&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Unlock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;expiry&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;unstableExpiry&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;AroundDuration&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;expire&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;MoveTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;c&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timingWheel&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;SetTimer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;expiry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;先看在 &lt;code&gt;data map&lt;/code&gt; 中有没有存在这个 key&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存在，则更新 &lt;code&gt;expire&lt;/code&gt; -&amp;gt; &lt;code&gt;MoveTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第一次设置 key -&amp;gt; &lt;code&gt;SetTimer()&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;所以对于 &lt;code&gt;timingWheel&lt;/code&gt; 的使用上就清晰了，开发者根据需求可以 &lt;code&gt;add&lt;/code&gt; 或是 &lt;code&gt;update&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;同时我们跟源码进去会发现：&lt;code&gt;SetTimer() MoveTimer()&lt;/code&gt; 都是将 task 输送到 channel，由 &lt;code&gt;run()&lt;/code&gt; 中开启的协程不断取出 &lt;code&gt;channel&lt;/code&gt; 的 task 操作。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;code&gt;SetTimer() -&amp;gt; setTask()&lt;/code&gt;：&lt;/p&gt;&lt;p&gt;&lt;code&gt;MoveTimer() -&amp;gt; moveTask()&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由上面的调用链，有一个都会调用的函数：&lt;code&gt;moveTask()&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;moveTask&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt; &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// timers: Map =&amp;gt; 通过key获取 [positionEntry「pos, task」]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;val&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;timer&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;val&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;positionEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// {delay &amp;lt; interval} =&amp;gt; 延迟时间比一个时间格间隔还小，没有更小的刻度，说明任务应该立即执行&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;threading&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;GoSafe&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 如果 &amp;gt; interval，则通过 延迟时间delay 计算其出时间轮中的 new pos, circle&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;&amp;gt;=&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 记录前后的移动offset。为了后面过程重新入队&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 转移到下一层，将 circle 转换为 diff 一部分&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为是一个数组，要加上 numSlots [也就是相当于要走到下一层]&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 如果 offset 提前了，此时 task 也还在第一层&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 标记删除老的 task，并重新入队，等待被执行&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;newItem&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;baseEntry&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;     &lt;span&gt;timer&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;item&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;newItem&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上过程有以下几种情况：&lt;/p&gt;&lt;h3&gt;Execute&lt;/h3&gt;&lt;p&gt;之前在初始化中，&lt;code&gt;run()&lt;/code&gt; 中定时器的不断推进，推进的过程主要就是把 list 中的 task 传给执行的 &lt;code&gt;execute func&lt;/code&gt;。我们从定时器的执行开始看：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 定时器 「每隔 internal 会执行一次」&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;onTick&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 每次执行更新一下当前执行 tick 位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 获取此时 tick位置 中的存储task的双向链表&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;l&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着是如何去执行 &lt;code&gt;execute&lt;/code&gt;：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;scanAndRunTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;l&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;List&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 存储目前需要执行的task{key, value}  [execute所需要的参数，依次传递给execute执行]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;[]&lt;/span&gt;&lt;span&gt;timingTask&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Front&lt;/span&gt;&lt;span&gt;();&lt;/span&gt; &lt;span&gt;e&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;task&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Value&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;timingEntry&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 标记删除，在 scan 中做真正的删除 「删除map的data」&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;removed&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 当前执行点已经过期，但是同时不在第一层，所以当前层即然已经完成了，就会降到下一层&lt;/span&gt;&lt;br/&gt;                        &lt;span&gt;// 但是并没有修改 pos&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 因为之前已经标注了diff，需要再进入队列&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;slots&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;PushBack&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;setTimerPosition&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;diff&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 以上的情况都是不能执行的情况，能够执行的会被加入tasks中&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tasks&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;append&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;timingTask&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;key&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;   &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;value&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;})&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;next&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Next&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;l&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Remove&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;e&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;timers&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Del&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;task&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;e&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;next&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// for range tasks，然后把每个 task-&amp;gt;execute 执行即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;runTasks&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;tasks&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的分支情况在注释中说明了，在看的时候可以和前面的 &lt;code&gt;moveTask()&lt;/code&gt; 结合起来，其中 &lt;code&gt;circle&lt;/code&gt; 下降，&lt;code&gt;diff&lt;/code&gt; 的计算是关联两个函数的重点。&lt;/p&gt;&lt;p&gt;至于 &lt;code&gt;diff&lt;/code&gt; 计算就涉及到 &lt;code&gt;pos, circle&lt;/code&gt; 的计算：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// interval: 4min, d: 60min, numSlots: 16, tickedPos = 15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// step = 15, pos = 14, circle = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;TimingWheel&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;getPositionAndCircle&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;steps&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;interval&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tickedPos&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; &lt;span&gt;steps&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;tw&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;&lt;p&gt;上面的过程可以简化成下面：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;steps&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;d&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;interval&lt;/span&gt;&lt;br/&gt;&lt;span&gt;pos&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;step&lt;/span&gt; &lt;span&gt;%&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;circle&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;&lt;span&gt;step&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; &lt;span&gt;numSlots&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;timingWheel&lt;/code&gt; 靠定时器推动，时间前进的同时会取出&lt;span&gt;当前时间格&lt;/span&gt;中 &lt;code&gt;list&lt;/code&gt;「双向链表」的 task，传递到 &lt;code&gt;execute&lt;/code&gt; 中执行。因为是是靠 &lt;code&gt;internal&lt;/code&gt; 固定时间刻度推进，可能就会出现：一个 60s 的 task，&lt;code&gt;internal = 1s&lt;/code&gt;，这样就会空跑 59 次 loop。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;而在扩展时间上，采取 &lt;code&gt;circle&lt;/code&gt; 分层，这样就可以不断复用原有的 &lt;code&gt;numSlots&lt;/code&gt; ，因为定时器在不断 &lt;code&gt;loop&lt;/code&gt;，而执行可以把上层的 &lt;code&gt;slot&lt;/code&gt; 下降到下层，在不断 &lt;code&gt;loop&lt;/code&gt; 中就可以执行到上层的 task。这样的设计可以在不创造额外的数据结构，突破长时间的限制。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;同时在 &lt;code&gt;go-zero&lt;/code&gt; 中还有很多实用的组件工具，用好工具对于提升服务性能和开发效率都有很大的帮助，希望本篇文章能给大家带来一些收获。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;同时欢迎大家使用 &lt;code&gt;go-zero&lt;/code&gt; 并加入我们，项目地址 https://github.com/tal-tech/go-zero&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9966442953020134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbA2Zb6GjZc0zo2icBRxhOlfZ7h0WKmxYsOuibrQiaxZDz1RqTKufficj5HC11VUYGtwyML4ia4nerr3jMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;596&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e15c3857e0a9fb770057e870ea4187db</guid>
<title>重新信仰 PoW，今天我们有了 EPoW</title>
<link>https://toutiao.io/k/53b5ikg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;md_view&quot;&gt;
                        &lt;p&gt;今天起，我们有了EPoW。区块链世界里有一些经典的名词，比如PoW工作量证明（中本聪共识），PoS，DPoS等共识算法，或者DAG代表一种网络结构。&lt;/p&gt;
&lt;p&gt;在中本聪发明PoW算法后的第12年，我们基于PoW提出了EPoW（Eco PoW 经济的工作量证明 &lt;a href=&quot;https://eprint.iacr.org/2020/1117）本质上是一种Proof&quot;&gt;https://eprint.iacr.org/2020/1117）本质上是一种Proof&lt;/a&gt; of Replication（复制证明）。但是这种复制证明的优点是，可以在做复制工作的同时，产生工作量证明。&lt;/p&gt;
&lt;h2&gt;首先，为什么要区块链存储？&lt;/h2&gt;
&lt;p&gt;现阶段的区块链，应用比如虚拟货币，存证或者溯源，甚至DeFi，主要是把区块链当成不可篡改的数据库来用。
简单回顾一下，创建一个互联网应用需要的技术：通常是服务器软件(Apache/Nginx/IIS)和数据库(MySQL/SQL Server)。文件服务器让硬盘上的资源可以被互联网访问，比如照片，音频，视频，软件包，和网页。
可以说，在区块链应用这个世界里，我们是先有数据库，但目前还没有可靠的文件服务器（IPFS没有区块链），因为这些静态数据目前只能放在链下，并不能上链。
链下的数据会被移动，删除。只有数据本身被区块链托管，复制，定期检查，才有可能保证数据安全和完整性。&lt;/p&gt;
&lt;h2&gt;我们需要理解一下复制证明，这是目前区块链文件存储算法的基石&lt;/h2&gt;
&lt;p&gt;因为区块链和云计算的背景不一样，云计算通常由商业公司提供，区块链网络往往由矿工们提供资源，赚取代币回报。
由一家公司提供的服务，最大的风险在于这家公司是否能一直存在。由于经营决策，360网盘等已经宣布关闭，用户不得不迁移数据。&lt;/p&gt;
&lt;p&gt;由多方提供资源的区块链，面临新的问题，就是资源提供方不一定会诚实的履行自己的承诺。一旦可以作弊来节省资源投入，很快其他人就会效仿。在区块链存储这方面，有一个抄作业问题：简单说，一个班的同学必须至少有一个人自己做了作业，这样全班才有作业可抄。同样的道理，文件存到多方，如果一些节点删除了文件，那么还有可能从其他诚实的节点恢复文件。如果连最后一份文件的拷贝都被删除了，那么这个文件就永远无法恢复了（不考虑磁盘恢复）&lt;/p&gt;
&lt;p&gt;解决这个作弊行为的方案就是复制证明。
假设三个存储节点自己有唯一的名字，那么同一份文件被三个存储节点存储时，按照约定我们不存文件的原文，而是存储用各自的名字编码的文件复制。这样同一份内容在三个节点的硬盘上，存为三份唯一的文件，解码后的结果是一样的。
最后，复制还有一个特点就是编码慢，解码快。理性的矿工宁可花钱购买硬盘存储，也不会选择删除复制文件重新生成，因为成本更高。&lt;/p&gt;
&lt;p&gt;复制证明是区块链存储的关键技术！&lt;/p&gt;
&lt;h2&gt;回顾一下工作量证明&lt;/h2&gt;
&lt;p&gt;中本聪提出的工作量证明，提出了以计算能力作为选票，形成共识。因为在计算机世界，身份是很容易伪造的。一个矿工为了被选举成功（并得到成功后的收益），可以创建任意多个身份，来获得更高的回报。这被称为女巫攻击。&lt;/p&gt;
&lt;p&gt;因为计算资源（CPU，GPU）是需要花钱买的，有限的。所以用计算资源的工作成果作为选票，形成共识。这里工作量证明有几个作用，以比特币为例 1.保护区块链的安全，因为投入了硬件和能源资源，所以其他人攻击的成本更高 2.选举，决定谁有权生成下一个区块，有手续费
3.初始币的分配，决定市场上最初的钱是哪里来的&lt;/p&gt;
&lt;p&gt;其中，初始币和手续费是吸引矿工投入资源挖矿的重要激励。随着币价升高，人们也更愿意投入更多资源。一旦在区块链中移除虚拟币的设计，就没有矿工会投入资源。&lt;/p&gt;
&lt;p&gt;作为回报，区块链得到了自己需要啊安全保护，巨大的算力保护着区块链本身，不被恶意的分叉，双花。&lt;/p&gt;
&lt;h2&gt;工作量证明的最大问题是什么？为什么会有PoS，DPoS这样的代替算法出现&lt;/h2&gt;
&lt;p&gt;耗电。由于比特币的总量稀缺，币价较高，所以为了赚取初始分配的比特币，矿工马力全开的争夺，这造成了能源的浪费。对于用户来说，矿机输出的工作量证明仅仅是保护了区块链的安全，并没有其他的实际用途。&lt;/p&gt;
&lt;p&gt;PoS的提出就是为了创建低耗能的区块链，DPoS则是性能上的改进。这方面介绍的文章较多，这里就不再展开。需要指出的是，我们认为共识算法与区块链性能之间没有必然联系，使用PoW也能设计出高性能区块链。&lt;/p&gt;
&lt;h2&gt;EPoW是一种复制证明&lt;/h2&gt;
&lt;p&gt;EPoW是一种复制证明，它使用PoW算法来做复制证明需要的编码工作。这样的算法符合复制证明中编码昂贵（慢），解码便宜（快）的原则。&lt;/p&gt;
&lt;p&gt;在此之前，业界先驱Filecoin提出过使用VDF和零知识证明的算法实现的复制证明。相比，我们的算法实现起来非常的简单，并且可以运行在超低规格的服务器上，比如树莓派。&lt;/p&gt;
&lt;p&gt;除此以外，EPoW可以在复制数据的同时也生成工作量证明，保护区块链的安全。&lt;/p&gt;
&lt;h2&gt;我只有一份算力，是用EPoW做复制证明，还是用来生成工作量证明以保护区块链安全？&lt;/h2&gt;
&lt;p&gt;这正是EPoW的绝妙之处：在做复制证明的同时，我们可以得到免费的工作量证明。&lt;/p&gt;
&lt;p&gt;以往，我们为了获得虚拟币而工作，努力消费更多的电力换取虚拟币，从区块链角度看，得到了工作量证明以保护链安全。现在，矿工为了挣钱（法币）而按需工作（有新文件需要复制证明时候工作，没有则不工作），顺带产生免费的工作量证明，来保护区块链安全。&lt;/p&gt;
&lt;h2&gt;既然还是用到PoW算法，为什么EPoW是经济的？&lt;/h2&gt;
&lt;p&gt;因为我们去掉了激励方式，虚拟币。以往，为了得到币，矿工会开足算力争夺“初始币分配”，也就是挖矿。但是无论我们投入多少资源，比特币的产出是恒定的。所以单位币需要承载更对的价值(涨价)，这是币价一定涨的内在逻辑，因为挖矿成本(难度)在增加。&lt;/p&gt;
&lt;p&gt;我们用复制证明编码并存储文件，这是一种切实的工作。EPoW能输出复制编码和工作的证明，虽然消耗了能源，但是是理性的。一旦没有新的复制任务，矿工不会主动消耗电力创建无意义的工作量证明。所以我们的算法是经济的工作量证明，就像运行在经济省油模式的汽车，以节约能源为目标。&lt;/p&gt;
&lt;h2&gt;为什么EPoW是无币区块链的关键技术？&lt;/h2&gt;
&lt;p&gt;区块链设计以虚拟币作为奖励，原因就是它的价格对于法币是浮动的。如果以法币来做激励，那么挖矿的成本一定会被控制在预期收入以内，区块链就不可能从矿工处得到越多越好的算力来保护区块链。&lt;/p&gt;
&lt;p&gt;使用EPoW，用户将存储需求交给区块链，并支付法币。资源提供方付出资源，并得到稳定的法币回报。&lt;/p&gt;
&lt;h2&gt;EPoW对现有已投入的区块链算力挖矿的硬件有什么影响？&lt;/h2&gt;
&lt;p&gt;老旧的矿机，由于生产的时候技术限制，单位能源产生的算力较低。这些老旧的矿机挖矿挣到的钱还不够支付消耗的能源，它们有关机价。也就是说比特币的价格如果低于一个点，这些老矿机宁可关机，因为开着也是亏本。然而这些早期投资依然能产生可观的算力来保护区块链网络，如果他们可以找到适当的理由来使用这些算力，如果有人可以支付开机成本。&lt;/p&gt;
&lt;p&gt;EPoW是一种有用的PoW，使用EPoW设计的区块链可以&#x27;复活&#x27;很多老的矿机，使得我们过去在算力上的投资没有白花。&lt;/p&gt;
&lt;h2&gt;对现有矿池有什么影响？&lt;/h2&gt;
&lt;p&gt;加入矿池，本质上是向矿池出售算力换取稳定的回报。
对于区块链的风险，是矿池控制了大量算力，一旦某矿池超过50%，它就有了作恶的能力。矿池的出现可能是中本聪没有预料到的，区块链更欢迎分散的算力。&lt;/p&gt;
&lt;p&gt;由于EPoW本地使用了算力，所以从矿池接一些任务进行计算的外包式挣钱法，就有点不太合适。使用EPoW本来就可以通过贡献资源来挣钱，而如果是比特币，没有巨大算力的情况下，不加入矿池，坚持独立挖矿，爆块的概率比中彩票还低，很有可能一整年颗粒无收。&lt;/p&gt;
&lt;p&gt;EPoW将使得区块链再次回到独立挖矿的田园时代，矿池将不再有能力获得寡头算力，这将极大的保障区块链安全。&lt;/p&gt;                    &lt;/div&gt;
                    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>