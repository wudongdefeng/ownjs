<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>348f9ad808ff5a4174e71db7674cc0ec</guid>
<title>收钱吧研发效能实践之工具篇</title>
<link>https://toutiao.io/k/2z8fuzj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编辑 | 邵一帆，徐豪&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFPk5LibqaPIcafkRB7GAOksacGeKO6d420HJiaSGqeIz6BpeOnVyicYEug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在降本增效火起来之前，每个研发团队就已经对效能二字充满了非比寻常的热忱与执着。究其原因，就在于研发工作经常会给人带来巨大的困扰。其一，每次代码提交后，研发人员都需要进行构建、测试、部署、合并等大量重复性的工作，当项目临近发布日期时，便倍感压力；其二，依赖手工的配置管理难免会在这种重复性的工作中出现人为错误；其三，在产品交付过程中，由于必要又不太熟悉的工具、看不懂的各种报错、搜不到的解决方法等技术上的壁垒存在，同样耗费研发人员大量的时间精力。怎样减少研发人员的时间不被无谓的浪费，如何将人的效率最大化激发利用，从而释放研发人员的创造性和积极性，是每个研发团队都会耗费心力去思考的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于研发效能的理论、体系、指标、框架方面的文章，近年来在网上层出不穷，其中也不乏有一些大牛的理论分析与实践建议，如，&lt;span&gt;InfoQ&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;上有一整个专题讨论研发效能。我们在此对理论和管理上的分析和设计不做赘述，仅简单介绍收钱吧在工程和工具层面所做的实践和改进。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CI/CD&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;研发效能工具链的提升，首当其冲离不开CI/CD。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5542168674698795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFNuQ9jNnibLh8biaXzRPFSPlabaczic99K4mqicibjib0TaZAzPAiaYoz7xVSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1494&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CI全称Continuous Integration，意思是持续集成，指在开发过程中，经常性地提交代码与之前的代码进行集成，每次集成都经过一些自动化过程进行验证，如自动构建、自动测试、自动部署等，这样就可以提高代码开发和集成的效率，并且可以尽可能早的发现集成过程中的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CD通常指Continuous Delivery，意思是持续交付，它建立在持续集成的基础上，对软件产品进行发布和部署。现在，CI/CD通常一起使用，来指代提交代码到上线发布过程中的一系列自动化流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CI/CD的建设水平，直接关系研发团队的生产效率和产品的交付周期。理想情况下，从提交代码到上线发布都通过自动化流程实现，无需人工介入，而现实情况中上线发布难免会受到一些人工的干预，有时候是因为技术的原因，有时候是因为业务的原因。在这样的情况下，我们介绍下收钱吧在建设CI/CD流程中遇到的问题以及对应的解决方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CI/CD流程优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年之前，收钱吧使用Jenkins作为CI/CD的解决方案。Jenkins是一款开源CI/CD软件，用于监控持续重复的工作，每次集成都通过自动化的构建(包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。Jenkins扩展性较好，插件的拓展可以大大提升研发效率和规范产品开发流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34195402298850575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFDoo8xgaOCIAourJmPrveIib1PGYDkSYjt0j2dePJNGsZYGgElQ0ibXwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;696&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Jenkins，可以很容易配置出CI/CD的流水线。但是随着业务的发展，Jenkins的弊端也逐渐显现出来。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;公司大多数项目是直接通过Jenkins界面配置项目的Pipeline Script，在发布过程中，由于项目的CI流程如出一辙，造成了大量重复配置，加剧了系统开销，也增加了维护难度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于在界面配置Pipeline，开发者无法对脚本进行版本管理，便导致了同一项目代码的不同分支无法执行不同的CI流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Jenkins本身需要一定的维护成本，管理密钥、插件，安装agent，开发共享库等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在2018年，公司将所有服务从Docker部署迁移到K8S集群部署，原来Jenkins上的使用Docker部署的CI流程不再适用。由于逐个修改Pipeline脚本工程浩大，再加上，公司代码原本就托管在的Gitlab上，所以考虑到将CI流程迁移到Gitlab内置的CI上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6312056737588653&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLF3ibiaIItvpVaUebia3bPO0mr9GPkcVTapVialoWLVgEMbFMkt34vQFc5kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比于Jenkins，Gitlab CI具有很多先天的优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Gitlab自身就是版本管理工具，CI配置文件先天就具有版本控制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本身作为代码仓库，无需在拉取代码上做权限控制，开发人员的Gitlab用户权限就是CI流程对代码仓库拥有的权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CI的执行日志就集成在Gitlab上，查看日志的方便度大大提高，并且，日志可以清晰地显示代码分支和提交时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以方便地在不同项目之间触发关联的构建&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了这些先天优势，Gitlab CI的配置文件也非常简单，几乎没有学习成本，而且模版文件的创建和引用，相比于Jenkins来说也要简单许多。Gitlab还支持多种执行器，适应不同的使用场景。我们目前使用K8S执行器。当任务规模达到一定量后，K8S几乎是一个必然的选择，相较于其他执行器，它有以下优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;安装简单，使用Helm一键安装，而且自动注册&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过提供统一的基础镜像，任务可以运行在我们提供的纯净环境中，避免环境污染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无需关注任务的资源调度问题，资源分配由K8S集群处理，资源可以做到弹性伸缩，节省费用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收钱吧使用Gitlab CI的实施方案：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.5629405840886204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFPcRzVbJllSKZoctRF7511dNHSVgMrfUZlOtmmGibaa9mT34B6knEibOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;组件化配置：创建了统一的CI配置仓库，每种类型的任务可以定义成单独的模版文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自由组装：业务项目引用仓库配置，最终的执行流程，由多个模版文件合并后的结果决定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务管理：CI/CD任务由Gitlab进行管理，包括任务生命周期管理、日志收集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;资源管理：资源调度由K8S集群管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码分支自动化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CI/CD进行的是代码提交到部署之间的自动化，而我们在不断优化CI/CD流程的基础上，又将自动化向前进行了延伸，在代码提交之前，也进行了自动化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大多数软件公司中，需求管理和代码开发之间常常是断开的，或者即使有关联也是人工进行关联，代码分支也由开发人员手动管理，这样就会造成以下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码分支管理混乱：分支名称、tag标注如若没有人为规范，服务扩展性便会下降，技术管理的复杂性也会提升&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码和需求之间关联困难：当需求增加、一人多需求并行开发、单需求多人协作，可能会造成代码提交错分支、返工，降低开发效率&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收钱吧目前使用Jira做项目管理，依托Jira的插件和工作流能力，开发了分支代码自动化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9598765432098766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFibsKPEtk7icor80d7XJSdCSNSFX4EfiaqxFq4gebTyySlJfFQCTLibO2VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个Jira主任务下可以创建多个子任务，子任务创建时，可以选择对应的Gitlab项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子任务进入开发流程时，系统自动会创建对应的release分支和feature分支，开发人员将对应分支pull到本地即可进行开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子任务提交审查后，会自动创建Merge Request，代码审查通过后合并入release分支&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试人员使用release分支进行测试，测试通过后合入主分支，系统自动打上tag&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这只是一个简化的模型，实际应用过程中，可以根据Jira的不同的任务类型，决定代码分支的管理模型。统一的分支管理、任务和分支的双向关联，可以让开发人员的认知保持一致，使个人的多任务开发的分支管理不再混乱，使多人协同开发、跨团队之间的合作，减少了很多不必要的沟通成本。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;制品管理优化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到CI/CD，就不能不说制品管理。制品是在CI/CD过程中产生的各种软件产品，如jar包、npm包、Docker镜像等等。这些制品会被其他的项目依赖或者被其他的CI流程使用，需要进行管理，能够方便地存储和查询，同时要对不同的制品进行权限管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在优化之前，制品关联存在以下乱象：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;各种编程语言的制品分散在各个仓库，没有统一管理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制品仓库没有权限管理，开发本地、CI流程中都可以任意上传，甚至覆盖，造成依赖关系混乱&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发、预发布、生产等各个阶段的制品混杂在一起，无法识别制品的有效性和稳定性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制品的各种规范，如命名、版本管理，没有强制的流程来保证&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;交付的软件都是在这些制品上构建起来的，如果制品是一团混乱，那最终交付的软件的可靠性也需要打一个问号。所以我们为了完成以下目标，重新设计了制品管理流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;统一的制品仓库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分仓库存储不同阶段制品&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制品经过验证后晋级&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;区分各阶段仓库读写权限&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在制品管理改造的方案上，收钱吧选择了JFrog，对所有制品进行统一管理。同时在JFrog的基础上，结合自身的研发流程特性，设计了制品的上传和晋级逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;制品上传逻辑：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6230677764565993&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFH7oumQaagYMKqajzMDAM8h6jGneseR81cMSDLGzN3Xd7666ce7mXibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;841&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;仓库隔离：不稳定制品的dev仓库和相对稳定的staging仓库隔离，制品解析时互不干扰。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CI/CD Runner隔离：dev runner和staging runner的环境配置隔离，不同的runner拥有不同仓库权限&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上传权限：本地调试和开发阶段CI的制品，只能上传dev仓库；只有预发布阶段的runner可以上传制品到staging仓库；prod仓库的制品无法上传，只能从staging仓库中晋级&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;制品晋级逻辑：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46554149085794655&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFwpqWPvib0qyQaj3TWKfjrxeWoNibGeu6viaYWSxpcAm7QzWJFlQV7XPibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;镜像交付：生产环境部署的镜像，和预发布过程中验证的镜像，只能是同一个镜像。记录镜像中使用的制品以及制品的依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;合规验证：测试完成之后，在预发布阶段进行镜像合规验证，验证通过之后，镜像晋级，可以在生产部署&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制品晋级：镜像上线验证通过后，镜像对应的制品及其依赖晋级到生产，供其他项目依赖使用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过仓库隔离和权限控制，既保证开发测试环境的灵活方便，又保证预发布和生产环境安全稳定。在CI流程中，还可以增加一些个性化的控制，如可以控制制品的覆盖逻辑、上传各个仓库制品需要满足的命名规范等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SCA&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在建立起规范的制品管理流程的基础上，CI/CD流程中便可以加入软件成分分析(&lt;span&gt;SCA&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;)。SCA是分析软件组件成分的一套方法论，它要求我们重视我们的应用程序代码中依赖的组件成分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么SCA如此重要？根据&lt;span&gt;Snyk Vulnerability DB&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;披露的漏洞数据来看，开源软件每年新增的漏洞数基本都在逐年增加。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6458583433373349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLF1mKXXlicEfwOYn6d78oIdIcBjTUcHzgV7eibUu7HGOTJkquicib1zMWpcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1666&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如今，绝大多数应用程序的代码都会依赖大量的开源组件，只对自研部分代码进行静态扫描、单元测试等动作是不够的。这些开源组件中可能会包含严重的漏洞，包括近期著名的log4j漏洞。如何识别这种潜在的威胁，成了软件开发中的挑战。SCA主要具有以下挑战：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码的低可见性：应用程序中依赖组件，组件中又依赖其他组件，层层的依赖，使得应用程序很难弄清楚到底使用了开源组件中的哪些代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;依赖逻辑：层层的依赖过于复杂，我们需要工具来支持组件的逻辑依赖关系&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;漏洞数据库：关于组件漏洞的数据分布在各种数据源里面，漏洞和被影响的组件匹配也比较困难，有些数据源存在漏洞数据滞后的问题&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较成熟的SCA解决方案有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;商业版解决方案：JFrog Xray、WhiteSource、Snyk等，商业版的最大缺点就是价格昂贵，每年至少需要多花费10多万元&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源解决方案：DependencyCheck，有Jenkins和SonarQube插件，但是测试下来有比较多的漏报误报，而且依赖的NVD数据更新不是特别及时&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不管是开源的方案，还是商业版的方案，都只是用来分析软件依赖中的存在高危漏洞的开源组件成分，对于公司内部自研的组件，如果存在业务需求需要强制将对应组件废弃，那以上方案都无法满足。基于上述原因，收钱吧自研了SCA分析，并将分析结果与发布流程结合：&lt;img data-ratio=&quot;0.3262092238470191&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFIrgtleOqCHbyLLM6AqF0fFO2hhWa0VKTjdmcpiau16wFG5TqZ8DibvUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;CI依赖解析：在CI构建过程中，将应用程序的依赖关系上传Next平台，Next平台分析依赖树，结合漏洞数据库，生成高危组件报表，同时给黑白名单决策提供依据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上线流程控制：命中黑白名单的组件，包括开源组件和公司自研组件，依赖这些组件的应用、docker镜像，Next平台都会拦截它们的上线发布，SCA流程的完善，将对应用程序的安全性提供一定保障&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统上线之后，截至目前共分析出469个应用中共206个不同的高危组件，且提供完整的报告和修复建议。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5765895953757225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFZp1IsBXSeRmwlvsr8XmIVDXepPBrekN0x2gn8mp3mYNicDFrvLrlg2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1384&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45597775718257644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFF43qg42MHYib4JB0tjY6a1OYmp6ZR1EcLoEgKT4re5G4liaosD4lGcWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，在应用部署过程中进行拦截。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.55765595463138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFQpyAiacbNPcTaygTzoSN8u1tsrG4t0lPTdczeo5mLk3iaTA6yLz1eJ6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2116&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5949656750572082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFMdia0ocjBib95lD3FYN6whGYDFRqEbVwia1QIP18PNajQ1EI98MxVFq3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Next平台&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CI/CD中提到的几种优化方法，仅仅只是一些支离破碎的点和线，所有这些点和线，都由收钱吧内部系统Next平台编织成面。在&lt;span&gt;《收钱吧多泳道环境的演进》&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;一文中简单提到过Next平台。Next平台定位为一站式研发流程管理平台，目前它的主要功能有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目管理：跟踪项目管理过程中的各个阶段，记录项目进度，管控上线发布，管理项目成员，自动化项目过程中的文书工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用管理和部署：管理收钱吧的应用程序，提供将它们部署到K8S集群的能力，提供多泳道环境支持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;制品管理：查看和搜索制品，漏洞组件数据库，应用漏洞组件数据统计&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;团队报表：各团队项目用时统计信息，各项目阶段耗时甘特图，项目bug统计信息等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的软件交付流程中，大致都会经历开发、测试、预发布、上线等阶段，虽然每个阶段内有CI的支持，但是阶段之间的转换常常需要人工进行确认，可能包含会议或者邮件等形式。在Next平台上，项目流程管理是核心功能，其他功能都围绕它进行展开。项目各个阶段中产生的技术指标，可以成为进入下一阶段的评估条件，在阶段的转换中，逐渐弱化人工确认，强化使用技术指标作为阶段转换的条件。这样，可以使得CI中各项指标为研发流程所用，研发流程可以最大化地实现自动化、标准化，从而提升研发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然Next平台目前支持的功能还比较有限，但未来将有越来越多在研发流程中需要用到的功能通过插件的形式集成进来，从而提供更多的技术指标，建立起越来越完善的研发交付流程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9197674418604651&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YEpicuFL4EKNchwE1XvfGLFpfS74357WuDmQvUDZ1j7ic4O6PaBcJr3dLqw0R1iakhIwReDrxno2grQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着收钱吧业务日益复杂，为了帮助研发团队提高生产效率、缩短产品的交付周期，我们对CI/CD做了以上优化。在CI/CD流程的优化使得同样多的硬件资源可以支持更多的任务，并且因为CI任务时间分布明显的峰谷特点，依托k8s集群的资源调度加上节点弹性伸缩，并且硬件成本也进一步压缩，节省开支。针对技术管理的痛点，代码分支自动化和制品管理的优化帮助研发人员更加高效地专注于业务需求，无需处理琐碎的技术细节，提高生产效率。我们自研的SCA解决方案，在一个季度内也完成开发和推动落地工作，不但具有商业解决方案（至少10万元/年）的功能，而且能够融入原有的项目交付流程，降低交付项目中存在的安全隐患。未来，关于Next项目方面的工作，我们将持续扩展工具链，将工具插件化，丰富Next平台生态，同时充分利用工具输出的结果，完善指标体系，让项目交付规范化、标准化。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于作者&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刘宁，来自技术平台部&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;研发效能启示录: &lt;em&gt;https://www.infoq.cn/theme/107&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;Guide to Software Composition Analysis (SCA): &lt;em&gt;https://snyk.io/series/open-source-security/software-composition-analysis-sca/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Open Source Vulnerability Database: &lt;em&gt;https://security.snyk.io/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;《收钱吧多泳道环境的演进》: &lt;em&gt;https://mp.weixin.qq.com/s/8DlQ4Q6lqACn4WUMjsPzgw&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMjg0MTgyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/1Qj2bOmgI3YPol9gdadazk1llKOjMcqb6xzZMc0cg7XwcrCmU0E1B2SQOI8ibL4v5oDVkTSPEZ1hkPCggBJHIyg/0?wx_fmt=png&quot; data-nickname=&quot;SQB Blog&quot; data-alias=&quot;&quot; data-signature=&quot;谢谢有你们。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27049ef517cc2796b330c860977adb98</guid>
<title>横贯八方揭秘RabbitMQ、RocketMQ、Kafka 的核心原理（建议收藏）</title>
<link>https://toutiao.io/k/ixymws7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ各组件的功能&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Broker&lt;/code&gt; ：一个RabbitMQ实例就是一个Broker&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Virtual Host&lt;/code&gt; ：虚拟主机。&lt;strong&gt;相当于MySQL的DataBase&lt;/strong&gt; ，一个Broker上可以存在多个vhost，vhost之间相互隔离。每个vhost都拥有自己的队列、交换机、绑定和权限机制。vhost必须在连接时指定，默认的vhost是/。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Exchange&lt;/code&gt; ：交换机，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Queue&lt;/code&gt; ：消息队列，用来保存消息直到发送给消费者。它是消息的容器。一个消息可投入一个或多个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Banding&lt;/code&gt; ：绑定关系，用于 &lt;strong&gt;消息队列和交换机之间的关联&lt;/strong&gt; 。通过路由键（ &lt;strong&gt;Routing Key&lt;/strong&gt; ）将交换机和消息队列关联起来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Channel&lt;/code&gt; ：管道，一条双向数据流通道。不管是发布消息、订阅队列还是接收消息，这些动作都是通过管道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了管道的概念，以复用一条TCP连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Connection&lt;/code&gt; ：生产者/消费者 与broker之间的TCP连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Publisher&lt;/code&gt; ：消息的生产者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Consumer&lt;/code&gt; ：消息的消费者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Message&lt;/code&gt; ：消息，它是由消息头和消息体组成。消息头则包括 &lt;strong&gt;Routing-Key&lt;/strong&gt; 、 &lt;strong&gt;Priority&lt;/strong&gt; （优先级）等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaL8LI0fl5F9P9uwRgKmAg2te0LffgQ1ticcG8NZJ6Wds0hq166vFYzogQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Exchange 分发消息给 Queue 时， Exchange 的类型对应不同的分发策略，有3种类型的 Exchange ：&lt;strong&gt;Direct&lt;/strong&gt; 、 &lt;strong&gt;Fanout&lt;/strong&gt; 、 &lt;strong&gt;Topic&lt;/strong&gt; 。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Direct&lt;/strong&gt; ：消息中的 Routing Key 如果和 Binding 中的 Routing Key 完全一致， Exchange 就会将消息分发到对应的队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Fanout&lt;/strong&gt; ：每个发到 Fanout 类型交换机的消息都会分发到所有绑定的队列上去。Fanout交换机没有 Routing Key 。&lt;strong&gt;它在三种类型的交换机中转发消息是最快的&lt;/strong&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Topic&lt;/strong&gt; ：Topic交换机通过模式匹配分配消息，将 Routing Key 和某个模式进行匹配。它只能识别两个 &lt;strong&gt;通配符&lt;/strong&gt; ：&lt;code&gt;#&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt; 。&lt;code&gt;# &lt;/code&gt;匹配0个或多个单词， &lt;code&gt;*&lt;/code&gt; 匹配1个单词。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TTL（Time To Live）：生存时间。RabbitMQ支持消息的过期时间，一共2种。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;在消息发送时进行指定&lt;/strong&gt; 。通过配置消息体的 Properties ，可以指定当前消息的过期时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;在创建Exchange时指定&lt;/strong&gt; 。从进入消息队列开始计算，只要超过了队列的超时时间配置，那么消息会自动清除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者的消息确认机制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Confirm机制：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;消息的确认，是指生产者投递消息后，如果Broker收到消息，则会给我们生产者一个应答。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者进行接受应答，用来确认这条消息是否正常的发送到了Broker，这种方式也是 &lt;strong&gt;消息的可靠性投递的核心保障！&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.521875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLKs0EmmEnHpia5CaQnT6fnmbZzJg83BYHxBiafZJszrkpVNq9JA5G4dAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;在channel上开启确认模式&lt;/strong&gt; ：&lt;code&gt;channel.confirmSelect()&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;在channel上开启监听&lt;/strong&gt; ：addConfirmListener ，监听成功和失败的处理结果，根据具体的结果对消息进行重新发送或记录日志处理等后续操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Return Listener &lt;strong&gt;用于处理一些不可路由的消息&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的消息生产者，通过指定一个Exchange和Routing，把消息送达到某一个队列中去，然后我们的消费者监听队列进行消息的消费处理操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在某些情况下，如果我们在发送消息的时候，当前的exchange不存在或者指定的路由key路由不到，这个时候我们需要监听这种不可达消息，就需要使用到&lt;code&gt;Returrn Listener&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础API中有个关键的配置项 Mandatory ：如果为true，监听器会收到路由不可达的消息，然后进行处理。如果为false，broker端会自动删除该消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，通过监听的方式， &lt;code&gt;chennel.addReturnListener(ReturnListener rl)&lt;/code&gt; 传入已经重写过handleReturn方法的ReturnListener。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费端进行消费的时候，如果由于业务异常可以进行日志的记录，然后进行补偿。但是对于服务器宕机等严重问题，我们需要 &lt;strong&gt;手动ACK&lt;/strong&gt; 保障消费端消费成功。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// deliveryTag：消息在mq中的唯一标识  &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;// multiple：是否批量(和qos设置类似的参数)  &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;// requeue：是否需要重回队列。或者丢弃或者重回队首再次消费。  &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;basicNack&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; deliveryTag, &lt;span&gt;boolean&lt;/span&gt; multiple, &lt;span&gt;boolean&lt;/span&gt; requeue)&lt;/span&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上代码，消息在 &lt;strong&gt;消费端重回队列&lt;/strong&gt; 是为了对没有成功处理消息，把消息重新返回到Broker。一般来说，实际应用中都会关闭重回队列（ &lt;strong&gt;避免进入死循环&lt;/strong&gt; ），也就是设置为false。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死信队列（DLX Dead-Letter-Exchange）：当消息在一个队列中变成死信之后，它会被重新推送到另一个队列，这个队列就是死信队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/ruoyi-vue-pro&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里巴巴双十一官方指定消息产品，支撑阿里巴巴集团所有的消息服务，历经十余年高可用与高可靠的严苛考验，是阿里巴巴交易链路的核心产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rocket：火箭的意思。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481481481482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWuAkCWgKdlRfCRt3D9tpaLTC9rTb4d37gHPDGCMhpFnQHXw5OIF94JdvDmSQ3IsI3ywSNv5ND6HA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他有以下核心概念：Broker 、 Topic 、 Tag 、 MessageQueue 、 NameServer 、 Group 、 Offset 、 Producer 以及 Consumer 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面来详细介绍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt; ：消息中转角色，负责 &lt;strong&gt;存储消息&lt;/strong&gt; ，转发消息。&lt;strong&gt;Broker&lt;/strong&gt; 是具体提供业务的服务器，单个Broker节点与所有的NameServer节点保持长连接及心跳，并会定时将 &lt;strong&gt;Topic&lt;/strong&gt; 信息注册到NameServer，顺带一提底层的通信和连接都是 &lt;strong&gt;基于Netty实现&lt;/strong&gt; 的。&lt;strong&gt;Broker&lt;/strong&gt; 负责消息存储，以Topic为纬度支持轻量级的队列，单机可以支撑上万队列规模，支持消息推拉模型。官网上有数据显示：具有 &lt;strong&gt;上亿级消息堆积能力&lt;/strong&gt; ，同时可 &lt;strong&gt;严格保证消息的有序性&lt;/strong&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Topic&lt;/strong&gt; ：主题！它是消息的第一级类型。比如一个电商系统可以分为：交易消息、物流消息等，一条消息必须有一个 Topic 。&lt;strong&gt;Topic&lt;/strong&gt; 与生产者和消费者的关系非常松散，一个 Topic 可以有0个、1个、多个生产者向其发送消息，一个生产者也可以同时向不同的 Topic 发送消息。一个 Topic 也可以被 0个、1个、多个消费者订阅。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Tag&lt;/strong&gt; ：标签！可以看作子主题，它是消息的第二级类型，用于为用户提供额外的灵活性。使用标签，同一业务模块不同目的的消息就可以用相同Topic而不同的 &lt;strong&gt;Tag&lt;/strong&gt; 来标识。比如交易消息又可以分为：交易创建消息、交易完成消息等，一条消息可以没有 &lt;strong&gt;Tag&lt;/strong&gt; 。标签有助于保持您的代码干净和连贯，并且还可以为 &lt;strong&gt;RocketMQ&lt;/strong&gt; 提供的查询系统提供帮助。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;MessageQueue&lt;/strong&gt; ：一个Topic下可以设置多个消息队列，发送消息时执行该消息的Topic，RocketMQ会轮询该Topic下的所有队列将消息发出去。消息的物理管理单位。一个Topic下可以有多个Queue，Queue的引入使得消息的存储可以分布式集群化，具有了水平扩展能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;NameServer&lt;/strong&gt; ：类似Kafka中的ZooKeeper，但NameServer集群之间是 &lt;strong&gt;没有通信&lt;/strong&gt; 的，相对ZK来说更加 &lt;strong&gt;轻量&lt;/strong&gt; 。它主要负责对于源数据的管理，包括了对于 &lt;strong&gt;Topic&lt;/strong&gt; 和路由信息的管理。每个Broker在启动的时候会到NameServer注册，Producer在发送消息前会根据Topic去NameServer &lt;strong&gt;获取对应Broker的路由信息&lt;/strong&gt; ，Consumer也会定时获取 Topic 的路由信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Producer&lt;/strong&gt; ：生产者，支持三种方式发送消息：&lt;strong&gt;同步、异步和单向&lt;/strong&gt; 单向发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应，且 &lt;strong&gt;没有回调函数&lt;/strong&gt; 。异步发送 ：消息发出去后，可以继续发送下一条消息或执行业务代码，不等待服务器回应， &lt;strong&gt;有回调函数&lt;/strong&gt; 。同步发送 ：消息发出去后，等待服务器响应成功或失败，才能继续后面的操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Consumer&lt;/strong&gt; ：消费者，支持 PUSH 和 PULL 两种消费模式，支持 &lt;strong&gt;集群消费&lt;/strong&gt; 和 &lt;strong&gt;广播消费&lt;/strong&gt; 集群消费 ：该模式下一个消费者集群共同消费一个主题的多个队列，一个队列只会被一个消费者消费，如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。广播消费 ：会发给消费者组中的每一个消费者进行消费。相当于 &lt;strong&gt;RabbitMQ&lt;/strong&gt; 的发布订阅模式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Group&lt;/strong&gt; ：分组，一个组可以订阅多个Topic。分为ProducerGroup，ConsumerGroup，代表某一类的生产者和消费者，一般来说同一个服务可以作为Group，同一个Group一般来说发送和消费的消息都是一样的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Offset&lt;/strong&gt; ：在RocketMQ中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用Offset来访问，Offset为Java Long类型，64位，理论上在 100年内不会溢出，所以认为是长度无限。也可以认为Message Queue是一个长度无限的数组， &lt;strong&gt;Offset&lt;/strong&gt; 就是下标。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开源版的RocketMQ不支持任意时间精度，仅支持特定的level，例如定时5s，10s，1min等。其中，level=0级表示不延时，level=1表示1级延时，level=2表示2级延时，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延时等级如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;messageDelayLevel=&lt;span&gt;1&lt;/span&gt;s &lt;span&gt;5&lt;/span&gt;s &lt;span&gt;10&lt;/span&gt;s &lt;span&gt;30&lt;/span&gt;s &lt;span&gt;1&lt;/span&gt;m &lt;span&gt;2&lt;/span&gt;m &lt;span&gt;3&lt;/span&gt;m &lt;span&gt;4&lt;/span&gt;m &lt;span&gt;5&lt;/span&gt;m &lt;span&gt;6&lt;/span&gt;m &lt;span&gt;7&lt;/span&gt;m &lt;span&gt;8&lt;/span&gt;m &lt;span&gt;9&lt;/span&gt;m &lt;span&gt;10&lt;/span&gt;m &lt;span&gt;20&lt;/span&gt;m &lt;span&gt;30&lt;/span&gt;m &lt;span&gt;1&lt;/span&gt;h &lt;span&gt;2&lt;/span&gt;h  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息有序指的是可以按照消息的发送顺序来消费（FIFO）。RocketMQ可以严格的保证消息有序，可以分为 分区有序 或者 全局有序 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3037037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWuAkCWgKdlRfCRt3D9tpaLv6Beygcxq36bRDS4MQkXUPWjRib7hvBHWWX0sWVEG7BydHI502akapw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列MQ提供类似X/Open XA的分布式事务功能，通过消息队列MQ事务消息能达到分布式事务的最终一致。上图说明了事务消息的大致流程：正常事务消息的发送和提交、事务消息的补偿流程。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发送half消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端响应消息写入结果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据本地事务状态执行Commit或Rollback（Commit操作生成消息索引，消息对消费者可见）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Producer收到回查消息，检查回查消息对应的本地事务的状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据本地事务状态，重新Commit或RollBack&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，补偿阶段用于解决消息Commit或Rollback发生超时或者失败的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务消息共有三种状态：提交状态、回滚状态、中间状态：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TransactionStatus.CommitTransaction&lt;/code&gt;：提交事务，它允许消费者消费此消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TransactionStatus.RollbackTransaction&lt;/code&gt;：回滚事务，它代表该消息将被删除，不允许被消费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;TransactionStatus.Unkonwn&lt;/code&gt;：中间状态，它代表需要检查消息队列来确定消息状态。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ是天生支持分布式的，可以配置主从以及水平扩展。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是 Producer只能和Master角色的Broker连接写入消息；Consumer可以连接 Master角色的Broker，也可以连接Slave角色的Broker来读取消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Consumer的配置文件中，并不需要设置是从Master读还是从Slave读，当Master不可用或者繁忙的时候，Consumer会被自动切换到从Slave读。有了自动切换Consumer这种机制，当一个Master角色的机器出现故障后，Consumer仍然可以从Slave读取消息，不影响Consumer程序。这就达到了消费端的高可用性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RocketMQ目前还不支持把Slave自动转成Master&lt;/strong&gt; ，如果机器资源不足，需要把Slave转成Master，则要手动停止Slave角色的Broker，更改配置文件，用新的配置文件启动Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建Topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同 brokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用后，其他组的Master仍然可用，Producer仍然可以发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从复制：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个Broker组有Master和Slave，消息需要从Master复制到Slave 上，有同步和异步两种复制方式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;同步复制&lt;/strong&gt; ：同步复制方式是等Master和Slave均写成功后才反馈给客户端写成功状态。如果Master出故障， Slave上有全部的备份数据，容易恢复同步复制会增大数据写入延迟，降低系统吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步复制&lt;/strong&gt; ：异步复制方式是只要Master写成功 即可反馈给客户端写成功状态。在异步复制方式下，系统拥有较低的延迟和较高的吞吐量，但是如果Master出了故障，有些数据因为没有被写 入Slave，有可能会丢失&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，应该把Master和Save配置成同步刷盘方式，主从之间配置成异步的复制方式，这样即使有一台机器出故障，仍然能保证数据不丢，是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer负载均衡：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer端，每个实例在发消息的时候，默认会 &lt;strong&gt;轮询&lt;/strong&gt; 所有的Message Queue发送，以达到让消息平均落在不同的Queue上。而由于Queue可以散落在不同的Broker，所以消息就发送到不同的Broker下，如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.462037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWuAkCWgKdlRfCRt3D9tpaLFdvOM0YQ9nfNNnhzbiaILAyia2w3lBPErJQdNlHyL1oQo0aD3FCTCk6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果Consumer实例的数量比Message Queue的总数量还多的话， &lt;strong&gt;多出来的Consumer实例将无法分到Queue&lt;/strong&gt; ，也就无法消费到消息，也就无法起到分摊负载的作用了。所以需要控制让Queue的总数量大于等于Consumer的数量。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;消费者的集群模式：启动多个消费者就可以保证消费者的负载均衡（均摊队列）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;默认使用的是均摊队列&lt;/strong&gt; ：会按照Queue的数量和实例的数量平均分配Queue给每个实例，这样每个消费者可以均摊消费的队列，如下图所示6个队列和三个生产者。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一种平均的算法 &lt;strong&gt;环状轮流分Queue&lt;/strong&gt; 的形式，每个消费者，均摊不同主节点的一个消息队列，如下图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于广播模式并不是负载均衡的，要求一条消息需要投递到一个消费组下面所有的消费者实例，所以也就没有消息被分摊消费的说法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一条消息消费失败，RocketMQ就会自动进行消息重试。而如果消息超过最大重试次数，RocketMQ就会认为这个消息有问题。但是此时，RocketMQ不会立刻将这个有问题的消息丢弃，而会将其发送到这个消费者组对应的一种特殊队列：死信队列。死信队列的名称是 %DLQ%+ConsumGroup 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死信队列具有以下特性：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;一个死信队列对应一个Group ID， 而不是对应单个消费者实例。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果一个Group ID未产生死信消息，消息队列RocketMQ不会为其创建相应的死信队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个死信队列包含了对应Group ID产生的所有死信消息，不论该消息属于哪个Topic。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Cloud Alibaba + Gateway + Nacos + RocketMQ + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目地址：https://gitee.com/zhijiantianya/yudao-cloud&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;视频教程：https://doc.iocoder.cn/video/&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka是一个分布式、支持分区的、多副本的， &lt;strong&gt;基于ZooKeeper&lt;/strong&gt; 协调的分布式消息系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于Hadoop的批处理系统、低延迟的实时系统、Storm/Spark流式处理引擎，Web/Nginx日志、访问日志，消息服务等等，用 &lt;strong&gt;Scala语言编写&lt;/strong&gt; 。属于Apache基金会的顶级开源项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一下Kafka的架构图 ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLVlricmialjZtVGBlcO85ntPDlKqYdccQBIfehZZIzs5CQT7xFvxPibkibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kafka中有几个核心概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt; ：消息中间件处理节点，一个Kafka节点就是一个Broker，一个或者多个Broker可以组成一个Kafka集群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Topic&lt;/strong&gt; ：Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Producer&lt;/strong&gt; ：消息生产者，向Broker发送消息的客户端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Consumer&lt;/strong&gt; ：消息消费者，从Broker读取消息的客户端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ConsumerGroup&lt;/strong&gt; ：每个Consumer属于一个特定的ConsumerGroup，一条消息可以被多个不同的ConsumerGroup消费，但是一个ConsumerGroup中只能有一个Consumer能够消费该消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Partition&lt;/strong&gt; ：物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Leader&lt;/strong&gt; ：每个Partition有多个副本，其中有且仅有一个作为Leader，Leader是负责数据读写的Partition。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Follower&lt;/strong&gt; ：Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，Leader会把这个Follower从 ISR列表 中删除，重新创建一个Follower。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Offset&lt;/strong&gt; ：偏移量。Kafka的存储文件都是按照offset.kafka来命名，用Offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个Topic，代表逻辑上的一个业务数据集，比如订单相关操作消息放入订单Topic，用户相关操作消息放入用户Topic，对于大型网站来说，后端数据都是海量的，订单消息很可能是非常巨量的，比如有几百个G甚至达到TB级别，如果把这么多数据都放在一台机器上可定会有容量限制问题，那么就可以在Topic内部划分多个Partition来分片存储数据，不同的Partition可以位于不同的机器上，相当于 &lt;strong&gt;分布式存储&lt;/strong&gt; 。每台机器上都运行一个Kafka的进程Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kafka集群中会有一个或者多个Broker，其中有一个Broker会被选举为控制器（Kafka Controller），可以理解为 Broker-Leader ，它负责管理整个 集群中所有分区和副本的状态。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Partition-Leader  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Controller选举机制&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kafka集群启动的时候，选举的过程是集群中每个Broker都会尝试在ZooKeeper上创建一个&lt;code&gt; /controller&lt;/code&gt;临时节点，ZooKeeper会保证有且仅有一个Broker能创建成功，这个Broker就会成为集群的总控器Controller。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当这个Controller角色的Broker宕机了，此时ZooKeeper临时节点会消失，集群里其他Broker会一直监听这个临时节 点，发现临时节点消失了，就竞争再次创建临时节点，就是我们上面说的选举机制，ZooKeeper又会保证有一个Broker成为新的Controller。具备控制器身份的Broker需要比其他普通的Broker多一份职责，具体细节如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监听Broker相关的变化&lt;/strong&gt; 。为ZooKeeper中的&lt;code&gt;/brokers/ids/&lt;/code&gt;节点添加&lt;code&gt;BrokerChangeListener&lt;/code&gt;，用来处理Broker增减的变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;监听Topic相关的变化&lt;/strong&gt; 。为ZooKeeper中的&lt;code&gt;/brokers/topics&lt;/code&gt;节点添加&lt;code&gt;TopicChangeListener&lt;/code&gt;，用来处理Topic增减的变化；为ZooKeeper中的&lt;code&gt;/admin/delete_topics&lt;/code&gt;节点添加&lt;code&gt;TopicDeletionListener&lt;/code&gt;，用来处理删除Topic的动作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从ZooKeeper中读取获取当前所有与Topic、Partition以及Broker有关的信息并进行相应的管理 。对于所有Topic所对应的ZooKeeper中的&lt;code&gt;/brokers/topics/&lt;/code&gt;节点添加&lt;code&gt;PartitionModificationsListener&lt;/code&gt;，用来监听Topic中的分区分配变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更新集群的元数据信息，同步到其他普通的Broker节点中&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Controller感知到分区Leader所在的Broker挂了，Controller会从ISR列表（参数 &lt;code&gt;unclean.leader.election.enable=false&lt;/code&gt;的前提下）里挑第一个Broker作为Leader（第一个Broker最先放进ISR列表，可能是同步数据最多的副本），如果参数&lt;code&gt;unclean.leader.election.enable&lt;/code&gt;为true，代表在ISR列表里所有副本都挂了的时候可以在ISR列表以外的副本中选Leader，这种设置，可以提高可用性，但是选出的新Leader有可能数据少很多。副本进入ISR列表有两个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;副本节点不能产生分区，必须能与ZooKeeper保持会话以及跟Leader副本网络连通&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;副本能复制Leader上的所有写操作，并且不能落后太多。（与Leader副本同步滞后的副本，是由&lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;配置决定的，超过这个时间都没有跟Leader同步过的一次的副本会被移出ISR列表）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Consumer会定期将自己消费分区的Offset提交给Kafka内部Topic：consumer_offsets，提交过去的时候，key是&lt;code&gt;consumerGroupId+topic+分区号&lt;/code&gt;，value就是当前Offset的值，Kafka会定期清理Topic里的消息，最后就保留最新的那条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;_consumer\_offsets&lt;/code&gt;可能会接收高并发的请求，Kafka默认给其分配50个分区（可以通过 &lt;code&gt;offsets.topic.num.partitions&lt;/code&gt;设置），这样可以通过加机器的方式抗大并发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rebalance就是说 如果消费组里的消费者数量有变化或消费的分区数有变化，Kafka会重新分配消费者与消费分区的关系 。比如consumer group中某个消费者挂了，此时会自动把分配给他的分区交给其他的消费者，如果他又重启了，那么又会把一些分区重新交还给他。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：Rebalance只针对subscribe这种不指定分区消费的情况，如果通过assign这种消费方式指定了分区，Kafka不会进行Rebalance。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下情况可能会触发消费者Rebalance：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;消费组里的Consumer增加或减少了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动态给Topic增加了分区&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费组订阅了更多的Topic&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Rebalance过程中，消费者无法从Kafka消费消息，这对Kafka的TPS会有影响，如果Kafka集群内节点较多，比如数百 个，那重平衡可能会耗时极多，所以应尽量避免在系统高峰期的重平衡发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有消费者加入消费组时，消费者、消费组及组协调器之间会经历以下几个阶段：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4546296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6mychickmupWuAkCWgKdlRfCRt3D9tpaLsOZ9J4oTKuDiaiakn2QEcWibTqpsjP3WbaOOZiaPrUZf2iaU1FsR43wB2NQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组协调器GroupCoordinator：每个consumer group都会选择一个Broker作为自己的组协调器coordinator，负责监控这个消费组里的所有消费者的心跳，以及判断是否宕机，然后开启消费者Rebalance。&lt;code&gt;consumer group&lt;/code&gt;中的每个consumer启动时会向Kafka集群中的某个节点发送&lt;code&gt;FindCoordinatorRequest&lt;/code&gt;请求来查找对应的组协调器&lt;code&gt;GroupCoordinator&lt;/code&gt;，并跟其建立网络连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组协调器选择方式：通过如下公式可以选出consumer消费的Offset要提交到&lt;code&gt;_consumer\_offsets&lt;/code&gt;的哪个分区，这个分区Leader对应的Broker就是这个&lt;code&gt;consumer group&lt;/code&gt;的coordinator公式：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;hash(consumer group id) % 对应主题的分区数&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在成功找到消费组所对应的&lt;code&gt;GroupCoordinator&lt;/code&gt;之后就进入加入消费组的阶段，在此阶段的消费者会向&lt;code&gt;GroupCoordinator&lt;/code&gt;发送&lt;code&gt;JoinGroupRequest&lt;/code&gt;请求，并处理响应。然后&lt;code&gt;GroupCoordinator&lt;/code&gt;从一个&lt;code&gt;consumer group&lt;/code&gt;中选择第一个加入group的consumer作为Leader（消费组协调器），把&lt;code&gt;consumer group&lt;/code&gt;情况发送给这个Leader，接着这个Leader会负责制定分区方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;consumer leader通过给GroupCoordinator发送SyncGroupRequest，接着GroupCoordinator就把分区方案下发给各个consumer，他们会根据指定分区的Leader Broker进行网络连接以及消息消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有三种Rebalance的策略：range 、 round-robin 、 sticky 。&lt;strong&gt;默认情况为range分配策略&lt;/strong&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设一个主题有10个分区（0-9），现在有三个consumer消费：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;range策略：&lt;/strong&gt; 按照分区序号排序分配 ，假设&lt;code&gt;n＝分区数／消费者数量 = 3&lt;/code&gt;， &lt;code&gt;m＝分区数%消费者数量 = 1&lt;/code&gt;，那么前 m 个消 费者每个分配 n+1 个分区，后面的（消费者数量－m ）个消费者每个分配 n 个分区。比如分区0~ 3给一个consumer，分区4~ 6给一个consumer，分区7~9给一个consumer。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;round-robin策略：&lt;/strong&gt; 轮询分配 ，比如分区0、3、6、9给一个consumer，分区1、4、7给一个consumer，分区2、5、 8给一个consumer&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;sticky策略：&lt;/strong&gt; 初始时分配策略与&lt;code&gt;round-robin&lt;/code&gt;类似，但是在rebalance的时候，需要保证如下两个原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;分区的分配要尽可能均匀 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分区的分配尽可能与上次分配的保持相同。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当两者发生冲突时，第一个目标优先于第二个目标 。这样可以最大程度维持原来的分区分配的策略。比如对于第一种range情况的分配，如果第三个consumer挂了，那么重新用sticky策略分配的结果如下：consumer1除了原有的0~ 3，会再分配一个7 consumer2除了原有的4~ 6，会再分配8和9。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;producer采用push模式将消息发布到broker，每条消息都被append到patition中，属于顺序写磁盘（ &lt;strong&gt;顺序写磁盘 比 随机写 效率要高，保障 kafka 吞吐率&lt;/strong&gt; ）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;producer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hash(key)%分区数  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8078125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLDLwkac1XribIazics42sU1GFlxGyUyCATUhQpy8hGVKtg4j31FibfRHyA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;producer先从ZooKeeper的 &quot;&lt;code&gt;/brokers/…/state&lt;/code&gt;&quot; 节点找到该partition的leader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;producer将消息发送给该leader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader将消息写入本地log&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;followers从leader pull消息，写入本地log后向leader发送ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后commit的offset）并向producer发送ACK&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HW俗称高水位 ，HighWatermark的缩写，取一个partition对应的ISR中最小的LEO（log-end-offset）作为HW， consumer最多只能消费到HW所在的位置。另外每个replica都有HW,leader和follower各自负责更新自己的HW的状 态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于leader新写入的消息，consumer不能立刻消费，leader会等待该消息被所有ISR中的replicas同步后更新HW， 此时消息才能被consumer消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就保证了如果leader所在的broker失效，该消息仍然可以从新选举的leader中获取。对于来自内部broker的读取请求，没有HW的限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka一个分区的消息数据对应存储在一个文件夹下，以topic名称+分区号命名，消息在分区内是分段存储的， 每个段的消息都存储在不一样的log文件里，Kafka规定了一个段位的log文件最大为1G，做这个限制目的是为了方便把log文件加载到内存去操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt; # 部分消息的offset索引文件，kafka每次往分区发&lt;span&gt;4&lt;/span&gt;K(可配置)消息就会记录一条当前消息的offset到index文件， &lt;br/&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt; # 如果要定位消息的offset会先在这个文件里快速定位，再去log文件里找具体消息 &lt;br/&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;00000000000000000000&lt;/span&gt;.index &lt;br/&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt; # 消息存储文件，主要存offset和消息体 &lt;br/&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;00000000000000000000&lt;/span&gt;.log &lt;br/&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt; # 消息的发送时间索引文件，kafka每次往分区发&lt;span&gt;4&lt;/span&gt;K(可配置)消息就会记录一条当前消息的发送时间戳与对应的offset到timeindex文件， &lt;br/&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt; # 如果需要按照时间来定位消息的offset，会先在这个文件里查找 &lt;br/&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;00000000000000000000&lt;/span&gt;.timeindex &lt;br/&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;00000000000005367851&lt;/span&gt;.index &lt;br/&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;00000000000005367851&lt;/span&gt;.log &lt;br/&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;00000000000005367851&lt;/span&gt;.timeindex &lt;br/&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;00000000000009936472&lt;/span&gt;.index &lt;br/&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;00000000000009936472&lt;/span&gt;.log &lt;br/&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;00000000000009936472&lt;/span&gt;.timeindex&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个9936472之类的数字，就是代表了这个日志段文件里包含的起始 Offset，也就说明这个分区里至少都写入了接近1000万条数据了。Kafka Broker有一个参数，&lt;code&gt;log.segment.bytes&lt;/code&gt;，限定了每个日志段文件的大小，最大就是1GB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做&lt;code&gt;log rolling&lt;/code&gt;，正在被写入的那个日志段文件，叫做&lt;code&gt;active log segment&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后附一张ZooKeeper节点数据图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.56875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLfLnczBLQJicOvHhopwrrez7GPvyNicrauepYBPb3JRPoJ83zHVNXOjicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt; ：一个Queue对应一个Consumer即可解决。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RocketMQ&lt;/strong&gt; &lt;strong&gt;hash&lt;/strong&gt; (key)%队列数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Kafka&lt;/strong&gt; ：&lt;strong&gt;hash&lt;/strong&gt; (key)%分区数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RabbitMQ&lt;/strong&gt; ：两种方案
死信队列 + TTL引入RabbitMQ的延迟插件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RocketMQ&lt;/strong&gt; ：天生支持延时消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Kafka&lt;/strong&gt; ：步骤如下&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;专门为要延迟的消息创建一个Topic新建一个消费者去消费这个Topic消息持久化再开一个线程定时去拉取持久化的消息，放入实际要消费的Topic实际消费的消费者从实际要消费的Topic拉取消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLNI95wZSDKuPhV22WR7zvUjyeXEsFSSN8mZmbSNBgDmYpqbQbJhwltw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Broker--&amp;gt;消费者：手动ACK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者--&amp;gt;Broker：两种方案&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库持久化：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;将业务订单数据和生成的Message进行持久化操作（一般情况下插入数据库，这里如果分库的话可能涉及到分布式事务）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将Message发送到Broker服务器中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过RabbitMQ的Confirm机制，在producer端，监听服务器是否ACK。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果ACK了，就将Message这条数据状态更新为已发送。如果失败，修改为失败状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式定时任务查询数据库3分钟（这个具体时间应该根据的时效性来定）之前的发送失败的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新发送消息，记录发送次数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果发送次数过多仍然失败，那么就需要人工排查之类的操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLP7ACYicuV9TGamfoYFyic6KQjFIric1pMUpAv7fY61B5adlKkGkTYyzYg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：能够保证消息百分百不丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：第一步会涉及到分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流程图中，颜色不同的代表不同的message&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.将业务订单持久化&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.发送一条Message到broker(称之为主Message)，再发送相同的一条到不同的队列或者交换机(这条称为确认Message)中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3.主Message由实际业务处理端消费后，生成一条响应Message。之前的确认Message由Message Service应用处理入库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4~6.实际业务处理端发送的确认Message由Message Service接收后，将原Message状态修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7.如果该条Message没有被确认，则通过rpc调用重新由producer进行全过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLI8AIhTgTDvicLVANdHNokb4WFwFnMUfJW0u7HWRiaYyljGf5qGdBKrzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：相对于持久化方案来说响应速度有所提升&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：系统复杂性有点高，万一两条消息都失败了，消息存在丢失情况，仍需Confirm机制做补偿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer在把Message发送Broker的过程中，因为网络问题等发生丢失，或者Message到了Broker，但是出了问题，没有保存下来。针对这个问题，RocketMQ对Producer发送消息设置了3种方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;同步发送  &lt;br/&gt;异步发送  &lt;br/&gt;单向发送  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker接收到Message暂存到内存，Consumer还没来得及消费，Broker挂掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 持久化 设置去解决：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;创建Queue的时候设置持久化，保证Broker持久化Queue的元数据，但是不会持久化Queue里面的消息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将Message的deliveryMode设置为2，可以将消息持久化到磁盘，这样只有Message支持化到磁盘之后才会发送通知Producer ack&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两步过后，即使Broker挂了，Producer肯定收不到ack的，就可以进行重发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer有消费到Message，但是内部出现问题，Message还没处理，Broker以为Consumer处理完了，只会把后续的消息发送。这时候，就要 关闭autoack，消息处理过后，进行手动ack , 多次消费失败的消息，会进入 死信队列 ，这时候需要人工干预。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置了 acks=all ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时一般是要求起码设置如下 4 个参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;replication.factor  &lt;br/&gt;min.insync.replicas  &lt;br/&gt;acks=all  &lt;br/&gt;retries=MAX  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要 关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 RocketMQ 为例，下面列出了消息重复的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一条消息已被成功发送到服务端并完成持久化，此时出现了网络闪断或者客户端宕机，导致服务端对客户端应答失败。如果此时生产者意识到消息发送失败并尝试再次发送消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息消费的场景下，消息已投递到消费者并完成业务处理，当客户端给服务端反馈应答的时候网络闪断。为了保证消息至少被消费一次，消息队列RocketMQ版的服务端将在网络恢复后再次尝试投递之前已被处理过的消息，消费者后续会收到两条内容相同并且Message ID也相同的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载均衡时消息重复（包括但不限于网络抖动、Broker重启以及消费者应用重启）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当消息队列RocketMQ版的Broker或客户端重启、扩容或缩容时，会触发Rebalance，此时消费者可能会收到重复消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，有什么解决方案呢？直接上图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLzYwicuqmVx0MB1T8ykP3SdZoh6W1JzoJPJP7ItPumHBMWTgAfz0VCKw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个问题，有几个点需要考虑：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何快速让积压的消息被消费掉？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;临时写一个消息分发的消费者，把积压队列里的消息均匀分发到N个队列中，同时一个队列对应一个消费者，相当于消费速度提高了N倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改前：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLrBWPFic1AExmxZJlW37cWP0GXhINPcW2rmV8JTSHMqI3QiaNo1XSbNGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6mychickmupWuAkCWgKdlRfCRt3D9tpaLOmwe3pMbmpFVHOqpnibqsonA3vx7wKHprITl4ib6bsic9VzImRgibvJzdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;积压时间太久，导致部分消息过期，怎么处理？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量重导。在业务不繁忙的时候，比如凌晨，提前准备好程序，把丢失的那批消息查出来，重新导入到MQ中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息大量积压，MQ磁盘被写满了，导致新消息进不来了，丢掉了大量消息，怎么处理？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个没办法。谁让【消息分发的消费者】写的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2ca033a1d09bc07bed05db1941a88d8</guid>
<title>丢弃掉那些BeanUtils工具类吧，MapStruct真香！！！</title>
<link>https://toutiao.io/k/6muqkam</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者 l Hollis&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源 l Hollis（ID：hollischuang）&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6rXsLrncBqzrqzaZMY3L9QQQLr2beXVha4MicumtStMbcghJUPIVwPlHALTGTkkmpGicPYQbQObXGWIZr9NvjAtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在前几天的文章《&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650137356&amp;amp;idx=1&amp;amp;sn=c1d3f57eb9ae9b535ed41560939a13b7&amp;amp;chksm=f36bfe2dc41c773b9086fa01735581616c438dba1619c0e8e26d429612739155d65c6b9ca120&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》中，我曾经对几款属性拷贝的工具类进行了对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后在评论区有些读者反馈说MapStruct才是真的香，于是我就抽时间了解了一下MapStruct。结果我发现，这真的是一个神仙框架，炒鸡香。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这一篇文章就来简单介绍下MapStruct的用法，并且再和其他几个工具类进行一下对比。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;为什么需要MapStruct ？&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，我们先说一下MapStruct这类框架适用于什么样的场景，为什么市面上会有这么多的类似的框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。很多人都对三层架构、四层架构等并不陌生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;甚至有人说：&lt;strong&gt;&quot;计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，如果不行，那就加两层。&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，随着软件架构分层越来越多，那么各个层次之间的数据模型就要面临着相互转换的问题，典型的就是我们可以在代码中见到各种O，如DO、DTO、VO等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般情况下，同样一个数据模型，我们在不同的层次要使用不同的数据模型。&lt;strong&gt;如在数据存储层，我们使用DO来抽象一个业务实体；在业务逻辑层，我们使用DTO来表示数据传输对象；到了展示层，我们又把对象封装成VO来与前端进行交互。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，数据的从前端透传到数据持久化层（从持久层透传到前端），就需要进行对象之间的互相转化，即在不同的对象模型之间进行映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常我们可以使用get/set等方式逐一进行字段映射操作，如：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;personDTO&lt;/span&gt;&lt;span&gt;.setName&lt;/span&gt;(&lt;span&gt;personDO&lt;/span&gt;&lt;span&gt;.getName&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;personDTO&lt;/span&gt;&lt;span&gt;.setAge&lt;/span&gt;(&lt;span&gt;personDO&lt;/span&gt;&lt;span&gt;.getAge&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;personDTO&lt;/span&gt;&lt;span&gt;.setSex&lt;/span&gt;(&lt;span&gt;personDO&lt;/span&gt;&lt;span&gt;.getSex&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;&lt;span&gt;personDTO&lt;/span&gt;&lt;span&gt;.setBirthday&lt;/span&gt;(&lt;span&gt;personDO&lt;/span&gt;&lt;span&gt;.getBirthday&lt;/span&gt;());&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;但是，编写这样的映射代码是一项冗长且容易出错的任务。MapStruct等类似的框架的目标是通过自动化的方式尽可能多地简化这项工作。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;MapStruct的使用&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;MapStruct（https://mapstruct.org/ ）是一种代码生成器，它极大地简化了基于&quot;约定优于配置&quot;方法的Java bean类型之间映射的实现。生成的映射代码使用纯方法调用，因此快速、类型安全且易于理解。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;约定优于配置，也称作按约定编程，是一种软&lt;/span&gt;&lt;span&gt;件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;假设我们有两个类需要进行互相转换，分别是PersonDO和PersonDTO，类定义如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonDO {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt; birthday;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; gender;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonDTO {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; userName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer age;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt; birthday;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Gender gender;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们演示下如何使用MapStruct进行bean映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想要使用MapStruct，首先需要依赖他的相关的jar包，使用maven依赖方式如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;org.mapstruct.version&lt;/span&gt;&amp;gt;&lt;/span&gt;1.3.1.Final&lt;span&gt;&amp;lt;/&lt;span&gt;org.mapstruct.version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;properties&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mapstruct&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mapstruct&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${org.mapstruct.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;...&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.8.1&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;source&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;span&gt;source&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!-- depending on your project --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;target&lt;/span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;span&gt;target&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!-- depending on your project --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;annotationProcessorPaths&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;&lt;span&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.mapstruct&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;mapstruct-processor&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                        &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${org.mapstruct.version}&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;/&lt;span&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                    &lt;span&gt;&amp;lt;!-- other annotation processors --&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;annotationProcessorPaths&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;因为MapStruct需要在编译器生成转换代码，所以需要在maven-compiler-plugin插件中配置上对mapstruct-processor的引用。这部分在后文会再次介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后，我们需要定义一个做映射的接口，主要代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;PersonConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.class);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mappings&lt;/span&gt;(&lt;span&gt;@Mapping&lt;/span&gt;(source = &lt;span&gt;&quot;name&quot;&lt;/span&gt;, target = &lt;span&gt;&quot;userName&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;PersonDTO &lt;span&gt;do2dto&lt;/span&gt;&lt;span&gt;(PersonDO person)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;使用注解&lt;/span&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;span&gt;定义一个Converter接口，在其中定义一个do2dto方法，方法的入参类型是PersonDO，出参类型是PersonDTO，这个方法就用于将PersonDO转成PersonDTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;测试代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;(&lt;span&gt;String[] args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    PersonDO personDO = &lt;span&gt;new&lt;/span&gt; PersonDO();&lt;br/&gt;&lt;br/&gt;    personDO.setName(&lt;span&gt;&quot;Hollis&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    personDO.setAge(&lt;span&gt;26&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    personDO.setBirthday(&lt;span&gt;new&lt;/span&gt; Date());&lt;br/&gt;&lt;br/&gt;    personDO.setId(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    personDO.setGender(Gender.MALE.name());&lt;br/&gt;&lt;br/&gt;    PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);&lt;br/&gt;&lt;br/&gt;    System.&lt;span&gt;out&lt;/span&gt;.println(personDTO);&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;PersonDTO{userName=&lt;span&gt;&#x27;Hollis&#x27;&lt;/span&gt;, age=26, birthday=Sat Aug 08 19:00:44 CST 2020, gender=MALE}&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;可以看到，我们使用MapStruct完美的将PersonDO转成了PersonDTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的代码可以看出，MapStruct的用法比较简单，主要依赖&lt;/span&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;span&gt;注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是我们知道，大多数情况下，我们需要互相转换的两个类之间的属性名称、类型等并不完全一致，还有些情况我们并不想直接做映射，那么该如何处理呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实MapStruct在这方面也是做的很好的。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;MapStruct处理字段映射&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先，可以明确的告诉大家，如果要转换的两个类中源对象属性与目标对象属性的类型和名字一致的时候，会自动映射对应属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，如果遇到特殊情况如何处理呢？&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;名字不一致如何映射&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;如上面的例子中，在PersonDO中用name表示用户名称，而在PersonDTO中使用userName表示用户名，那么如何进行参数映射呢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候就要使用&lt;/span&gt;&lt;span&gt;@Mapping&lt;/span&gt;&lt;span&gt;注解了，只需要在方法签名上，使用该注解，并指明需要转换的源对象的名字和目标对象的名字就可以了，如将name的值映射给userName，可以使用如下方式：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;@&lt;span&gt;Mapping&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt; = &lt;span&gt;&quot;name&quot;&lt;/span&gt;, target = &lt;span&gt;&quot;userName&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;可以自动映射的类型&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;除了名字不一致以外，还有一种特殊情况，那就是类型不一致，如上面的例子中，在PersonDO中用String类型表示用户性别，而在PersonDTO中使用一个Genter的枚举表示用户性别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这时候类型不一致，就需要涉及到互相转换的问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实，MapStruct会对部分类型自动做映射，不需要我们做额外配置，如例子中我们将String类型自动转成了枚举类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般情况下，对于以下情况可以做自动类型转换：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型及其他们对应的包装类型。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基本类型的包装类型和String类型之间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;String类型和枚举类型之间&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;自定义常量&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;如果我们在转换映射过程中，想要给一些属性定义一个固定的值，这个时候可以使用 constant&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;@&lt;span&gt;Mapping&lt;/span&gt;(&lt;span&gt;source&lt;/span&gt; = &lt;span&gt;&quot;name&quot;&lt;/span&gt;, constant = &lt;span&gt;&quot;hollis&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;类型不一致的如何映射&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;还是上面的例子，如果我们需要在Person这个对象中增加家庭住址这个属性，那么我们一般在PersonoDTO中会单独定义一个HomeAddress类来表示家庭住址，而在Person类中，我们一般使用String类型表示家庭住址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就需要在HomeAddress和String之间使用JSON进行互相转化，这种情况下，MapStruct也是可以支持的。&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonDO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String address;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonDTO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String userName;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; HomeAddress address;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;PersonConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.&lt;span&gt;class&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping(source = &lt;span&gt;&quot;userName&quot;&lt;/span&gt;, target = &lt;span&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping(target = &lt;span&gt;&quot;address&quot;&lt;/span&gt;,expression = &lt;span&gt;&quot;java(homeAddressToString(dto2do.getAddress()))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    PersonDO dto2do(PersonDTO dto2do);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt; String homeAddressToString(HomeAddress address){&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; JSON.toJSONString(address);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;我们只需要在PersonConverter中在定义一个方法（因为PersonConverter是一个接口，所以在JDK 1.8以后的版本中可以定义一个default方法），这个方法的作用就是将HomeAddress转换成String类型。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;default方法：&lt;/span&gt;&lt;span&gt;Java 8 引入的新的语言特性，用关键字default来标注，被default所标注的方法，需要提供实现，而子类可以选择实现或者不实现该方法&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;然后在dto2do方法上，通过以下注解方式即可实现类型的转换：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;@&lt;span&gt;Mapping&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt; = &lt;span&gt;&quot;address&quot;&lt;/span&gt;,expression = &lt;span&gt;&quot;java(homeAddressToString(dto2do.getAddress()))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;上面这种是自定义的类型转换，还有一些类型的转换是MapStruct本身就支持的，如String和Date之间的转换：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;@&lt;span&gt;Mapping&lt;/span&gt;(&lt;span&gt;target&lt;/span&gt; = &lt;span&gt;&quot;birthday&quot;&lt;/span&gt;,dateFormat = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;以上，简单介绍了一些常用的字段映射的方法，也是我自己在工作中经常遇到的几个场景，更多的情况大家可以查看官方的示例（https://github.com/mapstruct/mapstruct-examples）。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;MapStruct的性能&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;前面说了这么多MapStruct的用法，可以看出MapStruct的使用还是比较简单的，并且字段映射上面的功能很强大，那么他的性能到底怎么样呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;参考《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650137356&amp;amp;idx=1&amp;amp;sn=c1d3f57eb9ae9b535ed41560939a13b7&amp;amp;chksm=f36bfe2dc41c773b9086fa01735581616c438dba1619c0e8e26d429612739155d65c6b9ca120&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？&lt;/a&gt;》中的示例，我们对MapStruct进行性能测试。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分别执行1000、10000、100000、1000000次映射的耗时分别为：0ms、1ms、3ms、6ms。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到，&lt;strong&gt;MapStruct的耗时相比较于其他几款工具来说是非常短的&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么，为什么MapStruct的性能可以这么好呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，MapStruct和其他几类框架最大的区别就是：&lt;strong&gt;与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，可以提前将问题反馈出来，也使得开发人员可以彻底的错误检查。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还记得前面我们在引入MapStruct的依赖的时候，特别在maven-compiler-plugin中增加了mapstruct-processor的支持吗？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且我们在代码中使用了很多MapStruct提供的注解，这使得在编译期，MapStruct就可以直接生成bean映射的代码，相当于代替我们写了很多setter和getter。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如我们在代码中定义了以下一个Mapper：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;PersonConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter.&lt;span&gt;class&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping(source = &lt;span&gt;&quot;userName&quot;&lt;/span&gt;, target = &lt;span&gt;&quot;name&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping(target = &lt;span&gt;&quot;address&quot;&lt;/span&gt;,expression = &lt;span&gt;&quot;java(homeAddressToString(dto2do.getAddress()))&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping(target = &lt;span&gt;&quot;birthday&quot;&lt;/span&gt;,dateFormat = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    PersonDO dto2do(PersonDTO dto2do);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt; String homeAddressToString(HomeAddress address){&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; JSON.toJSONString(address);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;经过代码编译后，会自动生成一个PersonConverterImpl：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;@Generated&lt;/span&gt;(&lt;br/&gt;&lt;br/&gt;    value = &lt;span&gt;&quot;org.mapstruct.ap.MappingProcessor&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    date = &lt;span&gt;&quot;2020-08-09T12:58:41+0800&quot;&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    comments = &lt;span&gt;&quot;version: 1.3.1.Final, compiler: javac, environment: Java 1.8.0_181 (Oracle Corporation)&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PersonConverterImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;PersonConverter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; PersonDO &lt;span&gt;dto2do&lt;/span&gt;&lt;span&gt;(PersonDTO dto2do)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ( dto2do == &lt;span&gt;null&lt;/span&gt; ) {&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        PersonDO personDO = &lt;span&gt;new&lt;/span&gt; PersonDO();&lt;br/&gt;&lt;br/&gt;        personDO.setName( dto2do.getUserName() );&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ( dto2do.getAge() != &lt;span&gt;null&lt;/span&gt; ) {&lt;br/&gt;&lt;br/&gt;            personDO.setAge( dto2do.getAge() );&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ( dto2do.getGender() != &lt;span&gt;null&lt;/span&gt; ) {&lt;br/&gt;&lt;br/&gt;            personDO.setGender( dto2do.getGender().name() );&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        personDO.setAddress( homeAddressToString(dto2do.getAddress()) );&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; personDO;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在运行期，对于bean进行映射的时候，就会直接调用PersonConverterImpl的dto2do方法，这样就没有什么特殊的事情要做了，只是在内存中进行set和get就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，因为在编译期做了很多事情，所以MapStruct在运行期的性能会很好，并且还有一个好处，那就是可以把问题的暴露提前到编译期。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使得如果代码中字段映射有问题，那么应用就会无法编译，强制开发者要解决这个问题才行。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文介绍了一款Java中的字段映射工具类，MapStruct，他的用法比较简单，并且功能非常完善，可以应付各种情况的字段映射。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且因为他是编译期就会生成真正的映射代码，使得运行期的性能得到了大大的提升。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;强烈推荐，真的很香！！！&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3NTY2NDMwMQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iaPU220ia3N7QfHsbKk3mGa1lsrNh9kID5jJsopIGBnric9v4xKcFOv50y6N3A3CVRteuJ9tQI0IAIh37R3dpvGog/0?wx_fmt=png&quot; data-nickname=&quot;程序员田螺&quot; data-alias=&quot;&quot; data-signature=&quot;专注分享后端面试题，包括计算机网络、MySql数据库、Redis缓存、操作系统、Java后端、大厂面试真题等领域。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;转发至&lt;/span&gt;&lt;span&gt;朋友圈&lt;/span&gt;&lt;span&gt;，是对我最大的支持。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;点个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;在看 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;喜欢是一种感觉&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在看是一种支持&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;↘↘↘&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>51837b878b33487bee78b78c4afd97e0</guid>
<title>Prometheus+Grafana监控-基于docker-compose搭建</title>
<link>https://toutiao.io/k/e9a645c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content &quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;&lt;h3&gt;Prometheus&lt;/h3&gt;&lt;p&gt;Prometheus 是有 SoundCloud 开发的开源监控系统和时序数据库，基于 Go 语言开发。通过基于 HTTP 的 pull 方式采集时序数据，通过服务发现或静态配置去获取要采集的目标服务器，支持多节点工作，支持多种可视化图表及仪表盘。&lt;br/&gt;贴一下官方提供的架构图：&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371304&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;Pormetheus 几个主要模块有，Server，Exporters，Pushgateway，PromQL，Alertmanager，WebUI等，主要逻辑如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Prometheus server 定期从静态配置的 targets 或者服务发现的 targets 拉取数据。&lt;/li&gt;&lt;li&gt;当新拉取的数据大于配置内存缓存区时，Prometheus 会将数据持久化到磁盘（如果使用 remote storage 将持久化到云端）。&lt;/li&gt;&lt;li&gt;Prometheus 配置 rules，然后定时查询数据，当条件触发时，会将 alert 推送到配置的 Alertmanager。&lt;/li&gt;&lt;li&gt;Alertmanager 收到警告时，会根据配置，聚合、去重、降噪等操作，最后发送警告。&lt;/li&gt;&lt;li&gt;可以使用 API，Prometheus Console 或者 Grafana 查询和聚合数据。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;Grafana&lt;/h3&gt;&lt;p&gt;Grafana 是一个开源的度量分析及可视化套件。通过访问数据库（如InfluxDB、Prometheus），展示自定义图表。&lt;/p&gt;&lt;h3&gt;Exporter&lt;/h3&gt;&lt;p&gt;Exporter 是 Prometheus 推出的针对服务器状态监控的 Metrics 工具。目前开发中常见的组件都有对应的 exporter 可以直接使用。常见的有两大类，一种是社区提供的，包含数据库，消息队列，存储，HTTP服务，日志等，比如 node_exporter，mysqld_exporter等；还有一种是用户自定义的 exporter，可以基于官方提供的 Client Library 创建自己的 exporter 程序。&lt;br/&gt;每个 exporter 的一个实例被称为 target，Prometheus 通过轮询的方式定期从这些 target 中获取样本数据。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371305&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h3&gt;原理简介&lt;/h3&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371306&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h2&gt;安装数据收集器 node-exporter&lt;/h2&gt;&lt;h3&gt;安装 node-exporter&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;cd /opt
wget https://github.com/prometheus/node_exporter/releases/download/v1.4.0-rc.0/node_exporter-1.4.0-rc.0.linux-amd64.tar.gz
tar xvf node_exporter-1.4.0-rc.0.linux-amd64.tar.gz
mv node_exporter-1.4.0-rc.0.linux-amd64 node_exporter
mv node_exporter /usr/local/&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行如下命令测试 node-exporter 收集器启动情况，正常情况下会输出服务端口。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;/usr/local/node_exporter/node_exporter&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;添加到系统服务&lt;/h3&gt;&lt;p&gt;vim /etc/systemd/system/node_exporter.service&lt;br/&gt;添加如下内容&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;[Unit]
Description=mysqld_exporter
After=network.target
[Service]
ExecStart=/usr/local/node_exporter/node_exporter
Restart=on-failure
[Install]
WantedBy=multi-user.target&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;加载并重启服务&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;# 加载配置
systemctl daemon-reload
# 启动服务
systemctl restart node_exporter.service
# 查看服务状态
systemctl status node_exporter.service
# 配置开机启动
systemctl enable node_exporter.service&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;查看数据收集情况&lt;/h3&gt;&lt;p&gt;重新起一个终端，查看数据收集情况。也可以在浏览器中查看。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;curl http://127.0.0.1:9100/metrics&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;安装 prometheus 和 grafana&lt;/h2&gt;&lt;h3&gt;安装 docker&amp;amp;docker-compose&lt;/h3&gt;&lt;p&gt;本文介绍的安装方法是基于 docker-compose 的，所以需要先安装相关 docker 环境。相关方法可以见笔者的其他文章，本文中不做详细介绍。&lt;/p&gt;&lt;h3&gt;安装 prometheus 和 grafana&lt;/h3&gt;&lt;p&gt;可以直接 clone 这个项目来快速搭建：&lt;br/&gt;&lt;a href=&quot;https://link.segmentfault.com/?enc=8AsGmhWqmC3znIhWbhyCuQ%3D%3D.CrmAU8FBeJwmQ7qz%2FKXci5QdEY6w%2BZ1FZK9bZhrYTo2FdFRk%2BlBe72auRNdVVRr5rCaUvJSFOL7AeX1QYnin0vcoP72kQvVGvU9IegubYc4%3D&quot; rel=&quot;nofollow&quot;&gt;https://github.com/FX-Max/docker-install-everything/tree/master/prometheus&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;该项目是笔者弄的一个使用 docker-compose 搭建软件开发常见服务的项目，大家觉得有帮助，可以帮忙点个 star，感谢。&lt;/blockquote&gt;&lt;p&gt;根据实际情况，修改 prometheus.yml 文件中的内容，将ip修改为上面安装了 node-exporter 的服务器ip即可。&lt;br/&gt;然后在该目录下执行 &lt;code&gt;docker-compose up -d&lt;/code&gt;即可，&lt;code&gt;docker ps&lt;/code&gt;查看服务启动情况。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;CONTAINER ID   IMAGE              COMMAND                  CREATED        STATUS        PORTS                                      NAMES
6f360e9ab242   grafana/grafana    &quot;/run.sh&quot;                25 hours ago   Up 25 hours   0.0.0.0:3000-&amp;gt;3000/tcp, :::3000-&amp;gt;3000/tcp  grafana
97b92b65aca6   prom/prometheus    &quot;/bin/prometheus --c…&quot;   25 hours ago   Up 21 hours   0.0.0.0:9090-&amp;gt;9090/tcp, :::9090-&amp;gt;9090/tcp  prometheus
3f5906f07bf6   prom/pushgateway   &quot;/bin/pushgateway&quot;       25 hours ago   Up 25 hours   0.0.0.0:9091-&amp;gt;9091/tcp, :::9091-&amp;gt;9091/tcp  pushgateway
f556168c1b8b   prom/alertmanager  &quot;/bin/alertmanager -…&quot;   25 hours ago   Up 25 hours   0.0.0.0:9093-&amp;gt;9093/tcp, :::9093-&amp;gt;9093/tcp  alertmanager&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;docker-compose.yml 内容：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;version: &quot;3&quot;
services:
  prometheus:
    image: prom/prometheus
    container_name: prometheus
    user: root
#    restart: always
    ports:
      - &quot;9090:9090&quot;
    volumes:
      - ./conf/prometheus:/etc/prometheus
      - ./data/prometheus/prometheus_db:/prometheus 
    command:
      - &#x27;--config.file=/etc/prometheus/prometheus.yml&#x27;
      - &#x27;--storage.tsdb.path=/prometheus&#x27;
      - &#x27;--web.console.libraries=/usr/share/prometheus/console_libraries&#x27;
      - &#x27;--web.console.templates=/usr/share/prometheus/consoles&#x27;
    networks:
      - net-prometheus

  grafana:
    image: grafana/grafana
    container_name: grafana
    user: root
#    restart: always
    ports:
      - &quot;3000:3000&quot;
    volumes:
      #- ./conf/grafana:/etc/grafana
      - ./data/prometheus/grafana_data:/var/lib/grafana
    depends_on:  
      - prometheus
    networks:
      - net-prometheus

  pushgateway:
    image: prom/pushgateway
    container_name: pushgateway
    user: root
#    restart: always
    ports:
      - &quot;9091:9091&quot;
    volumes:
      - ./data/prometheus/pushgateway_data:/var/lib/pushgateway

  alertmanager:
    image: prom/alertmanager
    hostname: alertmanager
    container_name: alertmanager
    user: root
#    restart: always
    ports:
      - &quot;9093:9093&quot;
    volumes:
      - ./data/prometheus/alertmanager_data:/var/lib/alertmanager

networks:
  net-prometheus:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;prometheus.yml 内容：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;global:
  scrape_interval:     5s
  evaluation_interval: 5s

  external_labels:
      monitor: &#x27;dashboard&#x27;

alerting:
 alertmanagers:
 - static_configs:
    - targets:
        - &quot;alertmanager:9093&quot;

rule_files:
  #- &#x27;alert.rules&#x27;

scrape_configs:  
  - job_name: &#x27;prometheus&#x27;
    scrape_interval: 5s
    static_configs:
      - targets: [&#x27;prometheus:9090&#x27;]

  - job_name: node
    static_configs:
      - targets: [&#x27;192.168.0.103:9100&#x27;,&#x27;pushgateway:9091&#x27;]

  - job_name: &#x27;mysql-131&#x27;
    static_configs:
     - targets: [&#x27;192.168.0.131:9104&#x27;]
       labels:
          instance: mysql&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;查看 prometheus&lt;/h3&gt;&lt;p&gt;访问 &lt;code&gt;http://127.0.0.1:9090/targets&lt;/code&gt;，效果如下，上面我们通过 node_exporter 收集的节点状态是 up 状态。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371307&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h3&gt;配置 Grafana&lt;/h3&gt;&lt;p&gt;访问 &lt;code&gt;http://127.0.0.1:3000&lt;/code&gt;，登录 Grafana，默认的账号密码是 admin:admin，首次登录需要修改默认密码。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371308&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;按照如下添加 data sources，将 prometheus 添加到 data sources 中。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371309&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371310&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371311&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;添加 prometheus 服务地址，此处由于服务是基于 docker-compose 构建的，没有填写ip，直接填写服务名即可。&lt;/p&gt;&lt;h3&gt;添加监控模版&lt;/h3&gt;&lt;p&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371312&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;输入官方模版 id，1860，点击 load。然后按照下图选择确认即可。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371313&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;p&gt;导入成功后，会自动跳转到监控面板页面，如下图。&lt;br/&gt;&lt;img referrerpolicy=&quot;no-referrer&quot; src=&quot;/img/remote/1460000042371314&quot; alt=&quot;image.png&quot; title=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;&lt;h2&gt;结语&lt;/h2&gt;&lt;p&gt;本文简单介绍了 prometheus + grafana 服务搭建流程，初步跑通了整个服务。当然它还有很多功能，后续笔者会开新的文章来分享。&lt;/p&gt;&lt;h3&gt;参考文档&lt;/h3&gt;&lt;p&gt;官方模板库：&lt;a href=&quot;https://link.segmentfault.com/?enc=gm%2F3t2IDPShpFHlSeWnbjA%3D%3D.VVHRRkJwEUy198nBM9d4vxFjxMpTi6oG72B3hGLQtT5V%2FRvH%2FqfBBHPPcvhj3ofF&quot; rel=&quot;nofollow&quot;&gt;https://grafana.com/grafana/dashboards/&lt;/a&gt;&lt;br/&gt;node 模板：&lt;a href=&quot;https://link.segmentfault.com/?enc=h4EFpmiSlzHPcCs5qSa1EQ%3D%3D.FshN00W0iju9eqxLU6J6OJOs7Q8kTrGLc%2FZpSqhqO7%2B9Z0Pk7ZKHWU%2F2sPtrGReL&quot; rel=&quot;nofollow&quot;&gt;https://grafana.com/grafana/dashboards/1860&lt;/a&gt;&lt;br/&gt;MySQL 模板：&lt;a href=&quot;https://link.segmentfault.com/?enc=Z5lQUTzWSUJ8GXg7B2%2FyiQ%3D%3D.bcWW8B4Z4x3u8gHXH9ftc5fvYVY84vBcDXIagiOTT%2BZ2QJbmXv1BCbsCExnI%2FbLI&quot; rel=&quot;nofollow&quot;&gt;https://grafana.com/grafana/dashboards/7362&lt;/a&gt;&lt;br/&gt;docker 搭建 prometheus&amp;amp;grafana：&lt;a href=&quot;https://link.segmentfault.com/?enc=XssMLiZWnAeXHDxnXYagZg%3D%3D.Ur490jXwwpHA9gWnf0UJBKyeHNeZ1aU8j%2Bu8G1zvMnOa6WWpEF4wXkPf6hgfQKfr&quot; rel=&quot;nofollow&quot;&gt;https://blog.51cto.com/keep11/4261521&lt;/a&gt;&lt;/p&gt;&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ecbfd0c5194b4bc6f55a4e84ecc70399</guid>
<title>字典服务的设计与管理</title>
<link>https://toutiao.io/k/bq2ee4y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;&lt;blockquote&gt;&lt;p&gt;编码问题，谁不想避其锋芒；&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;&lt;span&gt;一、业务背景&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在搜索引擎的功能上，曾经遇到过这样一个问题，数据库中某个公司名称中存在特殊编码，尽管数据已经正常同步到索引中，但是系统中关键词始终也无法匹配到该公司；&lt;/p&gt;&lt;p&gt;然后在库中模糊匹配，将公司名称复制到搜索框中，这样就可以正常命中索引，那么问题也就很清楚了，这种数据&quot;隐身&quot;的情况，即看着是同一个字，但是实际上不是，通常由特殊编码引起的；&lt;/p&gt;&lt;p&gt;通过表单进行数据采集是常用的业务手段，但是如果表单存在多个任意输入的文本框，这样获取的数据在质量上可能存在很多欠缺，尤其针对一些核心字段，严谨的校验规则十分有必要；&lt;/p&gt;&lt;p&gt;如果站在数据层面来看，虽然获取多维度数据有利于全景识别，但是各个维度的值准确与否或质量高低才是关键，对于多数业务场景来说，只依赖数据实体的部分属性，更多还是在于数据维度的质量；&lt;/p&gt;&lt;p&gt;提高数据质量的手段中，最行之有效的方式就是尽可能对字段维度提供枚举值，将数据内容限制在约定的范围内，其次就是校验规则需要严谨，以此确保业务数据的高质量；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、字典服务&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在分布式系统架构中，比较常见的基础服务层通常有：调度、缓存、文件、消息、字典等，下面就来详细的聊聊字典服务的设计与业务协作的逻辑；首先看一看交互逻辑：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.34609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvB61VIVTptZic9k5ic21icL0hh0eTia9NgwzX8sm5bWxyiamrYLJPYqakEFJLq2SnaXJhEd51y71RBqDSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;在字典服务中，通常管理公共的常量与数据枚举值的维护；常规情况下，在业务表单加载的时候，从字典服务中读取各维度枚举值，在表单提交的时候，校验相关枚举字段，以此提高内容的质量；&lt;/p&gt;&lt;p&gt;在字典服务中提供的枚举值，根本目的是为了确保数据值的统一性，尽可能的避免同一个信息用两种方式描述，比如编程标签：&quot;JAVA&quot;与&quot;Java&quot;，虽然从程序角度可以规避识别，但实际上是可以避免的；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvB61VIVTptZic9k5ic21icL0hhdvPptgrrntSr7YHhgfjiab68EsBs82xiaR0diciaXImU5uCh1ZrLJYY6DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从字典服务常见的内容管理来看，通常包括：常量、状态描述、业务标识；行业、标签、地址、学校等数据码表；其最大的特点就是在系统中被全局复用和识别；&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、细节设计&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、维护方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;对于字典数据的维护，通常使用两种手段：枚举类管理，码表存储，参数表存储；如何选择对应的方式，更多是取决于数据的属性：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;枚举类：维护基本不会改变的字段，比如数据的常规状态描述；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;码表：通常数据具有层次或者级联关系，比如地址和行业中的多级联动；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;参数表：即时要求很高，例如字段枚举值的定义，需要动态实时管理；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.39375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvB61VIVTptZic9k5ic21icL0hhR8wpBObl94L1vibCOXZGVq9pqvg60wav9CFbicQAdWsIFT1EWXJYzB7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;不管使用那种方式管理字典数据，都需要增强业务语义的描述，这样在业务表单中通过相应标识读取对应枚举选项即可，并且拦截范围之外的提交动作；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、数据加载&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;字典数据的查询通常采用Cache-Aside缓存模式，即查询优先访问缓存数据，命中则返回数据；否则访问库表数据，获取数据后返回页面并同步缓存中；在控制中心做内容修改后也需要再次同步缓存；&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvB61VIVTptZic9k5ic21icL0hhVcAVq6L9q43gSl5TkJ58NcsjNfs2I7vWpPniaupMibbe6ibh8I2AHPibqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;字典服务虽然并不复杂的，但是系统访问却十分频繁，如果出现异常情况很容易对业务产生大规模的影响，既要考虑并发访问的流量，又要设计合理的查询降低加载时间，避免对流程产生有感知的影响；&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、数据修改&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;不管是采用字典方式加载枚举值，还是采用任意输入的方式，都会面对一个无法避开的问题，字段值在业务开发中不断优化，则需要对数据进行清洗，至于数据清洗的流程在之前有详细的总结过，这里不再赘述。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、数据意识&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;数据字典本身的逻辑比较简单，但是如果放在数据体系中，这是一种基础的意识，在数据中很容易出现同名但定义不同，或者定义相同但名称不同，这会给数据分析带来很多不必要的麻烦；&lt;/p&gt;&lt;p&gt;所以基于数据字典的方式，明确数据口径同时避免业务语义产生分歧，尤其对于汉语来说，&quot;意思&quot;到底是什么意思?&lt;/p&gt;&lt;h1&gt;&lt;span&gt;五、参考源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;编程文档：&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note&lt;br/&gt;&lt;br/&gt;应用仓库：&lt;br/&gt;https://gitee.com/cicadasmile/butte-flyer-parent&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mp-common-profile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBj3abVSgCmvm7FIYw55ficInd2se9ia6KSic0ma25AUvrmUtXUwXibjhHmCc7DUawfXBI30QuHBjDnzw/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累、总结、用心记录。&quot; data-from=&quot;0&quot; data-is_biz_ban=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;

          

          
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>